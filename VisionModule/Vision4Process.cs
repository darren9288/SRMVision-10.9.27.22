using System;
using System.Collections;
using System.Collections.Generic;
using System.Drawing;
using System.IO;
using System.Text;
using System.Threading;
using Common;
using ImageAcquisition;
using SharedMemory;
using VisionProcessing;
using System.Windows.Forms;
using IOMode;
using System.Runtime.InteropServices;
using Lighting;
using Microsoft.Win32;
using System.Linq;

namespace VisionModule
{
    public class Vision4Process
    {
        #region DllImport

#if (RTXDebug || RTXRelease)

        [DllImport("SRMRtx.dll", CharSet = CharSet.Auto)]
        public static extern bool SRMSingleLock([MarshalAs(UnmanagedType.LPStr)] string valueName);

        [DllImport("SRMRtx.dll", CharSet = CharSet.Auto)]
        public static extern void SRMSetEvent([MarshalAs(UnmanagedType.LPStr)] string eventName);

        [DllImport("SRMRtx.dll", CharSet = CharSet.Auto)]
        public static extern void SRMResetEvent([MarshalAs(UnmanagedType.LPStr)] string eventName);

#endif

        #endregion

        #region constant variables

        //private const int BUFFERSIZE = 20;

        #endregion

        #region enum
        public enum ResulType { Pass, FailPackageSize, FailPackageDefect, Timesout, NotReady };
        public enum TCPIPResulID
        {
            Fail = 0, /*FailMark = 1, FailPackage = 2,*/ FailPosition = 0/*3*/, FailNotSeatProper = 0/*4*///, FailCrack = 11, FailForeignMaterial = 12,
            //FailPackageDimension = 13, FailVoid = 14, FailChippedOffOrScractches = 15, FailCopper = 16, FailDiscolouration = 17, FailEmpty = 18,
            //FailNoMark = 19, Fail2DCodeNoFound = 20, Fail2DCodeVerification = 21
        };
        #endregion

        #region Member Variables
        private bool m_blnPocketPositionResult = false;
        private int m_intCounter = 0;
        List<IntPtr> m_arrBufferPointer = new List<IntPtr>();
        private bool m_blnCustomWantColor = false;
        private float m_fLeadPatternAngle = 0;
        private float m_fLeadPatternScore = 0;
        private float m_fCenterX, m_fCenterY;
        // Thread handle
        private readonly object m_objStopLock = new object();
        private bool m_blnAuto = false;
        private bool m_blnStopping = false;
        private bool m_blnPause = false;
        private bool m_blnPositionResult = true;
        private int m_intScenario = 0;
        private bool m_blnWantOrientTest = false;
        private bool m_blnWantMarkTest = false;
        private bool m_blnWantPocketPositionTest = false;
        private bool m_blnWantPackageTest = false;
        private bool m_blnWantPositioning = false;
        private bool m_blnWantLeadTest = false;
        private bool m_blnOrientDataUpdated1 = false;
        private bool m_blnOrientDataUpdated2 = false;
        private bool m_blnOrientGaugeUpdated1 = false;
        private bool m_blnOrientGaugeUpdated2 = false;
        private bool m_blnRotateImage1Updated = false;
        private bool m_blnRotateImage2Updated = false;
        private bool m_blnRotateImage3Updated = false;
        private bool m_blnRotateImage4Updated = false;
        private bool m_blnRotateImage5Updated = false;
        private bool m_blnRotateImage6Updated = false;
        private bool m_blnRotateImage7Updated = false;
        private bool m_blnRotateColorImage1Updated = false;
        private bool m_blnRotateColorImage2Updated = false;
        private bool m_blnRotateColorImage3Updated = false;
        private bool m_blnRotateColorImage4Updated = false;
        private bool m_blnRotateColorImage5Updated = false;
        private bool m_blnRotateColorImage6Updated = false;
        private bool m_blnRotateColorImage7Updated = false;
        private bool m_blnForceStopProduction = false;
        private bool m_blnLoadRejectImageListPath = false;
        private bool m_blnRollback = false;
        private bool m_blnCheckEmpty = false;
        private bool m_blnDefaultRetestON = false;
        private int m_intPassStartNode = 0;
        private int m_intFailStartNode = 0;
        private int m_intPassEndNode = 0;
        private int m_intFailEndNode = 0;
        private int m_intFileIndex = 0;

        private float m_fOrientFinalAngleForLead = 0;

        private int m_intGrabRequire = 0;
        private int m_intCurrentGrabRequire = 1;
        private double m_dRedRatioPrev = 2.309997559;
        private double m_dBlueRatioPrev = 2.539978027;
        private uint m_intCameraGainPrev = 1;
        private float m_fCameraShuttlePrev = 1f;
        private int m_intCameraOutState = 1;
        private int m_intRetryCount = 0;
        List<bool> m_arrFinalPreciseAnglePass = new List<bool>();
        private List<CImageDrawing> m_arrColorImage_ForInspection = new List<CImageDrawing>();
        private ImageDrawing m_objPkgViewImage = new ImageDrawing(true);
        private ImageDrawing m_objPkgViewImage_DarkField2 = new ImageDrawing(true);
        private ImageDrawing m_objPkgViewImage_DarkField3 = new ImageDrawing(true);
        private ImageDrawing m_objPkgViewImage_DarkField4 = new ImageDrawing(true);
        private ImageDrawing m_objPkgViewImage2 = new ImageDrawing(true);
        private ImageDrawing m_objVoidViewImage = new ImageDrawing(true);
        private ImageDrawing m_objMarkViewImage = new ImageDrawing(true);
        private ImageDrawing m_objCrackViewImage = new ImageDrawing(true);
        private ImageDrawing m_objChippedViewImage = new ImageDrawing(true);
        private ImageDrawing m_objMoldViewImage = new ImageDrawing(true);
        private ImageDrawing m_objOrientGainImage = new ImageDrawing(true);
        private ImageDrawing m_objPkgSizeGainImage = new ImageDrawing(true);
        private ImageDrawing m_objLeadImage = new ImageDrawing(true);
        private ImageDrawing m_objPreviousRotatedImage = new ImageDrawing(true);
        private ImageDrawing m_objMarkTestImage = new ImageDrawing(true); //use for mark 2D and dont care to prevent main image modifieds
        private ImageDrawing m_objGrayValueImage_SideLight = new ImageDrawing(true);
        private ImageDrawing m_objGrayValueImage_TopLight = new ImageDrawing(true);
        private ImageDrawing[] m_arrPassImage1Buffer = null;
        private ImageDrawing[] m_arrPassImage2Buffer = null;
        private ImageDrawing[] m_arrPassImage3Buffer = null;
        private ImageDrawing[] m_arrPassImage4Buffer = null;
        private ImageDrawing[] m_arrPassImage5Buffer = null;
        private ImageDrawing[] m_arrPassImage6Buffer = null;
        private ImageDrawing[] m_arrPassImage7Buffer = null;
        private ImageDrawing[] m_arrFailImage1Buffer = null;
        private ImageDrawing[] m_arrFailImage2Buffer = null;
        private ImageDrawing[] m_arrFailImage3Buffer = null;
        private ImageDrawing[] m_arrFailImage4Buffer = null;
        private ImageDrawing[] m_arrFailImage5Buffer = null;
        private ImageDrawing[] m_arrFailImage6Buffer = null;
        private ImageDrawing[] m_arrFailImage7Buffer = null;
        private CImageDrawing[] m_arrPassCImage1Buffer = null;
        private CImageDrawing[] m_arrPassCImage2Buffer = null;
        private CImageDrawing[] m_arrPassCImage3Buffer = null;
        private CImageDrawing[] m_arrPassCImage4Buffer = null;
        private CImageDrawing[] m_arrPassCImage5Buffer = null;
        private CImageDrawing[] m_arrPassCImage6Buffer = null;
        private CImageDrawing[] m_arrPassCImage7Buffer = null;
        private CImageDrawing[] m_arrFailCImage1Buffer = null;
        private CImageDrawing[] m_arrFailCImage2Buffer = null;
        private CImageDrawing[] m_arrFailCImage3Buffer = null;
        private CImageDrawing[] m_arrFailCImage4Buffer = null;
        private CImageDrawing[] m_arrFailCImage5Buffer = null;
        private CImageDrawing[] m_arrFailCImage6Buffer = null;
        private CImageDrawing[] m_arrFailCImage7Buffer = null;
        private RectGaugeM4L m_objGauge_PkgMarkView;
        private RectGaugeM4L m_objGauge_PkgSideView;
        private RectGaugeM4L m_objGauge_PkgTopView;
        private int[] m_arrPassNoBuffer = null;
        private int[] m_arrFailNoBuffer = null;
        private int[] m_arrOrientationBuffer = null;
        private int[] m_arrUnitNoBuffer = null;
        private int[] m_arrRetryCountBuffer = null;
        private string[] m_arrRejectNameBuffer = null;
        private string[] m_arrRejectMessageBuffer = null;
        private List<string> m_arrRejectImageListPath = new List<string>();
        private List<string> m_arrRejectImageErrorMessageListPath = new List<string>();
        private object m_objLock = new object();

        private string m_strErrorMsg = "";

        private bool m_blnStopped = false, m_blnStopped_GrabImage = false, m_blnStopped_TransferImage = false, m_blnStopped_WaitFrame = false, m_blnStopped_AfterInspect, m_blnStopped_SaveImage = false;
        private bool m_blnStopped_PositioningTest = false, m_blnStopped_EmptyTest = false, m_blnStopped_MarkTest = false, m_blnStopped_PackageTest_MarkLightView = false, m_blnStopped_PackageTest_SideLightView = false, m_blnStopped_PackageTest_TopLightView = false, m_blnStopped_LeadTest = false, m_blnStopped_PackageColorTest = false;
        private Thread m_thThread, m_thSubThread_GrabImage, m_thSubThread_TransferImage, m_thSubThread_WaitFrame, m_thSubThread_AfterInspect, m_thSubThread_SaveImage;
        private Thread m_thSubThread_PositioningTest, m_thSubThread_EmptyTest, m_thSubThread_MarkTest, m_thSubThread_PackageTest_MarkLightView, m_thSubThread_PackageTest_SideLightView, m_thSubThread_PackageTest_TopLightView, m_thSubThread_LeadTest, m_thSubThread_PackageColorTest;
        private VisionIO m_objVisionIO;
        private CustomOption m_smCustomizeInfo;
        private ProductionInfo m_smProductionInfo;
        private VisionInfo m_smVisionInfo;
        private AVTVimba m_objAVTFireGrab;
        private TeliCamera m_objTeliCamera;
        private VisionComThread m_smComThread;
        private TCPIPIO m_smTCPIPIO;
        private RS232 m_thCOMMPort;
        private ROI m_objMarkSearchROI = new ROI();
        private ROI m_objMarkTrainROI = new ROI();
        private ROI m_objMarkOcvSearchROI = new ROI();
        private Point m_pMarkTrainROIPoint_Unit2 = new Point(0, 0);
        private Size m_sMarkTrainROISize_Unit2 = new Size(0, 0);

        private List<ImageDrawing> m_arrRDImages = new List<ImageDrawing>();

        // Package
        private float m_fOrientGauge = 0.0f;

        // SitProper
        private float m_fObjectWidth = 0;
        private float m_fObjectHeight = 0;

        // Keep track Counter Status Variables
        private bool m_blnPassCounterAdded = false;
        private bool m_blnFailCounterAdded = false;
        private bool m_blnTotalCounterAdded = false;
        private int m_intContinueEndReTestCounter = 0;   // For AutoReplace Used Only

        // ---------------- Multitreading --------------------------------------

        private bool m_bSubTh1_GrabImage = false;
        private bool m_bSubTh1_TransferImage = false;
        private bool m_bSubTh1_WaitFrame = false;
        private bool m_bSubTh_PositioningTest = false;
        private bool m_bSubTh_EmptyTest = false;
        private bool m_bSubTh_MarkTest = false;
        private bool m_bSubTh_PackageTest_MarkLightView = false;
        private bool m_bSubTh_PackageTest_SideLightView = false;
        private bool m_bSubTh_PackageTest_TopLightView = false;
        private bool m_bSubTh_LeadTest = false;
        private bool m_bSubTh_PackageColorTest = false;
        private bool m_bSubTh_StartAfterInspect = false;
        private bool m_bSubTh_PositioningTest_Result = false;
        private bool m_bSubTh_EmptyTest_Result = false;
        private bool m_bSubTh_MarkTest_Result = false;
        private bool m_bSubTh_PackageTest_PackageSize_Result = false;
        private bool m_bSubTh_PackageTest_MarkLightView_Result = false;
        private bool m_bSubTh_PackageTest_SideLightView_Result = false;
        private bool m_bSubTh_PackageTest_TopLightView_Result = false;
        private bool m_bSubTh_LeadTest_Result = false;
        private bool m_bSubTh_PackageColorTest_Result = false;
        //Unit 2 test result
        private bool m_bSubTh_MarkTest_Result2 = false;
        private bool m_bSubTh_PackageTest_PackageSize_Result2 = false;
        private bool m_bSubTh_PackageTest_MarkLightView_Result2 = false;
        private bool m_bSubTh_PackageTest_SideLightView_Result2 = false;
        private bool m_bSubTh_PackageTest_TopLightView_Result2 = false;
        private bool m_bGrabImage1Done = false;
        private bool m_bGrabImage2Done = false;
        private bool m_bGrabImage3Done = false;
        private bool m_bGrabImage4Done = false;
        private bool m_bGrabImage5Done = false;
        private bool m_bGrabImage6Done = false;
        private bool m_bGrabImage7Done = false;
        private bool m_bGrabImage1Result = false;
        private bool m_bGrabImage2Result = false;
        private bool m_bGrabImage3Result = false;
        private bool m_bGrabImage4Result = false;
        private bool m_bGrabImage5Result = false;
        private bool m_bGrabImage6Result = false;
        private bool m_bGrabImage7Result = false;
        private bool m_bGrabImage1LoadDone = false;
        private bool m_bGrabImage2LoadDone = false;
        private bool m_bGrabImage3LoadDone = false;
        private bool m_bGrabImage4LoadDone = false;
        private bool m_bGrabImage5LoadDone = false;
        private bool m_bGrabImage6LoadDone = false;
        private bool m_bGrabImage7LoadDone = false;
        private bool m_bGrabImage1LoadResult = false;
        private bool m_bGrabImage2LoadResult = false;
        private bool m_bGrabImage3LoadResult = false;
        private bool m_bGrabImage4LoadResult = false;
        private bool m_bGrabImage5LoadResult = false;
        private bool m_bGrabImage6LoadResult = false;
        private bool m_bGrabImage7LoadResult = false;
        private bool m_bGrabImage1TriggerDone = false;
        private bool m_bGrabImage2TriggerDone = false;
        private bool m_bGrabImage3TriggerDone = false;
        private bool m_bGrabImage4TriggerDone = false;
        private bool m_bGrabImage5TriggerDone = false;
        private bool m_bGrabImage6TriggerDone = false;
        private bool m_bGrabImage7TriggerDone = false;
        private bool m_bGrabImage1TriggerResult = false;
        private bool m_bGrabImage2TriggerResult = false;
        private bool m_bGrabImage3TriggerResult = false;
        private bool m_bGrabImage4TriggerResult = false;
        private bool m_bGrabImage5TriggerResult = false;
        private bool m_bGrabImage6TriggerResult = false;
        private bool m_bGrabImage7TriggerResult = false;
        private bool m_bGrabImageFinalResult = false;
        private bool m_bMarkTestDone1 = false;
        private bool m_bMarkTestDone2 = false;
        private bool m_bPackageSizeTestDone1 = false;
        private bool m_bPackageSizeTestDone2 = false;
        private bool m_bPackageSizePreTestDone1 = false;
        private bool m_bPackageSizePreTestDone2 = false;
        private bool m_bPackageSizePreTestResult1 = false;
        private bool m_bPackageSizePreTestResult2 = false;
        private bool m_bLeadBaseCenterPointDone = false;
        private bool m_bLeadBaseCenterPointResult = false;
        private ResulType m_eInspectionResult_PositioningTest = ResulType.Pass;
        private ResulType m_eInspectionResult_EmptyTest = ResulType.Pass;
        private ResulType m_eInspectionResult_MarkTest = ResulType.Pass;
        private ResulType m_eInspectionResult_PackageTest_Size = ResulType.Pass;
        private ResulType m_eInspectionResult_PackageTest_MarkLightView = ResulType.Pass;
        private ResulType m_eInspectionResult_PackageTest_SideLightView = ResulType.Pass;
        private ResulType m_eInspectionResult_PackageTest_TopLightView = ResulType.Pass;
        private ResulType m_eInspectionResult_LeadTest = ResulType.Pass;
        private ResulType m_eInspectionResult_PackageColorTest = ResulType.Pass;
        private int m_intOrientAngle = 0;
        private int m_intTestCount = 0;

        private ROI m_objSubTh1_RotateROI = new ROI();
        private ROI m_objSubTh2_RotateROI = new ROI();
        private ROI m_objSubTh3_RotateROI = new ROI();

        private float m_fSubTh1_TotalRotateAngle = 0;
        private float m_fSubTh2_TotalRotateAngle = 0;
        private float m_fSubTh3_TotalRotateAngle = 0;

        private bool m_blnPreviouslyIsIPM = true;
        private int[] m_arrEmptyCameraIntensityPrev = { -1, -1, -1 };//Empty
        private float m_fEmptyCameraShuttlePrev = 1f;//Empty
        private uint m_uintEmptyCameraGainPrev = 1;//Empty


        //TCPIPIO
        private bool m_blnSentGrabDone = false;
        private int m_intTCPIPResultID = -1;
        private float m_fOffsetX = 0;
        private float m_fOffsetY = 0;
        private float m_fOffsetAngle = 0;
        private bool m_blnStartVision_In = false;
        private bool m_blnEndVision_Out = true;
        private bool m_blnGrabbing_Out = false;
        private bool m_blnCheckOffset_In = false;
        private bool m_blnInPocketCheckUnit1_In = false;
        private bool m_blnInPocketReTest_In = false;
        private bool m_blnInPocketReCheckUnit2_In = false;
        private bool m_blnInPocketEndOfReTest_In = false;
        private bool m_blnInPocketRollbackRetest_In = false;
        private bool m_blnInPocketCheckEmpty_In = false;
        private bool m_blnInPocketFailOffset_Out;
        private bool m_blnInPocketOffsetDone_Out;
        private bool m_blnRotatorSignal1_In = false;
        private bool m_blnRotatorSignal2_In = false;
        private bool m_blnPass1_Out = true;
        private bool m_blnPass2_Out = true;
        private bool m_blnOrientResult2_Out = false;
        private bool m_blnOrientResult1_Out = false;
        private bool m_blnUnitPresent_Out = true;
        private bool m_blnPackageFail_Out = false;        // Fail criteria: Package
        private bool m_blnEmptyUnit_Out = false;          // Fail criteria: Empty Unit           
        private bool m_blnWrongOrientation_Out = false;   // Fail criteria: Wrong Orientation
        private bool m_blnPositionReject_Out = false;     // Fail criteria: Position Reject
        private bool m_blnMarkFail_Out = false;           // Fail criteria: Mark
        private bool m_blnFailLead_Out = false;           // Fail criteria in Mark Orient : Trigger this IO when fail criteria is not mark
        private bool m_blnFailNoMark_Out = false;         // Fail criteria: no Mark
        private bool m_blnMarkData0_In = false;
        private bool m_blnMarkData1_In = false;
        private bool m_blnMarkData2_In = false;
        private bool m_blnMarkData3_In = false;
        private bool m_blnMarkData4_In = false;
        private bool m_blnMarkData5_In = false;

        #endregion

        //HiPerfTimer m_T1 = new HiPerfTimer();
        //string m_strTrack = "";
        //float m_fTimingPrev = 0;
        //float m_fTiming = 0;
        private int m_intLightControlModel = 1; // 0=LEDi, 1=VTControl
        private string m_strPocketPositionTrackingData = "";
        private string m_strTracking_StartPackageSizeTest = "";
        private List<float> m_arrDontCareLeadAreaStartX = new List<float>();
        private List<float> m_arrDontCareLeadAreaStartY = new List<float>();
        private List<float> m_arrDontCareLeadAreaEndX = new List<float>();
        private List<float> m_arrDontCareLeadAreaEndY = new List<float>();
        private List<int> m_arrDontCareLeadDirection = new List<int>();
        private bool ShowLiterationOnly = false;
        public Vision4Process(CustomOption objCustomOption, ProductionInfo smProductionInfo, VisionInfo objVisionInfo,
            AVTVimba objAVTFireGrab, VisionComThread smComThread, RS232 thCOMMPort, TCPIPIO smTCPIPIO)
        {
            m_smCustomizeInfo = objCustomOption;
            m_smProductionInfo = smProductionInfo;
            m_smVisionInfo = objVisionInfo;
            m_objAVTFireGrab = objAVTFireGrab;
            m_smComThread = smComThread;
            m_smTCPIPIO = smTCPIPIO;
            m_thCOMMPort = thCOMMPort;

            // 2019 09 12 - CCENG: Change to init this buffer during Init Camera.
            //if (m_smVisionInfo.g_blnViewColorImage)
            //{
            //    m_arrPassCImage1Buffer = new CImageDrawing[BUFFERSIZE];
            //    m_arrPassCImage2Buffer = new CImageDrawing[BUFFERSIZE];
            //    m_arrPassCImage3Buffer = new CImageDrawing[BUFFERSIZE];
            //    m_arrPassCImage4Buffer = new CImageDrawing[BUFFERSIZE];
            //    m_arrPassCImage5Buffer = new CImageDrawing[BUFFERSIZE];
            //    m_arrFailCImage1Buffer = new CImageDrawing[BUFFERSIZE];
            //    m_arrFailCImage2Buffer = new CImageDrawing[BUFFERSIZE];
            //    m_arrFailCImage3Buffer = new CImageDrawing[BUFFERSIZE];
            //    m_arrFailCImage4Buffer = new CImageDrawing[BUFFERSIZE];
            //    m_arrFailCImage5Buffer = new CImageDrawing[BUFFERSIZE];

            //    for (int i = 0; i < BUFFERSIZE; i++)
            //    {
            //        m_arrPassCImage1Buffer[i] = new CImageDrawing(true);
            //        m_arrPassCImage2Buffer[i] = new CImageDrawing(true);
            //        m_arrPassCImage3Buffer[i] = new CImageDrawing(true);
            //        m_arrPassCImage4Buffer[i] = new CImageDrawing(true);
            //        m_arrPassCImage5Buffer[i] = new CImageDrawing(true);
            //        m_arrFailCImage1Buffer[i] = new CImageDrawing(true);
            //        m_arrFailCImage2Buffer[i] = new CImageDrawing(true);
            //        m_arrFailCImage3Buffer[i] = new CImageDrawing(true);
            //        m_arrFailCImage4Buffer[i] = new CImageDrawing(true);
            //        m_arrFailCImage5Buffer[i] = new CImageDrawing(true);
            //    }
            //}
            //else
            //{
            //    m_arrPassImage1Buffer = new ImageDrawing[BUFFERSIZE];
            //    m_arrPassImage2Buffer = new ImageDrawing[BUFFERSIZE];
            //    m_arrPassImage3Buffer = new ImageDrawing[BUFFERSIZE];
            //    m_arrPassImage4Buffer = new ImageDrawing[BUFFERSIZE];
            //    m_arrPassImage5Buffer = new ImageDrawing[BUFFERSIZE];
            //    m_arrFailImage1Buffer = new ImageDrawing[BUFFERSIZE];
            //    m_arrFailImage2Buffer = new ImageDrawing[BUFFERSIZE];
            //    m_arrFailImage3Buffer = new ImageDrawing[BUFFERSIZE];
            //    m_arrFailImage4Buffer = new ImageDrawing[BUFFERSIZE];
            //    m_arrFailImage5Buffer = new ImageDrawing[BUFFERSIZE];

            //    for (int i = 0; i < BUFFERSIZE; i++)
            //    {
            //        m_arrPassImage1Buffer[i] = new ImageDrawing(true);
            //        m_arrPassImage2Buffer[i] = new ImageDrawing(true);
            //        m_arrPassImage3Buffer[i] = new ImageDrawing(true);
            //        m_arrPassImage4Buffer[i] = new ImageDrawing(true);
            //        m_arrPassImage5Buffer[i] = new ImageDrawing(true);
            //        m_arrFailImage1Buffer[i] = new ImageDrawing(true);
            //        m_arrFailImage2Buffer[i] = new ImageDrawing(true);
            //        m_arrFailImage3Buffer[i] = new ImageDrawing(true);
            //        m_arrFailImage4Buffer[i] = new ImageDrawing(true);
            //        m_arrFailImage5Buffer[i] = new ImageDrawing(true);
            //    }
            //}
            //m_arrPassNoBuffer = new int[BUFFERSIZE];
            //m_arrFailNoBuffer = new int[BUFFERSIZE];
            //m_arrOrientationBuffer = new int[BUFFERSIZE];
            //m_arrUnitNoBuffer = new int[BUFFERSIZE];
            //m_arrRetryCountBuffer = new int[BUFFERSIZE];
            //m_arrRejectNameBuffer = new string[BUFFERSIZE];

            if ((m_smCustomizeInfo.g_intUseColorCamera & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
            {
                m_blnCustomWantColor = true;
            }

            if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                m_smTCPIPIO.ReceiveCommandEvent += new TCPIPIO.ReceiveCommandHandle(TakeAction_TCPIPIO);
            else
                m_smComThread.ReceiveCommandEvent += new VisionComThread.ReceiveCommandHandle(TakeAction);

            //create vision io object
            m_objVisionIO = new VisionIO(m_smVisionInfo.g_strVisionName, m_smVisionInfo.g_strVisionDisplayName,
                                         m_smVisionInfo.g_intVisionIndex, m_smVisionInfo.g_intVisionSameCount,
                                         m_smVisionInfo.g_strVisionNameRemark, 0);

            m_arrRDImages.Add(new ImageDrawing(true));
            m_arrRDImages.Add(new ImageDrawing(true));
            m_arrRDImages.Add(new ImageDrawing(true));

            //List<string> arrThreadNameBF = new List<string>();
            //List<string> arrThreadNameAF = new List<string>();
            //arrThreadNameBF = ProcessTh.GetThreadsName("SRMVision");

            m_thThread = new Thread(new ThreadStart(UpdateProgress));
            m_thThread.IsBackground = true;
            m_thThread.Priority = ThreadPriority.Highest;
            m_thThread.Start();

            m_thSubThread_GrabImage = new Thread(new ThreadStart(UpdateSubProgress_GrabImage));
            m_thSubThread_GrabImage.IsBackground = true;
            m_thSubThread_GrabImage.Priority = ThreadPriority.Highest;
            m_thSubThread_GrabImage.Start();

            if (m_blnCustomWantColor || m_smVisionInfo.g_intGrabMode == 2)
            {
                m_thSubThread_TransferImage = new Thread(new ThreadStart(UpdateSubProgress_TransferImage));
                m_thSubThread_TransferImage.IsBackground = true;
                m_thSubThread_TransferImage.Priority = ThreadPriority.Highest;
                m_thSubThread_TransferImage.Start();

                m_thSubThread_WaitFrame = new Thread(new ThreadStart(UpdateSubProgress_WaitFrame));
                m_thSubThread_WaitFrame.IsBackground = true;
                m_thSubThread_WaitFrame.Priority = ThreadPriority.Highest;
                m_thSubThread_WaitFrame.Start();
            }
            else
            {
                m_blnStopped_TransferImage = true;
                m_blnStopped_WaitFrame = true;
            }

            m_thSubThread_SaveImage = new Thread(new ThreadStart(UpdateSubProgress_SaveImage));
            m_thSubThread_SaveImage.IsBackground = true;
            m_thSubThread_SaveImage.Priority = ThreadPriority.Lowest;
            m_thSubThread_SaveImage.Start();

            //if ((m_smCustomizeInfo.g_intWantPositioning & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
            //{
            //    m_thSubThread_PositioningTest = new Thread(new ThreadStart(UpdateSubProgress_PositioningTest));
            //    m_thSubThread_PositioningTest.IsBackground = true;
            //    m_thSubThread_PositioningTest.Priority = ThreadPriority.Highest;
            //    m_thSubThread_PositioningTest.Start();
            //}

            if ((m_smCustomizeInfo.g_intWantMark & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
            {
                m_thSubThread_MarkTest = new Thread(new ThreadStart(UpdateSubProgress_MarkTest));
                m_thSubThread_MarkTest.IsBackground = true;
                m_thSubThread_MarkTest.Priority = ThreadPriority.Highest;
                m_thSubThread_MarkTest.Start();
            }

            if ((m_smCustomizeInfo.g_intWantPackage & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
            {
                m_thSubThread_PackageTest_MarkLightView = new Thread(new ThreadStart(UpdateSubProgress_PackageTest_MarkLightView));
                m_thSubThread_PackageTest_MarkLightView.IsBackground = true;
                m_thSubThread_PackageTest_MarkLightView.Priority = ThreadPriority.Highest;
                m_thSubThread_PackageTest_MarkLightView.Start();

                m_thSubThread_PackageTest_SideLightView = new Thread(new ThreadStart(UpdateSubProgress_PackageTest_SideLightView));
                m_thSubThread_PackageTest_SideLightView.IsBackground = true;
                m_thSubThread_PackageTest_SideLightView.Priority = ThreadPriority.Highest;
                m_thSubThread_PackageTest_SideLightView.Start();

                m_thSubThread_PackageTest_TopLightView = new Thread(new ThreadStart(UpdateSubProgress_PackageTest_TopLightView));
                m_thSubThread_PackageTest_TopLightView.IsBackground = true;
                m_thSubThread_PackageTest_TopLightView.Priority = ThreadPriority.Highest;
                m_thSubThread_PackageTest_TopLightView.Start();
            }
            else
            {
                m_blnStopped_PackageTest_MarkLightView = true;
                m_blnStopped_PackageTest_SideLightView = true;
                m_blnStopped_PackageTest_TopLightView = true;
            }

            if ((m_smCustomizeInfo.g_intWantLead & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
            {
                m_thSubThread_LeadTest = new Thread(new ThreadStart(UpdateSubProgress_LeadTest));
                m_thSubThread_LeadTest.IsBackground = true;
                m_thSubThread_LeadTest.Priority = ThreadPriority.Highest;
                m_thSubThread_LeadTest.Start();
            }
            else
            {
                m_blnStopped_LeadTest = true;
            }

            if (m_blnCustomWantColor)
            {
                m_thSubThread_PackageColorTest = new Thread(new ThreadStart(UpdateSubProgress_PackageColorTest));
                m_thSubThread_PackageColorTest.IsBackground = true;
                m_thSubThread_PackageColorTest.Priority = ThreadPriority.Highest;
                m_thSubThread_PackageColorTest.Start();
            }
            else
            {
                m_blnStopped_PackageColorTest = true;
            }

            if (((m_smCustomizeInfo.g_intWantPackage & (1 << m_smVisionInfo.g_intVisionPos)) > 0) || ((m_smCustomizeInfo.g_intWantLead & (1 << m_smVisionInfo.g_intVisionPos)) > 0))
            {
                m_thSubThread_AfterInspect = new Thread(new ThreadStart(UpdateSubProgress_AfterInspect));
                m_thSubThread_AfterInspect.IsBackground = true;
                m_thSubThread_AfterInspect.Priority = ThreadPriority.Normal;
                m_thSubThread_AfterInspect.Start();
            }

            //Thread.Sleep(500);
            //arrThreadNameAF = ProcessTh.GetThreadsName("SRMVision");
            //ProcessTh.GetDifferentThreadsName(arrThreadNameAF, arrThreadNameBF, "V4a", 0x02);//0x08);
        }

        public Vision4Process(CustomOption objCustomOption, ProductionInfo smProductionInfo, VisionInfo objVisionInfo,
            TeliCamera objTeliCamera, VisionComThread smComThread, RS232 thCOMMPort, TCPIPIO smTCPIPIO)
        {
            m_smCustomizeInfo = objCustomOption;
            m_smProductionInfo = smProductionInfo;
            m_smVisionInfo = objVisionInfo;
            m_objTeliCamera = objTeliCamera;
            m_smComThread = smComThread;
            m_smTCPIPIO = smTCPIPIO;
            m_thCOMMPort = thCOMMPort;

            // 2019 09 12 - CCENG: Change to init this buffer during Init Camera.
            //if (m_smVisionInfo.g_blnViewColorImage)
            //{
            //    m_arrPassCImage1Buffer = new CImageDrawing[BUFFERSIZE];
            //    m_arrPassCImage2Buffer = new CImageDrawing[BUFFERSIZE];
            //    m_arrPassCImage3Buffer = new CImageDrawing[BUFFERSIZE];
            //    m_arrPassCImage4Buffer = new CImageDrawing[BUFFERSIZE];
            //    m_arrPassCImage5Buffer = new CImageDrawing[BUFFERSIZE];
            //    m_arrFailCImage1Buffer = new CImageDrawing[BUFFERSIZE];
            //    m_arrFailCImage2Buffer = new CImageDrawing[BUFFERSIZE];
            //    m_arrFailCImage3Buffer = new CImageDrawing[BUFFERSIZE];
            //    m_arrFailCImage4Buffer = new CImageDrawing[BUFFERSIZE];
            //    m_arrFailCImage5Buffer = new CImageDrawing[BUFFERSIZE];

            //    for (int i = 0; i < BUFFERSIZE; i++)
            //    {
            //        m_arrPassCImage1Buffer[i] = new CImageDrawing(true);
            //        m_arrPassCImage2Buffer[i] = new CImageDrawing(true);
            //        m_arrPassCImage3Buffer[i] = new CImageDrawing(true);
            //        m_arrPassCImage4Buffer[i] = new CImageDrawing(true);
            //        m_arrPassCImage5Buffer[i] = new CImageDrawing(true);
            //        m_arrFailCImage1Buffer[i] = new CImageDrawing(true);
            //        m_arrFailCImage2Buffer[i] = new CImageDrawing(true);
            //        m_arrFailCImage3Buffer[i] = new CImageDrawing(true);
            //        m_arrFailCImage4Buffer[i] = new CImageDrawing(true);
            //        m_arrFailCImage5Buffer[i] = new CImageDrawing(true);
            //    }
            //}
            //else
            //{
            //    m_arrPassImage1Buffer = new ImageDrawing[BUFFERSIZE];
            //    m_arrPassImage2Buffer = new ImageDrawing[BUFFERSIZE];
            //    m_arrPassImage3Buffer = new ImageDrawing[BUFFERSIZE];
            //    m_arrPassImage4Buffer = new ImageDrawing[BUFFERSIZE];
            //    m_arrPassImage5Buffer = new ImageDrawing[BUFFERSIZE];
            //    m_arrFailImage1Buffer = new ImageDrawing[BUFFERSIZE];
            //    m_arrFailImage2Buffer = new ImageDrawing[BUFFERSIZE];
            //    m_arrFailImage3Buffer = new ImageDrawing[BUFFERSIZE];
            //    m_arrFailImage4Buffer = new ImageDrawing[BUFFERSIZE];
            //    m_arrFailImage5Buffer = new ImageDrawing[BUFFERSIZE];

            //    for (int i = 0; i < BUFFERSIZE; i++)
            //    {
            //        m_arrPassImage1Buffer[i] = new ImageDrawing(true);
            //        m_arrPassImage2Buffer[i] = new ImageDrawing(true);
            //        m_arrPassImage3Buffer[i] = new ImageDrawing(true);
            //        m_arrPassImage4Buffer[i] = new ImageDrawing(true);
            //        m_arrPassImage5Buffer[i] = new ImageDrawing(true);
            //        m_arrFailImage1Buffer[i] = new ImageDrawing(true);
            //        m_arrFailImage2Buffer[i] = new ImageDrawing(true);
            //        m_arrFailImage3Buffer[i] = new ImageDrawing(true);
            //        m_arrFailImage4Buffer[i] = new ImageDrawing(true);
            //        m_arrFailImage5Buffer[i] = new ImageDrawing(true);
            //    }
            //}
            //m_arrPassNoBuffer = new int[BUFFERSIZE];
            //m_arrFailNoBuffer = new int[BUFFERSIZE];
            //m_arrOrientationBuffer = new int[BUFFERSIZE];
            //m_arrUnitNoBuffer = new int[BUFFERSIZE];
            //m_arrRetryCountBuffer = new int[BUFFERSIZE];
            //m_arrRejectNameBuffer = new string[BUFFERSIZE];

            if ((m_smCustomizeInfo.g_intUseColorCamera & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
            {
                m_blnCustomWantColor = true;
            }

            if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                m_smTCPIPIO.ReceiveCommandEvent += new TCPIPIO.ReceiveCommandHandle(TakeAction_TCPIPIO);
            else
                m_smComThread.ReceiveCommandEvent += new VisionComThread.ReceiveCommandHandle(TakeAction);
            
            //create vision io object
            m_objVisionIO = new VisionIO(m_smVisionInfo.g_strVisionName, m_smVisionInfo.g_strVisionDisplayName,
                                         m_smVisionInfo.g_intVisionIndex, m_smVisionInfo.g_intVisionSameCount,
                                         m_smVisionInfo.g_strVisionNameRemark, 0);

            m_arrRDImages.Add(new ImageDrawing(true));
            m_arrRDImages.Add(new ImageDrawing(true));
            m_arrRDImages.Add(new ImageDrawing(true));

            //List<string> arrThreadNameBF = new List<string>();
            //List<string> arrThreadNameAF = new List<string>();
            //arrThreadNameBF = ProcessTh.GetThreadsName("SRMVision");

            m_thThread = new Thread(new ThreadStart(UpdateProgress));
            m_thThread.IsBackground = true;
            m_thThread.Priority = ThreadPriority.Highest;
            m_thThread.Start();

            m_thSubThread_GrabImage = new Thread(new ThreadStart(UpdateSubProgress_GrabImage));
            m_thSubThread_GrabImage.IsBackground = true;
            m_thSubThread_GrabImage.Priority = ThreadPriority.Highest;
            m_thSubThread_GrabImage.Start();

            if (m_blnCustomWantColor || m_smVisionInfo.g_intGrabMode == 2)
            {
                m_thSubThread_TransferImage = new Thread(new ThreadStart(UpdateSubProgress_TransferImage));
                m_thSubThread_TransferImage.IsBackground = true;
                m_thSubThread_TransferImage.Priority = ThreadPriority.Highest;
                m_thSubThread_TransferImage.Start();

                m_thSubThread_WaitFrame = new Thread(new ThreadStart(UpdateSubProgress_WaitFrame));
                m_thSubThread_WaitFrame.IsBackground = true;
                m_thSubThread_WaitFrame.Priority = ThreadPriority.Highest;
                m_thSubThread_WaitFrame.Start();
            }
            else
            {
                m_blnStopped_TransferImage = true;
                m_blnStopped_WaitFrame = true;
            }

            m_thSubThread_SaveImage = new Thread(new ThreadStart(UpdateSubProgress_SaveImage));
            m_thSubThread_SaveImage.IsBackground = true;
            m_thSubThread_SaveImage.Priority = ThreadPriority.Lowest;
            m_thSubThread_SaveImage.Start();

            //if ((m_smCustomizeInfo.g_intWantPositioning & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
            //{
            //    m_thSubThread_PositioningTest = new Thread(new ThreadStart(UpdateSubProgress_PositioningTest));
            //    m_thSubThread_PositioningTest.IsBackground = true;
            //    m_thSubThread_PositioningTest.Priority = ThreadPriority.Highest;
            //    m_thSubThread_PositioningTest.Start();
            //}

            if ((m_smCustomizeInfo.g_intWantMark & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
            {
                m_thSubThread_MarkTest = new Thread(new ThreadStart(UpdateSubProgress_MarkTest));
                m_thSubThread_MarkTest.IsBackground = true;
                m_thSubThread_MarkTest.Priority = ThreadPriority.Highest;
                m_thSubThread_MarkTest.Start();
            }

            if ((m_smCustomizeInfo.g_intWantPackage & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
            {
                m_thSubThread_PackageTest_MarkLightView = new Thread(new ThreadStart(UpdateSubProgress_PackageTest_MarkLightView));
                m_thSubThread_PackageTest_MarkLightView.IsBackground = true;
                m_thSubThread_PackageTest_MarkLightView.Priority = ThreadPriority.Highest;
                m_thSubThread_PackageTest_MarkLightView.Start();

                m_thSubThread_PackageTest_SideLightView = new Thread(new ThreadStart(UpdateSubProgress_PackageTest_SideLightView));
                m_thSubThread_PackageTest_SideLightView.IsBackground = true;
                m_thSubThread_PackageTest_SideLightView.Priority = ThreadPriority.Highest;
                m_thSubThread_PackageTest_SideLightView.Start();

                m_thSubThread_PackageTest_TopLightView = new Thread(new ThreadStart(UpdateSubProgress_PackageTest_TopLightView));
                m_thSubThread_PackageTest_TopLightView.IsBackground = true;
                m_thSubThread_PackageTest_TopLightView.Priority = ThreadPriority.Highest;
                m_thSubThread_PackageTest_TopLightView.Start();
            }
            else
            {
                m_blnStopped_PackageTest_MarkLightView = true;
                m_blnStopped_PackageTest_SideLightView = true;
                m_blnStopped_PackageTest_TopLightView = true;
            }

            if ((m_smCustomizeInfo.g_intWantLead & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
            {
                m_thSubThread_LeadTest = new Thread(new ThreadStart(UpdateSubProgress_LeadTest));
                m_thSubThread_LeadTest.IsBackground = true;
                m_thSubThread_LeadTest.Priority = ThreadPriority.Highest;
                m_thSubThread_LeadTest.Start();
            }
            else
            {
                m_blnStopped_LeadTest = true;
            }

            if (m_blnCustomWantColor)
            {
                m_thSubThread_PackageColorTest = new Thread(new ThreadStart(UpdateSubProgress_PackageColorTest));
                m_thSubThread_PackageColorTest.IsBackground = true;
                m_thSubThread_PackageColorTest.Priority = ThreadPriority.Highest;
                m_thSubThread_PackageColorTest.Start();
            }
            else
            {
                m_blnStopped_PackageColorTest = true;
            }

            if (((m_smCustomizeInfo.g_intWantPackage & (1 << m_smVisionInfo.g_intVisionPos)) > 0) || ((m_smCustomizeInfo.g_intWantLead & (1 << m_smVisionInfo.g_intVisionPos)) > 0))
            {
                m_thSubThread_AfterInspect = new Thread(new ThreadStart(UpdateSubProgress_AfterInspect));
                m_thSubThread_AfterInspect.IsBackground = true;
                m_thSubThread_AfterInspect.Priority = ThreadPriority.Normal;
                m_thSubThread_AfterInspect.Start();
            }

            //Thread.Sleep(500);
            //arrThreadNameAF = ProcessTh.GetThreadsName("SRMVision");
            //ProcessTh.GetDifferentThreadsName(arrThreadNameAF, arrThreadNameBF, "V4b", 0x02);//0x08);
        }
        public void LoadIPMLighting()
        {

            //Set to stop mode
            LEDi_Control.RunStop(m_smVisionInfo.g_arrLightSource[0].ref_intPortNo, 0, false);
            Thread.Sleep(10);
            for (int i = 0; i < m_intGrabRequire; i++)
            {
                int intValue1 = 0;
                int intValue2 = 0;
                int intValue3 = 0;
                int intValue4 = 0;

                for (int j = 0; j < m_smVisionInfo.g_arrLightSource.Count; j++)
                {
                    int intValueNo = 0;

                    // Due to some light source only ON for second image so its intensity value is at array no. 0.
                    // So we need to loop to find which array no. is for that image
                    for (int k = 0; k < m_smVisionInfo.g_arrLightSource[j].ref_arrValue.Count; k++)
                    {
                        // if this image no is in array k
                        if (m_smVisionInfo.g_arrLightSource[j].ref_arrImageNo != null)
                        {
                            if (m_smVisionInfo.g_arrLightSource[j].ref_arrImageNo[k] == i)
                            {
                                intValueNo = k;

                                switch (j)
                                {
                                    case 0:
                                        if ((m_smVisionInfo.g_arrLightSource[j].ref_intSeqNo & (0x01 << i)) > 0)
                                        {
                                            intValue1 = m_smVisionInfo.g_arrLightSource[j].ref_arrValue[intValueNo];
                                        }
                                        break;
                                    case 1:
                                        if ((m_smVisionInfo.g_arrLightSource[j].ref_intSeqNo & (0x01 << i)) > 0)
                                        {
                                            intValue2 = m_smVisionInfo.g_arrLightSource[j].ref_arrValue[intValueNo];
                                        }
                                        break;
                                    case 2:
                                        if ((m_smVisionInfo.g_arrLightSource[j].ref_intSeqNo & (0x01 << i)) > 0)
                                        {
                                            intValue3 = m_smVisionInfo.g_arrLightSource[j].ref_arrValue[intValueNo];
                                        }
                                        break;
                                    case 3:
                                        if ((m_smVisionInfo.g_arrLightSource[j].ref_intSeqNo & (0x01 << i)) > 0)
                                        {
                                            intValue4 = m_smVisionInfo.g_arrLightSource[j].ref_arrValue[intValueNo];
                                        }
                                        break;
                                }

                                break;
                            }
                        }
                    }
                }
                //Set all light source for sequence light controller for each grab
                LEDi_Control.SetSeqIntensity(m_smVisionInfo.g_arrLightSource[0].ref_intPortNo, 0, i, intValue1, intValue2, intValue3, intValue4);
                Thread.Sleep(10);
            }
            LEDi_Control.SaveIntensity(m_smVisionInfo.g_arrLightSource[0].ref_intPortNo, 0);
            Thread.Sleep(100);
            //Set to run mode
            LEDi_Control.RunStop(m_smVisionInfo.g_arrLightSource[0].ref_intPortNo, 0, true);
            Thread.Sleep(10);

        }
        public void LoadPocketPositionLighting()
        {

            //Set to stop mode
            LEDi_Control.RunStop(m_smVisionInfo.g_arrLightSource[0].ref_intPortNo, 0, false);
            Thread.Sleep(10);
            for (int i = 1; i < m_intGrabRequire; i++)
            {
                int intValue1 = 0;
                int intValue2 = 0;
                int intValue3 = 0;
                int intValue4 = 0;

                for (int j = 0; j < m_smVisionInfo.g_arrLightSource.Count; j++)
                {

                    switch (j)
                    {
                        case 0:
                            if ((m_smVisionInfo.g_arrLightSource[j].ref_intSeqNo & (0x01 << i)) > 0)
                            {
                                intValue1 = m_smVisionInfo.g_arrLightSource[j].ref_arrValue[m_smVisionInfo.g_objPocketPosition.GetGrabImageIndex(i-1)];
                            }
                            break;
                        case 1:
                            if ((m_smVisionInfo.g_arrLightSource[j].ref_intSeqNo & (0x01 << i)) > 0)
                            {
                                intValue2 = m_smVisionInfo.g_arrLightSource[j].ref_arrValue[m_smVisionInfo.g_objPocketPosition.GetGrabImageIndex(i - 1)];
                            }
                            break;
                        case 2:
                            if ((m_smVisionInfo.g_arrLightSource[j].ref_intSeqNo & (0x01 << i)) > 0)
                            {
                                intValue3 = m_smVisionInfo.g_arrLightSource[j].ref_arrValue[m_smVisionInfo.g_objPocketPosition.GetGrabImageIndex(i - 1)];
                            }
                            break;
                        case 3:
                            if ((m_smVisionInfo.g_arrLightSource[j].ref_intSeqNo & (0x01 << i)) > 0)
                            {
                                intValue4 = m_smVisionInfo.g_arrLightSource[j].ref_arrValue[m_smVisionInfo.g_objPocketPosition.GetGrabImageIndex(i - 1)];
                            }
                            break;
                    }

                }
                //Set all light source for sequence light controller for each grab
                LEDi_Control.SetSeqIntensity(m_smVisionInfo.g_arrLightSource[0].ref_intPortNo, 0, i, intValue1, intValue2, intValue3, intValue4);
                Thread.Sleep(10);
            }
            LEDi_Control.SaveIntensity(m_smVisionInfo.g_arrLightSource[0].ref_intPortNo, 0);
            Thread.Sleep(100);
            //Set to run mode
            LEDi_Control.RunStop(m_smVisionInfo.g_arrLightSource[0].ref_intPortNo, 0, true);
            Thread.Sleep(10);

        }
        public void LoadEmptyLighting()
        {

            //Set to stop mode
            LEDi_Control.RunStop(m_smVisionInfo.g_arrLightSource[0].ref_intPortNo, 0, false);
            Thread.Sleep(10);
            for (int i = 0; i < 1; i++)
            {
                int intValue1 = 0;
                int intValue2 = 0;
                int intValue3 = 0;
                int intValue4 = 0;

                for (int j = 0; j < m_smVisionInfo.g_arrLightSource.Count; j++)
                {

                    switch (j)
                    {
                        case 0:
                            if ((m_smVisionInfo.g_arrLightSource[j].ref_intSeqNo & (0x01 << i)) > 0)
                            {
                                intValue1 = m_smVisionInfo.g_arrLightSource[j].ref_EmptyValue;
                            }
                            break;
                        case 1:
                            if ((m_smVisionInfo.g_arrLightSource[j].ref_intSeqNo & (0x01 << i)) > 0)
                            {
                                intValue2 = m_smVisionInfo.g_arrLightSource[j].ref_EmptyValue;
                            }
                            break;
                        case 2:
                            if ((m_smVisionInfo.g_arrLightSource[j].ref_intSeqNo & (0x01 << i)) > 0)
                            {
                                intValue3 = m_smVisionInfo.g_arrLightSource[j].ref_EmptyValue;
                            }
                            break;
                        case 3:
                            if ((m_smVisionInfo.g_arrLightSource[j].ref_intSeqNo & (0x01 << i)) > 0)
                            {
                                intValue4 = m_smVisionInfo.g_arrLightSource[j].ref_EmptyValue;
                            }
                            break;
                    }

                }
                //Set all light source for sequence light controller for each grab
                LEDi_Control.SetSeqIntensity(m_smVisionInfo.g_arrLightSource[0].ref_intPortNo, 0, i, intValue1, intValue2, intValue3, intValue4);
                Thread.Sleep(10);
            }
            LEDi_Control.SaveIntensity(m_smVisionInfo.g_arrLightSource[0].ref_intPortNo, 0);
            Thread.Sleep(100);
            //Set to run mode
            LEDi_Control.RunStop(m_smVisionInfo.g_arrLightSource[0].ref_intPortNo, 0, true);
            Thread.Sleep(10);

        }
        private bool IsCameraInitDone()
        {
            switch (m_smVisionInfo.g_strCameraModel)
            {
                case "AVT":
                    return m_objAVTFireGrab.ref_blnCameraInitDone;
                    break;
                case "Teli":
                default:
                    return m_objTeliCamera.IsCameraInitDone();
                    break;
            }
        }
        public bool GrabImage(bool blnForInspection)
        {
            //m_smVisionInfo.g_objGrabTime.Reset();
            //m_smVisionInfo.g_objTransferTime.Reset();
            m_blnSentGrabDone = false;

            // 2021 06 27 - Blank image before new grab.
            if (m_smProductionInfo.g_blnBlankImageBeforeGrab)
            {
                if (!m_smProductionInfo.g_blnAllRunGrabWithoutUseImage && IsCameraInitDone())
                {
                    for (int i = 0; i < m_smVisionInfo.g_arrImages.Count; i++)
                    {
                        m_smVisionInfo.g_arrImages[i].SetImageToBlack();
                    }
                }
            }

            if (((m_smCustomizeInfo.g_blnWantUseTCPIPIO && m_blnInPocketCheckEmpty_In && blnForInspection) || (!m_smCustomizeInfo.g_blnWantUseTCPIPIO && m_objVisionIO.CheckEmpty.IsOn() && blnForInspection) || (!blnForInspection && m_smVisionInfo.g_blnViewEmptyImage)) && m_smVisionInfo.g_blnWantCheckEmpty)
            {
                if (m_blnPreviouslyIsIPM)
                {
                    LoadEmptyLighting();

                    if (m_smVisionInfo.g_blnWantCheckPocketPosition)
                        LoadPocketPositionLighting();
                }

                m_blnPreviouslyIsIPM = false;
                if (m_blnCustomWantColor)
                    return GrabImage_Sequence_SetIntensityForEmpty_Teli_LowLevelAPI(blnForInspection);
                else
                {
                    if (m_smVisionInfo.g_intGrabMode == 0)
                        return GrabImage_Sequence_SetIntensityForEmpty_Teli(blnForInspection);
                    else
                        return GrabImage_Sequence_SetIntensityForEmpty_Teli_LowLevelAPI(blnForInspection);
                }
            }
            else
            {

                if (!m_blnPreviouslyIsIPM)
                    LoadIPMLighting();
                m_blnPreviouslyIsIPM = true;
                if (m_smVisionInfo.g_intLightControllerType == 2)
                {
                    if (m_smVisionInfo.g_strCameraModel == "AVT")
                        return GrabImage_Sequence_GetFrameBeforeNextGrab_NoSetIntensity_AVTVimba(blnForInspection); //GrabImage_Sequence_NoSetIntensity_AVT(blnForInspection);
                    else if (m_smVisionInfo.g_strCameraModel == "Teli")
                    {
                        if (m_blnCustomWantColor)
                            return GrabImage_Sequence_NoSetIntensity_Teli_HighSpeedOrColor(blnForInspection);
                        else
                        {
                            if (m_smVisionInfo.g_intGrabMode == 0)
                                return GrabImage_Sequence_NoSetIntensity_Teli(blnForInspection);
                            else if (m_smVisionInfo.g_intGrabMode == 1)
                                return GrabImage_Sequence_NoSetIntensity_Teli_GrabAllFirst(blnForInspection);
                            else
                                return GrabImage_Sequence_NoSetIntensity_Teli_HighSpeedOrColor(blnForInspection);
                        }
                    }
                }

                if (m_smVisionInfo.g_strCameraModel == "Teli")
                {
                    return GrabImage_Teli(blnForInspection);
                }
                else
                {
                    return GrabImage_Normal_GetFrameBeforeNextGrab_NoSetIntensity_AVTVimba(blnForInspection);
                }

            }
        }
        public bool GrabImage_Sequence_SetIntensityForEmpty_Teli(bool blnForInspection)
        {
            if (!m_objTeliCamera.IsCameraInitDone())
            {
                m_bGrabImage1Result = m_bGrabImage2Result = m_bGrabImage3Result = m_bGrabImage4Result = m_bGrabImage5Result = m_bGrabImage6Result = m_bGrabImage7Result = true;
                m_bGrabImage1Done = m_bGrabImage2Done = m_bGrabImage3Done = m_bGrabImage4Done = m_bGrabImage5Done = m_bGrabImage6Done = m_bGrabImage7Done = true;
                m_smVisionInfo.g_strErrorMessage = "Camera No Connected";
                return true;
            }
            m_bGrabImage1Result = m_bGrabImage2Result = m_bGrabImage3Result = m_bGrabImage4Result = m_bGrabImage5Result = m_bGrabImage6Result = m_bGrabImage7Result = false;
            // Using Teli Camera
            m_smVisionInfo.g_objGrabTime.Start();

            Thread.Sleep(m_smVisionInfo.g_intCameraGrabDelay);

            bool blnSuccess = true;
            bool blnSeparateGrab = m_smVisionInfo.g_blnSeparateGrab;
            int intSelectedImage = m_smVisionInfo.g_intSelectedImage;

            for (int i = 0; i < m_intGrabRequire; i++) // 2 --> m_intGrabRequire 
            {
                if (blnSeparateGrab)
                {
                    if (i != intSelectedImage)
                        continue;
                }

                if (i > 0) // for second image and third image
                {
                    if (m_objTeliCamera.WaitFrameReady())
                    {
                        if (m_smVisionInfo.g_blnViewColorImage)
                        {
                            m_smVisionInfo.g_objMemoryColorImage.SetImageSize(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight);
                            m_smVisionInfo.g_objMemoryColorImage.LoadImageFromMemory(m_objTeliCamera.GetImagePointer());
                            m_smVisionInfo.g_objMemoryColorImage.CopyTo(ref m_smVisionInfo.g_arrColorImages, i - 1);
                        }
                        else
                        {
                            m_smVisionInfo.g_objMemoryImage.SetImageSize(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight);
                            m_smVisionInfo.g_objMemoryImage.LoadImageFromMemory(m_objTeliCamera.GetImagePointer());

                            if (m_smProductionInfo.g_blnAllRunGrabWithoutUseImage)
                            {
                                if (m_smVisionInfo.g_arrDebugImages.Count != m_smVisionInfo.g_arrImages.Count)
                                {
                                    for (int d = 0; d < m_smVisionInfo.g_arrImages.Count; d++)
                                    {
                                        m_smVisionInfo.g_arrDebugImages.Add(new ImageDrawing(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight));
                                    }
                                }

                                if (m_smVisionInfo.g_intRotateFlip == 1)
                                {
                                    ImageDrawing.Rotate0Degree_Diff(m_smVisionInfo.g_objMemoryImage, 180, ref m_smVisionInfo.g_arrDebugImages, i - 1);
                                    if (m_smVisionInfo.g_blnWantCheckPocketPosition)
                                        m_smVisionInfo.g_arrDebugImages[i - 1].AddGain(m_smVisionInfo.g_arrImageGain[m_smVisionInfo.g_objPocketPosition.GetGrabImageIndex(i - 1)]);
                                    else
                                        m_smVisionInfo.g_arrDebugImages[i - 1].AddGain(m_smVisionInfo.g_arrImageGain[i - 1]);
                                }
                                else
                                {
                                    m_smVisionInfo.g_objMemoryImage.CopyTo(ref m_smVisionInfo.g_arrDebugImages, i - 1);
                                    if (i > 1)
                                    {
                                        if (m_smVisionInfo.g_blnWantCheckPocketPosition)
                                            m_smVisionInfo.g_arrDebugImages[i - 1].AddGain(m_smVisionInfo.g_arrImageGain[m_smVisionInfo.g_objPocketPosition.GetGrabImageIndex(i - 1)]);
                                        else
                                            m_smVisionInfo.g_arrDebugImages[i - 1].AddGain(m_smVisionInfo.g_arrImageGain[i - 1]);
                                    }
                                    else
                                        m_smVisionInfo.g_arrDebugImages[i - 1].AddGain(m_smVisionInfo.g_fEmptyImageGain);
                                }
                            }
                            else
                            {
                                if (m_smVisionInfo.g_intRotateFlip == 1)
                                {
                                    ImageDrawing.Rotate0Degree_Diff(m_smVisionInfo.g_objMemoryImage, 180, ref m_smVisionInfo.g_arrImages, i - 1);
                                    if (i > 1)
                                    {
                                        if (m_smVisionInfo.g_blnWantCheckPocketPosition)
                                            m_smVisionInfo.g_arrImages[i - 1].AddGain(m_smVisionInfo.g_arrImageGain[m_smVisionInfo.g_objPocketPosition.GetGrabImageIndex(i - 1)]);
                                        else
                                            m_smVisionInfo.g_arrImages[i - 1].AddGain(m_smVisionInfo.g_arrImageGain[i - 1]);
                                    }
                                    else
                                        m_smVisionInfo.g_arrImages[i - 1].AddGain(m_smVisionInfo.g_fEmptyImageGain);
                                }
                                else
                                {
                                    m_smVisionInfo.g_objMemoryImage.CopyTo(ref m_smVisionInfo.g_arrImages, i - 1);
                                    if (i > 1)
                                    {
                                        if (m_smVisionInfo.g_blnWantCheckPocketPosition)
                                            m_smVisionInfo.g_arrImages[i - 1].AddGain(m_smVisionInfo.g_arrImageGain[m_smVisionInfo.g_objPocketPosition.GetGrabImageIndex(i - 1)]);
                                        else
                                            m_smVisionInfo.g_arrImages[i - 1].AddGain(m_smVisionInfo.g_arrImageGain[i - 1]);
                                    }
                                    else
                                        m_smVisionInfo.g_arrImages[i - 1].AddGain(m_smVisionInfo.g_fEmptyImageGain);
                                }
                            }
                        }

                    }
                    else
                    {
                        blnSuccess = false;
                        m_blnForceStopProduction = true;
                    }

                    if (i == 1)
                    {
                        if (blnSuccess) m_bGrabImage1Result = true;
                        m_bGrabImage1Done = true;
                    }
                    else if (i == 2)
                    {
                        if (blnSuccess) m_bGrabImage2Result = true;
                        m_bGrabImage2Done = true;
                    }
                    else if (i == 3)
                    {
                        if (blnSuccess) m_bGrabImage3Result = true;
                        m_bGrabImage3Done = true;
                    }
                    else if (i == 4)
                    {
                        if (blnSuccess) m_bGrabImage4Result = true;
                        m_bGrabImage4Done = true;
                    }
                    else if (i == 5)
                    {
                        if (blnSuccess) m_bGrabImage5Result = true;
                        m_bGrabImage5Done = true;
                    }
                    else if (i == 6)
                    {
                        if (blnSuccess) m_bGrabImage6Result = true;
                        m_bGrabImage6Done = true;
                    }
                    else if (i == 7)
                    {
                        if (blnSuccess) m_bGrabImage7Result = true;
                        m_bGrabImage7Done = true;
                    }
                }


                // Set light source channel ON/OFF

                if (i == 0)
                {
                    // Set camera gain
                    if (m_uintEmptyCameraGainPrev != m_smVisionInfo.g_uintEmptyCameraGain)
                    {
                        m_objTeliCamera.SetCameraParameter(2, m_smVisionInfo.g_uintEmptyCameraGain);
                        m_uintEmptyCameraGainPrev = m_smVisionInfo.g_uintEmptyCameraGain;
                        m_intCameraGainPrev = m_smVisionInfo.g_uintEmptyCameraGain;
                    }

                    // Set camera shuttle
                    if (m_fEmptyCameraShuttlePrev != m_smVisionInfo.g_fEmptyCameraShuttle)
                    {
                        m_objTeliCamera.SetCameraParameter(1, m_smVisionInfo.g_fEmptyCameraShuttle);
                        m_fEmptyCameraShuttlePrev = m_smVisionInfo.g_fEmptyCameraShuttle;
                        m_fCameraShuttlePrev = m_smVisionInfo.g_fEmptyCameraShuttle;
                    }
                }

                if (i > 0 && m_smVisionInfo.g_blnWantCheckPocketPosition)
                {
                    // Set camera gain
                    if (m_intCameraGainPrev != m_smVisionInfo.g_arrCameraGain[m_smVisionInfo.g_objPocketPosition.GetGrabImageIndex(i - 1)])
                    {
                        m_objTeliCamera.SetCameraParameter(2, m_smVisionInfo.g_arrCameraGain[m_smVisionInfo.g_objPocketPosition.GetGrabImageIndex(i - 1)]);
                        m_intCameraGainPrev = m_smVisionInfo.g_arrCameraGain[m_smVisionInfo.g_objPocketPosition.GetGrabImageIndex(i - 1)];
                        m_uintEmptyCameraGainPrev = m_smVisionInfo.g_arrCameraGain[m_smVisionInfo.g_objPocketPosition.GetGrabImageIndex(i - 1)];
                        //if (m_objTeliCamera.ref_intSetGainDelay != 0)
                        //    Thread.Sleep(m_objTeliCamera.ref_intSetGainDelay);
                    }

                    // Set camera shuttle
                    if (m_fCameraShuttlePrev != m_smVisionInfo.g_arrCameraShuttle[m_smVisionInfo.g_objPocketPosition.GetGrabImageIndex(i - 1)])
                    {
                        m_objTeliCamera.SetCameraParameter(1, m_smVisionInfo.g_arrCameraShuttle[m_smVisionInfo.g_objPocketPosition.GetGrabImageIndex(i - 1)]);
                        m_fCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[m_smVisionInfo.g_objPocketPosition.GetGrabImageIndex(i - 1)];
                        m_fEmptyCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[m_smVisionInfo.g_objPocketPosition.GetGrabImageIndex(i - 1)];
                        //if (m_objTeliCamera.ref_intSetGainDelay != 0)
                        //    Thread.Sleep(m_objTeliCamera.ref_intSetGainDelay);
                    }
                }

                if (blnSuccess)//2021-10-21 ZJYEOH : No need to grab anymore if not success, as this will reset the camera error message
                {
                    if (!m_objTeliCamera.Grab())
                    {
                        blnSuccess = false;
                        m_blnForceStopProduction = true;
                    }
                }
            }

            if (!m_objTeliCamera.WaitFrameReady())
            {
                blnSuccess = false;
                m_blnForceStopProduction = true;
            }

            if (blnSuccess)
            {
                SetGrabDone(blnForInspection);
                m_smVisionInfo.g_objTransferTime.Start();

                if (m_objTeliCamera.GetFrame(m_intGrabRequire - 1))
                {
                    if (m_objTeliCamera.ConvertFrame(m_intGrabRequire - 1))
                    {
                        if (m_smVisionInfo.g_blnViewColorImage)
                        {
                            m_smVisionInfo.g_objMemoryColorImage.SetImageSize(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight);
                            m_smVisionInfo.g_objMemoryColorImage.LoadImageFromMemory(m_objTeliCamera.GetImagePointer());
                            m_smVisionInfo.g_objMemoryColorImage.CopyTo(ref m_smVisionInfo.g_arrColorImages, m_intGrabRequire - 1);
                        }
                        else
                        {
                            m_smVisionInfo.g_objMemoryImage.SetImageSize(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight);
                            m_smVisionInfo.g_objMemoryImage.LoadImageFromMemory(m_objTeliCamera.GetImagePointer());

                            if (m_smProductionInfo.g_blnAllRunGrabWithoutUseImage)
                            {
                                if (m_smVisionInfo.g_arrDebugImages.Count != m_smVisionInfo.g_arrImages.Count)
                                {
                                    for (int d = 0; d < m_smVisionInfo.g_arrImages.Count; d++)
                                    {
                                        m_smVisionInfo.g_arrDebugImages.Add(new ImageDrawing(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight));
                                    }
                                }

                                if (m_smVisionInfo.g_intRotateFlip == 1)
                                {
                                    ImageDrawing.Rotate0Degree_Diff(m_smVisionInfo.g_objMemoryImage, 180, ref m_smVisionInfo.g_arrDebugImages, m_intGrabRequire - 1);
                                    if (m_intGrabRequire > 1)
                                    {
                                        if (m_smVisionInfo.g_blnWantCheckPocketPosition)
                                            m_smVisionInfo.g_arrDebugImages[m_intGrabRequire - 1].AddGain(m_smVisionInfo.g_arrImageGain[m_smVisionInfo.g_objPocketPosition.GetGrabImageIndex(m_intGrabRequire - 1)]);
                                        else
                                            m_smVisionInfo.g_arrDebugImages[m_intGrabRequire - 1].AddGain(m_smVisionInfo.g_arrImageGain[m_intGrabRequire - 1]);
                                    }
                                    else
                                        m_smVisionInfo.g_arrDebugImages[m_intGrabRequire - 1].AddGain(m_smVisionInfo.g_fEmptyImageGain);
                                }
                                else
                                {
                                    m_smVisionInfo.g_objMemoryImage.CopyTo(ref m_smVisionInfo.g_arrDebugImages, m_intGrabRequire - 1);
                                    if (m_intGrabRequire > 1)
                                    {
                                        if (m_smVisionInfo.g_blnWantCheckPocketPosition)
                                            m_smVisionInfo.g_arrDebugImages[m_intGrabRequire - 1].AddGain(m_smVisionInfo.g_arrImageGain[m_smVisionInfo.g_objPocketPosition.GetGrabImageIndex(m_intGrabRequire - 1)]);
                                        else
                                            m_smVisionInfo.g_arrDebugImages[m_intGrabRequire - 1].AddGain(m_smVisionInfo.g_arrImageGain[m_intGrabRequire - 1]);
                                    }
                                    else
                                        m_smVisionInfo.g_arrDebugImages[m_intGrabRequire - 1].AddGain(m_smVisionInfo.g_fEmptyImageGain);
                                }


                            }
                            else
                            {

                                if (m_smVisionInfo.g_intRotateFlip == 1)
                                {
                                    ImageDrawing.Rotate0Degree_Diff(m_smVisionInfo.g_objMemoryImage, 180, ref m_smVisionInfo.g_arrImages, m_intGrabRequire - 1);
                                    if (m_intGrabRequire > 1)
                                    {
                                        if (m_smVisionInfo.g_blnWantCheckPocketPosition)
                                            m_smVisionInfo.g_arrImages[m_intGrabRequire - 1].AddGain(m_smVisionInfo.g_arrImageGain[m_smVisionInfo.g_objPocketPosition.GetGrabImageIndex(m_intGrabRequire - 1)]);
                                        else
                                            m_smVisionInfo.g_arrImages[m_intGrabRequire - 1].AddGain(m_smVisionInfo.g_arrImageGain[m_intGrabRequire - 1]);
                                    }
                                    else
                                        m_smVisionInfo.g_arrImages[m_intGrabRequire - 1].AddGain(m_smVisionInfo.g_fEmptyImageGain);
                                }
                                else
                                {
                                    m_smVisionInfo.g_objMemoryImage.CopyTo(ref m_smVisionInfo.g_arrImages, m_intGrabRequire - 1);
                                    if (m_intGrabRequire > 1)
                                    {
                                        if (m_smVisionInfo.g_blnWantCheckPocketPosition)
                                            m_smVisionInfo.g_arrImages[m_intGrabRequire - 1].AddGain(m_smVisionInfo.g_arrImageGain[m_smVisionInfo.g_objPocketPosition.GetGrabImageIndex(m_intGrabRequire - 1)]);
                                        else
                                            m_smVisionInfo.g_arrImages[m_intGrabRequire - 1].AddGain(m_smVisionInfo.g_arrImageGain[m_intGrabRequire - 1]);
                                    }
                                    else
                                        m_smVisionInfo.g_arrImages[m_intGrabRequire - 1].AddGain(m_smVisionInfo.g_fEmptyImageGain);
                                }

                            }
                        }
                        if (m_intGrabRequire == 1)
                        {
                            if (blnSuccess) m_bGrabImage1Result = true;
                            m_bGrabImage1Done = true;
                        }
                        else if (m_intGrabRequire == 2)
                        {
                            if (blnSuccess) m_bGrabImage2Result = true;
                            m_bGrabImage2Done = true;
                        }
                        else if (m_intGrabRequire == 3)
                        {
                            if (blnSuccess) m_bGrabImage3Result = true;
                            m_bGrabImage3Done = true;
                        }
                        else if (m_intGrabRequire == 4)
                        {
                            if (blnSuccess) m_bGrabImage4Result = true;
                            m_bGrabImage4Done = true;
                        }
                        else if (m_intGrabRequire == 5)
                        {
                            if (blnSuccess) m_bGrabImage5Result = true;
                            m_bGrabImage5Done = true;
                        }
                        else if (m_intGrabRequire == 6)
                        {
                            if (blnSuccess) m_bGrabImage6Result = true;
                            m_bGrabImage6Done = true;
                        }
                        else if (m_intGrabRequire == 7)
                        {
                            if (blnSuccess) m_bGrabImage7Result = true;
                            m_bGrabImage7Done = true;
                        }
                    }
                }
            }
            else
                SetGrabDone(blnForInspection);

            m_bGrabImage1Done = m_bGrabImage2Done = m_bGrabImage3Done = m_bGrabImage4Done = m_bGrabImage5Done = m_bGrabImage6Done = m_bGrabImage7Done = true;

            //Reset outport
            if (!m_smCustomizeInfo.g_blnMixController)
            {
                if (m_smCustomizeInfo.g_blnLEDiControl)
                {
                    m_objTeliCamera.OutPort(1, 3);
                    Thread.Sleep(3);
                    m_objTeliCamera.OutPort(1, 0);
                }
                else if (m_smCustomizeInfo.g_blnVTControl)
                {
                    m_objTeliCamera.OutPort(1, 0);
                }
            }

            //2021-10-21 ZJYEOH : Set Image to Black if camera fail
            if (!blnSuccess)
            {
                for (int i = 0; i < m_smVisionInfo.g_arrImages.Count; i++)
                {
                    if (m_smVisionInfo.g_blnViewColorImage)
                    {
                        m_smVisionInfo.g_arrColorImages[i].SetImageToBlack();
                        m_smVisionInfo.g_arrColorRotatedImages[i].SetImageToBlack();
                    }
                    m_smVisionInfo.g_arrImages[i].SetImageToBlack();
                    m_smVisionInfo.g_arrRotatedImages[i].SetImageToBlack();
                }
            }

            if (m_objTeliCamera.GetErrorMessage() != "")
            {
                m_smVisionInfo.g_strErrorMessage = m_objTeliCamera.GetErrorMessage();
                m_smVisionInfo.ALL_VM_UpdatePictureBox = true;
                m_smVisionInfo.g_objTransferTime.Stop();

                return false;
            }
            else
            {
                // Set camera gain
                if (m_uintEmptyCameraGainPrev != m_smVisionInfo.g_uintEmptyCameraGain)
                {
                    m_objTeliCamera.SetCameraParameter(2, m_smVisionInfo.g_uintEmptyCameraGain);
                    m_uintEmptyCameraGainPrev = m_smVisionInfo.g_uintEmptyCameraGain;
                    m_intCameraGainPrev = m_smVisionInfo.g_uintEmptyCameraGain;
                }

                // Set camera shuttle
                if (m_fEmptyCameraShuttlePrev != m_smVisionInfo.g_fEmptyCameraShuttle)
                {
                    m_objTeliCamera.SetCameraParameter(1, m_smVisionInfo.g_fEmptyCameraShuttle);
                    m_fEmptyCameraShuttlePrev = m_smVisionInfo.g_fEmptyCameraShuttle;
                    m_fCameraShuttlePrev = m_smVisionInfo.g_fEmptyCameraShuttle;

                }

                if (m_smVisionInfo.g_bImageStatisticAnalysisON)
                {
                    m_smVisionInfo.g_bImageStatisticAnalysisUpdateInfo = true;

                    while (true)
                    {
                        if (!m_smVisionInfo.g_bImageStatisticAnalysisUpdateInfo)
                            break;

                        Thread.Sleep(1);
                    }
                }

                //AttachImageToROI();
                m_smVisionInfo.g_blnLoadFile = false;
                m_smVisionInfo.ALL_VM_UpdatePictureBox = true;
                m_smVisionInfo.g_objTransferTime.Stop();

                return true;
            }
        }
        public bool GrabImage_Sequence_SetIntensityForEmpty_Teli_LowLevelAPI(bool blnForInspection)
        {
            if (!m_objTeliCamera.IsCameraInitDone())
            {
                m_bGrabImage1Result = m_bGrabImage2Result = m_bGrabImage3Result = m_bGrabImage4Result = m_bGrabImage5Result = m_bGrabImage6Result = m_bGrabImage7Result = true;
                m_bGrabImage1Done = m_bGrabImage2Done = m_bGrabImage3Done = m_bGrabImage4Done = m_bGrabImage5Done = m_bGrabImage6Done = m_bGrabImage7Done = true;
                m_smVisionInfo.g_strErrorMessage = "Camera No Connected";
                return true;
            }
            m_bGrabImage1Result = m_bGrabImage2Result = m_bGrabImage3Result = m_bGrabImage4Result = m_bGrabImage5Result = m_bGrabImage6Result = m_bGrabImage7Result = false;
            // Using Teli Camera
            m_smVisionInfo.g_objGrabTime.Start();

            // Set camera gain
            if (m_uintEmptyCameraGainPrev != m_smVisionInfo.g_uintEmptyCameraGain)
            {
                m_objTeliCamera.SetCameraParameter(2, m_smVisionInfo.g_uintEmptyCameraGain);
                m_uintEmptyCameraGainPrev = m_smVisionInfo.g_uintEmptyCameraGain;
                m_intCameraGainPrev = m_smVisionInfo.g_uintEmptyCameraGain;
            }

            // Set camera shuttle
            if (m_fEmptyCameraShuttlePrev != m_smVisionInfo.g_fEmptyCameraShuttle)
            {
                m_objTeliCamera.SetCameraParameter(1, m_smVisionInfo.g_fEmptyCameraShuttle);
                m_fEmptyCameraShuttlePrev = m_smVisionInfo.g_fEmptyCameraShuttle;
                m_fCameraShuttlePrev = m_smVisionInfo.g_fEmptyCameraShuttle;
            }

            Thread.Sleep(m_smVisionInfo.g_intCameraGrabDelay);

            bool blnSuccess = true;
            bool blnSeparateGrab = m_smVisionInfo.g_blnSeparateGrab;
            int intSelectedImage = m_smVisionInfo.g_intSelectedImage;
            m_arrBufferPointer = new List<IntPtr>();

            for (int i = 0; i < m_intGrabRequire; i++)
            {
                if (i > 0)
                {
                    if (m_objTeliCamera.WaitTriggerWaitDone())
                    {
                        if (m_smVisionInfo.g_blnWantCheckPocketPosition)
                        {
                            // Set camera gain
                            if (m_intCameraGainPrev != m_smVisionInfo.g_arrCameraGain[m_smVisionInfo.g_objPocketPosition.GetGrabImageIndex(i - 1)])
                            {
                                m_objTeliCamera.SetCameraParameter(2, m_smVisionInfo.g_arrCameraGain[m_smVisionInfo.g_objPocketPosition.GetGrabImageIndex(i - 1)]);
                                m_intCameraGainPrev = m_smVisionInfo.g_arrCameraGain[m_smVisionInfo.g_objPocketPosition.GetGrabImageIndex(i - 1)];
                                m_uintEmptyCameraGainPrev = m_smVisionInfo.g_arrCameraGain[m_smVisionInfo.g_objPocketPosition.GetGrabImageIndex(i - 1)];
                                //if (m_objTeliCamera.ref_intSetGainDelay != 0)
                                //    Thread.Sleep(m_objTeliCamera.ref_intSetGainDelay);
                            }
                        }

                        if (/*!blnStartGrab &&*/ !m_objTeliCamera.Grab(i))
                        {
                            blnSuccess = false;
                            m_blnForceStopProduction = true;
                        }
                    }
                    else
                    {
                        blnSuccess = false;
                        m_blnForceStopProduction = true;
                    }
                }
                else
                {
                    if (/*!blnStartGrab &&*/ !m_objTeliCamera.Grab(i))
                    {
                        blnSuccess = false;
                        m_blnForceStopProduction = true;
                    }
                }

                //Set light source channel ON / OFF
                if (m_intGrabRequire > 1 && ((i + 1) < m_smVisionInfo.g_arrCameraShuttle.Count))
                {
                    if (m_smVisionInfo.g_blnWantCheckPocketPosition)
                    {
                        // Set camera shuttle
                        if (m_fCameraShuttlePrev != m_smVisionInfo.g_arrCameraShuttle[m_smVisionInfo.g_objPocketPosition.GetGrabImageIndex(i)])
                        {
                            m_objTeliCamera.SetCameraParameter(1, m_smVisionInfo.g_arrCameraShuttle[m_smVisionInfo.g_objPocketPosition.GetGrabImageIndex(i)]);
                            m_fCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[m_smVisionInfo.g_objPocketPosition.GetGrabImageIndex(i)];
                            m_fEmptyCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[m_smVisionInfo.g_objPocketPosition.GetGrabImageIndex(i)];
                            //if (m_objTeliCamera.ref_intSetGainDelay != 0)
                            //    Thread.Sleep(m_objTeliCamera.ref_intSetGainDelay);
                        }
                    }
                }

                if (!m_objTeliCamera.WaitFrameAcquiredReady(i))
                {
                    blnSuccess = false;
                    m_blnForceStopProduction = true;
                }

            }

            if (blnSuccess)
            {
                //m_objTeliCamera.TriggerImageBufferRead();
                SetGrabDone(blnForInspection);
                m_smVisionInfo.g_objTransferTime.Start();

            }
            else
                SetGrabDone(blnForInspection);

            if (!m_objTeliCamera.WaitTriggerWaitDone())
            {
                blnSuccess = false;
                m_blnForceStopProduction = true;
            }

            for (int i = 0; i < m_intGrabRequire; i++) // 2 --> m_intGrabRequire 
            {
                if (m_smProductionInfo.g_blnAllRunGrabWithoutUseImage)
                {
                    if (m_smVisionInfo.g_blnViewColorImage)
                    {
                        if (m_smVisionInfo.g_arrDebugColorImages.Count != m_smVisionInfo.g_arrColorImages.Count)
                        {
                            for (int d = 0; d < m_smVisionInfo.g_arrColorImages.Count; d++)
                            {
                                m_smVisionInfo.g_arrDebugColorImages.Add(new CImageDrawing(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight));
                            }
                        }
                        m_objTeliCamera.ConvertImage(i);
                        m_smVisionInfo.g_arrMemoryColorImage[i].LoadImageFromMemory(m_objTeliCamera.GetImagePointer());

                        if (m_smVisionInfo.g_intRotateFlip == 1)
                        {
                            m_smVisionInfo.g_arrMemoryColorImage[i].Rotate180Image(ref m_smVisionInfo.g_arrCRotateImage, i);
                        }
                        else if (m_smVisionInfo.g_intRotateFlip == 2)
                        {
                            m_smVisionInfo.g_arrMemoryColorImage[i].Rotate90Image(ref m_smVisionInfo.g_arrCRotateImage, i);
                        }
                        else if (m_smVisionInfo.g_intRotateFlip == 3)
                        {
                            m_smVisionInfo.g_arrMemoryColorImage[i].RotateMinus90Image(ref m_smVisionInfo.g_arrCRotateImage, i);
                        }
                        else if (m_smVisionInfo.g_intRotateFlip == 4)
                        {
                            m_smVisionInfo.g_arrMemoryColorImage[i].FlipHorizontalImage(ref m_smVisionInfo.g_arrCRotateImage, i);
                        }
                        else if (m_smVisionInfo.g_intRotateFlip == 5)
                        {
                            m_smVisionInfo.g_arrMemoryColorImage[i].FlipVerticalImage(ref m_smVisionInfo.g_arrCRotateImage, i);
                        }
                        else
                        {
                            m_smVisionInfo.g_arrMemoryColorImage[i].CopyTo(ref m_smVisionInfo.g_arrCRotateImage, i);
                        }

                        m_smVisionInfo.g_arrCRotateImage[i].CopyTo(ref m_smVisionInfo.g_arrDebugColorImages, i);

                        if (m_smVisionInfo.g_arrImageGain[i] != 1f)
                        {
                            m_smVisionInfo.g_arrColorImages[i].AddGain(m_smVisionInfo.g_arrImageGain[i], m_smVisionInfo.g_intColorFormat);
                        }
                        m_smVisionInfo.g_arrDebugColorImages[i].ConvertColorToMono(ref m_smVisionInfo.g_arrDebugImages, i);
                    }
                }
                else
                {
                    if (m_smVisionInfo.g_blnViewColorImage)
                    {
                        //m_objTeliCamera.ConvertImage(i);
                        //m_objTeliCamera.ConvertImage(/*m_arrBitmapData[i],*/ m_arrBufferPointer[i]);
                        m_objTeliCamera.ConvertImage(i);
                        m_smVisionInfo.g_arrMemoryColorImage[i].LoadImageFromMemory(m_objTeliCamera.GetImagePointer());

                        if (m_smVisionInfo.g_intRotateFlip == 1)
                        {
                            m_smVisionInfo.g_arrMemoryColorImage[i].Rotate180Image(ref m_smVisionInfo.g_arrCRotateImage, i);
                        }
                        else if (m_smVisionInfo.g_intRotateFlip == 2)
                        {
                            m_smVisionInfo.g_arrMemoryColorImage[i].Rotate90Image(ref m_smVisionInfo.g_arrCRotateImage, i);
                        }
                        else if (m_smVisionInfo.g_intRotateFlip == 3)
                        {
                            m_smVisionInfo.g_arrMemoryColorImage[i].RotateMinus90Image(ref m_smVisionInfo.g_arrCRotateImage, i);
                        }
                        else if (m_smVisionInfo.g_intRotateFlip == 4)
                        {
                            m_smVisionInfo.g_arrMemoryColorImage[i].FlipHorizontalImage(ref m_smVisionInfo.g_arrCRotateImage, i);
                        }
                        else if (m_smVisionInfo.g_intRotateFlip == 5)
                        {
                            m_smVisionInfo.g_arrMemoryColorImage[i].FlipVerticalImage(ref m_smVisionInfo.g_arrCRotateImage, i);
                        }
                        else
                        {
                            m_smVisionInfo.g_arrMemoryColorImage[i].CopyTo(ref m_smVisionInfo.g_arrCRotateImage, i);
                        }

                        m_smVisionInfo.g_arrCRotateImage[i].CopyTo(ref m_smVisionInfo.g_arrColorImages, i);

                        if (m_smVisionInfo.g_arrImageGain[i] != 1f)
                        {
                            m_smVisionInfo.g_arrColorImages[i].AddGain(m_smVisionInfo.g_arrImageGain[i], m_smVisionInfo.g_intColorFormat);
                        }

                        m_smVisionInfo.g_arrColorImages[i].ConvertColorToMono(ref m_smVisionInfo.g_arrImages, i);

                    }
                }

                if (m_smProductionInfo.g_blnAllRunGrabWithoutUseImage)
                {
                    if (m_smVisionInfo.g_arrDebugImages.Count != m_smVisionInfo.g_arrImages.Count)
                    {
                        for (int d = 0; d < m_smVisionInfo.g_arrImages.Count; d++)
                        {
                            m_smVisionInfo.g_arrDebugImages.Add(new ImageDrawing(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight));
                        }
                    }
                    if (!m_smVisionInfo.g_blnViewColorImage)
                    {
                        m_smVisionInfo.g_arrMemoryImage[i].LoadImageFromMemory(m_objTeliCamera.GetImageBufferPointer(i));//(m_objTeliCamera.GetImagePointer());

                        if (m_smVisionInfo.g_intRotateFlip == 1)
                        {
                            m_smVisionInfo.g_arrMemoryImage[i].Rotate180Image(ref m_smVisionInfo.g_arrRotateImage, i);
                        }
                        else if (m_smVisionInfo.g_intRotateFlip == 2)
                        {
                            m_smVisionInfo.g_arrMemoryImage[i].Rotate90Image(ref m_smVisionInfo.g_arrRotateImage, i);
                        }
                        else if (m_smVisionInfo.g_intRotateFlip == 3)
                        {
                            m_smVisionInfo.g_arrMemoryImage[i].RotateMinus90Image(ref m_smVisionInfo.g_arrRotateImage, i);
                        }
                        else if (m_smVisionInfo.g_intRotateFlip == 4)
                        {
                            m_smVisionInfo.g_arrMemoryImage[i].FlipHorizontalImage(ref m_smVisionInfo.g_arrRotateImage, i);
                        }
                        else if (m_smVisionInfo.g_intRotateFlip == 5)
                        {
                            m_smVisionInfo.g_arrMemoryImage[i].FlipVerticalImage(ref m_smVisionInfo.g_arrRotateImage, i);
                        }
                        else
                        {
                            m_smVisionInfo.g_arrMemoryImage[i].CopyTo(ref m_smVisionInfo.g_arrRotateImage, i);
                        }
                        m_smVisionInfo.g_arrRotateImage[i].CopyTo(ref m_smVisionInfo.g_arrDebugImages, i);
                        if (i > 0)
                        {
                            if (m_smVisionInfo.g_blnWantCheckPocketPosition)
                                m_smVisionInfo.g_arrDebugImages[i].AddGain(m_smVisionInfo.g_arrImageGain[m_smVisionInfo.g_objPocketPosition.GetGrabImageIndex(i)]);
                            else
                                m_smVisionInfo.g_arrDebugImages[i].AddGain(m_smVisionInfo.g_arrImageGain[i]);
                        }
                        else
                            m_smVisionInfo.g_arrDebugImages[i].AddGain(m_smVisionInfo.g_fEmptyImageGain);

                    }

                }
                else
                {
                    if (!m_smVisionInfo.g_blnViewColorImage)
                    {
                        m_smVisionInfo.g_arrMemoryImage[i].LoadImageFromMemory(m_objTeliCamera.GetImageBufferPointer(i));//(m_objTeliCamera.GetImagePointer());

                        if (m_smVisionInfo.g_intRotateFlip == 1)
                        {
                            m_smVisionInfo.g_arrMemoryImage[i].Rotate180Image(ref m_smVisionInfo.g_arrRotateImage, i);
                        }
                        else if (m_smVisionInfo.g_intRotateFlip == 2)
                        {
                            m_smVisionInfo.g_arrMemoryImage[i].Rotate90Image(ref m_smVisionInfo.g_arrRotateImage, i);
                        }
                        else if (m_smVisionInfo.g_intRotateFlip == 3)
                        {
                            m_smVisionInfo.g_arrMemoryImage[i].RotateMinus90Image(ref m_smVisionInfo.g_arrRotateImage, i);
                        }
                        else if (m_smVisionInfo.g_intRotateFlip == 4)
                        {
                            m_smVisionInfo.g_arrMemoryImage[i].FlipHorizontalImage(ref m_smVisionInfo.g_arrRotateImage, i);
                        }
                        else if (m_smVisionInfo.g_intRotateFlip == 5)
                        {
                            m_smVisionInfo.g_arrMemoryImage[i].FlipVerticalImage(ref m_smVisionInfo.g_arrRotateImage, i);
                        }
                        else
                        {
                            m_smVisionInfo.g_arrMemoryImage[i].CopyTo(ref m_smVisionInfo.g_arrRotateImage, i);
                        }
                        m_smVisionInfo.g_arrRotateImage[i].CopyTo(ref m_smVisionInfo.g_arrImages, i);
                        if (i > 0)
                        {
                            if (m_smVisionInfo.g_blnWantCheckPocketPosition)
                                m_smVisionInfo.g_arrImages[i].AddGain(m_smVisionInfo.g_arrImageGain[m_smVisionInfo.g_objPocketPosition.GetGrabImageIndex(i)]);
                            else
                                m_smVisionInfo.g_arrImages[i].AddGain(m_smVisionInfo.g_arrImageGain[i]);
                        }
                        else
                            m_smVisionInfo.g_arrImages[i].AddGain(m_smVisionInfo.g_fEmptyImageGain);
                    }

                }

                if (i == 1)
                {
                    if (blnSuccess) m_bGrabImage1Result = true;
                    m_bGrabImage1Done = true;
                }
                else if (i == 2)
                {
                    if (blnSuccess) m_bGrabImage2Result = true;
                    m_bGrabImage2Done = true;
                }
                else if (i == 3)
                {
                    if (blnSuccess) m_bGrabImage3Result = true;
                    m_bGrabImage3Done = true;
                }
                else if (i == 4)
                {
                    if (blnSuccess) m_bGrabImage4Result = true;
                    m_bGrabImage4Done = true;
                }
                else if (i == 5)
                {
                    if (blnSuccess) m_bGrabImage5Result = true;
                    m_bGrabImage5Done = true;
                }
                else if (i == 6)
                {
                    if (blnSuccess) m_bGrabImage6Result = true;
                    m_bGrabImage6Done = true;
                }
                else if (i == 7)
                {
                    if (blnSuccess) m_bGrabImage7Result = true;
                    m_bGrabImage7Done = true;
                }


            }

            m_bGrabImage1Done = m_bGrabImage2Done = m_bGrabImage3Done = m_bGrabImage4Done = m_bGrabImage5Done = m_bGrabImage6Done = m_bGrabImage7Done = true;

            //Reset outport
            if (!m_smCustomizeInfo.g_blnMixController)
            {
                if (m_smCustomizeInfo.g_blnLEDiControl)
                {
                    m_objTeliCamera.OutPort(1, 3);
                    Thread.Sleep(3);
                    m_objTeliCamera.OutPort(1, 0);
                }
                else if (m_smCustomizeInfo.g_blnVTControl)
                {
                    m_objTeliCamera.OutPort(1, 0);
                }
            }

            //2021-10-21 ZJYEOH : Set Image to Black if camera fail
            if (!blnSuccess)
            {
                for (int i = 0; i < m_smVisionInfo.g_arrImages.Count; i++)
                {
                    if (m_smVisionInfo.g_blnViewColorImage)
                    {
                        m_smVisionInfo.g_arrColorImages[i].SetImageToBlack();
                        m_smVisionInfo.g_arrColorRotatedImages[i].SetImageToBlack();
                    }
                    m_smVisionInfo.g_arrImages[i].SetImageToBlack();
                    m_smVisionInfo.g_arrRotatedImages[i].SetImageToBlack();
                }
            }

            if (m_objTeliCamera.GetErrorMessage() != "")
            {
                m_smVisionInfo.g_strErrorMessage = m_objTeliCamera.GetErrorMessage();
                m_smVisionInfo.ALL_VM_UpdatePictureBox = true;
                m_smVisionInfo.g_objTransferTime.Stop();

                return false;
            }
            else
            {
                // Set camera gain
                if (m_uintEmptyCameraGainPrev != m_smVisionInfo.g_uintEmptyCameraGain)
                {
                    m_objTeliCamera.SetCameraParameter(2, m_smVisionInfo.g_uintEmptyCameraGain);
                    m_uintEmptyCameraGainPrev = m_smVisionInfo.g_uintEmptyCameraGain;
                    m_intCameraGainPrev = m_smVisionInfo.g_uintEmptyCameraGain;
                }

                // Set camera shuttle
                if (m_fEmptyCameraShuttlePrev != m_smVisionInfo.g_fEmptyCameraShuttle)
                {
                    m_objTeliCamera.SetCameraParameter(1, m_smVisionInfo.g_fEmptyCameraShuttle);
                    m_fEmptyCameraShuttlePrev = m_smVisionInfo.g_fEmptyCameraShuttle;
                    m_fCameraShuttlePrev = m_smVisionInfo.g_fEmptyCameraShuttle;

                }

                if (m_smVisionInfo.g_bImageStatisticAnalysisON)
                {
                    m_smVisionInfo.g_bImageStatisticAnalysisUpdateInfo = true;

                    while (true)
                    {
                        if (!m_smVisionInfo.g_bImageStatisticAnalysisUpdateInfo)
                            break;

                        Thread.Sleep(1);
                    }
                }

                //AttachImageToROI();
                m_smVisionInfo.g_blnLoadFile = false;
                m_smVisionInfo.ALL_VM_UpdatePictureBox = true;
                m_smVisionInfo.g_objTransferTime.Stop();

                return true;
            }
        }
        public bool GrabImage_Teli(bool blnForInspection)
        {
            if (!m_objTeliCamera.IsCameraInitDone())
            {
                m_bGrabImage1Result = m_bGrabImage2Result = m_bGrabImage3Result = m_bGrabImage4Result = m_bGrabImage5Result = m_bGrabImage6Result = m_bGrabImage7Result = true;
                m_bGrabImage1Done = m_bGrabImage2Done = m_bGrabImage3Done = m_bGrabImage4Done = m_bGrabImage5Done = m_bGrabImage6Done = m_bGrabImage7Done = true;
                m_smVisionInfo.g_strErrorMessage = "Camera No Connected";
                return true;
            }

            m_smVisionInfo.g_objGrabTime.Start();

            Thread.Sleep(m_smVisionInfo.g_intCameraGrabDelay);

            bool blnSuccess = true;
            bool blnSeparateGrab = m_smVisionInfo.g_blnSeparateGrab;
            int intSelectedImage = m_smVisionInfo.g_intSelectedImage;
            HiPerfTimer timer_GrabTime = new HiPerfTimer();

            int intExposureTime = (int)Math.Ceiling(m_smVisionInfo.g_arrCameraShuttle[0] * 0.001f);  // For Teli, Shuttle 1 == 1 microsecond

            // Define grab images require
            if (blnForInspection)
            {
                if ((m_smCustomizeInfo.g_intWantPackage & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
                {
                    if (m_intCurrentGrabRequire != m_intGrabRequire)
                        m_intCurrentGrabRequire = m_intGrabRequire;
                }
                else
                {
                    if (m_intCurrentGrabRequire != 1)
                        m_intCurrentGrabRequire = 1;
                }
            }
            else
            {
                // Set to maximum requirement grab image if camera live or grab.
                if (m_intCurrentGrabRequire != m_intGrabRequire)
                    m_intCurrentGrabRequire = m_intGrabRequire;
            }

            m_objTeliCamera.DiscardFrame();

            for (int i = 0; i < m_intCurrentGrabRequire; i++)
            {
                if (blnSeparateGrab)
                {
                    if (i != intSelectedImage)
                        continue;
                }

                if (i > 0) // for second image and third image
                {
                    if (m_objTeliCamera.WaitFrameReady())
                    {
                        if (m_smVisionInfo.g_blnViewColorImage)
                        {
                            m_smVisionInfo.g_objMemoryColorImage.LoadImageFromMemory(m_objTeliCamera.GetImagePointer());
                            m_smVisionInfo.g_objMemoryColorImage.CopyTo(ref m_smVisionInfo.g_arrColorImages, i - 1);
                        }
                        else
                        {
                            m_smVisionInfo.g_objMemoryImage.LoadImageFromMemory(m_objTeliCamera.GetImagePointer());
                            m_smVisionInfo.g_objMemoryImage.CopyTo(ref m_smVisionInfo.g_arrImages, i - 1);
                            m_smVisionInfo.g_arrImages[i - 1].AddGain(m_smVisionInfo.g_arrImageGain[i - 1]);
                        }
                    }
                    else
                    {
                        blnSuccess = false;
                        m_blnForceStopProduction = true;
                    }
                }

                #region if more than 1 image need to be captured
                // Set light source channel ON/OFF
                if (m_intCurrentGrabRequire > 1)
                {
                    // Set camera gain
                    if (m_intCameraGainPrev != m_smVisionInfo.g_arrCameraGain[i])
                    {
                        m_objTeliCamera.SetCameraParameter(2, m_smVisionInfo.g_arrCameraGain[i]);
                        m_intCameraGainPrev = m_smVisionInfo.g_arrCameraGain[i];
                        //if (m_objAVTFireGrab.ref_intSetGainDelay != 0)
                        //    Thread.Sleep(m_objAVTFireGrab.ref_intSetGainDelay);
                    }

                    // Set camera shuttle
                    if (m_fCameraShuttlePrev != m_smVisionInfo.g_arrCameraShuttle[i])
                    {
                        m_objTeliCamera.SetCameraParameter(1, m_smVisionInfo.g_arrCameraShuttle[i]);
                        m_fCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[i];
                        ////if (m_objAVTFireGrab.ref_intSetGainDelay != 0)
                        ////    Thread.Sleep(m_objAVTFireGrab.ref_intSetGainDelay);

                        intExposureTime = (int)Math.Ceiling(m_smVisionInfo.g_arrCameraShuttle[i] * 0.0001f);
                    }

                    switch (i)
                    {
                        case 0:
                            if ((m_intCameraOutState & (0x01)) == 0)
                            {
                                m_objTeliCamera.OutPort(0, 2);
                                m_intCameraOutState |= 0x01;
                            }
                            if ((m_intCameraOutState & (0x02)) > 0)
                            {
                                m_objTeliCamera.OutPort(1, 0);
                                m_intCameraOutState &= ~0x02;
                            }
                            if ((m_intCameraOutState & (0x04)) > 0)
                            {
                                m_objTeliCamera.OutPort(2, 0);
                                m_intCameraOutState &= ~0x04;
                            }
                            break;
                        case 1:
                            if ((m_intCameraOutState & (0x01)) > 0)
                            {
                                m_objTeliCamera.OutPort(0, 0);
                                m_intCameraOutState &= ~0x01;
                            }
                            if ((m_intCameraOutState & (0x02)) == 0)
                            {
                                m_objTeliCamera.OutPort(1, 2);
                                m_intCameraOutState |= 0x02;
                            }
                            if ((m_intCameraOutState & (0x04)) > 0)
                            {
                                m_objTeliCamera.OutPort(2, 0);
                                m_intCameraOutState &= ~0x04;
                            }
                            break;
                        case 2:
                            if ((m_intCameraOutState & (0x01)) > 0)
                            {
                                m_objTeliCamera.OutPort(0, 0);
                                m_intCameraOutState &= ~0x01;
                            }
                            if ((m_intCameraOutState & (0x02)) > 0)
                            {
                                m_objTeliCamera.OutPort(1, 0);
                                m_intCameraOutState &= ~0x02;
                            }
                            if ((m_intCameraOutState & (0x04)) == 0)
                            {
                                m_objTeliCamera.OutPort(2, 2);
                                m_intCameraOutState |= 0x04;
                            }
                            break;
                    }
                }
                #endregion

                if (blnSuccess)//2021-10-21 ZJYEOH : No need to grab anymore if not success, as this will reset the camera error message
                {
                    if (!m_objTeliCamera.Grab())
                    {
                        blnSuccess = false;
                        m_blnForceStopProduction = true;
                    }
                }

                if (i < m_intCurrentGrabRequire - 1)
                {
                    timer_GrabTime.Start();
                    Thread.Sleep(intExposureTime);
                }
                else
                {
                    Thread.Sleep(Math.Max(intExposureTime, 4));
                }
            }

            if (!m_objTeliCamera.WaitFrameReady())
            {
                blnSuccess = false;
                m_blnForceStopProduction = true;
            }

            if (blnSuccess)
            {
                SetGrabDone(blnForInspection);
                m_smVisionInfo.g_objTransferTime.Start();

                //for (int i = 0; i < m_intCurrentGrabRequire; i++)
                //{
                //    if (blnSeparateGrab)
                //    {
                //        if (i != intSelectedImage)
                //            continue;
                //    }

                if (m_objTeliCamera.GetFrame(m_intCurrentGrabRequire - 1))
                {
                    if (m_objTeliCamera.ConvertFrame(m_intCurrentGrabRequire - 1))
                    {
                        if (m_smVisionInfo.g_blnViewColorImage)
                        {
                            m_smVisionInfo.g_objMemoryColorImage.LoadImageFromMemory(m_objTeliCamera.GetImagePointer());
                            m_smVisionInfo.g_objMemoryColorImage.CopyTo(ref m_smVisionInfo.g_arrColorImages, m_intCurrentGrabRequire - 1);
                        }
                        else
                        {
                            m_smVisionInfo.g_objMemoryImage.LoadImageFromMemory(m_objTeliCamera.GetImagePointer());
                            m_smVisionInfo.g_objMemoryImage.CopyTo(ref m_smVisionInfo.g_arrImages, m_intCurrentGrabRequire - 1);
                            m_smVisionInfo.g_arrImages[m_intCurrentGrabRequire - 1].AddGain(m_smVisionInfo.g_arrImageGain[m_intCurrentGrabRequire - 1]);

                            // =================Temporary use for 0603 InPocket Auto Replace With Positioning===========
                            //ROI objSourceROI = new ROI();
                            //objSourceROI.AttachImage(m_smVisionInfo.g_objMemoryImage);
                            //objSourceROI.LoadROISetting(0, 0, 
                            //    m_smVisionInfo.g_objMemoryImage.ref_intImageWidth, 
                            //    m_smVisionInfo.g_objMemoryImage.ref_intImageHeight - 12);

                            //ROI objOffSetROI = new ROI();
                            //objOffSetROI.AttachImage(m_smVisionInfo.g_arrImages[i]);
                            //objOffSetROI.LoadROISetting(0, 12,
                            //    m_smVisionInfo.g_arrImages[i].ref_intImageWidth,
                            //    m_smVisionInfo.g_arrImages[i].ref_intImageHeight - 12);
                            //objSourceROI.CopyImage(ref objOffSetROI);
                            //=============================================================================
                        }
                    }
                }
                //}
            }
            else
                SetGrabDone(blnForInspection);

            //for (int i = 0; i < m_intCurrentGrabRequire; i++)
            //{
            //    if (blnSeparateGrab)
            //    {
            //        if (i != intSelectedImage)
            //            continue;
            //    }

            //    m_objAVTFireGrab.ReleaseImage(i);
            //}

            m_bGrabImage1Done = m_bGrabImage2Done = m_bGrabImage3Done = m_bGrabImage4Done = m_bGrabImage5Done = m_bGrabImage6Done = m_bGrabImage7Done = true;
            m_bGrabImage1Result = m_bGrabImage2Result = m_bGrabImage3Result = m_bGrabImage4Result = m_bGrabImage5Result = m_bGrabImage6Result = m_bGrabImage7Result = true;

            //2021-10-21 ZJYEOH : Set Image to Black if camera fail
            if (!blnSuccess)
            {
                for (int i = 0; i < m_smVisionInfo.g_arrImages.Count; i++)
                {
                    if (m_smVisionInfo.g_blnViewColorImage)
                    {
                        m_smVisionInfo.g_arrColorImages[i].SetImageToBlack();
                        m_smVisionInfo.g_arrColorRotatedImages[i].SetImageToBlack();
                    }
                    m_smVisionInfo.g_arrImages[i].SetImageToBlack();
                    m_smVisionInfo.g_arrRotatedImages[i].SetImageToBlack();
                }
            }

            if (m_objTeliCamera.GetErrorMessage() != "")
            {
                m_smVisionInfo.g_strErrorMessage = m_objTeliCamera.GetErrorMessage();
                m_smVisionInfo.ALL_VM_UpdatePictureBox = true;
                m_smVisionInfo.g_objTransferTime.Stop();
                return false;
            }
            else
            {
                // Set camera gain
                if (m_intCameraGainPrev != m_smVisionInfo.g_arrCameraGain[0])
                {
                    m_objTeliCamera.SetCameraParameter(2, m_smVisionInfo.g_arrCameraGain[0]);
                    m_intCameraGainPrev = m_smVisionInfo.g_arrCameraGain[0];
                }

                // Set camera shuttle
                if (m_fCameraShuttlePrev != m_smVisionInfo.g_arrCameraShuttle[0])
                {
                    m_objTeliCamera.SetCameraParameter(1, m_smVisionInfo.g_arrCameraShuttle[0]);
                    m_fCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[0];
                }

                AttachImageToROI();
                m_smVisionInfo.g_blnLoadFile = false;
                m_smVisionInfo.ALL_VM_UpdatePictureBox = true;
                m_smVisionInfo.g_objTransferTime.Stop();
                return true;
            }
        }

        public bool GrabImage_AVT(bool blnForInspection)
        {
            if (!m_objAVTFireGrab.ref_blnCameraInitDone)
                return true;

            m_smVisionInfo.g_objGrabTime.Start();
            bool blnSuccess = true;
            bool blnSeparateGrab = m_smVisionInfo.g_blnSeparateGrab;
            int intSelectedImage = m_smVisionInfo.g_intSelectedImage;
            HiPerfTimer timer_GrabTime = new HiPerfTimer();

            int intExposureTime = (int)Math.Ceiling(m_smVisionInfo.g_fCameraShuttle * 0.02f);

            // Define grab images require
            if (blnForInspection)
            {
                if ((m_smCustomizeInfo.g_intWantPackage & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
                {
                    if (m_intCurrentGrabRequire != m_intGrabRequire)
                        m_intCurrentGrabRequire = m_intGrabRequire;
                }
                else
                {
                    if (m_intCurrentGrabRequire != 1)
                        m_intCurrentGrabRequire = 1;
                }
            }
            else
            {
                // Set to maximum requirement grab image if camera live or grab.
                if (m_intCurrentGrabRequire != m_intGrabRequire)
                    m_intCurrentGrabRequire = m_intGrabRequire;
            }

            m_objAVTFireGrab.DiscardFrame();

            for (int i = 0; i < m_intCurrentGrabRequire; i++)
            {
                if (blnSeparateGrab)
                {
                    if (i != intSelectedImage)
                        continue;
                }

                if (i > 0) // for second image and third image
                {
                    timer_GrabTime.Stop();
                    if ((m_objAVTFireGrab.ref_intNextGrabDelay - timer_GrabTime.Duration) > 0)
                        Thread.Sleep((int)(m_objAVTFireGrab.ref_intNextGrabDelay - timer_GrabTime.Duration));
                }

                #region if more than 1 image need to be captured
                // Set light source channel ON/OFF
                if (m_intGrabRequire > 1)
                {
                    // Set camera gain
                    if (m_intCameraGainPrev != m_smVisionInfo.g_arrCameraGain[i])
                    {
                        m_objAVTFireGrab.SetCameraParameter(2, m_smVisionInfo.g_arrCameraGain[i]);
                        m_intCameraGainPrev = m_smVisionInfo.g_arrCameraGain[i];
                        if (m_objAVTFireGrab.ref_intSetGainDelay != 0)
                            Thread.Sleep(m_objAVTFireGrab.ref_intSetGainDelay);
                    }

                    // Set camera shuttle
                    if (m_fCameraShuttlePrev != m_smVisionInfo.g_arrCameraShuttle[i])
                    {
                        m_objAVTFireGrab.SetCameraParameter(1, (uint)m_smVisionInfo.g_arrCameraShuttle[i]);
                        m_fCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[i];
                        if (m_objAVTFireGrab.ref_intSetGainDelay != 0)
                            Thread.Sleep(m_objAVTFireGrab.ref_intSetGainDelay);
                    }

                    switch (i)
                    {
                        case 0:
                            if ((m_intCameraOutState & (0x01)) == 0)
                            {
                                m_objAVTFireGrab.OutPort(0, 2);
                                m_intCameraOutState |= 0x01;
                            }
                            if ((m_intCameraOutState & (0x02)) > 0)
                            {
                                m_objAVTFireGrab.OutPort(1, 0);
                                m_intCameraOutState &= ~0x02;
                            }
                            if ((m_intCameraOutState & (0x04)) > 0)
                            {
                                m_objAVTFireGrab.OutPort(2, 0);
                                m_intCameraOutState &= ~0x04;
                            }
                            break;
                        case 1:
                            if ((m_intCameraOutState & (0x01)) > 0)
                            {
                                m_objAVTFireGrab.OutPort(0, 0);
                                m_intCameraOutState &= ~0x01;
                            }
                            if ((m_intCameraOutState & (0x02)) == 0)
                            {
                                m_objAVTFireGrab.OutPort(1, 2);
                                m_intCameraOutState |= 0x02;
                            }
                            if ((m_intCameraOutState & (0x04)) > 0)
                            {
                                m_objAVTFireGrab.OutPort(2, 0);
                                m_intCameraOutState &= ~0x04;
                            }
                            break;
                        case 2:
                            if ((m_intCameraOutState & (0x01)) > 0)
                            {
                                m_objAVTFireGrab.OutPort(0, 0);
                                m_intCameraOutState &= ~0x01;
                            }
                            if ((m_intCameraOutState & (0x02)) > 0)
                            {
                                m_objAVTFireGrab.OutPort(1, 0);
                                m_intCameraOutState &= ~0x02;
                            }
                            if ((m_intCameraOutState & (0x04)) == 0)
                            {
                                m_objAVTFireGrab.OutPort(2, 2);
                                m_intCameraOutState |= 0x04;
                            }
                            break;
                    }
                }
                #endregion

                if (!m_objAVTFireGrab.Grab())
                {
                    blnSuccess = false;
                    m_blnForceStopProduction = true;
                }

                if (i < m_intCurrentGrabRequire - 1)
                {
                    timer_GrabTime.Start();
                    Thread.Sleep(intExposureTime);
                }
                else
                {
                    Thread.Sleep(Math.Max(intExposureTime, 4));
                }
            }

            if (blnSuccess)
            {
                SetGrabDone(blnForInspection);
                m_smVisionInfo.g_objTransferTime.Start();

                for (int i = 0; i < m_intCurrentGrabRequire; i++)
                {
                    if (blnSeparateGrab)
                    {
                        if (i != intSelectedImage)
                            continue;
                    }

                    if (m_objAVTFireGrab.GetFrame(i))
                    {
                        if (m_objAVTFireGrab.ConvertFrame(i))
                        {
                            if (m_smVisionInfo.g_blnViewColorImage)
                            {
                                m_smVisionInfo.g_objMemoryColorImage.LoadImageFromMemory(m_objAVTFireGrab.ref_ptrImagePointer);
                                m_smVisionInfo.g_objMemoryColorImage.CopyTo(ref m_smVisionInfo.g_arrColorImages, i);
                            }
                            else
                            {
                                m_smVisionInfo.g_objMemoryImage.LoadImageFromMemory(m_objAVTFireGrab.ref_ptrImagePointer);
                                m_smVisionInfo.g_objMemoryImage.CopyTo(ref m_smVisionInfo.g_arrImages, i);
                                m_smVisionInfo.g_arrImages[i].AddGain(m_smVisionInfo.g_arrImageGain[i]);

                                // =================Temporary use for 0603 InPocket Auto Replace With Positioning===========
                                //ROI objSourceROI = new ROI();
                                //objSourceROI.AttachImage(m_smVisionInfo.g_objMemoryImage);
                                //objSourceROI.LoadROISetting(0, 0, 
                                //    m_smVisionInfo.g_objMemoryImage.ref_intImageWidth, 
                                //    m_smVisionInfo.g_objMemoryImage.ref_intImageHeight - 12);

                                //ROI objOffSetROI = new ROI();
                                //objOffSetROI.AttachImage(m_smVisionInfo.g_arrImages[i]);
                                //objOffSetROI.LoadROISetting(0, 12,
                                //    m_smVisionInfo.g_arrImages[i].ref_intImageWidth,
                                //    m_smVisionInfo.g_arrImages[i].ref_intImageHeight - 12);
                                //objSourceROI.CopyImage(ref objOffSetROI);
                                //=============================================================================
                            }
                        }
                    }
                }
            }
            else
                SetGrabDone(blnForInspection);

            for (int i = 0; i < m_intCurrentGrabRequire; i++)
            {
                if (blnSeparateGrab)
                {
                    if (i != intSelectedImage)
                        continue;
                }

                m_objAVTFireGrab.ReleaseImage(i);
            }

            if (m_objAVTFireGrab.ref_strErrorText != "")
            {
                m_smVisionInfo.g_strErrorMessage = m_objAVTFireGrab.ref_strErrorText;
                m_smVisionInfo.ALL_VM_UpdatePictureBox = true;
                m_smVisionInfo.g_objTransferTime.Stop();
                return false;
            }
            else
            {
                // Set camera gain
                if (m_intCameraGainPrev != m_smVisionInfo.g_arrCameraGain[0])
                {
                    m_objAVTFireGrab.SetCameraParameter(2, m_smVisionInfo.g_arrCameraGain[0]);
                    m_intCameraGainPrev = m_smVisionInfo.g_arrCameraGain[0];
                }

                // Set camera shuttle
                if (m_fCameraShuttlePrev != m_smVisionInfo.g_arrCameraShuttle[0])
                {
                    m_objAVTFireGrab.SetCameraParameter(1, (uint)m_smVisionInfo.g_arrCameraShuttle[0]);
                    m_fCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[0];
                }

                AttachImageToROI();
                m_smVisionInfo.g_blnLoadFile = false;
                m_smVisionInfo.ALL_VM_UpdatePictureBox = true;
                m_smVisionInfo.g_objTransferTime.Stop();
                return true;
            }
        }

        public bool GrabImage_Normal_GetFrameBeforeNextGrab_NoSetIntensity_AVTVimba(bool blnForInspection)
        {
            /*
             * Use LEDi standard controller
             * Grab each image, get frame, convert frame, assign to imagedrawing by sequence.
             * No grab all first, then only get all frame after.
             * Use this function unless you need to trigger GrabDone signal to software as early as possible.
             */

            if (!m_objAVTFireGrab.ref_blnCameraInitDone)
            {
                m_bGrabImage1Result = m_bGrabImage2Result = m_bGrabImage3Result = m_bGrabImage4Result = m_bGrabImage5Result = m_bGrabImage6Result = m_bGrabImage7Result = true;
                m_bGrabImage1Done = m_bGrabImage2Done = m_bGrabImage3Done = m_bGrabImage4Done = m_bGrabImage5Done = m_bGrabImage6Done = m_bGrabImage7Done = true;
                m_smVisionInfo.g_strErrorMessage = "Camera No Connected";
                return true;
            }

            // Default Using AVT Camera
            m_smVisionInfo.g_objGrabTime.Start();

            Thread.Sleep(m_smVisionInfo.g_intCameraGrabDelay);

            bool blnSuccess = true;
            bool blnSeparateGrab = m_smVisionInfo.g_blnSeparateGrab;
            int intSelectedImage = m_smVisionInfo.g_intSelectedImage;


            m_objAVTFireGrab.DiscardFrame();

            for (int i = 0; i < m_intGrabRequire; i++)
            {
                if (blnSeparateGrab)
                {
                    if (i != intSelectedImage)
                        continue;
                }

                #region if more than 1 image need to be captured
                // Set light source channel ON/OFF
                if (m_intGrabRequire > 1)
                {
                    // Set camera gain
                    if (m_intCameraGainPrev != m_smVisionInfo.g_arrCameraGain[i])
                    {
                        m_objAVTFireGrab.SetCameraParameter(2, m_smVisionInfo.g_arrCameraGain[i]);
                        m_intCameraGainPrev = m_smVisionInfo.g_arrCameraGain[i];
                        if (m_objAVTFireGrab.ref_intSetGainDelay != 0)
                            Thread.Sleep(m_objAVTFireGrab.ref_intSetGainDelay);
                    }

                    // Set camera shuttle
                    if (m_fCameraShuttlePrev != m_smVisionInfo.g_arrCameraShuttle[i])
                    {
                        m_objAVTFireGrab.SetCameraParameter(1, m_smVisionInfo.g_arrCameraShuttle[i]);
                        m_fCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[i];
                        if (m_objAVTFireGrab.ref_intSetGainDelay != 0)
                            Thread.Sleep(m_objAVTFireGrab.ref_intSetGainDelay);
                    }
                }
                #endregion

                switch (i)
                {
                    case 0:
                        if ((m_intCameraOutState & (0x01)) == 0)
                        {
                            m_objAVTFireGrab.OutPort(0, m_smVisionInfo.g_intTriggerMode);
                            m_intCameraOutState |= 0x01;
                        }
                        if ((m_intCameraOutState & (0x02)) > 0)
                        {
                            m_objAVTFireGrab.OutPort(1, 0);
                            m_intCameraOutState &= ~0x02;
                        }
                        if ((m_intCameraOutState & (0x04)) > 0)
                        {
                            m_objAVTFireGrab.OutPort(2, 0);
                            m_intCameraOutState &= ~0x04;
                        }
                        break;
                    case 1:
                        if ((m_intCameraOutState & (0x01)) > 0)
                        {
                            m_objAVTFireGrab.OutPort(0, 0);
                            m_intCameraOutState &= ~0x01;
                        }
                        if ((m_intCameraOutState & (0x02)) == 0)
                        {
                            m_objAVTFireGrab.OutPort(1, m_smVisionInfo.g_intTriggerMode);
                            m_intCameraOutState |= 0x02;
                        }
                        if ((m_intCameraOutState & (0x04)) > 0)
                        {
                            m_objAVTFireGrab.OutPort(2, 0);
                            m_intCameraOutState &= ~0x04;
                        }
                        break;
                    case 2:
                        if ((m_intCameraOutState & (0x01)) > 0)
                        {
                            m_objAVTFireGrab.OutPort(0, 0);
                            m_intCameraOutState &= ~0x01;
                        }
                        if ((m_intCameraOutState & (0x02)) > 0)
                        {
                            m_objAVTFireGrab.OutPort(1, 0);
                            m_intCameraOutState &= ~0x02;
                        }
                        if ((m_intCameraOutState & (0x04)) == 0)
                        {
                            m_objAVTFireGrab.OutPort(2, m_smVisionInfo.g_intTriggerMode);
                            m_intCameraOutState |= 0x04;
                        }
                        break;
                }

                if (!m_objAVTFireGrab.Grab())
                {
                    blnSuccess = false;
                    m_blnForceStopProduction = true;
                }

                if (i == (m_intGrabRequire - 1))
                {
                    SetGrabDone(blnForInspection);
                    m_smVisionInfo.g_objTransferTime.Start();
                }

                if (m_objAVTFireGrab.GetFrame(i))
                {
                    if (m_objAVTFireGrab.ConvertFrame(i))
                    {
                        if (m_smVisionInfo.g_blnViewColorImage)
                        {
                            m_smVisionInfo.g_objMemoryColorImage.SetImageSize(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight);
                            m_smVisionInfo.g_objMemoryColorImage.LoadImageFromMemory(m_objAVTFireGrab.ref_ptrImagePointer);
                            m_smVisionInfo.g_objMemoryColorImage.CopyTo(ref m_smVisionInfo.g_arrColorImages, i);
                        }
                        else
                        {
                            m_smVisionInfo.g_objMemoryImage.SetImageSize(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight);
                            m_smVisionInfo.g_objMemoryImage.LoadImageFromMemory(m_objAVTFireGrab.ref_ptrImagePointer);
                            m_smVisionInfo.g_objMemoryImage.CopyTo(ref m_smVisionInfo.g_arrImages, i);
                            m_smVisionInfo.g_arrImages[i].AddGain(m_smVisionInfo.g_arrImageGain[i]);
                        }
                        if (i == 1)
                        {
                            if (blnSuccess) m_bGrabImage1Result = true;
                            m_bGrabImage1Done = true;
                        }
                        else if (i == 2)
                        {
                            if (blnSuccess) m_bGrabImage2Result = true;
                            m_bGrabImage2Done = true;
                        }
                        else if (i == 3)
                        {
                            if (blnSuccess) m_bGrabImage3Result = true;
                            m_bGrabImage3Done = true;
                        }
                        else if (i == 4)
                        {
                            if (blnSuccess) m_bGrabImage4Result = true;
                            m_bGrabImage4Done = true;
                        }
                        else if (i == 5)
                        {
                            if (blnSuccess) m_bGrabImage5Result = true;
                            m_bGrabImage5Done = true;
                        }
                        else if (i == 6)
                        {
                            if (blnSuccess) m_bGrabImage6Result = true;
                            m_bGrabImage6Done = true;
                        }
                        else if (i == 7)
                        {
                            if (blnSuccess) m_bGrabImage7Result = true;
                            m_bGrabImage7Done = true;
                        }
                    }
                }

                //if (i == 0)
                //{
                //    m_bGrabImage1Done = true;
                //}
                //else if (i == 1)
                //{
                //    m_bGrabImage2Done = true;
                //}
                //else if (i == 2)
                //{
                //    m_bGrabImage3Done = true;
                //}

                m_objAVTFireGrab.ReleaseImage(i);
            }

            if (!blnSuccess)
            {
                SetGrabDone(blnForInspection);
            }

            //for (int i = 0; i < m_intGrabRequire; i++)
            //{
            //    if (blnSeparateGrab)
            //    {
            //        if (i != intSelectedImage)
            //            continue;
            //    }

            //    m_objAVTFireGrab.ReleaseImage(i);
            //}

            if (m_objAVTFireGrab.ref_strErrorText != "")
            {
                m_smVisionInfo.g_strErrorMessage = m_objAVTFireGrab.ref_strErrorText;
                m_smVisionInfo.ALL_VM_UpdatePictureBox = true;
                m_smVisionInfo.g_objTransferTime.Stop();

                return false;
            }
            else
            {
                // Set camera gain
                if (m_intCameraGainPrev != m_smVisionInfo.g_arrCameraGain[0])
                {
                    m_objAVTFireGrab.SetCameraParameter(2, m_smVisionInfo.g_arrCameraGain[0]);
                    m_intCameraGainPrev = m_smVisionInfo.g_arrCameraGain[0];
                }

                // Set camera shuttle
                if (m_fCameraShuttlePrev != m_smVisionInfo.g_arrCameraShuttle[0])
                {
                    m_objAVTFireGrab.SetCameraParameter(1, (uint)m_smVisionInfo.g_arrCameraShuttle[0]);
                    m_fCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[0];
                }

                AttachImageToROI();
                m_smVisionInfo.g_blnLoadFile = false;
                m_smVisionInfo.ALL_VM_UpdatePictureBox = true;
                m_smVisionInfo.g_objTransferTime.Stop();

                return true;
            }
        }

        public bool GrabImage_Sequence_GetFrameBeforeNextGrab_NoSetIntensity_AVTVimba(bool blnForInspection)
        {
            /*
             * Grab each image, get frame, convert frame, assign to imagedrawing by sequence.
             * No grab all first, then only get all frame after.
             * Use this function unless you need to trigger GrabDone signal to software as early as possible.
             */

            if (!m_objAVTFireGrab.ref_blnCameraInitDone)
            {
                m_bGrabImage1Result = m_bGrabImage2Result = m_bGrabImage3Result = m_bGrabImage4Result = m_bGrabImage5Result = m_bGrabImage6Result = m_bGrabImage7Result = true;
                m_bGrabImage1Done = m_bGrabImage2Done = m_bGrabImage3Done = m_bGrabImage4Done = m_bGrabImage5Done = m_bGrabImage6Done = m_bGrabImage7Done = true;
                m_smVisionInfo.g_strErrorMessage = "Camera No Connected";
                return true;
            }

            // Default Using AVT Camera
            m_smVisionInfo.g_objGrabTime.Start();

            Thread.Sleep(m_smVisionInfo.g_intCameraGrabDelay);

            bool blnSuccess = true;
            bool blnSeparateGrab = m_smVisionInfo.g_blnSeparateGrab;
            int intSelectedImage = m_smVisionInfo.g_intSelectedImage;

            m_objAVTFireGrab.DiscardFrame();


            for (int i = 0; i < m_intGrabRequire; i++)
            {
                if (blnSeparateGrab)
                {
                    if (i != intSelectedImage)
                        continue;
                }

                #region if more than 1 image need to be captured
                // Set light source channel ON/OFF
                if (m_intGrabRequire > 1)
                {
                    // Set camera gain
                    if (m_intCameraGainPrev != m_smVisionInfo.g_arrCameraGain[i])
                    {
                        m_objAVTFireGrab.SetCameraParameter_Quick(2, m_smVisionInfo.g_arrCameraGain[i]);
                        m_intCameraGainPrev = m_smVisionInfo.g_arrCameraGain[i];
                    }

                    // Set camera shuttle
                    if (m_fCameraShuttlePrev != m_smVisionInfo.g_arrCameraShuttle[i])
                    {
                        m_objAVTFireGrab.SetCameraParameter_Quick(1, (uint)m_smVisionInfo.g_arrCameraShuttle[i]);
                        m_fCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[i];
                    }
                }

                #endregion
                if (i == 0)
                {
                    m_objAVTFireGrab.QuickOutPort(1, 4);     // Set high to controller's Reset Trigger 
                    m_objAVTFireGrab.QuickOutPort(0, m_smVisionInfo.g_intTriggerMode);
                    Thread.Sleep(1);
                }
                else if (i == (m_intGrabRequire - 1))
                {
                    m_objAVTFireGrab.QuickOutPort(0, 0);
                }

                if (!m_objAVTFireGrab.Grab())
                {
                    blnSuccess = false;
                    m_blnForceStopProduction = true;
                }

                if (i == (m_intGrabRequire - 1))
                {
                    SetGrabDone(blnForInspection);
                    m_smVisionInfo.g_objTransferTime.Start();
                }

                if (m_objAVTFireGrab.GetFrame(i))
                {
                    if (m_objAVTFireGrab.ConvertFrame(i))
                    {
                        if (m_smVisionInfo.g_blnViewColorImage)
                        {
                            m_smVisionInfo.g_objMemoryColorImage.SetImageSize(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight);
                            m_smVisionInfo.g_objMemoryColorImage.LoadImageFromMemory(m_objAVTFireGrab.ref_ptrImagePointer);
                            m_smVisionInfo.g_objMemoryColorImage.CopyTo(ref m_smVisionInfo.g_arrColorImages, i);
                        }
                        else
                        {
                            m_smVisionInfo.g_objMemoryImage.SetImageSize(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight);
                            m_smVisionInfo.g_objMemoryImage.LoadImageFromMemory(m_objAVTFireGrab.ref_ptrImagePointer);
                            m_smVisionInfo.g_objMemoryImage.CopyTo(ref m_smVisionInfo.g_arrImages, i);
                            m_smVisionInfo.g_arrImages[i].AddGain(m_smVisionInfo.g_arrImageGain[i]);
                        }
                        if (i == 0)
                        {
                            if (blnSuccess) m_bGrabImage1Result = true;
                            m_bGrabImage1Done = true;
                        }
                        else if (i == 1)
                        {
                            if (blnSuccess) m_bGrabImage2Result = true;
                            m_bGrabImage2Done = true;
                        }
                        else if (i == 2)
                        {
                            if (blnSuccess) m_bGrabImage3Result = true;
                            m_bGrabImage3Done = true;
                        }
                        else if (i == 3)
                        {
                            if (blnSuccess) m_bGrabImage4Result = true;
                            m_bGrabImage4Done = true;
                        }
                        else if (i == 4)
                        {
                            if (blnSuccess) m_bGrabImage5Result = true;
                            m_bGrabImage5Done = true;
                        }
                        else if (i == 5)
                        {
                            if (blnSuccess) m_bGrabImage6Result = true;
                            m_bGrabImage6Done = true;
                        }
                        else if (i == 6)
                        {
                            if (blnSuccess) m_bGrabImage7Result = true;
                            m_bGrabImage7Done = true;
                        }
                    }
                }

                //if (i == 0)
                //{
                //    m_bGrabImage1Result = true;
                //    m_bGrabImage1Done = true;
                //}
                //else if (i == 1)
                //{
                //    m_bGrabImage2Result = true;
                //    m_bGrabImage2Done = true;
                //}
                //else if (i == 2)
                //{
                //    m_bGrabImage3Result = true;
                //    m_bGrabImage3Done = true;
                //}
                //else if (i == 3)
                //{
                //    m_bGrabImage4Result = true;
                //    m_bGrabImage4Done = true;
                //}
                m_objAVTFireGrab.ReleaseImage(i);
            }

            if (!blnSuccess)
            {
                SetGrabDone(blnForInspection);
            }

            //for (int i = 0; i < m_intGrabRequire; i++)
            //{
            //    if (blnSeparateGrab)
            //    {
            //        if (i != intSelectedImage)
            //            continue;
            //    }

            //    m_objAVTFireGrab.ReleaseImage(i);
            //}

            //Reset outport
            m_objAVTFireGrab.QuickOutPort(1, 5);     // Set Low to controller's Reset Trigger 

            if (m_objAVTFireGrab.ref_strErrorText != "")
            {
                m_smVisionInfo.g_strErrorMessage = m_objAVTFireGrab.ref_strErrorText;
                m_smVisionInfo.ALL_VM_UpdatePictureBox = true;
                m_smVisionInfo.g_objTransferTime.Stop();

                return false;
            }
            else
            {
                // Set camera gain
                if (m_intCameraGainPrev != m_smVisionInfo.g_arrCameraGain[0])
                {
                    m_objAVTFireGrab.SetCameraParameter_Quick(2, m_smVisionInfo.g_arrCameraGain[0]);
                    m_intCameraGainPrev = m_smVisionInfo.g_arrCameraGain[0];
                }

                // Set camera shuttle
                if (m_fCameraShuttlePrev != m_smVisionInfo.g_arrCameraShuttle[0])
                {
                    m_objAVTFireGrab.SetCameraParameter_Quick(1, (uint)m_smVisionInfo.g_arrCameraShuttle[0]);
                    m_fCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[0];
                }

                AttachImageToROI();
                m_smVisionInfo.g_blnLoadFile = false;
                m_smVisionInfo.ALL_VM_UpdatePictureBox = true;
                m_smVisionInfo.g_objTransferTime.Stop();

                return true;
            }
        }
        public bool GrabImage_Sequence_NoSetIntensity_AVT(bool blnForInspection)
        {
#if (DEBUG || Debug_2_12 || RTXDebug)
            return true;
#endif
            // Default Using AVT Camera
            m_smVisionInfo.g_objGrabTime.Start();
            bool blnSuccess = true;
            bool blnSeparateGrab = m_smVisionInfo.g_blnSeparateGrab;
            int intSelectedImage = m_smVisionInfo.g_intSelectedImage;
            HiPerfTimer timer_GrabTime = new HiPerfTimer();

            TrackLog objTL = new TrackLog();
            float fTotalGrabTime = 0f;
            HiPerfTimer timer_TotalTime = new HiPerfTimer();
            HiPerfTimer timer_TotalGrabTime = new HiPerfTimer();
            timer_TotalTime.Start();

            int intExposureTime = (int)Math.Ceiling(m_smVisionInfo.g_fCameraShuttle * 0.02f);

            // Define grab images require
            if (blnForInspection)
            {
                if ((m_smCustomizeInfo.g_intWantPackage & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
                {
                    if (m_intCurrentGrabRequire != m_intGrabRequire)
                        m_intCurrentGrabRequire = m_intGrabRequire;
                }
                else
                {
                    if (m_intCurrentGrabRequire != 1)
                        m_intCurrentGrabRequire = 1;
                }
            }
            else
            {
                // Set to maximum requirement grab image if camera live or grab.
                if (m_intCurrentGrabRequire != m_intGrabRequire)
                    m_intCurrentGrabRequire = m_intGrabRequire;
            }

            timer_TotalGrabTime.Start();
            m_objAVTFireGrab.DiscardFrame();
            timer_TotalGrabTime.Stop();
            fTotalGrabTime = fTotalGrabTime + timer_TotalGrabTime.Duration;

            for (int i = 0; i < m_intCurrentGrabRequire; i++)
            {
                if (blnSeparateGrab)
                {
                    if (i != intSelectedImage)
                        continue;
                }

                if (i > 0) // for second image and third image
                {
                    timer_GrabTime.Stop();
                    if ((m_objAVTFireGrab.ref_intNextGrabDelay - timer_GrabTime.Duration) > 0)
                        Thread.Sleep((int)(m_objAVTFireGrab.ref_intNextGrabDelay - timer_GrabTime.Duration));
                }

                #region if more than 1 image need to be captured
                // Set light source channel ON/OFF
                if (m_intCurrentGrabRequire > 1)
                {
                    // Set camera gain
                    if (m_intCameraGainPrev != m_smVisionInfo.g_arrCameraGain[i])
                    {
                        m_objAVTFireGrab.SetCameraParameter(2, m_smVisionInfo.g_arrCameraGain[i]);
                        m_intCameraGainPrev = m_smVisionInfo.g_arrCameraGain[i];
                        if (m_objAVTFireGrab.ref_intSetGainDelay != 0)
                            Thread.Sleep(m_objAVTFireGrab.ref_intSetGainDelay);
                    }

                    // Set camera shuttle
                    if (m_fCameraShuttlePrev != m_smVisionInfo.g_arrCameraShuttle[i])
                    {
                        m_objAVTFireGrab.SetCameraParameter(1, (uint)m_smVisionInfo.g_arrCameraShuttle[i]);
                        m_fCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[i];
                        if (m_objAVTFireGrab.ref_intSetGainDelay != 0)
                            Thread.Sleep(m_objAVTFireGrab.ref_intSetGainDelay);

                        intExposureTime = (int)Math.Ceiling(m_smVisionInfo.g_arrCameraShuttle[i] * 0.02f);
                    }
                }
                #endregion
                if (i == 0)
                {
                    m_objAVTFireGrab.OutPort(1, 4);
                }

                timer_TotalGrabTime.Start();
                if (!m_objAVTFireGrab.Grab())
                {
                    blnSuccess = false;
                    m_blnForceStopProduction = true;
                }
                timer_TotalGrabTime.Stop();
                fTotalGrabTime = fTotalGrabTime + timer_TotalGrabTime.Duration;

                if (i < m_intCurrentGrabRequire - 1)
                {
                    timer_GrabTime.Start();
                    Thread.Sleep(intExposureTime);
                }
                else
                {
                    Thread.Sleep(Math.Max(intExposureTime, 4));
                }

            }

            if (blnSuccess)
            {
                SetGrabDone(blnForInspection);
                m_smVisionInfo.g_objTransferTime.Start();

                for (int i = 0; i < m_intCurrentGrabRequire; i++)
                {
                    if (blnSeparateGrab)
                    {
                        if (i != intSelectedImage)
                            continue;
                    }

                    timer_TotalGrabTime.Start();
                    if (m_objAVTFireGrab.GetFrame(i))
                    {
                        if (m_objAVTFireGrab.ConvertFrame(i))
                        {
                            if (m_smVisionInfo.g_blnViewColorImage)
                            {
                                m_smVisionInfo.g_objMemoryColorImage.SetImageSize(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight);
                                m_smVisionInfo.g_objMemoryColorImage.LoadImageFromMemory(m_objAVTFireGrab.ref_ptrImagePointer);
                                m_smVisionInfo.g_objMemoryColorImage.CopyTo(ref m_smVisionInfo.g_arrColorImages, i);
                            }
                            else
                            {
                                m_smVisionInfo.g_objMemoryImage.SetImageSize(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight);
                                m_smVisionInfo.g_objMemoryImage.LoadImageFromMemory(m_objAVTFireGrab.ref_ptrImagePointer);
                                m_smVisionInfo.g_objMemoryImage.CopyTo(ref m_smVisionInfo.g_arrImages, i);
                                m_smVisionInfo.g_arrImages[i].AddGain(m_smVisionInfo.g_arrImageGain[i]);
                            }
                        }
                    }
                    timer_TotalGrabTime.Stop();
                    fTotalGrabTime = fTotalGrabTime + timer_TotalGrabTime.Duration;
                }
            }
            else
                SetGrabDone(blnForInspection);

            for (int i = 0; i < m_intCurrentGrabRequire; i++)
            {
                if (blnSeparateGrab)
                {
                    if (i != intSelectedImage)
                        continue;
                }

                timer_TotalGrabTime.Start();
                m_objAVTFireGrab.ReleaseImage(i);
                timer_TotalGrabTime.Stop();
                fTotalGrabTime = fTotalGrabTime + timer_TotalGrabTime.Duration;
            }

            //Reset outport
            m_objAVTFireGrab.OutPort(1, 5);
            //m_objAVTFireGrab.OutPort(0, 0);

            if (m_objAVTFireGrab.ref_strErrorText != "")
            {
                m_smVisionInfo.g_strErrorMessage = m_objAVTFireGrab.ref_strErrorText;
                m_smVisionInfo.ALL_VM_UpdatePictureBox = true;
                m_smVisionInfo.g_objTransferTime.Stop();
                return false;
            }
            else
            {
                // Set camera gain
                if (m_intCameraGainPrev != m_smVisionInfo.g_arrCameraGain[0])
                {
                    m_objAVTFireGrab.SetCameraParameter(2, m_smVisionInfo.g_arrCameraGain[0]);
                    m_intCameraGainPrev = m_smVisionInfo.g_arrCameraGain[0];
                }

                // Set camera shuttle
                if (m_fCameraShuttlePrev != m_smVisionInfo.g_arrCameraShuttle[0])
                {
                    m_objAVTFireGrab.SetCameraParameter(1, (uint)m_smVisionInfo.g_arrCameraShuttle[0]);
                    m_fCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[0];
                }

                AttachImageToROI();
                m_smVisionInfo.g_blnLoadFile = false;
                m_smVisionInfo.ALL_VM_UpdatePictureBox = true;
                m_smVisionInfo.g_objTransferTime.Stop();

                timer_TotalTime.Stop();
                //objTL.WriteLine("Total grab time = " + ((timer_TotalTime.Duration - fTotalGrabTime).ToString()));
                //objTL.WriteLine("Total grab time = " + timer_TotalTime.Duration.ToString());
                return true;
            }
        }

        public bool GrabImage_Sequence_NoSetIntensity_Teli(bool blnForInspection)
        {
            if (!m_objTeliCamera.IsCameraInitDone())
            {
                m_bGrabImage1Result = m_bGrabImage2Result = m_bGrabImage3Result = m_bGrabImage4Result = m_bGrabImage5Result = m_bGrabImage6Result = m_bGrabImage7Result = true;
                m_bGrabImage1Done = m_bGrabImage2Done = m_bGrabImage3Done = m_bGrabImage4Done = m_bGrabImage5Done = m_bGrabImage6Done = m_bGrabImage7Done = true;
                m_smVisionInfo.g_strErrorMessage = "Camera No Connected";
                return true;
            }

            // Using Teli Camera
            m_smVisionInfo.g_objGrabTime.Start();

            Thread.Sleep(m_smVisionInfo.g_intCameraGrabDelay);

            bool blnSuccess = true;
            bool blnSeparateGrab = m_smVisionInfo.g_blnSeparateGrab;
            int intSelectedImage = m_smVisionInfo.g_intSelectedImage;

            for (int i = 0; i < m_intGrabRequire; i++)
            {
                if (blnSeparateGrab)
                {
                    if (i != intSelectedImage)
                        continue;
                }

                if (i > 0) // for second image and third image
                {
                    if (m_objTeliCamera.WaitFrameReady())
                    {
                        if (m_smVisionInfo.g_blnViewColorImage)
                        {
                            m_smVisionInfo.g_objMemoryColorImage.SetImageSize(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight);
                            m_smVisionInfo.g_objMemoryColorImage.LoadImageFromMemory(m_objTeliCamera.GetImagePointer());
                            m_smVisionInfo.g_objMemoryColorImage.CopyTo(ref m_smVisionInfo.g_arrColorImages, i - 1);
                        }
                        else
                        {
                            m_smVisionInfo.g_objMemoryImage.SetImageSize(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight);
                            m_smVisionInfo.g_objMemoryImage.LoadImageFromMemory(m_objTeliCamera.GetImagePointer());

                            if (m_smProductionInfo.g_blnAllRunGrabWithoutUseImage)
                            {
                                if (m_smVisionInfo.g_arrDebugImages.Count != m_smVisionInfo.g_arrImages.Count)
                                {
                                    for (int d = 0; d < m_smVisionInfo.g_arrImages.Count; d++)
                                    {
                                        m_smVisionInfo.g_arrDebugImages.Add(new ImageDrawing(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight));
                                    }
                                }

                                if (m_smVisionInfo.g_intRotateFlip == 1)
                                {
                                    ImageDrawing.Rotate0Degree_Diff(m_smVisionInfo.g_objMemoryImage, 180, ref m_smVisionInfo.g_arrDebugImages, i - 1);
                                    m_smVisionInfo.g_arrDebugImages[i - 1].AddGain(m_smVisionInfo.g_arrImageGain[i - 1]);
                                }
                                else
                                {
                                    m_smVisionInfo.g_objMemoryImage.CopyTo(ref m_smVisionInfo.g_arrDebugImages, i - 1);
                                    m_smVisionInfo.g_arrDebugImages[i - 1].AddGain(m_smVisionInfo.g_arrImageGain[i - 1]);
                                }
                            }
                            else
                            {
                                if (m_smVisionInfo.g_intRotateFlip == 1)
                                {
                                    ImageDrawing.Rotate0Degree_Diff(m_smVisionInfo.g_objMemoryImage, 180, ref m_smVisionInfo.g_arrImages, i - 1);
                                    m_smVisionInfo.g_arrImages[i - 1].AddGain(m_smVisionInfo.g_arrImageGain[i - 1]);
                                }
                                else
                                {
                                    m_smVisionInfo.g_objMemoryImage.CopyTo(ref m_smVisionInfo.g_arrImages, i - 1);
                                    m_smVisionInfo.g_arrImages[i - 1].AddGain(m_smVisionInfo.g_arrImageGain[i - 1]);
                                }
                            }

                            if (i == 1)
                            {
                                if (m_smVisionInfo.g_blnEnhanceImage_Enable)
                                {
                                    if (m_smVisionInfo.g_intEnhanceImage_Close > 0)
                                        m_smVisionInfo.g_arrImages[0].AddCloseMorphology(m_smVisionInfo.g_intEnhanceImage_Close);
                                    if (m_smVisionInfo.g_intEnhanceImage_Open > 0)
                                        m_smVisionInfo.g_arrImages[0].AddOpenMorphology(m_smVisionInfo.g_intEnhanceImage_Open);
                                    if (m_smVisionInfo.g_intEnhanceImage_Dilate > 0)
                                        m_smVisionInfo.g_arrImages[0].AddDilate(m_smVisionInfo.g_intEnhanceImage_Dilate);
                                    if (m_smVisionInfo.g_intEnhanceImage_Offset != 0)
                                        m_smVisionInfo.g_arrImages[0].AddOffset(m_smVisionInfo.g_intEnhanceImage_Offset);
                                    if (m_smVisionInfo.g_fEnhanceImage_Gain != 1f)
                                        m_smVisionInfo.g_arrImages[0].AddGain(m_smVisionInfo.g_fEnhanceImage_Gain);
                                }
                            }
                        }

                    }
                    else
                    {
                        blnSuccess = false;
                        m_blnForceStopProduction = true;
                    }

                    if (i == 1)
                    {
                        if (m_smVisionInfo.g_blnSaveImageAfterGrab && blnForInspection) m_smVisionInfo.g_arrImages[i - 1].SaveImage("D:\\TS\\" + m_smVisionInfo.g_strVisionFolderName + "\\" + m_intCounter + ".bmp");
                        if (blnSuccess) m_bGrabImage1Result = true;
                        m_bGrabImage1Done = true;
                    }
                    else if (i == 2)
                    {
                        if (m_smVisionInfo.g_blnSaveImageAfterGrab && blnForInspection) m_smVisionInfo.g_arrImages[i - 1].SaveImage("D:\\TS\\" + m_smVisionInfo.g_strVisionFolderName + "\\" + m_intCounter + "_Image" + (i - 1) + ".bmp");
                        if (blnSuccess) m_bGrabImage2Result = true;
                        m_bGrabImage2Done = true;
                    }
                    else if (i == 3)
                    {
                        if (m_smVisionInfo.g_blnSaveImageAfterGrab && blnForInspection) m_smVisionInfo.g_arrImages[i - 1].SaveImage("D:\\TS\\" + m_smVisionInfo.g_strVisionFolderName + "\\" + m_intCounter + "_Image" + (i - 1) + ".bmp");
                        if (blnSuccess) m_bGrabImage3Result = true;
                        m_bGrabImage3Done = true;
                    }
                    else if (i == 4)
                    {
                        if (m_smVisionInfo.g_blnSaveImageAfterGrab && blnForInspection) m_smVisionInfo.g_arrImages[i - 1].SaveImage("D:\\TS\\" + m_smVisionInfo.g_strVisionFolderName + "\\" + m_intCounter + "_Image" + (i - 1) + ".bmp");
                        if (blnSuccess) m_bGrabImage4Result = true;
                        m_bGrabImage4Done = true;
                    }
                    else if (i == 5)
                    {
                        if (m_smVisionInfo.g_blnSaveImageAfterGrab && blnForInspection) m_smVisionInfo.g_arrImages[i - 1].SaveImage("D:\\TS\\" + m_smVisionInfo.g_strVisionFolderName + "\\" + m_intCounter + "_Image" + (i - 1) + ".bmp");
                        if (blnSuccess) m_bGrabImage5Result = true;
                        m_bGrabImage5Done = true;
                    }
                    else if (i == 6)
                    {
                        if (m_smVisionInfo.g_blnSaveImageAfterGrab && blnForInspection) m_smVisionInfo.g_arrImages[i - 1].SaveImage("D:\\TS\\" + m_smVisionInfo.g_strVisionFolderName + "\\" + m_intCounter + "_Image" + (i - 1) + ".bmp");
                        if (blnSuccess) m_bGrabImage6Result = true;
                        m_bGrabImage6Done = true;
                    }
                    else if (i == 7)
                    {
                        if (m_smVisionInfo.g_blnSaveImageAfterGrab && blnForInspection) m_smVisionInfo.g_arrImages[i - 1].SaveImage("D:\\TS\\" + m_smVisionInfo.g_strVisionFolderName + "\\" + m_intCounter + "_Image" + (i - 1) + ".bmp");
                        if (blnSuccess) m_bGrabImage7Result = true;
                        m_bGrabImage7Done = true;
                    }
                }

                #region if more than 1 image need to be captured
                // Set light source channel ON/OFF
                if (m_intGrabRequire > 1)
                {
                    // Set camera gain
                    if (m_intCameraGainPrev != m_smVisionInfo.g_arrCameraGain[i])
                    {
                        m_objTeliCamera.SetCameraParameter(2, m_smVisionInfo.g_arrCameraGain[i]);
                        m_intCameraGainPrev = m_smVisionInfo.g_arrCameraGain[i];
                        m_uintEmptyCameraGainPrev = m_smVisionInfo.g_arrCameraGain[i];
                        //if (m_objTeliCamera.ref_intSetGainDelay != 0)
                        //    Thread.Sleep(m_objTeliCamera.ref_intSetGainDelay);
                    }

                    // Set camera shuttle
                    if (m_fCameraShuttlePrev != m_smVisionInfo.g_arrCameraShuttle[i])
                    {
                        m_objTeliCamera.SetCameraParameter(1, m_smVisionInfo.g_arrCameraShuttle[i]);
                        m_fCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[i];
                        m_fEmptyCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[i];
                        //if (m_objTeliCamera.ref_intSetGainDelay != 0)
                        //    Thread.Sleep(m_objTeliCamera.ref_intSetGainDelay);
                    }
                }
                #endregion
                if (i == 0)
                {

                    //10-07-2019 ZJYEOH : Check the shuttle and gain again because PH got other setting
                    m_uintEmptyCameraGainPrev = 1;
                    m_fEmptyCameraShuttlePrev = 1f;
                    // Set camera gain
                    if (m_intCameraGainPrev != m_smVisionInfo.g_arrCameraGain[i])
                    {
                        m_objTeliCamera.SetCameraParameter(2, m_smVisionInfo.g_arrCameraGain[i]);
                        m_intCameraGainPrev = m_smVisionInfo.g_arrCameraGain[i];
                        m_uintEmptyCameraGainPrev = m_smVisionInfo.g_arrCameraGain[i];
                        //if (m_objTeliCamera.ref_intSetGainDelay != 0)
                        //    Thread.Sleep(m_objTeliCamera.ref_intSetGainDelay);
                    }

                    // Set camera shuttle
                    if (m_fCameraShuttlePrev != m_smVisionInfo.g_arrCameraShuttle[i])
                    {
                        m_objTeliCamera.SetCameraParameter(1, m_smVisionInfo.g_arrCameraShuttle[i]);
                        m_fCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[i];
                        m_fEmptyCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[i];
                        //if (m_objTeliCamera.ref_intSetGainDelay != 0)
                        //    Thread.Sleep(m_objTeliCamera.ref_intSetGainDelay);
                    }

                    if (!m_smCustomizeInfo.g_blnMixController)
                    {
                        if (m_smCustomizeInfo.g_blnVTControl)
                        {
                            m_objTeliCamera.OutPort(1, 3);
                        }
                    }
                    else
                    {
                        if (m_intLightControlModel == 1) // 2018 07 13 - CCENG: Temporary force to use VTControl
                        {
                            m_objTeliCamera.OutPort(1, 3);
                        }
                    }

                }

                if (blnSuccess)//2021-10-21 ZJYEOH : No need to grab anymore if not success, as this will reset the camera error message
                {
                    if (!m_objTeliCamera.Grab())
                    {
                        blnSuccess = false;
                        m_blnForceStopProduction = true;
                    }
                }
            }

            if (!m_objTeliCamera.WaitFrameReady())
            {
                blnSuccess = false;
                m_blnForceStopProduction = true;
            }

            if (blnSuccess)
            {
                SetGrabDone(blnForInspection);
                m_smVisionInfo.g_objTransferTime.Start();

                if (m_objTeliCamera.GetFrame(m_intGrabRequire - 1))
                {
                    if (m_objTeliCamera.ConvertFrame(m_intGrabRequire - 1))
                    {
                        if (m_smVisionInfo.g_blnViewColorImage)
                        {
                            m_smVisionInfo.g_objMemoryColorImage.SetImageSize(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight);
                            m_smVisionInfo.g_objMemoryColorImage.LoadImageFromMemory(m_objTeliCamera.GetImagePointer());
                            m_smVisionInfo.g_objMemoryColorImage.CopyTo(ref m_smVisionInfo.g_arrColorImages, m_intGrabRequire - 1);
                        }
                        else
                        {
                            m_smVisionInfo.g_objMemoryImage.SetImageSize(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight);
                            m_smVisionInfo.g_objMemoryImage.LoadImageFromMemory(m_objTeliCamera.GetImagePointer());

                            if (m_smProductionInfo.g_blnAllRunGrabWithoutUseImage)
                            {
                                if (m_smVisionInfo.g_arrDebugImages.Count != m_smVisionInfo.g_arrImages.Count)
                                {
                                    for (int d = 0; d < m_smVisionInfo.g_arrImages.Count; d++)
                                    {
                                        m_smVisionInfo.g_arrDebugImages.Add(new ImageDrawing(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight));
                                    }
                                }

                                if (m_smVisionInfo.g_intRotateFlip == 1)
                                {
                                    ImageDrawing.Rotate0Degree_Diff(m_smVisionInfo.g_objMemoryImage, 180, ref m_smVisionInfo.g_arrDebugImages, m_intGrabRequire - 1);
                                    m_smVisionInfo.g_arrDebugImages[m_intGrabRequire - 1].AddGain(m_smVisionInfo.g_arrImageGain[m_intGrabRequire - 1]);
                                }
                                else
                                {
                                    m_smVisionInfo.g_objMemoryImage.CopyTo(ref m_smVisionInfo.g_arrDebugImages, m_intGrabRequire - 1);
                                    m_smVisionInfo.g_arrDebugImages[m_intGrabRequire - 1].AddGain(m_smVisionInfo.g_arrImageGain[m_intGrabRequire - 1]);
                                }


                            }
                            else
                            {

                                if (m_smVisionInfo.g_intRotateFlip == 1)
                                {
                                    ImageDrawing.Rotate0Degree_Diff(m_smVisionInfo.g_objMemoryImage, 180, ref m_smVisionInfo.g_arrImages, m_intGrabRequire - 1);
                                    m_smVisionInfo.g_arrImages[m_intGrabRequire - 1].AddGain(m_smVisionInfo.g_arrImageGain[m_intGrabRequire - 1]);
                                }
                                else
                                {
                                    m_smVisionInfo.g_objMemoryImage.CopyTo(ref m_smVisionInfo.g_arrImages, m_intGrabRequire - 1);
                                    m_smVisionInfo.g_arrImages[m_intGrabRequire - 1].AddGain(m_smVisionInfo.g_arrImageGain[m_intGrabRequire - 1]);
                                }

                            }
                        }
                        if (m_intGrabRequire == 1)
                        {
                            if (m_smVisionInfo.g_blnSaveImageAfterGrab && blnForInspection) m_smVisionInfo.g_arrImages[m_intGrabRequire - 1].SaveImage("D:\\TS\\" + m_smVisionInfo.g_strVisionFolderName + "\\" + m_intCounter + ".bmp");
                            if (blnSuccess) m_bGrabImage1Result = true;
                            m_bGrabImage1Done = true;
                        }
                        else if (m_intGrabRequire == 2)
                        {
                            if (m_smVisionInfo.g_blnSaveImageAfterGrab && blnForInspection) m_smVisionInfo.g_arrImages[m_intGrabRequire - 1].SaveImage("D:\\TS\\" + m_smVisionInfo.g_strVisionFolderName + "\\" + m_intCounter + "_Image" + (m_intGrabRequire - 1) + ".bmp");
                            if (blnSuccess) m_bGrabImage2Result = true;
                            m_bGrabImage2Done = true;
                        }
                        else if (m_intGrabRequire == 3)
                        {
                            if (m_smVisionInfo.g_blnSaveImageAfterGrab && blnForInspection) m_smVisionInfo.g_arrImages[m_intGrabRequire - 1].SaveImage("D:\\TS\\" + m_smVisionInfo.g_strVisionFolderName + "\\" + m_intCounter + "_Image" + (m_intGrabRequire - 1) + ".bmp");
                            if (blnSuccess) m_bGrabImage3Result = true;
                            m_bGrabImage3Done = true;
                        }
                        else if (m_intGrabRequire == 4)
                        {
                            if (m_smVisionInfo.g_blnSaveImageAfterGrab && blnForInspection) m_smVisionInfo.g_arrImages[m_intGrabRequire - 1].SaveImage("D:\\TS\\" + m_smVisionInfo.g_strVisionFolderName + "\\" + m_intCounter + "_Image" + (m_intGrabRequire - 1) + ".bmp");
                            if (blnSuccess) m_bGrabImage4Result = true;
                            m_bGrabImage4Done = true;
                        }
                        else if (m_intGrabRequire == 5)
                        {
                            if (m_smVisionInfo.g_blnSaveImageAfterGrab && blnForInspection) m_smVisionInfo.g_arrImages[m_intGrabRequire - 1].SaveImage("D:\\TS\\" + m_smVisionInfo.g_strVisionFolderName + "\\" + m_intCounter + "_Image" + (m_intGrabRequire - 1) + ".bmp");
                            if (blnSuccess) m_bGrabImage5Result = true;
                            m_bGrabImage5Done = true;
                        }
                        else if (m_intGrabRequire == 6)
                        {
                            if (m_smVisionInfo.g_blnSaveImageAfterGrab && blnForInspection) m_smVisionInfo.g_arrImages[m_intGrabRequire - 1].SaveImage("D:\\TS\\" + m_smVisionInfo.g_strVisionFolderName + "\\" + m_intCounter + "_Image" + (m_intGrabRequire - 1) + ".bmp");
                            if (blnSuccess) m_bGrabImage6Result = true;
                            m_bGrabImage6Done = true;
                        }
                        else if (m_intGrabRequire == 7)
                        {
                            if (m_smVisionInfo.g_blnSaveImageAfterGrab && blnForInspection) m_smVisionInfo.g_arrImages[m_intGrabRequire - 1].SaveImage("D:\\TS\\" + m_smVisionInfo.g_strVisionFolderName + "\\" + m_intCounter + "_Image" + (m_intGrabRequire - 1) + ".bmp");
                            if (blnSuccess) m_bGrabImage7Result = true;
                            m_bGrabImage7Done = true;
                        }
                    }
                }
            }
            else
                SetGrabDone(blnForInspection);

            m_bGrabImage1Done = m_bGrabImage2Done = m_bGrabImage3Done = m_bGrabImage4Done = m_bGrabImage5Done = m_bGrabImage6Done = m_bGrabImage7Done = true;

            //Reset outport
            if (!m_smCustomizeInfo.g_blnMixController)
            {
                if (m_smCustomizeInfo.g_blnLEDiControl)
                {
                    m_objTeliCamera.OutPort(1, 3);
                    Thread.Sleep(3);
                    m_objTeliCamera.OutPort(1, 0);
                }
                else if (m_smCustomizeInfo.g_blnVTControl)
                {
                    m_objTeliCamera.OutPort(1, 0);
                }
            }
            else
            {
                if (m_intLightControlModel == 0) // 2018 07 13 - CCENG: Temporary force to use VTControl
                {
                    m_objTeliCamera.OutPort(1, 3);
                    Thread.Sleep(3);
                    m_objTeliCamera.OutPort(1, 0);
                }
                else if (m_intLightControlModel == 1) // 2018 07 13 - CCENG: Temporary force to use VTControl
                {
                    m_objTeliCamera.OutPort(1, 0);
                }

            }

            //2021-10-21 ZJYEOH : Set Image to Black if camera fail
            if (!blnSuccess)
            {
                for (int i = 0; i < m_smVisionInfo.g_arrImages.Count; i++)
                {
                    if (m_smVisionInfo.g_blnViewColorImage)
                    {
                        m_smVisionInfo.g_arrColorImages[i].SetImageToBlack();
                        m_smVisionInfo.g_arrColorRotatedImages[i].SetImageToBlack();
                    }
                    m_smVisionInfo.g_arrImages[i].SetImageToBlack();
                    m_smVisionInfo.g_arrRotatedImages[i].SetImageToBlack();
                }
            }

            if (m_objTeliCamera.GetErrorMessage() != "")
            {
                m_smVisionInfo.g_strErrorMessage = m_objTeliCamera.GetErrorMessage();
                m_smVisionInfo.ALL_VM_UpdatePictureBox = true;
                m_smVisionInfo.g_objTransferTime.Stop();

                return false;
            }
            else
            {
                // Set camera gain
                if (m_intCameraGainPrev != m_smVisionInfo.g_arrCameraGain[0])
                {
                    m_objTeliCamera.SetCameraParameter(2, m_smVisionInfo.g_arrCameraGain[0]);
                    m_intCameraGainPrev = m_smVisionInfo.g_arrCameraGain[0];
                    m_uintEmptyCameraGainPrev = m_smVisionInfo.g_arrCameraGain[0];

                }

                // Set camera shuttle
                if (m_fCameraShuttlePrev != m_smVisionInfo.g_arrCameraShuttle[0])
                {
                    m_objTeliCamera.SetCameraParameter(1, m_smVisionInfo.g_arrCameraShuttle[0]);
                    m_fCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[0];
                    m_fEmptyCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[0];
                }

                if (m_smVisionInfo.g_bImageStatisticAnalysisON)
                {
                    m_smVisionInfo.g_bImageStatisticAnalysisUpdateInfo = true;

                    while (true)
                    {
                        if (!m_smVisionInfo.g_bImageStatisticAnalysisUpdateInfo)
                            break;

                        Thread.Sleep(1);
                    }
                }

                //AttachImageToROI();
                m_smVisionInfo.g_blnLoadFile = false;
                m_smVisionInfo.ALL_VM_UpdatePictureBox = true;
                m_smVisionInfo.g_objTransferTime.Stop();

                return true;
            }
        }
        public bool GrabImage_Sequence_NoSetIntensity_Teli_GrabAllFirst(bool blnForInspection)
        {
            if (!m_objTeliCamera.IsCameraInitDone())
            {
                m_bGrabImage1Result = m_bGrabImage2Result = m_bGrabImage3Result = m_bGrabImage4Result = m_bGrabImage5Result = m_bGrabImage6Result = m_bGrabImage7Result = true;
                m_bGrabImage1Done = m_bGrabImage2Done = m_bGrabImage3Done = m_bGrabImage4Done = m_bGrabImage5Done = m_bGrabImage6Done = m_bGrabImage7Done = true;
                m_smVisionInfo.g_strErrorMessage = "Camera No Connected";
                return true;
            }

            // Using Teli Camera
            m_smVisionInfo.g_objGrabTime.Start();

            // Set camera gain
            if (m_intCameraGainPrev != m_smVisionInfo.g_arrCameraGain[0])
            {
                m_objTeliCamera.SetCameraParameter(2, m_smVisionInfo.g_arrCameraGain[0]);
                m_intCameraGainPrev = m_smVisionInfo.g_arrCameraGain[0];
                m_uintEmptyCameraGainPrev = m_smVisionInfo.g_arrCameraGain[0];
                //if (m_objTeliCamera.ref_intSetGainDelay != 0)
                //    Thread.Sleep(m_objTeliCamera.ref_intSetGainDelay);
            }

            // Set camera shuttle
            if (m_fCameraShuttlePrev != m_smVisionInfo.g_arrCameraShuttle[0])
            {
                m_objTeliCamera.SetCameraParameter(1, m_smVisionInfo.g_arrCameraShuttle[0]);
                m_fCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[0];
                m_fEmptyCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[0];
                //if (m_objTeliCamera.ref_intSetGainDelay != 0)
                //    Thread.Sleep(m_objTeliCamera.ref_intSetGainDelay);
            }

            Thread.Sleep(m_smVisionInfo.g_intCameraGrabDelay);

            bool blnSuccess = true;
            bool blnSeparateGrab = m_smVisionInfo.g_blnSeparateGrab;
            int intSelectedImage = m_smVisionInfo.g_intSelectedImage;

            TrackLog objTL = new TrackLog();
            float fTotalGrabTime = 0f;
            HiPerfTimer timer_TotalTime = new HiPerfTimer();
            HiPerfTimer timer_TotalGrabTime = new HiPerfTimer();
            timer_TotalTime.Start();
            m_arrBufferPointer = new List<IntPtr>();

            for (int i = 0; i < m_intGrabRequire; i++)
            {

                if (i > 0)
                {
                    if (m_objTeliCamera.WaitTriggerWaitDone())
                    {
                        // Set camera gain
                        if (m_intCameraGainPrev != m_smVisionInfo.g_arrCameraGain[i])
                        {
                            m_objTeliCamera.SetCameraParameter(2, m_smVisionInfo.g_arrCameraGain[i]);
                            m_intCameraGainPrev = m_smVisionInfo.g_arrCameraGain[i];
                            m_uintEmptyCameraGainPrev = m_smVisionInfo.g_arrCameraGain[i];
                        }

                        if (/*!blnStartGrab &&*/ !m_objTeliCamera.Grab(i))
                        {
                            blnSuccess = false;
                            m_blnForceStopProduction = true;
                        }
                    }
                    else
                    {
                        blnSuccess = false;
                        m_blnForceStopProduction = true;
                    }
                }
                else
                {
                    if (/*!blnStartGrab &&*/ !m_objTeliCamera.Grab(i))
                    {
                        blnSuccess = false;
                        m_blnForceStopProduction = true;
                    }
                }

                //Set light source channel ON / OFF
                if (m_intGrabRequire > 1 && ((i + 1) < m_smVisionInfo.g_arrCameraShuttle.Count))
                {

                    // Set camera shuttle
                    if (m_fCameraShuttlePrev != m_smVisionInfo.g_arrCameraShuttle[i + 1])
                    {
                        m_objTeliCamera.SetCameraParameter(1, m_smVisionInfo.g_arrCameraShuttle[i + 1]);
                        m_fCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[i + 1];
                        m_fEmptyCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[i + 1];
                        //if (m_objTeliCamera.ref_intSetGainDelay != 0)
                        //    Thread.Sleep(m_objTeliCamera.ref_intSetGainDelay);
                    }

                }

                if (!m_objTeliCamera.WaitFrameAcquiredReady(i))
                {
                    blnSuccess = false;
                    m_blnForceStopProduction = true;
                }

            }

            if (blnSuccess)
            {
                //m_objTeliCamera.TriggerImageBufferRead();
                SetGrabDone(blnForInspection);
                m_smVisionInfo.g_objTransferTime.Start();

            }
            else
                SetGrabDone(blnForInspection);

            if (!m_objTeliCamera.WaitTriggerWaitDone())
            {
                blnSuccess = false;
                m_blnForceStopProduction = true;
            }

            for (int i = 0; i < m_intGrabRequire; i++)
            {
                if (m_smProductionInfo.g_blnAllRunGrabWithoutUseImage)
                {
                    if (m_smVisionInfo.g_blnViewColorImage)
                    {
                        if (m_smVisionInfo.g_arrDebugColorImages.Count != m_smVisionInfo.g_arrColorImages.Count)
                        {
                            for (int d = 0; d < m_smVisionInfo.g_arrColorImages.Count; d++)
                            {
                                m_smVisionInfo.g_arrDebugColorImages.Add(new CImageDrawing(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight));
                            }
                        }
                        m_objTeliCamera.ConvertImage(i);
                        m_smVisionInfo.g_arrMemoryColorImage[i].LoadImageFromMemory(m_objTeliCamera.GetImagePointer());

                        if (m_smVisionInfo.g_intRotateFlip == 1)
                        {
                            m_smVisionInfo.g_arrMemoryColorImage[i].Rotate180Image(ref m_smVisionInfo.g_arrCRotateImage, i);
                        }
                        else if (m_smVisionInfo.g_intRotateFlip == 2)
                        {
                            m_smVisionInfo.g_arrMemoryColorImage[i].Rotate90Image(ref m_smVisionInfo.g_arrCRotateImage, i);
                        }
                        else if (m_smVisionInfo.g_intRotateFlip == 3)
                        {
                            m_smVisionInfo.g_arrMemoryColorImage[i].RotateMinus90Image(ref m_smVisionInfo.g_arrCRotateImage, i);
                        }
                        else if (m_smVisionInfo.g_intRotateFlip == 4)
                        {
                            m_smVisionInfo.g_arrMemoryColorImage[i].FlipHorizontalImage(ref m_smVisionInfo.g_arrCRotateImage, i);
                        }
                        else if (m_smVisionInfo.g_intRotateFlip == 5)
                        {
                            m_smVisionInfo.g_arrMemoryColorImage[i].FlipVerticalImage(ref m_smVisionInfo.g_arrCRotateImage, i);
                        }
                        else
                        {
                            m_smVisionInfo.g_arrMemoryColorImage[i].CopyTo(ref m_smVisionInfo.g_arrCRotateImage, i);
                        }

                        m_smVisionInfo.g_arrCRotateImage[i].CopyTo(ref m_smVisionInfo.g_arrDebugColorImages, i);

                        if (m_smVisionInfo.g_arrImageGain[i] != 1f)
                        {
                            m_smVisionInfo.g_arrColorImages[i].AddGain(m_smVisionInfo.g_arrImageGain[i], m_smVisionInfo.g_intColorFormat);
                        }
                        m_smVisionInfo.g_arrDebugColorImages[i].ConvertColorToMono(ref m_smVisionInfo.g_arrDebugImages, i);
                    }
                }
                else
                {
                    if (m_smVisionInfo.g_blnViewColorImage)
                    {
                        //m_objTeliCamera.ConvertImage(i);
                        //m_objTeliCamera.ConvertImage(/*m_arrBitmapData[i],*/ m_arrBufferPointer[i]);
                        m_objTeliCamera.ConvertImage(i);
                        m_smVisionInfo.g_arrMemoryColorImage[i].LoadImageFromMemory(m_objTeliCamera.GetImagePointer());

                        if (m_smVisionInfo.g_intRotateFlip == 1)
                        {
                            m_smVisionInfo.g_arrMemoryColorImage[i].Rotate180Image(ref m_smVisionInfo.g_arrCRotateImage, i);
                        }
                        else if (m_smVisionInfo.g_intRotateFlip == 2)
                        {
                            m_smVisionInfo.g_arrMemoryColorImage[i].Rotate90Image(ref m_smVisionInfo.g_arrCRotateImage, i);
                        }
                        else if (m_smVisionInfo.g_intRotateFlip == 3)
                        {
                            m_smVisionInfo.g_arrMemoryColorImage[i].RotateMinus90Image(ref m_smVisionInfo.g_arrCRotateImage, i);
                        }
                        else if (m_smVisionInfo.g_intRotateFlip == 4)
                        {
                            m_smVisionInfo.g_arrMemoryColorImage[i].FlipHorizontalImage(ref m_smVisionInfo.g_arrCRotateImage, i);
                        }
                        else if (m_smVisionInfo.g_intRotateFlip == 5)
                        {
                            m_smVisionInfo.g_arrMemoryColorImage[i].FlipVerticalImage(ref m_smVisionInfo.g_arrCRotateImage, i);
                        }
                        else
                        {
                            m_smVisionInfo.g_arrMemoryColorImage[i].CopyTo(ref m_smVisionInfo.g_arrCRotateImage, i);
                        }

                        m_smVisionInfo.g_arrCRotateImage[i].CopyTo(ref m_smVisionInfo.g_arrColorImages, i);

                        if (m_smVisionInfo.g_arrImageGain[i] != 1f)
                        {
                            m_smVisionInfo.g_arrColorImages[i].AddGain(m_smVisionInfo.g_arrImageGain[i], m_smVisionInfo.g_intColorFormat);
                        }

                        m_smVisionInfo.g_arrColorImages[i].ConvertColorToMono(ref m_smVisionInfo.g_arrImages, i);

                    }
                }

                if (m_smProductionInfo.g_blnAllRunGrabWithoutUseImage)
                {
                    if (m_smVisionInfo.g_arrDebugImages.Count != m_smVisionInfo.g_arrImages.Count)
                    {
                        for (int d = 0; d < m_smVisionInfo.g_arrImages.Count; d++)
                        {
                            m_smVisionInfo.g_arrDebugImages.Add(new ImageDrawing(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight));
                        }
                    }
                    if (!m_smVisionInfo.g_blnViewColorImage)
                    {
                        m_smVisionInfo.g_arrMemoryImage[i].LoadImageFromMemory(m_objTeliCamera.GetImageBufferPointer(i));//(m_objTeliCamera.GetImagePointer());

                        if (m_smVisionInfo.g_intRotateFlip == 1)
                        {
                            m_smVisionInfo.g_arrMemoryImage[i].Rotate180Image(ref m_smVisionInfo.g_arrRotateImage, i);
                        }
                        else if (m_smVisionInfo.g_intRotateFlip == 2)
                        {
                            m_smVisionInfo.g_arrMemoryImage[i].Rotate90Image(ref m_smVisionInfo.g_arrRotateImage, i);
                        }
                        else if (m_smVisionInfo.g_intRotateFlip == 3)
                        {
                            m_smVisionInfo.g_arrMemoryImage[i].RotateMinus90Image(ref m_smVisionInfo.g_arrRotateImage, i);
                        }
                        else if (m_smVisionInfo.g_intRotateFlip == 4)
                        {
                            m_smVisionInfo.g_arrMemoryImage[i].FlipHorizontalImage(ref m_smVisionInfo.g_arrRotateImage, i);
                        }
                        else if (m_smVisionInfo.g_intRotateFlip == 5)
                        {
                            m_smVisionInfo.g_arrMemoryImage[i].FlipVerticalImage(ref m_smVisionInfo.g_arrRotateImage, i);
                        }
                        else
                        {
                            m_smVisionInfo.g_arrMemoryImage[i].CopyTo(ref m_smVisionInfo.g_arrRotateImage, i);
                        }
                        m_smVisionInfo.g_arrRotateImage[i].CopyTo(ref m_smVisionInfo.g_arrDebugImages, i);
                        m_smVisionInfo.g_arrDebugImages[i].AddGain(m_smVisionInfo.g_arrImageGain[i]);

                        // 2020 12 30 - CCENG: Do image processing to increase image contrast. (to solve mark no enough contrast case)
                        if (i == 0)
                        {
                            if (m_smVisionInfo.g_blnEnhanceImage_Enable)
                            {
                                if (m_smVisionInfo.g_intEnhanceImage_Close > 0)
                                    m_smVisionInfo.g_arrImages[i].AddCloseMorphology(m_smVisionInfo.g_intEnhanceImage_Close);
                                if (m_smVisionInfo.g_intEnhanceImage_Open > 0)
                                    m_smVisionInfo.g_arrImages[i].AddOpenMorphology(m_smVisionInfo.g_intEnhanceImage_Open);
                                if (m_smVisionInfo.g_intEnhanceImage_Dilate > 0)
                                    m_smVisionInfo.g_arrImages[i].AddDilate(m_smVisionInfo.g_intEnhanceImage_Dilate);
                                if (m_smVisionInfo.g_intEnhanceImage_Offset != 0)
                                    m_smVisionInfo.g_arrImages[i].AddOffset(m_smVisionInfo.g_intEnhanceImage_Offset);
                                if (m_smVisionInfo.g_fEnhanceImage_Gain != 1f)
                                    m_smVisionInfo.g_arrImages[i].AddGain(m_smVisionInfo.g_fEnhanceImage_Gain);
                            }
                        }
                    }

                }
                else
                {
                    if (!m_smVisionInfo.g_blnViewColorImage)
                    {
                        m_smVisionInfo.g_arrMemoryImage[i].LoadImageFromMemory(m_objTeliCamera.GetImageBufferPointer(i));//(m_objTeliCamera.GetImagePointer());

                        if (m_smVisionInfo.g_intRotateFlip == 1)
                        {
                            m_smVisionInfo.g_arrMemoryImage[i].Rotate180Image(ref m_smVisionInfo.g_arrRotateImage, i);
                        }
                        else if (m_smVisionInfo.g_intRotateFlip == 2)
                        {
                            m_smVisionInfo.g_arrMemoryImage[i].Rotate90Image(ref m_smVisionInfo.g_arrRotateImage, i);
                        }
                        else if (m_smVisionInfo.g_intRotateFlip == 3)
                        {
                            m_smVisionInfo.g_arrMemoryImage[i].RotateMinus90Image(ref m_smVisionInfo.g_arrRotateImage, i);
                        }
                        else if (m_smVisionInfo.g_intRotateFlip == 4)
                        {
                            m_smVisionInfo.g_arrMemoryImage[i].FlipHorizontalImage(ref m_smVisionInfo.g_arrRotateImage, i);
                        }
                        else if (m_smVisionInfo.g_intRotateFlip == 5)
                        {
                            m_smVisionInfo.g_arrMemoryImage[i].FlipVerticalImage(ref m_smVisionInfo.g_arrRotateImage, i);
                        }
                        else
                        {
                            m_smVisionInfo.g_arrMemoryImage[i].CopyTo(ref m_smVisionInfo.g_arrRotateImage, i);
                        }
                        m_smVisionInfo.g_arrRotateImage[i].CopyTo(ref m_smVisionInfo.g_arrImages, i);
                        m_smVisionInfo.g_arrImages[i].AddGain(m_smVisionInfo.g_arrImageGain[i]);

                        // 2020 12 30 - CCENG: Do image processing to increase image contrast. (to solve mark no enough contrast case)
                        if (i == 0)
                        {
                            if (m_smVisionInfo.g_blnEnhanceImage_Enable)
                            {
                                if (m_smVisionInfo.g_intEnhanceImage_Close > 0)
                                    m_smVisionInfo.g_arrImages[i].AddCloseMorphology(m_smVisionInfo.g_intEnhanceImage_Close);
                                if (m_smVisionInfo.g_intEnhanceImage_Open > 0)
                                    m_smVisionInfo.g_arrImages[i].AddOpenMorphology(m_smVisionInfo.g_intEnhanceImage_Open);
                                if (m_smVisionInfo.g_intEnhanceImage_Dilate > 0)
                                    m_smVisionInfo.g_arrImages[i].AddDilate(m_smVisionInfo.g_intEnhanceImage_Dilate);
                                if (m_smVisionInfo.g_intEnhanceImage_Offset != 0)
                                    m_smVisionInfo.g_arrImages[i].AddOffset(m_smVisionInfo.g_intEnhanceImage_Offset);
                                if (m_smVisionInfo.g_fEnhanceImage_Gain != 1f)
                                    m_smVisionInfo.g_arrImages[i].AddGain(m_smVisionInfo.g_fEnhanceImage_Gain);
                            }
                        }
                    }

                }

                // STTrackLog.WriteLine("Grab i = " + i.ToString());
                if (i == 0)
                {
                    //if (m_smVisionInfo.g_blnSaveImageAfterGrab) m_smVisionInfo.g_arrImages[i].SaveImage("D:\\TSMark\\" + m_intCounter + ".bmp");
                    //      STTrackLog.WriteLine("Grab 1 done.");
                    if (blnSuccess) m_bGrabImage1Result = true;
                    m_bGrabImage1Done = true;
                }
                else if (i == 1)
                {
                    //if (m_smVisionInfo.g_blnSaveImageAfterGrab) m_smVisionInfo.g_arrImages[i].SaveImage("D:\\TSMark\\" + m_intCounter + "_Image" + (i) + ".bmp");
                    if (blnSuccess) m_bGrabImage2Result = true;
                    m_bGrabImage2Done = true;
                }
                else if (i == 2)
                {
                    //if (m_smVisionInfo.g_blnSaveImageAfterGrab) m_smVisionInfo.g_arrImages[i].SaveImage("D:\\TSMark\\" + m_intCounter + "_Image" + (i) + ".bmp");
                    if (blnSuccess) m_bGrabImage3Result = true;
                    m_bGrabImage3Done = true;
                }
                else if (i == 3)
                {
                    //if (m_smVisionInfo.g_blnSaveImageAfterGrab) m_smVisionInfo.g_arrImages[i].SaveImage("D:\\TSMark\\" + m_intCounter + "_Image" + (i) + ".bmp");
                    if (blnSuccess) m_bGrabImage4Result = true;
                    m_bGrabImage4Done = true;
                }
                else if (i == 4)
                {
                    //if (m_smVisionInfo.g_blnSaveImageAfterGrab) m_smVisionInfo.g_arrImages[i].SaveImage("D:\\TSMark\\" + m_intCounter + "_Image" + (i) + ".bmp");
                    if (blnSuccess) m_bGrabImage5Result = true;
                    m_bGrabImage5Done = true;
                }
                else if (i == 5)
                {
                    //if (m_smVisionInfo.g_blnSaveImageAfterGrab) m_smVisionInfo.g_arrImages[i].SaveImage("D:\\TSMark\\" + m_intCounter + "_Image" + (i) + ".bmp");
                    if (blnSuccess) m_bGrabImage6Result = true;
                    m_bGrabImage6Done = true;
                }
                else if (i == 6)
                {
                    //if (m_smVisionInfo.g_blnSaveImageAfterGrab) m_smVisionInfo.g_arrImages[i].SaveImage("D:\\TSMark\\" + m_intCounter + "_Image" + (i) + ".bmp");
                    if (blnSuccess) m_bGrabImage7Result = true;
                    m_bGrabImage7Done = true;
                }

            }

            //m_intCounter++;
            m_bGrabImage1Done = m_bGrabImage2Done = m_bGrabImage3Done = m_bGrabImage4Done = m_bGrabImage5Done = m_bGrabImage6Done = m_bGrabImage7Done = true;

            //Reset outport
            if (m_smCustomizeInfo.g_blnLEDiControl)
            {
                m_objTeliCamera.OutPort(1, 3);
                Thread.Sleep(3);
                m_objTeliCamera.OutPort(1, 0);
            }
            else if (m_smCustomizeInfo.g_blnVTControl)
            {
                m_objTeliCamera.OutPort(1, 0);
            }

            //2021-10-21 ZJYEOH : Set Image to Black if camera fail
            if (!blnSuccess)
            {
                for (int i = 0; i < m_smVisionInfo.g_arrImages.Count; i++)
                {
                    if (m_smVisionInfo.g_blnViewColorImage)
                    {
                        m_smVisionInfo.g_arrColorImages[i].SetImageToBlack();
                        m_smVisionInfo.g_arrColorRotatedImages[i].SetImageToBlack();
                    }
                    m_smVisionInfo.g_arrImages[i].SetImageToBlack();
                    m_smVisionInfo.g_arrRotatedImages[i].SetImageToBlack();
                }
            }

            if (m_objTeliCamera.GetErrorMessage() != "")
            {
                m_smVisionInfo.g_strErrorMessage = m_objTeliCamera.GetErrorMessage();
                m_smVisionInfo.ALL_VM_UpdatePictureBox = true;
                m_smVisionInfo.g_objTransferTime.Stop();

                timer_TotalTime.Stop();
                //objTL.WriteLine("Total grab time = " + fTotalGrabTime.ToString());
                //objTL.WriteLine("Total time = " + timer_TotalTime.Duration.ToString());
                return false;
            }
            else
            {
                // Set camera gain
                if (m_intCameraGainPrev != m_smVisionInfo.g_arrCameraGain[0])
                {
                    m_objTeliCamera.SetCameraParameter(2, m_smVisionInfo.g_arrCameraGain[0]);
                    m_intCameraGainPrev = m_smVisionInfo.g_arrCameraGain[0];
                    m_uintEmptyCameraGainPrev = m_smVisionInfo.g_arrCameraGain[0];
                }

                // Set camera shuttle
                if (m_fCameraShuttlePrev != m_smVisionInfo.g_arrCameraShuttle[0])
                {
                    m_objTeliCamera.SetCameraParameter(1, m_smVisionInfo.g_arrCameraShuttle[0]);
                    m_fCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[0];
                    m_fEmptyCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[0];
                }

                if (m_smVisionInfo.g_bImageStatisticAnalysisON)
                {
                    m_smVisionInfo.g_bImageStatisticAnalysisUpdateInfo = true;

                    while (true)
                    {
                        if (!m_smVisionInfo.g_bImageStatisticAnalysisUpdateInfo)
                            break;

                        Thread.Sleep(1);
                    }
                }

                //AttachImageToROI();
                m_smVisionInfo.g_blnLoadFile = false;
                m_smVisionInfo.ALL_VM_UpdatePictureBox = true;
                m_smVisionInfo.g_objTransferTime.Stop();

                timer_TotalTime.Stop();
                //objTL.WriteLine("Total grab time = " + fTotalGrabTime.ToString());
                //objTL.WriteLine("Total time = " + timer_TotalTime.Duration.ToString());

                return true;
            }
        }
        public bool GrabImage_Sequence_NoSetIntensity_Teli_HighSpeedOrColor(bool blnForInspection)
        {
            //m_smVisionInfo.g_objGrabTime.Reset();
            //m_smVisionInfo.g_objTransferTime.Reset();

            if (!m_objTeliCamera.IsCameraInitDone())
            {
                m_bGrabImage1Result = m_bGrabImage2Result = m_bGrabImage3Result = m_bGrabImage4Result = m_bGrabImage5Result = m_bGrabImage6Result = m_bGrabImage7Result = true; // 2020 07 17 - CCENG: Set Result before Set Done.
                m_bGrabImage1Done = m_bGrabImage2Done = m_bGrabImage3Done = m_bGrabImage4Done = m_bGrabImage5Done = m_bGrabImage6Done = m_bGrabImage7Done = true;
                //m_bGrabImage1Result = m_bGrabImage2Result = m_bGrabImage3Result = m_bGrabImage4Result = m_bGrabImage5Result = true;
                m_bGrabImage1LoadDone = m_bGrabImage2LoadDone = m_bGrabImage3LoadDone = m_bGrabImage4LoadDone = m_bGrabImage5LoadDone = m_bGrabImage6LoadDone = m_bGrabImage7LoadDone = true;
                m_bGrabImage1LoadResult = m_bGrabImage2LoadResult = m_bGrabImage3LoadResult = m_bGrabImage4LoadResult = m_bGrabImage5LoadResult = m_bGrabImage6LoadResult = m_bGrabImage7LoadResult = true;
                m_bGrabImage1TriggerDone = m_bGrabImage2TriggerDone = m_bGrabImage3TriggerDone = m_bGrabImage4TriggerDone = m_bGrabImage5TriggerDone = m_bGrabImage6TriggerDone = m_bGrabImage7TriggerDone = true;
                m_bGrabImage1TriggerResult = m_bGrabImage2TriggerResult = m_bGrabImage3TriggerResult = m_bGrabImage4TriggerResult = m_bGrabImage5TriggerResult = m_bGrabImage6TriggerResult = m_bGrabImage7TriggerResult = true;
                m_smVisionInfo.g_strErrorMessage = "Camera No Connected";
                return true;
            }
            m_smVisionInfo.g_objGrabTime.Start();

            //10-07-2019 ZJYEOH : Check the shuttle and gain again because PH got other setting
            // Set camera gain
            if (m_intCameraGainPrev != m_smVisionInfo.g_arrCameraGain[0])
            {
                m_objTeliCamera.SetCameraParameter(2, m_smVisionInfo.g_arrCameraGain[0]);
                m_intCameraGainPrev = m_smVisionInfo.g_arrCameraGain[0];
                m_uintEmptyCameraGainPrev = m_smVisionInfo.g_arrCameraGain[0];
            }

            // Set camera shuttle
            if (m_fCameraShuttlePrev != m_smVisionInfo.g_arrCameraShuttle[0])
            {
                m_objTeliCamera.SetCameraParameter(1, m_smVisionInfo.g_arrCameraShuttle[0]);
                m_fCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[0];
                m_fEmptyCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[0];
            }

            if (m_dRedRatioPrev != m_smVisionInfo.g_dRedRatio)
            {
                m_objTeliCamera.SetWhiteBalance_ForRed(m_smVisionInfo.g_dRedRatio);
                m_dRedRatioPrev = m_smVisionInfo.g_dRedRatio;
            }

            if (m_dBlueRatioPrev != m_smVisionInfo.g_dBlueRatio)
            {
                m_objTeliCamera.SetWhiteBalance_ForBlue(m_smVisionInfo.g_dBlueRatio);
                m_dBlueRatioPrev = m_smVisionInfo.g_dBlueRatio;
            }

            Thread.Sleep(m_smVisionInfo.g_intCameraGrabDelay);

            if (m_smVisionInfo.g_blnWhiteBalanceAuto)
            {
                m_objTeliCamera.SetWhiteBalanceAuto();
            }

            bool blnSuccess = true;
            bool blnSeparateGrab = m_smVisionInfo.g_blnSeparateGrab;
            int intSelectedImage = m_smVisionInfo.g_intSelectedImage;
            m_bGrabImage1Result = m_bGrabImage2Result = m_bGrabImage3Result = m_bGrabImage4Result = m_bGrabImage5Result = m_bGrabImage6Result = m_bGrabImage7Result = false;
            m_bGrabImage1LoadDone = m_bGrabImage2LoadDone = m_bGrabImage3LoadDone = m_bGrabImage4LoadDone = m_bGrabImage5LoadDone = m_bGrabImage6LoadDone = m_bGrabImage7LoadDone = false;
            m_bGrabImage1LoadResult = m_bGrabImage2LoadResult = m_bGrabImage3LoadResult = m_bGrabImage4LoadResult = m_bGrabImage5LoadResult = m_bGrabImage6LoadResult = m_bGrabImage7LoadResult = false;
            m_bGrabImage1TriggerDone = m_bGrabImage2TriggerDone = m_bGrabImage3TriggerDone = m_bGrabImage4TriggerDone = m_bGrabImage5TriggerDone = m_bGrabImage6TriggerDone = m_bGrabImage7TriggerDone = false;
            m_bGrabImage1TriggerResult = m_bGrabImage2TriggerResult = m_bGrabImage3TriggerResult = m_bGrabImage4TriggerResult = m_bGrabImage5TriggerResult = m_bGrabImage6TriggerResult = m_bGrabImage7TriggerResult = false;

            m_arrBufferPointer = new List<IntPtr>();
            m_bSubTh1_TransferImage = true;
            m_bSubTh1_WaitFrame = true;
            for (int i = 0; i < m_intGrabRequire; i++)
            {
                if (blnSeparateGrab)
                {
                    if (i != intSelectedImage)
                        continue;
                }

                if (i > 0)
                {
                    bool blnStartTransfer2 = false;
                    switch (i - 1)
                    {
                        case 0:
                            blnStartTransfer2 = WaitEventDone(ref m_bGrabImage1LoadDone, true, ref m_bGrabImage1LoadResult, "WaitGrab1");
                            break;
                        case 1:
                            blnStartTransfer2 = WaitEventDone(ref m_bGrabImage2LoadDone, true, ref m_bGrabImage2LoadResult, "WaitGrab2");
                            break;
                        case 2:
                            blnStartTransfer2 = WaitEventDone(ref m_bGrabImage3LoadDone, true, ref m_bGrabImage3LoadResult, "WaitGrab3");
                            break;
                        case 3:
                            blnStartTransfer2 = WaitEventDone(ref m_bGrabImage4LoadDone, true, ref m_bGrabImage4LoadResult, "WaitGrab4");
                            break;
                        case 4:
                            blnStartTransfer2 = WaitEventDone(ref m_bGrabImage5LoadDone, true, ref m_bGrabImage5LoadResult, "WaitGrab5");
                            break;
                        case 5:
                            blnStartTransfer2 = WaitEventDone(ref m_bGrabImage6LoadDone, true, ref m_bGrabImage6LoadResult, "WaitGrab6");
                            break;
                        case 6:
                            blnStartTransfer2 = WaitEventDone(ref m_bGrabImage7LoadDone, true, ref m_bGrabImage7LoadResult, "WaitGrab7");
                            break;
                        default:
                            blnStartTransfer2 = false;
                            break;
                    }
                    if (blnStartTransfer2)  //if (m_objTeliCamera.WaitTriggerWaitDone())
                    {
                        // Set camera gain
                        if (m_intCameraGainPrev != m_smVisionInfo.g_arrCameraGain[i])
                        {
                            m_objTeliCamera.SetCameraParameter(2, m_smVisionInfo.g_arrCameraGain[i]);
                            m_intCameraGainPrev = m_smVisionInfo.g_arrCameraGain[i];
                            m_uintEmptyCameraGainPrev = m_smVisionInfo.g_arrCameraGain[i];
                        }

                        if (/*!blnStartGrab &&*/ !m_objTeliCamera.Grab(i))
                        {
                            blnSuccess = false;
                            m_blnForceStopProduction = true;
                        }
                    }
                    else
                    {
                        STTrackLog.WriteLine("GrabImage_Sequence_NoSetIntensity_Teli_HighSpeedOrColor > blnStartTransfer2 " + (i - 1).ToString() + " fail");
                        blnSuccess = false;
                        m_blnForceStopProduction = true;
                    }
                }
                else
                {
                    if (/*!blnStartGrab &&*/ !m_objTeliCamera.Grab(i))
                    {
                        blnSuccess = false;
                        m_blnForceStopProduction = true;
                    }
                }

                if (m_intGrabRequire > 1 && ((i + 1) < m_smVisionInfo.g_arrCameraShuttle.Count))
                {
                    // Set camera shuttle
                    if (m_fCameraShuttlePrev != m_smVisionInfo.g_arrCameraShuttle[i + 1])
                    {
                        m_objTeliCamera.SetCameraParameter(1, m_smVisionInfo.g_arrCameraShuttle[i + 1]);
                        m_fCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[i + 1];
                        m_fEmptyCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[i + 1];
                    }
                }

                if (i == 0)//1
                {
                    m_bGrabImage1TriggerResult = blnSuccess;
                    m_bGrabImage1TriggerDone = true;
                }
                else if (i == 1)//2
                {
                    m_bGrabImage2TriggerResult = blnSuccess;
                    m_bGrabImage2TriggerDone = true;
                }
                else if (i == 2)//3
                {
                    m_bGrabImage3TriggerResult = blnSuccess;
                    m_bGrabImage3TriggerDone = true;
                }
                else if (i == 3)//4
                {
                    m_bGrabImage4TriggerResult = blnSuccess;
                    m_bGrabImage4TriggerDone = true;
                }
                else if (i == 4)//5
                {
                    m_bGrabImage5TriggerResult = blnSuccess;
                    m_bGrabImage5TriggerDone = true;
                }
                else if (i == 5)//6
                {
                    m_bGrabImage6TriggerResult = blnSuccess;
                    m_bGrabImage6TriggerDone = true;
                }
                else if (i == 6)//7
                {
                    m_bGrabImage7TriggerResult = blnSuccess;
                    m_bGrabImage7TriggerDone = true;
                }
            }

            // --- After last grab ---------------------------------------------------------------------------------------------------------------------------
            m_bGrabImage1TriggerDone = m_bGrabImage2TriggerDone = m_bGrabImage3TriggerDone = m_bGrabImage4TriggerDone = m_bGrabImage5TriggerDone = m_bGrabImage6TriggerDone = m_bGrabImage7TriggerDone = true;
            bool blnStartTransfer = false;
            switch (m_intGrabRequire - 1)
            {
                case 0:
                    blnStartTransfer = WaitEventDone(ref m_bGrabImage1LoadDone, true, ref m_bGrabImage1LoadResult, "WaitGrab1");
                    break;
                case 1:
                    blnStartTransfer = WaitEventDone(ref m_bGrabImage2LoadDone, true, ref m_bGrabImage2LoadResult, "WaitGrab2");
                    break;
                case 2:
                    blnStartTransfer = WaitEventDone(ref m_bGrabImage3LoadDone, true, ref m_bGrabImage3LoadResult, "WaitGrab3");
                    break;
                case 3:
                    blnStartTransfer = WaitEventDone(ref m_bGrabImage4LoadDone, true, ref m_bGrabImage4LoadResult, "WaitGrab4");
                    break;
                case 4:
                    blnStartTransfer = WaitEventDone(ref m_bGrabImage5LoadDone, true, ref m_bGrabImage5LoadResult, "WaitGrab5");
                    break;
                case 5:
                    blnStartTransfer = WaitEventDone(ref m_bGrabImage6LoadDone, true, ref m_bGrabImage6LoadResult, "WaitGrab6");
                    break;
                case 6:
                    blnStartTransfer = WaitEventDone(ref m_bGrabImage7LoadDone, true, ref m_bGrabImage7LoadResult, "WaitGrab7");
                    break;
                default:
                    blnStartTransfer = false;
                    break;
            }
            if (!blnStartTransfer)
            {
                STTrackLog.WriteLine("GrabImage_Sequence_NoSetIntensity_Teli_HighSpeedOrColor > blnStartTransfer last " + m_intGrabRequire.ToString() + " fail");
                blnSuccess = false;
                m_blnForceStopProduction = true;
            }

            if (blnSuccess)
            {
                SetGrabDone(blnForInspection);
                m_smVisionInfo.g_objTransferTime.Start();
            }
            else
                SetGrabDone(blnForInspection);

            if (m_smCustomizeInfo.g_blnLEDiControl)
            {
                m_objTeliCamera.OutPort(1, 3);
                //Thread.Sleep(3);
                m_objTeliCamera.OutPort(1, 0);
            }
            else if (m_smCustomizeInfo.g_blnVTControl)
            {
                m_objTeliCamera.OutPort(1, 0);
            }

            // Set camera gain
            if (m_intCameraGainPrev != m_smVisionInfo.g_arrCameraGain[0])
            {
                m_objTeliCamera.SetCameraParameter(2, m_smVisionInfo.g_arrCameraGain[0]);
                m_intCameraGainPrev = m_smVisionInfo.g_arrCameraGain[0];
                m_uintEmptyCameraGainPrev = m_smVisionInfo.g_arrCameraGain[0];
            }

            // Set camera shuttle
            if (m_fCameraShuttlePrev != m_smVisionInfo.g_arrCameraShuttle[0])
            {
                m_objTeliCamera.SetCameraParameter(1, m_smVisionInfo.g_arrCameraShuttle[0]);
                m_fCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[0];
                m_fEmptyCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[0];
            }

            if (m_smVisionInfo.g_blnWhiteBalanceAuto)
            {
                double dRedRatio = 0, dBlueRatio = 0;
                m_objTeliCamera.GetWhiteBalance(ref dRedRatio, ref dBlueRatio);

                m_smVisionInfo.g_dRedRatio = dRedRatio;
                m_smVisionInfo.g_dBlueRatio = dBlueRatio;

                m_smVisionInfo.g_blnWhiteBalanceAuto = false;
            }

            WaitEventDone(ref m_bSubTh1_TransferImage, false, 10000, "WaitTransferDone");

            //2021-10-21 ZJYEOH : Set Image to Black if camera fail
            if (!blnSuccess)
            {
                for (int i = 0; i < m_smVisionInfo.g_arrImages.Count; i++)
                {
                    if (m_smVisionInfo.g_blnViewColorImage)
                    {
                        m_smVisionInfo.g_arrColorImages[i].SetImageToBlack();
                        m_smVisionInfo.g_arrColorRotatedImages[i].SetImageToBlack();
                    }
                    m_smVisionInfo.g_arrImages[i].SetImageToBlack();
                    m_smVisionInfo.g_arrRotatedImages[i].SetImageToBlack();
                }
            }

            if (m_objTeliCamera.GetErrorMessage() != "")
            {
                m_smVisionInfo.g_strErrorMessage = m_objTeliCamera.GetErrorMessage();
                m_smVisionInfo.ALL_VM_UpdatePictureBox = true;
                m_smVisionInfo.g_objTransferTime.Stop();

                return false;
            }
            else
            {
                if (m_smVisionInfo.g_bImageStatisticAnalysisON)
                {
                    m_smVisionInfo.g_bImageStatisticAnalysisUpdateInfo = true;

                    HiPerfTimer timesout = new HiPerfTimer();
                    timesout.Start();

                    while (true)
                    {
                        if (!m_smVisionInfo.g_bImageStatisticAnalysisUpdateInfo)
                            break;

                        if (timesout.Timing > 3000)
                        {
                            STTrackLog.WriteLine(">>>>>>>>>>>>> time out 1");
                            break;
                        }

                        Thread.Sleep(1);
                    }
                }

                //AttachImageToROI();
                m_smVisionInfo.g_blnLoadFile = false;
                m_smVisionInfo.ALL_VM_UpdatePictureBox = true;
                m_smVisionInfo.g_objTransferTime.Stop();

                return true;
            }
        }

        //public bool GrabImage_Sequence_NoSetIntensity_Teli(bool blnForInspection)
        //{
        //    if (!m_objTeliCamera.IsCameraInitDone())
        //    {
        //        m_bGrabImage1Result = m_bGrabImage2Result = m_bGrabImage3Result = m_bGrabImage4Result = m_bGrabImage5Result = m_bGrabImage6Result = m_bGrabImage7Result = true;
        //        m_bGrabImage1Done = m_bGrabImage2Done = m_bGrabImage3Done = m_bGrabImage4Done = m_bGrabImage5Done = m_bGrabImage6Done = m_bGrabImage7Done = true;
        //        m_smVisionInfo.g_strErrorMessage = "Camera No Connected";
        //        return true;
        //    }

        //    // Using Teli Camera
        //    m_smVisionInfo.g_objGrabTime.Start();
        //    bool blnSuccess = true;
        //    bool blnSeparateGrab = m_smVisionInfo.g_blnSeparateGrab;
        //    int intSelectedImage = m_smVisionInfo.g_intSelectedImage;

        //    // Define grab images require
        //    if (blnForInspection)
        //    {
        //        if ((m_smCustomizeInfo.g_intWantPackage & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
        //        {
        //            if (m_intCurrentGrabRequire != m_intGrabRequire)
        //                m_intCurrentGrabRequire = m_intGrabRequire;
        //        }
        //        else
        //        {
        //            if (m_intCurrentGrabRequire != 1)
        //                m_intCurrentGrabRequire = 1;
        //        }
        //    }
        //    else
        //    {
        //        // Set to maximum requirement grab image if camera live or grab.
        //        if (m_intCurrentGrabRequire != m_intGrabRequire)
        //            m_intCurrentGrabRequire = m_intGrabRequire;
        //    }

        //    m_objTeliCamera.DiscardFrame();

        //    for (int i = 0; i < m_intCurrentGrabRequire; i++)
        //    {
        //        if (blnSeparateGrab)
        //        {
        //            if (i != intSelectedImage)
        //                continue;
        //        }

        //        if (i > 0) // for second image and third image
        //        {
        //            if (m_objTeliCamera.WaitFrameReady())
        //            {
        //                if (m_smVisionInfo.g_blnViewColorImage)
        //                {
        //                    m_smVisionInfo.g_objMemoryColorImage.SetImageSize(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight);
        //                    m_smVisionInfo.g_objMemoryColorImage.LoadImageFromMemory(m_objTeliCamera.GetImagePointer());
        //                    m_smVisionInfo.g_objMemoryColorImage.CopyTo(ref m_smVisionInfo.g_arrColorImages, i - 1);
        //                }
        //                else
        //                {
        //                    m_smVisionInfo.g_objMemoryImage.SetImageSize(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight);
        //                    m_smVisionInfo.g_objMemoryImage.LoadImageFromMemory(m_objTeliCamera.GetImagePointer());
        //                    m_smVisionInfo.g_objMemoryImage.CopyTo(ref m_smVisionInfo.g_arrImages, i - 1);
        //                    m_smVisionInfo.g_arrImages[i - 1].AddGain(m_smVisionInfo.g_arrImageGain[i - 1]);
        //                }
        //            }
        //            else
        //            {
        //                blnSuccess = false;
        //                m_blnForceStopProduction = true;
        //            }

        //            if (i == 1)
        //            {
        //                if (blnSuccess) m_bGrabImage1Result = true;
        //                m_bGrabImage1Done = true;
        //            }
        //            else if (i == 2)
        //            {
        //                if (blnSuccess) m_bGrabImage2Result = true;
        //                m_bGrabImage2Done = true;
        //            }
        //            else if (i == 3)
        //            {
        //                if (blnSuccess) m_bGrabImage3Result = true;
        //                m_bGrabImage3Done = true;
        //            }
        //            else if (i == 4)
        //            {
        //                if (blnSuccess) m_bGrabImage4Result = true;
        //                m_bGrabImage4Done = true;
        //            }
        //            else if (i == 5)
        //            {
        //                if (blnSuccess) m_bGrabImage5Result = true;
        //                m_bGrabImage5Done = true;
        //            }
        //            else if (i == 6)
        //            {
        //                if (blnSuccess) m_bGrabImage6Result = true;
        //                m_bGrabImage6Done = true;
        //            }
        //            else if (i == 7)
        //            {
        //                if (blnSuccess) m_bGrabImage7Result = true;
        //                m_bGrabImage7Done = true;
        //            }
        //        }

        //        #region if more than 1 image need to be captured
        //        // Set light source channel ON/OFF
        //        if (m_intCurrentGrabRequire > 1)
        //        {
        //            // Set camera gain
        //            if (m_intCameraGainPrev != m_smVisionInfo.g_arrCameraGain[i])
        //            {
        //                m_objTeliCamera.SetCameraParameter(2, m_smVisionInfo.g_arrCameraGain[i]);
        //                m_intCameraGainPrev = m_smVisionInfo.g_arrCameraGain[i];
        //                m_uintEmptyCameraGainPrev = m_smVisionInfo.g_arrCameraGain[i];
        //                //if (m_objTeliCamera.ref_intSetGainDelay != 0)
        //                //    Thread.Sleep(m_objTeliCamera.ref_intSetGainDelay);
        //            }

        //            // Set camera shuttle
        //            if (m_fCameraShuttlePrev != m_smVisionInfo.g_arrCameraShuttle[i])
        //            {
        //                m_objTeliCamera.SetCameraParameter(1, m_smVisionInfo.g_arrCameraShuttle[i]);
        //                m_fCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[i];
        //                m_fEmptyCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[i];
        //                //if (m_objTeliCamera.ref_intSetGainDelay != 0)
        //                //    Thread.Sleep(m_objTeliCamera.ref_intSetGainDelay);

        //                //intExposureTime = (int)Math.Ceiling(m_smVisionInfo.g_arrCameraShuttle[i] * 0.0001f);
        //            }
        //        }
        //        #endregion
        //        if (i == 0)
        //        {
        //            if (!m_smCustomizeInfo.g_blnMixController)
        //            {
        //                if (m_smCustomizeInfo.g_blnVTControl)
        //                {
        //                    m_objTeliCamera.OutPort(1, 3);
        //                }
        //            }
        //            else
        //            {
        //                if (m_intLightControlModel == 1) // 2018 07 13 - CCENG: Temporary force to use VTControl
        //                {
        //                    m_objTeliCamera.OutPort(1, 3);
        //                }
        //            }

        //        }

        //        if (!m_objTeliCamera.Grab())
        //        {
        //            blnSuccess = false;
        //            m_blnForceStopProduction = true;
        //        }
        //    }

        //    if (!m_objTeliCamera.WaitFrameReady())
        //    {
        //        blnSuccess = false;
        //        m_blnForceStopProduction = true;
        //    }

        //    if (blnSuccess)
        //    {
        //        SetGrabDone();
        //        m_smVisionInfo.g_objTransferTime.Start();

        //        if (m_objTeliCamera.GetFrame(m_intCurrentGrabRequire - 1))
        //        {
        //            if (m_objTeliCamera.ConvertFrame(m_intCurrentGrabRequire - 1))
        //            {
        //                if (m_smVisionInfo.g_blnViewColorImage)
        //                {
        //                    m_smVisionInfo.g_objMemoryColorImage.SetImageSize(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight);
        //                    m_smVisionInfo.g_objMemoryColorImage.LoadImageFromMemory(m_objTeliCamera.GetImagePointer());
        //                    m_smVisionInfo.g_objMemoryColorImage.CopyTo(ref m_smVisionInfo.g_arrColorImages, m_intCurrentGrabRequire - 1);
        //                }
        //                else
        //                {
        //                    m_smVisionInfo.g_objMemoryImage.SetImageSize(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight);
        //                    m_smVisionInfo.g_objMemoryImage.LoadImageFromMemory(m_objTeliCamera.GetImagePointer());
        //                    m_smVisionInfo.g_objMemoryImage.CopyTo(ref m_smVisionInfo.g_arrImages, m_intCurrentGrabRequire - 1);
        //                    m_smVisionInfo.g_arrImages[m_intCurrentGrabRequire - 1].AddGain(m_smVisionInfo.g_arrImageGain[m_intCurrentGrabRequire - 1]);
        //                }
        //                if (m_intGrabRequire == 1)
        //                {
        //                    if (blnSuccess) m_bGrabImage1Result = true;
        //                    m_bGrabImage1Done = true;
        //                }
        //                else if (m_intGrabRequire == 2)
        //                {
        //                    if (blnSuccess) m_bGrabImage2Result = true;
        //                    m_bGrabImage2Done = true;
        //                }
        //                else if (m_intGrabRequire == 3)
        //                {
        //                    if (blnSuccess) m_bGrabImage3Result = true;
        //                    m_bGrabImage3Done = true;
        //                }
        //                else if (m_intGrabRequire == 4)
        //                {
        //                    if (blnSuccess) m_bGrabImage4Result = true;
        //                    m_bGrabImage4Done = true;
        //                }
        //                else if (m_intGrabRequire == 5)
        //                {
        //                    if (blnSuccess) m_bGrabImage5Result = true;
        //                    m_bGrabImage5Done = true;
        //                }
        //                else if (m_intGrabRequire == 6)
        //                {
        //                    if (blnSuccess) m_bGrabImage6Result = true;
        //                    m_bGrabImage6Done = true;
        //                }
        //                else if (m_intGrabRequire == 7)
        //                {
        //                    if (blnSuccess) m_bGrabImage7Result = true;
        //                    m_bGrabImage7Done = true;
        //                }
        //            }
        //        }
        //    }
        //    else
        //        SetGrabDone();

        //    m_bGrabImage1Done = m_bGrabImage2Done = m_bGrabImage3Done = m_bGrabImage4Done = m_bGrabImage5Done = m_bGrabImage6Done = m_bGrabImage7Done = true;

        //    //Reset outport
        //    if (!m_smCustomizeInfo.g_blnMixController)
        //    {
        //        if (m_smCustomizeInfo.g_blnLEDiControl)
        //        {
        //            m_objTeliCamera.OutPort(1, 3);
        //            m_objTeliCamera.OutPort(1, 0);
        //        }
        //        else if (m_smCustomizeInfo.g_blnVTControl)
        //        {
        //            m_objTeliCamera.OutPort(1, 0);
        //        }
        //    }
        //    else
        //    {
        //        if (m_intLightControlModel == 0) // 2018 07 13 - CCENG: Temporary force to use VTControl
        //        {
        //            m_objTeliCamera.OutPort(1, 3);
        //            m_objTeliCamera.OutPort(1, 0);
        //        }
        //        else if (m_intLightControlModel == 1) // 2018 07 13 - CCENG: Temporary force to use VTControl
        //        {
        //            m_objTeliCamera.OutPort(1, 0);
        //        }
        //    }

        //    if (m_objTeliCamera.GetErrorMessage() != "")
        //    {
        //        m_smVisionInfo.g_strErrorMessage = m_objTeliCamera.GetErrorMessage();
        //        m_smVisionInfo.ALL_VM_UpdatePictureBox = true;
        //        m_smVisionInfo.g_objTransferTime.Stop();
        //        return false;
        //    }
        //    else
        //    {
        //        // Set camera gain
        //        if (m_intCameraGainPrev != m_smVisionInfo.g_arrCameraGain[0])
        //        {
        //            m_objTeliCamera.SetCameraParameter(2, m_smVisionInfo.g_arrCameraGain[0]);
        //            m_intCameraGainPrev = m_smVisionInfo.g_arrCameraGain[0];
        //            m_uintEmptyCameraGainPrev = m_smVisionInfo.g_arrCameraGain[0];
        //        }

        //        // Set camera shuttle
        //        if (m_fCameraShuttlePrev != m_smVisionInfo.g_arrCameraShuttle[0])
        //        {
        //            m_objTeliCamera.SetCameraParameter(1, m_smVisionInfo.g_arrCameraShuttle[0]);
        //            m_fCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[0];
        //            m_fEmptyCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[0];
        //        }

        //        if (m_smVisionInfo.g_bImageStatisticAnalysisON)
        //        {
        //            m_smVisionInfo.g_bImageStatisticAnalysisUpdateInfo = true;

        //            while (true)
        //            {
        //                if (!m_smVisionInfo.g_bImageStatisticAnalysisUpdateInfo)
        //                    break;

        //                Thread.Sleep(1);
        //            }
        //        }

        //        AttachImageToROI();
        //        m_smVisionInfo.g_blnLoadFile = false;
        //        m_smVisionInfo.ALL_VM_UpdatePictureBox = true;
        //        m_smVisionInfo.g_objTransferTime.Stop();

        //        return true;
        //    }
        //}

        public bool InitCamera(int intPort, String SerialNo, int intResolutionX, int intResolutionY, bool blnFirstTime)
        {
            bool blnInitSuccess = true;
            if (blnFirstTime)
            {
                if (m_smVisionInfo.g_strCameraModel == "AVT")
                {
                    if (!m_objAVTFireGrab.InitializeCamera(intPort, false))
                        blnInitSuccess = false;
                }
                else if (m_smVisionInfo.g_strCameraModel == "Teli")
                {
                    if (!m_objTeliCamera.InitializeCamera(SerialNo, intResolutionX, intResolutionY))
                    {
                        blnInitSuccess = false;
                        SRMMessageBox.Show("Serial No. " + SerialNo + " - " + m_smVisionInfo.g_strVisionDisplayName + " " + m_objTeliCamera.GetErrorMessage());
                    }
                }
            }
            RegistryKey Key = Registry.LocalMachine.OpenSubKey("Software", true);
            RegistryKey subKey = Key.OpenSubKey("SVG\\LightControl", true);
            string[] strLightControlMaskList = subKey.GetValueNames();

            string strCameraFilePath = m_smProductionInfo.g_strRecipePath + m_smProductionInfo.g_arrSingleRecipeID[m_smVisionInfo.g_intVisionIndex] + "\\Camera.xml";
            if (m_smVisionInfo.g_blnGlobalSharingCameraData)
                strCameraFilePath = AppDomain.CurrentDomain.BaseDirectory + "DeviceNo\\GlobalCamera.xml";

            XmlParser fileHandle = new XmlParser(m_smProductionInfo.g_strRecipePath + "Camera.xml");
            XmlParser objFileHandle = new XmlParser(strCameraFilePath);
            fileHandle.GetFirstSection(m_smVisionInfo.g_strVisionName);
            objFileHandle.GetFirstSection(m_smVisionInfo.g_strVisionFolderName);

            m_smVisionInfo.g_fCameraShuttle = objFileHandle.GetValueAsFloat("Shutter", 200f);
            if (m_smVisionInfo.g_strCameraModel == "AVT")
            {
                m_objAVTFireGrab.SetCameraParameter(1, Convert.ToUInt32(m_smVisionInfo.g_fCameraShuttle));
                m_objAVTFireGrab.SetCameraParameter(4, objFileHandle.GetValueAsUInt("Gamma", 0));
                if (m_smVisionInfo.g_blnViewColorImage)
                {
                    m_objAVTFireGrab.SetCameraParameter(5, objFileHandle.GetValueAsUInt("UBValue", 0));
                    m_objAVTFireGrab.SetCameraParameter(6, objFileHandle.GetValueAsUInt("VRValue", 0));
                }
            }
            else if (m_smVisionInfo.g_strCameraModel == "Teli")
            {

            }
            m_smVisionInfo.g_intCameraGrabDelay = objFileHandle.GetValueAsInt("GrabDelay", 5);

            m_smVisionInfo.g_arrLightSource.Clear();
           
            string[] arrName = subKey.GetSubKeyNames();          // Get Related CommPort List
            for (int x = 0; x < arrName.Length; x++)
            {
                RegistryKey child = subKey.OpenSubKey(arrName[x], true);
                RegistryKey grandChild = child.CreateSubKey(m_smVisionInfo.g_strVisionFolderName);

                string[] arrType = grandChild.GetValueNames();
                for (int i = 0; i < arrType.Length; i++)
                {
                    LightSource objLightSource = new LightSource();
                    objLightSource.ref_strCommPort = arrName[x];
                    objLightSource.ref_strType = arrType[i];
                    objLightSource.ref_intChannel = Convert.ToInt32(grandChild.GetValue(arrType[i], 1));

                    string strSearch = arrType[i].Replace(" ", string.Empty);
                    bool blnLightMaskingFound = false;
                    for (int y = 0; y < strLightControlMaskList.Length; y++)
                    {
                        if (strLightControlMaskList[y].Contains(m_smVisionInfo.g_strVisionName + " - " + arrType[i]))
                            blnLightMaskingFound = true;
                    }
                    if (blnLightMaskingFound)
                        objLightSource.ref_intSeqNo = Convert.ToInt32(subKey.GetValue(m_smVisionInfo.g_strVisionName + " - " + arrType[i], 1));
                    else
                    {
                        objLightSource.ref_intSeqNo = fileHandle.GetValueAsInt(strSearch, 1);
                        subKey.SetValue(m_smVisionInfo.g_strVisionName + " - " + arrType[i], objLightSource.ref_intSeqNo);
                    }
                    objLightSource.ref_intValue = objFileHandle.GetValueAsInt(arrType[i], 31);
                    objLightSource.ref_intPortNo = x;
                    int intCameraOutNo = Convert.ToInt32(objLightSource.ref_strType.Substring(objLightSource.ref_strType.Length - 1));

                    if (m_smVisionInfo.g_strCameraModel == "AVT")
                    {
                        if (intCameraOutNo == 0)
                            m_objAVTFireGrab.OutPort(intCameraOutNo, m_smVisionInfo.g_intTriggerMode);
                        else
                            m_objAVTFireGrab.OutPort(intCameraOutNo, 0);
                    }
                    else if (m_smVisionInfo.g_strCameraModel == "Teli")
                    {
                        if (intCameraOutNo == 0)
                            m_objTeliCamera.OutPort(intCameraOutNo, m_smVisionInfo.g_intTriggerMode);
                        else
                            m_objTeliCamera.OutPort(intCameraOutNo, 0);
                    }

                    objLightSource.ref_arrValue = new List<int>();
                    objLightSource.ref_arrImageNo = new List<int>();
                    // Maximum grab 7 times
                    for (int j = 0; j < 7; j++)
                    {
                        if ((objLightSource.ref_intSeqNo & (0x01 << j)) > 0)
                        {
                            if (m_intGrabRequire < (j + 1))
                            {
                                m_intGrabRequire = j + 1; // Get highest grab number
                                for (int k = m_smVisionInfo.g_arrImages.Count; k < m_intGrabRequire; k++)
                                {
                                    if (m_smVisionInfo.g_blnViewColorImage)
                                    {
                                        m_smVisionInfo.g_arrColorImages.Add(new CImageDrawing());
                                        m_smVisionInfo.g_arrColorRotatedImages.Add(new CImageDrawing());
                                    }

                                    m_smVisionInfo.g_arrImages.Add(new ImageDrawing());
                                    m_smVisionInfo.g_arrRotatedImages.Add(new ImageDrawing());

                                    m_smVisionInfo.g_arrCameraShuttle.Add(new float());
                                    m_smVisionInfo.g_arrCameraGain.Add(new int());
                                    m_smVisionInfo.g_arrImageGain.Add(new float());
                                }
                            }
                            int intCount = objLightSource.ref_arrValue.Count;

                            objLightSource.ref_arrValue.Add(new int());
                            objLightSource.ref_arrImageNo.Add(new int());
                            objFileHandle.GetSecondSection(objLightSource.ref_strType);
                            objLightSource.ref_arrValue[intCount] = objFileHandle.GetValueAsInt("Seq" + intCount.ToString(), 31, 2);
                            objLightSource.ref_arrImageNo[intCount] = j;
                        }
                    }

                    m_smVisionInfo.g_arrLightSource.Add(objLightSource);

                    if (!m_smCustomizeInfo.g_blnMixController)
                    {
                        if (m_smCustomizeInfo.g_blnLEDiControl)
                        {
                            LEDi_Control.SetIntensity(x, objLightSource.ref_intChannel, Convert.ToByte(objLightSource.ref_arrValue[0]));
                        }
                        else if (m_smCustomizeInfo.g_blnVTControl)
                        {
                            VT_Control.SetConfigMode(objLightSource.ref_intPortNo);
                            VT_Control.SetIntensity(x, objLightSource.ref_intChannel, objLightSource.ref_arrValue[0]);
                            VT_Control.SetRunMode(objLightSource.ref_intPortNo);
                        }
                        else
                        {
                            TCOSIO_Control.SetIntensity(x, objLightSource.ref_intChannel, objLightSource.ref_arrValue[0]);
                            TCOSIO_Control.SendMessage(x, "@ST" + objLightSource.ref_intChannel + "1*");    // Set Strobe ON
                            TCOSIO_Control.SendMessage(x, "@SI" + objLightSource.ref_intChannel + "00*");   // Set Constant Intensity to 0
                        }
                    }
                    else
                    {
                        if (m_intLightControlModel == 0) // 2018 07 13 - CCENG: Temporary force to use VTControl
                        {
                            LEDi_Control.SetIntensity(x, objLightSource.ref_intChannel, Convert.ToByte(objLightSource.ref_arrValue[0]));
                        }
                        else if (m_intLightControlModel == 1) // 2018 07 13 - CCENG: Temporary force to use VTControl
                        {
                            VT_Control.SetConfigMode(objLightSource.ref_intPortNo);
                            VT_Control.SetIntensity(x, objLightSource.ref_intChannel, objLightSource.ref_arrValue[0]);
                            VT_Control.SetRunMode(objLightSource.ref_intPortNo);
                        }
                        else
                        {
                            TCOSIO_Control.SetIntensity(x, objLightSource.ref_intChannel, objLightSource.ref_arrValue[0]);
                            TCOSIO_Control.SendMessage(x, "@ST" + objLightSource.ref_intChannel + "1*");    // Set Strobe ON
                            TCOSIO_Control.SendMessage(x, "@SI" + objLightSource.ref_intChannel + "00*");   // Set Constant Intensity to 0
                        }
                    }


                    Thread.Sleep(5); // Delay after set intensity to light source controller
                }
            }

            if (blnFirstTime)
            {
                InitSaveImageBuffer(m_intGrabRequire);
            }

            // Sorting light source
            LightSource[] arrLightSource = new LightSource[m_smVisionInfo.g_arrLightSource.Count];
            for (int i = 0; i < m_smVisionInfo.g_arrLightSource.Count; i++)
            {
                int intStartIndex = m_smVisionInfo.g_arrLightSource[i].ref_strType.Length - 1;
                int intLightSourceIndex = Convert.ToInt32(m_smVisionInfo.g_arrLightSource[i].ref_strType.Substring(intStartIndex, 1));

                arrLightSource[intLightSourceIndex] = m_smVisionInfo.g_arrLightSource[i];
            }

            m_smVisionInfo.g_arrLightSource.Clear();
            for (int i = 0; i < arrLightSource.Length; i++)
            {
                m_smVisionInfo.g_arrLightSource.Add(arrLightSource[i]);
            }

            if (!m_smCustomizeInfo.g_blnMixController)
            {
                if (m_smCustomizeInfo.g_blnVTControl)
                {
                    //channel grouping
                    int intChannelNum = 0;
                    uint uintGroupNum = 0;
                    for (int k = 0; k < m_smVisionInfo.g_arrLightSource.Count; k++)
                    {
                        intChannelNum = m_smVisionInfo.g_arrLightSource[k].ref_intChannel;
                        //intChannelNum -= 1;
                        uintGroupNum += Convert.ToUInt32(Math.Pow(2, intChannelNum));
                    }
                    VT_Control.SetConfigMode(m_smVisionInfo.g_arrLightSource[0].ref_intPortNo);
                    VT_Control.SetGroupsAvailable(m_smVisionInfo.g_arrLightSource[0].ref_intPortNo, uintGroupNum);

                    //Setting active flag
                    for (int m = 0; m < m_intGrabRequire; m++)
                    {
                        VT_Control.SetActiveOutFlag(m_smVisionInfo.g_arrLightSource[0].ref_intPortNo, uintGroupNum, m, 1);
                    }
                    VT_Control.SetRunMode(m_smVisionInfo.g_arrLightSource[0].ref_intPortNo);
                }
            }
            else
            {
                if (m_intLightControlModel == 1) // 2018 07 13 - CCENG: Temporary force to use VTControl
                {
                    //channel grouping
                    int intChannelNum = 0;
                    uint uintGroupNum = 0;
                    for (int k = 0; k < m_smVisionInfo.g_arrLightSource.Count; k++)
                    {
                        intChannelNum = m_smVisionInfo.g_arrLightSource[k].ref_intChannel;
                        //intChannelNum -= 1;
                        uintGroupNum += Convert.ToUInt32(Math.Pow(2, intChannelNum));
                    }
                    VT_Control.SetConfigMode(m_smVisionInfo.g_arrLightSource[0].ref_intPortNo);
                    VT_Control.SetGroupsAvailable(m_smVisionInfo.g_arrLightSource[0].ref_intPortNo, uintGroupNum);

                    //Setting active flag
                    for (int m = 0; m < m_intGrabRequire; m++)
                    {
                        VT_Control.SetActiveOutFlag(m_smVisionInfo.g_arrLightSource[0].ref_intPortNo, uintGroupNum, m, 1);
                    }
                    VT_Control.SetRunMode(m_smVisionInfo.g_arrLightSource[0].ref_intPortNo);
                }
            }

            for (int i = 0; i < m_smVisionInfo.g_arrCameraShuttle.Count; i++)
            {
                m_smVisionInfo.g_arrCameraShuttle[i] = objFileHandle.GetValueAsFloat("Shutter" + i.ToString(), 0f);

                if (m_smVisionInfo.g_arrCameraShuttle[i] == 0)
                {
                    m_smVisionInfo.g_arrCameraShuttle[i] = m_smVisionInfo.g_fCameraShuttle;
                }

                if (i == 0)
                {
                    if (m_smVisionInfo.g_strCameraModel == "AVT")
                        m_objAVTFireGrab.SetCameraParameter(1, (uint)m_smVisionInfo.g_arrCameraShuttle[i]);
                    else if (m_smVisionInfo.g_strCameraModel == "Teli")
                        m_objTeliCamera.SetCameraParameter(1, m_smVisionInfo.g_arrCameraShuttle[i]);
                }
            }

            for (int i = 0; i < m_smVisionInfo.g_arrCameraGain.Count; i++)
            {
                m_smVisionInfo.g_arrCameraGain[i] = (uint)objFileHandle.GetValueAsInt("Gain" + i.ToString(), 1);

                if (i == 0)
                {
                    if (m_smVisionInfo.g_strCameraModel == "AVT")
                        m_objAVTFireGrab.SetCameraParameter(2, m_smVisionInfo.g_arrCameraGain[i]);
                    else if (m_smVisionInfo.g_strCameraModel == "Teli")
                        m_objTeliCamera.SetCameraParameter(2, m_smVisionInfo.g_arrCameraGain[i]);
                }
            }

            for (int i = 0; i < m_smVisionInfo.g_arrImageGain.Count; i++)
            {
                m_smVisionInfo.g_arrImageGain[i] = objFileHandle.GetValueAsFloat("ImageGain" + i.ToString(), 1);
            }

            // Define Image View Count
            m_smVisionInfo.g_intImageViewCount = m_intGrabRequire;
            ImageDrawing.SetImageCount(m_intGrabRequire, m_smVisionInfo.g_intVisionIndex);
            ImageDrawing.SetImageMergeType(m_smVisionInfo.g_intImageMergeType, m_smVisionInfo.g_intVisionIndex);

            if (m_smVisionInfo.g_intSelectedImage >= m_smVisionInfo.g_arrImages.Count)
            {
                m_smVisionInfo.g_intSelectedImage = 0;
            }

            return blnInitSuccess;
        }

        public bool InitCameraSequence(int intPort, String SerialNo, int intResolutionX, int intResolutionY, bool blnFirstTime)
        {
            bool blnInitSuccess = true;

            if (blnFirstTime)
            {
                if (m_smVisionInfo.g_strCameraModel == "AVT")
                {
                    if (!m_objAVTFireGrab.InitializeCamera(intPort, false))
                        blnInitSuccess = false;
                }
                else if (m_smVisionInfo.g_strCameraModel == "Teli")
                {
                    if (m_blnCustomWantColor)
                    {
                        if (!m_objTeliCamera.InitializeCamera_LowLevelAPI(SerialNo, intResolutionX, intResolutionY, true))
                        {
                            blnInitSuccess = false;
                            SRMMessageBox.Show("Serial No. " + SerialNo + " - " + m_smVisionInfo.g_strVisionDisplayName + " " + m_objTeliCamera.GetErrorMessage());

                            if (blnInitSuccess)
                            {
                                double dRedRatio = 0, dBlueRatio = 0;
                                m_objTeliCamera.GetWhiteBalance(ref dRedRatio, ref dBlueRatio);

                                m_dRedRatioPrev = m_smVisionInfo.g_dRedRatio = dRedRatio;
                                m_dBlueRatioPrev = m_smVisionInfo.g_dBlueRatio = dBlueRatio;
                            }
                        }
                    }
                    else
                    {
                        if (m_smVisionInfo.g_intGrabMode == 0)
                        {
                            if (!m_objTeliCamera.InitializeCamera(SerialNo, intResolutionX, intResolutionY))
                            {
                                blnInitSuccess = false;
                                SRMMessageBox.Show("Serial No. " + SerialNo + " - " + m_smVisionInfo.g_strVisionDisplayName + " " + m_objTeliCamera.GetErrorMessage());
                            }
                        }
                        else
                        {
                            if (!m_objTeliCamera.InitializeCamera_LowLevelAPI(SerialNo, intResolutionX, intResolutionY, false))
                            {
                                blnInitSuccess = false;
                                SRMMessageBox.Show("Serial No. " + SerialNo + " - " + m_smVisionInfo.g_strVisionDisplayName + " " + m_objTeliCamera.GetErrorMessage());

                                if (blnInitSuccess)
                                {
                                    double dRedRatio = 0, dBlueRatio = 0;
                                    m_objTeliCamera.GetWhiteBalance(ref dRedRatio, ref dBlueRatio);

                                    m_dRedRatioPrev = m_smVisionInfo.g_dRedRatio = dRedRatio;
                                    m_dBlueRatioPrev = m_smVisionInfo.g_dBlueRatio = dBlueRatio;
                                }
                            }
                        }
                    }
                }
            }
            RegistryKey Key = Registry.LocalMachine.OpenSubKey("Software", true);
            RegistryKey subKey = Key.OpenSubKey("SVG\\LightControl", true);
            string[] strLightControlMaskList = subKey.GetValueNames();

            string strCameraFilePath = m_smProductionInfo.g_strRecipePath + m_smProductionInfo.g_arrSingleRecipeID[m_smVisionInfo.g_intVisionIndex] + "\\Camera.xml";
            if (m_smVisionInfo.g_blnGlobalSharingCameraData)
                strCameraFilePath = AppDomain.CurrentDomain.BaseDirectory + "DeviceNo\\GlobalCamera.xml";

            XmlParser fileHandle = new XmlParser(m_smProductionInfo.g_strRecipePath + "Camera.xml");
            XmlParser objFileHandle = new XmlParser(strCameraFilePath);
            fileHandle.GetFirstSection(m_smVisionInfo.g_strVisionName);
            objFileHandle.GetFirstSection(m_smVisionInfo.g_strVisionFolderName);

            m_smVisionInfo.g_fCameraShuttle = objFileHandle.GetValueAsFloat("Shutter", 200f);
            if (m_smVisionInfo.g_strCameraModel == "AVT")
            {
                m_objAVTFireGrab.SetCameraParameter(1, Convert.ToUInt32(m_smVisionInfo.g_fCameraShuttle));
                m_objAVTFireGrab.SetCameraParameter(4, objFileHandle.GetValueAsUInt("Gamma", 0));
                if (m_smVisionInfo.g_blnViewColorImage)
                {
                    m_objAVTFireGrab.SetCameraParameter(5, objFileHandle.GetValueAsUInt("UBValue", 0));
                    m_objAVTFireGrab.SetCameraParameter(6, objFileHandle.GetValueAsUInt("VRValue", 0));
                }
            }
            else if (m_smVisionInfo.g_strCameraModel == "Teli")
            {
                if (m_smVisionInfo.g_blnViewColorImage)
                {
                    m_smVisionInfo.g_dRedRatio = objFileHandle.GetValueAsDouble("RedRatio", 2.309997559);
                    m_smVisionInfo.g_dBlueRatio = objFileHandle.GetValueAsDouble("BlueRatio", 2.539978027);
                    m_objTeliCamera.SetWhiteBalance_ForRed(m_smVisionInfo.g_dRedRatio);
                    m_objTeliCamera.SetWhiteBalance_ForBlue(m_smVisionInfo.g_dBlueRatio);
                }
            }

            m_smVisionInfo.g_intCameraGrabDelay = objFileHandle.GetValueAsInt("GrabDelay", 5);

            m_smVisionInfo.g_arrLightSource.Clear();
          
            string[] arrName = subKey.GetSubKeyNames();          // Get Related CommPort List

            //arrName means comport number
            for (int x = 0; x < arrName.Length; x++)
            {
                RegistryKey child = subKey.OpenSubKey(arrName[x], true);
                RegistryKey grandChild = child.CreateSubKey(m_smVisionInfo.g_strVisionFolderName);

                string[] arrType = grandChild.GetValueNames();

                //arrType means light source type
                for (int i = 0; i < arrType.Length; i++)
                {
                    LightSource objLightSource = new LightSource();
                    objLightSource.ref_strCommPort = arrName[x];
                    objLightSource.ref_strType = arrType[i];

                    objLightSource.ref_intChannel = Convert.ToInt32(grandChild.GetValue(arrType[i], 1));

                    string strSearch = arrType[i].Replace(" ", string.Empty);
                    bool blnLightMaskingFound = false;
                    for (int y = 0; y < strLightControlMaskList.Length; y++)
                    {
                        if (strLightControlMaskList[y].Contains(m_smVisionInfo.g_strVisionName + m_smVisionInfo.g_strVisionNameNo + " - " + arrType[i]))
                            blnLightMaskingFound = true;
                    }
                    if (blnLightMaskingFound)
                    {
                        // 2021 05 04 - CCENG: need to read VisionNameNo as well due to InPocket will have 2 modules.
                        //objLightSource.ref_intSeqNo = Convert.ToInt32(subKey.GetValue(m_smVisionInfo.g_strVisionName + " - " + arrType[i], 1));
                        objLightSource.ref_intSeqNo = Convert.ToInt32(subKey.GetValue(m_smVisionInfo.g_strVisionName + m_smVisionInfo.g_strVisionNameNo + " - " + arrType[i], 1));
                    }
                    else
                    {
                        objLightSource.ref_intSeqNo = fileHandle.GetValueAsInt(strSearch, 1);

                        // 2021 05 04 - CCENG: need to read VisionNameNo as well due to InPocket will have 2 modules.
                        //subKey.SetValue(m_smVisionInfo.g_strVisionName + " - " + arrType[i], objLightSource.ref_intSeqNo);
                        subKey.SetValue(m_smVisionInfo.g_strVisionName + m_smVisionInfo.g_strVisionNameNo + " - " + arrType[i], objLightSource.ref_intSeqNo);
                    }
                    objLightSource.ref_intValue = 31;// objFileHandle.GetValueAsInt(arrType[i], 31); 2019-09-12 ZJYEOH : do not read this value from XML file because it combine all intensity value in the light source sequence which will exceed 32 bit integer value when have 5 grab 
                    objLightSource.ref_intPortNo = x;
                    objLightSource.ref_EmptyValue = objFileHandle.GetValueAsInt("Empty" + strSearch, 31, 1);

                    if (m_smVisionInfo.g_strCameraModel == "AVT")
                    {
                        //Need to change
                        m_objAVTFireGrab.OutPort(0, m_smVisionInfo.g_intTriggerMode);
                        Thread.Sleep(10);
                        m_objAVTFireGrab.OutPort(1, 5);
                    }
                    else if (m_smVisionInfo.g_strCameraModel == "Teli")
                    {
                        m_objTeliCamera.OutPort(0, m_smVisionInfo.g_intTriggerMode);
                        Thread.Sleep(10);
                        m_objTeliCamera.OutPort(1, 0);
                    }

                    objLightSource.ref_arrValue = new List<int>();
                    objLightSource.ref_arrImageNo = new List<int>();
                    // Maximum grab 7 times
                    for (int j = 0; j < 7; j++)
                    {
                        if ((objLightSource.ref_intSeqNo & (0x01 << j)) > 0)
                        {
                            if (m_intGrabRequire < (j + 1))
                            {
                                m_intGrabRequire = j + 1; // Get highest grab number
                                for (int k = m_smVisionInfo.g_arrImages.Count; k < m_intGrabRequire; k++)
                                {
                                    if (blnFirstTime)
                                    {
                                        if (m_smVisionInfo.g_blnViewColorImage)
                                        {
                                            m_smVisionInfo.g_arrColorImages.Add(new CImageDrawing());
                                            m_smVisionInfo.g_arrColorRotatedImages.Add(new CImageDrawing());
                                            m_smVisionInfo.g_arrMemoryColorImage.Add(new CImageDrawing(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight));
                                            m_smVisionInfo.g_arrCRotateImage.Add(new CImageDrawing(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight));
                                            m_arrColorImage_ForInspection.Add(new CImageDrawing(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight));
                                        }

                                        m_smVisionInfo.g_arrRotateImage.Add(new ImageDrawing(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight));
                                        m_smVisionInfo.g_arrMemoryImage.Add(new ImageDrawing(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight));
                                        m_smVisionInfo.g_arrImages.Add(new ImageDrawing(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight));
                                        m_smVisionInfo.g_arrRotatedImages.Add(new ImageDrawing(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight));

                                        m_smVisionInfo.g_arrCameraShuttle.Add(new float());
                                        m_smVisionInfo.g_arrCameraGain.Add(new int());
                                        m_smVisionInfo.g_arrImageGain.Add(new float());
                                    }
                                }
                            }
                            int intCount = objLightSource.ref_arrValue.Count;

                            objLightSource.ref_arrValue.Add(new int());
                            objLightSource.ref_arrImageNo.Add(new int());
                            objFileHandle.GetSecondSection(objLightSource.ref_strType);
                            objLightSource.ref_arrValue[intCount] = objFileHandle.GetValueAsInt("Seq" + intCount.ToString(), 31, 2);
                            objLightSource.ref_arrImageNo[intCount] = j;
                        }
                    }

                    m_smVisionInfo.g_arrLightSource.Add(objLightSource);
                }
            }

            if (blnFirstTime)
            {
                InitSaveImageBuffer(m_intGrabRequire);
            }

            // Sorting light source
            LightSource[] arrLightSource = new LightSource[m_smVisionInfo.g_arrLightSource.Count];
            for (int i = 0; i < m_smVisionInfo.g_arrLightSource.Count; i++)
            {
                int intStartIndex = m_smVisionInfo.g_arrLightSource[i].ref_strType.Length - 1;
                int intLightSourceIndex = Convert.ToInt32(m_smVisionInfo.g_arrLightSource[i].ref_strType.Substring(intStartIndex, 1));

                arrLightSource[intLightSourceIndex] = m_smVisionInfo.g_arrLightSource[i];
            }

            m_smVisionInfo.g_arrLightSource.Clear();
            for (int i = 0; i < arrLightSource.Length; i++)
            {
                m_smVisionInfo.g_arrLightSource.Add(arrLightSource[i]);
            }

            if (!m_smCustomizeInfo.g_blnMixController)
            {
                if (m_smCustomizeInfo.g_blnLEDiControl)
                {
                    //Set to stop mode
                    LEDi_Control.RunStop(m_smVisionInfo.g_arrLightSource[0].ref_intPortNo, 0, false);
                    Thread.Sleep(10);
                    for (int i = 0; i < m_intGrabRequire; i++)
                    {
                        int intValue1 = 0;
                        int intValue2 = 0;
                        int intValue3 = 0;
                        int intValue4 = 0;

                        if (m_intGrabRequire > 0)
                        {
                            for (int j = 0; j < m_smVisionInfo.g_arrLightSource.Count; j++)
                            {
                                int intValueNo = 0;

                                // Due to some light source only ON for second image so its intensity value is at array no. 0.
                                // So we need to loop to find which array no. is for that image
                                for (int k = 0; k < m_smVisionInfo.g_arrLightSource[j].ref_arrValue.Count; k++)
                                {
                                    // if this image no is in array k
                                    if (m_smVisionInfo.g_arrLightSource[j].ref_arrImageNo != null)
                                    {
                                        if (m_smVisionInfo.g_arrLightSource[j].ref_arrImageNo[k] == i)
                                        {
                                            intValueNo = k;

                                            switch (j)
                                            {
                                                case 0:
                                                    if ((m_smVisionInfo.g_arrLightSource[j].ref_intSeqNo & (0x01 << i)) > 0)
                                                    {
                                                        intValue1 = m_smVisionInfo.g_arrLightSource[j].ref_arrValue[intValueNo];
                                                    }
                                                    break;
                                                case 1:
                                                    if ((m_smVisionInfo.g_arrLightSource[j].ref_intSeqNo & (0x01 << i)) > 0)
                                                    {
                                                        intValue2 = m_smVisionInfo.g_arrLightSource[j].ref_arrValue[intValueNo];
                                                    }
                                                    break;
                                                case 2:
                                                    if ((m_smVisionInfo.g_arrLightSource[j].ref_intSeqNo & (0x01 << i)) > 0)
                                                    {
                                                        intValue3 = m_smVisionInfo.g_arrLightSource[j].ref_arrValue[intValueNo];
                                                    }
                                                    break;
                                                case 3:
                                                    if ((m_smVisionInfo.g_arrLightSource[j].ref_intSeqNo & (0x01 << i)) > 0)
                                                    {
                                                        intValue4 = m_smVisionInfo.g_arrLightSource[j].ref_arrValue[intValueNo];
                                                    }
                                                    break;
                                            }

                                            break;
                                        }
                                    }
                                }
                            }
                            //Set all light source for sequence light controller for each grab
                            LEDi_Control.SetSeqIntensity(m_smVisionInfo.g_arrLightSource[0].ref_intPortNo, 0, i, intValue1, intValue2, intValue3, intValue4);
                            Thread.Sleep(10);
                            //TrackLog objTL = new TrackLog();
                            //objTL.WriteLine("Vision 4");
                            //objTL.WriteLine("Sequence number: " + i.ToString());
                            //objTL.WriteLine("Com: " + m_smVisionInfo.g_arrLightSource[0].ref_intPortNo.ToString());
                            //objTL.WriteLine("Intensity 1: " + intValue1.ToString());
                            //objTL.WriteLine("Intensity 2: " + intValue2.ToString());
                            //objTL.WriteLine("Intensity 3: " + intValue3.ToString());
                        }
                    }
                    LEDi_Control.SaveIntensity(m_smVisionInfo.g_arrLightSource[0].ref_intPortNo, 0);
                    Thread.Sleep(100);
                    //Set to run mode
                    LEDi_Control.RunStop(m_smVisionInfo.g_arrLightSource[0].ref_intPortNo, 0, true);
                    Thread.Sleep(10);
                }
                else if (m_smCustomizeInfo.g_blnVTControl)
                {
                    //channel grouping
                    int intChannelNum = 0;
                    uint uintGroupNum = 0;
                    for (int k = 0; k < m_smVisionInfo.g_arrLightSource.Count; k++)
                    {
                        intChannelNum = m_smVisionInfo.g_arrLightSource[k].ref_intChannel;
                        //intChannelNum -= 1;
                        uintGroupNum += Convert.ToUInt32(Math.Pow(2, intChannelNum));
                    }
                    //TrackLog objTL = new TrackLog();
                    //objTL.WriteLine("m_smVisionInfo.g_arrLightSource[0].ref_intPortNo=" + m_smVisionInfo.g_arrLightSource[0].ref_intPortNo.ToString());
                    //objTL.WriteLine("uintGroupNum=" + uintGroupNum.ToString());
                    VT_Control.SetConfigMode(m_smVisionInfo.g_arrLightSource[0].ref_intPortNo);
                    VT_Control.SetGroupsAvailable(m_smVisionInfo.g_arrLightSource[0].ref_intPortNo, uintGroupNum);

                    //Setting active flag
                    for (int m = 0; m < m_intGrabRequire; m++)
                    {
                        //objTL.WriteLine("SetActiveOutFlag m=" + m.ToString());
                        VT_Control.SetActiveOutFlag(m_smVisionInfo.g_arrLightSource[0].ref_intPortNo, uintGroupNum, m, 1);
                    }

                    for (int j = 0; j < m_smVisionInfo.g_arrLightSource.Count; j++)
                    {
                        int intCount = 0;
                        for (int i = 0; i < m_intGrabRequire; i++)
                        {
                            if (m_intGrabRequire > 0)
                            {
                                // if this image no is in array intCount
                                if (m_smVisionInfo.g_arrLightSource[j].ref_arrImageNo != null)
                                {
                                    if (m_smVisionInfo.g_arrLightSource[j].ref_arrImageNo.Count != intCount)
                                    {
                                        if (m_smVisionInfo.g_arrLightSource[j].ref_arrImageNo[intCount] == i)
                                        {
                                            //objTL.WriteLine("Set Seq Intensity A Port=" + m_smVisionInfo.g_arrLightSource[j].ref_intPortNo.ToString() +
                                            //                ", i=" + i.ToString() +
                                            //                ", channel=" + m_smVisionInfo.g_arrLightSource[j].ref_intChannel.ToString() +
                                            //                ", value=" + m_smVisionInfo.g_arrLightSource[j].ref_arrValue[intCount].ToString());
                                            VT_Control.SetSeqIntensity(m_smVisionInfo.g_arrLightSource[j].ref_intPortNo, i, m_smVisionInfo.g_arrLightSource[j].ref_intChannel, m_smVisionInfo.g_arrLightSource[j].ref_arrValue[intCount]);
                                            intCount++;
                                        }
                                        else
                                        {
                                            //                    objTL.WriteLine("Set Seq Intensity B Port=" + m_smVisionInfo.g_arrLightSource[j].ref_intPortNo.ToString() +
                                            //", i=" + i.ToString() +
                                            //", channel=" + m_smVisionInfo.g_arrLightSource[j].ref_intChannel.ToString() +
                                            //", value=0");

                                            VT_Control.SetSeqIntensity(m_smVisionInfo.g_arrLightSource[j].ref_intPortNo, i, m_smVisionInfo.g_arrLightSource[j].ref_intChannel, 0);
                                        }
                                    }
                                    else
                                    {
                                        //                objTL.WriteLine("Set Seq Intensity C Port=" + m_smVisionInfo.g_arrLightSource[j].ref_intPortNo.ToString() +
                                        //", i=" + i.ToString() +
                                        //", channel=" + m_smVisionInfo.g_arrLightSource[j].ref_intChannel.ToString() +
                                        //", value=0");

                                        VT_Control.SetSeqIntensity(m_smVisionInfo.g_arrLightSource[j].ref_intPortNo, i, m_smVisionInfo.g_arrLightSource[j].ref_intChannel, 0);
                                    }
                                }
                            }
                        }
                        //VT_Control.SaveIntensity(m_smVisionInfo.g_arrLightSource[j].ref_intPortNo, m_smVisionInfo.g_arrLightSource[j].ref_intChannel);
                    }

                    //objTL.WriteLine("SetRunMode=" + m_smVisionInfo.g_arrLightSource[0].ref_intPortNo.ToString());
                    VT_Control.SetRunMode(m_smVisionInfo.g_arrLightSource[0].ref_intPortNo);
                }

            }
            else
            {
                if (m_intLightControlModel == 0) // 2018 07 13 - CCENG: Temporary force to use VTControl
                {
                    //Set to stop mode
                    LEDi_Control.RunStop(m_smVisionInfo.g_arrLightSource[0].ref_intPortNo, 0, false);
                    Thread.Sleep(10);
                    for (int i = 0; i < m_intGrabRequire; i++)
                    {
                        int intValue1 = 0;
                        int intValue2 = 0;
                        int intValue3 = 0;

                        if (m_intGrabRequire > 0)
                        {
                            for (int j = 0; j < m_smVisionInfo.g_arrLightSource.Count; j++)
                            {
                                int intValueNo = 0;

                                // Due to some light source only ON for second image so its intensity value is at array no. 0.
                                // So we need to loop to find which array no. is for that image
                                for (int k = 0; k < m_smVisionInfo.g_arrLightSource[j].ref_arrValue.Count; k++)
                                {
                                    // if this image no is in array k
                                    if (m_smVisionInfo.g_arrLightSource[j].ref_arrImageNo != null)
                                    {
                                        if (m_smVisionInfo.g_arrLightSource[j].ref_arrImageNo[k] == i)
                                        {
                                            intValueNo = k;

                                            switch (j)
                                            {
                                                case 0:
                                                    if ((m_smVisionInfo.g_arrLightSource[j].ref_intSeqNo & (0x01 << i)) > 0)
                                                    {
                                                        intValue1 = m_smVisionInfo.g_arrLightSource[j].ref_arrValue[intValueNo];
                                                    }
                                                    break;
                                                case 1:
                                                    if ((m_smVisionInfo.g_arrLightSource[j].ref_intSeqNo & (0x01 << i)) > 0)
                                                    {
                                                        intValue2 = m_smVisionInfo.g_arrLightSource[j].ref_arrValue[intValueNo];
                                                    }
                                                    break;
                                                case 2:
                                                    if ((m_smVisionInfo.g_arrLightSource[j].ref_intSeqNo & (0x01 << i)) > 0)
                                                    {
                                                        intValue3 = m_smVisionInfo.g_arrLightSource[j].ref_arrValue[intValueNo];
                                                    }
                                                    break;
                                            }

                                            break;
                                        }
                                    }
                                }
                            }
                            //Set all light source for sequence light controller for each grab
                            LEDi_Control.SetSeqIntensity(m_smVisionInfo.g_arrLightSource[0].ref_intPortNo, 0, i, intValue1, intValue2, intValue3, 0);
                            Thread.Sleep(10);
                            //TrackLog objTL = new TrackLog();
                            //objTL.WriteLine("Vision 4");
                            //objTL.WriteLine("Sequence number: " + i.ToString());
                            //objTL.WriteLine("Com: " + m_smVisionInfo.g_arrLightSource[0].ref_intPortNo.ToString());
                            //objTL.WriteLine("Intensity 1: " + intValue1.ToString());
                            //objTL.WriteLine("Intensity 2: " + intValue2.ToString());
                            //objTL.WriteLine("Intensity 3: " + intValue3.ToString());
                        }
                    }
                    LEDi_Control.SaveIntensity(m_smVisionInfo.g_arrLightSource[0].ref_intPortNo, 0);
                    Thread.Sleep(100);
                    //Set to run mode
                    LEDi_Control.RunStop(m_smVisionInfo.g_arrLightSource[0].ref_intPortNo, 0, true);
                    Thread.Sleep(10);
                }
                else if (m_intLightControlModel == 1) // 2018 07 13 - CCENG: Temporary force to use VTControl
                {
                    //channel grouping
                    int intChannelNum = 0;
                    uint uintGroupNum = 0;
                    for (int k = 0; k < m_smVisionInfo.g_arrLightSource.Count; k++)
                    {
                        intChannelNum = m_smVisionInfo.g_arrLightSource[k].ref_intChannel;
                        //intChannelNum -= 1;
                        uintGroupNum += Convert.ToUInt32(Math.Pow(2, intChannelNum));
                    }
                    //TrackLog objTL = new TrackLog();
                    //objTL.WriteLine("m_smVisionInfo.g_arrLightSource[0].ref_intPortNo=" + m_smVisionInfo.g_arrLightSource[0].ref_intPortNo.ToString());
                    //objTL.WriteLine("uintGroupNum=" + uintGroupNum.ToString());
                    VT_Control.SetConfigMode(m_smVisionInfo.g_arrLightSource[0].ref_intPortNo);
                    VT_Control.SetGroupsAvailable(m_smVisionInfo.g_arrLightSource[0].ref_intPortNo, uintGroupNum);

                    //Setting active flag
                    for (int m = 0; m < m_intGrabRequire; m++)
                    {
                        //objTL.WriteLine("SetActiveOutFlag m=" + m.ToString());
                        VT_Control.SetActiveOutFlag(m_smVisionInfo.g_arrLightSource[0].ref_intPortNo, uintGroupNum, m, 1);
                    }

                    for (int j = 0; j < m_smVisionInfo.g_arrLightSource.Count; j++)
                    {
                        int intCount = 0;
                        for (int i = 0; i < m_intGrabRequire; i++)
                        {
                            if (m_intGrabRequire > 0)
                            {
                                // if this image no is in array intCount
                                if (m_smVisionInfo.g_arrLightSource[j].ref_arrImageNo != null)
                                {
                                    if (m_smVisionInfo.g_arrLightSource[j].ref_arrImageNo.Count != intCount)
                                    {
                                        if (m_smVisionInfo.g_arrLightSource[j].ref_arrImageNo[intCount] == i)
                                        {
                                            //objTL.WriteLine("Set Seq Intensity A Port=" + m_smVisionInfo.g_arrLightSource[j].ref_intPortNo.ToString() +
                                            //                ", i=" + i.ToString() +
                                            //                ", channel=" + m_smVisionInfo.g_arrLightSource[j].ref_intChannel.ToString() +
                                            //                ", value=" + m_smVisionInfo.g_arrLightSource[j].ref_arrValue[intCount].ToString());
                                            VT_Control.SetSeqIntensity(m_smVisionInfo.g_arrLightSource[j].ref_intPortNo, i, m_smVisionInfo.g_arrLightSource[j].ref_intChannel, m_smVisionInfo.g_arrLightSource[j].ref_arrValue[intCount]);
                                            intCount++;
                                        }
                                        else
                                        {
                                            //                    objTL.WriteLine("Set Seq Intensity B Port=" + m_smVisionInfo.g_arrLightSource[j].ref_intPortNo.ToString() +
                                            //", i=" + i.ToString() +
                                            //", channel=" + m_smVisionInfo.g_arrLightSource[j].ref_intChannel.ToString() +
                                            //", value=0");

                                            VT_Control.SetSeqIntensity(m_smVisionInfo.g_arrLightSource[j].ref_intPortNo, i, m_smVisionInfo.g_arrLightSource[j].ref_intChannel, 0);
                                        }
                                    }
                                    else
                                    {
                                        //                objTL.WriteLine("Set Seq Intensity C Port=" + m_smVisionInfo.g_arrLightSource[j].ref_intPortNo.ToString() +
                                        //", i=" + i.ToString() +
                                        //", channel=" + m_smVisionInfo.g_arrLightSource[j].ref_intChannel.ToString() +
                                        //", value=0");

                                        VT_Control.SetSeqIntensity(m_smVisionInfo.g_arrLightSource[j].ref_intPortNo, i, m_smVisionInfo.g_arrLightSource[j].ref_intChannel, 0);
                                    }
                                }
                            }
                        }
                        //VT_Control.SaveIntensity(m_smVisionInfo.g_arrLightSource[j].ref_intPortNo, m_smVisionInfo.g_arrLightSource[j].ref_intChannel);
                    }

                    //objTL.WriteLine("SetRunMode=" + m_smVisionInfo.g_arrLightSource[0].ref_intPortNo.ToString());
                    VT_Control.SetRunMode(m_smVisionInfo.g_arrLightSource[0].ref_intPortNo);
                }

            }

            m_smVisionInfo.g_fEmptyCameraShuttle = objFileHandle.GetValueAsFloat("EmptyShutter", 200f);
            for (int i = 0; i < m_smVisionInfo.g_arrCameraShuttle.Count; i++)
            {
                m_smVisionInfo.g_arrCameraShuttle[i] = objFileHandle.GetValueAsFloat("Shutter" + i.ToString(), 0f);

                if (m_smVisionInfo.g_arrCameraShuttle[i] == 0)
                {
                    m_smVisionInfo.g_arrCameraShuttle[i] = Convert.ToUInt32(m_smVisionInfo.g_fCameraShuttle);
                }

                if (i == 0)
                {
                    if (m_smVisionInfo.g_strCameraModel == "AVT")
                        m_objAVTFireGrab.SetCameraParameter(1, (uint)m_smVisionInfo.g_arrCameraShuttle[i]);
                    else if (m_smVisionInfo.g_strCameraModel == "Teli")
                        m_objTeliCamera.SetCameraParameter(1, m_smVisionInfo.g_arrCameraShuttle[i]);
                    m_fCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[i];
                }
            }
            m_smVisionInfo.g_uintEmptyCameraGain = (uint)objFileHandle.GetValueAsInt("EmptyGain", 20);
            for (int i = 0; i < m_smVisionInfo.g_arrCameraGain.Count; i++)
            {
                m_smVisionInfo.g_arrCameraGain[i] = (uint)objFileHandle.GetValueAsInt("Gain" + i.ToString(), 1);

                if (i == 0)
                {
                    if (m_smVisionInfo.g_strCameraModel == "AVT")
                        m_objAVTFireGrab.SetCameraParameter(2, m_smVisionInfo.g_arrCameraGain[i]);
                    else if (m_smVisionInfo.g_strCameraModel == "Teli")
                        m_objTeliCamera.SetCameraParameter(2, m_smVisionInfo.g_arrCameraGain[i]);

                    m_intCameraGainPrev = m_smVisionInfo.g_arrCameraGain[i];
                }
            }
            m_smVisionInfo.g_fEmptyImageGain = objFileHandle.GetValueAsFloat("EmptyImageGain", 1);
            for (int i = 0; i < m_smVisionInfo.g_arrImageGain.Count; i++)
            {
                m_smVisionInfo.g_arrImageGain[i] = objFileHandle.GetValueAsFloat("ImageGain" + i.ToString(), 1);
            }

            objFileHandle.GetSecondSection("EnhanceImage");
            m_smVisionInfo.g_intEnhanceImage_Close = objFileHandle.GetValueAsInt("EnhanceImage_Close", 0, 2);
            m_smVisionInfo.g_blnEnhanceImage_Enable = objFileHandle.GetValueAsBoolean("EnhanceImage_Enable", false, 2);
            m_smVisionInfo.g_intEnhanceImage_Open = objFileHandle.GetValueAsInt("EnhanceImage_Open", 1, 2);
            m_smVisionInfo.g_intEnhanceImage_Dilate = objFileHandle.GetValueAsInt("EnhanceImage_Dilate", 1, 2);
            m_smVisionInfo.g_intEnhanceImage_Offset = objFileHandle.GetValueAsInt("EnhanceImage_Offset", -50, 2);
            m_smVisionInfo.g_fEnhanceImage_Gain = objFileHandle.GetValueAsFloat("EnhanceImage_Gain", 2, 2);

            // Define Image View Count
            m_smVisionInfo.g_intImageViewCount = m_intGrabRequire;
            ImageDrawing.SetImageCount(m_intGrabRequire, m_smVisionInfo.g_intVisionIndex);
            ImageDrawing.SetImageMergeType(m_smVisionInfo.g_intImageMergeType, m_smVisionInfo.g_intVisionIndex);
            if (m_smVisionInfo.g_blnViewColorImage)
            {
                CImageDrawing.SetImageCount(m_intGrabRequire, m_smVisionInfo.g_intVisionIndex);
                CImageDrawing.SetImageMergeType(m_smVisionInfo.g_intImageMergeType, m_smVisionInfo.g_intVisionIndex);
            }

            if (m_smVisionInfo.g_intSelectedImage >= m_smVisionInfo.g_arrImages.Count)
            {
                m_smVisionInfo.g_intSelectedImage = 0;
            }

            return blnInitSuccess;
        }

        /// <summary>
        /// Returns whether the worker thread has stopped.
        /// </summary>
        public bool IsThreadStopped
        {
            get
            {
                //lock (m_objStopLock)
                {
                    return m_blnStopped;
                }
            }
        }
        /// <summary>
        /// Tells the thread to stop, typically after completing its 
        /// current work item.
        /// </summary>
        public void StopThread()
        {
            //lock (m_objStopLock)
            {
                m_blnStopping = true;
            }

            WaitAllThreadStopped();
        }

        public void PauseThread()
        {
            m_blnPause = true;
        }

        public void StartThread()
        {
            m_blnPause = false;
        }

        private void AttachImageToROI()
        {
            m_smVisionInfo.g_arrImages[0].CopyTo(m_smVisionInfo.g_arrRotatedImages[0]);
            if (m_smVisionInfo.g_blnViewColorImage)
                m_smVisionInfo.g_arrColorImages[0].CopyTo(m_smVisionInfo.g_arrColorRotatedImages[0]);
            m_smVisionInfo.g_objCameraROI.AttachImage(m_smVisionInfo.g_arrImages[0]);
            m_smVisionInfo.g_objCalibrateROI.AttachImage(m_smVisionInfo.g_arrImages[0]);

            if ((m_smCustomizeInfo.g_intWantOrient & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
            {
                AttachToROI(m_smVisionInfo.g_arrOrientROIs, m_smVisionInfo.g_arrImages[0]);
            }
            if ((m_smCustomizeInfo.g_intWantMark & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
            {
                AttachToROI(m_smVisionInfo.g_arrMarkROIs, m_smVisionInfo.g_arrImages[0]);
            }
            if ((m_smCustomizeInfo.g_intWantPackage & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
            {
                for(int i = 1; i < m_smVisionInfo.g_arrImages.Count; i++)
                m_smVisionInfo.g_arrImages[i].CopyTo(m_smVisionInfo.g_arrRotatedImages[i]);
                if (m_smVisionInfo.g_blnViewColorImage)
                {
                    for (int i = 1; i < m_smVisionInfo.g_arrColorImages.Count; i++)
                        m_smVisionInfo.g_arrColorImages[i].CopyTo(m_smVisionInfo.g_arrColorRotatedImages[i]);
                    AttachToROI(m_smVisionInfo.g_arrColorPackageROIs, m_smVisionInfo.g_arrColorImages[0]);
                }
            }
            // 2019 06 21 - CCENG: Attach to image as long as g_arrPositioningROIs object is declaced.
            //if ((m_smCustomizeInfo.g_intWantPositioning & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
            {
                for (int i = 0; i < m_smVisionInfo.g_arrPositioningROIs.Count; i++)
                {
                    if (m_smVisionInfo.g_arrPositioningROIs[i].ref_intType == 1)
                        m_smVisionInfo.g_arrPositioningROIs[i].AttachImage(m_smVisionInfo.g_arrImages[0]);
                    else
                        m_smVisionInfo.g_arrPositioningROIs[i].AttachImage(m_smVisionInfo.g_arrPositioningROIs[0]);
                }
            }

            ////////////////////////////////////////////////
            if (m_smVisionInfo.g_blnWantCheckEmpty)
            {
                for (int i = 0; i < m_smVisionInfo.g_arrPositioningROIs.Count; i++)
                {
                    if (m_smVisionInfo.g_arrPositioningROIs[i].ref_intType == 1)
                        m_smVisionInfo.g_arrPositioningROIs[i].AttachImage(m_smVisionInfo.g_arrImages[0]);
                }
            }
            //////////////////////////////////////////////////////


            //if ((m_smCustomizeInfo.g_intWantLead & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
            //    AttachToROI(m_smVisionInfo.g_arrLeadROIs, m_smVisionInfo.g_arrImages, m_smVisionInfo.g_arrLead[0].ref_intImageViewNo);

            if (m_smVisionInfo.g_intMachineStatus != 2)
            {
                m_smVisionInfo.ALL_VM_UpdatePictureBox = true;
            }
            m_smVisionInfo.VS_VM_UpdateSmallPictureBox = true;
        }
        private void AttachToROI(List<List<CROI>> arrROI, CImageDrawing objImage)
        {
            CROI objROI;

            for (int i = 0; i < arrROI.Count; i++)
            {
                for (int j = 0; j < arrROI[i].Count; j++)
                {
                    objROI = (CROI)arrROI[i][j];

                    switch (objROI.ref_intType)
                    {
                        case 1:
                            objROI.AttachImage(objImage);
                            break;
                        case 2:
                            objROI.AttachImage((CROI)arrROI[i][0]);
                            break;
                    }
                    arrROI[i][j] = objROI;
                }
            }

            objROI = null;
        }
        private void AttachToROI(List<List<ROI>> arrROI, ImageDrawing objImage)
        {
            ROI objROI;

            for (int i = 0; i < arrROI.Count; i++)
            {
                for (int j = 0; j < arrROI[i].Count; j++)
                {
                    objROI = (ROI)arrROI[i][j];

                    switch (objROI.ref_intType)
                    {
                        case 1:
                            objROI.AttachImage(objImage);
                            break;
                        case 2:
                            objROI.AttachImage((ROI)arrROI[i][0]);
                            break;
                    }
                    arrROI[i][j] = objROI;
                }
            }

            objROI = null;
        }

        private void CheckLowYield()
        {
            if (!m_smVisionInfo.g_blnStopLowYield)//m_smCustomizeInfo.g_blnStopLowYield)
                return;

            if (m_smVisionInfo.g_intTestedTotal != 0)
            {
                float fYield = m_smVisionInfo.g_intPassTotal / (float)m_smVisionInfo.g_intTestedTotal * 100;
                if ((fYield <= m_smVisionInfo.g_fLowYield) && (m_smVisionInfo.g_intLowYieldUnitCount >= m_smVisionInfo.g_intMinUnitCheck)) //m_smCustomizeInfo.g_fLowYield , m_smCustomizeInfo.g_intMinUnitCheck
                {
                    m_smProductionInfo.PR_AT_StopProduction = true;
                    m_smVisionInfo.g_intMachineStatus = 1;
                    m_smVisionInfo.g_intLowYieldUnitCount = 0;
                    m_smVisionInfo.g_strErrorMessage += "Low Yield Fail!";
                }
            }
        }
        private void CheckContinuousPass()
        {
            if (!m_smVisionInfo.g_blnStopContinuousPass)
                return;

            if (m_smVisionInfo.g_intTestedTotal != 0)
            {
                if (m_smVisionInfo.g_intContinuousPassUnitCount >= m_smVisionInfo.g_intMinPassUnit)
                {
                    m_smProductionInfo.PR_AT_StopProduction = true;
                    m_smVisionInfo.g_intMachineStatus = 1;
                    m_smVisionInfo.g_intContinuousPassUnitCount = 0;
                    m_smVisionInfo.g_strErrorMessage += "*Continuous Pass " + m_smVisionInfo.g_intMinPassUnit.ToString() + " Unit(s)!";
                }
            }
        }

        private void CheckContinuousFail()
        {
            if (!m_smVisionInfo.g_blnStopContinuousFail)
                return;

            if (m_smVisionInfo.g_intTestedTotal != 0)
            {
                if (m_smVisionInfo.g_intContinuousFailUnitCount >= m_smVisionInfo.g_intMinFailUnit)
                {
                    m_smProductionInfo.PR_AT_StopProduction = true;
                    m_smVisionInfo.g_intMachineStatus = 1;
                    m_smVisionInfo.g_intContinuousFailUnitCount = 0;
                    m_smVisionInfo.g_strErrorMessage += "*Continuous Fail " + m_smVisionInfo.g_intMinFailUnit.ToString() + " Unit(s)!";
                }
            }
        }
        private bool DeleteTemplate()
        {
            try
            {
                //// Delete OCV array object
                //for (int u = 0; u < m_smVisionInfo.g_intUnitsOnImage; u++)
                //{
                //    int intTemplateCount = m_smVisionInfo.g_arrOCVs[u].Count;
                //    for (int i = intTemplateCount - 1; i >= 0; i--)
                //    {
                //        m_smVisionInfo.g_arrOCVs[u].RemoveAt(i);
                //    }
                //}
                //m_smVisionInfo.g_intTemplateMask = 0;
                //m_smVisionInfo.g_intTemplatePriority = 0;
                //m_smVisionInfo.g_intTotalGroup = 0;
                //m_smVisionInfo.g_intTotalTemplates = 0;

                string strFolderPath = m_smProductionInfo.g_strRecipePath + m_smProductionInfo.g_arrSingleRecipeID[m_smVisionInfo.g_intVisionIndex] + "\\" + m_smVisionInfo.g_strVisionFolderName + "\\";

                // 2019 07 31 - JBTAN: Delete all mark template
                for (int u = 0; u < m_smVisionInfo.g_intUnitsOnImage; u++)
                {
                    m_smVisionInfo.g_arrMarks[u].DeleteAllPreviousTemplate(strFolderPath + "Mark\\");
                    m_smVisionInfo.g_arrMarks[u].SaveSingleTemplate(strFolderPath + "Mark\\Template\\", false, false); // 2020-05-11 ZJYEOH: Save first template setting 
                    m_smVisionInfo.g_arrMarks[u].ClearTemplateSetting();
                    m_smVisionInfo.g_blnUnitInspected[u] = false;
                }

                // Reset variables
                m_smVisionInfo.g_intTotalGroup = 1; //Group count is always 1
                m_smVisionInfo.g_intTotalTemplates = 0;
                m_smVisionInfo.g_intTemplateMask = 0;
                m_smVisionInfo.g_intTemplatePriority = 0;

                XmlParser objFile = new XmlParser(strFolderPath + "General.xml");
                objFile.WriteSectionElement("TemplateCounting");
                objFile.WriteElement1Value("TotalGroups", m_smVisionInfo.g_intTotalGroup);
                objFile.WriteElement1Value("TotalTemplates", m_smVisionInfo.g_intTotalTemplates);
                objFile.WriteElement1Value("TemplateMask", m_smVisionInfo.g_intTemplateMask);
                objFile.WriteElement1Value("TemplatePriority", m_smVisionInfo.g_intTemplatePriority);

                objFile.WriteEndElement();

                m_smVisionInfo.PG_VM_LoadTemplate = true;
                m_smVisionInfo.VM_AT_TemplateNotLearn = true;
            }
            catch
            {
                return false;
            }
            return false;
        }

        private string DisplayMarkTestResult(int intMarkFailMask, int intUnitNo)
        {
            int intCount = m_smVisionInfo.g_arrOCVs[intUnitNo][m_smVisionInfo.g_intSelectedGroup].Count;
            int intCharSetValue;
            float fScoreValue;
            string strErrorMessage = "";
            int intStartLearnNo = 0;
            if (!m_smVisionInfo.g_blnInspectAllTemplate)
                intStartLearnNo = m_smVisionInfo.g_intSelectedTemplate;

            float fGradientScore;
            float fBinarizedScore;
            for (int ln = intStartLearnNo; ln < intCount; ln++)
            {
                OCV objOCV = (OCV)m_smVisionInfo.g_arrOCVs[intUnitNo][m_smVisionInfo.g_intSelectedGroup][ln];
                for (int i = 0; i < objOCV.ref_intCharsCount; i++)
                {
                    intCharSetValue = objOCV.GetCharSetting(i);
                    fGradientScore = objOCV.GetOcvScore(i);
                    fBinarizedScore = objOCV.GetBinarizedOcvScore(i);
                    if ((fGradientScore >= fBinarizedScore) || ((fGradientScore < 101) && (fBinarizedScore == 101)))
                        fScoreValue = fGradientScore;
                    else
                        fScoreValue = fBinarizedScore;
                    if ((intCharSetValue > fGradientScore) &&
                        (intCharSetValue > fBinarizedScore))
                    {
                        strErrorMessage += "*Unit " + (intUnitNo + 1)
                                        + " Fail Mark :" + " Template " + (ln + 1)
                                        + ", Mark " + i + " : Set="
                                        + intCharSetValue.ToString() + "% Score= "
                                        + fScoreValue.ToString("F2") + "%";
                    }
                }
                if (!m_smVisionInfo.g_blnInspectAllTemplate)
                    break;
            }

            if ((intMarkFailMask & 0x01) > 0)
                strErrorMessage += "*Unit " + (intUnitNo + 1) + " Text Not Found! ";
            if ((intMarkFailMask & 0x02) > 0)
                strErrorMessage += "*Unit " + (intUnitNo + 1) + " Text Mismatch! ";
            if ((intMarkFailMask & 0x04) > 0)
                strErrorMessage += "*Unit " + (intUnitNo + 1) + " Text Overprint! ";
            if ((intMarkFailMask & 0x08) > 0)
                strErrorMessage += "*Unit " + (intUnitNo + 1) + " Text Underprint! ";
            if ((intMarkFailMask & 0x100) > 0)
                strErrorMessage += "*Unit " + (intUnitNo + 1) + " Extra Mark! ";
            if ((intMarkFailMask & 0x200) > 0)
                strErrorMessage += "*Unit " + (intUnitNo + 1) + " Broken Mark! ";
            if ((intMarkFailMask & 0x400) > 0)
                strErrorMessage += "*Unit " + (intUnitNo + 1) + " Excess Mark! ";
            if ((intMarkFailMask & 0x800) > 0)
                strErrorMessage += "*Unit " + (intUnitNo + 1) + " Broken Mark! ";
            if ((intMarkFailMask & 0x1000) > 0)
                strErrorMessage += "*Unit " + (intUnitNo + 1) + " Joint Mark! ";
            if ((intMarkFailMask & 0x2000) > 0)
                strErrorMessage += "*Unit " + (intUnitNo + 1) + " Text Shfited! ";
            if ((intMarkFailMask & 0x4000) > 0)
                strErrorMessage += "*Unit " + (intUnitNo + 1) + " Total Extra Mark! ";

            return strErrorMessage;
        }

        /// <summary>
        /// Save different category of reject image
        /// </summary>
        /// <param name="strModule">Reject Image category name</param>
        private void SaveRejectImage_AddToBuffer(string strRejectName, string strRejectMessage)
        {
            if (m_smCustomizeInfo.g_blnSaveFailImage)
            {
                if (m_smCustomizeInfo.g_intSaveImageMode == 0)
                {
                    if (m_smVisionInfo.g_intFailImageCount >= m_smCustomizeInfo.g_intFailImagePics)
                        return;
                }

                if (m_smVisionInfo.g_intUnitsOnImage == 2)
                {
                    if (!m_smCustomizeInfo.g_blnWantUseTCPIPIO && m_objVisionIO.InPocketReTest.IsOff(!m_blnDefaultRetestON))
                    {
                        m_intRetryCount++;
                    }
                    else if (m_smCustomizeInfo.g_blnWantUseTCPIPIO && !m_blnInPocketReTest_In)
                    {
                        m_intRetryCount++;
                    }
                    else
                    {
                        if (m_intRetryCount > 0)
                            m_intRetryCount = 0;
                    }
                }
                else
                {
                    if (!m_smCustomizeInfo.g_blnWantUseTCPIPIO && m_objVisionIO.InPocketReTest.IsOn(m_blnDefaultRetestON))
                    {
                        m_intRetryCount++;
                    }
                    else if (m_smCustomizeInfo.g_blnWantUseTCPIPIO && m_blnInPocketReTest_In)
                    {
                        m_intRetryCount++;
                    }
                    else
                    {
                        if (m_intRetryCount > 0)
                            m_intRetryCount = 0;
                    }
                }

                //STTrackLog.WriteLine("SaveRejectImage_AddToBuffer 1");
                WaitImageBufferClear(ref m_intFailStartNode, ref m_intFailEndNode);
                //To handle case when test fail before all image grab complete

                //STTrackLog.WriteLine("SaveRejectImage_AddToBuffer 2");
                WaitAllImageGrabDone();

                //STTrackLog.WriteLine("SaveRejectImage_AddToBuffer 3");

                if (m_smVisionInfo.g_blnViewColorImage)
                    m_smVisionInfo.g_arrColorImages[0].CopyTo(ref m_arrFailCImage1Buffer[m_intFailEndNode]);
                else
                    m_smVisionInfo.g_arrImages[0].CopyTo(ref m_arrFailImage1Buffer[m_intFailEndNode]);

                if (m_smVisionInfo.g_arrImages.Count > 1)
                {
                    if (m_smVisionInfo.g_blnViewColorImage)
                        m_smVisionInfo.g_arrColorImages[1].CopyTo(ref m_arrFailCImage2Buffer[m_intFailEndNode]);
                    else
                        m_smVisionInfo.g_arrImages[1].CopyTo(ref m_arrFailImage2Buffer[m_intFailEndNode]);
                }

                if (m_smVisionInfo.g_arrImages.Count > 2)
                {
                    if (m_smVisionInfo.g_blnViewColorImage)
                        m_smVisionInfo.g_arrColorImages[2].CopyTo(ref m_arrFailCImage3Buffer[m_intFailEndNode]);
                    else
                        m_smVisionInfo.g_arrImages[2].CopyTo(ref m_arrFailImage3Buffer[m_intFailEndNode]);
                }

                if (m_smVisionInfo.g_arrImages.Count > 3)
                {
                    if (m_smVisionInfo.g_blnViewColorImage)
                        m_smVisionInfo.g_arrColorImages[3].CopyTo(ref m_arrFailCImage4Buffer[m_intFailEndNode]);
                    else
                        m_smVisionInfo.g_arrImages[3].CopyTo(ref m_arrFailImage4Buffer[m_intFailEndNode]);
                }

                if (m_smVisionInfo.g_arrImages.Count > 4)
                {
                    if (m_smVisionInfo.g_blnViewColorImage)
                        m_smVisionInfo.g_arrColorImages[4].CopyTo(ref m_arrFailCImage5Buffer[m_intFailEndNode]);
                    else
                        m_smVisionInfo.g_arrImages[4].CopyTo(ref m_arrFailImage5Buffer[m_intFailEndNode]);
                }

                if (m_smVisionInfo.g_arrImages.Count > 5)
                {
                    if (m_smVisionInfo.g_blnViewColorImage)
                        m_smVisionInfo.g_arrColorImages[5].CopyTo(ref m_arrFailCImage6Buffer[m_intFailEndNode]);
                    else
                        m_smVisionInfo.g_arrImages[5].CopyTo(ref m_arrFailImage6Buffer[m_intFailEndNode]);
                }

                if (m_smVisionInfo.g_arrImages.Count > 6)
                {
                    if (m_smVisionInfo.g_blnViewColorImage)
                        m_smVisionInfo.g_arrColorImages[6].CopyTo(ref m_arrFailCImage7Buffer[m_intFailEndNode]);
                    else
                        m_smVisionInfo.g_arrImages[6].CopyTo(ref m_arrFailImage7Buffer[m_intFailEndNode]);
                }

                m_arrRejectNameBuffer[m_intFailEndNode] = strRejectName;
                m_arrRetryCountBuffer[m_intFailEndNode] = m_intRetryCount;
                m_arrRejectMessageBuffer[m_intFailEndNode] = strRejectMessage;
                //m_arrFailNoBuffer[m_intFailEndNode] = m_smVisionInfo.g_intFailImageCount;
                m_arrFailNoBuffer[m_intFailEndNode] = m_smVisionInfo.g_intTotalImageCount;  // 2019 09 18 - CCENG: Use total image count instead of Fail Image count so that pass fail image will display in sequence.
                                                                                            //if (m_intRetryCount == 0)
                                                                                            //{
                                                                                            //    m_smVisionInfo.g_intTotalImageCount++;  // 2020 01 09 - CCENG: Total count will only ++ if not retest.
                                                                                            //}
                if (m_smVisionInfo.g_intUnitsOnImage == 2)
                {
                    if (m_intRetryCount == 0)
                    {
                        m_smVisionInfo.g_intTotalImageCount++;  // 2020 01 09 - CCENG: When unit fail, Total count will only ++ if end of retest.
                    }
                }
                else
                {
                    if (m_smVisionInfo.g_blnInPocketRetestEnd) //if (m_intRetryCount == 0)  // if fai
                    {
                        m_smVisionInfo.g_intTotalImageCount++;  // 2020 01 09 - CCENG: When unit fail, Total count will only ++ if end of retest.
                    }
                }

                m_smVisionInfo.g_intFailImageCount++;

                m_intFailEndNode++;
                //STTrackLog.WriteLine("F0 Start=" + m_intFailStartNode.ToString() + ", End=" + m_intFailEndNode.ToString());
                if (m_smVisionInfo.g_blnViewColorImage)
                {
                    if (m_intFailEndNode == m_smVisionInfo.g_intSaveImageBufferSize)
                        m_intFailEndNode = 0;
                }
                else
                {
                    if (m_intFailEndNode == m_smVisionInfo.g_intSaveImageBufferSize)
                        m_intFailEndNode = 0;
                }
            }
        }

        private void SavePassImage_AddToBuffer(int intUnitNo)
        {
            if (m_smCustomizeInfo.g_blnSavePassImage)
            {
                if (m_smVisionInfo.g_intPassImageCount < m_smCustomizeInfo.g_intPassImagePics)
                {
                    STTrackLog.WriteLine("SavePassImage_AddToBuffer 1");
                    WaitImageBufferClear(ref m_intPassStartNode, ref m_intPassEndNode);

                    STTrackLog.WriteLine("SavePassImage_AddToBuffer 2. m_intPassEndNode=" + m_intPassEndNode.ToString());
                    if (m_smVisionInfo.g_blnViewColorImage)
                        m_smVisionInfo.g_arrColorImages[0].CopyTo(ref m_arrPassCImage1Buffer[m_intPassEndNode]);
                    else
                        m_smVisionInfo.g_arrImages[0].CopyTo(ref m_arrPassImage1Buffer[m_intPassEndNode]);

                    if (m_smVisionInfo.g_arrImages.Count > 1)
                    {
                        if (m_smVisionInfo.g_blnViewColorImage)
                            m_smVisionInfo.g_arrColorImages[1].CopyTo(ref m_arrPassCImage2Buffer[m_intPassEndNode]);
                        else
                            m_smVisionInfo.g_arrImages[1].CopyTo(ref m_arrPassImage2Buffer[m_intPassEndNode]);
                    }

                    if (m_smVisionInfo.g_arrImages.Count > 2)
                    {
                        if (m_smVisionInfo.g_blnViewColorImage)
                            m_smVisionInfo.g_arrColorImages[2].CopyTo(ref m_arrPassCImage3Buffer[m_intPassEndNode]);
                        else
                            m_smVisionInfo.g_arrImages[2].CopyTo(ref m_arrPassImage3Buffer[m_intPassEndNode]);
                    }

                    if (m_smVisionInfo.g_arrImages.Count > 3)
                    {
                        if (m_smVisionInfo.g_blnViewColorImage)
                            m_smVisionInfo.g_arrColorImages[3].CopyTo(ref m_arrPassCImage4Buffer[m_intPassEndNode]);
                        else
                            m_smVisionInfo.g_arrImages[3].CopyTo(ref m_arrPassImage4Buffer[m_intPassEndNode]);
                    }

                    if (m_smVisionInfo.g_arrImages.Count > 4)
                    {
                        if (m_smVisionInfo.g_blnViewColorImage)
                            m_smVisionInfo.g_arrColorImages[4].CopyTo(ref m_arrPassCImage5Buffer[m_intPassEndNode]);
                        else
                            m_smVisionInfo.g_arrImages[4].CopyTo(ref m_arrPassImage5Buffer[m_intPassEndNode]);
                    }

                    if (m_smVisionInfo.g_arrImages.Count > 5)
                    {
                        if (m_smVisionInfo.g_blnViewColorImage)
                            m_smVisionInfo.g_arrColorImages[5].CopyTo(ref m_arrPassCImage6Buffer[m_intPassEndNode]);
                        else
                            m_smVisionInfo.g_arrImages[5].CopyTo(ref m_arrPassImage6Buffer[m_intPassEndNode]);
                    }

                    if (m_smVisionInfo.g_arrImages.Count > 6)
                    {
                        if (m_smVisionInfo.g_blnViewColorImage)
                            m_smVisionInfo.g_arrColorImages[6].CopyTo(ref m_arrPassCImage7Buffer[m_intPassEndNode]);
                        else
                            m_smVisionInfo.g_arrImages[6].CopyTo(ref m_arrPassImage7Buffer[m_intPassEndNode]);
                    }

                    m_arrOrientationBuffer[m_intPassEndNode] = m_smVisionInfo.g_intOrientResult[intUnitNo];
                    m_arrUnitNoBuffer[m_intPassEndNode] = intUnitNo;
                    //m_arrPassNoBuffer[m_intPassEndNode] = m_smVisionInfo.g_intPassImageCount;
                    m_arrPassNoBuffer[m_intPassEndNode] = m_smVisionInfo.g_intTotalImageCount;  // 2019 09 18 - CCENG: Use total image count instead of Pass Image count so that pass fail image will display in sequence.
                    m_smVisionInfo.g_intTotalImageCount++;
                    m_smVisionInfo.g_intPassImageCount++;


                    m_intPassEndNode++;
                    STTrackLog.WriteLine("SavePassImage_AddToBuffer 3. m_intPassEndNode=" + m_intPassEndNode.ToString());

                    if (m_intPassEndNode == m_smVisionInfo.g_intSaveImageBufferSize)
                        m_intPassEndNode = 0;
                }
            }
        }

        private void SetGrabDone(bool blnForInspection)
        {
            if (!m_blnSentGrabDone)
            {
                m_blnSentGrabDone = true;

                float fGrabDelay = 5 - m_smVisionInfo.g_objGrabTime.Timing;
                if (fGrabDelay >= 1)

                    Thread.Sleep((int)fGrabDelay);

                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                {
                    if (blnForInspection) //2021-11-16 ZJYEOH : Change m_smVisionInfo.g_intMachineStatus == 2 to blnForInspection
                        m_smTCPIPIO.Send(m_smVisionInfo.g_intVisionIndex, "GRBRP", true, -1);
                }
            }

            m_blnGrabbing_Out = false;
            m_smVisionInfo.g_objGrabTime.Stop();
        }
        private int GetLargestGaugeImageNo(RectGaugeM4L objGauge)
        {
            int[] arrPackageSizeImageIndex = { };

            arrPackageSizeImageIndex = objGauge.GetGaugeImageNoList();

            int intMinImageIndex = 0;
            for (int j = 0; j < 4; j++)
            {
                if (arrPackageSizeImageIndex[j] > intMinImageIndex)
                    intMinImageIndex = arrPackageSizeImageIndex[j];
            }

            return intMinImageIndex;
        }
        private bool StartPackageSizeTest(bool blnAuto, int intUnitNo, ref float ObjectWidth, ref float ObjectHeight)
        {
            m_strTracking_StartPackageSizeTest = "1,";
            // 2019 07 15 - CCENG: Need to measure package size even though no check package size because need the unit edge for inspect package defect.
            if ((m_smCustomizeInfo.g_intWantPackage & (1 << m_smVisionInfo.g_intVisionPos)) == 0 ||
                ((m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailMask & 0x1000) == 0 && !m_smVisionInfo.g_arrPackage[intUnitNo].GetWantInspectPackage()))
            //if ((m_smCustomizeInfo.g_intWantPackage & (1 << m_smVisionInfo.g_intVisionPos)) == 0 || (m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailMask & 0x1000) == 0)
            {
                if (intUnitNo == 0)
                {
                    m_bPackageSizePreTestResult1 = false;
                    m_bPackageSizePreTestDone1 = true;
                }
                else
                {
                    m_bPackageSizePreTestResult2 = false;
                    m_bPackageSizePreTestDone2 = true;
                }
                return true;
            }

            m_strTracking_StartPackageSizeTest += "2,";
            // Check is templates learnt
            if (m_smVisionInfo.g_arrPackageROIs.Count <= intUnitNo || m_smVisionInfo.g_arrPackageROIs[intUnitNo].Count == 0)
            {
                if (intUnitNo == 0)
                {
                    m_bPackageSizePreTestResult1 = false;
                    m_bPackageSizePreTestDone1 = true;

                    WaitEventDone(ref m_bMarkTestDone1, true, 10000, "StartPackageSizeTest > m_bMarkTestDone1 4419");    //m_bSubTh_MarkTest,false// need to wait for mark inspection done. Because package size fail should not display error msg if mark fail.
                    if (!m_bSubTh_MarkTest_Result)
                    {
                        return false;   // Skip package counter if mark fail because counter will add to mark
                    }
                }
                else
                {
                    m_bPackageSizePreTestResult2 = false;
                    m_bPackageSizePreTestDone2 = true;

                    WaitEventDone(ref m_bMarkTestDone2, true, 10000, "StartPackageSizeTest > m_bMarkTestDone2 4430");  //m_bSubTh_MarkTest,false  // need to wait for mark inspection done. Because package size fail should not display error msg if mark fail.
                    if (!m_bSubTh_MarkTest_Result2)
                    {
                        return false;   // Skip package counter if mark fail because counter will add to mark
                    }
                }

                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 1 PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());

                if (intUnitNo == 1)
                {
                    m_smVisionInfo.g_strErrorMessageForSecondUnit += GetUnitName(intUnitNo) + "*Package : No Template Found";
                }
                else
                {
                    m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + "*Package : No Template Found";
                }

                if (blnAuto)
                {
                    SaveRejectImage_AddToBuffer("Package", "*Package : No Template Found");
                }
                if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                {
                    //SaveRejectImage_AddToBuffer("Package", "*Package : No Template Found");
                    m_smVisionInfo.g_intNoTemplateFailureTotal++;
                    m_blnFailCounterAdded = true;
                    m_blnTotalCounterAdded = false;

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 1a PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                }
                if (blnAuto)
                {
                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        if (m_intTCPIPResultID == -1)
                            SetPackageResultID(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailResultMask);
                }
                return false;
            }

            m_strTracking_StartPackageSizeTest += "3,";

            // Make sure template unit size not set to zero
            if ((m_smVisionInfo.g_arrPackage[intUnitNo].ref_fUnitWidthMin == 0 || m_smVisionInfo.g_arrPackage[intUnitNo].ref_fUnitHeightMin == 0) ||
                (m_smVisionInfo.g_arrPackage[intUnitNo].ref_fUnitWidthMax == 0 || m_smVisionInfo.g_arrPackage[intUnitNo].ref_fUnitHeightMax == 0))
            {
                if (intUnitNo == 0)
                {
                    m_bPackageSizePreTestResult1 = false;
                    m_bPackageSizePreTestDone1 = true;

                    WaitEventDone(ref m_bMarkTestDone1, true, 10000, "StartPackageSizeTest > m_bMarkTestDone1 4466");    //m_bSubTh_MarkTest,false// need to wait for mark inspection done. Because package size fail should not display error msg if mark fail.
                    if (!m_bSubTh_MarkTest_Result)
                    {
                        return false;   // Skip package counter if mark fail because counter will add to mark
                    }

                }
                else
                {
                    m_bPackageSizePreTestResult2 = false;
                    m_bPackageSizePreTestDone2 = true;

                    WaitEventDone(ref m_bMarkTestDone2, true, 10000, "StartPackageSizeTest > m_bMarkTestDone2 4478");    //m_bSubTh_MarkTest,false// need to wait for mark inspection done. Because package size fail should not display error msg if mark fail.
                    if (!m_bSubTh_MarkTest_Result2)
                    {
                        return false;   // Skip package counter if mark fail because counter will add to mark
                    }

                }

                if (intUnitNo == 1)
                {
                    m_smVisionInfo.g_strErrorMessageForSecondUnit += GetUnitName(intUnitNo) + "*Package : Template Unit Size cannot be zero.";
                }
                else
                {
                    m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + "*Package : Template Unit Size cannot be zero.";
                }

                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 2 PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                if (blnAuto)
                {
                    SaveRejectImage_AddToBuffer("Package", "*Package : Template Unit Size cannot be zero.");
                }
                if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded) //2020-11-11 ZJYEOH : Removed && !m_blnPassCounterAdded
                {
                    //SaveRejectImage_AddToBuffer("Package", "*Package : Template Unit Size cannot be zero.");
                    m_smVisionInfo.g_intPackageFailureTotal++;
                    m_blnFailCounterAdded = true;
                    m_blnTotalCounterAdded = false;

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 2a PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                }
                if (blnAuto)
                {
                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        if (m_intTCPIPResultID == -1)
                            m_intTCPIPResultID = (int)TCPIPResulID.Fail;// FailPackageDimension;
                }
                return false;
            }

            m_strTracking_StartPackageSizeTest += "4,";

            // --------- Get image index for : unit edge / Mark / package / crack -----------------
            int intUnitEdgeImageIndex = GetLargestGaugeImageNo(m_smVisionInfo.g_arrPackageGaugeM4L[intUnitNo]); // 2020-09-10 ZJYEOH : Need to wait the lagest image no // m_smVisionInfo.g_arrPackage[intUnitNo].GetGrabImageIndex(0);

            if (intUnitEdgeImageIndex == 0)
                WaitEventDone(ref m_bGrabImage1Done, true, 10000, "StartPackageSizeTest > m_bGrabImage1Done a");
            else if (intUnitEdgeImageIndex == 1)
                WaitEventDone(ref m_bGrabImage2Done, true, 10000, "StartPackageSizeTest > m_bGrabImage2Done a");
            else if (intUnitEdgeImageIndex == 2)
                WaitEventDone(ref m_bGrabImage3Done, true, 10000, "StartPackageSizeTest > m_bGrabImage3Done a");
            else if (intUnitEdgeImageIndex == 3)
                WaitEventDone(ref m_bGrabImage4Done, true, 10000, "StartPackageSizeTest > m_bGrabImage4Done a");
            else if (intUnitEdgeImageIndex == 4)
                WaitEventDone(ref m_bGrabImage5Done, true, 10000, "StartPackageSizeTest > m_bGrabImage5Done a");
            else if (intUnitEdgeImageIndex == 5)
                WaitEventDone(ref m_bGrabImage6Done, true, 10000, "StartPackageSizeTest > m_bGrabImage6Done a");
            else if (intUnitEdgeImageIndex == 6)
                WaitEventDone(ref m_bGrabImage7Done, true, 10000, "StartPackageSizeTest > m_bGrabImage7Done a");
            else
            {
                if (intUnitNo == 0)
                {
                    m_bPackageSizePreTestResult1 = false;
                    m_bPackageSizePreTestDone1 = true;
                    WaitEventDone(ref m_bMarkTestDone1, true, 10000, "StartPackageSizeTest > m_bMarkTestDone1 4527");    //m_bSubTh_MarkTest,false// need to wait for mark inspection done. Because package size fail should not display error msg if mark fail.
                    if (!m_bSubTh_MarkTest_Result)
                    {
                        return false;   // Skip package counter if mark fail because counter will add to mark
                    }
                }
                else
                {
                    m_bPackageSizePreTestResult2 = false;
                    m_bPackageSizePreTestDone2 = true;
                    WaitEventDone(ref m_bMarkTestDone2, true, 10000, "StartPackageSizeTest > m_bMarkTestDone2 4535");    //m_bSubTh_MarkTest,false// need to wait for mark inspection done. Because package size fail should not display error msg if mark fail.
                    if (!m_bSubTh_MarkTest_Result2)
                    {
                        return false;   // Skip package counter if mark fail because counter will add to mark
                    }
                }

                if (intUnitNo == 1)
                {
                    m_smVisionInfo.g_strErrorMessageForSecondUnit += GetUnitName(intUnitNo) + "*Package : Wrong setting for package size image number. intUnitEdgeImageIndex = " + intUnitEdgeImageIndex.ToString();
                }
                else
                {
                    m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + "*Package : Wrong setting for package size image number. intUnitEdgeImageIndex = " + intUnitEdgeImageIndex.ToString();
                }

                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 3 PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                if (blnAuto)
                {
                    SaveRejectImage_AddToBuffer("Package", "*Package : Wrong setting for package size image number. intUnitEdgeImageIndex = " + intUnitEdgeImageIndex.ToString());
                }
                if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)//2020-11-11 ZJYEOH : Removed && !m_blnPassCounterAdded
                {
                    //SaveRejectImage_AddToBuffer("Package", "*Package : Wrong setting for package size image number. intUnitEdgeImageIndex = " + intUnitEdgeImageIndex.ToString());
                    m_smVisionInfo.g_intPackageFailureTotal++;
                    m_blnFailCounterAdded = true;
                    m_blnTotalCounterAdded = false;

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 3a PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                }
                if (blnAuto)
                {
                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        if (m_intTCPIPResultID == -1)
                            SetPackageResultID(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailResultMask);
                }
                return false;
            }

            m_strTracking_StartPackageSizeTest += "5,";

            if (m_smVisionInfo.g_objGauge_PkgSize == null)
            {
                m_smVisionInfo.g_objGauge_PkgSize = new RectGaugeM4L(m_smVisionInfo.g_WorldShape, 0, m_smVisionInfo.g_intVisionIndex);
            }

            if (intUnitNo == 1)
            {
                if (m_smVisionInfo.g_objGauge_PkgSize2 == null)
                {
                    m_smVisionInfo.g_objGauge_PkgSize2 = new RectGaugeM4L(m_smVisionInfo.g_WorldShape, 0, m_smVisionInfo.g_intVisionIndex);
                }
            }

            m_strTracking_StartPackageSizeTest += "6,";

            string strTrackStep = "0";
            string strTrackData = "";
            // 2019-12-30 JBTAN : do pr before gauge here if g_blnWantUseUnitPRFindGauge is true, and check mark inspection option is false
            if (!m_smVisionInfo.g_blnWantGauge && m_smVisionInfo.g_blnWantUseUnitPRFindGauge || !m_smVisionInfo.g_arrMarks[intUnitNo].ref_blnCheckMark && m_smVisionInfo.g_blnWantUseUnitPRFindGauge)
            {
                m_strTracking_StartPackageSizeTest += "7,";
                // 2020 02 25 - CCENG: Attach Package group Search ROI to main image
                m_smVisionInfo.g_arrPackageROIs[intUnitNo][0].AttachImage(m_smVisionInfo.g_arrImages[0]);

                m_strTracking_StartPackageSizeTest += "8,";

                float fUnitPRResultCenterX = 0;
                float fUnitPRResultCenterY = 0;
                //if (m_smVisionInfo.g_arrPackage[intUnitNo].MatchWithTemplateUnitPR(m_smVisionInfo.g_arrPackageROIs[intUnitNo][0]))
                //{
                //    fUnitPRResultCenterX = m_smVisionInfo.g_arrPackage[intUnitNo].GetUnitPRResultCenterX() + m_smVisionInfo.g_arrPackageROIs[intUnitNo][0].ref_ROIPositionX;
                //    fUnitPRResultCenterY = m_smVisionInfo.g_arrPackage[intUnitNo].GetUnitPRResultCenterY() + m_smVisionInfo.g_arrPackageROIs[intUnitNo][0].ref_ROIPositionY;
                //    int intUnitPRWidth = m_smVisionInfo.g_arrPackage[intUnitNo].GetUnitPRWidth();
                //    int intUnitPRHeight = m_smVisionInfo.g_arrPackage[intUnitNo].GetUnitPRHeight();

                //    if (m_smVisionInfo.g_arrPackageGaugeM4L.Count > intUnitNo)
                //        m_smVisionInfo.g_arrPackageGaugeM4L[intUnitNo].SetEdgeROIPlacementLimit2(m_smVisionInfo.g_arrPackageROIs[intUnitNo][0], (int)fUnitPRResultCenterX, (int)fUnitPRResultCenterY, intUnitPRWidth, intUnitPRHeight);

                //    if (m_smVisionInfo.g_arrPackageGauge2M4L.Count > intUnitNo)
                //        m_smVisionInfo.g_arrPackageGauge2M4L[intUnitNo].SetEdgeROIPlacementLimit2(m_smVisionInfo.g_arrPackageROIs[intUnitNo][0], (int)fUnitPRResultCenterX, (int)fUnitPRResultCenterY, intUnitPRWidth, intUnitPRHeight);
                //}
                //else

                strTrackStep += ",1";
                m_strTracking_StartPackageSizeTest += "[" + intUnitNo.ToString() + "]";
                m_strTracking_StartPackageSizeTest += "[" + m_smVisionInfo.g_arrOrients.Count.ToString() + "]";
                m_strTracking_StartPackageSizeTest += "[" + m_smVisionInfo.g_arrOrients[intUnitNo].Count.ToString() + "]";
                m_strTracking_StartPackageSizeTest += "[" + m_smVisionInfo.g_intSelectedOcv.Length + "]";
                m_strTracking_StartPackageSizeTest += "[" + m_smVisionInfo.g_intSelectedOcv[intUnitNo] + "]";
                m_strTracking_StartPackageSizeTest += "[" + m_smVisionInfo.g_arrPackageROIs.Count + "]";
                m_strTracking_StartPackageSizeTest += "[" + m_smVisionInfo.g_arrPackageROIs[intUnitNo].Count + "]";

                // 2020 05 01 - CCENG: Change from g_intSelectedTemplate to m_smVisionInfo.g_intSelectedOcv[intUnitNo]
                if (m_smVisionInfo.g_arrOrients[intUnitNo][m_smVisionInfo.g_intSelectedOcv[intUnitNo]].MatchWithTemplateUnitPR(m_smVisionInfo.g_arrPackageROIs[intUnitNo][0]))
                {
                    m_strTracking_StartPackageSizeTest += "9,";
                    strTrackStep += ",2";

                    fUnitPRResultCenterX = m_smVisionInfo.g_arrOrients[intUnitNo][m_smVisionInfo.g_intSelectedOcv[intUnitNo]].GetUnitPRResultCenterX() +
                                           m_smVisionInfo.g_arrPackageROIs[intUnitNo][0].ref_ROIPositionX;
                    fUnitPRResultCenterY = m_smVisionInfo.g_arrOrients[intUnitNo][m_smVisionInfo.g_intSelectedOcv[intUnitNo]].GetUnitPRResultCenterY() +
                                           m_smVisionInfo.g_arrPackageROIs[intUnitNo][0].ref_ROIPositionY;
                    int intUnitPRWidth = m_smVisionInfo.g_arrOrients[intUnitNo][m_smVisionInfo.g_intSelectedOcv[intUnitNo]].GetUnitPRWidth();
                    int intUnitPRHeight = m_smVisionInfo.g_arrOrients[intUnitNo][m_smVisionInfo.g_intSelectedOcv[intUnitNo]].GetUnitPRHeight();

                    m_strTracking_StartPackageSizeTest += "9a,";
                    if (m_smVisionInfo.g_arrPackageGaugeM4L.Count > intUnitNo)
                        m_smVisionInfo.g_arrPackageGaugeM4L[intUnitNo].SetEdgeROIPlacementLimit3(m_smVisionInfo.g_arrPackageROIs[intUnitNo][0], (int)fUnitPRResultCenterX, (int)fUnitPRResultCenterY, intUnitPRWidth, intUnitPRHeight);

                    m_strTracking_StartPackageSizeTest += "9b,";
                    if (m_smVisionInfo.g_blnTrackIPMEdgeROI)
                    {
                        strTrackData += ", fUnitPRResultCenterX=" + fUnitPRResultCenterX.ToString() +
                                        ", fUnitPRResultCenterY=" + fUnitPRResultCenterY.ToString() +
                                        ", intUnitPRWidth=" + intUnitPRWidth.ToString() +
                                        ", intUnitPRHeight=" + intUnitPRHeight.ToString();
                    }

                    if (m_smVisionInfo.g_arrPackageGauge2M4L.Count > intUnitNo)
                        m_smVisionInfo.g_arrPackageGauge2M4L[intUnitNo].SetEdgeROIPlacementLimit3(m_smVisionInfo.g_arrPackageROIs[intUnitNo][0], (int)fUnitPRResultCenterX, (int)fUnitPRResultCenterY, intUnitPRWidth, intUnitPRHeight);

                    m_strTracking_StartPackageSizeTest += "9c,";
                }
                else
                {
                    m_strTracking_StartPackageSizeTest += "10,";
                    strTrackStep += ",3";
                    //2019-10-14 ZJYEOH : If matching fail, load gauge using template unit position center
                    if (m_smVisionInfo.g_arrPackageGaugeM4L.Count > intUnitNo)
                        m_smVisionInfo.g_arrPackageGaugeM4L[intUnitNo].SetEdgeROIPlacementLimit2(m_smVisionInfo.g_arrPackageROIs[intUnitNo][0],
                            (int)m_smVisionInfo.g_arrPackageGaugeM4L[intUnitNo].ref_f4LGaugeCenterPointX, (int)m_smVisionInfo.g_arrPackageGaugeM4L[intUnitNo].ref_f4LGaugeCenterPointY,
                            (int)m_smVisionInfo.g_arrPackageGaugeM4L[intUnitNo].ref_f4LGaugeUnitWidth, (int)m_smVisionInfo.g_arrPackageGaugeM4L[intUnitNo].ref_f4LGaugeUnitHeight);

                    m_strTracking_StartPackageSizeTest += "10a,";
                    if (m_smVisionInfo.g_blnTrackIPMEdgeROI)
                    {
                        strTrackData += ", f4LGaugeCenterPointX=" + m_smVisionInfo.g_arrPackageGaugeM4L[intUnitNo].ref_f4LGaugeCenterPointX.ToString() +
                                        ", f4LGaugeCenterPointY=" + m_smVisionInfo.g_arrPackageGaugeM4L[intUnitNo].ref_f4LGaugeCenterPointY.ToString() +
                                        ", f4LGaugeUnitWidth=" + m_smVisionInfo.g_arrPackageGaugeM4L[intUnitNo].ref_f4LGaugeUnitWidth.ToString() +
                                        ", f4LGaugeUnitHeight=" + m_smVisionInfo.g_arrPackageGaugeM4L[intUnitNo].ref_f4LGaugeUnitHeight.ToString();
                    }

                    if (m_smVisionInfo.g_arrPackageGauge2M4L.Count > intUnitNo)
                        m_smVisionInfo.g_arrPackageGauge2M4L[intUnitNo].SetEdgeROIPlacementLimit2(m_smVisionInfo.g_arrPackageROIs[intUnitNo][0],
                            (int)m_smVisionInfo.g_arrPackageGauge2M4L[intUnitNo].ref_f4LGaugeCenterPointX, (int)m_smVisionInfo.g_arrPackageGauge2M4L[intUnitNo].ref_f4LGaugeCenterPointY,
                            (int)m_smVisionInfo.g_arrPackageGauge2M4L[intUnitNo].ref_f4LGaugeUnitWidth, (int)m_smVisionInfo.g_arrPackageGauge2M4L[intUnitNo].ref_f4LGaugeUnitHeight);

                    m_strTracking_StartPackageSizeTest += "10b,";
                }

                m_strTracking_StartPackageSizeTest += "11,";
            }

            m_strTracking_StartPackageSizeTest += "12,";
            m_smVisionInfo.g_arrPackageGaugeM4L[intUnitNo].SetGaugePlace_BasedOnEdgeROI();
            if (intUnitNo == 0)
                m_smVisionInfo.g_arrPackageGaugeM4L[intUnitNo].CopyTo(ref m_smVisionInfo.g_objGauge_PkgSize);
            else
                m_smVisionInfo.g_arrPackageGaugeM4L[intUnitNo].CopyTo(ref m_smVisionInfo.g_objGauge_PkgSize2);

            RectGaugeM4L objGauge;

            if (intUnitNo == 0)
                objGauge = m_smVisionInfo.g_objGauge_PkgSize;
            else
                objGauge = m_smVisionInfo.g_objGauge_PkgSize2;

            m_strTracking_StartPackageSizeTest += "13,";
            if (m_smVisionInfo.g_blnTrackIPMEdgeROI)
            {
                STTrackLog.WriteLine("Step=" + strTrackStep +
                                     ", EdgeROI X=" + m_smVisionInfo.g_arrPackageGaugeM4L[intUnitNo].ref_arrEdgeROI[0].ref_ROIPositionX.ToString() +
                                     ", Y=" + m_smVisionInfo.g_arrPackageGaugeM4L[intUnitNo].ref_arrEdgeROI[0].ref_ROIPositionY.ToString() +
                                     ", W=" + m_smVisionInfo.g_arrPackageGaugeM4L[intUnitNo].ref_arrEdgeROI[0].ref_ROIWidth.ToString() +
                                     ", H=" + m_smVisionInfo.g_arrPackageGaugeM4L[intUnitNo].ref_arrEdgeROI[0].ref_ROIHeight.ToString() +
                                     ", GaugeM4L CenterX=" + m_smVisionInfo.g_arrPackageGaugeM4L[intUnitNo].ref_arrLineGauge[0].ref_GaugeCenterX.ToString() +
                                     ", CenterX=" + m_smVisionInfo.g_arrPackageGaugeM4L[intUnitNo].ref_arrLineGauge[0].ref_GaugeCenterY.ToString() +
                                     ", GaugePkgSize CenterX=" + objGauge.ref_arrLineGauge[0].ref_GaugeCenterX.ToString() +
                                     ", GaugePkgSize=" + objGauge.ref_arrLineGauge[0].ref_GaugeCenterY.ToString() +
                                     strTrackData);
            }


            int[] arrUserSelectImageViewIndex = objGauge.GetGaugeImageNoList();

            if (!WaitEventDone(arrUserSelectImageViewIndex, "StartPackageSizeTest > arrUserSelectImageViewIndex 4707"))
            {
                if (intUnitNo == 0)
                {
                    m_bPackageSizePreTestResult1 = false;
                    m_bPackageSizePreTestDone1 = true;
                }
                else
                {
                    m_bPackageSizePreTestResult2 = false;
                    m_bPackageSizePreTestDone2 = true;
                }

                if (intUnitNo == 1)
                {
                    m_smVisionInfo.g_strErrorMessageForSecondUnit += GetUnitName(intUnitNo) + "*Package : Wrong setting for package size image number.";
                }
                else
                {
                    m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + "*Package : Wrong setting for package size image number.";
                }

                if (blnAuto)
                {
                    m_smVisionInfo.g_intPackageFailureTotal++;

                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        if (m_intTCPIPResultID == -1)
                            SetPackageResultID(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailResultMask);

                }
                return false;
            }

            m_strTracking_StartPackageSizeTest += "14,";
            bool blnGaugeResult = false;
            if (!GaugeMeasureUnit(objGauge, m_smVisionInfo.g_arrImages, intUnitNo))
            {
                m_strTracking_StartPackageSizeTest += "15,";
                if (intUnitNo == 0)
                {
                    m_bPackageSizePreTestResult1 = false;
                    m_bPackageSizePreTestDone1 = true;
                }
                else
                {
                    m_bPackageSizePreTestResult2 = false;
                    m_bPackageSizePreTestDone2 = true;
                }
                m_smVisionInfo.g_arrPackageGaugeM4L[intUnitNo] = objGauge; // 2020-02-06 ZJYEOH : Pass back to g_arrPackageGaugeM4L so that drawing will based on latest measured result
                m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnDrawPkgGaugeResult = true;
                m_smVisionInfo.g_arrPackage[intUnitNo].DoInspection_PackageSizeOnly(objGauge, m_smVisionInfo.g_blnWantCheckPackageAngle);

                if (intUnitNo == 0)
                {
                    WaitEventDone(ref m_bMarkTestDone1, true, 10000, "StartPackageSizeTest > m_bMarkTestDone1 4738");    //m_bSubTh_MarkTest,false// need to wait for mark inspection done. Because package size fail should not display error msg if mark fail.
                    if (!m_bSubTh_MarkTest_Result)
                    {
                        return false;   // Skip package counter if mark fail because counter will add to mark
                    }
                }
                else
                {
                    WaitEventDone(ref m_bMarkTestDone2, true, 10000, "StartPackageSizeTest > m_bMarkTestDone2 4747");    //m_bSubTh_MarkTest,false// need to wait for mark inspection done. Because package size fail should not display error msg if mark fail.
                    if (!m_bSubTh_MarkTest_Result2)
                    {
                        return false;   // Skip package counter if mark fail because counter will add to mark
                    }
                }

                if (intUnitNo == 1)
                {
                    m_smVisionInfo.g_strErrorMessageForSecondUnit += GetUnitName(intUnitNo) + objGauge.ref_strErrorMessage;
                }
                else
                {
                    m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + objGauge.ref_strErrorMessage;
                }

                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 200 PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                //if (blnAuto)
                if (blnAuto)
                {
                    SaveRejectImage_AddToBuffer("Package", objGauge.ref_strErrorMessage);
                }
                if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)//2020-11-11 ZJYEOH : Removed && !m_blnPassCounterAdded
                {
                    //SaveRejectImage_AddToBuffer("Package", m_smVisionInfo.g_objGauge_PkgSize.ref_strErrorMessage);
                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 200a PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                    m_smVisionInfo.g_intPackageFailureTotal++;
                    m_blnFailCounterAdded = true;
                    m_blnTotalCounterAdded = false;

                }
                if (blnAuto)
                {
                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        if (m_intTCPIPResultID == -1)
                            SetPackageResultID(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailResultMask);
                }
                return false;
            }
            else
            {
                m_strTracking_StartPackageSizeTest += "16,";
                if (m_blnWantLeadTest)
                {
                    m_strTracking_StartPackageSizeTest += "17,";
                    for (int j = 0; j < m_smVisionInfo.g_arrLead.Length; j++)
                    {
                        if (m_smVisionInfo.g_arrLead[j].ref_blnSelected)
                        {
                            if (m_smVisionInfo.g_arrLead[0].ref_blnWantUsePkgToBaseTolerance)
                                m_smVisionInfo.g_arrLead[j].AssignLineGaugeDataFromPackageGaugeM4L(objGauge.ref_pRectCenterPoint.X, objGauge.ref_pRectCenterPoint.Y, objGauge.ref_fRectWidth, objGauge.ref_fRectHeight, objGauge.ref_fRectAngle);
                        }
                    }
                }
                if (intUnitNo == 0)
                {
                    m_bPackageSizePreTestResult1 = true;
                    m_bPackageSizePreTestDone1 = true;
                }
                else
                {
                    m_bPackageSizePreTestResult2 = true;
                    m_bPackageSizePreTestDone2 = true;
                }
            }

            m_strTracking_StartPackageSizeTest += "18,";
            ObjectWidth = objGauge.ref_fRectWidth;
            ObjectHeight = objGauge.ref_fRectHeight;
            if (!m_smVisionInfo.g_arrPackage[intUnitNo].DoInspection_PackageSizeOnly(objGauge, m_smVisionInfo.g_blnWantCheckPackageAngle))
            {
                // 2019-10-16 ZJYEOH : change packagesize pretest state above during measure gauge, here is compare package size with tolerance
                //m_bPackageSizePreTestResult = false;
                //m_bPackageSizePreTestDone = true;
                if ((m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailMask & 0x1000) == 0)
                    return true;    // When check Package Size Option is OFF, not need to display fail package size even though package size fail. 

                if (intUnitNo == 0)
                {
                    WaitEventDone(ref m_bMarkTestDone1, true, 10000, "StartPackageSizeTest > m_bMarkTestDone1 4810");    //m_bSubTh_MarkTest,false// need to wait for mark inspection done. Because package size fail should not display error msg if mark fail.
                    if (!m_bSubTh_MarkTest_Result)
                    {
                        return false;   // Skip package counter if mark fail because counter will add to mark
                    }
                }
                else
                {
                    WaitEventDone(ref m_bMarkTestDone2, true, 10000, "StartPackageSizeTest > m_bMarkTestDone2 4818");    //m_bSubTh_MarkTest,false// need to wait for mark inspection done. Because package size fail should not display error msg if mark fail.
                    if (!m_bSubTh_MarkTest_Result2)
                    {
                        return false;   // Skip package counter if mark fail because counter will add to mark
                    }
                }

                if (intUnitNo == 1)
                {
                    m_smVisionInfo.g_strErrorMessageForSecondUnit += GetUnitName(intUnitNo) + m_smVisionInfo.g_arrPackage[intUnitNo].ref_strErrorMessage;
                }
                else
                {
                    m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + m_smVisionInfo.g_arrPackage[intUnitNo].ref_strErrorMessage;
                }

                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 4 PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                if (blnAuto)
                {
                    SaveRejectImage_AddToBuffer("Package", m_smVisionInfo.g_arrPackage[intUnitNo].ref_strErrorMessage);
                }
                if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)//2020-11-11 ZJYEOH : Removed && !m_blnPassCounterAdded
                {
                    m_objVisionIO.PackageFail.SetOn("V4 PackageFail 00");
                    //SaveRejectImage_AddToBuffer("Package", m_smVisionInfo.g_arrPackage[intUnitNo].ref_strErrorMessage);
                    m_smVisionInfo.g_intPackageFailureTotal++;
                    //m_smVisionInfo.g_intTestedTotal++;
                    //m_smVisionInfo.g_intLowYieldUnitCount++;
                    m_blnFailCounterAdded = true;
                    m_blnTotalCounterAdded = false;

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 4a PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                }
                if (blnAuto)
                {
                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        if (m_intTCPIPResultID == -1)
                            m_intTCPIPResultID = (int)TCPIPResulID.Fail;// FailPackageDimension;
                }
                return false;
            }

            m_strTracking_StartPackageSizeTest += "20,";
            //else
            //{
            //    m_bPackageSizePreTestResult = true;
            //    m_bPackageSizePreTestDone = true;
            //}




            return true;
        }

        private bool StartPackageTest_MarkLightView(bool blnAuto, int intUnitNo)
        {
            bool blnResult = true;

            if ((m_smCustomizeInfo.g_intWantPackage & (1 << m_smVisionInfo.g_intVisionPos)) == 0 || !m_smVisionInfo.g_arrPackage[intUnitNo].GetWantInspectPackage())
                return true;

            if (m_smVisionInfo.g_arrPackage[intUnitNo].GetGrabImageIndex(2) == 0 || !m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnUseDetailDefectCriteria)     // Side light View// 13-08-2019 ZJYEOH : No need to test mark light view during simple mode
            {
                // 2019 06 08 - CCENG: Not need to check defect under mark light view because it will test under side light view
                return true;
            }

            // Check is templates learnt
            if (m_smVisionInfo.g_arrPackageROIs[intUnitNo].Count == 0)
            {
                if (intUnitNo == 1)
                {
                    m_smVisionInfo.g_strErrorMessageForSecondUnit += GetUnitName(intUnitNo) + "*Package : No Template Found";
                }
                else
                {
                    m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + "*Package : No Template Found";
                }

                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 5 PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                {
                    m_smVisionInfo.g_intNoTemplateFailureTotal++;
                    //m_smVisionInfo.g_intTestedTotal++;
                    //m_smVisionInfo.g_intLowYieldUnitCount++;
                    m_blnFailCounterAdded = true;
                    m_blnTotalCounterAdded = false;

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 5a PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                }
                if (blnAuto)
                {
                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        if (m_intTCPIPResultID == -1)
                            SetPackageResultID(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailResultMask);
                }
                return false;
            }

            // Make sure template unit size not set to zero
            if ((m_smVisionInfo.g_arrPackage[intUnitNo].ref_fUnitWidthMin == 0 || m_smVisionInfo.g_arrPackage[intUnitNo].ref_fUnitHeightMin == 0) ||
                (m_smVisionInfo.g_arrPackage[intUnitNo].ref_fUnitWidthMax == 0 || m_smVisionInfo.g_arrPackage[intUnitNo].ref_fUnitHeightMax == 0))
            {
                if (intUnitNo == 1)
                {
                    m_smVisionInfo.g_strErrorMessageForSecondUnit += GetUnitName(intUnitNo) + "*Package : Template Unit Size cannot be zero.";
                }
                else
                {
                    m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + "*Package : Template Unit Size cannot be zero.";
                }

                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 6 PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)//2020-11-11 ZJYEOH : Removed && !m_blnPassCounterAdded
                {
                    m_smVisionInfo.g_intPackageFailureTotal++;
                    //m_smVisionInfo.g_intTestedTotal++;
                    //m_smVisionInfo.g_intLowYieldUnitCount++;
                    m_blnFailCounterAdded = true;
                    m_blnTotalCounterAdded = false;

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 6a PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                }
                if (blnAuto)
                {
                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        if (m_intTCPIPResultID == -1)
                            m_intTCPIPResultID = (int)TCPIPResulID.Fail;// FailPackageDimension;
                }
                return false;
            }

            // --------- Get image index for : Mark -----------------
            int intMarkImageIndex = m_smVisionInfo.g_arrPackage[intUnitNo].GetGrabImageIndex(1);

            // 2019 03 07 - ZJYeoh: Wait m_intOrientAngle value from StartOrientTest First
            //if (intSideLightViewImageIndex > 0)   
            if (intUnitNo == 0)
                WaitEventDone(ref m_blnOrientDataUpdated1, true, 10000, "StartPackageTest_MarkLightView > m_blnOrientDataUpdated1 4911");
            else
                WaitEventDone(ref m_blnOrientDataUpdated2, true, 10000, "StartPackageTest_MarkLightView > m_blnOrientDataUpdated2 493");


            // ---------  Rotate image 2 and 3 to oriented 0 deg -------------
            if (m_objGauge_PkgMarkView == null)
            {
                m_objGauge_PkgMarkView = new RectGaugeM4L(m_smVisionInfo.g_WorldShape, 0, m_smVisionInfo.g_intVisionIndex);
            }

            float fGaugeCenterX = 0, fGaugeCenterY = 0, fGaugeWidth = 0, fGaugeHeight = 0, fGaugeAngle = 0;

            if (m_smVisionInfo.g_blnWantGauge)
            {
                // 2019 07 15 - CCENG: if want gauge ON, mean g_arrOrientGauge is used to measure unit edge for image 1. So not need to remeasure again here. Direct get measure result from g_arrOrientGauge.
                m_objGauge_PkgMarkView = m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo];

                fGaugeCenterX = m_objGauge_PkgMarkView.ref_pRectCenterPoint.X;
                fGaugeCenterY = m_objGauge_PkgMarkView.ref_pRectCenterPoint.Y;
                fGaugeWidth = m_objGauge_PkgMarkView.ref_fRectWidth;
                fGaugeHeight = m_objGauge_PkgMarkView.ref_fRectHeight;
                fGaugeAngle = m_objGauge_PkgMarkView.ref_fRectAngle;

                // 2019 07 15 - CCENG: If want gauge ON, mean image 1 has been rotated. So not need to re-rotate image 1 here again.
            }
            else
            {
                if (intUnitNo == 0)
                    WaitEventDone(ref m_bPackageSizeTestDone1, true, 10000, "StartPackageTest_MarkLightView > m_bPackageSizeTestDone1 4940");
                else
                    WaitEventDone(ref m_bPackageSizeTestDone2, true, 10000, "StartPackageTest_MarkLightView > m_bPackageSizeTestDone2 4942");
                if (intUnitNo == 0)
                {
                    fGaugeCenterX = m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X;
                    fGaugeCenterY = m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y;
                    fGaugeWidth = m_smVisionInfo.g_objGauge_PkgSize.ref_fRectWidth;
                    fGaugeHeight = m_smVisionInfo.g_objGauge_PkgSize.ref_fRectHeight;
                    fGaugeAngle = m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle;
                }
                else
                {
                    fGaugeCenterX = m_smVisionInfo.g_objGauge_PkgSize2.ref_pRectCenterPoint.X;
                    fGaugeCenterY = m_smVisionInfo.g_objGauge_PkgSize2.ref_pRectCenterPoint.Y;
                    fGaugeWidth = m_smVisionInfo.g_objGauge_PkgSize2.ref_fRectWidth;
                    fGaugeHeight = m_smVisionInfo.g_objGauge_PkgSize2.ref_fRectHeight;
                    fGaugeAngle = m_smVisionInfo.g_objGauge_PkgSize2.ref_fRectAngle;
                }
                float fTotalRotateAngle = m_intOrientAngle + fGaugeAngle;

                // Get RotateROI center point where the ROI center point == Unit Center Point
                m_objSubTh1_RotateROI.LoadROISetting(
                            (int)Math.Round(fGaugeCenterX -
                            m_smVisionInfo.g_arrPackageROIs[intUnitNo][0].ref_ROIWidth / 2, 0, MidpointRounding.AwayFromZero),
                            (int)Math.Round(fGaugeCenterY -
                            m_smVisionInfo.g_arrPackageROIs[intUnitNo][0].ref_ROIHeight / 2, 0, MidpointRounding.AwayFromZero),
                            m_smVisionInfo.g_arrPackageROIs[intUnitNo][0].ref_ROIWidth,
                            m_smVisionInfo.g_arrPackageROIs[intUnitNo][0].ref_ROIHeight);

                // 2019 07 15 - Since want gauge is OFF, mean image 1 is not rotated according to unit angle, but accoring to orient again only. So need to re-rotate here again.
                // Rotate imgae 1 
                m_objSubTh1_RotateROI.AttachImage(m_smVisionInfo.g_arrImages[0]);
                ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[0], m_objSubTh1_RotateROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_PkgBright, ref m_smVisionInfo.g_arrRotatedImages, 0);
            }

            m_blnRotateImage1Updated = true;

            // =========================================================================== 

            m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnViewUnitPosition = true;

            m_smVisionInfo.g_arrPackage[intUnitNo].ClearDontCareAreaArray();

            // ------- Copy image to temporary inspection image.
            if (m_smVisionInfo.g_arrImages.Count > 2) // when mark image present
                m_smVisionInfo.g_arrRotatedImages[intMarkImageIndex].CopyTo(ref m_objMarkViewImage);

            bool blnWantMark = false;
            int intCharDilateHalfWidth = 2;
            if (m_smVisionInfo.g_arrMarks != null && m_smVisionInfo.g_arrMarks.Count > 0)
            {
                // 2020 04 15 - JBTAN: will continue to check mark even option uncheck check mark option
                // 2020 07 08 - Roll back to previous method, wont check mark if Mark Checking is not selected.
                blnWantMark = m_smVisionInfo.g_arrMarks[intUnitNo].ref_blnCheckMark;
                //blnWantMark = true;
                intCharDilateHalfWidth = m_smVisionInfo.g_arrMarks[intUnitNo].ref_intCharDilateHalfWidth; // thick iteration
            }

            if (blnWantMark)
            {
                // ---------- Fill Mark Image's mark area with black color -------------------
                int intNumChars = m_smVisionInfo.g_arrMarks[intUnitNo].GetNumChars();
                int intStartX = 0, intStartY = 0, intEndX = 0, intEndY = 0;

                int intOffsetX;
                int intOffsetY;

                if (m_smVisionInfo.g_blnWantGauge)  // Mean during mark inspection, orient gauge is used to measure unit position for m_objMarkTrainROI
                {
                    if (intUnitNo == 0)
                    {
                        intOffsetX = m_objMarkTrainROI.ref_ROITotalX;
                        intOffsetY = m_objMarkTrainROI.ref_ROITotalY;
                    }
                    else
                    {
                        intOffsetX = m_pMarkTrainROIPoint_Unit2.X;
                        intOffsetY = m_pMarkTrainROIPoint_Unit2.Y;
                    }
                }
                else if (m_smVisionInfo.g_arrMarkROIs[intUnitNo].Count > 3)    // Mean during mark inspection, Unit PR is used to find unit surface position for m_objMarkTrainROI
                {
                    if (intUnitNo == 0)
                    {
                        intOffsetX = m_objMarkTrainROI.ref_ROITotalX;
                        intOffsetY = m_objMarkTrainROI.ref_ROITotalY;
                    }
                    else
                    {
                        intOffsetX = m_pMarkTrainROIPoint_Unit2.X;
                        intOffsetY = m_pMarkTrainROIPoint_Unit2.Y;
                    }
                }
                else // Mean during mark inspection, m_objMarkSearchROI is used.
                {
                    if (intUnitNo == 0)
                    {
                        intOffsetX = m_objMarkTrainROI.ref_ROITotalX;
                        intOffsetY = m_objMarkTrainROI.ref_ROITotalY;
                    }
                    else
                    {
                        intOffsetX = m_pMarkTrainROIPoint_Unit2.X;
                        intOffsetY = m_pMarkTrainROIPoint_Unit2.Y;
                    }
                }

                for (int i = 0; i < intNumChars; i++)
                {
                    int intRectStartX, intRectStartY, intRectEndX, intRectEndY;
                    intRectStartX = intRectStartY = intRectEndX = intRectEndY = 0;
                    m_smVisionInfo.g_arrMarks[intUnitNo].GetCharStartXY(i, ref intStartX, ref intStartY);
                    m_smVisionInfo.g_arrMarks[intUnitNo].GetCharEndXY(i, ref intEndX, ref intEndY);

                    if (m_smVisionInfo.g_arrMarks[intUnitNo].ref_blnWantDontCareIgnoredMarkWholeArea && !m_smVisionInfo.g_arrMarks[intUnitNo].GetEnableMarkSetting(i))
                    {
                        //2021-01-18 ZJYEOH : Should use sample position
                        Point pStartTemplate = new Point(intStartX, intStartY);//m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharROIStartPoint(i);
                        Point pEndTemplate = new Point(intEndX, intEndY);//m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharROIEndPoint(i);

                        if ((intOffsetX + pStartTemplate.X - m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftX(i)) >= 0)
                            intRectStartX = intOffsetX + pStartTemplate.X - m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftX(i);
                        else
                            intRectStartX = intOffsetX;

                        if ((intOffsetY + pStartTemplate.Y - m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftY(i)) >= 0)
                            intRectStartY = intOffsetY + pStartTemplate.Y - m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftY(i);
                        else
                            intRectStartY = intOffsetY;

                        if ((intOffsetX + pEndTemplate.X + m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftX(i)) < m_smVisionInfo.g_intCameraResolutionWidth)
                            intRectEndX = intOffsetX + pEndTemplate.X + m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftX(i);
                        else
                            continue;
                        if ((intOffsetY + pEndTemplate.Y + m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftY(i)) < m_smVisionInfo.g_intCameraResolutionHeight)
                            intRectEndY = intOffsetY + pEndTemplate.Y + m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftY(i);
                        else
                            continue;
                    }
                    else
                    {
                        if ((intStartX - intCharDilateHalfWidth) >= 0)
                            intRectStartX = intOffsetX + intStartX - intCharDilateHalfWidth;
                        else
                            intRectStartX = intOffsetX;

                        if ((intStartY - intCharDilateHalfWidth) >= 0)
                            intRectStartY = intOffsetY + intStartY - intCharDilateHalfWidth;
                        else
                            intRectStartY = intOffsetY;

                        if ((intEndX + intCharDilateHalfWidth) < m_smVisionInfo.g_intCameraResolutionWidth)
                            intRectEndX = intOffsetX + intEndX + intCharDilateHalfWidth;
                        else
                            intRectEndX = intOffsetX + intEndX;

                        if ((intEndY + intCharDilateHalfWidth) < m_smVisionInfo.g_intCameraResolutionHeight)
                            intRectEndY = intOffsetY + intEndY + intCharDilateHalfWidth;
                        else
                            intRectEndY = intOffsetY + intEndY;
                    }

                    if (m_smVisionInfo.g_arrImages.Count > 2) // when mark image present
                        Shape.FillRectangle(m_objMarkViewImage, intRectStartX, intRectStartY, intRectEndX, intRectEndY, 0);

                    m_smVisionInfo.g_arrPackage[intUnitNo].SetDontCareArea(intRectStartX, intRectStartY, intRectEndX, intRectEndY);
                }
            }

            // ----------- Define the actual location for unit and place the package roi on that location. ------------------------
            ROI objMarkViewROI = null;
            if (m_smVisionInfo.g_arrImages.Count > 2) // when mark image present
            {
                objMarkViewROI = new ROI();
                objMarkViewROI.LoadROISetting((int)Math.Round((fGaugeCenterX -
                                             fGaugeWidth / 2 +
                                             m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeft), 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round((fGaugeCenterY -
                                             fGaugeHeight / 2 +
                                             m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdge), 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round(fGaugeWidth - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromRight - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeft, 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round(fGaugeHeight - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdge - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromBottom, 0, MidpointRounding.AwayFromZero));
                objMarkViewROI.AttachImage(m_objMarkViewImage);
            }

            if (m_smVisionInfo.g_blnWantDontCareArea_Package)
            {
                if (m_smVisionInfo.g_arrImages.Count > 2)
                {
                    ////Draw don't care ROI edge to make sure Don't Care Area is not inspected
                    //for (int k = 3; k < m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit].Count; k++)
                    //{
                    //    m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][k].AttachImage(objMarkViewROI);
                    //    ROI objROI = new ROI();
                    //    objROI.LoadROISetting((int)Math.Round((fGaugeCenterX - fGaugeWidth / 2 + m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][k].ref_ROIPositionX), 0, MidpointRounding.AwayFromZero),
                    //                          (int)Math.Round((fGaugeCenterY - fGaugeHeight / 2 + m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][k].ref_ROIPositionY), 0, MidpointRounding.AwayFromZero),
                    //                           m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][k].ref_ROIWidth, m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][k].ref_ROIHeight);
                    //    objROI.AttachImage(m_smVisionInfo.g_objWhiteImage);
                    //    ROI.SubtractROI(m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][k], objROI);
                    //    //objPkgViewROI.SaveImage("D:\\aaa.bmp");
                    //    objROI.Dispose();
                    //}

                    ROI objDontCareROI = new ROI();
                    //objDontCareROI.LoadROISetting(0, 0, objMarkViewROI.ref_ROIWidth, objMarkViewROI.ref_ROIHeight);
                    // 2020 06 27 - CCENG: objDontCareROI have to start from Package Tolerance bcos g_objDontCareImage_Package_Bright template is start from Package Size Template.
                    objDontCareROI.LoadROISetting(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeft, 
                              m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdge,
                              objMarkViewROI.ref_ROIWidth, objMarkViewROI.ref_ROIHeight);
                    objDontCareROI.AttachImage(m_smVisionInfo.g_objDontCareImage_Package_Bright);
                    ROI.SubtractROI(objMarkViewROI, objDontCareROI);
                    //objMarkViewROI.SaveImage("D:\\aaa.bmp");
                    objDontCareROI.Dispose();
                }
            }

            if (!m_smVisionInfo.g_arrPackage[intUnitNo].DoInspection_MarkLightView(objMarkViewROI,      // Package Test on first image
                                                                           m_objMarkViewImage)) // First package image

            {
                if (intUnitNo == 1)
                {
                    m_smVisionInfo.g_strErrorMessageForSecondUnit += GetUnitName(intUnitNo) + m_smVisionInfo.g_arrPackage[intUnitNo].ref_strErrorMessage;
                }
                else
                {
                    m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + m_smVisionInfo.g_arrPackage[intUnitNo].ref_strErrorMessage;
                }

                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 7 PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                if (blnAuto)
                {
                    SaveRejectImage_AddToBuffer("PackageDefect", m_smVisionInfo.g_arrPackage[intUnitNo].ref_strErrorMessage);
                }
                if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                {
                    if (!m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    {
                        m_objVisionIO.PackageFail.SetOn("V4 PackageFail 1");
                    }

                    //SaveRejectImage_AddToBuffer("PackageDefect", m_smVisionInfo.g_arrPackage[intUnitNo].ref_strErrorMessage);

                    m_smVisionInfo.g_intPkgDefectFailureTotal++;
                    //m_smVisionInfo.g_intTestedTotal++;
                    //m_smVisionInfo.g_intLowYieldUnitCount++;
                    m_blnFailCounterAdded = true;
                    m_blnTotalCounterAdded = false;
                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 7a PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                }
                if (blnAuto)
                {
                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    {
                        m_blnPackageFail_Out = true;
                        if (m_intTCPIPResultID == -1)
                            SetPackageResultID(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailResultMask);
                    }
                }
                blnResult = false;
            }

            objMarkViewROI.Dispose();

            return blnResult;
        }
        private bool StartPackageTest_MarkLightView_WithoutRotate(bool blnAuto, int intUnitNo)
        {
            bool blnResult = true;
            bool blnWantDebug = false;
            if ((m_smCustomizeInfo.g_intWantPackage & (1 << m_smVisionInfo.g_intVisionPos)) == 0 || !m_smVisionInfo.g_arrPackage[intUnitNo].GetWantInspectPackage())
                return true;

            if (m_smVisionInfo.g_arrPackage[intUnitNo].GetGrabImageIndex(2) == 0 || !m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnUseDetailDefectCriteria)     // Side light View// 13-08-2019 ZJYEOH : No need to test mark light view during simple mode
            {
                // 2019 06 08 - CCENG: Not need to check defect under mark light view because it will test under side light view
                return true;
            }

            // Check is templates learnt
            if (m_smVisionInfo.g_arrPackageROIs[intUnitNo].Count == 0)
            {
                if (intUnitNo == 1)
                {
                    m_smVisionInfo.g_strErrorMessageForSecondUnit += GetUnitName(intUnitNo) + "*Package : No Template Found";
                }
                else
                {
                    m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + "*Package : No Template Found";
                }

                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 5 PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                {
                    m_smVisionInfo.g_intNoTemplateFailureTotal++;
                    //m_smVisionInfo.g_intTestedTotal++;
                    //m_smVisionInfo.g_intLowYieldUnitCount++;
                    m_blnFailCounterAdded = true;
                    m_blnTotalCounterAdded = false;

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 5a PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                }
                if (blnAuto)
                {
                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        if (m_intTCPIPResultID == -1)
                            SetPackageResultID(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailResultMask);
                }
                return false;
            }

            // Make sure template unit size not set to zero
            if ((m_smVisionInfo.g_arrPackage[intUnitNo].ref_fUnitWidthMin == 0 || m_smVisionInfo.g_arrPackage[intUnitNo].ref_fUnitHeightMin == 0) ||
                (m_smVisionInfo.g_arrPackage[intUnitNo].ref_fUnitWidthMax == 0 || m_smVisionInfo.g_arrPackage[intUnitNo].ref_fUnitHeightMax == 0))
            {
                if (intUnitNo == 1)
                {
                    m_smVisionInfo.g_strErrorMessageForSecondUnit += GetUnitName(intUnitNo) + "*Package : Template Unit Size cannot be zero.";
                }
                else
                {
                    m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + "*Package : Template Unit Size cannot be zero.";
                }

                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 6 PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)//2020-11-11 ZJYEOH : Removed && !m_blnPassCounterAdded
                {
                    m_smVisionInfo.g_intPackageFailureTotal++;
                    //m_smVisionInfo.g_intTestedTotal++;
                    //m_smVisionInfo.g_intLowYieldUnitCount++;
                    m_blnFailCounterAdded = true;
                    m_blnTotalCounterAdded = false;

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 6a PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                }
                if (blnAuto)
                {
                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        if (m_intTCPIPResultID == -1)
                            m_intTCPIPResultID = (int)TCPIPResulID.Fail;//FailPackageDimension;
                }
                return false;
            }

            // --------- Get image index for : Mark -----------------
            int intMarkImageIndex = m_smVisionInfo.g_arrPackage[intUnitNo].GetGrabImageIndex(1);

            // 2019 03 07 - ZJYeoh: Wait m_intOrientAngle value from StartOrientTest First
            //if (intSideLightViewImageIndex > 0)   
            if (intUnitNo == 0)
                WaitEventDone(ref m_blnOrientDataUpdated1, true, 10000, "StartPackageTest_MarkLightView_WithoutRotate > m_blnOrientDataUpdated1 5241");
            else
                WaitEventDone(ref m_blnOrientDataUpdated2, true, 10000, "StartPackageTest_MarkLightView_WithoutRotate > m_blnOrientDataUpdated2 5243");


            // ---------  Rotate image 2 and 3 to oriented 0 deg -------------
            if (m_objGauge_PkgMarkView == null)
            {
                m_objGauge_PkgMarkView = new RectGaugeM4L(m_smVisionInfo.g_WorldShape, 0, m_smVisionInfo.g_intVisionIndex);
            }

            float fGaugeCenterX = 0, fGaugeCenterY = 0, fGaugeWidth = 0, fGaugeHeight = 0, fGaugeAngle = 0;

            if (m_smVisionInfo.g_blnWantGauge)
            {
                // 2019 07 15 - CCENG: if want gauge ON, mean g_arrOrientGauge is used to measure unit edge for image 1. So not need to remeasure again here. Direct get measure result from g_arrOrientGauge.
                m_objGauge_PkgMarkView = m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo];

                fGaugeCenterX = m_objGauge_PkgMarkView.ref_pRectCenterPoint.X;
                fGaugeCenterY = m_objGauge_PkgMarkView.ref_pRectCenterPoint.Y;
                fGaugeWidth = m_objGauge_PkgMarkView.ref_fRectWidth;
                fGaugeHeight = m_objGauge_PkgMarkView.ref_fRectHeight;
                fGaugeAngle = m_objGauge_PkgMarkView.ref_fRectAngle;

                // 2019 07 15 - CCENG: If want gauge ON, mean image 1 has been rotated. So not need to re-rotate image 1 here again.
            }
            else
            {
                if (intUnitNo == 0)
                    WaitEventDone(ref m_bPackageSizeTestDone1, true, 10000, "StartPackageTest_MarkLightView_WithoutRotate > m_bPackageSizeTestDone1 5270");
                else
                    WaitEventDone(ref m_bPackageSizeTestDone2, true, 10000, "StartPackageTest_MarkLightView_WithoutRotate > m_bPackageSizeTestDone1 5272");
                if (intUnitNo == 0)
                {
                    fGaugeCenterX = m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X;
                    fGaugeCenterY = m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y;
                    fGaugeWidth = m_smVisionInfo.g_objGauge_PkgSize.ref_fRectWidth;
                    fGaugeHeight = m_smVisionInfo.g_objGauge_PkgSize.ref_fRectHeight;
                    fGaugeAngle = m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle;
                }
                else
                {
                    fGaugeCenterX = m_smVisionInfo.g_objGauge_PkgSize2.ref_pRectCenterPoint.X;
                    fGaugeCenterY = m_smVisionInfo.g_objGauge_PkgSize2.ref_pRectCenterPoint.Y;
                    fGaugeWidth = m_smVisionInfo.g_objGauge_PkgSize2.ref_fRectWidth;
                    fGaugeHeight = m_smVisionInfo.g_objGauge_PkgSize2.ref_fRectHeight;
                    fGaugeAngle = m_smVisionInfo.g_objGauge_PkgSize2.ref_fRectAngle;
                }
                //float fTotalRotateAngle = m_intOrientAngle + fGaugeAngle;

                //// Get RotateROI center point where the ROI center point == Unit Center Point
                //m_objSubTh1_RotateROI.LoadROISetting(
                //            (int)Math.Round(fGaugeCenterX -
                //            m_smVisionInfo.g_arrPackageROIs[intUnitNo][0].ref_ROIWidth / 2, 0, MidpointRounding.AwayFromZero),
                //            (int)Math.Round(fGaugeCenterY -
                //            m_smVisionInfo.g_arrPackageROIs[intUnitNo][0].ref_ROIHeight / 2, 0, MidpointRounding.AwayFromZero),
                //            m_smVisionInfo.g_arrPackageROIs[intUnitNo][0].ref_ROIWidth,
                //            m_smVisionInfo.g_arrPackageROIs[intUnitNo][0].ref_ROIHeight);

                //// 2019 07 15 - Since want gauge is OFF, mean image 1 is not rotated according to unit angle, but accoring to orient again only. So need to re-rotate here again.
                //// Rotate imgae 1 
                //m_objSubTh1_RotateROI.AttachImage(m_smVisionInfo.g_arrImages[0]);
                //ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[0], m_objSubTh1_RotateROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_PkgBright, ref m_smVisionInfo.g_arrRotatedImages, 0);
            }

            m_blnRotateImage1Updated = true;
            float fTotalRotateAngle = m_intOrientAngle + fGaugeAngle;
            // =========================================================================== 

            m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnViewUnitPosition = true;

            m_smVisionInfo.g_arrPackage[intUnitNo].ClearDontCareAreaArray();

            // ------- Copy image to temporary inspection image.
            if (m_smVisionInfo.g_arrImages.Count > 2) // when mark image present
                m_smVisionInfo.g_arrImages[intMarkImageIndex].CopyTo(ref m_objMarkViewImage);

            bool blnWantMark = false;
            int intCharDilateHalfWidth = 2;
            if (m_smVisionInfo.g_arrMarks != null && m_smVisionInfo.g_arrMarks.Count > 0)
            {
                // 2020 04 15 - JBTAN: will continue to check mark even option uncheck check mark option
                // 2020 07 08 - Roll back to previous method, wont check mark if Mark Checking is not selected.
                blnWantMark = m_smVisionInfo.g_arrMarks[intUnitNo].ref_blnCheckMark;
                //blnWantMark = true;
                intCharDilateHalfWidth = m_smVisionInfo.g_arrMarks[intUnitNo].ref_intCharDilateHalfWidth; // thick iteration
            }

            if (blnWantMark)
            {
                // ---------- Fill Mark Image's mark area with black color -------------------
                int intNumChars = m_smVisionInfo.g_arrMarks[intUnitNo].GetNumChars();
                int intStartX = 0, intStartY = 0, intEndX = 0, intEndY = 0;

                int intOffsetX;
                int intOffsetY;

                if (m_smVisionInfo.g_blnWantGauge)  // Mean during mark inspection, orient gauge is used to measure unit position for m_objMarkTrainROI
                {
                    if (intUnitNo == 0)
                    {
                        intOffsetX = m_objMarkTrainROI.ref_ROITotalX;
                        intOffsetY = m_objMarkTrainROI.ref_ROITotalY;
                    }
                    else
                    {
                        intOffsetX = m_pMarkTrainROIPoint_Unit2.X;
                        intOffsetY = m_pMarkTrainROIPoint_Unit2.Y;
                    }
                }
                else if (m_smVisionInfo.g_arrMarkROIs[intUnitNo].Count > 3)    // Mean during mark inspection, Unit PR is used to find unit surface position for m_objMarkTrainROI
                {
                    if (intUnitNo == 0)
                    {
                        intOffsetX = m_objMarkTrainROI.ref_ROITotalX;
                        intOffsetY = m_objMarkTrainROI.ref_ROITotalY;
                    }
                    else
                    {
                        intOffsetX = m_pMarkTrainROIPoint_Unit2.X;
                        intOffsetY = m_pMarkTrainROIPoint_Unit2.Y;
                    }
                }
                else // Mean during mark inspection, m_objMarkSearchROI is used.
                {
                    if (intUnitNo == 0)
                    {
                        intOffsetX = m_objMarkTrainROI.ref_ROITotalX;
                        intOffsetY = m_objMarkTrainROI.ref_ROITotalY;
                    }
                    else
                    {
                        intOffsetX = m_pMarkTrainROIPoint_Unit2.X;
                        intOffsetY = m_pMarkTrainROIPoint_Unit2.Y;
                    }
                }

                float fTotalRotateMarkAngle;
                if (m_smVisionInfo.g_arrMarks[intUnitNo].ref_blnCheckMark)
                {
                    fTotalRotateMarkAngle = m_intOrientAngle + m_smVisionInfo.g_arrOrients[intUnitNo][m_smVisionInfo.g_intSelectedOcv[0]].ref_fDegAngleResult;
                }
                else
                {
                    fTotalRotateMarkAngle = fTotalRotateAngle;
                }

                for (int i = 0; i < intNumChars; i++)
                {
                    int intRectStartX, intRectStartY, intRectEndX, intRectEndY;
                    intRectStartX = intRectStartY = intRectEndX = intRectEndY = 0;
                    m_smVisionInfo.g_arrMarks[intUnitNo].GetCharStartXY(i, ref intStartX, ref intStartY);
                    m_smVisionInfo.g_arrMarks[intUnitNo].GetCharEndXY(i, ref intEndX, ref intEndY);

                    if (m_smVisionInfo.g_arrMarks[intUnitNo].ref_blnWantDontCareIgnoredMarkWholeArea && !m_smVisionInfo.g_arrMarks[intUnitNo].GetEnableMarkSetting(i))
                    {
                        //2021-01-18 ZJYEOH : Should use sample position
                        Point pStartTemplate = new Point(intStartX, intStartY);//m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharROIStartPoint(i);
                        Point pEndTemplate = new Point(intEndX, intEndY);//m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharROIEndPoint(i);

                        if ((intOffsetX + pStartTemplate.X - m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftX(i)) >= 0)
                            intRectStartX = intOffsetX + pStartTemplate.X - m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftX(i);
                        else
                            intRectStartX = intOffsetX;

                        if ((intOffsetY + pStartTemplate.Y - m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftY(i)) >= 0)
                            intRectStartY = intOffsetY + pStartTemplate.Y - m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftY(i);
                        else
                            intRectStartY = intOffsetY;

                        if ((intOffsetX + pEndTemplate.X + m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftX(i)) < m_smVisionInfo.g_intCameraResolutionWidth)
                            intRectEndX = intOffsetX + pEndTemplate.X + m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftX(i);
                        else
                            continue;
                        if ((intOffsetY + pEndTemplate.Y + m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftY(i)) < m_smVisionInfo.g_intCameraResolutionHeight)
                            intRectEndY = intOffsetY + pEndTemplate.Y + m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftY(i);
                        else
                            continue;
                    }
                    else
                    {
                        if ((intStartX - intCharDilateHalfWidth) >= 0)
                            intRectStartX = intOffsetX + intStartX - intCharDilateHalfWidth;
                        else
                            intRectStartX = intOffsetX;

                        if ((intStartY - intCharDilateHalfWidth) >= 0)
                            intRectStartY = intOffsetY + intStartY - intCharDilateHalfWidth;
                        else
                            intRectStartY = intOffsetY;

                        if ((intEndX + intCharDilateHalfWidth) < m_smVisionInfo.g_intCameraResolutionWidth)
                            intRectEndX = intOffsetX + intEndX + intCharDilateHalfWidth;
                        else
                            intRectEndX = intOffsetX + intEndX;

                        if ((intEndY + intCharDilateHalfWidth) < m_smVisionInfo.g_intCameraResolutionHeight)
                            intRectEndY = intOffsetY + intEndY + intCharDilateHalfWidth;
                        else
                            intRectEndY = intOffsetY + intEndY;
                    }

                    if (blnWantDebug)
                    {
                        m_objMarkViewImage.SaveImage("D:\\TS\\1.m_objMarkViewImage" + i.ToString() + ".bmp");
                    }

                    float newSX = 0, newSY = 0, newEX = 0, newEY = 0;
                    Math2.GetNewXYAfterRotate_360deg((intRectEndX + intRectStartX) / 2, (intRectEndY + intRectStartY) / 2, intRectStartX, intRectStartY, -(fTotalRotateMarkAngle), ref newSX, ref newSY);

                    Math2.GetNewXYAfterRotate_360deg((intRectEndX + intRectStartX) / 2, (intRectEndY + intRectStartY) / 2, intRectEndX, intRectEndY, -(fTotalRotateMarkAngle), ref newEX, ref newEY);
                    Point pStart = new Point((int)Math.Round(newSX), (int)Math.Round(newSY));
                    Point pEnd = new Point((int)Math.Round(newEX), (int)Math.Round(newEY));

                    List<Point> arrPoints = new List<Point>();
                    arrPoints.Add(pStart);
                    arrPoints.Add(new Point(pStart.X + (pEnd.X - pStart.X), pStart.Y));
                    arrPoints.Add(pEnd);
                    arrPoints.Add(new Point(pStart.X, pStart.Y + (pEnd.Y - pStart.Y)));

                    PointF pTemp = new PointF();
                    Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
                                                     arrPoints[0],
                                                     (fTotalRotateMarkAngle),
                                                     ref pTemp);
                    arrPoints[0] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));
                    //arrPoints.Add(new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y)));
                    Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
                                                     arrPoints[1],
                                                     (fTotalRotateMarkAngle),
                                                     ref pTemp);
                    arrPoints[1] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

                    Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
                                                     arrPoints[2],
                                                     (fTotalRotateMarkAngle),
                                                     ref pTemp);
                    arrPoints[2] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

                    Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
                                                     arrPoints[3],
                                                     (fTotalRotateMarkAngle),
                                                     ref pTemp);
                    arrPoints[3] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));


                    if (m_smVisionInfo.g_arrImages.Count > 2)
                    {
                        //Shape.FillRectangle(m_objMarkViewImage, intRectStartX, intRectStartY, intRectEndX, intRectEndY, 0);
                        Shape.FillPolygonWithScale(m_objMarkViewImage, arrPoints, 0, 1.0f, 1.0f, 0, 0);
                    }
                    if (blnWantDebug)
                    {
                        m_objMarkViewImage.SaveImage("D:\\TS\\2.m_objMarkViewImage" + i.ToString() + ".bmp");
                    }
                    
                    m_smVisionInfo.g_arrPackage[intUnitNo].SetDontCareArea(intRectStartX, intRectStartY, intRectEndX, intRectEndY);
                }
            }

            if (blnWantDebug)
            {
                m_objMarkViewImage.SaveImage("D:\\TS\\3.m_objMarkViewImage.bmp");
            }

            // ----------- Define the actual location for unit and place the package roi on that location. ------------------------
            ROI objMarkViewROI = null;
            if (m_smVisionInfo.g_arrImages.Count > 2) // when mark image present
            {
                objMarkViewROI = new ROI();
                objMarkViewROI.LoadROISetting((int)Math.Round((fGaugeCenterX -
                                             fGaugeWidth / 2 +
                                             m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeft), 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round((fGaugeCenterY -
                                             fGaugeHeight / 2 +
                                             m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdge), 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round(fGaugeWidth - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromRight - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeft, 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round(fGaugeHeight - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdge - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromBottom, 0, MidpointRounding.AwayFromZero));
                objMarkViewROI.AttachImage(m_objMarkViewImage);
            }

            if (m_smVisionInfo.g_blnWantDontCareArea_Package)
            {
                if (m_smVisionInfo.g_arrImages.Count > 2)
                {
                    ////Draw don't care ROI edge to make sure Don't Care Area is not inspected
                    //for (int k = 3; k < m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit].Count; k++)
                    //{
                    //    m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][k].AttachImage(objMarkViewROI);
                    //    ROI objROI = new ROI();
                    //    objROI.LoadROISetting((int)Math.Round((fGaugeCenterX - fGaugeWidth / 2 + m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][k].ref_ROIPositionX), 0, MidpointRounding.AwayFromZero),
                    //                          (int)Math.Round((fGaugeCenterY - fGaugeHeight / 2 + m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][k].ref_ROIPositionY), 0, MidpointRounding.AwayFromZero),
                    //                           m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][k].ref_ROIWidth, m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][k].ref_ROIHeight);
                    //    objROI.AttachImage(m_smVisionInfo.g_objWhiteImage);
                    //    ROI.SubtractROI(m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][k], objROI);
                    //    //objPkgViewROI.SaveImage("D:\\aaa.bmp");
                    //    objROI.Dispose();
                    //}

                    ROI objDontCareROI = new ROI();
                    //objDontCareROI.LoadROISetting(0, 0, objMarkViewROI.ref_ROIWidth, objMarkViewROI.ref_ROIHeight);
                    // 2020 06 27 - CCENG: objDontCareROI have to start from Package Tolerance bcos g_objDontCareImage_Package_Bright template is start from Package Size Template.
                    objDontCareROI.LoadROISetting(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeft,
                              m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdge,
                              objMarkViewROI.ref_ROIWidth, objMarkViewROI.ref_ROIHeight);
                    objDontCareROI.AttachImage(m_smVisionInfo.g_objDontCareImage_Package_Bright);
                    ImageDrawing objImgDontCare = new ImageDrawing(true, m_smVisionInfo.g_objDontCareImage_Package_Bright.ref_intImageWidth, m_smVisionInfo.g_objDontCareImage_Package_Bright.ref_intImageHeight);
                    ROI.Rotate0Degree_Better(m_smVisionInfo.g_objDontCareImage_Package_Bright, objDontCareROI, -fTotalRotateAngle, 4, ref objImgDontCare);
                    objDontCareROI.AttachImage(objImgDontCare);
                    ROI.SubtractROI(objMarkViewROI, objDontCareROI);
                    //objMarkViewROI.SaveImage("D:\\aaa.bmp");
                    objDontCareROI.Dispose();
                    objImgDontCare.Dispose();
                }
            }

            if (!m_smVisionInfo.g_arrPackage[intUnitNo].DoInspection_MarkLightView(objMarkViewROI,      // Package Test on first image
                                                                           m_objMarkViewImage)) // First package image

            {
                if (intUnitNo == 1)
                {
                    m_smVisionInfo.g_strErrorMessageForSecondUnit += GetUnitName(intUnitNo) + m_smVisionInfo.g_arrPackage[intUnitNo].ref_strErrorMessage;
                }
                else
                {
                    m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + m_smVisionInfo.g_arrPackage[intUnitNo].ref_strErrorMessage;
                }

                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 7 PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                if (blnAuto)
                {
                    SaveRejectImage_AddToBuffer("PackageDefect", m_smVisionInfo.g_arrPackage[intUnitNo].ref_strErrorMessage);
                }
                if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                {
                    if (!m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    {
                        m_objVisionIO.PackageFail.SetOn("V4 PackageFail 1");
                    }
                    //SaveRejectImage_AddToBuffer("PackageDefect", m_smVisionInfo.g_arrPackage[intUnitNo].ref_strErrorMessage);

                    m_smVisionInfo.g_intPkgDefectFailureTotal++;
                    //m_smVisionInfo.g_intTestedTotal++;
                    //m_smVisionInfo.g_intLowYieldUnitCount++;
                    m_blnFailCounterAdded = true;
                    m_blnTotalCounterAdded = false;
                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 7a PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                }
                if (blnAuto)
                {
                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    {
                        m_blnPackageFail_Out = true;
                        if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                            if (m_intTCPIPResultID == -1)
                                SetPackageResultID(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailResultMask);
                    }
                }
                blnResult = false;
            }

            objMarkViewROI.Dispose();

            return blnResult;
        }

        private bool StartPackageTest_SideLightView(bool blnAuto, int intUnitNo)
        {
            bool blnResult = true;
            bool blnWantDebug = false;

            if ((m_smCustomizeInfo.g_intWantPackage & (1 << m_smVisionInfo.g_intVisionPos)) == 0 || !m_smVisionInfo.g_arrPackage[intUnitNo].GetWantInspectPackage())
                return true;

            // Check is templates learnt
            if (m_smVisionInfo.g_arrPackageROIs[intUnitNo].Count == 0)
            {
                if (intUnitNo == 1)
                {
                    m_smVisionInfo.g_strErrorMessageForSecondUnit += GetUnitName(intUnitNo) + "*Package : No Template Found";
                }
                else
                {
                    m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + "*Package : No Template Found";
                }

                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 8 PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                {
                    m_smVisionInfo.g_intNoTemplateFailureTotal++;
                    m_blnFailCounterAdded = true;
                    m_blnTotalCounterAdded = false;

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 8a PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                }
                if (blnAuto)
                {
                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        if (m_intTCPIPResultID == -1)
                            SetPackageResultID(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailResultMask);
                }
                return false;
            }

            // Make sure template unit size not set to zero
            if ((m_smVisionInfo.g_arrPackage[intUnitNo].ref_fUnitWidthMin == 0 || m_smVisionInfo.g_arrPackage[intUnitNo].ref_fUnitHeightMin == 0) ||
                (m_smVisionInfo.g_arrPackage[intUnitNo].ref_fUnitWidthMax == 0 || m_smVisionInfo.g_arrPackage[intUnitNo].ref_fUnitHeightMax == 0))
            {
                if (intUnitNo == 1)
                {
                    m_smVisionInfo.g_strErrorMessageForSecondUnit += GetUnitName(intUnitNo) + "*Package : Template Unit Size cannot be zero.";
                }
                else
                {
                    m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + "*Package : Template Unit Size cannot be zero.";
                }

                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 9 PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)//2020-11-11 ZJYEOH : Removed && !m_blnPassCounterAdded
                {
                    m_smVisionInfo.g_intPackageFailureTotal++;
                    m_blnFailCounterAdded = true;
                    m_blnTotalCounterAdded = false;

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 9a PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                }
                if (blnAuto)
                {
                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        if (m_intTCPIPResultID == -1)
                            m_intTCPIPResultID = (int)TCPIPResulID.Fail;//FailPackageDimension;
                }
                return false;
            }

            // ------------- Make sure grab image done ------------------------
            int intSideLightViewImageIndex = m_smVisionInfo.g_arrPackage[intUnitNo].GetGrabImageIndex(2);     // Side light View
            if (intSideLightViewImageIndex == 0)
                WaitEventDone(ref m_bGrabImage1Done, true, 10000, "StartPackageTest_SideLightView> m_bGrabImage1Done c");
            else if (intSideLightViewImageIndex == 1)
                WaitEventDone(ref m_bGrabImage2Done, true, 10000, "StartPackageTest_SideLightView> m_bGrabImage2Done c");
            else if (intSideLightViewImageIndex == 2)
                WaitEventDone(ref m_bGrabImage3Done, true, 10000, "StartPackageTest_SideLightView> m_bGrabImage3Done c");
            else if (intSideLightViewImageIndex == 3)
                WaitEventDone(ref m_bGrabImage4Done, true, 10000, "StartPackageTest_SideLightView> m_bGrabImage4Done c");
            else if (intSideLightViewImageIndex == 4)
                WaitEventDone(ref m_bGrabImage5Done, true, 10000, "StartPackageTest_SideLightView> m_bGrabImage5Done c");
            else if (intSideLightViewImageIndex == 5)
                WaitEventDone(ref m_bGrabImage6Done, true, 10000, "StartPackageTest_SideLightView> m_bGrabImage6Done c");
            else if (intSideLightViewImageIndex == 6)
                WaitEventDone(ref m_bGrabImage7Done, true, 10000, "StartPackageTest_SideLightView> m_bGrabImage7Done c");
            else
            {
                if (intUnitNo == 1)
                {
                    m_smVisionInfo.g_strErrorMessageForSecondUnit += GetUnitName(intUnitNo) + "*Package : Wrong setting for package (Side Light View) image number. intSideLightViewImageIndex = " + intSideLightViewImageIndex.ToString();
                }
                else
                {
                    m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + "*Package : Wrong setting for package (Side Light View) image number. intSideLightViewImageIndex = " + intSideLightViewImageIndex.ToString();
                }

                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 10 PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)//2020-11-11 ZJYEOH : Removed && !m_blnPassCounterAdded
                {
                    m_smVisionInfo.g_intPackageFailureTotal++;
                    m_blnFailCounterAdded = true;
                    m_blnTotalCounterAdded = false;

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 10a PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                }
                if (blnAuto)
                {
                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        if (m_intTCPIPResultID == -1)
                            SetPackageResultID(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailResultMask);
                }
                return false;
            }

            //2020-06-18 ZJYEOH : wait image used for dark field 2 grab done
            int intSideLightViewImageIndex_DarkField2 = m_smVisionInfo.g_arrPackage[intUnitNo].GetGrabImageIndex(4);     // Side light View
            int intSideLightViewImageIndex_DarkField3 = m_smVisionInfo.g_arrPackage[intUnitNo].GetGrabImageIndex(6);     // Side light View
            int intSideLightViewImageIndex_DarkField4 = m_smVisionInfo.g_arrPackage[intUnitNo].GetGrabImageIndex(7);     // Side light View

            if (intSideLightViewImageIndex_DarkField2 == 0)
                WaitEventDone(ref m_bGrabImage1Done, true, 10000, "StartPackageTest_SideLightView> m_bGrabImage1Done d");
            else if (intSideLightViewImageIndex_DarkField2 == 1)
                WaitEventDone(ref m_bGrabImage2Done, true, 10000, "StartPackageTest_SideLightView> m_bGrabImage2Done d");
            else if (intSideLightViewImageIndex_DarkField2 == 2)
                WaitEventDone(ref m_bGrabImage3Done, true, 10000, "StartPackageTest_SideLightView> m_bGrabImage3Done d");
            else if (intSideLightViewImageIndex_DarkField2 == 3)
                WaitEventDone(ref m_bGrabImage4Done, true, 10000, "StartPackageTest_SideLightView> m_bGrabImage4Done d");
            else if (intSideLightViewImageIndex_DarkField2 == 4)
                WaitEventDone(ref m_bGrabImage5Done, true, 10000, "StartPackageTest_SideLightView> m_bGrabImage5Done d");
            else if (intSideLightViewImageIndex_DarkField2 == 5)
                WaitEventDone(ref m_bGrabImage6Done, true, 10000, "StartPackageTest_SideLightView> m_bGrabImage6Done d");
            else if (intSideLightViewImageIndex_DarkField2 == 6)
                WaitEventDone(ref m_bGrabImage7Done, true, 10000, "StartPackageTest_SideLightView> m_bGrabImage7Done d");
            else
            {
                if (intUnitNo == 1)
                {
                    m_smVisionInfo.g_strErrorMessageForSecondUnit += GetUnitName(intUnitNo) + "*Package : Wrong setting for package (Side Light View - Dark Field 2) image number. intSideLightViewImageIndex_DarkField2 = " + intSideLightViewImageIndex_DarkField2.ToString();
                }
                else
                {
                    m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + "*Package : Wrong setting for package (Side Light View - Dark Field 2) image number. intSideLightViewImageIndex_DarkField2 = " + intSideLightViewImageIndex_DarkField2.ToString();
                }

                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 10 PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)//2020-11-11 ZJYEOH : Removed && !m_blnPassCounterAdded
                {
                    m_smVisionInfo.g_intPackageFailureTotal++;
                    m_blnFailCounterAdded = true;
                    m_blnTotalCounterAdded = false;

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 10a PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                }
                if (blnAuto)
                {
                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        if (m_intTCPIPResultID == -1)
                            SetPackageResultID(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailResultMask);
                }
                return false;
            }

            if (intSideLightViewImageIndex_DarkField3 == 0)
                WaitEventDone(ref m_bGrabImage1Done, true, 10000, "StartPackageTest_SideLightView> m_bGrabImage1Done d");
            else if (intSideLightViewImageIndex_DarkField3 == 1)
                WaitEventDone(ref m_bGrabImage2Done, true, 10000, "StartPackageTest_SideLightView> m_bGrabImage2Done d");
            else if (intSideLightViewImageIndex_DarkField3 == 2)
                WaitEventDone(ref m_bGrabImage3Done, true, 10000, "StartPackageTest_SideLightView> m_bGrabImage3Done d");
            else if (intSideLightViewImageIndex_DarkField3 == 3)
                WaitEventDone(ref m_bGrabImage4Done, true, 10000, "StartPackageTest_SideLightView> m_bGrabImage4Done d");
            else if (intSideLightViewImageIndex_DarkField3 == 4)
                WaitEventDone(ref m_bGrabImage5Done, true, 10000, "StartPackageTest_SideLightView> m_bGrabImage5Done d");
            else if (intSideLightViewImageIndex_DarkField3 == 5)
                WaitEventDone(ref m_bGrabImage6Done, true, 10000, "StartPackageTest_SideLightView> m_bGrabImage6Done d");
            else if (intSideLightViewImageIndex_DarkField3 == 6)
                WaitEventDone(ref m_bGrabImage7Done, true, 10000, "StartPackageTest_SideLightView> m_bGrabImage7Done d");
            else
            {
                if (intUnitNo == 1)
                {
                    m_smVisionInfo.g_strErrorMessageForSecondUnit += GetUnitName(intUnitNo) + "*Package : Wrong setting for package (Side Light View - Dark Field 3) image number. intSideLightViewImageIndex_DarkField3 = " + intSideLightViewImageIndex_DarkField3.ToString();
                }
                else
                {
                    m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + "*Package : Wrong setting for package (Side Light View - Dark Field 2) image number. intSideLightViewImageIndex_DarkField3 = " + intSideLightViewImageIndex_DarkField3.ToString();
                }

                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 10 PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)//2020-11-11 ZJYEOH : Removed && !m_blnPassCounterAdded
                {
                    m_smVisionInfo.g_intPackageFailureTotal++;
                    m_blnFailCounterAdded = true;
                    m_blnTotalCounterAdded = false;

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 10a PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                }
                if (blnAuto)
                {
                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        if (m_intTCPIPResultID == -1)
                            SetPackageResultID(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailResultMask);
                }
                return false;
            }

            if (intSideLightViewImageIndex_DarkField4 == 0)
                WaitEventDone(ref m_bGrabImage1Done, true, 10000, "StartPackageTest_SideLightView> m_bGrabImage1Done d");
            else if (intSideLightViewImageIndex_DarkField4 == 1)
                WaitEventDone(ref m_bGrabImage2Done, true, 10000, "StartPackageTest_SideLightView> m_bGrabImage2Done d");
            else if (intSideLightViewImageIndex_DarkField4 == 2)
                WaitEventDone(ref m_bGrabImage3Done, true, 10000, "StartPackageTest_SideLightView> m_bGrabImage3Done d");
            else if (intSideLightViewImageIndex_DarkField4 == 3)
                WaitEventDone(ref m_bGrabImage4Done, true, 10000, "StartPackageTest_SideLightView> m_bGrabImage4Done d");
            else if (intSideLightViewImageIndex_DarkField4 == 4)
                WaitEventDone(ref m_bGrabImage5Done, true, 10000, "StartPackageTest_SideLightView> m_bGrabImage5Done d");
            else if (intSideLightViewImageIndex_DarkField4 == 5)
                WaitEventDone(ref m_bGrabImage6Done, true, 10000, "StartPackageTest_SideLightView> m_bGrabImage6Done d");
            else if (intSideLightViewImageIndex_DarkField4 == 6)
                WaitEventDone(ref m_bGrabImage7Done, true, 10000, "StartPackageTest_SideLightView> m_bGrabImage7Done d");
            else
            {
                if (intUnitNo == 1)
                {
                    m_smVisionInfo.g_strErrorMessageForSecondUnit += GetUnitName(intUnitNo) + "*Package : Wrong setting for package (Side Light View - Dark Field 4) image number. intSideLightViewImageIndex_DarkField4 = " + intSideLightViewImageIndex_DarkField4.ToString();
                }
                else
                {
                    m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + "*Package : Wrong setting for package (Side Light View - Dark Field 4) image number. intSideLightViewImageIndex_DarkField4 = " + intSideLightViewImageIndex_DarkField4.ToString();
                }

                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 10 PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)//2020-11-11 ZJYEOH : Removed && !m_blnPassCounterAdded
                {
                    m_smVisionInfo.g_intPackageFailureTotal++;
                    m_blnFailCounterAdded = true;
                    m_blnTotalCounterAdded = false;

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 10a PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                }
                if (blnAuto)
                {
                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        if (m_intTCPIPResultID == -1)
                            SetPackageResultID(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailResultMask);
                }
                return false;
            }

            //2020-12-18 ZJYEOH : wait image used for Mold Flash grab done
            int intMoldFlashViewImageIndex = m_smVisionInfo.g_arrPackage[intUnitNo].GetGrabImageIndex(5);     // Mold Flash View
            if (intMoldFlashViewImageIndex == 0)
                WaitEventDone(ref m_bGrabImage1Done, true, 10000, "StartPackageTest_SideLightView> m_bGrabImage1Done e");
            else if (intMoldFlashViewImageIndex == 1)
                WaitEventDone(ref m_bGrabImage2Done, true, 10000, "StartPackageTest_SideLightView> m_bGrabImage2Done e");
            else if (intMoldFlashViewImageIndex == 2)
                WaitEventDone(ref m_bGrabImage3Done, true, 10000, "StartPackageTest_SideLightView> m_bGrabImage3Done e");
            else if (intMoldFlashViewImageIndex == 3)
                WaitEventDone(ref m_bGrabImage4Done, true, 10000, "StartPackageTest_SideLightView> m_bGrabImage4Done e");
            else if (intMoldFlashViewImageIndex == 4)
                WaitEventDone(ref m_bGrabImage5Done, true, 10000, "StartPackageTest_SideLightView> m_bGrabImage5Done e");
            else if (intMoldFlashViewImageIndex == 5)
                WaitEventDone(ref m_bGrabImage6Done, true, 10000, "StartPackageTest_SideLightView> m_bGrabImage6Done e");
            else if (intMoldFlashViewImageIndex == 6)
                WaitEventDone(ref m_bGrabImage7Done, true, 10000, "StartPackageTest_SideLightView> m_bGrabImage7Done e");
            else
            {
                if (intUnitNo == 1)
                {
                    m_smVisionInfo.g_strErrorMessageForSecondUnit += GetUnitName(intUnitNo) + "*Package : Wrong setting for package (Side Light View - Dark Field 2) image number. intMoldFlashViewImageIndex = " + intMoldFlashViewImageIndex.ToString();
                }
                else
                {
                    m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + "*Package : Wrong setting for package (Side Light View - Dark Field 2) image number. intMoldFlashViewImageIndex = " + intMoldFlashViewImageIndex.ToString();
                }

                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 10 PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)//2020-11-11 ZJYEOH : Removed && !m_blnPassCounterAdded
                {
                    m_smVisionInfo.g_intPackageFailureTotal++;
                    m_blnFailCounterAdded = true;
                    m_blnTotalCounterAdded = false;

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 10a PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                }
                if (blnAuto)
                {
                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        if (m_intTCPIPResultID == -1)
                            SetPackageResultID(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailResultMask);
                }
                return false;
            }

            // 08-03-19 ZJYEOH: wait for orient angle update
            //if (intSideLightViewImageIndex > 0)
            if (intUnitNo == 0)
                WaitEventDone(ref m_blnOrientDataUpdated1, true, 10000, "StartPackageTest_SideLightView> m_blnOrientDataUpdated1 5719");
            else
                WaitEventDone(ref m_blnOrientDataUpdated2, true, 10000, "StartPackageTest_SideLightView> m_blnOrientDataUpdated2 5721");


            // ---------  Rotate image 2 and 3 to oriented 0 deg -------------
            if (m_objGauge_PkgSideView == null)
            {
                m_objGauge_PkgSideView = new RectGaugeM4L(m_smVisionInfo.g_WorldShape, 0, m_smVisionInfo.g_intVisionIndex);
            }

            float fGaugeCenterX = 0, fGaugeCenterY = 0, fGaugeWidth = 0, fGaugeHeight = 0, fGaugeAngle = 0;

            if (m_smVisionInfo.g_blnWantGauge &&
                (intSideLightViewImageIndex == 0 ||
                (intSideLightViewImageIndex_DarkField2 == 0 && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateDarkField2DefectSetting)
                || (intSideLightViewImageIndex_DarkField3 == 0 && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateDarkField3DefectSetting)
                || (intSideLightViewImageIndex_DarkField4 == 0 && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateDarkField4DefectSetting) ||
                (intMoldFlashViewImageIndex == 0 && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateMoldFlashDefectSetting)))
            {
                //if (intSideLightViewImageIndex == 0)
                //{
                //    m_smVisionInfo.g_arrOrientGauge[intUnitNo].CopyTo(ref m_objGauge_PkgSideView);
                //    GaugeMeasureUnit(m_objGauge_PkgSideView, m_smVisionInfo.g_arrImages[intSideLightViewImageIndex]);
                //}
                //else if (intSideLightViewImageIndex == 1)
                //{
                //    m_smVisionInfo.g_arrPackageGauge[intUnitNo].CopyTo(ref m_objGauge_PkgSideView);
                //    GaugeMeasureUnit(m_objGauge_PkgSideView, m_smVisionInfo.g_arrImages[intSideLightViewImageIndex]);
                //}
                //else
                //{
                //    if (m_smVisionInfo.g_arrPackageGauge2[0] != null)
                //    {
                //        m_smVisionInfo.g_arrPackageGauge2[intUnitNo].CopyTo(ref m_objGauge_PkgSideView);
                //        GaugeMeasureUnit(m_objGauge_PkgSideView, m_smVisionInfo.g_arrImages[intSideLightViewImageIndex]);
                //    }
                //    else
                //    {
                //        m_smVisionInfo.g_arrPackageGauge[intUnitNo].CopyTo(ref m_objGauge_PkgSideView);
                //        GaugeMeasureUnit(m_objGauge_PkgSideView, m_smVisionInfo.g_arrImages[intSideLightViewImageIndex]);
                //    }
                //}
                if (m_blnWantOrientTest)
                    m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].CopyTo(ref m_objGauge_PkgSideView);
                else
                    m_smVisionInfo.g_arrMarkGaugeM4L[intUnitNo].CopyTo(ref m_objGauge_PkgSideView); // 2019-09-18 ZJYEOH : Changed g_arrPackageGaugeM4L to g_arrMarkGaugeM4L, if got use mark gauge and intSideLightViewImageIndex == 0

                int[] arrUserSelectImageViewIndex = m_objGauge_PkgSideView.GetGaugeImageNoList();

                if (!WaitEventDone(arrUserSelectImageViewIndex, "StartPackageTest_SideLightView > arrUserSelectImageViewIndex 5767"))
                {
                    if (intUnitNo == 1)
                    {
                        m_smVisionInfo.g_strErrorMessageForSecondUnit += GetUnitName(intUnitNo) + "*Package : Wrong setting for package size image number.";
                    }
                    else
                    {
                        m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + "*Package : Wrong setting for package size image number.";
                    }

                    if (blnAuto)
                    {
                        m_smVisionInfo.g_intPackageFailureTotal++;

                        if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                            if (m_intTCPIPResultID == -1)
                                SetPackageResultID(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailResultMask);

                    }
                    return false;
                }

                if (!GaugeMeasureUnit(m_objGauge_PkgSideView, m_smVisionInfo.g_arrImages, intUnitNo))
                {
                    if (intUnitNo == 1)
                    {
                        m_smVisionInfo.g_strErrorMessageForSecondUnit += GetUnitName(intUnitNo) + "*Package : " + m_objGauge_PkgSideView.ref_strErrorMessage;
                    }
                    else
                    {
                        m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + "*Package : " + m_objGauge_PkgSideView.ref_strErrorMessage;
                    }

                    //if (blnAuto)
                    if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)//2020-11-11 ZJYEOH : Removed && !m_blnPassCounterAdded
                    {
                        m_smVisionInfo.g_intPackageFailureTotal++;
                        m_blnFailCounterAdded = true;
                        m_blnTotalCounterAdded = false;

                    }
                    if (blnAuto)
                    {
                        if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                            if (m_intTCPIPResultID == -1)
                                SetPackageResultID(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailResultMask);
                    }
                    return false;
                }
                fGaugeCenterX = m_objGauge_PkgSideView.ref_pRectCenterPoint.X;
                fGaugeCenterY = m_objGauge_PkgSideView.ref_pRectCenterPoint.Y;
                fGaugeWidth = m_objGauge_PkgSideView.ref_fRectWidth;
                fGaugeHeight = m_objGauge_PkgSideView.ref_fRectHeight;
                fGaugeAngle = m_objGauge_PkgSideView.ref_fRectAngle;
            }
            else
            {
                //WaitEventDone(ref m_bPackageSizeTestDone, true);
                //fGaugeCenterX = m_smVisionInfo.g_objGauge_PkgSize.ref_ObjectCenterX;
                //fGaugeCenterY = m_smVisionInfo.g_objGauge_PkgSize.ref_ObjectCenterY;
                //fGaugeWidth = m_smVisionInfo.g_objGauge_PkgSize.ref_ObjectWidth;
                //fGaugeHeight = m_smVisionInfo.g_objGauge_PkgSize.ref_ObjectHeight;
                //fGaugeAngle = m_smVisionInfo.g_objGauge_PkgSize.ref_ObjectAngle;
                if (intUnitNo == 0)
                    WaitEventDone(ref m_bPackageSizeTestDone1, true, 10000, "StartPackageTest_SideLightView> m_bPackageSizeTestDone1 5804");
                else
                    WaitEventDone(ref m_bPackageSizeTestDone2, true, 10000, "StartPackageTest_SideLightView> m_bPackageSizeTestDone2 5806");
                if (intUnitNo == 0)
                {
                    fGaugeCenterX = m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X;
                    fGaugeCenterY = m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y;
                    fGaugeWidth = m_smVisionInfo.g_objGauge_PkgSize.ref_fRectWidth;
                    fGaugeHeight = m_smVisionInfo.g_objGauge_PkgSize.ref_fRectHeight;
                    fGaugeAngle = m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle;
                }
                else
                {
                    fGaugeCenterX = m_smVisionInfo.g_objGauge_PkgSize2.ref_pRectCenterPoint.X;
                    fGaugeCenterY = m_smVisionInfo.g_objGauge_PkgSize2.ref_pRectCenterPoint.Y;
                    fGaugeWidth = m_smVisionInfo.g_objGauge_PkgSize2.ref_fRectWidth;
                    fGaugeHeight = m_smVisionInfo.g_objGauge_PkgSize2.ref_fRectHeight;
                    fGaugeAngle = m_smVisionInfo.g_objGauge_PkgSize2.ref_fRectAngle;
                }
            }

            float fTotalRotateAngle = m_intOrientAngle + fGaugeAngle;
            float fTotalRotateMarkAngle;
            if (m_smVisionInfo.g_arrMarks[intUnitNo].ref_blnCheckMark)
            {
                fTotalRotateMarkAngle = m_intOrientAngle + m_smVisionInfo.g_arrOrients[intUnitNo][m_smVisionInfo.g_intSelectedOcv[0]].ref_fDegAngleResult;
            }
            else
            {
                fTotalRotateMarkAngle = fTotalRotateAngle;
            }

            // 2019 06 08 - CCENG: Add this 0.5 formula to make sure ROI attahced to image in the best way
            float fCenterX, fCenterY;
            if ((m_smVisionInfo.g_arrPackageROIs[intUnitNo][0].ref_ROIWidth % 2) == 0)
                fCenterX = (float)Math.Round(fGaugeCenterX, 0, MidpointRounding.AwayFromZero);
            else
                fCenterX = (float)Math.Floor(fGaugeCenterX) + 0.5f;

            if ((m_smVisionInfo.g_arrPackageROIs[intUnitNo][0].ref_ROIHeight % 2) == 0)
                fCenterY = (float)Math.Round(fGaugeCenterY, 0, MidpointRounding.AwayFromZero);
            else
                fCenterY = (float)Math.Floor(fGaugeCenterY) + 0.5f;

            m_objSubTh2_RotateROI.LoadROISetting(
                        (int)Math.Round(fCenterX -
                        (float)m_smVisionInfo.g_arrPackageROIs[intUnitNo][0].ref_ROIWidth / 2, 0, MidpointRounding.AwayFromZero),
                        (int)Math.Round(fCenterY -
                        (float)m_smVisionInfo.g_arrPackageROIs[intUnitNo][0].ref_ROIHeight / 2, 0, MidpointRounding.AwayFromZero),
                        m_smVisionInfo.g_arrPackageROIs[intUnitNo][0].ref_ROIWidth,
                        m_smVisionInfo.g_arrPackageROIs[intUnitNo][0].ref_ROIHeight);

            // Rotate image
            if (intSideLightViewImageIndex == 0)
            {
                /* 2019 07 14 - CCENG: 
                 * if g_blnWantGauge is false, mean Image 1 is rotated according to Orient Matching Angle, which is not 100% correct,
                 * because the Orient Matching Angle and Unit Angle may be different.
                 * So when come to Image 1 package size test, Image 1 need to be re-rotated  according to Package size result angle.
                 */
                if (m_smVisionInfo.g_blnWantGauge)
                {
                    // Wait StartOrientTest rotate image 1 done or mark test done. (sometime rotate image 1 done will not set to true if Orient fail).
                    if (intUnitNo == 0)
                        WaitEventDone(ref m_blnRotateImage1Updated, ref m_bMarkTestDone1, true, true, "StartPackageTest_SideLightView> m_blnRotateImage1Updated 5868");//m_bSubTh_MarkTest,false
                    else
                        WaitEventDone(ref m_blnRotateImage1Updated, ref m_bMarkTestDone2, true, true, "StartPackageTest_SideLightView> m_blnRotateImage1Updated 5870");//m_bSubTh_MarkTest,false
                }
                else
                {
                    // Since Mark Test Image index and side light package view image index are same, then need to Wait for Marktest done because Rotated image need to be tested by mark inspection function. After mark inspection, then only allow to re-rotate again using packge angle.
                    if (intUnitNo == 0)
                    {
                        WaitEventDone(ref m_bMarkTestDone1, true, 10000, "StartPackageTest_SideLightView> m_bMarkTestDone1 5877");    //m_bSubTh_MarkTest,false// need to wait for mark inspection done. Because package size fail should not display error msg if mark fail.
                        if (!m_bSubTh_MarkTest_Result)
                        {
                            return false;   // Skip package counter if mark fail because counter will add to mark
                        }
                    }
                    else
                    {
                        WaitEventDone(ref m_bMarkTestDone2, true, 10000, "StartPackageTest_SideLightView> m_bMarkTestDone2 5886");    //m_bSubTh_MarkTest,false// need to wait for mark inspection done. Because package size fail should not display error msg if mark fail.
                        if (!m_bSubTh_MarkTest_Result2)
                        {
                            return false;   // Skip package counter if mark fail because counter will add to mark
                        }
                    }

                    m_objSubTh2_RotateROI.AttachImage(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex]);
                    m_smVisionInfo.g_arrRotatedImages[intSideLightViewImageIndex].CopyTo(ref m_objPreviousRotatedImage);//2020-11-11 ZJYEOH : Use rotated image to rotate so that both unit will rotate
                    // use back original image first, because currently we are having dark defect if rotate the rotated image (will study why previously rotate the rotated image)
                    //ROI.Rotate0Degree(m_objPreviousRotatedImage, m_objSubTh2_RotateROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_PkgBright, ref m_smVisionInfo.g_arrRotatedImages, intSideLightViewImageIndex);
                    ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex], m_objSubTh2_RotateROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_PkgBright, ref m_smVisionInfo.g_arrRotatedImages, intSideLightViewImageIndex);                    
                }

            }
            else
            {
                // Rotate imgae 2
                m_objSubTh2_RotateROI.AttachImage(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex]);
                ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex], m_objSubTh2_RotateROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_PkgBright, ref m_smVisionInfo.g_arrRotatedImages, intSideLightViewImageIndex);
            }

            if (intSideLightViewImageIndex == 0)
                m_blnRotateImage1Updated = true;
            else if (intSideLightViewImageIndex == 1)
                m_blnRotateImage2Updated = true;
            else if (intSideLightViewImageIndex == 2)
                m_blnRotateImage3Updated = true;
            else if (intSideLightViewImageIndex == 3)
                m_blnRotateImage4Updated = true;
            else if (intSideLightViewImageIndex == 4)
                m_blnRotateImage5Updated = true;
            else if (intSideLightViewImageIndex == 5)
                m_blnRotateImage6Updated = true;
            else
                m_blnRotateImage7Updated = true;

            // 2020-06-18 ZJYEOH : If not same image selected, need rotate another image
            if (intSideLightViewImageIndex != intSideLightViewImageIndex_DarkField2 && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateDarkField2DefectSetting
                || intSideLightViewImageIndex != intSideLightViewImageIndex_DarkField3 && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateDarkField3DefectSetting
                || intSideLightViewImageIndex != intSideLightViewImageIndex_DarkField4 && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateDarkField4DefectSetting)
            {
                if (intSideLightViewImageIndex_DarkField2 == 0 || intSideLightViewImageIndex_DarkField3 == 0 || intSideLightViewImageIndex_DarkField4 == 0)
                {
                    /* 2019 07 14 - CCENG: 
                     * if g_blnWantGauge is false, mean Image 1 is rotated according to Orient Matching Angle, which is not 100% correct,
                     * because the Orient Matching Angle and Unit Angle may be different.
                     * So when come to Image 1 package size test, Image 1 need to be re-rotated  according to Package size result angle.
                     */
                    if (m_smVisionInfo.g_blnWantGauge)
                    {
                        // Wait StartOrientTest rotate image 1 done or mark test done. (sometime rotate image 1 done will not set to true if Orient fail).
                        if (intUnitNo == 0)
                            WaitEventDone(ref m_blnRotateImage1Updated, ref m_bMarkTestDone1, true, true, "StartPackageTest_SideLightView> m_blnRotateImage1Updated 5934");//m_bSubTh_MarkTest,false
                        else
                            WaitEventDone(ref m_blnRotateImage1Updated, ref m_bMarkTestDone2, true, true, "StartPackageTest_SideLightView> m_blnRotateImage1Updated 5936");//m_bSubTh_MarkTest,false
                    }
                    else
                    {
                        // Since Mark Test Image index and side light package view image index are same, then need to Wait for Marktest done because Rotated image need to be tested by mark inspection function. After mark inspection, then only allow to re-rotate again using packge angle.
                        if (intUnitNo == 0)
                        {
                            WaitEventDone(ref m_bMarkTestDone1, true, 10000, "StartPackageTest_SideLightView> m_bMarkTestDone1 5943");    //m_bSubTh_MarkTest,false// need to wait for mark inspection done. Because package size fail should not display error msg if mark fail.
                            if (!m_bSubTh_MarkTest_Result)
                            {
                                return false;   // Skip package counter if mark fail because counter will add to mark
                            }
                        }
                        else
                        {
                            WaitEventDone(ref m_bMarkTestDone2, true, 10000, "StartPackageTest_SideLightView> m_bMarkTestDone2 5951");    //m_bSubTh_MarkTest,false// need to wait for mark inspection done. Because package size fail should not display error msg if mark fail.
                            if (!m_bSubTh_MarkTest_Result2)
                            {
                                return false;   // Skip package counter if mark fail because counter will add to mark
                            }
                        }

                        if (m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateDarkField2DefectSetting)
                        {
                            m_objSubTh2_RotateROI.AttachImage(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex_DarkField2]);
                            ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex_DarkField2], m_objSubTh2_RotateROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_PkgBright, ref m_smVisionInfo.g_arrRotatedImages, intSideLightViewImageIndex_DarkField2);
                        }

                        if (m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateDarkField3DefectSetting)
                        {
                            m_objSubTh2_RotateROI.AttachImage(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex_DarkField3]);
                            ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex_DarkField3], m_objSubTh2_RotateROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_PkgBright, ref m_smVisionInfo.g_arrRotatedImages, intSideLightViewImageIndex_DarkField3);
                        }


                        if (m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateDarkField4DefectSetting)
                        {
                            m_objSubTh2_RotateROI.AttachImage(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex_DarkField4]);
                            ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex_DarkField4], m_objSubTh2_RotateROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_PkgBright, ref m_smVisionInfo.g_arrRotatedImages, intSideLightViewImageIndex_DarkField4);
                        }
                    }

                }
                else
                {
                    // Rotate imgae 2
                    if (m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateDarkField2DefectSetting)
                    {
                        m_objSubTh2_RotateROI.AttachImage(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex_DarkField2]);
                        ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex_DarkField2], m_objSubTh2_RotateROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_PkgBright, ref m_smVisionInfo.g_arrRotatedImages, intSideLightViewImageIndex_DarkField2);
                    }

                    if (m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateDarkField3DefectSetting)
                    {
                        m_objSubTh2_RotateROI.AttachImage(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex_DarkField3]);
                        ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex_DarkField3], m_objSubTh2_RotateROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_PkgBright, ref m_smVisionInfo.g_arrRotatedImages, intSideLightViewImageIndex_DarkField3);
                    }

                    if (m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateDarkField4DefectSetting)
                    {
                        m_objSubTh2_RotateROI.AttachImage(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex_DarkField4]);
                        ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex_DarkField4], m_objSubTh2_RotateROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_PkgBright, ref m_smVisionInfo.g_arrRotatedImages, intSideLightViewImageIndex_DarkField4);
                    }

                }

                if (m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateDarkField2DefectSetting)
                {
                    if (intSideLightViewImageIndex_DarkField2 == 0)
                        m_blnRotateImage1Updated = true;
                    else if (intSideLightViewImageIndex_DarkField2 == 1)
                        m_blnRotateImage2Updated = true;
                    else if (intSideLightViewImageIndex_DarkField2 == 2)
                        m_blnRotateImage3Updated = true;
                    else if (intSideLightViewImageIndex_DarkField2 == 3)
                        m_blnRotateImage4Updated = true;
                    else if (intSideLightViewImageIndex_DarkField2 == 4)
                        m_blnRotateImage5Updated = true;
                    else if (intSideLightViewImageIndex_DarkField2 == 5)
                        m_blnRotateImage6Updated = true;
                    else
                        m_blnRotateImage7Updated = true;
                }

                if (m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateDarkField3DefectSetting)
                {
                    if (intSideLightViewImageIndex_DarkField3 == 0)
                        m_blnRotateImage1Updated = true;
                    else if (intSideLightViewImageIndex_DarkField3 == 1)
                        m_blnRotateImage2Updated = true;
                    else if (intSideLightViewImageIndex_DarkField3 == 2)
                        m_blnRotateImage3Updated = true;
                    else if (intSideLightViewImageIndex_DarkField3 == 3)
                        m_blnRotateImage4Updated = true;
                    else if (intSideLightViewImageIndex_DarkField3 == 4)
                        m_blnRotateImage5Updated = true;
                    else if (intSideLightViewImageIndex_DarkField3 == 5)
                        m_blnRotateImage6Updated = true;
                    else
                        m_blnRotateImage7Updated = true;
                }

                if (m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateDarkField4DefectSetting)
                {
                    if (intSideLightViewImageIndex_DarkField4 == 0)
                        m_blnRotateImage1Updated = true;
                    else if (intSideLightViewImageIndex_DarkField4 == 1)
                        m_blnRotateImage2Updated = true;
                    else if (intSideLightViewImageIndex_DarkField4 == 2)
                        m_blnRotateImage3Updated = true;
                    else if (intSideLightViewImageIndex_DarkField4 == 3)
                        m_blnRotateImage4Updated = true;
                    else if (intSideLightViewImageIndex_DarkField4 == 4)
                        m_blnRotateImage5Updated = true;
                    else if (intSideLightViewImageIndex_DarkField4 == 5)
                        m_blnRotateImage6Updated = true;
                    else
                        m_blnRotateImage7Updated = true;
                }

            }

            // 2020-06-18 ZJYEOH : If not same image selected, need rotate another image
            if ((intSideLightViewImageIndex != intMoldFlashViewImageIndex && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateMoldFlashDefectSetting) &&
                (intSideLightViewImageIndex_DarkField2 != intMoldFlashViewImageIndex && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateMoldFlashDefectSetting)
                && (intSideLightViewImageIndex_DarkField3 != intMoldFlashViewImageIndex && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateMoldFlashDefectSetting)
                && (intSideLightViewImageIndex_DarkField4 != intMoldFlashViewImageIndex && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateMoldFlashDefectSetting))
            {
                if (intMoldFlashViewImageIndex == 0)
                {
                    /* 2019 07 14 - CCENG: 
                     * if g_blnWantGauge is false, mean Image 1 is rotated according to Orient Matching Angle, which is not 100% correct,
                     * because the Orient Matching Angle and Unit Angle may be different.
                     * So when come to Image 1 package size test, Image 1 need to be re-rotated  according to Package size result angle.
                     */
                    if (m_smVisionInfo.g_blnWantGauge)
                    {
                        // Wait StartOrientTest rotate image 1 done or mark test done. (sometime rotate image 1 done will not set to true if Orient fail).
                        if (intUnitNo == 0)
                            WaitEventDone(ref m_blnRotateImage1Updated, ref m_bMarkTestDone1, true, true, "StartPackageTest_SideLightView> m_bMarkTestDone1 6002");//m_bSubTh_MarkTest,false
                        else
                            WaitEventDone(ref m_blnRotateImage1Updated, ref m_bMarkTestDone2, true, true, "StartPackageTest_SideLightView> m_bMarkTestDone2 6004");//m_bSubTh_MarkTest,false
                    }
                    else
                    {
                        // Since Mark Test Image index and side light package view image index are same, then need to Wait for Marktest done because Rotated image need to be tested by mark inspection function. After mark inspection, then only allow to re-rotate again using packge angle.
                        if (intUnitNo == 0)
                        {
                            WaitEventDone(ref m_bMarkTestDone1, true, 10000, "StartPackageTest_SideLightView> m_bMarkTestDone1 6011");    //m_bSubTh_MarkTest,false// need to wait for mark inspection done. Because package size fail should not display error msg if mark fail.
                            if (!m_bSubTh_MarkTest_Result)
                            {
                                return false;   // Skip package counter if mark fail because counter will add to mark
                            }
                        }
                        else
                        {
                            WaitEventDone(ref m_bMarkTestDone2, true, 10000, "StartPackageTest_SideLightView> m_bMarkTestDone2 6019");    //m_bSubTh_MarkTest,false// need to wait for mark inspection done. Because package size fail should not display error msg if mark fail.
                            if (!m_bSubTh_MarkTest_Result2)
                            {
                                return false;   // Skip package counter if mark fail because counter will add to mark
                            }
                        }

                        m_objSubTh2_RotateROI.AttachImage(m_smVisionInfo.g_arrImages[intMoldFlashViewImageIndex]);
                        ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[intMoldFlashViewImageIndex], m_objSubTh2_RotateROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_PkgBright, ref m_smVisionInfo.g_arrRotatedImages, intMoldFlashViewImageIndex);
                    }

                }
                else
                {
                    // Rotate imgae 2
                    m_objSubTh2_RotateROI.AttachImage(m_smVisionInfo.g_arrImages[intMoldFlashViewImageIndex]);
                    ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[intMoldFlashViewImageIndex], m_objSubTh2_RotateROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_PkgBright, ref m_smVisionInfo.g_arrRotatedImages, intMoldFlashViewImageIndex);
                }

                if (intMoldFlashViewImageIndex == 0)
                    m_blnRotateImage1Updated = true;
                else if (intMoldFlashViewImageIndex == 1)
                    m_blnRotateImage2Updated = true;
                else if (intMoldFlashViewImageIndex == 2)
                    m_blnRotateImage3Updated = true;
                else if (intMoldFlashViewImageIndex == 3)
                    m_blnRotateImage4Updated = true;
                else if (intMoldFlashViewImageIndex == 4)
                    m_blnRotateImage5Updated = true;
                else if (intMoldFlashViewImageIndex == 5)
                    m_blnRotateImage6Updated = true;
                else
                    m_blnRotateImage7Updated = true;

            }
            // Wait mark inspection done.
            if (intUnitNo == 0)
            {
                WaitEventDone(ref m_bMarkTestDone1, true, 10000, "StartPackageTest_SideLightView> m_bMarkTestDone1 6057");    //m_bSubTh_MarkTest,false// need to wait for mark inspection done. Because package size fail should not display error msg if mark fail.
                if (!m_bSubTh_MarkTest_Result)
                {
                    return false;   // Skip package counter if mark fail because counter will add to mark
                }
            }
            else
            {
                WaitEventDone(ref m_bMarkTestDone2, true, 10000, "StartPackageTest_SideLightView> m_bMarkTestDone2 6065");    //m_bSubTh_MarkTest,false// need to wait for mark inspection done. Because package size fail should not display error msg if mark fail.
                if (!m_bSubTh_MarkTest_Result2)
                {
                    return false;   // Skip package counter if mark fail because counter will add to mark
                }
            }

            // Wait package test done under mark light view 
            WaitEventDone(ref m_bSubTh_PackageTest_MarkLightView, false, 10000, "StartPackageTest_SideLightView> m_bSubTh_PackageTest_MarkLightView 6073");
            if (intUnitNo == 0)
            {
                if (!m_bSubTh_PackageTest_MarkLightView_Result)
                {
                    return false;
                }
            }
            else
            {
                if (!m_bSubTh_PackageTest_MarkLightView_Result2)
                {
                    return false;
                }
            }
            // --------- Get image index for : package -----------------
            m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnViewUnitPosition = true;

            //m_smVisionInfo.g_arrPackage[intUnitNo].ClearDontCareAreaArray();//2020-12-28 ZJYEOH : Only StartPackageTest_MarkLightView will use this dont care

            // ------- Copy image to temporary inspection image
            if (intSideLightViewImageIndex >= 0)
            {
                if (m_objPkgViewImage == null)
                    m_objPkgViewImage = new ImageDrawing(true);

                if (blnWantDebug)
                {
                    m_smVisionInfo.g_arrRotatedImages[intSideLightViewImageIndex].SaveImage("D:\\TS\\3.RotateImage.bmp");
                }

                //m_smVisionInfo.g_arrRotatedImages[intSideLightViewImageIndex].CopyTo(ref m_objPkgViewImage);
                // 2020 07 11 - CCENG: need to rotate to mark 0 deg first in order to mask dont care the marking area before proceed for package inspection.
                //            - Why cannot mask dont care mark without mark 0 deg. 
                //              > because currently ocv do inspection when mark is in 0 deg.
                //              > also our mark template is in 0 deg also. If want to mask dont care without mark 0 deg, 
                //                then dont mark template need to rotate to sample mark angle before masking dont care. 
                ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex], m_objSubTh2_RotateROI, fTotalRotateMarkAngle, m_smVisionInfo.g_intRotationInterpolation_PkgBright, ref m_objPkgViewImage);

                if (blnWantDebug)
                {
                    m_objPkgViewImage.SaveImage("D:\\TS\\0.m_objPkgViewImage.bmp");
                }

            }
            else if (m_objPkgViewImage != null)
                m_objPkgViewImage = null;


            if (intSideLightViewImageIndex_DarkField2 >= 0)
            {
                if (m_objPkgViewImage_DarkField2 == null)
                    m_objPkgViewImage_DarkField2 = new ImageDrawing(true);

                if (intSideLightViewImageIndex != intSideLightViewImageIndex_DarkField2 && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateDarkField2DefectSetting)
                {
                    // 2020-11-07 ZJYEOH : Need to rotate using mark angle because later will subtract mark char area
                    m_objSubTh2_RotateROI.AttachImage(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex_DarkField2]);
                    ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex_DarkField2], m_objSubTh2_RotateROI, fTotalRotateMarkAngle, m_smVisionInfo.g_intRotationInterpolation_PkgBright, ref m_objPkgViewImage_DarkField2);
                }
                else
                {
                    m_objPkgViewImage.CopyTo(ref m_objPkgViewImage_DarkField2);
                }
            }
            else if (m_objPkgViewImage_DarkField2 != null)
                m_objPkgViewImage_DarkField2 = null;

            if (intSideLightViewImageIndex_DarkField3 >= 0)
            {
                if (m_objPkgViewImage_DarkField3 == null)
                    m_objPkgViewImage_DarkField3 = new ImageDrawing(true);

                if (intSideLightViewImageIndex != intSideLightViewImageIndex_DarkField3 && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateDarkField3DefectSetting)
                {
                    // 2020-11-07 ZJYEOH : Need to rotate using mark angle because later will subtract mark char area
                    m_objSubTh2_RotateROI.AttachImage(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex_DarkField3]);
                    ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex_DarkField3], m_objSubTh2_RotateROI, fTotalRotateMarkAngle, m_smVisionInfo.g_intRotationInterpolation_PkgBright, ref m_objPkgViewImage_DarkField3);
                }
                else
                {
                    m_objPkgViewImage.CopyTo(ref m_objPkgViewImage_DarkField3);
                }
            }
            else if (m_objPkgViewImage_DarkField3 != null)
                m_objPkgViewImage_DarkField3 = null;


            if (intSideLightViewImageIndex_DarkField4 >= 0)
            {
                if (m_objPkgViewImage_DarkField4 == null)
                    m_objPkgViewImage_DarkField4 = new ImageDrawing(true);

                if (intSideLightViewImageIndex != intSideLightViewImageIndex_DarkField4 && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateDarkField4DefectSetting)
                {
                    // 2020-11-07 ZJYEOH : Need to rotate using mark angle because later will subtract mark char area
                    m_objSubTh2_RotateROI.AttachImage(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex_DarkField4]);
                    ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex_DarkField4], m_objSubTh2_RotateROI, fTotalRotateMarkAngle, m_smVisionInfo.g_intRotationInterpolation_PkgBright, ref m_objPkgViewImage_DarkField4);
                }
                else
                {
                    m_objPkgViewImage.CopyTo(ref m_objPkgViewImage_DarkField4);
                }
            }
            else if (m_objPkgViewImage_DarkField4 != null)
                m_objPkgViewImage_DarkField4 = null;

            if (intMoldFlashViewImageIndex >= 0)
            {
                if (m_objMoldViewImage == null)
                    m_objMoldViewImage = new ImageDrawing(true);

                if ((intSideLightViewImageIndex != intMoldFlashViewImageIndex && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateMoldFlashDefectSetting) &&
                    (intSideLightViewImageIndex_DarkField2 != intMoldFlashViewImageIndex && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateMoldFlashDefectSetting)
                    && (intSideLightViewImageIndex_DarkField3 != intMoldFlashViewImageIndex && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateMoldFlashDefectSetting)
                    && (intSideLightViewImageIndex_DarkField4 != intMoldFlashViewImageIndex && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateMoldFlashDefectSetting))
                {
                    // 2020-11-07 ZJYEOH : Need to rotate using mark angle because later will subtract mark char area
                    m_objSubTh2_RotateROI.AttachImage(m_smVisionInfo.g_arrImages[intMoldFlashViewImageIndex]);
                    ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[intMoldFlashViewImageIndex], m_objSubTh2_RotateROI, fTotalRotateMarkAngle, m_smVisionInfo.g_intRotationInterpolation_PkgBright, ref m_objMoldViewImage);
                }
                else
                {
                    if (intSideLightViewImageIndex == intMoldFlashViewImageIndex)
                        m_objPkgViewImage.CopyTo(ref m_objMoldViewImage);
                    else if (intSideLightViewImageIndex_DarkField2 != intMoldFlashViewImageIndex)
                        m_objPkgViewImage_DarkField2.CopyTo(ref m_objMoldViewImage);
                    else if (intSideLightViewImageIndex_DarkField3 != intMoldFlashViewImageIndex)
                        m_objPkgViewImage_DarkField3.CopyTo(ref m_objMoldViewImage);
                    else if (intSideLightViewImageIndex_DarkField4 != intMoldFlashViewImageIndex)
                        m_objPkgViewImage_DarkField4.CopyTo(ref m_objMoldViewImage);
                    else
                        m_objPkgViewImage.CopyTo(ref m_objMoldViewImage);
                }
            }
            else if (m_objMoldViewImage != null)
                m_objMoldViewImage = null;


            bool blnWantMark = false;
            int intCharDilateHalfWidth = 2;
            if (m_smVisionInfo.g_arrMarks != null && m_smVisionInfo.g_arrMarks.Count > 0)
            {
                // 2020 04 15 - JBTAN: will continue to check mark even option uncheck check mark option
                // 2020 07 08 - Roll back to previous method, wont check mark if Mark Checking is not selected.
                blnWantMark = m_smVisionInfo.g_arrMarks[intUnitNo].ref_blnCheckMark;
                //blnWantMark = true;
                intCharDilateHalfWidth = m_smVisionInfo.g_arrMarks[intUnitNo].ref_intCharDilateHalfWidth; // thick iteration
            }

            //2020-05-18 ZJYEOH : Get another Image without subtract mark area
            //2020-05-18 ZJYEOH : Get another Image without subtract mark area
            if (m_smVisionInfo.g_intPackageDefectInspectionMethod != 0)
            {
                m_objPkgViewImage.CopyTo(ref m_objGrayValueImage_SideLight);
            }

            if (blnWantMark)
            {
                // ---------- Fill Mark Image's mark area with black color -------------------
                int intNumChars = m_smVisionInfo.g_arrMarks[intUnitNo].GetNumChars();
                int intStartX = 0, intStartY = 0, intEndX = 0, intEndY = 0;

                int intOffsetX;
                int intOffsetY;

                if (m_smVisionInfo.g_blnWantGauge)  // Mean during mark inspection, orient gauge is used to measure unit position for m_objMarkTrainROI
                {
                    if (intUnitNo == 0)
                    {
                        intOffsetX = m_objMarkTrainROI.ref_ROITotalX;
                        intOffsetY = m_objMarkTrainROI.ref_ROITotalY;
                    }
                    else
                    {
                        intOffsetX = m_pMarkTrainROIPoint_Unit2.X;
                        intOffsetY = m_pMarkTrainROIPoint_Unit2.Y;
                    }
                }
                else if (m_smVisionInfo.g_arrMarkROIs[intUnitNo].Count > 3)    // Mean during mark inspection, Unit PR is used to find unit surface position for m_objMarkTrainROI
                {
                    if (intUnitNo == 0)
                    {
                        intOffsetX = m_objMarkTrainROI.ref_ROITotalX;
                        intOffsetY = m_objMarkTrainROI.ref_ROITotalY;
                    }
                    else
                    {
                        intOffsetX = m_pMarkTrainROIPoint_Unit2.X;
                        intOffsetY = m_pMarkTrainROIPoint_Unit2.Y;
                    }
                }
                else // Mean during mark inspection, m_objMarkSearchROI is used.
                {
                    if (intUnitNo == 0)
                    {
                        intOffsetX = m_objMarkTrainROI.ref_ROITotalX;
                        intOffsetY = m_objMarkTrainROI.ref_ROITotalY;
                    }
                    else
                    {
                        intOffsetX = m_pMarkTrainROIPoint_Unit2.X;
                        intOffsetY = m_pMarkTrainROIPoint_Unit2.Y;
                    }
                }

                for (int i = 0; i < intNumChars; i++)
                {
                    int intRectStartX, intRectStartY, intRectEndX, intRectEndY;
                    intRectStartX = intRectStartY = intRectEndX = intRectEndY = 0;
                    m_smVisionInfo.g_arrMarks[intUnitNo].GetCharStartXY(i, ref intStartX, ref intStartY);
                    m_smVisionInfo.g_arrMarks[intUnitNo].GetCharEndXY(i, ref intEndX, ref intEndY);

                    if (m_smVisionInfo.g_arrMarks[intUnitNo].ref_blnWantDontCareIgnoredMarkWholeArea && !m_smVisionInfo.g_arrMarks[intUnitNo].GetEnableMarkSetting(i))
                    {
                        //2021-01-18 ZJYEOH : Should use sample position
                        Point pStartTemplate = new Point(intStartX, intStartY);// m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharROIStartPoint(i);
                        Point pEndTemplate = new Point(intEndX, intEndY);// m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharROIEndPoint(i);

                        if ((intOffsetX + pStartTemplate.X - m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftX(i)) >= 0)
                            intRectStartX = intOffsetX + pStartTemplate.X - m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftX(i);
                        else
                            intRectStartX = intOffsetX;

                        if ((intOffsetY + pStartTemplate.Y - m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftY(i)) >= 0)
                            intRectStartY = intOffsetY + pStartTemplate.Y - m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftY(i);
                        else
                            intRectStartY = intOffsetY;

                        if ((intOffsetX + pEndTemplate.X + m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftX(i)) < m_smVisionInfo.g_intCameraResolutionWidth)
                            intRectEndX = intOffsetX + pEndTemplate.X + m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftX(i);
                        else
                            continue;
                        if ((intOffsetY + pEndTemplate.Y + m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftY(i)) < m_smVisionInfo.g_intCameraResolutionHeight)
                            intRectEndY = intOffsetY + pEndTemplate.Y + m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftY(i);
                        else
                            continue;
                    }
                    else
                    {
                        if ((intStartX - intCharDilateHalfWidth) >= 0)
                            intRectStartX = intOffsetX + intStartX - intCharDilateHalfWidth;
                        else
                            intRectStartX = intOffsetX;

                        if ((intStartY - intCharDilateHalfWidth) >= 0)
                            intRectStartY = intOffsetY + intStartY - intCharDilateHalfWidth;
                        else
                            intRectStartY = intOffsetY;

                        if ((intEndX + intCharDilateHalfWidth) < m_smVisionInfo.g_intCameraResolutionWidth)
                            intRectEndX = intOffsetX + intEndX + intCharDilateHalfWidth;
                        else
                            intRectEndX = intOffsetX + intEndX;

                        if ((intEndY + intCharDilateHalfWidth) < m_smVisionInfo.g_intCameraResolutionHeight)
                            intRectEndY = intOffsetY + intEndY + intCharDilateHalfWidth;
                        else
                            intRectEndY = intOffsetY + intEndY;

                    }

                    // 2020 02 27 - Fill rectangle whole bar if it is Bar.
                    if (m_smVisionInfo.g_arrMarks[intUnitNo].ref_blnWantCheckBarPin1)
                    {
                        if (m_smVisionInfo.g_arrMarks[intUnitNo].GetCharIsBarPin1(m_smVisionInfo.g_arrMarks[intUnitNo].ref_intGroupIndex,
                                                                                  m_smVisionInfo.g_arrMarks[intUnitNo].ref_intTemplateIndex,
                                                                                  i))
                        {
                            if (m_smVisionInfo.g_arrMarks[intUnitNo].GetCharBarPin1Type(m_smVisionInfo.g_arrMarks[intUnitNo].ref_intGroupIndex,
                                                                                  m_smVisionInfo.g_arrMarks[intUnitNo].ref_intTemplateIndex,
                                                                                  i) == 0)
                            {
                                // vertical bar
                                //if (intRectStartY > m_objMarkTrainROI.ref_ROITotalY)
                                //    intRectStartY = m_objMarkTrainROI.ref_ROITotalY;
                                //if (intRectEndY < m_objMarkTrainROI.ref_ROITotalY + m_objMarkTrainROI.ref_ROIHeight)
                                //    intRectEndY = m_objMarkTrainROI.ref_ROITotalY + m_objMarkTrainROI.ref_ROIHeight;
                                if (intUnitNo == 0)
                                {
                                    intRectStartY = m_objMarkTrainROI.ref_ROITotalY;
                                    intRectEndY = m_objMarkTrainROI.ref_ROITotalY + m_objMarkTrainROI.ref_ROIHeight;
                                }
                                else
                                {
                                    intRectStartY = m_pMarkTrainROIPoint_Unit2.Y;
                                    intRectEndY = m_pMarkTrainROIPoint_Unit2.Y + m_sMarkTrainROISize_Unit2.Height;
                                }
                            }
                            else
                            {
                                // horizontal bar
                                //if (intRectStartX > m_objMarkTrainROI.ref_ROITotalX)
                                //    intRectStartX = m_objMarkTrainROI.ref_ROITotalX;
                                //if (intRectEndX < m_objMarkTrainROI.ref_ROITotalX + m_objMarkTrainROI.ref_ROIWidth)
                                //    intRectEndX = m_objMarkTrainROI.ref_ROITotalX + m_objMarkTrainROI.ref_ROIWidth;
                                if (intUnitNo == 0)
                                {
                                    intRectStartX = m_objMarkTrainROI.ref_ROITotalX;
                                    intRectEndX = m_objMarkTrainROI.ref_ROITotalX + m_objMarkTrainROI.ref_ROIWidth;
                                }
                                else
                                {
                                    intRectStartX = m_pMarkTrainROIPoint_Unit2.X;
                                    intRectEndX = m_pMarkTrainROIPoint_Unit2.X + m_sMarkTrainROISize_Unit2.Width;
                                }
                            }

                        }
                    }

                    if (blnWantDebug)
                    {
                        m_objPkgViewImage.SaveImage("D:\\TS\\1.m_objPkgViewImage" + i.ToString() + ".bmp");
                    }

                    if (intSideLightViewImageIndex >= 0)
                        Shape.FillRectangle(m_objPkgViewImage, intRectStartX, intRectStartY, intRectEndX, intRectEndY, 0);

                    if (blnWantDebug)
                    {
                        m_objPkgViewImage.SaveImage("D:\\TS\\2.m_objPkgViewImage" + i.ToString() + ".bmp");
                    }

                    // 2020-06-18 ZJYEOH : Fill white pixel on DarkField2 image
                    if (intSideLightViewImageIndex_DarkField2 >= 0 && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateDarkField2DefectSetting && !m_smVisionInfo.g_blnWantCheckVoidOnMarkArea_SideLight[0])
                    {
                        Shape.FillRectangle(m_objPkgViewImage_DarkField2, intRectStartX, intRectStartY, intRectEndX, intRectEndY, 255);
                    }

                    if (intSideLightViewImageIndex_DarkField3 >= 0 && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateDarkField3DefectSetting && !m_smVisionInfo.g_blnWantCheckVoidOnMarkArea_SideLight[1])
                    {
                        Shape.FillRectangle(m_objPkgViewImage_DarkField3, intRectStartX, intRectStartY, intRectEndX, intRectEndY, 255);
                    }

                    if (intSideLightViewImageIndex_DarkField4 >= 0 && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateDarkField4DefectSetting && !m_smVisionInfo.g_blnWantCheckVoidOnMarkArea_SideLight[2])
                    {
                        Shape.FillRectangle(m_objPkgViewImage_DarkField4, intRectStartX, intRectStartY, intRectEndX, intRectEndY, 255);
                    }

                    // 2020-12-18 ZJYEOH : Fill dark pixel on Mold Falsh image
                    if (intMoldFlashViewImageIndex >= 0 && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateMoldFlashDefectSetting)
                    {
                        Shape.FillRectangle(m_objMoldViewImage, intRectStartX, intRectStartY, intRectEndX, intRectEndY, 0);
                    }

                    //m_smVisionInfo.g_arrPackage[intUnitNo].SetDontCareArea(intRectStartX, intRectStartY, intRectEndX, intRectEndY);//2020-12-28 ZJYEOH : Only StartPackageTest_MarkLightView will use this dont care
                }
            }

            if (blnWantDebug)
            {
                m_objPkgViewImage.SaveImage("D:\\TS\\3.m_objPkgViewImage.bmp");
            }


            if (fTotalRotateMarkAngle != fTotalRotateAngle)
            {
                // Rotate unit to package zero deg

                if (m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateDarkField2DefectSetting)
                {
                    m_objSubTh2_RotateROI.AttachImage(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex]);
                    ROI.Rotate0Degree(m_objSubTh2_RotateROI, fTotalRotateAngle - fTotalRotateMarkAngle, m_smVisionInfo.g_intRotationInterpolation_PkgBright, ref m_objPkgViewImage);
                    if (intSideLightViewImageIndex != intSideLightViewImageIndex_DarkField2 && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateDarkField2DefectSetting)
                    {
                        m_objSubTh2_RotateROI.AttachImage(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex_DarkField2]);
                        ROI.Rotate0Degree(m_objSubTh2_RotateROI, fTotalRotateAngle - fTotalRotateMarkAngle, m_smVisionInfo.g_intRotationInterpolation_PkgBright, ref m_objPkgViewImage_DarkField2);
                    }
                    else
                    {
                        m_objPkgViewImage.CopyTo(ref m_objPkgViewImage_DarkField2);
                    }
                }


                if (m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateDarkField3DefectSetting)
                {
                    m_objSubTh2_RotateROI.AttachImage(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex]);
                    ROI.Rotate0Degree(m_objSubTh2_RotateROI, fTotalRotateAngle - fTotalRotateMarkAngle, m_smVisionInfo.g_intRotationInterpolation_PkgBright, ref m_objPkgViewImage);
                    if (intSideLightViewImageIndex != intSideLightViewImageIndex_DarkField3 && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateDarkField3DefectSetting)
                    {
                        m_objSubTh2_RotateROI.AttachImage(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex_DarkField3]);
                        ROI.Rotate0Degree(m_objSubTh2_RotateROI, fTotalRotateAngle - fTotalRotateMarkAngle, m_smVisionInfo.g_intRotationInterpolation_PkgBright, ref m_objPkgViewImage_DarkField3);
                    }
                    else
                    {
                        m_objPkgViewImage.CopyTo(ref m_objPkgViewImage_DarkField3);
                    }
                }


                if (m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateDarkField4DefectSetting)
                {
                    m_objSubTh2_RotateROI.AttachImage(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex]);
                    ROI.Rotate0Degree(m_objSubTh2_RotateROI, fTotalRotateAngle - fTotalRotateMarkAngle, m_smVisionInfo.g_intRotationInterpolation_PkgBright, ref m_objPkgViewImage);
                    if (intSideLightViewImageIndex != intSideLightViewImageIndex_DarkField4 && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateDarkField4DefectSetting)
                    {
                        m_objSubTh2_RotateROI.AttachImage(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex_DarkField4]);
                        ROI.Rotate0Degree(m_objSubTh2_RotateROI, fTotalRotateAngle - fTotalRotateMarkAngle, m_smVisionInfo.g_intRotationInterpolation_PkgBright, ref m_objPkgViewImage_DarkField4);
                    }
                    else
                    {
                        m_objPkgViewImage.CopyTo(ref m_objPkgViewImage_DarkField4);
                    }
                }
            }

            if (fTotalRotateMarkAngle != fTotalRotateAngle)
            {
                if ((intSideLightViewImageIndex != intMoldFlashViewImageIndex && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateMoldFlashDefectSetting) &&
                    (intSideLightViewImageIndex_DarkField2 != intMoldFlashViewImageIndex && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateMoldFlashDefectSetting)
                    && (intSideLightViewImageIndex_DarkField3 != intMoldFlashViewImageIndex && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateMoldFlashDefectSetting)
                    && (intSideLightViewImageIndex_DarkField4 != intMoldFlashViewImageIndex && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateMoldFlashDefectSetting))
                {
                    m_objSubTh2_RotateROI.AttachImage(m_smVisionInfo.g_arrImages[intMoldFlashViewImageIndex]);
                    ROI.Rotate0Degree(m_objSubTh2_RotateROI, fTotalRotateAngle - fTotalRotateMarkAngle, m_smVisionInfo.g_intRotationInterpolation_PkgBright, ref m_objMoldViewImage);
                }
                else
                {
                    if (intSideLightViewImageIndex == intMoldFlashViewImageIndex)
                        m_objPkgViewImage.CopyTo(ref m_objMoldViewImage);
                    else if (intSideLightViewImageIndex_DarkField2 == intMoldFlashViewImageIndex)
                        m_objPkgViewImage_DarkField2.CopyTo(ref m_objMoldViewImage);
                    else if (intSideLightViewImageIndex_DarkField3 == intMoldFlashViewImageIndex)
                        m_objPkgViewImage_DarkField3.CopyTo(ref m_objMoldViewImage);
                    else if (intSideLightViewImageIndex_DarkField4 == intMoldFlashViewImageIndex)
                        m_objPkgViewImage_DarkField4.CopyTo(ref m_objMoldViewImage);
                    else
                        m_objPkgViewImage.CopyTo(ref m_objMoldViewImage);
                }
            }

            if (blnWantDebug)
            {
                m_objPkgViewImage.SaveImage("D:\\TS\\4.m_objPkgViewImage.bmp");
            }

            ROI objPkgViewROI = null; // Image 2 - Package ROI
            if (intSideLightViewImageIndex >= 0)
            {
                objPkgViewROI = new ROI();
                objPkgViewROI.LoadROISetting((int)Math.Round((fGaugeCenterX -
                                             fGaugeWidth / 2 +
                                             m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeft), 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round((fGaugeCenterY -
                                             fGaugeHeight / 2 +
                                             m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdge), 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round(fGaugeWidth - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromRight - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeft, 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round(fGaugeHeight - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdge - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromBottom, 0, MidpointRounding.AwayFromZero));
                objPkgViewROI.AttachImage(m_objPkgViewImage);
            }


            ROI objPkgViewROI_DarkField2 = null; // Dark Field 2 ROI
            ROI objPkgViewROI_DarkField3 = null; // Dark Field 3 ROI
            ROI objPkgViewROI_DarkField4 = null; // Dark Field 4 ROI

            if (intSideLightViewImageIndex_DarkField2 >= 0)
            {
                objPkgViewROI_DarkField2 = new ROI();
                objPkgViewROI_DarkField2.AttachImage(m_objPkgViewImage_DarkField2);
                objPkgViewROI_DarkField2.LoadROISetting((int)Math.Round((fGaugeCenterX -
                                             fGaugeWidth / 2 +
                                             m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeft_DarkField2), 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round((fGaugeCenterY -
                                             fGaugeHeight / 2 +
                                             m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdge_DarkField2), 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round(fGaugeWidth - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromRight_DarkField2 - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeft_DarkField2, 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round(fGaugeHeight - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdge_DarkField2 - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromBottom_DarkField2, 0, MidpointRounding.AwayFromZero));
            }

            if (intSideLightViewImageIndex_DarkField3 >= 0)
            {
                objPkgViewROI_DarkField3 = new ROI();
                objPkgViewROI_DarkField3.AttachImage(m_objPkgViewImage_DarkField3);
                objPkgViewROI_DarkField3.LoadROISetting((int)Math.Round((fGaugeCenterX -
                                             fGaugeWidth / 2 +
                                             m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeft_DarkField3), 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round((fGaugeCenterY -
                                             fGaugeHeight / 2 +
                                             m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdge_DarkField3), 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round(fGaugeWidth - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromRight_DarkField3 - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeft_DarkField3, 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round(fGaugeHeight - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdge_DarkField3 - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromBottom_DarkField3, 0, MidpointRounding.AwayFromZero));
            }


            if (intSideLightViewImageIndex_DarkField4 >= 0)
            {
                objPkgViewROI_DarkField4 = new ROI();
                objPkgViewROI_DarkField4.AttachImage(m_objPkgViewImage_DarkField4);
                objPkgViewROI_DarkField4.LoadROISetting((int)Math.Round((fGaugeCenterX -
                                             fGaugeWidth / 2 +
                                             m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeft_DarkField4), 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round((fGaugeCenterY -
                                             fGaugeHeight / 2 +
                                             m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdge_DarkField4), 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round(fGaugeWidth - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromRight_DarkField4 - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeft_DarkField4, 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round(fGaugeHeight - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdge_DarkField4 - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromBottom_DarkField4, 0, MidpointRounding.AwayFromZero));
            }

            ROI objChipUnitROI = null; // Image 2 - Chip ROI
            if (intSideLightViewImageIndex >= 0)
            {
                objChipUnitROI = new ROI();
                //objChipUnitROI.LoadROISetting((int)Math.Round((fGaugeCenterX - fGaugeWidth / 2), 0, MidpointRounding.AwayFromZero),
                //                              (int)Math.Round((fGaugeCenterY - fGaugeHeight / 2), 0, MidpointRounding.AwayFromZero),
                //                              (int)Math.Round(fGaugeWidth, 0, MidpointRounding.AwayFromZero),
                //                              (int)Math.Round(fGaugeHeight, 0, MidpointRounding.AwayFromZero));
                objChipUnitROI.LoadROISetting((int)Math.Round((fGaugeCenterX - fGaugeWidth / 2) + m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelExtendFromLeft_Chip, 0, MidpointRounding.AwayFromZero),
                                        (int)Math.Round((fGaugeCenterY - fGaugeHeight / 2) + m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelExtendFromEdge_Chip, 0, MidpointRounding.AwayFromZero),
                                        (int)Math.Round(fGaugeWidth - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelExtendFromLeft_Chip - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelExtendFromRight_Chip, 0, MidpointRounding.AwayFromZero),
                                        (int)Math.Round(fGaugeHeight - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelExtendFromEdge_Chip - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelExtendFromBottom_Chip, 0, MidpointRounding.AwayFromZero));

                // Use pkg image for chip test as priority
                objChipUnitROI.AttachImage(m_objPkgViewImage);
            }

            ROI objMoldFlashROI = null; // Image 2 - MoldFlash ROI
            if (intMoldFlashViewImageIndex >= 0)
            {
                objMoldFlashROI = new ROI();
                objMoldFlashROI.LoadROISetting((int)Math.Round((fGaugeCenterX -
                                             fGaugeWidth / 2 -
                                             m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeft_Mold), 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round((fGaugeCenterY -
                                             fGaugeHeight / 2 -
                                             m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdge_Mold), 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round(fGaugeWidth + m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromRight_Mold + m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeft_Mold, 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round(fGaugeHeight + m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdge_Mold + m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromBottom_Mold, 0, MidpointRounding.AwayFromZero));
                objMoldFlashROI.AttachImage(m_objMoldViewImage);
            }

            if (m_smVisionInfo.g_blnWantDontCareArea_Package)
            {
                if (intSideLightViewImageIndex >= 0)
                {
                    ////Draw don't care ROI edge to make sure Don't Care Area is not inspected
                    //for (int k = 3; k < m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit].Count; k++)
                    //{
                    //    m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][k].AttachImage(objPkgViewROI);
                    //    ROI objROI = new ROI();
                    //    objROI.LoadROISetting((int)Math.Round((fGaugeCenterX - fGaugeWidth / 2 + m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][k].ref_ROIPositionX), 0, MidpointRounding.AwayFromZero),
                    //                          (int)Math.Round((fGaugeCenterY - fGaugeHeight / 2 + m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][k].ref_ROIPositionY), 0, MidpointRounding.AwayFromZero),
                    //                           m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][k].ref_ROIWidth, m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][k].ref_ROIHeight);
                    //    objROI.AttachImage(m_smVisionInfo.g_objWhiteImage);
                    //    ROI.SubtractROI(m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][k], objROI);
                    //    //objPkgViewROI.SaveImage("D:\\aaa.bmp");
                    //    objROI.Dispose();
                    //}

                    ROI objDontCareROI = new ROI();
                    //objDontCareROI.LoadROISetting(0, 0, objPkgViewROI.ref_ROIWidth, objPkgViewROI.ref_ROIHeight);
                    // 2020 06 27 - CCENG: objDontCareROI have to start from Package Tolerance bcos g_objDontCareImage_Package_Bright template is start from Package Size Template.
                    objDontCareROI.LoadROISetting(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeft,
                                                  m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdge,
                                                  objPkgViewROI.ref_ROIWidth, objPkgViewROI.ref_ROIHeight);
                    objDontCareROI.AttachImage(m_smVisionInfo.g_objDontCareImage_Package_Bright);
                    ROI.SubtractROI(objPkgViewROI, objDontCareROI);
                    //objPkgViewROI.SaveImage("D:\\aaa.bmp");
                    objDontCareROI.Dispose();
                }

                if (intSideLightViewImageIndex_DarkField2 >= 0 && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateDarkField2DefectSetting)
                {
                    ROI objDontCareROI = new ROI();
                    objDontCareROI.LoadROISetting(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeft,
                                                  m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdge,
                                                  objPkgViewROI.ref_ROIWidth, objPkgViewROI.ref_ROIHeight);
                    objDontCareROI.AttachImage(m_smVisionInfo.g_objDontCareImage_Package_Bright);
                    ROI.LogicOperationAddROI(objPkgViewROI_DarkField2, objDontCareROI);
                    //objPkgViewROI.SaveImage("D:\\aaa.bmp");
                    objDontCareROI.Dispose();
                }

                if (intSideLightViewImageIndex_DarkField3 >= 0 && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateDarkField3DefectSetting)
                {
                    ROI objDontCareROI = new ROI();
                    objDontCareROI.LoadROISetting(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeft,
                                                  m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdge,
                                                  objPkgViewROI.ref_ROIWidth, objPkgViewROI.ref_ROIHeight);
                    objDontCareROI.AttachImage(m_smVisionInfo.g_objDontCareImage_Package_Bright);
                    ROI.LogicOperationAddROI(objPkgViewROI_DarkField3, objDontCareROI);
                    objDontCareROI.Dispose();
                }

                if (intSideLightViewImageIndex_DarkField4 >= 0 && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateDarkField4DefectSetting)
                {
                    ROI objDontCareROI = new ROI();
                    objDontCareROI.LoadROISetting(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeft,
                                                  m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdge,
                                                  objPkgViewROI.ref_ROIWidth, objPkgViewROI.ref_ROIHeight);
                    objDontCareROI.AttachImage(m_smVisionInfo.g_objDontCareImage_Package_Bright);
                    ROI.LogicOperationAddROI(objPkgViewROI_DarkField4, objDontCareROI);
                    objDontCareROI.Dispose();
                }

                if (intMoldFlashViewImageIndex >= 0 && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateMoldFlashDefectSetting)
                {
                    ROI objDontCareROI = new ROI();
                    ROI objOriROI = new ROI();
                    for (int i = 0; i < m_smVisionInfo.g_arrPackageMoldFlashDontCareROIs.Count; i++)
                    {
                        objOriROI.AttachImage(m_objMoldViewImage);

                        objDontCareROI.AttachImage(m_smVisionInfo.g_objWhiteImage);

                        objOriROI.LoadROISetting((int)Math.Round(fCenterX - m_smVisionInfo.g_arrPackageMoldFlashDontCareROIs[i].ref_intStartOffsetX),
                                                      (int)Math.Round(fCenterY - m_smVisionInfo.g_arrPackageMoldFlashDontCareROIs[i].ref_intStartOffsetY),
                                                      m_smVisionInfo.g_arrPackageMoldFlashDontCareROIs[i].ref_ROIWidth, m_smVisionInfo.g_arrPackageMoldFlashDontCareROIs[i].ref_ROIHeight);

                        objDontCareROI.LoadROISetting((int)Math.Round(fCenterX - m_smVisionInfo.g_arrPackageMoldFlashDontCareROIs[i].ref_intStartOffsetX),
                                                      (int)Math.Round(fCenterY - m_smVisionInfo.g_arrPackageMoldFlashDontCareROIs[i].ref_intStartOffsetY),
                                                      m_smVisionInfo.g_arrPackageMoldFlashDontCareROIs[i].ref_ROIWidth, m_smVisionInfo.g_arrPackageMoldFlashDontCareROIs[i].ref_ROIHeight);

                        ROI.SubtractROI(objOriROI, objDontCareROI);
                        //m_objMoldViewImage.SaveImage("D:\\m_objMoldViewImage.bmp");
                        //objMoldFlashROI.SaveImage("D:\\objMoldFlashROI" + i.ToString() + ".bmp");
                    }
                    objDontCareROI.Dispose();
                    objOriROI.Dispose();
                }
            }

            //objPkgViewROI.SaveImage("D:\\TS\\objPkgViewROI" + m_intTestCount.ToString() + ".bmp");
            //objChipUnitROI.SaveImage("D:\\TS\\objChipUnitROI" + m_intTestCount.ToString() + ".bmp");
            if (m_smVisionInfo.g_intPackageDefectInspectionMethod == 0)
            {
                if (!m_smVisionInfo.g_arrPackage[intUnitNo].DoInspection_SideLightView(//m_smVisionInfo.g_arrPackageGaugeM4L[intUnitNo],   // use to measure unit edge
                                                    fGaugeCenterX, fGaugeCenterY,
                                                    fGaugeWidth, fGaugeHeight,
                                                    objPkgViewROI,              // Package Test on second image
                                                    objChipUnitROI,             // Chipped off test on image 2
                                                    m_objPkgViewImage,         // Second package image (option)
                                                    objMoldFlashROI,
                                                    objPkgViewROI_DarkField2,
                                                    objPkgViewROI_DarkField3,
                                                    objPkgViewROI_DarkField4, // Dark field 2 ROI
                                                    m_smVisionInfo.g_objWhiteImage, m_smVisionInfo.g_objBlackImage))
                {
                    if (intUnitNo == 1)
                    {
                        m_smVisionInfo.g_strErrorMessageForSecondUnit += GetUnitName(intUnitNo) + m_smVisionInfo.g_arrPackage[intUnitNo].ref_strErrorMessage;
                    }
                    else
                    {
                        m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + m_smVisionInfo.g_arrPackage[intUnitNo].ref_strErrorMessage;
                    }

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 11 PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());

                    if (blnAuto)
                    {
                        SaveRejectImage_AddToBuffer("PackageDefect", m_smVisionInfo.g_arrPackage[intUnitNo].ref_strErrorMessage);
                    }
                    if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                    {
                        if (!m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        {
                            m_objVisionIO.PackageFail.SetOn("V4 PackageFail 2");
                        }
                        //SaveRejectImage_AddToBuffer("PackageDefect", m_smVisionInfo.g_arrPackage[intUnitNo].ref_strErrorMessage);

                        m_smVisionInfo.g_intPkgDefectFailureTotal++;
                        //m_smVisionInfo.g_intTestedTotal++;
                        //m_smVisionInfo.g_intLowYieldUnitCount++;
                        m_blnFailCounterAdded = true;
                        m_blnTotalCounterAdded = false;
                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 11a PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                    }
                    if (blnAuto)
                    {
                        if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        {
                            m_blnPackageFail_Out = true;
                            if (m_intTCPIPResultID == -1)
                                SetPackageResultID(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailResultMask);
                        }
                    }
                    blnResult = false;
                }
            }
            else
            {
                if (!m_smVisionInfo.g_arrPackage[intUnitNo].DoInspection_SideLightView_GrayValueThresholdMethod(//m_smVisionInfo.g_arrPackageGaugeM4L[intUnitNo],   // use to measure unit edge
                                                    fGaugeCenterX, fGaugeCenterY,
                                                    fGaugeWidth, fGaugeHeight, 
                                                    objPkgViewROI,              // Package Test on second image
                                                    objChipUnitROI,             // Chipped off test on image 2
                                                    m_objPkgViewImage,         // Second package image (option)
                                                    m_objGrayValueImage_SideLight,
                                                    objMoldFlashROI,
                                                    m_smVisionInfo.g_intPackageInspectionAreaGrayValueSensitivity,
                                                    m_smVisionInfo.g_intPackageMergeSensitivity,
                                                    m_smVisionInfo.g_intPackageBrightSensitivity,
                                                    m_smVisionInfo.g_objWhiteImage, m_smVisionInfo.g_objBlackImage))
                {
                    if (intUnitNo == 1)
                    {
                        m_smVisionInfo.g_strErrorMessageForSecondUnit += GetUnitName(intUnitNo) + m_smVisionInfo.g_arrPackage[intUnitNo].ref_strErrorMessage;
                    }
                    else
                    {
                        m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + m_smVisionInfo.g_arrPackage[intUnitNo].ref_strErrorMessage;
                    }

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 11 PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());

                    if (blnAuto)
                    {
                        SaveRejectImage_AddToBuffer("PackageDefect", m_smVisionInfo.g_arrPackage[intUnitNo].ref_strErrorMessage);
                    }
                    if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                    {
                        if (!m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        {
                            m_objVisionIO.PackageFail.SetOn("V4 PackageFail 2");
                        }
                        //SaveRejectImage_AddToBuffer("PackageDefect", m_smVisionInfo.g_arrPackage[intUnitNo].ref_strErrorMessage);

                        m_smVisionInfo.g_intPkgDefectFailureTotal++;
                        //m_smVisionInfo.g_intTestedTotal++;
                        //m_smVisionInfo.g_intLowYieldUnitCount++;
                        m_blnFailCounterAdded = true;
                        m_blnTotalCounterAdded = false;
                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 11a PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                    }
                    if (blnAuto)
                    {
                        if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        {
                            m_blnPackageFail_Out = true;
                            if (m_intTCPIPResultID == -1)
                                SetPackageResultID(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailResultMask);
                        }
                    }
                    blnResult = false;
                }
            }
            objMoldFlashROI.Dispose();
            objPkgViewROI.Dispose();
            objPkgViewROI_DarkField2.Dispose();
            objPkgViewROI_DarkField3.Dispose();
            objPkgViewROI_DarkField4.Dispose();
            objChipUnitROI.Dispose();
            m_smVisionInfo.g_blnDrawPkgResult = true;
            m_smVisionInfo.g_blnPackageInspected = true;

            return blnResult;
        }
        private bool StartPackageTest_SideLightView_WithoutRotate(bool blnAuto, int intUnitNo)
        {
            bool blnResult = true;
            bool blnWantDebug = false;

            if ((m_smCustomizeInfo.g_intWantPackage & (1 << m_smVisionInfo.g_intVisionPos)) == 0 || !m_smVisionInfo.g_arrPackage[intUnitNo].GetWantInspectPackage())
                return true;

            // Check is templates learnt
            if (m_smVisionInfo.g_arrPackageROIs[intUnitNo].Count == 0)
            {
                if (intUnitNo == 1)
                {
                    m_smVisionInfo.g_strErrorMessageForSecondUnit += GetUnitName(intUnitNo) + "*Package : No Template Found";
                }
                else
                {
                    m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + "*Package : No Template Found";
                }

                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 8 PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                {
                    m_smVisionInfo.g_intNoTemplateFailureTotal++;
                    m_blnFailCounterAdded = true;
                    m_blnTotalCounterAdded = false;

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 8a PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                }
                if (blnAuto)
                {
                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        if (m_intTCPIPResultID == -1)
                            SetPackageResultID(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailResultMask);
                }
                return false;
            }

            // Make sure template unit size not set to zero
            if ((m_smVisionInfo.g_arrPackage[intUnitNo].ref_fUnitWidthMin == 0 || m_smVisionInfo.g_arrPackage[intUnitNo].ref_fUnitHeightMin == 0) ||
                (m_smVisionInfo.g_arrPackage[intUnitNo].ref_fUnitWidthMax == 0 || m_smVisionInfo.g_arrPackage[intUnitNo].ref_fUnitHeightMax == 0))
            {
                if (intUnitNo == 1)
                {
                    m_smVisionInfo.g_strErrorMessageForSecondUnit += GetUnitName(intUnitNo) + "*Package : Template Unit Size cannot be zero.";
                }
                else
                {
                    m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + "*Package : Template Unit Size cannot be zero.";
                }

                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 9 PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)//2020-11-11 ZJYEOH : Removed && !m_blnPassCounterAdded
                {
                    m_smVisionInfo.g_intPackageFailureTotal++;
                    m_blnFailCounterAdded = true;
                    m_blnTotalCounterAdded = false;

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 9a PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                }
                if (blnAuto)
                {
                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        if (m_intTCPIPResultID == -1)
                            SetPackageResultID(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailResultMask);
                }
                return false;
            }

            // ------------- Make sure grab image done ------------------------
            int intSideLightViewImageIndex = m_smVisionInfo.g_arrPackage[intUnitNo].GetGrabImageIndex(2);     // Side light View
            if (intSideLightViewImageIndex == 0)
                WaitEventDone(ref m_bGrabImage1Done, true, 10000, "StartPackageTest_SideLightView_WithoutRotate > m_bGrabImage1Done f");
            else if (intSideLightViewImageIndex == 1)
                WaitEventDone(ref m_bGrabImage2Done, true, 10000, "StartPackageTest_SideLightView_WithoutRotate > m_bGrabImage2Done f");
            else if (intSideLightViewImageIndex == 2)
                WaitEventDone(ref m_bGrabImage3Done, true, 10000, "StartPackageTest_SideLightView_WithoutRotate > m_bGrabImage3Done f");
            else if (intSideLightViewImageIndex == 3)
                WaitEventDone(ref m_bGrabImage4Done, true, 10000, "StartPackageTest_SideLightView_WithoutRotate > m_bGrabImage4Done f");
            else if (intSideLightViewImageIndex == 4)
                WaitEventDone(ref m_bGrabImage5Done, true, 10000, "StartPackageTest_SideLightView_WithoutRotate > m_bGrabImage5Done f");
            else if (intSideLightViewImageIndex == 5)
                WaitEventDone(ref m_bGrabImage6Done, true, 10000, "StartPackageTest_SideLightView_WithoutRotate > m_bGrabImage6Done f");
            else if (intSideLightViewImageIndex == 6)
                WaitEventDone(ref m_bGrabImage7Done, true, 10000, "StartPackageTest_SideLightView_WithoutRotate > m_bGrabImage7Done f");
            else
            {
                if (intUnitNo == 1)
                {
                    m_smVisionInfo.g_strErrorMessageForSecondUnit += GetUnitName(intUnitNo) + "*Package : Wrong setting for package (Side Light View) image number. intSideLightViewImageIndex = " + intSideLightViewImageIndex.ToString();
                }
                else
                {
                    m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + "*Package : Wrong setting for package (Side Light View) image number. intSideLightViewImageIndex = " + intSideLightViewImageIndex.ToString();
                }

                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 10 PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)//2020-11-11 ZJYEOH : Removed && !m_blnPassCounterAdded
                {
                    m_smVisionInfo.g_intPackageFailureTotal++;
                    m_blnFailCounterAdded = true;
                    m_blnTotalCounterAdded = false;

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 10a PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                }
                if (blnAuto)
                {
                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        if (m_intTCPIPResultID == -1)
                            SetPackageResultID(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailResultMask);
                }
                return false;
            }

            //2020-06-18 ZJYEOH : wait image used for dark field 2 grab done
            int intSideLightViewImageIndex_DarkField2 = m_smVisionInfo.g_arrPackage[intUnitNo].GetGrabImageIndex(4);     // Side light View
            if (intSideLightViewImageIndex_DarkField2 == 0)
                WaitEventDone(ref m_bGrabImage1Done, true, 10000, "StartPackageTest_SideLightView_WithoutRotate > m_bGrabImage1Done g");
            else if (intSideLightViewImageIndex_DarkField2 == 1)
                WaitEventDone(ref m_bGrabImage2Done, true, 10000, "StartPackageTest_SideLightView_WithoutRotate > m_bGrabImage2Done g");
            else if (intSideLightViewImageIndex_DarkField2 == 2)
                WaitEventDone(ref m_bGrabImage3Done, true, 10000, "StartPackageTest_SideLightView_WithoutRotate > m_bGrabImage3Done g");
            else if (intSideLightViewImageIndex_DarkField2 == 3)
                WaitEventDone(ref m_bGrabImage4Done, true, 10000, "StartPackageTest_SideLightView_WithoutRotate > m_bGrabImage4Done g");
            else if (intSideLightViewImageIndex_DarkField2 == 4)
                WaitEventDone(ref m_bGrabImage5Done, true, 10000, "StartPackageTest_SideLightView_WithoutRotate > m_bGrabImage5Done g");
            else if (intSideLightViewImageIndex_DarkField2 == 5)
                WaitEventDone(ref m_bGrabImage6Done, true, 10000, "StartPackageTest_SideLightView_WithoutRotate > m_bGrabImage6Done g");
            else if (intSideLightViewImageIndex_DarkField2 == 6)
                WaitEventDone(ref m_bGrabImage7Done, true, 10000, "StartPackageTest_SideLightView_WithoutRotate > m_bGrabImage7Done g");
            else
            {
                if (intUnitNo == 1)
                {
                    m_smVisionInfo.g_strErrorMessageForSecondUnit += GetUnitName(intUnitNo) + "*Package : Wrong setting for package (Side Light View - Dark Field 2) image number. intSideLightViewImageIndex_DarkField2 = " + intSideLightViewImageIndex_DarkField2.ToString();
                }
                else
                {
                    m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + "*Package : Wrong setting for package (Side Light View - Dark Field 2) image number. intSideLightViewImageIndex_DarkField2 = " + intSideLightViewImageIndex_DarkField2.ToString();
                }

                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 10 PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)//2020-11-11 ZJYEOH : Removed && !m_blnPassCounterAdded
                {
                    m_smVisionInfo.g_intPackageFailureTotal++;
                    m_blnFailCounterAdded = true;
                    m_blnTotalCounterAdded = false;

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 10a PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                }
                if (blnAuto)
                {
                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        if (m_intTCPIPResultID == -1)
                            SetPackageResultID(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailResultMask);
                }
                return false;
            }

            int intSideLightViewImageIndex_DarkField3 = m_smVisionInfo.g_arrPackage[intUnitNo].GetGrabImageIndex(6);     // Side light View
            if (intSideLightViewImageIndex_DarkField3 == 0)
                WaitEventDone(ref m_bGrabImage1Done, true, 10000, "StartPackageTest_SideLightView_WithoutRotate > m_bGrabImage1Done g");
            else if (intSideLightViewImageIndex_DarkField3 == 1)
                WaitEventDone(ref m_bGrabImage2Done, true, 10000, "StartPackageTest_SideLightView_WithoutRotate > m_bGrabImage2Done g");
            else if (intSideLightViewImageIndex_DarkField3 == 2)
                WaitEventDone(ref m_bGrabImage3Done, true, 10000, "StartPackageTest_SideLightView_WithoutRotate > m_bGrabImage3Done g");
            else if (intSideLightViewImageIndex_DarkField3 == 3)
                WaitEventDone(ref m_bGrabImage4Done, true, 10000, "StartPackageTest_SideLightView_WithoutRotate > m_bGrabImage4Done g");
            else if (intSideLightViewImageIndex_DarkField3 == 4)
                WaitEventDone(ref m_bGrabImage5Done, true, 10000, "StartPackageTest_SideLightView_WithoutRotate > m_bGrabImage5Done g");
            else if (intSideLightViewImageIndex_DarkField3 == 5)
                WaitEventDone(ref m_bGrabImage6Done, true, 10000, "StartPackageTest_SideLightView_WithoutRotate > m_bGrabImage6Done g");
            else if (intSideLightViewImageIndex_DarkField3 == 6)
                WaitEventDone(ref m_bGrabImage7Done, true, 10000, "StartPackageTest_SideLightView_WithoutRotate > m_bGrabImage7Done g");
            else
            {
                if (intUnitNo == 1)
                {
                    m_smVisionInfo.g_strErrorMessageForSecondUnit += GetUnitName(intUnitNo) + "*Package : Wrong setting for package (Side Light View - Dark Field 3) image number. intSideLightViewImageIndex_DarkField3 = " + intSideLightViewImageIndex_DarkField3.ToString();
                }
                else
                {
                    m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + "*Package : Wrong setting for package (Side Light View - Dark Field 3) image number. intSideLightViewImageIndex_DarkField3 = " + intSideLightViewImageIndex_DarkField3.ToString();
                }

                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 10 PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)//2020-11-11 ZJYEOH : Removed && !m_blnPassCounterAdded
                {
                    m_smVisionInfo.g_intPackageFailureTotal++;
                    m_blnFailCounterAdded = true;
                    m_blnTotalCounterAdded = false;

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 10a PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                }
                if (blnAuto)
                {
                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        if (m_intTCPIPResultID == -1)
                            SetPackageResultID(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailResultMask);
                }
                return false;
            }

            int intSideLightViewImageIndex_DarkField4 = m_smVisionInfo.g_arrPackage[intUnitNo].GetGrabImageIndex(7);     // Side light View
            if (intSideLightViewImageIndex_DarkField4 == 0)
                WaitEventDone(ref m_bGrabImage1Done, true, 10000, "StartPackageTest_SideLightView_WithoutRotate > m_bGrabImage1Done g");
            else if (intSideLightViewImageIndex_DarkField4 == 1)
                WaitEventDone(ref m_bGrabImage2Done, true, 10000, "StartPackageTest_SideLightView_WithoutRotate > m_bGrabImage2Done g");
            else if (intSideLightViewImageIndex_DarkField4 == 2)
                WaitEventDone(ref m_bGrabImage3Done, true, 10000, "StartPackageTest_SideLightView_WithoutRotate > m_bGrabImage3Done g");
            else if (intSideLightViewImageIndex_DarkField4 == 3)
                WaitEventDone(ref m_bGrabImage4Done, true, 10000, "StartPackageTest_SideLightView_WithoutRotate > m_bGrabImage4Done g");
            else if (intSideLightViewImageIndex_DarkField4 == 4)
                WaitEventDone(ref m_bGrabImage5Done, true, 10000, "StartPackageTest_SideLightView_WithoutRotate > m_bGrabImage5Done g");
            else if (intSideLightViewImageIndex_DarkField4 == 5)
                WaitEventDone(ref m_bGrabImage6Done, true, 10000, "StartPackageTest_SideLightView_WithoutRotate > m_bGrabImage6Done g");
            else if (intSideLightViewImageIndex_DarkField4 == 6)
                WaitEventDone(ref m_bGrabImage7Done, true, 10000, "StartPackageTest_SideLightView_WithoutRotate > m_bGrabImage7Done g");
            else
            {
                if (intUnitNo == 1)
                {
                    m_smVisionInfo.g_strErrorMessageForSecondUnit += GetUnitName(intUnitNo) + "*Package : Wrong setting for package (Side Light View - Dark Field 4) image number. intSideLightViewImageIndex_DarkField4 = " + intSideLightViewImageIndex_DarkField4.ToString();
                }
                else
                {
                    m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + "*Package : Wrong setting for package (Side Light View - Dark Field 4) image number. intSideLightViewImageIndex_DarkField4 = " + intSideLightViewImageIndex_DarkField4.ToString();
                }

                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 10 PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)//2020-11-11 ZJYEOH : Removed && !m_blnPassCounterAdded
                {
                    m_smVisionInfo.g_intPackageFailureTotal++;
                    m_blnFailCounterAdded = true;
                    m_blnTotalCounterAdded = false;

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 10a PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                }
                if (blnAuto)
                {
                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        if (m_intTCPIPResultID == -1)
                            SetPackageResultID(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailResultMask);
                }
                return false;
            }

            //2020-12-18 ZJYEOH : wait image used for dark field 2 grab done
            int intMoldFlashViewImageIndex = m_smVisionInfo.g_arrPackage[intUnitNo].GetGrabImageIndex(5);     // Mold Flash View
            if (intMoldFlashViewImageIndex == 0)
                WaitEventDone(ref m_bGrabImage1Done, true, 10000, "StartPackageTest_SideLightView_WithoutRotate > m_bGrabImage1Done h");
            else if (intMoldFlashViewImageIndex == 1)
                WaitEventDone(ref m_bGrabImage2Done, true, 10000, "StartPackageTest_SideLightView_WithoutRotate > m_bGrabImage2Done h");
            else if (intMoldFlashViewImageIndex == 2)
                WaitEventDone(ref m_bGrabImage3Done, true, 10000, "StartPackageTest_SideLightView_WithoutRotate > m_bGrabImage3Done h");
            else if (intMoldFlashViewImageIndex == 3)
                WaitEventDone(ref m_bGrabImage4Done, true, 10000, "StartPackageTest_SideLightView_WithoutRotate > m_bGrabImage4Done h");
            else if (intMoldFlashViewImageIndex == 4)
                WaitEventDone(ref m_bGrabImage5Done, true, 10000, "StartPackageTest_SideLightView_WithoutRotate > m_bGrabImage5Done h");
            else if (intMoldFlashViewImageIndex == 5)
                WaitEventDone(ref m_bGrabImage6Done, true, 10000, "StartPackageTest_SideLightView_WithoutRotate > m_bGrabImage6Done h");
            else if (intMoldFlashViewImageIndex == 6)
                WaitEventDone(ref m_bGrabImage7Done, true, 10000, "StartPackageTest_SideLightView_WithoutRotate > m_bGrabImage7Done h");
            else
            {
                if (intUnitNo == 1)
                {
                    m_smVisionInfo.g_strErrorMessageForSecondUnit += GetUnitName(intUnitNo) + "*Package : Wrong setting for package (Side Light View - Dark Field 2) image number. intMoldFlashViewImageIndex = " + intMoldFlashViewImageIndex.ToString();
                }
                else
                {
                    m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + "*Package : Wrong setting for package (Side Light View - Dark Field 2) image number. intMoldFlashViewImageIndex = " + intMoldFlashViewImageIndex.ToString();
                }

                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 10 PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)//2020-11-11 ZJYEOH : Removed && !m_blnPassCounterAdded
                {
                    m_smVisionInfo.g_intPackageFailureTotal++;
                    m_blnFailCounterAdded = true;
                    m_blnTotalCounterAdded = false;

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 10a PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                }
                if (blnAuto)
                {
                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        if (m_intTCPIPResultID == -1)
                            SetPackageResultID(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailResultMask);
                }
                return false;
            }

            // 08-03-19 ZJYEOH: wait for orient angle update
            //if (intSideLightViewImageIndex > 0)
            if (intUnitNo == 0)
                WaitEventDone(ref m_blnOrientDataUpdated1, true, 10000, "StartPackageTest_SideLightView_WithoutRotate > m_blnOrientDataUpdated1 6758");
            else
                WaitEventDone(ref m_blnOrientDataUpdated2, true, 10000, "StartPackageTest_SideLightView_WithoutRotate > m_blnOrientDataUpdated2 6760");


            // ---------  Rotate image 2 and 3 to oriented 0 deg -------------
            if (m_objGauge_PkgSideView == null)
            {
                m_objGauge_PkgSideView = new RectGaugeM4L(m_smVisionInfo.g_WorldShape, 0, m_smVisionInfo.g_intVisionIndex);
            }

            float fGaugeCenterX = 0, fGaugeCenterY = 0, fGaugeWidth = 0, fGaugeHeight = 0, fGaugeAngle = 0;

            if (m_smVisionInfo.g_blnWantGauge &&
                (intSideLightViewImageIndex == 0 ||
                (intSideLightViewImageIndex_DarkField2 == 0 && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateDarkField2DefectSetting) ||
                (intSideLightViewImageIndex_DarkField3 == 0 && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateDarkField3DefectSetting) ||
                (intSideLightViewImageIndex_DarkField4 == 0 && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateDarkField4DefectSetting) ||
                (intMoldFlashViewImageIndex == 0 && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateMoldFlashDefectSetting)))
            {
                //if (intSideLightViewImageIndex == 0)
                //{
                //    m_smVisionInfo.g_arrOrientGauge[intUnitNo].CopyTo(ref m_objGauge_PkgSideView);
                //    GaugeMeasureUnit(m_objGauge_PkgSideView, m_smVisionInfo.g_arrImages[intSideLightViewImageIndex]);
                //}
                //else if (intSideLightViewImageIndex == 1)
                //{
                //    m_smVisionInfo.g_arrPackageGauge[intUnitNo].CopyTo(ref m_objGauge_PkgSideView);
                //    GaugeMeasureUnit(m_objGauge_PkgSideView, m_smVisionInfo.g_arrImages[intSideLightViewImageIndex]);
                //}
                //else
                //{
                //    if (m_smVisionInfo.g_arrPackageGauge2[0] != null)
                //    {
                //        m_smVisionInfo.g_arrPackageGauge2[intUnitNo].CopyTo(ref m_objGauge_PkgSideView);
                //        GaugeMeasureUnit(m_objGauge_PkgSideView, m_smVisionInfo.g_arrImages[intSideLightViewImageIndex]);
                //    }
                //    else
                //    {
                //        m_smVisionInfo.g_arrPackageGauge[intUnitNo].CopyTo(ref m_objGauge_PkgSideView);
                //        GaugeMeasureUnit(m_objGauge_PkgSideView, m_smVisionInfo.g_arrImages[intSideLightViewImageIndex]);
                //    }
                //}
                if (m_blnWantOrientTest)
                    m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].CopyTo(ref m_objGauge_PkgSideView);
                else
                    m_smVisionInfo.g_arrMarkGaugeM4L[intUnitNo].CopyTo(ref m_objGauge_PkgSideView); // 2019-09-18 ZJYEOH : Changed g_arrPackageGaugeM4L to g_arrMarkGaugeM4L, if got use mark gauge and intSideLightViewImageIndex == 0

                int[] arrUserSelectImageViewIndex = m_objGauge_PkgSideView.GetGaugeImageNoList();

                if (!WaitEventDone(arrUserSelectImageViewIndex, "StartPackageTest_SideLightView_WithoutRotate > arrUserSelectImageViewIndex 6806"))
                {
                    if (intUnitNo == 1)
                    {
                        m_smVisionInfo.g_strErrorMessageForSecondUnit += GetUnitName(intUnitNo) + "*Package : Wrong setting for package size image number.";
                    }
                    else
                    {
                        m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + "*Package : Wrong setting for package size image number.";
                    }

                    if (blnAuto)
                    {
                        m_smVisionInfo.g_intPackageFailureTotal++;

                        if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                            if (m_intTCPIPResultID == -1)
                                SetPackageResultID(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailResultMask);

                    }
                    return false;
                }

                if (!GaugeMeasureUnit(m_objGauge_PkgSideView, m_smVisionInfo.g_arrImages, intUnitNo))
                {
                    if (intUnitNo == 1)
                    {
                        m_smVisionInfo.g_strErrorMessageForSecondUnit += GetUnitName(intUnitNo) + "*Package : " + m_objGauge_PkgSideView.ref_strErrorMessage;
                    }
                    else
                    {
                        m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + "*Package : " + m_objGauge_PkgSideView.ref_strErrorMessage;
                    }

                    //if (blnAuto)
                    if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)//2020-11-11 ZJYEOH : Removed && !m_blnPassCounterAdded
                    {
                        m_smVisionInfo.g_intPackageFailureTotal++;
                        m_blnFailCounterAdded = true;
                        m_blnTotalCounterAdded = false;

                    }
                    if (blnAuto)
                    {
                        if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                            if (m_intTCPIPResultID == -1)
                                SetPackageResultID(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailResultMask);
                    }
                    return false;
                }
                fGaugeCenterX = m_objGauge_PkgSideView.ref_pRectCenterPoint.X;
                fGaugeCenterY = m_objGauge_PkgSideView.ref_pRectCenterPoint.Y;
                fGaugeWidth = m_objGauge_PkgSideView.ref_fRectWidth;
                fGaugeHeight = m_objGauge_PkgSideView.ref_fRectHeight;
                fGaugeAngle = m_objGauge_PkgSideView.ref_fRectAngle;
            }
            else
            {
                //WaitEventDone(ref m_bPackageSizeTestDone, true);
                //fGaugeCenterX = m_smVisionInfo.g_objGauge_PkgSize.ref_ObjectCenterX;
                //fGaugeCenterY = m_smVisionInfo.g_objGauge_PkgSize.ref_ObjectCenterY;
                //fGaugeWidth = m_smVisionInfo.g_objGauge_PkgSize.ref_ObjectWidth;
                //fGaugeHeight = m_smVisionInfo.g_objGauge_PkgSize.ref_ObjectHeight;
                //fGaugeAngle = m_smVisionInfo.g_objGauge_PkgSize.ref_ObjectAngle;

                if (intUnitNo == 0)
                    WaitEventDone(ref m_bPackageSizeTestDone1, true, 10000, "StartPackageTest_SideLightView_WithoutRotate > m_bPackageSizeTestDone1 6844");
                else
                    WaitEventDone(ref m_bPackageSizeTestDone2, true, 10000, "StartPackageTest_SideLightView_WithoutRotate > m_bPackageSizeTestDone2 6846");
                if (intUnitNo == 0)
                {
                    fGaugeCenterX = m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X;
                    fGaugeCenterY = m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y;
                    fGaugeWidth = m_smVisionInfo.g_objGauge_PkgSize.ref_fRectWidth;
                    fGaugeHeight = m_smVisionInfo.g_objGauge_PkgSize.ref_fRectHeight;
                    fGaugeAngle = m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle;
                }
                else
                {
                    fGaugeCenterX = m_smVisionInfo.g_objGauge_PkgSize2.ref_pRectCenterPoint.X;
                    fGaugeCenterY = m_smVisionInfo.g_objGauge_PkgSize2.ref_pRectCenterPoint.Y;
                    fGaugeWidth = m_smVisionInfo.g_objGauge_PkgSize2.ref_fRectWidth;
                    fGaugeHeight = m_smVisionInfo.g_objGauge_PkgSize2.ref_fRectHeight;
                    fGaugeAngle = m_smVisionInfo.g_objGauge_PkgSize2.ref_fRectAngle;
                }
            }

            float fTotalRotateAngle = m_intOrientAngle + fGaugeAngle;
            float fTotalRotateMarkAngle;
            if (m_smVisionInfo.g_arrMarks[intUnitNo].ref_blnCheckMark)
            {
                fTotalRotateMarkAngle = m_intOrientAngle + m_smVisionInfo.g_arrOrients[intUnitNo][m_smVisionInfo.g_intSelectedOcv[0]].ref_fDegAngleResult;
            }
            else
            {
                fTotalRotateMarkAngle = fTotalRotateAngle;
            }

            // 2019 06 08 - CCENG: Add this 0.5 formula to make sure ROI attahced to image in the best way
            float fCenterX, fCenterY;
            if ((m_smVisionInfo.g_arrPackageROIs[intUnitNo][0].ref_ROIWidth % 2) == 0)
                fCenterX = (float)Math.Round(fGaugeCenterX, 0, MidpointRounding.AwayFromZero);
            else
                fCenterX = (float)Math.Floor(fGaugeCenterX) + 0.5f;

            if ((m_smVisionInfo.g_arrPackageROIs[intUnitNo][0].ref_ROIHeight % 2) == 0)
                fCenterY = (float)Math.Round(fGaugeCenterY, 0, MidpointRounding.AwayFromZero);
            else
                fCenterY = (float)Math.Floor(fGaugeCenterY) + 0.5f;

            m_objSubTh2_RotateROI.LoadROISetting(
                        (int)Math.Round(fCenterX -
                        (float)m_smVisionInfo.g_arrPackageROIs[intUnitNo][0].ref_ROIWidth / 2, 0, MidpointRounding.AwayFromZero),
                        (int)Math.Round(fCenterY -
                        (float)m_smVisionInfo.g_arrPackageROIs[intUnitNo][0].ref_ROIHeight / 2, 0, MidpointRounding.AwayFromZero),
                        m_smVisionInfo.g_arrPackageROIs[intUnitNo][0].ref_ROIWidth,
                        m_smVisionInfo.g_arrPackageROIs[intUnitNo][0].ref_ROIHeight);

            // Rotate image
            if (intSideLightViewImageIndex == 0)
            {
                /* 2019 07 14 - CCENG: 
                 * if g_blnWantGauge is false, mean Image 1 is rotated according to Orient Matching Angle, which is not 100% correct,
                 * because the Orient Matching Angle and Unit Angle may be different.
                 * So when come to Image 1 package size test, Image 1 need to be re-rotated  according to Package size result angle.
                 */
                //if (m_smVisionInfo.g_blnWantGauge)
                //{
                //    // Wait StartOrientTest rotate image 1 done or mark test done. (sometime rotate image 1 done will not set to true if Orient fail).
                //    WaitEventDone(ref m_blnRotateImage1Updated, ref m_bSubTh_MarkTest, true, false);
                //}
                //else
                //{
                //    // Since Mark Test Image index and side light package view image index are same, then need to Wait for Marktest done because Rotated image need to be tested by mark inspection function. After mark inspection, then only allow to re-rotate again using packge angle.
                //    WaitEventDone(ref m_bSubTh_MarkTest, false);

                //    if (!m_bSubTh_MarkTest_Result)
                //    {
                //        return false;   // Skip package inspection if mark test fail.
                //    }

                //    m_objSubTh2_RotateROI.AttachImage(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex]);
                //    ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex], m_objSubTh2_RotateROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_PkgBright, ref m_smVisionInfo.g_arrRotatedImages, intSideLightViewImageIndex);
                //}

            }
            else
            {
                // Rotate imgae 2
                //m_objSubTh2_RotateROI.AttachImage(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex]);
                //ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex], m_objSubTh2_RotateROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_PkgBright, ref m_smVisionInfo.g_arrRotatedImages, intSideLightViewImageIndex);
            }

            if (intSideLightViewImageIndex == 0)
                m_blnRotateImage1Updated = true;
            else if (intSideLightViewImageIndex == 1)
                m_blnRotateImage2Updated = true;
            else if (intSideLightViewImageIndex == 2)
                m_blnRotateImage3Updated = true;
            else if (intSideLightViewImageIndex == 3)
                m_blnRotateImage4Updated = true;
            else if (intSideLightViewImageIndex == 4)
                m_blnRotateImage5Updated = true;
            else if (intSideLightViewImageIndex == 5)
                m_blnRotateImage6Updated = true;
            else
                m_blnRotateImage7Updated = true;

            // 2020-06-18 ZJYEOH : If not same image selected, need rotate another image
            if (intSideLightViewImageIndex != intSideLightViewImageIndex_DarkField2 && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateDarkField2DefectSetting
                || intSideLightViewImageIndex != intSideLightViewImageIndex_DarkField3 && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateDarkField3DefectSetting
                || intSideLightViewImageIndex != intSideLightViewImageIndex_DarkField4 && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateDarkField4DefectSetting)
            {
                if (intSideLightViewImageIndex_DarkField2 == 0 || intSideLightViewImageIndex_DarkField3 == 0 || intSideLightViewImageIndex_DarkField4 == 0)
                {
                    /* 2019 07 14 - CCENG: 
                     * if g_blnWantGauge is false, mean Image 1 is rotated according to Orient Matching Angle, which is not 100% correct,
                     * because the Orient Matching Angle and Unit Angle may be different.
                     * So when come to Image 1 package size test, Image 1 need to be re-rotated  according to Package size result angle.
                     */
                    //if (m_smVisionInfo.g_blnWantGauge)
                    //{
                    //    // Wait StartOrientTest rotate image 1 done or mark test done. (sometime rotate image 1 done will not set to true if Orient fail).
                    //    WaitEventDone(ref m_blnRotateImage1Updated, ref m_bSubTh_MarkTest, true, false);
                    //}
                    //else
                    //{
                    //    // Since Mark Test Image index and side light package view image index are same, then need to Wait for Marktest done because Rotated image need to be tested by mark inspection function. After mark inspection, then only allow to re-rotate again using packge angle.
                    //    WaitEventDone(ref m_bSubTh_MarkTest, false);

                    //    if (!m_bSubTh_MarkTest_Result)
                    //    {
                    //        return false;   // Skip package inspection if mark test fail.
                    //    }

                    //    m_objSubTh2_RotateROI.AttachImage(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex_DarkField2]);
                    //    ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex_DarkField2], m_objSubTh2_RotateROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_PkgBright, ref m_smVisionInfo.g_arrRotatedImages, intSideLightViewImageIndex_DarkField2);
                    //}

                }
                else
                {
                    // Rotate imgae 2
                    //m_objSubTh2_RotateROI.AttachImage(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex_DarkField2]);
                    //ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex_DarkField2], m_objSubTh2_RotateROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_PkgBright, ref m_smVisionInfo.g_arrRotatedImages, intSideLightViewImageIndex_DarkField2);
                }

                if (m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateDarkField2DefectSetting)
                {
                    if (intSideLightViewImageIndex_DarkField2 == 0)
                        m_blnRotateImage1Updated = true;
                    else if (intSideLightViewImageIndex_DarkField2 == 1)
                        m_blnRotateImage2Updated = true;
                    else if (intSideLightViewImageIndex_DarkField2 == 2)
                        m_blnRotateImage3Updated = true;
                    else if (intSideLightViewImageIndex_DarkField2 == 3)
                        m_blnRotateImage4Updated = true;
                    else if (intSideLightViewImageIndex_DarkField2 == 4)
                        m_blnRotateImage5Updated = true;
                    else if (intSideLightViewImageIndex_DarkField2 == 5)
                        m_blnRotateImage6Updated = true;
                    else
                        m_blnRotateImage7Updated = true;
                }

                if (m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateDarkField3DefectSetting)
                {
                    if (intSideLightViewImageIndex_DarkField3 == 0)
                        m_blnRotateImage1Updated = true;
                    else if (intSideLightViewImageIndex_DarkField3 == 1)
                        m_blnRotateImage2Updated = true;
                    else if (intSideLightViewImageIndex_DarkField3 == 2)
                        m_blnRotateImage3Updated = true;
                    else if (intSideLightViewImageIndex_DarkField3 == 3)
                        m_blnRotateImage4Updated = true;
                    else if (intSideLightViewImageIndex_DarkField3 == 4)
                        m_blnRotateImage5Updated = true;
                    else if (intSideLightViewImageIndex_DarkField3 == 5)
                        m_blnRotateImage6Updated = true;
                    else
                        m_blnRotateImage7Updated = true;
                }

                if (m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateDarkField4DefectSetting)
                {
                    if (intSideLightViewImageIndex_DarkField4 == 0)
                        m_blnRotateImage1Updated = true;
                    else if (intSideLightViewImageIndex_DarkField4 == 1)
                        m_blnRotateImage2Updated = true;
                    else if (intSideLightViewImageIndex_DarkField4 == 2)
                        m_blnRotateImage3Updated = true;
                    else if (intSideLightViewImageIndex_DarkField4 == 3)
                        m_blnRotateImage4Updated = true;
                    else if (intSideLightViewImageIndex_DarkField4 == 4)
                        m_blnRotateImage5Updated = true;
                    else if (intSideLightViewImageIndex_DarkField4 == 5)
                        m_blnRotateImage6Updated = true;
                    else
                        m_blnRotateImage7Updated = true;
                }

            }

            // 2020-12-18 ZJYEOH : If not same image selected, need rotate another image
            if ((intSideLightViewImageIndex != intMoldFlashViewImageIndex && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateMoldFlashDefectSetting) &&
                (intSideLightViewImageIndex_DarkField2 != intMoldFlashViewImageIndex && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateMoldFlashDefectSetting)
                && (intSideLightViewImageIndex_DarkField3 != intMoldFlashViewImageIndex && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateMoldFlashDefectSetting)
                && (intSideLightViewImageIndex_DarkField4 != intMoldFlashViewImageIndex && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateMoldFlashDefectSetting))
            {
                if (intMoldFlashViewImageIndex == 0)
                {
                    /* 2019 07 14 - CCENG: 
                     * if g_blnWantGauge is false, mean Image 1 is rotated according to Orient Matching Angle, which is not 100% correct,
                     * because the Orient Matching Angle and Unit Angle may be different.
                     * So when come to Image 1 package size test, Image 1 need to be re-rotated  according to Package size result angle.
                     */
                    //if (m_smVisionInfo.g_blnWantGauge)
                    //{
                    //    // Wait StartOrientTest rotate image 1 done or mark test done. (sometime rotate image 1 done will not set to true if Orient fail).
                    //    WaitEventDone(ref m_blnRotateImage1Updated, ref m_bSubTh_MarkTest, true, false);
                    //}
                    //else
                    //{
                    //    // Since Mark Test Image index and side light package view image index are same, then need to Wait for Marktest done because Rotated image need to be tested by mark inspection function. After mark inspection, then only allow to re-rotate again using packge angle.
                    //    WaitEventDone(ref m_bSubTh_MarkTest, false);

                    //    if (!m_bSubTh_MarkTest_Result)
                    //    {
                    //        return false;   // Skip package inspection if mark test fail.
                    //    }

                    //    m_objSubTh2_RotateROI.AttachImage(m_smVisionInfo.g_arrImages[intMoldFlashViewImageIndex]);
                    //    ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[intMoldFlashViewImageIndex], m_objSubTh2_RotateROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_PkgBright, ref m_smVisionInfo.g_arrRotatedImages, intMoldFlashViewImageIndex);
                    //}

                }
                else
                {
                    // Rotate imgae 2
                    //m_objSubTh2_RotateROI.AttachImage(m_smVisionInfo.g_arrImages[intMoldFlashViewImageIndex]);
                    //ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[intMoldFlashViewImageIndex], m_objSubTh2_RotateROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_PkgBright, ref m_smVisionInfo.g_arrRotatedImages, intMoldFlashViewImageIndex);
                }

                if (intMoldFlashViewImageIndex == 0)
                    m_blnRotateImage1Updated = true;
                else if (intMoldFlashViewImageIndex == 1)
                    m_blnRotateImage2Updated = true;
                else if (intMoldFlashViewImageIndex == 2)
                    m_blnRotateImage3Updated = true;
                else if (intMoldFlashViewImageIndex == 3)
                    m_blnRotateImage4Updated = true;
                else if (intMoldFlashViewImageIndex == 4)
                    m_blnRotateImage5Updated = true;
                else if (intMoldFlashViewImageIndex == 5)
                    m_blnRotateImage6Updated = true;
                else
                    m_blnRotateImage7Updated = true;

            }

            // Wait mark inspection done.
            if (intUnitNo == 0)
            {
                WaitEventDone(ref m_bMarkTestDone1, true, 10000, "StartPackageTest_SideLightView_WithoutRotate > m_bMarkTestDone1 7058");    //m_bSubTh_MarkTest,false// need to wait for mark inspection done. Because package size fail should not display error msg if mark fail.
                if (!m_bSubTh_MarkTest_Result)
                {
                    return false;   // Skip package counter if mark fail because counter will add to mark
                }
            }
            else
            {
                WaitEventDone(ref m_bMarkTestDone2, true, 10000, "StartPackageTest_SideLightView_WithoutRotate > m_bMarkTestDone2 7066");    //m_bSubTh_MarkTest,false// need to wait for mark inspection done. Because package size fail should not display error msg if mark fail.
                if (!m_bSubTh_MarkTest_Result2)
                {
                    return false;   // Skip package counter if mark fail because counter will add to mark
                }
            }

            // Wait package test done under mark light view 
            WaitEventDone(ref m_bSubTh_PackageTest_MarkLightView, false, 10000, "StartPackageTest_SideLightView_WithoutRotate > m_bSubTh_PackageTest_MarkLightView 7074");
            if (intUnitNo == 0)
            {
                if (!m_bSubTh_PackageTest_MarkLightView_Result)
                {
                    return false;
                }
            }
            else
            {
                if (!m_bSubTh_PackageTest_MarkLightView_Result2)
                {
                    return false;
                }
            }
            // --------- Get image index for : package -----------------
            m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnViewUnitPosition = true;

            //m_smVisionInfo.g_arrPackage[intUnitNo].ClearDontCareAreaArray();//2020-12-28 ZJYEOH : Only StartPackageTest_MarkLightView will use this dont care

            // ------- Copy image to temporary inspection image
            if (intSideLightViewImageIndex >= 0)
            {
                if (m_objPkgViewImage == null)
                    m_objPkgViewImage = new ImageDrawing(true);

                if (blnWantDebug)
                {
                    m_smVisionInfo.g_arrRotatedImages[intSideLightViewImageIndex].SaveImage("D:\\TS\\3.RotateImage.bmp");
                }

                //m_smVisionInfo.g_arrRotatedImages[intSideLightViewImageIndex].CopyTo(ref m_objPkgViewImage);
                // 2020 07 11 - CCENG: need to rotate to mark 0 deg first in order to mask dont care the marking area before proceed for package inspection.
                //            - Why cannot mask dont care mark without mark 0 deg. 
                //              > because currently ocv do inspection when mark is in 0 deg.
                //              > also our mark template is in 0 deg also. If want to mask dont care without mark 0 deg, 
                //                then dont mark template need to rotate to sample mark angle before masking dont care. 
                //ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex], m_objSubTh2_RotateROI, fTotalRotateMarkAngle, m_smVisionInfo.g_intRotationInterpolation_PkgBright, ref m_objPkgViewImage);
                m_smVisionInfo.g_arrImages[intSideLightViewImageIndex].CopyTo(ref m_objPkgViewImage);
                if (blnWantDebug)
                {
                    m_objPkgViewImage.SaveImage("D:\\TS\\0.m_objPkgViewImage.bmp");
                }

            }
            else if (m_objPkgViewImage != null)
                m_objPkgViewImage = null;


            if (intSideLightViewImageIndex_DarkField2 >= 0)
            {
                if (m_objPkgViewImage_DarkField2 == null)
                    m_objPkgViewImage_DarkField2 = new ImageDrawing(true);

                if (intSideLightViewImageIndex != intSideLightViewImageIndex_DarkField2 && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateDarkField2DefectSetting)
                {
                    // 2020-11-07 ZJYEOH : Need to rotate using mark angle because later will subtract mark char area
                    //m_objSubTh2_RotateROI.AttachImage(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex_DarkField2]);
                    //ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex_DarkField2], m_objSubTh2_RotateROI, fTotalRotateMarkAngle, m_smVisionInfo.g_intRotationInterpolation_PkgBright, ref m_objPkgViewImage_DarkField2);
                    m_smVisionInfo.g_arrImages[intSideLightViewImageIndex_DarkField2].CopyTo(ref m_objPkgViewImage_DarkField2);
                }
                else
                {
                    m_objPkgViewImage.CopyTo(ref m_objPkgViewImage_DarkField2);
                }
            }
            else if (m_objPkgViewImage_DarkField3 != null)
                m_objPkgViewImage_DarkField3 = null;


            if (intSideLightViewImageIndex_DarkField3 >= 0)
            {
                if (m_objPkgViewImage_DarkField3 == null)
                    m_objPkgViewImage_DarkField3 = new ImageDrawing(true);

                if (intSideLightViewImageIndex != intSideLightViewImageIndex_DarkField3 && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateDarkField3DefectSetting)
                {
                    // 2020-11-07 ZJYEOH : Need to rotate using mark angle because later will subtract mark char area
                    //m_objSubTh2_RotateROI.AttachImage(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex_DarkField3]);
                    //ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex_DarkField3], m_objSubTh2_RotateROI, fTotalRotateMarkAngle, m_smVisionInfo.g_intRotationInterpolation_PkgBright, ref m_objPkgViewImage_DarkField3);
                    m_smVisionInfo.g_arrImages[intSideLightViewImageIndex_DarkField3].CopyTo(ref m_objPkgViewImage_DarkField3);
                }
                else
                {
                    m_objPkgViewImage.CopyTo(ref m_objPkgViewImage_DarkField3);
                }
            }
            else if (m_objPkgViewImage_DarkField3 != null)
                m_objPkgViewImage_DarkField3 = null;


            if (intSideLightViewImageIndex_DarkField4 >= 0)
            {
                if (m_objPkgViewImage_DarkField4 == null)
                    m_objPkgViewImage_DarkField4 = new ImageDrawing(true);

                if (intSideLightViewImageIndex != intSideLightViewImageIndex_DarkField4 && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateDarkField4DefectSetting)
                {
                    // 2020-11-07 ZJYEOH : Need to rotate using mark angle because later will subtract mark char area
                    //m_objSubTh2_RotateROI.AttachImage(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex_DarkField4]);
                    //ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex_DarkField4], m_objSubTh2_RotateROI, fTotalRotateMarkAngle, m_smVisionInfo.g_intRotationInterpolation_PkgBright, ref m_objPkgViewImage_DarkField4);
                    m_smVisionInfo.g_arrImages[intSideLightViewImageIndex_DarkField4].CopyTo(ref m_objPkgViewImage_DarkField4);
                }
                else
                {
                    m_objPkgViewImage.CopyTo(ref m_objPkgViewImage_DarkField4);
                }
            }
            else if (m_objPkgViewImage_DarkField4 != null)
                m_objPkgViewImage_DarkField4 = null;


            if (intMoldFlashViewImageIndex >= 0)
            {
                if (m_objMoldViewImage == null)
                    m_objMoldViewImage = new ImageDrawing(true);

                if ((intSideLightViewImageIndex != intMoldFlashViewImageIndex && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateMoldFlashDefectSetting) &&
                    (intSideLightViewImageIndex_DarkField2 != intMoldFlashViewImageIndex && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateMoldFlashDefectSetting)
                    && (intSideLightViewImageIndex_DarkField3 != intMoldFlashViewImageIndex && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateMoldFlashDefectSetting)
                    && (intSideLightViewImageIndex_DarkField4 != intMoldFlashViewImageIndex && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateMoldFlashDefectSetting))
                {
                    // 2020-11-07 ZJYEOH : Need to rotate using mark angle because later will subtract mark char area
                    //m_objSubTh2_RotateROI.AttachImage(m_smVisionInfo.g_arrImages[intMoldFlashViewImageIndex]);
                    //ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[intMoldFlashViewImageIndex], m_objSubTh2_RotateROI, fTotalRotateMarkAngle, m_smVisionInfo.g_intRotationInterpolation_PkgBright, ref m_objPkgMoldFlashViewImage);
                    m_smVisionInfo.g_arrImages[intMoldFlashViewImageIndex].CopyTo(ref m_objMoldViewImage);
                }
                else
                {
                    if (intSideLightViewImageIndex == intMoldFlashViewImageIndex)
                        m_objPkgViewImage.CopyTo(ref m_objMoldViewImage);
                    else if (intSideLightViewImageIndex_DarkField2 == intMoldFlashViewImageIndex)
                        m_objPkgViewImage_DarkField2.CopyTo(ref m_objMoldViewImage);
                    else if (intSideLightViewImageIndex_DarkField3 == intMoldFlashViewImageIndex)
                        m_objPkgViewImage_DarkField3.CopyTo(ref m_objMoldViewImage);
                    else if (intSideLightViewImageIndex_DarkField4 == intMoldFlashViewImageIndex)
                        m_objPkgViewImage_DarkField4.CopyTo(ref m_objMoldViewImage);
                    else
                        m_objPkgViewImage.CopyTo(ref m_objMoldViewImage);
                }
            }
            else if (m_objMoldViewImage != null)
                m_objMoldViewImage = null;

            if (intSideLightViewImageIndex >= 0)
            {
                if (m_objChippedViewImage == null)
                    m_objChippedViewImage = new ImageDrawing(true);
                m_smVisionInfo.g_arrImages[intSideLightViewImageIndex].CopyTo(ref m_objChippedViewImage);
            }
            else if (m_objChippedViewImage != null)
                m_objChippedViewImage = null;

            //if (intSideLightViewImageIndex >= 0)
            //{
            //    if (m_objMoldViewImage == null)
            //        m_objMoldViewImage = new ImageDrawing(true);
            //    m_smVisionInfo.g_arrImages[intSideLightViewImageIndex].CopyTo(ref m_objMoldViewImage);
            //}
            //else if (m_objMoldViewImage != null)
            //    m_objMoldViewImage = null;

            bool blnWantMark = false;
            int intCharDilateHalfWidth = 2;
            if (m_smVisionInfo.g_arrMarks != null && m_smVisionInfo.g_arrMarks.Count > 0)
            {
                // 2020 04 15 - JBTAN: will continue to check mark even option uncheck check mark option
                // 2020 07 08 - Roll back to previous method, wont check mark if Mark Checking is not selected.
                blnWantMark = m_smVisionInfo.g_arrMarks[intUnitNo].ref_blnCheckMark;
                //blnWantMark = true;
                intCharDilateHalfWidth = m_smVisionInfo.g_arrMarks[intUnitNo].ref_intCharDilateHalfWidth; // thick iteration
            }

            //2020-05-18 ZJYEOH : Get another Image without subtract mark area
            //2020-05-18 ZJYEOH : Get another Image without subtract mark area
            if (m_smVisionInfo.g_intPackageDefectInspectionMethod != 0)
            {
                m_objPkgViewImage.CopyTo(ref m_objGrayValueImage_SideLight);
            }

            if (blnWantMark)
            {
                // ---------- Fill Mark Image's mark area with black color -------------------
                int intNumChars = m_smVisionInfo.g_arrMarks[intUnitNo].GetNumChars();
                int intStartX = 0, intStartY = 0, intEndX = 0, intEndY = 0;

                int intOffsetX;
                int intOffsetY;

                if (m_smVisionInfo.g_blnWantGauge)  // Mean during mark inspection, orient gauge is used to measure unit position for m_objMarkTrainROI
                {
                    if (intUnitNo == 0)
                    {
                        intOffsetX = m_objMarkTrainROI.ref_ROITotalX;
                        intOffsetY = m_objMarkTrainROI.ref_ROITotalY;
                    }
                    else
                    {
                        intOffsetX = m_pMarkTrainROIPoint_Unit2.X;
                        intOffsetY = m_pMarkTrainROIPoint_Unit2.Y;
                    }
                }
                else if (m_smVisionInfo.g_arrMarkROIs[intUnitNo].Count > 3)    // Mean during mark inspection, Unit PR is used to find unit surface position for m_objMarkTrainROI
                {
                    if (intUnitNo == 0)
                    {
                        intOffsetX = m_objMarkTrainROI.ref_ROITotalX;
                        intOffsetY = m_objMarkTrainROI.ref_ROITotalY;
                    }
                    else
                    {
                        intOffsetX = m_pMarkTrainROIPoint_Unit2.X;
                        intOffsetY = m_pMarkTrainROIPoint_Unit2.Y;
                    }
                }
                else // Mean during mark inspection, m_objMarkSearchROI is used.
                {
                    if (intUnitNo == 0)
                    {
                        intOffsetX = m_objMarkTrainROI.ref_ROITotalX;
                        intOffsetY = m_objMarkTrainROI.ref_ROITotalY;
                    }
                    else
                    {
                        intOffsetX = m_pMarkTrainROIPoint_Unit2.X;
                        intOffsetY = m_pMarkTrainROIPoint_Unit2.Y;
                    }
                }

                for (int i = 0; i < intNumChars; i++)
                {
                    int intRectStartX, intRectStartY, intRectEndX, intRectEndY;
                    intRectStartX = intRectStartY = intRectEndX = intRectEndY = 0;
                    m_smVisionInfo.g_arrMarks[intUnitNo].GetCharStartXY(i, ref intStartX, ref intStartY);
                    m_smVisionInfo.g_arrMarks[intUnitNo].GetCharEndXY(i, ref intEndX, ref intEndY);

                    if (m_smVisionInfo.g_arrMarks[intUnitNo].ref_blnWantDontCareIgnoredMarkWholeArea && !m_smVisionInfo.g_arrMarks[intUnitNo].GetEnableMarkSetting(i))
                    {
                        //2021-01-18 ZJYEOH : Should use sample position
                        Point pStartTemplate = new Point(intStartX, intStartY);//m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharROIStartPoint(i);
                        Point pEndTemplate = new Point(intEndX, intEndY);//m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharROIEndPoint(i);

                        if ((intOffsetX + pStartTemplate.X - m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftX(i)) >= 0)
                            intRectStartX = intOffsetX + pStartTemplate.X - m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftX(i);
                        else
                            intRectStartX = intOffsetX;

                        if ((intOffsetY + pStartTemplate.Y - m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftY(i)) >= 0)
                            intRectStartY = intOffsetY + pStartTemplate.Y - m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftY(i);
                        else
                            intRectStartY = intOffsetY;

                        if ((intOffsetX + pEndTemplate.X + m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftX(i)) < m_smVisionInfo.g_intCameraResolutionWidth)
                            intRectEndX = intOffsetX + pEndTemplate.X + m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftX(i);
                        else
                            continue;
                        if ((intOffsetY + pEndTemplate.Y + m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftY(i)) < m_smVisionInfo.g_intCameraResolutionHeight)
                            intRectEndY = intOffsetY + pEndTemplate.Y + m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftY(i);
                        else
                            continue;
                    }
                    else
                    {
                        if ((intStartX - intCharDilateHalfWidth) >= 0)
                            intRectStartX = intOffsetX + intStartX - intCharDilateHalfWidth;
                        else
                            intRectStartX = intOffsetX;

                        if ((intStartY - intCharDilateHalfWidth) >= 0)
                            intRectStartY = intOffsetY + intStartY - intCharDilateHalfWidth;
                        else
                            intRectStartY = intOffsetY;

                        if ((intEndX + intCharDilateHalfWidth) < m_smVisionInfo.g_intCameraResolutionWidth)
                            intRectEndX = intOffsetX + intEndX + intCharDilateHalfWidth;
                        else
                            intRectEndX = intOffsetX + intEndX;

                        if ((intEndY + intCharDilateHalfWidth) < m_smVisionInfo.g_intCameraResolutionHeight)
                            intRectEndY = intOffsetY + intEndY + intCharDilateHalfWidth;
                        else
                            intRectEndY = intOffsetY + intEndY;
                    }

                    // 2020 02 27 - Fill rectangle whole bar if it is Bar.
                    if (m_smVisionInfo.g_arrMarks[intUnitNo].ref_blnWantCheckBarPin1)
                    {
                        if (m_smVisionInfo.g_arrMarks[intUnitNo].GetCharIsBarPin1(m_smVisionInfo.g_arrMarks[intUnitNo].ref_intGroupIndex,
                                                                                  m_smVisionInfo.g_arrMarks[intUnitNo].ref_intTemplateIndex,
                                                                                  i))
                        {
                            if (m_smVisionInfo.g_arrMarks[intUnitNo].GetCharBarPin1Type(m_smVisionInfo.g_arrMarks[intUnitNo].ref_intGroupIndex,
                                                                                  m_smVisionInfo.g_arrMarks[intUnitNo].ref_intTemplateIndex,
                                                                                  i) == 0)
                            {
                                // vertical bar
                                //if (intRectStartY > m_objMarkTrainROI.ref_ROITotalY)
                                //    intRectStartY = m_objMarkTrainROI.ref_ROITotalY;
                                //if (intRectEndY < m_objMarkTrainROI.ref_ROITotalY + m_objMarkTrainROI.ref_ROIHeight)
                                //    intRectEndY = m_objMarkTrainROI.ref_ROITotalY + m_objMarkTrainROI.ref_ROIHeight;
                                if (intUnitNo == 0)
                                {
                                    intRectStartY = m_objMarkTrainROI.ref_ROITotalY;
                                    intRectEndY = m_objMarkTrainROI.ref_ROITotalY + m_objMarkTrainROI.ref_ROIHeight;
                                }
                                else
                                {
                                    intRectStartY = m_pMarkTrainROIPoint_Unit2.Y;
                                    intRectEndY = m_pMarkTrainROIPoint_Unit2.Y + m_sMarkTrainROISize_Unit2.Height;
                                }
                            }
                            else
                            {
                                // horizontal bar
                                //if (intRectStartX > m_objMarkTrainROI.ref_ROITotalX)
                                //    intRectStartX = m_objMarkTrainROI.ref_ROITotalX;
                                //if (intRectEndX < m_objMarkTrainROI.ref_ROITotalX + m_objMarkTrainROI.ref_ROIWidth)
                                //    intRectEndX = m_objMarkTrainROI.ref_ROITotalX + m_objMarkTrainROI.ref_ROIWidth;
                                if (intUnitNo == 0)
                                {
                                    intRectStartX = m_objMarkTrainROI.ref_ROITotalX;
                                    intRectEndX = m_objMarkTrainROI.ref_ROITotalX + m_objMarkTrainROI.ref_ROIWidth;
                                }
                                else
                                {
                                    intRectStartX = m_pMarkTrainROIPoint_Unit2.X;
                                    intRectEndX = m_pMarkTrainROIPoint_Unit2.X + m_sMarkTrainROISize_Unit2.Width;
                                }
                            }

                        }
                    }

                    if (blnWantDebug)
                    {
                        m_objPkgViewImage.SaveImage("D:\\TS\\1.m_objPkgViewImage" + i.ToString() + ".bmp");
                    }

                    float newSX = 0, newSY = 0, newEX = 0, newEY = 0;
                    Math2.GetNewXYAfterRotate_360deg((intRectEndX + intRectStartX) / 2, (intRectEndY + intRectStartY) / 2, intRectStartX, intRectStartY, -(fTotalRotateMarkAngle), ref newSX, ref newSY);

                    Math2.GetNewXYAfterRotate_360deg((intRectEndX + intRectStartX) / 2, (intRectEndY + intRectStartY) / 2, intRectEndX, intRectEndY, -(fTotalRotateMarkAngle), ref newEX, ref newEY);
                    Point pStart = new Point((int)Math.Round(newSX), (int)Math.Round(newSY));
                    Point pEnd = new Point((int)Math.Round(newEX), (int)Math.Round(newEY));

                    List<Point> arrPoints = new List<Point>();
                    arrPoints.Add(pStart);
                    arrPoints.Add(new Point(pStart.X + (pEnd.X - pStart.X), pStart.Y));
                    arrPoints.Add(pEnd);
                    arrPoints.Add(new Point(pStart.X, pStart.Y + (pEnd.Y - pStart.Y)));

                    if (intSideLightViewImageIndex >= 0)
                    {
                        //Shape.FillRectangle(m_objPkgViewImage, intRectStartX, intRectStartY, intRectEndX, intRectEndY, 0);
                        //Shape.FillPolygonWithScale(m_objPkgViewImage, arrPoints, 0, 1.0f, 1.0f, 0, 0); // 2020-11-16 ZJYEOH : Time consuming
                        DontCareWithoutRotateImage.ProduceImage(arrPoints, m_objPkgViewImage, m_smVisionInfo.g_objWhiteImage, m_smVisionInfo.g_objBlackImage, fTotalRotateMarkAngle, false);
                    }
                    if (blnWantDebug)
                    {
                        m_objPkgViewImage.SaveImage("D:\\TS\\2.m_objPkgViewImage" + i.ToString() + ".bmp");
                    }

                    // 2020-06-18 ZJYEOH : Fill white pixel on DarkField2 image
                    if (intSideLightViewImageIndex_DarkField2 >= 0 && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateDarkField2DefectSetting && !m_smVisionInfo.g_blnWantCheckVoidOnMarkArea_SideLight[0])
                    {
                        //Shape.FillRectangle(m_objPkgViewImage_DarkField2, intRectStartX, intRectStartY, intRectEndX, intRectEndY, 255);
                        //Shape.FillPolygonWithScale(m_objPkgViewImage_DarkField2, arrPoints, 255, 1.0f, 1.0f, 0, 0);
                        DontCareWithoutRotateImage.ProduceImage(arrPoints, m_objPkgViewImage_DarkField2, m_smVisionInfo.g_objWhiteImage, m_smVisionInfo.g_objBlackImage, fTotalRotateMarkAngle, true);
                    }

                    // 2020-12-18 ZJYEOH : Fill dark pixel on Mold Flash image
                    if (intSideLightViewImageIndex_DarkField2 >= 0 && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateMoldFlashDefectSetting)
                    {
                        DontCareWithoutRotateImage.ProduceImage(arrPoints, m_objMoldViewImage, m_smVisionInfo.g_objWhiteImage, m_smVisionInfo.g_objBlackImage, fTotalRotateMarkAngle, false);
                    }
                    else if (intSideLightViewImageIndex_DarkField3 >= 0 && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateMoldFlashDefectSetting)
                    {
                        DontCareWithoutRotateImage.ProduceImage(arrPoints, m_objMoldViewImage, m_smVisionInfo.g_objWhiteImage, m_smVisionInfo.g_objBlackImage, fTotalRotateMarkAngle, false);
                    }
                    else if (intSideLightViewImageIndex_DarkField4 >= 0 && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateMoldFlashDefectSetting)
                    {
                        DontCareWithoutRotateImage.ProduceImage(arrPoints, m_objMoldViewImage, m_smVisionInfo.g_objWhiteImage, m_smVisionInfo.g_objBlackImage, fTotalRotateMarkAngle, false);
                    }

                    if (intSideLightViewImageIndex_DarkField3 >= 0 && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateDarkField3DefectSetting && !m_smVisionInfo.g_blnWantCheckVoidOnMarkArea_SideLight[1])
                    {
                        DontCareWithoutRotateImage.ProduceImage(arrPoints, m_objPkgViewImage_DarkField3, m_smVisionInfo.g_objWhiteImage, m_smVisionInfo.g_objBlackImage, fTotalRotateMarkAngle, true);
                    }

                    if (intSideLightViewImageIndex_DarkField4 >= 0 && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateDarkField4DefectSetting && !m_smVisionInfo.g_blnWantCheckVoidOnMarkArea_SideLight[2])
                    {
                        DontCareWithoutRotateImage.ProduceImage(arrPoints, m_objPkgViewImage_DarkField4, m_smVisionInfo.g_objWhiteImage, m_smVisionInfo.g_objBlackImage, fTotalRotateMarkAngle, true);
                    }
                    //m_smVisionInfo.g_arrPackage[intUnitNo].SetDontCareArea(intRectStartX, intRectStartY, intRectEndX, intRectEndY);//2020-12-28 ZJYEOH : Only StartPackageTest_MarkLightView will use this dont care
                }

                //m_smVisionInfo.g_arrMarks[intUnitNo].DontCareOCVArea(m_objPkgViewImage, fTotalRotateMarkAngle, true);
            }

            if (blnWantDebug)
            {
                m_objPkgViewImage.SaveImage("D:\\TS\\3.m_objPkgViewImage.bmp");
            }


            //if (fTotalRotateMarkAngle != fTotalRotateAngle)
            //{
            //    // Rotate unit to package zero deg
            //    m_objSubTh2_RotateROI.AttachImage(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex]);
            //    ROI.Rotate0Degree(m_objSubTh2_RotateROI, fTotalRotateAngle - fTotalRotateMarkAngle, m_smVisionInfo.g_intRotationInterpolation_PkgBright, ref m_objPkgViewImage);
            //    if (intSideLightViewImageIndex != intSideLightViewImageIndex_DarkField2)
            //    {
            //        m_objSubTh2_RotateROI.AttachImage(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex_DarkField2]);
            //        ROI.Rotate0Degree(m_objSubTh2_RotateROI, fTotalRotateAngle - fTotalRotateMarkAngle, m_smVisionInfo.g_intRotationInterpolation_PkgBright, ref m_objPkgViewImage_DarkField2);
            //    }
            //    else
            //    {
            //        m_objPkgViewImage.CopyTo(ref m_objPkgViewImage_DarkField2);
            //    }
            //}

            if (blnWantDebug)
            {
                m_objPkgViewImage.SaveImage("D:\\TS\\4.m_objPkgViewImage.bmp");
            }

            if (intSideLightViewImageIndex >= 0)
            {
                if (m_objChippedViewImage == null)
                    m_objChippedViewImage = new ImageDrawing(true);
                m_objPkgViewImage.CopyTo(ref m_objChippedViewImage);
            }
            else if (m_objChippedViewImage != null)
                m_objChippedViewImage = null;

            //if (intSideLightViewImageIndex >= 0)
            //{
            //    if (m_objMoldViewImage == null)
            //        m_objMoldViewImage = new ImageDrawing(true);
            //    m_objPkgViewImage.CopyTo(ref m_objMoldViewImage);
            //}
            //else if (m_objMoldViewImage != null)
            //    m_objMoldViewImage = null;
            List<PointF> arrMoldROIPoints = new List<PointF>();
            ROI objMoldFlashROI = null; // Image 2 - MoldFlash ROI
            if (intMoldFlashViewImageIndex >= 0)
            {
                ImageDrawing objMoldTempImg = new ImageDrawing(true, m_objMoldViewImage.ref_intImageWidth, m_objMoldViewImage.ref_intImageHeight);
                m_objMoldViewImage.CopyTo(ref objMoldTempImg);
                objMoldFlashROI = new ROI();
                objMoldFlashROI.LoadROISetting((int)Math.Round((fGaugeCenterX -
                                             fGaugeWidth / 2 -
                                             m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeft_Mold), 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round((fGaugeCenterY -
                                             fGaugeHeight / 2 -
                                             m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdge_Mold), 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round(fGaugeWidth + m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromRight_Mold + m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeft_Mold, 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round(fGaugeHeight + m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdge_Mold + m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromBottom_Mold, 0, MidpointRounding.AwayFromZero));
                objMoldFlashROI.AttachImage(m_objMoldViewImage);
                if (m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateMoldFlashDefectSetting)
                {
                    objMoldFlashROI.LoadROISetting((int)Math.Round((fGaugeCenterX - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeftInner_Mold -
                                               fGaugeWidth / 2), 0, MidpointRounding.AwayFromZero),
                                               (int)Math.Round((fGaugeCenterY - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdgeInner_Mold -
                                               fGaugeHeight / 2), 0, MidpointRounding.AwayFromZero),
                                               (int)Math.Round(fGaugeWidth + m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromRightInner_Mold + m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeftInner_Mold, 0, MidpointRounding.AwayFromZero),
                                               (int)Math.Round(fGaugeHeight + m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdgeInner_Mold + m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromBottomInner_Mold, 0, MidpointRounding.AwayFromZero));

                    PointF pStart = new PointF(objMoldFlashROI.ref_ROITotalX, objMoldFlashROI.ref_ROITotalY);
                    PointF pEnd = new PointF(objMoldFlashROI.ref_ROITotalX + objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROITotalY + objMoldFlashROI.ref_ROIHeight);
                    List<PointF> arrPoints = new List<PointF>(); // 0:Top Left, 1: Top Right, 2:Bottom Left, 3:Bottom Right
                    arrPoints.Add(new PointF(pStart.X, pStart.Y));
                    arrPoints.Add(new PointF(pEnd.X, pStart.Y));
                    arrPoints.Add(new PointF(pStart.X, pEnd.Y));
                    arrPoints.Add(new PointF(pEnd.X, pEnd.Y));

                    //m_objMarkTrainROI.SaveImage("D:\\m_objMarkTrainROI1.bmp");

                    PointF pTemp = new PointF();
                    Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2,
                                                     (pEnd.Y + pStart.Y) / 2,
                                                     arrPoints[0],
                                                     (fGaugeAngle + (m_intOrientAngle)),
                                                     ref pTemp);
                    arrPoints[0] = pTemp;

                    Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2,
                                                     (pEnd.Y + pStart.Y) / 2,
                                                     arrPoints[1],
                                                     (fGaugeAngle + (m_intOrientAngle)),
                                                     ref pTemp);
                    arrPoints[1] = pTemp;

                    Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2,
                                                     (pEnd.Y + pStart.Y) / 2,
                                                     arrPoints[2],
                                                     (fGaugeAngle + (m_intOrientAngle)),
                                                     ref pTemp);
                    arrPoints[2] = pTemp;

                    Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2,
                                                     (pEnd.Y + pStart.Y) / 2,
                                                     arrPoints[3],
                                                     (fGaugeAngle + (m_intOrientAngle)),
                                                     ref pTemp);
                    arrPoints[3] = pTemp;

                    if ((fGaugeAngle + (m_intOrientAngle)) >= 0)
                    {
                        arrMoldROIPoints.Add(new PointF(arrPoints[0].X, arrPoints[1].Y));
                        arrMoldROIPoints.Add(new PointF(arrPoints[3].X, arrPoints[1].Y));
                        arrMoldROIPoints.Add(new PointF(arrPoints[0].X, arrPoints[2].Y));
                        arrMoldROIPoints.Add(new PointF(arrPoints[3].X, arrPoints[2].Y));
                    }
                    else
                    {
                        arrMoldROIPoints.Add(new PointF(arrPoints[2].X, arrPoints[0].Y));
                        arrMoldROIPoints.Add(new PointF(arrPoints[1].X, arrPoints[0].Y));
                        arrMoldROIPoints.Add(new PointF(arrPoints[2].X, arrPoints[3].Y));
                        arrMoldROIPoints.Add(new PointF(arrPoints[1].X, arrPoints[3].Y));
                    }
                    DontCareWithoutRotateImage.ProduceImageInner(arrPoints, objMoldFlashROI, m_objMoldViewImage
                        , m_smVisionInfo.g_objBlackWhiteTopImage, m_smVisionInfo.g_objBlackWhiteRightImage, m_smVisionInfo.g_objBlackWhiteBottomImage, m_smVisionInfo.g_objBlackWhiteLeftImage, false);
                    //m_objMoldViewImage.SaveImage("D:\\m_objMoldViewImage.bmp");
                    //objMoldFlashROI.SaveImage("D:\\objMoldFlashROI.bmp");
                    //ROI objTempROI = new ROI();
                    //objTempROI.LoadROISetting(objMoldFlashROI.ref_ROITotalX, objMoldFlashROI.ref_ROITotalY,
                    //                             objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                    //objTempROI.AttachImage(objMoldTempImg);
                    //ROI.SubtractROI2(objTempROI, objMoldFlashROI);
                    //objTempROI.SaveImage("D:\\objTempROI.bmp");
                    //objMoldFlashROI.SaveImage("D:\\objMoldFlashROIAfterSubtract.bmp");
                    //objTempROI.Dispose();

                    //m_objMoldViewImage.SaveImage("D:\\m_objMoldViewImageAfterSubtract.bmp");
                    objMoldFlashROI.LoadROISetting((int)Math.Round((fGaugeCenterX -
                                            fGaugeWidth / 2 -
                                            m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeft_Mold), 0, MidpointRounding.AwayFromZero),
                                            (int)Math.Round((fGaugeCenterY -
                                            fGaugeHeight / 2 -
                                            m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdge_Mold), 0, MidpointRounding.AwayFromZero),
                                            (int)Math.Round(fGaugeWidth + m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromRight_Mold + m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeft_Mold, 0, MidpointRounding.AwayFromZero),
                                            (int)Math.Round(fGaugeHeight + m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdge_Mold + m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromBottom_Mold, 0, MidpointRounding.AwayFromZero));

                    pStart = new PointF(objMoldFlashROI.ref_ROITotalX, objMoldFlashROI.ref_ROITotalY);
                    pEnd = new PointF(objMoldFlashROI.ref_ROITotalX + objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROITotalY + objMoldFlashROI.ref_ROIHeight);
                    arrPoints = new List<PointF>(); // 0:Top Left, 1: Top Right, 2:Bottom Left, 3:Bottom Right
                    arrPoints.Add(new PointF(pStart.X, pStart.Y));
                    arrPoints.Add(new PointF(pEnd.X, pStart.Y));
                    arrPoints.Add(new PointF(pStart.X, pEnd.Y));
                    arrPoints.Add(new PointF(pEnd.X, pEnd.Y));

                    pTemp = new PointF();
                    Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2,
                                                     (pEnd.Y + pStart.Y) / 2,
                                                     arrPoints[0],
                                                     (fGaugeAngle + (m_intOrientAngle)),
                                                     ref pTemp);
                    arrPoints[0] = pTemp;

                    Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2,
                                                     (pEnd.Y + pStart.Y) / 2,
                                                     arrPoints[1],
                                                     (fGaugeAngle + (m_intOrientAngle)),
                                                     ref pTemp);
                    arrPoints[1] = pTemp;

                    Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2,
                                                     (pEnd.Y + pStart.Y) / 2,
                                                     arrPoints[2],
                                                     (fGaugeAngle + (m_intOrientAngle)),
                                                     ref pTemp);
                    arrPoints[2] = pTemp;

                    Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2,
                                                     (pEnd.Y + pStart.Y) / 2,
                                                     arrPoints[3],
                                                     (fGaugeAngle + (m_intOrientAngle)),
                                                     ref pTemp);
                    arrPoints[3] = pTemp;

                    DontCareWithoutRotateImage.ProduceImage(arrPoints, objMoldFlashROI, m_objMoldViewImage
                        , m_smVisionInfo.g_objBlackWhiteTopImage, m_smVisionInfo.g_objBlackWhiteRightImage, m_smVisionInfo.g_objBlackWhiteBottomImage, m_smVisionInfo.g_objBlackWhiteLeftImage, false);
                    //m_objMoldViewImage.SaveImage("D:\\m_objMoldViewImage2.bmp");
                    //objMoldFlashROI.SaveImage("D:\\objMoldFlashROI2.bmp");
                }
                objMoldTempImg.Dispose();
            }

            ROI objPkgViewROI = null; // Image 2 - Package ROI
            if (intSideLightViewImageIndex >= 0)
            {
                objPkgViewROI = new ROI();
                objPkgViewROI.LoadROISetting((int)Math.Round((fGaugeCenterX -
                                             fGaugeWidth / 2 +
                                             m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeft), 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round((fGaugeCenterY -
                                             fGaugeHeight / 2 +
                                             m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdge), 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round(fGaugeWidth - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromRight - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeft, 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round(fGaugeHeight - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdge - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromBottom, 0, MidpointRounding.AwayFromZero));
                objPkgViewROI.AttachImage(m_objPkgViewImage);

                PointF pStart = new PointF(objPkgViewROI.ref_ROITotalX, objPkgViewROI.ref_ROITotalY);
                PointF pEnd = new PointF(objPkgViewROI.ref_ROITotalX + objPkgViewROI.ref_ROIWidth, objPkgViewROI.ref_ROITotalY + objPkgViewROI.ref_ROIHeight);
                List<PointF> arrPoints = new List<PointF>(); // 0:Top Left, 1: Top Right, 2:Bottom Left, 3:Bottom Right
                arrPoints.Add(new PointF(pStart.X, pStart.Y));
                arrPoints.Add(new PointF(pEnd.X, pStart.Y));
                arrPoints.Add(new PointF(pStart.X, pEnd.Y));
                arrPoints.Add(new PointF(pEnd.X, pEnd.Y));

                //m_objMarkTrainROI.SaveImage("D:\\m_objMarkTrainROI1.bmp");

                PointF pTemp = new PointF();
                Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2,
                                                 (pEnd.Y + pStart.Y) / 2,
                                                 arrPoints[0],
                                                 (fGaugeAngle + (m_intOrientAngle)),
                                                 ref pTemp);
                arrPoints[0] = pTemp;

                Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2,
                                                 (pEnd.Y + pStart.Y) / 2,
                                                 arrPoints[1],
                                                 (fGaugeAngle + (m_intOrientAngle)),
                                                 ref pTemp);
                arrPoints[1] = pTemp;

                Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2,
                                                 (pEnd.Y + pStart.Y) / 2,
                                                 arrPoints[2],
                                                 (fGaugeAngle + (m_intOrientAngle)),
                                                 ref pTemp);
                arrPoints[2] = pTemp;

                Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2,
                                                 (pEnd.Y + pStart.Y) / 2,
                                                 arrPoints[3],
                                                 (fGaugeAngle + (m_intOrientAngle)),
                                                 ref pTemp);
                arrPoints[3] = pTemp;

                DontCareWithoutRotateImage.ProduceImage(arrPoints, objPkgViewROI, m_objPkgViewImage
                    , m_smVisionInfo.g_objBlackWhiteTopImage, m_smVisionInfo.g_objBlackWhiteRightImage, m_smVisionInfo.g_objBlackWhiteBottomImage, m_smVisionInfo.g_objBlackWhiteLeftImage, false);
            }


            ROI objPkgViewROI_DarkField2 = null; // Dark Field 2 ROI
            if (intSideLightViewImageIndex_DarkField2 >= 0)
            {
                objPkgViewROI_DarkField2 = new ROI();
                objPkgViewROI_DarkField2.AttachImage(m_objPkgViewImage_DarkField2);
                objPkgViewROI_DarkField2.LoadROISetting((int)Math.Round((fGaugeCenterX -
                                             fGaugeWidth / 2 +
                                             m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeft_DarkField2), 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round((fGaugeCenterY -
                                             fGaugeHeight / 2 +
                                             m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdge_DarkField2), 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round(fGaugeWidth - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromRight_DarkField2 - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeft_DarkField2, 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round(fGaugeHeight - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdge_DarkField2 - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromBottom_DarkField2, 0, MidpointRounding.AwayFromZero));

                if (m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateDarkField2DefectSetting)
                {
                    PointF pStart = new PointF(objPkgViewROI_DarkField2.ref_ROITotalX, objPkgViewROI_DarkField2.ref_ROITotalY);
                    PointF pEnd = new PointF(objPkgViewROI_DarkField2.ref_ROITotalX + objPkgViewROI_DarkField2.ref_ROIWidth, objPkgViewROI_DarkField2.ref_ROITotalY + objPkgViewROI_DarkField2.ref_ROIHeight);
                    List<PointF> arrPoints = new List<PointF>(); // 0:Top Left, 1: Top Right, 2:Bottom Left, 3:Bottom Right
                    arrPoints.Add(new PointF(pStart.X, pStart.Y));
                    arrPoints.Add(new PointF(pEnd.X, pStart.Y));
                    arrPoints.Add(new PointF(pStart.X, pEnd.Y));
                    arrPoints.Add(new PointF(pEnd.X, pEnd.Y));

                    //m_objMarkTrainROI.SaveImage("D:\\m_objMarkTrainROI1.bmp");

                    PointF pTemp = new PointF();
                    Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2,
                                                     (pEnd.Y + pStart.Y) / 2,
                                                     arrPoints[0],
                                                     (fGaugeAngle + (m_intOrientAngle)),
                                                     ref pTemp);
                    arrPoints[0] = pTemp;

                    Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2,
                                                     (pEnd.Y + pStart.Y) / 2,
                                                     arrPoints[1],
                                                     (fGaugeAngle + (m_intOrientAngle)),
                                                     ref pTemp);
                    arrPoints[1] = pTemp;

                    Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2,
                                                     (pEnd.Y + pStart.Y) / 2,
                                                     arrPoints[2],
                                                     (fGaugeAngle + (m_intOrientAngle)),
                                                     ref pTemp);
                    arrPoints[2] = pTemp;

                    Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2,
                                                     (pEnd.Y + pStart.Y) / 2,
                                                     arrPoints[3],
                                                     (fGaugeAngle + (m_intOrientAngle)),
                                                     ref pTemp);
                    arrPoints[3] = pTemp;

                    DontCareWithoutRotateImage.ProduceImage(arrPoints, objPkgViewROI_DarkField2, m_objPkgViewImage_DarkField2
                        , m_smVisionInfo.g_objBlackWhiteTopImage, m_smVisionInfo.g_objBlackWhiteRightImage, m_smVisionInfo.g_objBlackWhiteBottomImage, m_smVisionInfo.g_objBlackWhiteLeftImage, true);
                }
            }


            ROI objPkgViewROI_DarkField3 = null; // Dark Field 2 ROI
            if (intSideLightViewImageIndex_DarkField3 >= 0)
            {
                objPkgViewROI_DarkField3 = new ROI();
                objPkgViewROI_DarkField3.AttachImage(m_objPkgViewImage_DarkField3);
                objPkgViewROI_DarkField3.LoadROISetting((int)Math.Round((fGaugeCenterX -
                                             fGaugeWidth / 2 +
                                             m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeft_DarkField3), 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round((fGaugeCenterY -
                                             fGaugeHeight / 2 +
                                             m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdge_DarkField3), 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round(fGaugeWidth - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromRight_DarkField3 - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeft_DarkField3, 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round(fGaugeHeight - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdge_DarkField3 - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromBottom_DarkField3, 0, MidpointRounding.AwayFromZero));

                if (m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateDarkField3DefectSetting)
                {
                    PointF pStart = new PointF(objPkgViewROI_DarkField3.ref_ROITotalX, objPkgViewROI_DarkField3.ref_ROITotalY);
                    PointF pEnd = new PointF(objPkgViewROI_DarkField3.ref_ROITotalX + objPkgViewROI_DarkField3.ref_ROIWidth, objPkgViewROI_DarkField3.ref_ROITotalY + objPkgViewROI_DarkField3.ref_ROIHeight);
                    List<PointF> arrPoints = new List<PointF>(); // 0:Top Left, 1: Top Right, 2:Bottom Left, 3:Bottom Right
                    arrPoints.Add(new PointF(pStart.X, pStart.Y));
                    arrPoints.Add(new PointF(pEnd.X, pStart.Y));
                    arrPoints.Add(new PointF(pStart.X, pEnd.Y));
                    arrPoints.Add(new PointF(pEnd.X, pEnd.Y));

                    //m_objMarkTrainROI.SaveImage("D:\\m_objMarkTrainROI1.bmp");

                    PointF pTemp = new PointF();
                    Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2,
                                                     (pEnd.Y + pStart.Y) / 2,
                                                     arrPoints[0],
                                                     (fGaugeAngle + (m_intOrientAngle)),
                                                     ref pTemp);
                    arrPoints[0] = pTemp;

                    Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2,
                                                     (pEnd.Y + pStart.Y) / 2,
                                                     arrPoints[1],
                                                     (fGaugeAngle + (m_intOrientAngle)),
                                                     ref pTemp);
                    arrPoints[1] = pTemp;

                    Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2,
                                                     (pEnd.Y + pStart.Y) / 2,
                                                     arrPoints[2],
                                                     (fGaugeAngle + (m_intOrientAngle)),
                                                     ref pTemp);
                    arrPoints[2] = pTemp;

                    Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2,
                                                     (pEnd.Y + pStart.Y) / 2,
                                                     arrPoints[3],
                                                     (fGaugeAngle + (m_intOrientAngle)),
                                                     ref pTemp);
                    arrPoints[3] = pTemp;

                    DontCareWithoutRotateImage.ProduceImage(arrPoints, objPkgViewROI_DarkField3, m_objPkgViewImage_DarkField3
                        , m_smVisionInfo.g_objBlackWhiteTopImage, m_smVisionInfo.g_objBlackWhiteRightImage, m_smVisionInfo.g_objBlackWhiteBottomImage, m_smVisionInfo.g_objBlackWhiteLeftImage, true);
                }
            }


            ROI objPkgViewROI_DarkField4 = null; // Dark Field 2 ROI
            if (intSideLightViewImageIndex_DarkField4 >= 0)
            {
                objPkgViewROI_DarkField4 = new ROI();
                objPkgViewROI_DarkField4.AttachImage(m_objPkgViewImage_DarkField4);
                objPkgViewROI_DarkField4.LoadROISetting((int)Math.Round((fGaugeCenterX -
                                             fGaugeWidth / 2 +
                                             m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeft_DarkField4), 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round((fGaugeCenterY -
                                             fGaugeHeight / 2 +
                                             m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdge_DarkField4), 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round(fGaugeWidth - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromRight_DarkField4 - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeft_DarkField4, 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round(fGaugeHeight - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdge_DarkField4 - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromBottom_DarkField4, 0, MidpointRounding.AwayFromZero));

                if (m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateDarkField4DefectSetting)
                {
                    PointF pStart = new PointF(objPkgViewROI_DarkField4.ref_ROITotalX, objPkgViewROI_DarkField4.ref_ROITotalY);
                    PointF pEnd = new PointF(objPkgViewROI_DarkField4.ref_ROITotalX + objPkgViewROI_DarkField4.ref_ROIWidth, objPkgViewROI_DarkField4.ref_ROITotalY + objPkgViewROI_DarkField4.ref_ROIHeight);
                    List<PointF> arrPoints = new List<PointF>(); // 0:Top Left, 1: Top Right, 2:Bottom Left, 3:Bottom Right
                    arrPoints.Add(new PointF(pStart.X, pStart.Y));
                    arrPoints.Add(new PointF(pEnd.X, pStart.Y));
                    arrPoints.Add(new PointF(pStart.X, pEnd.Y));
                    arrPoints.Add(new PointF(pEnd.X, pEnd.Y));

                    //m_objMarkTrainROI.SaveImage("D:\\m_objMarkTrainROI1.bmp");

                    PointF pTemp = new PointF();
                    Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2,
                                                     (pEnd.Y + pStart.Y) / 2,
                                                     arrPoints[0],
                                                     (fGaugeAngle + (m_intOrientAngle)),
                                                     ref pTemp);
                    arrPoints[0] = pTemp;

                    Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2,
                                                     (pEnd.Y + pStart.Y) / 2,
                                                     arrPoints[1],
                                                     (fGaugeAngle + (m_intOrientAngle)),
                                                     ref pTemp);
                    arrPoints[1] = pTemp;

                    Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2,
                                                     (pEnd.Y + pStart.Y) / 2,
                                                     arrPoints[2],
                                                     (fGaugeAngle + (m_intOrientAngle)),
                                                     ref pTemp);
                    arrPoints[2] = pTemp;

                    Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2,
                                                     (pEnd.Y + pStart.Y) / 2,
                                                     arrPoints[3],
                                                     (fGaugeAngle + (m_intOrientAngle)),
                                                     ref pTemp);
                    arrPoints[3] = pTemp;

                    DontCareWithoutRotateImage.ProduceImage(arrPoints, objPkgViewROI_DarkField4, m_objPkgViewImage_DarkField4
                        , m_smVisionInfo.g_objBlackWhiteTopImage, m_smVisionInfo.g_objBlackWhiteRightImage, m_smVisionInfo.g_objBlackWhiteBottomImage, m_smVisionInfo.g_objBlackWhiteLeftImage, true);
                }
            }

            List<PointF> arrChippedROIPoints = new List<PointF>();
            ROI objChipUnitROI = null; // Image 2 - Chip ROI
            if (intSideLightViewImageIndex >= 0)
            {
                objChipUnitROI = new ROI();
                //objChipUnitROI.LoadROISetting((int)Math.Round((fGaugeCenterX - fGaugeWidth / 2), 0, MidpointRounding.AwayFromZero),
                //                              (int)Math.Round((fGaugeCenterY - fGaugeHeight / 2), 0, MidpointRounding.AwayFromZero),
                //                              (int)Math.Round(fGaugeWidth, 0, MidpointRounding.AwayFromZero),
                //                              (int)Math.Round(fGaugeHeight, 0, MidpointRounding.AwayFromZero));
                objChipUnitROI.LoadROISetting((int)Math.Round((fGaugeCenterX - fGaugeWidth / 2) + m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelExtendFromLeft_Chip, 0, MidpointRounding.AwayFromZero),
                                        (int)Math.Round((fGaugeCenterY - fGaugeHeight / 2) + m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelExtendFromEdge_Chip, 0, MidpointRounding.AwayFromZero),
                                        (int)Math.Round(fGaugeWidth - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelExtendFromLeft_Chip - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelExtendFromRight_Chip, 0, MidpointRounding.AwayFromZero),
                                        (int)Math.Round(fGaugeHeight - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelExtendFromEdge_Chip - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelExtendFromBottom_Chip, 0, MidpointRounding.AwayFromZero));

                // Use pkg image for chip test as priority
                objChipUnitROI.AttachImage(m_objChippedViewImage);
                if (m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateChippedOffDefectSetting)
                {
                    PointF pStart = new PointF(objChipUnitROI.ref_ROITotalX, objChipUnitROI.ref_ROITotalY);
                    PointF pEnd = new PointF(objChipUnitROI.ref_ROITotalX + objChipUnitROI.ref_ROIWidth, objChipUnitROI.ref_ROITotalY + objChipUnitROI.ref_ROIHeight);
                    List<PointF> arrPoints = new List<PointF>(); // 0:Top Left, 1: Top Right, 2:Bottom Left, 3:Bottom Right
                    arrPoints.Add(new PointF(pStart.X, pStart.Y));
                    arrPoints.Add(new PointF(pEnd.X, pStart.Y));
                    arrPoints.Add(new PointF(pStart.X, pEnd.Y));
                    arrPoints.Add(new PointF(pEnd.X, pEnd.Y));


                    //m_objMarkTrainROI.SaveImage("D:\\m_objMarkTrainROI1.bmp");

                    PointF pTemp = new PointF();
                    Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2,
                                                     (pEnd.Y + pStart.Y) / 2,
                                                     arrPoints[0],
                                                     (fGaugeAngle + (m_intOrientAngle)),
                                                     ref pTemp);
                    arrPoints[0] = pTemp;
                    arrChippedROIPoints.Add(pTemp);

                    Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2,
                                                     (pEnd.Y + pStart.Y) / 2,
                                                     arrPoints[1],
                                                     (fGaugeAngle + (m_intOrientAngle)),
                                                     ref pTemp);
                    arrPoints[1] = pTemp;
                    arrChippedROIPoints.Add(pTemp);

                    Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2,
                                                     (pEnd.Y + pStart.Y) / 2,
                                                     arrPoints[2],
                                                     (fGaugeAngle + (m_intOrientAngle)),
                                                     ref pTemp);
                    arrPoints[2] = pTemp;
                    arrChippedROIPoints.Add(pTemp);

                    Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2,
                                                     (pEnd.Y + pStart.Y) / 2,
                                                     arrPoints[3],
                                                     (fGaugeAngle + (m_intOrientAngle)),
                                                     ref pTemp);
                    arrPoints[3] = pTemp;
                    arrChippedROIPoints.Add(pTemp);
                    //arrChippedROIPoints = arrPoints;
                    DontCareWithoutRotateImage.ProduceImage(arrPoints, objChipUnitROI, m_objChippedViewImage
                        , m_smVisionInfo.g_objBlackWhiteTopImage, m_smVisionInfo.g_objBlackWhiteRightImage, m_smVisionInfo.g_objBlackWhiteBottomImage, m_smVisionInfo.g_objBlackWhiteLeftImage, false);
                }
            }


            if (m_smVisionInfo.g_blnWantDontCareArea_Package)
            {
                if (intSideLightViewImageIndex >= 0)
                {
                    ////Draw don't care ROI edge to make sure Don't Care Area is not inspected
                    //for (int k = 3; k < m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit].Count; k++)
                    //{
                    //    m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][k].AttachImage(objPkgViewROI);
                    //    ROI objROI = new ROI();
                    //    objROI.LoadROISetting((int)Math.Round((fGaugeCenterX - fGaugeWidth / 2 + m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][k].ref_ROIPositionX), 0, MidpointRounding.AwayFromZero),
                    //                          (int)Math.Round((fGaugeCenterY - fGaugeHeight / 2 + m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][k].ref_ROIPositionY), 0, MidpointRounding.AwayFromZero),
                    //                           m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][k].ref_ROIWidth, m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][k].ref_ROIHeight);
                    //    objROI.AttachImage(m_smVisionInfo.g_objWhiteImage);
                    //    ROI.SubtractROI(m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][k], objROI);
                    //    //objPkgViewROI.SaveImage("D:\\aaa.bmp");
                    //    objROI.Dispose();
                    //}

                    ROI objDontCareROI = new ROI();
                    //objDontCareROI.LoadROISetting(0, 0, objPkgViewROI.ref_ROIWidth, objPkgViewROI.ref_ROIHeight);
                    // 2020 06 27 - CCENG: objDontCareROI have to start from Package Tolerance bcos g_objDontCareImage_Package_Bright template is start from Package Size Template.
                    objDontCareROI.LoadROISetting(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeft,
                                                  m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdge,
                                                  objPkgViewROI.ref_ROIWidth, objPkgViewROI.ref_ROIHeight);
                    objDontCareROI.AttachImage(m_smVisionInfo.g_objDontCareImage_Package_Bright);
                    //objDontCareROI.SaveImage("D:\\objDontCareROI1.bmp");
                    ImageDrawing objImgDontCare = new ImageDrawing(true, m_smVisionInfo.g_objDontCareImage_Package_Bright.ref_intImageWidth, m_smVisionInfo.g_objDontCareImage_Package_Bright.ref_intImageHeight);
                    ROI.Rotate0Degree_Better(m_smVisionInfo.g_objDontCareImage_Package_Bright, objDontCareROI, -fTotalRotateAngle, 4, ref objImgDontCare);
                    objDontCareROI.AttachImage(objImgDontCare);
                    //objDontCareROI.SaveImage("D:\\objDontCareROI12.bmp");
                    ROI.SubtractROI(objPkgViewROI, objDontCareROI);
                    //objPkgViewROI.SaveImage("D:\\aaa.bmp");
                    objDontCareROI.Dispose();
                    objImgDontCare.Dispose();
                }

                if (intMoldFlashViewImageIndex >= 0 && m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateMoldFlashDefectSetting)
                {
                    ImageDrawing objTempImg = new ImageDrawing(true, m_objMoldViewImage.ref_intImageWidth, m_objMoldViewImage.ref_intImageHeight);
                    ROI objWhiteROI = new ROI();
                    ROI objDontCareROI = new ROI();
                    ROI objOriROI = new ROI();
                    for (int i = 0; i < m_smVisionInfo.g_arrPackageMoldFlashDontCareROIs.Count; i++)
                    {
                        Point pStart = new Point((int)Math.Round(fCenterX - m_smVisionInfo.g_arrPackageMoldFlashDontCareROIs[i].ref_intStartOffsetX),
                                                 (int)Math.Round(fCenterY - m_smVisionInfo.g_arrPackageMoldFlashDontCareROIs[i].ref_intStartOffsetY));
                        Point pEnd = new Point((int)Math.Round(fCenterX - m_smVisionInfo.g_arrPackageMoldFlashDontCareROIs[i].ref_intStartOffsetX) + m_smVisionInfo.g_arrPackageMoldFlashDontCareROIs[i].ref_ROIWidth,
                                               (int)Math.Round(fCenterY - m_smVisionInfo.g_arrPackageMoldFlashDontCareROIs[i].ref_intStartOffsetY) + m_smVisionInfo.g_arrPackageMoldFlashDontCareROIs[i].ref_ROIHeight);

                        float newSX = 0, newSY = 0, newEX = 0, newEY = 0;
                        //Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2, pStart.X, pStart.Y, -(fGaugeAngle), ref newSX, ref newSY);

                        //Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2, pEnd.X, pEnd.Y, -(fGaugeAngle), ref newEX, ref newEY);
                        //pStart = new Point((int)Math.Round(newSX), (int)Math.Round(newSY));
                        //pEnd = new Point((int)Math.Round(newEX), (int)Math.Round(newEY));

                        List<Point> arrPoints = new List<Point>();
                        arrPoints.Add(pStart);
                        arrPoints.Add(new Point(pStart.X + (pEnd.X - pStart.X), pStart.Y));
                        arrPoints.Add(new Point(pStart.X, pStart.Y + (pEnd.Y - pStart.Y)));
                        arrPoints.Add(pEnd);

                        PointF pTemp = new PointF();
                        Math2.GetNewXYAfterRotate_360deg(fCenterX, fCenterY,
                                                         arrPoints[0],
                                                         (fGaugeAngle),
                                                         ref pTemp);
                        arrPoints[0] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

                        Math2.GetNewXYAfterRotate_360deg(fCenterX, fCenterY,
                                                         arrPoints[1],
                                                         (fGaugeAngle),
                                                         ref pTemp);
                        arrPoints[1] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

                        Math2.GetNewXYAfterRotate_360deg(fCenterX, fCenterY,
                                                        arrPoints[2],
                                                         (fGaugeAngle),
                                                         ref pTemp);
                        arrPoints[2] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

                        Math2.GetNewXYAfterRotate_360deg(fCenterX, fCenterY,
                                                        arrPoints[3],
                                                         (fGaugeAngle),
                                                         ref pTemp);
                        arrPoints[3] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

                        float fMinX = float.MaxValue;
                        float fMinY = float.MaxValue;
                        float fMaxX = 0;
                        float fMaxY = 0;
                        for (int a = 0; a < arrPoints.Count; a++)
                        {
                            if (fMinX > arrPoints[a].X)
                                fMinX = arrPoints[a].X;

                            if (fMinY > arrPoints[a].Y)
                                fMinY = arrPoints[a].Y;

                            if (fMaxX < arrPoints[a].X)
                                fMaxX = arrPoints[a].X;

                            if (fMaxY < arrPoints[a].Y)
                                fMaxY = arrPoints[a].Y;
                        }

                        objWhiteROI.AttachImage(m_smVisionInfo.g_objWhiteImage);

                        objOriROI.AttachImage(m_objMoldViewImage);

                        objDontCareROI.AttachImage(objTempImg);

                        objWhiteROI.LoadROISetting((int)Math.Round(fMinX), (int)Math.Round(fMinY),
                           (int)Math.Round(fMaxX - fMinX), (int)Math.Round(fMaxY - fMinY));

                        objOriROI.LoadROISetting((int)Math.Round(fMinX), (int)Math.Round(fMinY),
                           (int)Math.Round(fMaxX - fMinX), (int)Math.Round(fMaxY - fMinY));

                        objDontCareROI.LoadROISetting((int)Math.Round(fMinX), (int)Math.Round(fMinY),
                           (int)Math.Round(fMaxX - fMinX), (int)Math.Round(fMaxY - fMinY));

                        ROI.Rotate0Degree_ForDontCare(objWhiteROI, -(fGaugeAngle), 4, objDontCareROI);
                        //objDontCareROI.SaveImage("D:\\objDontCareROI" + i.ToString() + ".bmp");

                        //objOriROI.LoadROISetting((int)Math.Round(fCenterX - m_smVisionInfo.g_arrPackageMoldFlashDontCareROIs[i].ref_intStartOffsetX),
                        //                              (int)Math.Round(fCenterY - m_smVisionInfo.g_arrPackageMoldFlashDontCareROIs[i].ref_intStartOffsetY),
                        //                              m_smVisionInfo.g_arrPackageMoldFlashDontCareROIs[i].ref_ROIWidth, m_smVisionInfo.g_arrPackageMoldFlashDontCareROIs[i].ref_ROIHeight);

                        //objDontCareROI.LoadROISetting((int)Math.Round(fCenterX - m_smVisionInfo.g_arrPackageMoldFlashDontCareROIs[i].ref_intStartOffsetX),
                        //                              (int)Math.Round(fCenterY - m_smVisionInfo.g_arrPackageMoldFlashDontCareROIs[i].ref_intStartOffsetY),
                        //                              m_smVisionInfo.g_arrPackageMoldFlashDontCareROIs[i].ref_ROIWidth, m_smVisionInfo.g_arrPackageMoldFlashDontCareROIs[i].ref_ROIHeight);

                        ROI.SubtractROI(objOriROI, objDontCareROI);
                        //m_objMoldViewImage.SaveImage("D:\\m_objMoldViewImage.bmp");

                    }
                    objDontCareROI.Dispose();
                    objOriROI.Dispose();
                    objWhiteROI.Dispose();
                    objTempImg.Dispose();
                }
            }

            //objPkgViewROI.SaveImage("D:\\TS\\objPkgViewROI" + m_intTestCount.ToString() + ".bmp");
            //objChipUnitROI.SaveImage("D:\\TS\\objChipUnitROI" + m_intTestCount.ToString() + ".bmp");
            if (m_smVisionInfo.g_intPackageDefectInspectionMethod == 0)
            {
                if (!m_smVisionInfo.g_arrPackage[intUnitNo].DoInspection_SideLightView(//m_smVisionInfo.g_arrPackageGaugeM4L[intUnitNo],   // use to measure unit edge
                                                    fGaugeCenterX, fGaugeCenterY,
                                                    fGaugeWidth, fGaugeHeight,
                                                    objPkgViewROI,              // Package Test on second image
                                                    objChipUnitROI,             // Chipped off test on image 2
                                                    m_objPkgViewImage,         // Second package image (option)
                                                    objMoldFlashROI,
                                                    objPkgViewROI_DarkField2, // Dark field 2 ROI
                                                    objPkgViewROI_DarkField3,
                                                    objPkgViewROI_DarkField4,
                                                    arrChippedROIPoints,
                                                    m_smVisionInfo.g_objWhiteImage,
                                                    m_smVisionInfo.g_objBlackImage,
                                                    fGaugeAngle + (m_intOrientAngle),
                                                    arrMoldROIPoints,
                                                    m_smVisionInfo.g_objBlackWhiteTopImage, m_smVisionInfo.g_objBlackWhiteRightImage, m_smVisionInfo.g_objBlackWhiteBottomImage, m_smVisionInfo.g_objBlackWhiteLeftImage))
                {
                    if (intUnitNo == 1)
                    {
                        m_smVisionInfo.g_strErrorMessageForSecondUnit += GetUnitName(intUnitNo) + m_smVisionInfo.g_arrPackage[intUnitNo].ref_strErrorMessage;
                    }
                    else
                    {
                        m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + m_smVisionInfo.g_arrPackage[intUnitNo].ref_strErrorMessage;
                    }

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 11 PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());

                    if (blnAuto)
                    {
                        SaveRejectImage_AddToBuffer("PackageDefect", m_smVisionInfo.g_arrPackage[intUnitNo].ref_strErrorMessage);
                    }
                    if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                    {
                        if (!m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        {
                            m_objVisionIO.PackageFail.SetOn("V4 PackageFail 2");
                        }
                        //SaveRejectImage_AddToBuffer("PackageDefect", m_smVisionInfo.g_arrPackage[intUnitNo].ref_strErrorMessage);

                        m_smVisionInfo.g_intPkgDefectFailureTotal++;
                        //m_smVisionInfo.g_intTestedTotal++;
                        //m_smVisionInfo.g_intLowYieldUnitCount++;
                        m_blnFailCounterAdded = true;
                        m_blnTotalCounterAdded = false;
                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 11a PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                    }
                    if (blnAuto)
                    {
                        if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        {
                            m_blnPackageFail_Out = true;
                            if (m_intTCPIPResultID == -1)
                                SetPackageResultID(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailResultMask);
                        }
                    }
                    blnResult = false;
                }
            }
            else
            {
                if (!m_smVisionInfo.g_arrPackage[intUnitNo].DoInspection_SideLightView_GrayValueThresholdMethod(//m_smVisionInfo.g_arrPackageGaugeM4L[intUnitNo],   // use to measure unit edge
                                                    fGaugeCenterX, fGaugeCenterY,
                                                    fGaugeWidth, fGaugeHeight,
                                                    objPkgViewROI,              // Package Test on second image
                                                    objChipUnitROI,             // Chipped off test on image 2
                                                    m_objPkgViewImage,         // Second package image (option)
                                                    m_objGrayValueImage_SideLight,
                                                    objMoldFlashROI,
                                                    m_smVisionInfo.g_intPackageInspectionAreaGrayValueSensitivity,
                                                    m_smVisionInfo.g_intPackageMergeSensitivity,
                                                    m_smVisionInfo.g_intPackageBrightSensitivity, arrChippedROIPoints,
                                                    m_smVisionInfo.g_objWhiteImage,
                                                    m_smVisionInfo.g_objBlackImage,
                                                    fGaugeAngle + (m_intOrientAngle),
                                                    arrMoldROIPoints,
                                                    m_smVisionInfo.g_objBlackWhiteTopImage, m_smVisionInfo.g_objBlackWhiteRightImage, m_smVisionInfo.g_objBlackWhiteBottomImage, m_smVisionInfo.g_objBlackWhiteLeftImage))
                {
                    if (intUnitNo == 1)
                    {
                        m_smVisionInfo.g_strErrorMessageForSecondUnit += GetUnitName(intUnitNo) + m_smVisionInfo.g_arrPackage[intUnitNo].ref_strErrorMessage;
                    }
                    else
                    {
                        m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + m_smVisionInfo.g_arrPackage[intUnitNo].ref_strErrorMessage;
                    }

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 11 PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());

                    if (blnAuto)
                    {
                        SaveRejectImage_AddToBuffer("PackageDefect", m_smVisionInfo.g_arrPackage[intUnitNo].ref_strErrorMessage);
                    }
                    if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                    {
                        if (!m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        {
                            m_objVisionIO.PackageFail.SetOn("V4 PackageFail 2");
                        }
                        //SaveRejectImage_AddToBuffer("PackageDefect", m_smVisionInfo.g_arrPackage[intUnitNo].ref_strErrorMessage);

                        m_smVisionInfo.g_intPkgDefectFailureTotal++;
                        //m_smVisionInfo.g_intTestedTotal++;
                        //m_smVisionInfo.g_intLowYieldUnitCount++;
                        m_blnFailCounterAdded = true;
                        m_blnTotalCounterAdded = false;
                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 11a PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                    }
                    if (blnAuto)
                    {
                        if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        {
                            m_blnPackageFail_Out = true;
                            if (m_intTCPIPResultID == -1)
                                SetPackageResultID(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailResultMask);
                        }
                    }
                    blnResult = false;
                }
            }
            objMoldFlashROI.Dispose();
            objPkgViewROI.Dispose();
            objPkgViewROI_DarkField2.Dispose();
            objChipUnitROI.Dispose();
            m_smVisionInfo.g_blnDrawPkgResult = true;
            m_smVisionInfo.g_blnPackageInspected = true;

            return blnResult;
        }

        private bool StartPackageTest_TopLightView(bool blnAuto, int intUnitNo)
        {
            bool blnResult = true;

            if ((m_smCustomizeInfo.g_intWantPackage & (1 << m_smVisionInfo.g_intVisionPos)) == 0 || !m_smVisionInfo.g_arrPackage[intUnitNo].GetWantInspectPackage())
                return true;

            // Check is templates learnt
            if (m_smVisionInfo.g_arrPackageROIs[intUnitNo].Count == 0)
            {
                if (intUnitNo == 1)
                {
                    m_smVisionInfo.g_strErrorMessageForSecondUnit += GetUnitName(intUnitNo) + "*Package : No Template Found";
                }
                else
                {
                    m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + "*Package : No Template Found";
                }

                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 12 PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                {
                    m_smVisionInfo.g_intNoTemplateFailureTotal++;
                    m_blnFailCounterAdded = true;
                    m_blnTotalCounterAdded = false;

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 12a PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                }
                if (blnAuto)
                {
                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        if (m_intTCPIPResultID == -1)
                            SetPackageResultID(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailResultMask);
                }
                return false;
            }

            // Make sure template unit size not set to zero
            if ((m_smVisionInfo.g_arrPackage[intUnitNo].ref_fUnitWidthMin == 0 || m_smVisionInfo.g_arrPackage[intUnitNo].ref_fUnitHeightMin == 0) ||
                (m_smVisionInfo.g_arrPackage[intUnitNo].ref_fUnitWidthMax == 0 || m_smVisionInfo.g_arrPackage[intUnitNo].ref_fUnitHeightMax == 0))
            {
                if (intUnitNo == 1)
                {
                    m_smVisionInfo.g_strErrorMessageForSecondUnit += GetUnitName(intUnitNo) + "*Package : Template Unit Size cannot be zero.";
                }
                else
                {
                    m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + "*Package : Template Unit Size cannot be zero.";
                }

                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 13 PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)//2020-11-11 ZJYEOH : Removed && !m_blnPassCounterAdded
                {
                    m_smVisionInfo.g_intPackageFailureTotal++;
                    m_blnFailCounterAdded = true;
                    m_blnTotalCounterAdded = false;

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 13a PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                }
                if (blnAuto)
                {
                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        if (m_intTCPIPResultID == -1)
                            m_intTCPIPResultID = (int)TCPIPResulID.Fail;//FailPackageDimension;
                }
                return false;
            }


            // ------------- Make sure grab image done ------------------------
            int intTopLightViewImageIndex = m_smVisionInfo.g_arrPackage[intUnitNo].GetGrabImageIndex(3);    // Top Light 
            if (intTopLightViewImageIndex == 0)
                WaitEventDone(ref m_bGrabImage1Done, true, 10000, "StartPackageTest_TopLightView > m_bGrabImage1Done g");
            else if (intTopLightViewImageIndex == 1)
                WaitEventDone(ref m_bGrabImage2Done, true, 10000, "StartPackageTest_TopLightView > m_bGrabImage2Done g");
            else if (intTopLightViewImageIndex == 2)
                WaitEventDone(ref m_bGrabImage3Done, true, 10000, "StartPackageTest_TopLightView > m_bGrabImage3Done g");
            else if (intTopLightViewImageIndex == 3)
                WaitEventDone(ref m_bGrabImage4Done, true, 10000, "StartPackageTest_TopLightView > m_bGrabImage4Done g");
            else if (intTopLightViewImageIndex == 4)
                WaitEventDone(ref m_bGrabImage5Done, true, 10000, "StartPackageTest_TopLightView > m_bGrabImage5Done g");
            else if (intTopLightViewImageIndex == 5)
                WaitEventDone(ref m_bGrabImage6Done, true, 10000, "StartPackageTest_TopLightView > m_bGrabImage6Done g");
            else if (intTopLightViewImageIndex == 6)
                WaitEventDone(ref m_bGrabImage7Done, true, 10000, "StartPackageTest_TopLightView > m_bGrabImage7Done g");
            else
            {
                if (intUnitNo == 1)
                {
                    m_smVisionInfo.g_strErrorMessageForSecondUnit += GetUnitName(intUnitNo) + "Package : Wrong setting for package (Top Light View) image number. intTopLightViewImageIndex = " + intTopLightViewImageIndex.ToString();
                }
                else
                {
                    m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + "Package : Wrong setting for package (Top Light View) image number. intTopLightViewImageIndex = " + intTopLightViewImageIndex.ToString();
                }
                
                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 14 PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)//2020-11-11 ZJYEOH : Removed && !m_blnPassCounterAdded
                {
                    m_smVisionInfo.g_intPackageFailureTotal++;
                    m_blnFailCounterAdded = true;
                    m_blnTotalCounterAdded = false;

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 14a PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                }
                if (blnAuto)
                {
                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        if (m_intTCPIPResultID == -1)
                            SetPackageResultID(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailResultMask);
                }
                return false;
            }

            // 2019 03 07 - ZJYeoh: Wait m_intOrientAngle value from StartOrientTest First
            if (intTopLightViewImageIndex > 0)
            {
                if (intUnitNo == 0)
                    WaitEventDone(ref m_blnOrientDataUpdated1, true, 10000, "StartPackageTest_TopLightView > m_blnOrientDataUpdated1 8089");
                else
                    WaitEventDone(ref m_blnOrientDataUpdated2, true, 10000, "StartPackageTest_TopLightView > m_blnOrientDataUpdated2 8091");
            }

            // ---------  Rotate image 2 and 3 to oriented 0 deg -------------
            // 2019 04 30 - JBTAN: Top light view use m_smVisionInfo.g_arrPackageGauge2[0]
            if (m_objGauge_PkgTopView == null)
            {
                m_objGauge_PkgTopView = new RectGaugeM4L(m_smVisionInfo.g_WorldShape, 0, m_smVisionInfo.g_intVisionIndex);
            }

            float fGaugeCenterX = 0, fGaugeCenterY = 0, fGaugeWidth = 0, fGaugeHeight = 0, fGaugeAngle = 0;

            if (!m_smVisionInfo.g_blnWantUseSideLightGauge)
            {
                if (intTopLightViewImageIndex == 1)
                {
                    m_smVisionInfo.g_arrPackageGauge2M4L[intUnitNo].CopyTo(ref m_objGauge_PkgTopView);

                    int[] arrUserSelectImageViewIndex = m_objGauge_PkgTopView.GetGaugeImageNoList();

                    if (!WaitEventDone(arrUserSelectImageViewIndex, "StartPackageTest_TopLightView > arrUserSelectImageViewIndex 8111"))
                    {
                        if (intUnitNo == 1)
                        {
                            m_smVisionInfo.g_strErrorMessageForSecondUnit += GetUnitName(intUnitNo) + "*Package : Wrong setting for package size image number.";
                        }
                        else
                        {
                            m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + "*Package : Wrong setting for package size image number.";
                        }

                        if (blnAuto)
                        {
                            m_smVisionInfo.g_intPackageFailureTotal++;

                            if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                                if (m_intTCPIPResultID == -1)
                                    SetPackageResultID(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailResultMask);

                        }
                        return false;
                    }

                    if (!GaugeMeasureUnit(m_objGauge_PkgTopView, m_smVisionInfo.g_arrImages, intUnitNo))
                    {
                        if (intUnitNo == 1)
                        {
                            m_smVisionInfo.g_strErrorMessageForSecondUnit += GetUnitName(intUnitNo) + "*Package : " + m_objGauge_PkgTopView.ref_strErrorMessage;
                        }
                        else
                        {
                            m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + "*Package : " + m_objGauge_PkgTopView.ref_strErrorMessage;
                        }

                        //if (blnAuto)
                        if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)//2020-11-11 ZJYEOH : Removed && !m_blnPassCounterAdded
                        {
                            m_smVisionInfo.g_intPackageFailureTotal++;
                            m_blnFailCounterAdded = true;
                            m_blnTotalCounterAdded = false;

                        }
                        if (blnAuto)
                        {
                            if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                                if (m_intTCPIPResultID == -1)
                                    SetPackageResultID(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailResultMask);
                        }
                        return false;
                    }
                }
                else
                {
                    //if (m_smVisionInfo.g_arrPackageGauge2[0] != null)
                    //{
                    //    m_smVisionInfo.g_arrPackageGauge2[intUnitNo].CopyTo(ref m_objGauge_PkgTopView);
                    //    GaugeMeasureUnit(m_objGauge_PkgTopView, m_smVisionInfo.g_arrImages[intTopLightViewImageIndex]);
                    //}
                    //else
                    {
                        m_smVisionInfo.g_arrPackageGauge2M4L[intUnitNo].CopyTo(ref m_objGauge_PkgTopView);

                        int[] arrUserSelectImageViewIndex = m_objGauge_PkgTopView.GetGaugeImageNoList();

                        if (!WaitEventDone(arrUserSelectImageViewIndex, "StartPackageTest_TopLightView > arrUserSelectImageViewIndex 8147"))
                        {
                            if (intUnitNo == 1)
                            {
                                m_smVisionInfo.g_strErrorMessageForSecondUnit += GetUnitName(intUnitNo) + "*Package : Wrong setting for package size image number.";
                            }
                            else
                            {
                                m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + "*Package : Wrong setting for package size image number.";
                            }

                            if (blnAuto)
                            {
                                m_smVisionInfo.g_intPackageFailureTotal++;

                                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                                    if (m_intTCPIPResultID == -1)
                                        SetPackageResultID(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailResultMask);

                            }
                            return false;
                        }

                        if (!GaugeMeasureUnit(m_objGauge_PkgTopView, m_smVisionInfo.g_arrImages, intUnitNo))
                        {
                            if (intUnitNo == 1)
                            {
                                m_smVisionInfo.g_strErrorMessageForSecondUnit += GetUnitName(intUnitNo) + "*Package : " + m_objGauge_PkgTopView.ref_strErrorMessage;
                            }
                            else
                            {
                                m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + "*Package : " + m_objGauge_PkgTopView.ref_strErrorMessage;
                            }

                            if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 144 PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                            //if (blnAuto)
                            if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)//2020-11-11 ZJYEOH : Removed && !m_blnPassCounterAdded
                            {
                                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 144a PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                                m_smVisionInfo.g_intPackageFailureTotal++;
                                m_blnFailCounterAdded = true;
                                m_blnTotalCounterAdded = false;

                            }
                            if (blnAuto)
                            {
                                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                                    if (m_intTCPIPResultID == -1)
                                        SetPackageResultID(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailResultMask);
                            }
                            return false;
                        }
                    }
                }

                fGaugeCenterX = m_objGauge_PkgTopView.ref_pRectCenterPoint.X;
                fGaugeCenterY = m_objGauge_PkgTopView.ref_pRectCenterPoint.Y;
                fGaugeWidth = m_objGauge_PkgTopView.ref_fRectWidth;
                fGaugeHeight = m_objGauge_PkgTopView.ref_fRectHeight;
                fGaugeAngle = m_objGauge_PkgTopView.ref_fRectAngle;
            }
            else
            {
                if (intUnitNo == 0)
                {
                    WaitEventDone(ref m_bPackageSizeTestDone1, true, 10000, "StartPackageTest_TopLightView > m_bPackageSizeTestDone1 8184");
                    fGaugeCenterX = m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X;
                    fGaugeCenterY = m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y;
                    fGaugeWidth = m_smVisionInfo.g_objGauge_PkgSize.ref_fRectWidth;
                    fGaugeHeight = m_smVisionInfo.g_objGauge_PkgSize.ref_fRectHeight;
                    fGaugeAngle = m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle;
                }
                else
                {
                    WaitEventDone(ref m_bPackageSizeTestDone2, true, 10000, "StartPackageTest_TopLightView > m_bPackageSizeTestDone1 8193");
                    fGaugeCenterX = m_smVisionInfo.g_objGauge_PkgSize2.ref_pRectCenterPoint.X;
                    fGaugeCenterY = m_smVisionInfo.g_objGauge_PkgSize2.ref_pRectCenterPoint.Y;
                    fGaugeWidth = m_smVisionInfo.g_objGauge_PkgSize2.ref_fRectWidth;
                    fGaugeHeight = m_smVisionInfo.g_objGauge_PkgSize2.ref_fRectHeight;
                    fGaugeAngle = m_smVisionInfo.g_objGauge_PkgSize2.ref_fRectAngle;
                }
            }

            float fTotalRotateAngle = m_intOrientAngle + fGaugeAngle;

            // 2019 06 08 - CCENG: Add this 0.5 formula to make sure ROI attahced to image in the best way
            float fCenterX, fCenterY;
            if ((m_smVisionInfo.g_arrPackageROIs[intUnitNo][0].ref_ROIWidth % 2) == 0)
                fCenterX = (float)Math.Round(fGaugeCenterX, 0, MidpointRounding.AwayFromZero);
            else
                fCenterX = (float)Math.Floor(fGaugeCenterX) + 0.5f;

            if ((m_smVisionInfo.g_arrPackageROIs[intUnitNo][0].ref_ROIHeight % 2) == 0)
                fCenterY = (float)Math.Round(fGaugeCenterY, 0, MidpointRounding.AwayFromZero);
            else
                fCenterY = (float)Math.Floor(fGaugeCenterY) + 0.5f;

            m_objSubTh3_RotateROI.LoadROISetting(
                        (int)Math.Round(fCenterX -
                        (float)m_smVisionInfo.g_arrPackageROIs[intUnitNo][0].ref_ROIWidth / 2, 0, MidpointRounding.AwayFromZero),
                        (int)Math.Round(fCenterY -
                        (float)m_smVisionInfo.g_arrPackageROIs[intUnitNo][0].ref_ROIHeight / 2, 0, MidpointRounding.AwayFromZero),
                        m_smVisionInfo.g_arrPackageROIs[intUnitNo][0].ref_ROIWidth,
                        m_smVisionInfo.g_arrPackageROIs[intUnitNo][0].ref_ROIHeight);

            // Get RotateROI center point where the ROI center point == Unit Center Point
            //m_objSubTh3_RotateROI.LoadROISetting(
            //            (int)Math.Round(m_objGauge_PkgTopView.ref_ObjectCenterX -
            //            m_smVisionInfo.g_arrPackageROIs[intUnitNo][0].ref_ROIWidth / 2, 0, MidpointRounding.AwayFromZero),
            //            (int)Math.Round(m_objGauge_PkgTopView.ref_ObjectCenterY -
            //            m_smVisionInfo.g_arrPackageROIs[intUnitNo][0].ref_ROIHeight / 2, 0, MidpointRounding.AwayFromZero),
            //            m_smVisionInfo.g_arrPackageROIs[intUnitNo][0].ref_ROIWidth,
            //            m_smVisionInfo.g_arrPackageROIs[intUnitNo][0].ref_ROIHeight);

            // Rotate image 3
            m_objSubTh3_RotateROI.AttachImage(m_smVisionInfo.g_arrImages[intTopLightViewImageIndex]);
            ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[intTopLightViewImageIndex], m_objSubTh3_RotateROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_PkgDark, ref m_smVisionInfo.g_arrRotatedImages, intTopLightViewImageIndex);
            if (intTopLightViewImageIndex == 0)
                m_blnRotateImage1Updated = true;
            else if (intTopLightViewImageIndex == 1)
                m_blnRotateImage2Updated = true;
            else if (intTopLightViewImageIndex == 2)
                m_blnRotateImage3Updated = true;
            else if (intTopLightViewImageIndex == 3)
                m_blnRotateImage4Updated = true;
            else if (intTopLightViewImageIndex == 4)
                m_blnRotateImage5Updated = true;
            else if (intTopLightViewImageIndex == 5)
                m_blnRotateImage6Updated = true;
            else
                m_blnRotateImage7Updated = true;

            // Wait mark inspection done.
            if (intUnitNo == 0)
            {
                WaitEventDone(ref m_bMarkTestDone1, true, 10000, "AAA1");    //m_bSubTh_MarkTest,false// need to wait for mark inspection done. Because package size fail should not display error msg if mark fail.
                if (!m_bSubTh_MarkTest_Result)
                {
                    return false;   // Skip package counter if mark fail because counter will add to mark
                }
            }
            else
            {
                WaitEventDone(ref m_bMarkTestDone2, true, 10000, "AAA2");    //m_bSubTh_MarkTest,false// need to wait for mark inspection done. Because package size fail should not display error msg if mark fail.
                if (!m_bSubTh_MarkTest_Result2)
                {
                    return false;   // Skip package counter if mark fail because counter will add to mark
                }
            }

            // Wait package test done under mark light view 
            WaitEventDone(ref m_bSubTh_PackageTest_MarkLightView, false, 10000, "AAA3");
            if (intUnitNo == 0)
            {
                if (!m_bSubTh_PackageTest_MarkLightView_Result)
                {
                    return false;
                }
            }
            else
            {
                if (!m_bSubTh_PackageTest_MarkLightView_Result2)
                {
                    return false;
                }
            }
            // Wait SideLightView Package done because using same database (array)
            WaitEventDone(ref m_bSubTh_PackageTest_SideLightView, false, 10000, "AAA4");
            if (!m_bSubTh_PackageTest_SideLightView_Result)
            {
                return false;
            }

            m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnViewUnitPosition = true;
            //m_smVisionInfo.g_arrPackage[intUnitNo].ClearDontCareAreaArray();//2020-12-28 ZJYEOH : Only StartPackageTest_MarkLightView will use this dont care

            // ------- Copy image to temporary inspection image.
            if (intTopLightViewImageIndex >= 0)
            {
                if (m_objPkgViewImage2 == null)
                    m_objPkgViewImage2 = new ImageDrawing(true);
                m_smVisionInfo.g_arrRotatedImages[intTopLightViewImageIndex].CopyTo(ref m_objPkgViewImage2);
            }
            else if (m_objPkgViewImage2 != null)
                m_objPkgViewImage2 = null;

            if (intTopLightViewImageIndex >= 0)
            {
                if (m_objVoidViewImage == null)
                    m_objVoidViewImage = new ImageDrawing(true);
                m_smVisionInfo.g_arrRotatedImages[intTopLightViewImageIndex].CopyTo(ref m_objVoidViewImage);
            }
            else if (m_objVoidViewImage != null)
                m_objVoidViewImage = null;

            if (intTopLightViewImageIndex >= 0)
            {
                if (m_objCrackViewImage == null)
                    m_objCrackViewImage = new ImageDrawing(true);
                m_smVisionInfo.g_arrRotatedImages[intTopLightViewImageIndex].CopyTo(ref m_objCrackViewImage);
            }
            else if (m_objCrackViewImage != null)
                m_objCrackViewImage = null;

            bool blnWantMark = false;
            int intCharDilateHalfWidth = 2;
            if (m_smVisionInfo.g_arrMarks != null && m_smVisionInfo.g_arrMarks.Count > 0)
            {
                // 2020 04 15 - JBTAN: will continue to check mark even option uncheck check mark option
                // 2020 07 08 - Roll back to previous method, wont check mark if Mark Checking is not selected.
                blnWantMark = m_smVisionInfo.g_arrMarks[intUnitNo].ref_blnCheckMark;
                //blnWantMark = true;
                intCharDilateHalfWidth = m_smVisionInfo.g_arrMarks[intUnitNo].ref_intCharDilateHalfWidth; // thick iteration
            }

            //2020-05-18 ZJYEOH : Get another Image without subtract mark area
            //2020-05-18 ZJYEOH : Get another Image without subtract mark area
            if (m_smVisionInfo.g_intPackageDefectInspectionMethod != 0)
            {
                m_objCrackViewImage.CopyTo(ref m_objGrayValueImage_TopLight);
            }

            if (blnWantMark)
            {
                // ---------- Fill Mark Image's mark area with black color -------------------
                int intNumChars = m_smVisionInfo.g_arrMarks[intUnitNo].GetNumChars();
                int intStartX = 0, intStartY = 0, intEndX = 0, intEndY = 0;

                int intOffsetX;
                int intOffsetY;

                if (m_smVisionInfo.g_blnWantGauge)  // Mean during mark inspection, orient gauge is used to measure unit position for m_objMarkTrainROI
                {
                    if (intUnitNo == 0)
                    {
                        intOffsetX = m_objMarkTrainROI.ref_ROITotalX;
                        intOffsetY = m_objMarkTrainROI.ref_ROITotalY;
                    }
                    else
                    {
                        intOffsetX = m_pMarkTrainROIPoint_Unit2.X;
                        intOffsetY = m_pMarkTrainROIPoint_Unit2.Y;
                    }
                }
                else if (m_smVisionInfo.g_arrMarkROIs[intUnitNo].Count > 3)    // Mean during mark inspection, Unit PR is used to find unit surface position for m_objMarkTrainROI
                {
                    if (intUnitNo == 0)
                    {
                        intOffsetX = m_objMarkTrainROI.ref_ROITotalX;
                        intOffsetY = m_objMarkTrainROI.ref_ROITotalY;
                    }
                    else
                    {
                        intOffsetX = m_pMarkTrainROIPoint_Unit2.X;
                        intOffsetY = m_pMarkTrainROIPoint_Unit2.Y;
                    }
                }
                else // Mean during mark inspection, m_objMarkSearchROI is used.
                {
                    if (intUnitNo == 0)
                    {
                        intOffsetX = m_objMarkTrainROI.ref_ROITotalX;
                        intOffsetY = m_objMarkTrainROI.ref_ROITotalY;
                    }
                    else
                    {
                        intOffsetX = m_pMarkTrainROIPoint_Unit2.X;
                        intOffsetY = m_pMarkTrainROIPoint_Unit2.Y;
                    }
                }

                for (int i = 0; i < intNumChars; i++)
                {
                    int intRectStartX, intRectStartY, intRectEndX, intRectEndY;
                    intRectStartX = intRectStartY = intRectEndX = intRectEndY = 0;
                    m_smVisionInfo.g_arrMarks[intUnitNo].GetCharStartXY(i, ref intStartX, ref intStartY);
                    m_smVisionInfo.g_arrMarks[intUnitNo].GetCharEndXY(i, ref intEndX, ref intEndY);

                    if (m_smVisionInfo.g_arrMarks[intUnitNo].ref_blnWantDontCareIgnoredMarkWholeArea && !m_smVisionInfo.g_arrMarks[intUnitNo].GetEnableMarkSetting(i))
                    {
                        //2021-01-18 ZJYEOH : Should use sample position
                        Point pStartTemplate = new Point(intStartX, intStartY);//m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharROIStartPoint(i);
                        Point pEndTemplate = new Point(intEndX, intEndY);//m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharROIEndPoint(i);

                        if ((intOffsetX + pStartTemplate.X - m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftX(i)) >= 0)
                            intRectStartX = intOffsetX + pStartTemplate.X - m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftX(i);
                        else
                            intRectStartX = intOffsetX;

                        if ((intOffsetY + pStartTemplate.Y - m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftY(i)) >= 0)
                            intRectStartY = intOffsetY + pStartTemplate.Y - m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftY(i);
                        else
                            intRectStartY = intOffsetY;

                        if ((intOffsetX + pEndTemplate.X + m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftX(i)) < m_smVisionInfo.g_intCameraResolutionWidth)
                            intRectEndX = intOffsetX + pEndTemplate.X + m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftX(i);
                        else
                            continue;
                        if ((intOffsetY + pEndTemplate.Y + m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftY(i)) < m_smVisionInfo.g_intCameraResolutionHeight)
                            intRectEndY = intOffsetY + pEndTemplate.Y + m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftY(i);
                        else
                            continue;
                    }
                    else
                    {
                        if ((intStartX - intCharDilateHalfWidth) >= 0)
                            intRectStartX = intOffsetX + intStartX - intCharDilateHalfWidth;
                        else
                            intRectStartX = intOffsetX;

                        if ((intStartY - intCharDilateHalfWidth) >= 0)
                            intRectStartY = intOffsetY + intStartY - intCharDilateHalfWidth;
                        else
                            intRectStartY = intOffsetY;

                        if ((intEndX + intCharDilateHalfWidth) < m_smVisionInfo.g_intCameraResolutionWidth)
                            intRectEndX = intOffsetX + intEndX + intCharDilateHalfWidth;
                        else
                            intRectEndX = intOffsetX + intEndX;

                        if ((intEndY + intCharDilateHalfWidth) < m_smVisionInfo.g_intCameraResolutionHeight)
                            intRectEndY = intOffsetY + intEndY + intCharDilateHalfWidth;
                        else
                            intRectEndY = intOffsetY + intEndY;
                    }

                    if (m_smVisionInfo.g_arrMarks[intUnitNo].ref_blnWantCheckBarPin1)
                    {
                        bool blnIsBarPin1 = m_smVisionInfo.g_arrMarks[intUnitNo].GetCharIsBarPin1(m_smVisionInfo.g_arrMarks[0].ref_intGroupIndex, m_smVisionInfo.g_arrMarks[0].ref_intTemplateIndex, i);
                        int intBarPin1Type = m_smVisionInfo.g_arrMarks[intUnitNo].GetCharBarPin1Type(m_smVisionInfo.g_arrMarks[0].ref_intGroupIndex, m_smVisionInfo.g_arrMarks[0].ref_intTemplateIndex, i);

                        //2020-05-28 ZJYEOH : extend the dont care area to fit the m_objMarkTrainROI size
                        if (blnIsBarPin1 && !m_smVisionInfo.g_blnWantCheckBarPin1)
                        {
                            if (intBarPin1Type == 0) // Virtical bar
                            {
                                //if (intRectStartY > intOffsetY)
                                //    intRectStartY = intOffsetY;
                                //if (intRectEndY < intOffsetY + m_objMarkTrainROI.ref_ROIHeight)
                                //    intRectEndY = intOffsetY + m_objMarkTrainROI.ref_ROIHeight;
                                if (intUnitNo == 0)
                                {
                                    intRectStartY = intOffsetY;
                                    intRectEndY = intOffsetY + m_objMarkTrainROI.ref_ROIHeight;
                                }
                                else
                                {
                                    intRectStartY = intOffsetY;
                                    intRectEndY = intOffsetY + m_sMarkTrainROISize_Unit2.Height;
                                }
                            }
                            else if (intBarPin1Type == 1) // Horizontal bar
                            {
                                //if (intRectStartX > intOffsetX)
                                //    intRectStartX = intOffsetX;
                                //if (intRectEndX < intOffsetX + m_objMarkTrainROI.ref_ROIWidth)
                                //    intRectEndX = intOffsetX + m_objMarkTrainROI.ref_ROIWidth;
                                if (intUnitNo == 0)
                                {
                                    intRectStartX = intOffsetX;
                                    intRectEndX = intOffsetX + m_objMarkTrainROI.ref_ROIWidth;
                                }
                                else
                                {
                                    intRectStartX = intOffsetX;
                                    intRectEndX = intOffsetX + m_sMarkTrainROISize_Unit2.Width;
                                }
                            }
                        }
                    }

                    if (intTopLightViewImageIndex >= 0 && !m_smVisionInfo.g_blnWantCheckVoidOnMarkArea)
                        Shape.FillRectangle(m_objPkgViewImage2, intRectStartX, intRectStartY, intRectEndX, intRectEndY, 255);
                    if (intTopLightViewImageIndex >= 0 && !m_smVisionInfo.g_blnWantCheckVoidOnMarkArea)
                        Shape.FillRectangle(m_objCrackViewImage, intRectStartX, intRectStartY, intRectEndX, intRectEndY, 255);
                    if (intTopLightViewImageIndex >= 0 && !m_smVisionInfo.g_blnWantCheckVoidOnMarkArea)
                        Shape.FillRectangle(m_objVoidViewImage, intRectStartX, intRectStartY, intRectEndX, intRectEndY, 255);

                    //m_smVisionInfo.g_arrPackage[intUnitNo].SetDontCareArea(intRectStartX, intRectStartY, intRectEndX, intRectEndY);//2020-12-28 ZJYEOH : Only StartPackageTest_MarkLightView will use this dont care
                }
            }

            ROI objChipUnitROI2 = null; // Image 3 - Chip ROI
            if (intTopLightViewImageIndex >= 0)
            {
                objChipUnitROI2 = new ROI();

                // 2019 06 08 - CCENG: +1 pixel to start point and -1 pixel to size. This is To avoid unit long chamfer affecting result.
                //objChipUnitROI2.LoadROISetting((int)Math.Round((m_objGauge_PkgTopView.ref_ObjectCenterX - m_objGauge_PkgTopView.ref_ObjectWidth / 2), 0, MidpointRounding.AwayFromZero),
                //                               (int)Math.Round((m_objGauge_PkgTopView.ref_ObjectCenterY - m_objGauge_PkgTopView.ref_ObjectHeight / 2), 0, MidpointRounding.AwayFromZero),
                //                               (int)Math.Round(m_objGauge_PkgTopView.ref_ObjectWidth, 0, MidpointRounding.AwayFromZero),
                //                               (int)Math.Round(m_objGauge_PkgTopView.ref_ObjectHeight, 0, MidpointRounding.AwayFromZero));
                //objChipUnitROI2.LoadROISetting(1 + (int)Math.Round((fGaugeCenterX - fGaugeWidth / 2), 0, MidpointRounding.AwayFromZero),
                //                               1 + (int)Math.Round((fGaugeCenterY - fGaugeHeight / 2), 0, MidpointRounding.AwayFromZero),
                //                               (int)Math.Round(fGaugeWidth - 1, 0, MidpointRounding.AwayFromZero),
                //                               (int)Math.Round(fGaugeHeight - 1, 0, MidpointRounding.AwayFromZero));
                objChipUnitROI2.LoadROISetting(1 + (int)Math.Round((fGaugeCenterX - fGaugeWidth / 2) + m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelExtendFromLeft_Chip, 0, MidpointRounding.AwayFromZero),
                                        1 + (int)Math.Round((fGaugeCenterY - fGaugeHeight / 2) + m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelExtendFromEdge_Chip, 0, MidpointRounding.AwayFromZero),
                                        (int)Math.Round(fGaugeWidth - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelExtendFromLeft_Chip - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelExtendFromRight_Chip - 1, 0, MidpointRounding.AwayFromZero),
                                        (int)Math.Round(fGaugeHeight - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelExtendFromEdge_Chip - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelExtendFromBottom_Chip - 1, 0, MidpointRounding.AwayFromZero));

                // Use pkg image for chip test as priority
                objChipUnitROI2.AttachImage(m_objPkgViewImage2);
            }

            ROI objVoidUnitROI = null; // Image 3 - Void ROI
            if (intTopLightViewImageIndex >= 0)
            {
                objVoidUnitROI = new ROI();
                if (m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateBrightDarkROITolerance)
                {
                    objVoidUnitROI.LoadROISetting((int)Math.Round((fGaugeCenterX -
                                fGaugeWidth / 2 +
                                m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeft_Dark), 0, MidpointRounding.AwayFromZero),
                                (int)Math.Round((fGaugeCenterY -
                                fGaugeHeight / 2 +
                                m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdge_Dark), 0, MidpointRounding.AwayFromZero),
                                (int)Math.Round(fGaugeWidth - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromRight_Dark - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeft_Dark, 0, MidpointRounding.AwayFromZero),
                                (int)Math.Round(fGaugeHeight - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdge_Dark - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromBottom_Dark, 0, MidpointRounding.AwayFromZero));
                }
                else
                {
                    objVoidUnitROI.LoadROISetting((int)Math.Round((fGaugeCenterX -
                                fGaugeWidth / 2 +
                                m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeft), 0, MidpointRounding.AwayFromZero),
                                (int)Math.Round((fGaugeCenterY -
                                fGaugeHeight / 2 +
                                m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdge), 0, MidpointRounding.AwayFromZero),
                                (int)Math.Round(fGaugeWidth - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromRight - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeft, 0, MidpointRounding.AwayFromZero),
                                (int)Math.Round(fGaugeHeight - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdge - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromBottom, 0, MidpointRounding.AwayFromZero));
                }

                objVoidUnitROI.AttachImage(m_objVoidViewImage);
            }

            ROI objCrackViewROI = null; // Image 3 - Crack ROI
            if (intTopLightViewImageIndex >= 0)
            {
                //RectGauge objGauge2 = m_smVisionInfo.g_arrPackageGauge[intUnitNo];

                objCrackViewROI = new ROI();
                if (m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateBrightDarkROITolerance)
                {
                    objCrackViewROI.LoadROISetting((int)Math.Round((fGaugeCenterX -
                                fGaugeWidth / 2 +
                                m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeft_Dark), 0, MidpointRounding.AwayFromZero),
                                (int)Math.Round((fGaugeCenterY -
                                fGaugeHeight / 2 +
                                m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdge_Dark), 0, MidpointRounding.AwayFromZero),
                                (int)Math.Round(fGaugeWidth - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromRight_Dark - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeft_Dark, 0, MidpointRounding.AwayFromZero),
                                (int)Math.Round(fGaugeHeight - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdge_Dark - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromBottom_Dark, 0, MidpointRounding.AwayFromZero));
                }
                else
                {
                    objCrackViewROI.LoadROISetting((int)Math.Round((fGaugeCenterX -
                                fGaugeWidth / 2 +
                                m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeft), 0, MidpointRounding.AwayFromZero),
                                (int)Math.Round((fGaugeCenterY -
                                fGaugeHeight / 2 +
                                m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdge), 0, MidpointRounding.AwayFromZero),
                                (int)Math.Round(fGaugeWidth - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromRight - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeft, 0, MidpointRounding.AwayFromZero),
                                (int)Math.Round(fGaugeHeight - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdge - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromBottom, 0, MidpointRounding.AwayFromZero));
                }
                objCrackViewROI.AttachImage(m_objCrackViewImage);
            }

            if (m_smVisionInfo.g_blnWantDontCareArea_Package)
            {
                if (intTopLightViewImageIndex >= 0)
                {
                    ////Draw don't care ROI edge to make sure Don't Care Area is not inspected
                    //for (int k = 3; k < m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit].Count; k++)
                    //{
                    //    m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][k].AttachImage(objCrackViewROI);
                    //    ROI objROI = new ROI();
                    //    objROI.LoadROISetting((int)Math.Round((fGaugeCenterX - fGaugeWidth / 2 + m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][k].ref_ROIPositionX), 0, MidpointRounding.AwayFromZero),
                    //                          (int)Math.Round((fGaugeCenterY - fGaugeHeight / 2 + m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][k].ref_ROIPositionY), 0, MidpointRounding.AwayFromZero),
                    //                           m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][k].ref_ROIWidth, m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][k].ref_ROIHeight);
                    //    objROI.AttachImage(m_smVisionInfo.g_objWhiteImage);
                    //    ROI.LogicOperationAddROI(m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][k], objROI);
                    //    //objCrackViewROI.SaveImage("D:\\aaa.bmp");
                    //    objROI.Dispose();
                    //}

                    ROI objDontCareROI = new ROI();
                    //objDontCareROI.LoadROISetting(0, 0, objCrackViewROI.ref_ROIWidth, objCrackViewROI.ref_ROIHeight);
                    // 2020 06 27 - CCENG: objDontCareROI have to start from Package Tolerance bcos g_objDontCareImage_Package_Dark template is start from Package Size Template.
                    if (m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateBrightDarkROITolerance)
                    {
                        objDontCareROI.LoadROISetting(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeft_Dark,
                              m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdge_Dark,
                              objCrackViewROI.ref_ROIWidth, objCrackViewROI.ref_ROIHeight);
                    }
                    else
                    {
                        objDontCareROI.LoadROISetting(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeft,
                              m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdge,
                              objCrackViewROI.ref_ROIWidth, objCrackViewROI.ref_ROIHeight);
                    }
                    objDontCareROI.AttachImage(m_smVisionInfo.g_objDontCareImage_Package_Dark);
                    ROI.LogicOperationAddROI(objCrackViewROI, objDontCareROI);
                    //objCrackViewROI.SaveImage("D:\\aaa.bmp");
                    objDontCareROI.Dispose();
                }
            }
            if (m_smVisionInfo.g_intPackageDefectInspectionMethod == 0)
            {
                if (!m_smVisionInfo.g_arrPackage[intUnitNo].DoInspection_TopLightView(//m_objGauge_PkgTopView,   // use to measure unit edge
                                                    fGaugeCenterX, fGaugeCenterY,
                                                    fGaugeWidth, fGaugeHeight,
                                                    objCrackViewROI,            // Crack test
                                                    objChipUnitROI2,            // Chipped off test on image 3
                                                    objVoidUnitROI, // Void Test using Image 3
                                                    m_smVisionInfo.g_arrRotatedImages[intTopLightViewImageIndex],       // Image from Top light source
                                                    m_smVisionInfo.g_objWhiteImage, m_smVisionInfo.g_objBlackImage))
                {
                    if (intUnitNo == 1)
                    {
                        m_smVisionInfo.g_strErrorMessageForSecondUnit += GetUnitName(intUnitNo) + m_smVisionInfo.g_arrPackage[intUnitNo].ref_strErrorMessage;
                    }
                    else
                    {
                        m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + m_smVisionInfo.g_arrPackage[intUnitNo].ref_strErrorMessage;
                    }

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 15 PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());

                    if (blnAuto)
                    {
                        SaveRejectImage_AddToBuffer("PackageDefect", m_smVisionInfo.g_arrPackage[intUnitNo].ref_strErrorMessage);
                    }

                    if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                    {
                        if (!m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        {
                            m_objVisionIO.PackageFail.SetOn("V4 PackageFail 3");
                        }
                        //SaveRejectImage_AddToBuffer("PackageDefect", m_smVisionInfo.g_arrPackage[intUnitNo].ref_strErrorMessage);

                        m_smVisionInfo.g_intPkgDefectFailureTotal++;
                        //m_smVisionInfo.g_intTestedTotal++;
                        //m_smVisionInfo.g_intLowYieldUnitCount++;
                        m_blnFailCounterAdded = true;
                        m_blnTotalCounterAdded = false;
                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 15a PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                    }
                    if (blnAuto)
                    {
                        if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        {
                            m_blnPackageFail_Out = true;
                            if (m_intTCPIPResultID == -1)
                                SetPackageResultID(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailResultMask);
                        }
                    }
                    blnResult = false;
                }
            }
            else
            {
                if (!m_smVisionInfo.g_arrPackage[intUnitNo].DoInspection_TopLightView_GrayValueThresholdMethod(//m_objGauge_PkgTopView,   // use to measure unit edge
                                                    fGaugeCenterX, fGaugeCenterY,
                                                    fGaugeWidth, fGaugeHeight,
                                                    objCrackViewROI,            // Crack test
                                                    objChipUnitROI2,            // Chipped off test on image 3
                                                    objVoidUnitROI, // Void Test using Image 3
                                                    m_smVisionInfo.g_arrRotatedImages[intTopLightViewImageIndex],       // Image from Top light source
                                                     m_objGrayValueImage_TopLight,
                                                   m_smVisionInfo.g_intPackageInspectionAreaGrayValueSensitivity,
                                                   m_smVisionInfo.g_intPackageMergeSensitivity,
                                                  m_smVisionInfo.g_intPackageDarkSensitivity,
                                                  m_smVisionInfo.g_objWhiteImage, m_smVisionInfo.g_objBlackImage))
                {
                    if (intUnitNo == 1)
                    {
                        m_smVisionInfo.g_strErrorMessageForSecondUnit += GetUnitName(intUnitNo) + m_smVisionInfo.g_arrPackage[intUnitNo].ref_strErrorMessage;
                    }
                    else
                    {
                        m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + m_smVisionInfo.g_arrPackage[intUnitNo].ref_strErrorMessage;
                    }

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 15 PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());

                    if (blnAuto)
                    {
                        SaveRejectImage_AddToBuffer("PackageDefect", m_smVisionInfo.g_arrPackage[intUnitNo].ref_strErrorMessage);
                    }

                    if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                    {
                        if (!m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        {
                            m_objVisionIO.PackageFail.SetOn("V4 PackageFail 3");
                        }
                        //SaveRejectImage_AddToBuffer("PackageDefect", m_smVisionInfo.g_arrPackage[intUnitNo].ref_strErrorMessage);

                        m_smVisionInfo.g_intPkgDefectFailureTotal++;
                        //m_smVisionInfo.g_intTestedTotal++;
                        //m_smVisionInfo.g_intLowYieldUnitCount++;
                        m_blnFailCounterAdded = true;
                        m_blnTotalCounterAdded = false;
                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 15a PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                    }
                    if (blnAuto)
                    {
                        if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        {
                            m_blnPackageFail_Out = true;
                            if (m_intTCPIPResultID == -1)
                                SetPackageResultID(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailResultMask);
                        }
                    }
                    blnResult = false;
                }
            }
            objVoidUnitROI.Dispose();
            objChipUnitROI2.Dispose();
            objCrackViewROI.Dispose();
            m_smVisionInfo.g_blnDrawPkgResult = true;
            m_smVisionInfo.g_blnPackageInspected = true;

            return blnResult;
        }
        private bool StartPackageTest_TopLightView_WithoutRotate(bool blnAuto, int intUnitNo)
        {
            bool blnResult = true;
            bool blnWantDebug = false;

            if ((m_smCustomizeInfo.g_intWantPackage & (1 << m_smVisionInfo.g_intVisionPos)) == 0 || !m_smVisionInfo.g_arrPackage[intUnitNo].GetWantInspectPackage())
                return true;

            // Check is templates learnt
            if (m_smVisionInfo.g_arrPackageROIs[intUnitNo].Count == 0)
            {
                if (intUnitNo == 1)
                {
                    m_smVisionInfo.g_strErrorMessageForSecondUnit += GetUnitName(intUnitNo) + "*Package : No Template Found";
                }
                else
                {
                    m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + "*Package : No Template Found";
                }

                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 12 PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                {
                    m_smVisionInfo.g_intNoTemplateFailureTotal++;
                    m_blnFailCounterAdded = true;
                    m_blnTotalCounterAdded = false;

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 12a PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                }
                if (blnAuto)
                {
                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        if (m_intTCPIPResultID == -1)
                            SetPackageResultID(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailResultMask);
                }
                return false;
            }

            // Make sure template unit size not set to zero
            if ((m_smVisionInfo.g_arrPackage[intUnitNo].ref_fUnitWidthMin == 0 || m_smVisionInfo.g_arrPackage[intUnitNo].ref_fUnitHeightMin == 0) ||
                (m_smVisionInfo.g_arrPackage[intUnitNo].ref_fUnitWidthMax == 0 || m_smVisionInfo.g_arrPackage[intUnitNo].ref_fUnitHeightMax == 0))
            {
                if (intUnitNo == 1)
                {
                    m_smVisionInfo.g_strErrorMessageForSecondUnit += GetUnitName(intUnitNo) + "*Package : Template Unit Size cannot be zero.";
                }
                else
                {
                    m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + "*Package : Template Unit Size cannot be zero.";
                }

                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 13 PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)//2020-11-11 ZJYEOH : Removed && !m_blnPassCounterAdded
                {
                    m_smVisionInfo.g_intPackageFailureTotal++;
                    m_blnFailCounterAdded = true;
                    m_blnTotalCounterAdded = false;

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 13a PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                }
                if (blnAuto)
                {
                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        if (m_intTCPIPResultID == -1)
                            m_intTCPIPResultID = (int)TCPIPResulID.Fail;//FailPackageDimension;
                }
                return false;
            }


            // ------------- Make sure grab image done ------------------------
            int intTopLightViewImageIndex = m_smVisionInfo.g_arrPackage[intUnitNo].GetGrabImageIndex(3);    // Top Light 
            if (intTopLightViewImageIndex == 0)
                WaitEventDone(ref m_bGrabImage1Done, true, 10000, "AAA5");
            else if (intTopLightViewImageIndex == 1)
                WaitEventDone(ref m_bGrabImage2Done, true, 10000, "AAA6");
            else if (intTopLightViewImageIndex == 2)
                WaitEventDone(ref m_bGrabImage3Done, true, 10000, "AAA7");
            else if (intTopLightViewImageIndex == 3)
                WaitEventDone(ref m_bGrabImage4Done, true, 10000, "AAA8");
            else if (intTopLightViewImageIndex == 4)
                WaitEventDone(ref m_bGrabImage5Done, true, 10000, "AAA9");
            else if (intTopLightViewImageIndex == 5)
                WaitEventDone(ref m_bGrabImage6Done, true, 10000, "AAA10");
            else if (intTopLightViewImageIndex == 6)
                WaitEventDone(ref m_bGrabImage7Done, true, 10000, "AAA11");
            else
            {
                if (intUnitNo == 1)
                {
                    m_smVisionInfo.g_strErrorMessageForSecondUnit += GetUnitName(intUnitNo) + "*Package : Wrong setting for package (Top Light View) image number. intTopLightViewImageIndex = " + intTopLightViewImageIndex.ToString();
                }
                else
                {
                    m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + "*Package : Wrong setting for package (Top Light View) image number. intTopLightViewImageIndex = " + intTopLightViewImageIndex.ToString();
                }

                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 14 PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)//2020-11-11 ZJYEOH : Removed && !m_blnPassCounterAdded
                {
                    m_smVisionInfo.g_intPackageFailureTotal++;
                    m_blnFailCounterAdded = true;
                    m_blnTotalCounterAdded = false;

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 14a PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                }
                if (blnAuto)
                {
                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        if (m_intTCPIPResultID == -1)
                            SetPackageResultID(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailResultMask);
                }
                return false;
            }

            // 2022 02 16 - Hide this intTopLightViewImageIndex > 0. If silver unit, User will select image 0 for top light package also.
            //            - During orient test, system will copy ori image to rotated image object. 
            //            - rotated image will overlap with orient rotated image if no wait for orient data updated.
            // 2019 03 07 - ZJYeoh: Wait m_intOrientAngle value from StartOrientTest First
            //if (intTopLightViewImageIndex > 0)
            {
                if (intUnitNo == 0)
                    WaitEventDone(ref m_blnOrientDataUpdated1, true, 10000, "AAA12");
                else
                    WaitEventDone(ref m_blnOrientDataUpdated2, true, 10000, "AAA13");
            }

            // ---------  Rotate image 2 and 3 to oriented 0 deg -------------
            // 2019 04 30 - JBTAN: Top light view use m_smVisionInfo.g_arrPackageGauge2[0]
            if (m_objGauge_PkgTopView == null)
            {
                m_objGauge_PkgTopView = new RectGaugeM4L(m_smVisionInfo.g_WorldShape, 0, m_smVisionInfo.g_intVisionIndex);
            }

            float fGaugeCenterX = 0, fGaugeCenterY = 0, fGaugeWidth = 0, fGaugeHeight = 0, fGaugeAngle = 0;

            if (!m_smVisionInfo.g_blnWantUseSideLightGauge)
            {
                if (intTopLightViewImageIndex == 1)
                {
                    m_smVisionInfo.g_arrPackageGauge2M4L[intUnitNo].CopyTo(ref m_objGauge_PkgTopView);

                    int[] arrUserSelectImageViewIndex = m_objGauge_PkgTopView.GetGaugeImageNoList();

                    if (!WaitEventDone(arrUserSelectImageViewIndex, "AAA14"))
                    {
                        if (intUnitNo == 1)
                        {
                            m_smVisionInfo.g_strErrorMessageForSecondUnit += GetUnitName(intUnitNo) + "*Package : Wrong setting for package size image number.";
                        }
                        else
                        {
                            m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + "*Package : Wrong setting for package size image number.";
                        }

                        if (blnAuto)
                        {
                            m_smVisionInfo.g_intPackageFailureTotal++;

                            if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                                if (m_intTCPIPResultID == -1)
                                    SetPackageResultID(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailResultMask);

                        }
                        return false;
                    }

                    if (!GaugeMeasureUnit(m_objGauge_PkgTopView, m_smVisionInfo.g_arrImages, intUnitNo))
                    {
                        if (intUnitNo == 1)
                        {
                            m_smVisionInfo.g_strErrorMessageForSecondUnit += GetUnitName(intUnitNo) + "*Package : " + m_objGauge_PkgTopView.ref_strErrorMessage;
                        }
                        else
                        {
                            m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + "*Package : " + m_objGauge_PkgTopView.ref_strErrorMessage;
                        }

                        //if (blnAuto)
                        if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)//2020-11-11 ZJYEOH : Removed && !m_blnPassCounterAdded
                        {
                            m_smVisionInfo.g_intPackageFailureTotal++;
                            m_blnFailCounterAdded = true;
                            m_blnTotalCounterAdded = false;

                        }
                        if (blnAuto)
                        {
                            if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                                if (m_intTCPIPResultID == -1)
                                    SetPackageResultID(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailResultMask);
                        }
                        return false;
                    }
                }
                else
                {
                    //if (m_smVisionInfo.g_arrPackageGauge2[0] != null)
                    //{
                    //    m_smVisionInfo.g_arrPackageGauge2[intUnitNo].CopyTo(ref m_objGauge_PkgTopView);
                    //    GaugeMeasureUnit(m_objGauge_PkgTopView, m_smVisionInfo.g_arrImages[intTopLightViewImageIndex]);
                    //}
                    //else
                    {
                        m_smVisionInfo.g_arrPackageGauge2M4L[intUnitNo].CopyTo(ref m_objGauge_PkgTopView);

                        int[] arrUserSelectImageViewIndex = m_objGauge_PkgTopView.GetGaugeImageNoList();

                        if (!WaitEventDone(arrUserSelectImageViewIndex, "AAA15"))
                        {
                            if (intUnitNo == 1)
                            {
                                m_smVisionInfo.g_strErrorMessageForSecondUnit += GetUnitName(intUnitNo) + "*Package : Wrong setting for package size image number.";
                            }
                            else
                            {
                                m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + "*Package : Wrong setting for package size image number.";
                            }

                            if (blnAuto)
                            {
                                m_smVisionInfo.g_intPackageFailureTotal++;

                                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                                    if (m_intTCPIPResultID == -1)
                                        SetPackageResultID(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailResultMask);

                            }
                            return false;
                        }

                        if (!GaugeMeasureUnit(m_objGauge_PkgTopView, m_smVisionInfo.g_arrImages, intUnitNo))
                        {
                            if (intUnitNo == 1)
                            {
                                m_smVisionInfo.g_strErrorMessageForSecondUnit += GetUnitName(intUnitNo) + "*Package : " + m_objGauge_PkgTopView.ref_strErrorMessage;
                            }
                            else
                            {
                                m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + "*Package : " + m_objGauge_PkgTopView.ref_strErrorMessage;
                            }

                            if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 144 PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                            //if (blnAuto)
                            if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)//2020-11-11 ZJYEOH : Removed && !m_blnPassCounterAdded
                            {
                                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 144a PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                                m_smVisionInfo.g_intPackageFailureTotal++;
                                m_blnFailCounterAdded = true;
                                m_blnTotalCounterAdded = false;

                            }
                            if (blnAuto)
                            {
                                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                                    if (m_intTCPIPResultID == -1)
                                        SetPackageResultID(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailResultMask);
                            }
                            return false;
                        }
                    }
                }

                fGaugeCenterX = m_objGauge_PkgTopView.ref_pRectCenterPoint.X;
                fGaugeCenterY = m_objGauge_PkgTopView.ref_pRectCenterPoint.Y;
                fGaugeWidth = m_objGauge_PkgTopView.ref_fRectWidth;
                fGaugeHeight = m_objGauge_PkgTopView.ref_fRectHeight;
                fGaugeAngle = m_objGauge_PkgTopView.ref_fRectAngle;
            }
            else
            {
                if (intUnitNo == 0)
                {
                    WaitEventDone(ref m_bPackageSizeTestDone1, true, 10000, "AAA16");
                    fGaugeCenterX = m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X;
                    fGaugeCenterY = m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y;
                    fGaugeWidth = m_smVisionInfo.g_objGauge_PkgSize.ref_fRectWidth;
                    fGaugeHeight = m_smVisionInfo.g_objGauge_PkgSize.ref_fRectHeight;
                    fGaugeAngle = m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle;
                }
                else
                {
                    WaitEventDone(ref m_bPackageSizeTestDone2, true, 10000, "AAA17");
                    fGaugeCenterX = m_smVisionInfo.g_objGauge_PkgSize2.ref_pRectCenterPoint.X;
                    fGaugeCenterY = m_smVisionInfo.g_objGauge_PkgSize2.ref_pRectCenterPoint.Y;
                    fGaugeWidth = m_smVisionInfo.g_objGauge_PkgSize2.ref_fRectWidth;
                    fGaugeHeight = m_smVisionInfo.g_objGauge_PkgSize2.ref_fRectHeight;
                    fGaugeAngle = m_smVisionInfo.g_objGauge_PkgSize2.ref_fRectAngle;
                }
            }

            float fTotalRotateAngle = m_intOrientAngle + fGaugeAngle;

            // 2019 06 08 - CCENG: Add this 0.5 formula to make sure ROI attahced to image in the best way
            float fCenterX, fCenterY;
            if ((m_smVisionInfo.g_arrPackageROIs[intUnitNo][0].ref_ROIWidth % 2) == 0)
                fCenterX = (float)Math.Round(fGaugeCenterX, 0, MidpointRounding.AwayFromZero);
            else
                fCenterX = (float)Math.Floor(fGaugeCenterX) + 0.5f;

            if ((m_smVisionInfo.g_arrPackageROIs[intUnitNo][0].ref_ROIHeight % 2) == 0)
                fCenterY = (float)Math.Round(fGaugeCenterY, 0, MidpointRounding.AwayFromZero);
            else
                fCenterY = (float)Math.Floor(fGaugeCenterY) + 0.5f;

            m_objSubTh3_RotateROI.LoadROISetting(
                        (int)Math.Round(fCenterX -
                        (float)m_smVisionInfo.g_arrPackageROIs[intUnitNo][0].ref_ROIWidth / 2, 0, MidpointRounding.AwayFromZero),
                        (int)Math.Round(fCenterY -
                        (float)m_smVisionInfo.g_arrPackageROIs[intUnitNo][0].ref_ROIHeight / 2, 0, MidpointRounding.AwayFromZero),
                        m_smVisionInfo.g_arrPackageROIs[intUnitNo][0].ref_ROIWidth,
                        m_smVisionInfo.g_arrPackageROIs[intUnitNo][0].ref_ROIHeight);

            // Get RotateROI center point where the ROI center point == Unit Center Point
            //m_objSubTh3_RotateROI.LoadROISetting(
            //            (int)Math.Round(m_objGauge_PkgTopView.ref_ObjectCenterX -
            //            m_smVisionInfo.g_arrPackageROIs[intUnitNo][0].ref_ROIWidth / 2, 0, MidpointRounding.AwayFromZero),
            //            (int)Math.Round(m_objGauge_PkgTopView.ref_ObjectCenterY -
            //            m_smVisionInfo.g_arrPackageROIs[intUnitNo][0].ref_ROIHeight / 2, 0, MidpointRounding.AwayFromZero),
            //            m_smVisionInfo.g_arrPackageROIs[intUnitNo][0].ref_ROIWidth,
            //            m_smVisionInfo.g_arrPackageROIs[intUnitNo][0].ref_ROIHeight);

            if (intTopLightViewImageIndex == 0)
            {
                /* 2019 07 14 - CCENG: 
                 * if g_blnWantGauge is false, mean Image 1 is rotated according to Orient Matching Angle, which is not 100% correct,
                 * because the Orient Matching Angle and Unit Angle may be different.
                 * So when come to Image 1 package size test, Image 1 need to be re-rotated  according to Package size result angle.
                 */
                if (m_smVisionInfo.g_blnWantGauge)
                {
                    // Wait StartOrientTest rotate image 1 done or mark test done. (sometime rotate image 1 done will not set to true if Orient fail).
                    WaitEventDone(ref m_blnRotateImage1Updated, ref m_bSubTh_MarkTest, true, false, "StartPackageTest_SideLightView > m_blnRotateImage1Updated 6542");
                }
                else
                {
                    // Since Mark Test Image index and top light package view image index are same, then need to Wait for Marktest done because Rotated image need to be tested by mark inspection function. After mark inspection, then only allow to re-rotate again using packge angle.
                    WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartPackageTest > m_bSubTh_MarkTest 6547");

                    if (!m_bSubTh_MarkTest_Result)
                    {
                        return false;   // Skip package inspection if mark test fail.
                    }

                    // Rotate image 3
                    m_objSubTh3_RotateROI.AttachImage(m_smVisionInfo.g_arrImages[intTopLightViewImageIndex]);
                    ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[intTopLightViewImageIndex], m_objSubTh3_RotateROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_PkgDark, ref m_smVisionInfo.g_arrRotatedImages, intTopLightViewImageIndex);

                    if (m_blnCustomWantColor && !GetColorImageRotated(intTopLightViewImageIndex) && !ContainColorSelectedImage(intTopLightViewImageIndex, m_smVisionInfo.g_intSelectedUnit))
                    {
                        CROI objColorRotatedROI = new CROI();
                        objColorRotatedROI.AttachImage(m_smVisionInfo.g_arrColorImages[intTopLightViewImageIndex]);

                        // Get RotateROI center point where the ROI center point == Package Unit Center Point
                        objColorRotatedROI.LoadROISetting(m_objSubTh3_RotateROI.ref_ROIPositionX,
                                                     m_objSubTh3_RotateROI.ref_ROIPositionY,
                                                     m_objSubTh3_RotateROI.ref_ROIWidth,
                                                     m_objSubTh3_RotateROI.ref_ROIHeight);

                        CROI.Rotate0Degree(m_smVisionInfo.g_arrColorImages[intTopLightViewImageIndex], objColorRotatedROI, fTotalRotateAngle, 4, ref m_smVisionInfo.g_arrColorRotatedImages, intTopLightViewImageIndex);

                        SetColorImageRotated(intTopLightViewImageIndex);
                        objColorRotatedROI.Dispose();
                    }
                }
            }
            else
            {
                // Rotate image 3
                m_objSubTh3_RotateROI.AttachImage(m_smVisionInfo.g_arrImages[intTopLightViewImageIndex]);
                //ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[intTopLightViewImageIndex], m_objSubTh3_RotateROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_PkgDark, ref m_smVisionInfo.g_arrRotatedImages, intTopLightViewImageIndex);

                // Rotate image 3
                m_objSubTh3_RotateROI.AttachImage(m_smVisionInfo.g_arrImages[intTopLightViewImageIndex]);
                ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[intTopLightViewImageIndex], m_objSubTh3_RotateROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_PkgDark, ref m_smVisionInfo.g_arrRotatedImages, intTopLightViewImageIndex);

                if (m_blnCustomWantColor && !GetColorImageRotated(intTopLightViewImageIndex) && !ContainColorSelectedImage(intTopLightViewImageIndex, m_smVisionInfo.g_intSelectedUnit))
                {
                    CROI objColorRotatedROI = new CROI();
                    objColorRotatedROI.AttachImage(m_smVisionInfo.g_arrColorImages[intTopLightViewImageIndex]);

                    // Get RotateROI center point where the ROI center point == Package Unit Center Point
                    objColorRotatedROI.LoadROISetting(m_objSubTh3_RotateROI.ref_ROIPositionX,
                                                 m_objSubTh3_RotateROI.ref_ROIPositionY,
                                                 m_objSubTh3_RotateROI.ref_ROIWidth,
                                                 m_objSubTh3_RotateROI.ref_ROIHeight);

                    CROI.Rotate0Degree(m_smVisionInfo.g_arrColorImages[intTopLightViewImageIndex], objColorRotatedROI, fTotalRotateAngle, 4, ref m_smVisionInfo.g_arrColorRotatedImages, intTopLightViewImageIndex);

                    SetColorImageRotated(intTopLightViewImageIndex);
                    objColorRotatedROI.Dispose();
                }

            }

            if (intTopLightViewImageIndex == 0)
                m_blnRotateImage1Updated = true;
            else if (intTopLightViewImageIndex == 1)
                m_blnRotateImage2Updated = true;
            else if (intTopLightViewImageIndex == 2)
                m_blnRotateImage3Updated = true;
            else if (intTopLightViewImageIndex == 3)
                m_blnRotateImage4Updated = true;
            else if (intTopLightViewImageIndex == 4)
                m_blnRotateImage5Updated = true;
            else if (intTopLightViewImageIndex == 5)
                m_blnRotateImage6Updated = true;
            else
                m_blnRotateImage7Updated = true;

            // Wait mark inspection done.
            if (intUnitNo == 0)
            {
                WaitEventDone(ref m_bMarkTestDone1, true, 10000, "AAA18");    //m_bSubTh_MarkTest,false// need to wait for mark inspection done. Because package size fail should not display error msg if mark fail.
                if (!m_bSubTh_MarkTest_Result)
                {
                    return false;   // Skip package counter if mark fail because counter will add to mark
                }
            }
            else
            {
                WaitEventDone(ref m_bMarkTestDone2, true, 10000, "AAA19");    //m_bSubTh_MarkTest,false// need to wait for mark inspection done. Because package size fail should not display error msg if mark fail.
                if (!m_bSubTh_MarkTest_Result2)
                {
                    return false;   // Skip package counter if mark fail because counter will add to mark
                }
            }

            // Wait package test done under mark light view 
            WaitEventDone(ref m_bSubTh_PackageTest_MarkLightView, false, 10000, "AAA20");
            if (intUnitNo == 0)
            {
                if (!m_bSubTh_PackageTest_MarkLightView_Result)
                {
                    return false;
                }
            }
            else
            {
                if (!m_bSubTh_PackageTest_MarkLightView_Result2)
                {
                    return false;
                }
            }
            // Wait SideLightView Package done because using same database (array)
            //WaitEventDone(ref m_bSubTh_PackageTest_SideLightView, false);
            //if (!m_bSubTh_PackageTest_SideLightView_Result)
            //{
            //    return false;
            //}

            m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnViewUnitPosition = true;
            //m_smVisionInfo.g_arrPackage[intUnitNo].ClearDontCareAreaArray();//2020-12-28 ZJYEOH : Only StartPackageTest_MarkLightView will use this dont care

            // ------- Copy image to temporary inspection image.
            if (intTopLightViewImageIndex >= 0)
            {
                if (m_objPkgViewImage2 == null)
                    m_objPkgViewImage2 = new ImageDrawing(true);
                m_smVisionInfo.g_arrImages[intTopLightViewImageIndex].CopyTo(ref m_objPkgViewImage2);
            }
            else if (m_objPkgViewImage2 != null)
                m_objPkgViewImage2 = null;

            //if (intTopLightViewImageIndex >= 0)
            //{
            //    if (m_objVoidViewImage == null)
            //        m_objVoidViewImage = new ImageDrawing(true);
            //    m_smVisionInfo.g_arrImages[intTopLightViewImageIndex].CopyTo(ref m_objVoidViewImage);
            //}
            //else if (m_objVoidViewImage != null)
            //    m_objVoidViewImage = null;

            if (intTopLightViewImageIndex >= 0)
            {
                if (m_objCrackViewImage == null)
                    m_objCrackViewImage = new ImageDrawing(true);
                m_smVisionInfo.g_arrImages[intTopLightViewImageIndex].CopyTo(ref m_objCrackViewImage);
            }
            else if (m_objCrackViewImage != null)
                m_objCrackViewImage = null;

            bool blnWantMark = false;
            int intCharDilateHalfWidth = 2;
            if (m_smVisionInfo.g_arrMarks != null && m_smVisionInfo.g_arrMarks.Count > 0)
            {
                // 2020 04 15 - JBTAN: will continue to check mark even option uncheck check mark option
                // 2020 07 08 - Roll back to previous method, wont check mark if Mark Checking is not selected.
                blnWantMark = m_smVisionInfo.g_arrMarks[intUnitNo].ref_blnCheckMark;
                //blnWantMark = true;
                intCharDilateHalfWidth = m_smVisionInfo.g_arrMarks[intUnitNo].ref_intCharDilateHalfWidth; // thick iteration
            }

            //2020-05-18 ZJYEOH : Get another Image without subtract mark area
            //2020-05-18 ZJYEOH : Get another Image without subtract mark area
            if (m_smVisionInfo.g_intPackageDefectInspectionMethod != 0)
            {
                m_objCrackViewImage.CopyTo(ref m_objGrayValueImage_TopLight);
            }
            
            if (blnWantMark)
            {
                // ---------- Fill Mark Image's mark area with black color -------------------
                int intNumChars = m_smVisionInfo.g_arrMarks[intUnitNo].GetNumChars();
                int intStartX = 0, intStartY = 0, intEndX = 0, intEndY = 0;

                int intOffsetX;
                int intOffsetY;

                if (m_smVisionInfo.g_blnWantGauge)  // Mean during mark inspection, orient gauge is used to measure unit position for m_objMarkTrainROI
                {
                    if (intUnitNo == 0)
                    {
                        intOffsetX = m_objMarkTrainROI.ref_ROITotalX;
                        intOffsetY = m_objMarkTrainROI.ref_ROITotalY;
                    }
                    else
                    {
                        intOffsetX = m_pMarkTrainROIPoint_Unit2.X;
                        intOffsetY = m_pMarkTrainROIPoint_Unit2.Y;
                    }
                }
                else if (m_smVisionInfo.g_arrMarkROIs[intUnitNo].Count > 3)    // Mean during mark inspection, Unit PR is used to find unit surface position for m_objMarkTrainROI
                {
                    if (intUnitNo == 0)
                    {
                        intOffsetX = m_objMarkTrainROI.ref_ROITotalX;
                        intOffsetY = m_objMarkTrainROI.ref_ROITotalY;
                    }
                    else
                    {
                        intOffsetX = m_pMarkTrainROIPoint_Unit2.X;
                        intOffsetY = m_pMarkTrainROIPoint_Unit2.Y;
                    }
                }
                else // Mean during mark inspection, m_objMarkSearchROI is used.
                {
                    if (intUnitNo == 0)
                    {
                        intOffsetX = m_objMarkTrainROI.ref_ROITotalX;
                        intOffsetY = m_objMarkTrainROI.ref_ROITotalY;
                    }
                    else
                    {
                        intOffsetX = m_pMarkTrainROIPoint_Unit2.X;
                        intOffsetY = m_pMarkTrainROIPoint_Unit2.Y;
                    }
                }

                float fTotalRotateMarkAngle;
                if (m_smVisionInfo.g_arrMarks[intUnitNo].ref_blnCheckMark)
                {
                    fTotalRotateMarkAngle = m_intOrientAngle + m_smVisionInfo.g_arrOrients[intUnitNo][m_smVisionInfo.g_intSelectedOcv[0]].ref_fDegAngleResult;
                }
                else
                {
                    fTotalRotateMarkAngle = fTotalRotateAngle;
                }
                for (int i = 0; i < intNumChars; i++)
                {
                    int intRectStartX, intRectStartY, intRectEndX, intRectEndY;
                    intRectStartX = intRectStartY = intRectEndX = intRectEndY = 0;
                    m_smVisionInfo.g_arrMarks[intUnitNo].GetCharStartXY(i, ref intStartX, ref intStartY);
                    m_smVisionInfo.g_arrMarks[intUnitNo].GetCharEndXY(i, ref intEndX, ref intEndY);

                    if (m_smVisionInfo.g_arrMarks[intUnitNo].ref_blnWantDontCareIgnoredMarkWholeArea && !m_smVisionInfo.g_arrMarks[intUnitNo].GetEnableMarkSetting(i))
                    {
                        //2021-01-18 ZJYEOH : Should use sample position
                        Point pStartTemplate = new Point(intStartX, intStartY);//m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharROIStartPoint(i);
                        Point pEndTemplate = new Point(intEndX, intEndY);//m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharROIEndPoint(i);

                        if ((intOffsetX + pStartTemplate.X - m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftX(i)) >= 0)
                            intRectStartX = intOffsetX + pStartTemplate.X - m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftX(i);
                        else
                            intRectStartX = intOffsetX;

                        if ((intOffsetY + pStartTemplate.Y - m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftY(i)) >= 0)
                            intRectStartY = intOffsetY + pStartTemplate.Y - m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftY(i);
                        else
                            intRectStartY = intOffsetY;

                        if ((intOffsetX + pEndTemplate.X + m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftX(i)) < m_smVisionInfo.g_intCameraResolutionWidth)
                            intRectEndX = intOffsetX + pEndTemplate.X + m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftX(i);
                        else
                            continue;
                        if ((intOffsetY + pEndTemplate.Y + m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftY(i)) < m_smVisionInfo.g_intCameraResolutionHeight)
                            intRectEndY = intOffsetY + pEndTemplate.Y + m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftY(i);
                        else
                            continue;
                    }
                    else
                    {
                        if ((intStartX - intCharDilateHalfWidth) >= 0)
                            intRectStartX = intOffsetX + intStartX - intCharDilateHalfWidth;
                        else
                            intRectStartX = intOffsetX;

                        if ((intStartY - intCharDilateHalfWidth) >= 0)
                            intRectStartY = intOffsetY + intStartY - intCharDilateHalfWidth;
                        else
                            intRectStartY = intOffsetY;

                        if ((intEndX + intCharDilateHalfWidth) < m_smVisionInfo.g_intCameraResolutionWidth)
                            intRectEndX = intOffsetX + intEndX + intCharDilateHalfWidth;
                        else
                            intRectEndX = intOffsetX + intEndX;

                        if ((intEndY + intCharDilateHalfWidth) < m_smVisionInfo.g_intCameraResolutionHeight)
                            intRectEndY = intOffsetY + intEndY + intCharDilateHalfWidth;
                        else
                            intRectEndY = intOffsetY + intEndY;
                    }

                    if (m_smVisionInfo.g_arrMarks[intUnitNo].ref_blnWantCheckBarPin1)
                    {
                        bool blnIsBarPin1 = m_smVisionInfo.g_arrMarks[intUnitNo].GetCharIsBarPin1(m_smVisionInfo.g_arrMarks[0].ref_intGroupIndex, m_smVisionInfo.g_arrMarks[0].ref_intTemplateIndex, i);
                        int intBarPin1Type = m_smVisionInfo.g_arrMarks[intUnitNo].GetCharBarPin1Type(m_smVisionInfo.g_arrMarks[0].ref_intGroupIndex, m_smVisionInfo.g_arrMarks[0].ref_intTemplateIndex, i);

                        //2020-05-28 ZJYEOH : extend the dont care area to fit the m_objMarkTrainROI size
                        if (blnIsBarPin1 && !m_smVisionInfo.g_blnWantCheckBarPin1)
                        {
                            if (intBarPin1Type == 0) // Virtical bar
                            {
                                //if (intRectStartY > intOffsetY)
                                //    intRectStartY = intOffsetY;
                                //if (intRectEndY < intOffsetY + m_objMarkTrainROI.ref_ROIHeight)
                                //    intRectEndY = intOffsetY + m_objMarkTrainROI.ref_ROIHeight;
                                if (intUnitNo == 0)
                                {
                                    intRectStartY = intOffsetY;
                                    intRectEndY = intOffsetY + m_objMarkTrainROI.ref_ROIHeight;
                                }
                                else
                                {
                                    intRectStartY = intOffsetY;
                                    intRectEndY = intOffsetY + m_sMarkTrainROISize_Unit2.Height;
                                }
                            }
                            else if (intBarPin1Type == 1) // Horizontal bar
                            {
                                //if (intRectStartX > intOffsetX)
                                //    intRectStartX = intOffsetX;
                                //if (intRectEndX < intOffsetX + m_objMarkTrainROI.ref_ROIWidth)
                                //    intRectEndX = intOffsetX + m_objMarkTrainROI.ref_ROIWidth;
                                if (intUnitNo == 0)
                                {
                                    intRectStartX = intOffsetX;
                                    intRectEndX = intOffsetX + m_objMarkTrainROI.ref_ROIWidth;
                                }
                                else
                                {
                                    intRectStartX = intOffsetX;
                                    intRectEndX = intOffsetX + m_sMarkTrainROISize_Unit2.Width;
                                }
                            }
                        }
                    }

                    if (blnWantDebug)
                    {
                        m_objPkgViewImage2.SaveImage("D:\\TS\\1.m_objPkgViewImage2" + i.ToString() + ".bmp");
                    }

                    float newSX = 0, newSY = 0, newEX = 0, newEY = 0;
                    Math2.GetNewXYAfterRotate_360deg((intRectEndX + intRectStartX) / 2, (intRectEndY + intRectStartY) / 2, intRectStartX, intRectStartY, -(fTotalRotateMarkAngle), ref newSX, ref newSY);

                    Math2.GetNewXYAfterRotate_360deg((intRectEndX + intRectStartX) / 2, (intRectEndY + intRectStartY) / 2, intRectEndX, intRectEndY, -(fTotalRotateMarkAngle), ref newEX, ref newEY);
                    Point pStart = new Point((int)Math.Round(newSX), (int)Math.Round(newSY));
                    Point pEnd = new Point((int)Math.Round(newEX), (int)Math.Round(newEY));

                    List<Point> arrPoints = new List<Point>();
                    arrPoints.Add(pStart);
                    arrPoints.Add(new Point(pStart.X + (pEnd.X - pStart.X), pStart.Y));
                    arrPoints.Add(pEnd);
                    arrPoints.Add(new Point(pStart.X, pStart.Y + (pEnd.Y - pStart.Y)));

                    //PointF pTemp = new PointF();
                    //Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
                    //                                 arrPoints[0],
                    //                                 (fTotalRotateMarkAngle),
                    //                                 ref pTemp);
                    //arrPoints[0] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));
                    ////arrPoints.Add(new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y)));
                    //Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
                    //                                 arrPoints[1],
                    //                                 (fTotalRotateMarkAngle),
                    //                                 ref pTemp);
                    //arrPoints[1] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

                    //Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
                    //                                 arrPoints[2],
                    //                                 (fTotalRotateMarkAngle),
                    //                                 ref pTemp);
                    //arrPoints[2] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

                    //Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
                    //                                 arrPoints[3],
                    //                                 (fTotalRotateMarkAngle),
                    //                                 ref pTemp);
                    //arrPoints[3] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

                    if (intTopLightViewImageIndex >= 0 && !m_smVisionInfo.g_blnWantCheckVoidOnMarkArea)
                    {
                        //Shape.FillRectangle(m_objPkgViewImage2, intRectStartX, intRectStartY, intRectEndX, intRectEndY, 255);
                        //Shape.FillPolygonWithScale(m_objPkgViewImage2, arrPoints, 255, 1.0f, 1.0f, 0, 0);
                        DontCareWithoutRotateImage.ProduceImage(arrPoints, m_objPkgViewImage2, m_smVisionInfo.g_objWhiteImage, m_smVisionInfo.g_objBlackImage, fTotalRotateMarkAngle, true);
                    }

                    //2020-11-16 ZJYEOH : Direct use m_objPkgViewImage2 copy to them after done dont care
                    //if (intTopLightViewImageIndex >= 0 && !m_smVisionInfo.g_blnWantCheckVoidOnMarkArea)
                    //{
                    //    //Shape.FillRectangle(m_objCrackViewImage, intRectStartX, intRectStartY, intRectEndX, intRectEndY, 255);
                    //    Shape.FillPolygonWithScale(m_objCrackViewImage, arrPoints, 255, 1.0f, 1.0f, 0, 0);
                    //}
                    //if (intTopLightViewImageIndex >= 0 && !m_smVisionInfo.g_blnWantCheckVoidOnMarkArea)
                    //{
                    //    //Shape.FillRectangle(m_objVoidViewImage, intRectStartX, intRectStartY, intRectEndX, intRectEndY, 255);
                    //    Shape.FillPolygonWithScale(m_objVoidViewImage, arrPoints, 255, 1.0f, 1.0f, 0, 0);
                    //}

                    if (blnWantDebug)
                    {
                        m_objPkgViewImage2.SaveImage("D:\\TS\\2.m_objPkgViewImage2" + i.ToString() + ".bmp");
                    }

                    //m_smVisionInfo.g_arrPackage[intUnitNo].SetDontCareArea(intRectStartX, intRectStartY, intRectEndX, intRectEndY);//2020-12-28 ZJYEOH : Only StartPackageTest_MarkLightView will use this dont care

                }
            }
           
            //if (intTopLightViewImageIndex >= 0)
            //{
            //    if (m_objVoidViewImage == null)
            //        m_objVoidViewImage = new ImageDrawing(true);
            //    m_objPkgViewImage2.CopyTo(ref m_objVoidViewImage);
            //}
            //else if (m_objVoidViewImage != null)
            //    m_objVoidViewImage = null;

            if (intTopLightViewImageIndex >= 0)
            {
                if (m_objCrackViewImage == null)
                    m_objCrackViewImage = new ImageDrawing(true);
                m_objPkgViewImage2.CopyTo(ref m_objCrackViewImage);
            }
            else if (m_objCrackViewImage != null)
                m_objCrackViewImage = null;
            
            //2020-11-16 ZJYEOH : Wait after done care done as dont care consume time
            //Wait SideLightView Package done because using same database (array)
           WaitEventDone(ref m_bSubTh_PackageTest_SideLightView, false, 10000, "AAA21");

            if (intUnitNo == 0)
            {
                if (!m_bSubTh_PackageTest_SideLightView_Result)
                {
                    return false;
                }
            }
            else
            {
                if (!m_bSubTh_PackageTest_SideLightView_Result2)
                {
                    return false;
                }
            }

            if (blnWantDebug)
            {
                m_objPkgViewImage2.SaveImage("D:\\TS\\3.m_objPkgViewImage2.bmp");
            }

            List<PointF> arrChippedROIPoints = new List<PointF>();
            ROI objChipUnitROI2 = null; // Image 3 - Chip ROI
            if (intTopLightViewImageIndex >= 0)
            {
                objChipUnitROI2 = new ROI();

                // 2019 06 08 - CCENG: +1 pixel to start point and -1 pixel to size. This is To avoid unit long chamfer affecting result.
                //objChipUnitROI2.LoadROISetting((int)Math.Round((m_objGauge_PkgTopView.ref_ObjectCenterX - m_objGauge_PkgTopView.ref_ObjectWidth / 2), 0, MidpointRounding.AwayFromZero),
                //                               (int)Math.Round((m_objGauge_PkgTopView.ref_ObjectCenterY - m_objGauge_PkgTopView.ref_ObjectHeight / 2), 0, MidpointRounding.AwayFromZero),
                //                               (int)Math.Round(m_objGauge_PkgTopView.ref_ObjectWidth, 0, MidpointRounding.AwayFromZero),
                //                               (int)Math.Round(m_objGauge_PkgTopView.ref_ObjectHeight, 0, MidpointRounding.AwayFromZero));
                //objChipUnitROI2.LoadROISetting(1 + (int)Math.Round((fGaugeCenterX - fGaugeWidth / 2), 0, MidpointRounding.AwayFromZero),
                //                               1 + (int)Math.Round((fGaugeCenterY - fGaugeHeight / 2), 0, MidpointRounding.AwayFromZero),
                //                               (int)Math.Round(fGaugeWidth - 1, 0, MidpointRounding.AwayFromZero),
                //                               (int)Math.Round(fGaugeHeight - 1, 0, MidpointRounding.AwayFromZero));
                objChipUnitROI2.LoadROISetting(1 + (int)Math.Round((fGaugeCenterX - fGaugeWidth / 2) + m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelExtendFromLeft_Chip_Dark, 0, MidpointRounding.AwayFromZero),
                                        1 + (int)Math.Round((fGaugeCenterY - fGaugeHeight / 2) + m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelExtendFromEdge_Chip_Dark, 0, MidpointRounding.AwayFromZero),
                                        (int)Math.Round(fGaugeWidth - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelExtendFromLeft_Chip_Dark - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelExtendFromRight_Chip_Dark - 1, 0, MidpointRounding.AwayFromZero),
                                        (int)Math.Round(fGaugeHeight - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelExtendFromEdge_Chip_Dark - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelExtendFromBottom_Chip_Dark - 1, 0, MidpointRounding.AwayFromZero));

                // Use pkg image for chip test as priority
                objChipUnitROI2.AttachImage(m_objPkgViewImage2);
                if (m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateChippedOffDefectSetting)
                {
                    PointF pStart = new PointF(objChipUnitROI2.ref_ROITotalX, objChipUnitROI2.ref_ROITotalY);
                    PointF pEnd = new PointF(objChipUnitROI2.ref_ROITotalX + objChipUnitROI2.ref_ROIWidth, objChipUnitROI2.ref_ROITotalY + objChipUnitROI2.ref_ROIHeight);
                    List<PointF> arrPoints = new List<PointF>(); // 0:Top Left, 1: Top Right, 2:Bottom Left, 3:Bottom Right
                    arrPoints.Add(new PointF(pStart.X, pStart.Y));
                    arrPoints.Add(new PointF(pEnd.X, pStart.Y));
                    arrPoints.Add(new PointF(pStart.X, pEnd.Y));
                    arrPoints.Add(new PointF(pEnd.X, pEnd.Y));

                    //m_objMarkTrainROI.SaveImage("D:\\m_objMarkTrainROI1.bmp");

                    PointF pTemp = new PointF();
                    Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2,
                                                     (pEnd.Y + pStart.Y) / 2,
                                                     arrPoints[0],
                                                     (fGaugeAngle + (m_intOrientAngle)),
                                                     ref pTemp);
                    arrPoints[0] = pTemp;

                    Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2,
                                                     (pEnd.Y + pStart.Y) / 2,
                                                     arrPoints[1],
                                                     (fGaugeAngle + (m_intOrientAngle)),
                                                     ref pTemp);
                    arrPoints[1] = pTemp;

                    Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2,
                                                     (pEnd.Y + pStart.Y) / 2,
                                                     arrPoints[2],
                                                     (fGaugeAngle + (m_intOrientAngle)),
                                                     ref pTemp);
                    arrPoints[2] = pTemp;

                    Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2,
                                                     (pEnd.Y + pStart.Y) / 2,
                                                     arrPoints[3],
                                                     (fGaugeAngle + (m_intOrientAngle)),
                                                     ref pTemp);
                    arrPoints[3] = pTemp;
                    arrChippedROIPoints = arrPoints;
                    DontCareWithoutRotateImage.ProduceImage(arrPoints, objChipUnitROI2, m_objPkgViewImage2
                        , m_smVisionInfo.g_objBlackWhiteTopImage, m_smVisionInfo.g_objBlackWhiteRightImage, m_smVisionInfo.g_objBlackWhiteBottomImage, m_smVisionInfo.g_objBlackWhiteLeftImage, true);
                }
            }

            //ROI objVoidUnitROI = null; // Image 3 - Void ROI
            //if (intTopLightViewImageIndex >= 0)
            //{
            //    objVoidUnitROI = new ROI();
            //    objVoidUnitROI.LoadROISetting((int)Math.Round((fGaugeCenterX -
            //                    fGaugeWidth / 2 +
            //                    m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeft), 0, MidpointRounding.AwayFromZero),
            //                    (int)Math.Round((fGaugeCenterY -
            //                    fGaugeHeight / 2 +
            //                    m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdge), 0, MidpointRounding.AwayFromZero),
            //                    (int)Math.Round(fGaugeWidth - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromRight - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeft, 0, MidpointRounding.AwayFromZero),
            //                    (int)Math.Round(fGaugeHeight - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdge - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromBottom, 0, MidpointRounding.AwayFromZero));


            //    objVoidUnitROI.AttachImage(m_objVoidViewImage);
            //}

            ROI objCrackViewROI = null; // Image 3 - Crack ROI
            if (intTopLightViewImageIndex >= 0)
            {
                //RectGauge objGauge2 = m_smVisionInfo.g_arrPackageGauge[intUnitNo];

                objCrackViewROI = new ROI();
                if (m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateBrightDarkROITolerance)
                {
                    objCrackViewROI.LoadROISetting((int)Math.Round((fGaugeCenterX -
                                fGaugeWidth / 2 +
                                m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeft_Dark), 0, MidpointRounding.AwayFromZero),
                                (int)Math.Round((fGaugeCenterY -
                                fGaugeHeight / 2 +
                                m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdge_Dark), 0, MidpointRounding.AwayFromZero),
                                (int)Math.Round(fGaugeWidth - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromRight_Dark - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeft_Dark, 0, MidpointRounding.AwayFromZero),
                                (int)Math.Round(fGaugeHeight - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdge_Dark - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromBottom_Dark, 0, MidpointRounding.AwayFromZero));
                }
                else
                {
                    objCrackViewROI.LoadROISetting((int)Math.Round((fGaugeCenterX -
                                fGaugeWidth / 2 +
                                m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeft), 0, MidpointRounding.AwayFromZero),
                                (int)Math.Round((fGaugeCenterY -
                                fGaugeHeight / 2 +
                                m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdge), 0, MidpointRounding.AwayFromZero),
                                (int)Math.Round(fGaugeWidth - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromRight - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeft, 0, MidpointRounding.AwayFromZero),
                                (int)Math.Round(fGaugeHeight - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdge - m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromBottom, 0, MidpointRounding.AwayFromZero));
                }
                objCrackViewROI.AttachImage(m_objCrackViewImage);

                PointF pStart = new PointF(objCrackViewROI.ref_ROITotalX, objCrackViewROI.ref_ROITotalY);
                PointF pEnd = new PointF(objCrackViewROI.ref_ROITotalX + objCrackViewROI.ref_ROIWidth, objCrackViewROI.ref_ROITotalY + objCrackViewROI.ref_ROIHeight);
                List<PointF> arrPoints = new List<PointF>(); // 0:Top Left, 1: Top Right, 2:Bottom Left, 3:Bottom Right
                arrPoints.Add(new PointF(pStart.X, pStart.Y));
                arrPoints.Add(new PointF(pEnd.X, pStart.Y));
                arrPoints.Add(new PointF(pStart.X, pEnd.Y));
                arrPoints.Add(new PointF(pEnd.X, pEnd.Y));

                //m_objMarkTrainROI.SaveImage("D:\\m_objMarkTrainROI1.bmp");

                PointF pTemp = new PointF();
                Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2,
                                                 (pEnd.Y + pStart.Y) / 2,
                                                 arrPoints[0],
                                                 (fGaugeAngle + (m_intOrientAngle)),
                                                 ref pTemp);
                arrPoints[0] = pTemp;

                Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2,
                                                 (pEnd.Y + pStart.Y) / 2,
                                                 arrPoints[1],
                                                 (fGaugeAngle + (m_intOrientAngle)),
                                                 ref pTemp);
                arrPoints[1] = pTemp;

                Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2,
                                                 (pEnd.Y + pStart.Y) / 2,
                                                 arrPoints[2],
                                                 (fGaugeAngle + (m_intOrientAngle)),
                                                 ref pTemp);
                arrPoints[2] = pTemp;

                Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2,
                                                 (pEnd.Y + pStart.Y) / 2,
                                                 arrPoints[3],
                                                 (fGaugeAngle + (m_intOrientAngle)),
                                                 ref pTemp);
                arrPoints[3] = pTemp;
                
                DontCareWithoutRotateImage.ProduceImage(arrPoints, objCrackViewROI, m_objCrackViewImage
                    , m_smVisionInfo.g_objBlackWhiteTopImage, m_smVisionInfo.g_objBlackWhiteRightImage, m_smVisionInfo.g_objBlackWhiteBottomImage, m_smVisionInfo.g_objBlackWhiteLeftImage, true);
            }

            if (m_smVisionInfo.g_blnWantDontCareArea_Package)
            {
                if (intTopLightViewImageIndex >= 0)
                {
                    ////Draw don't care ROI edge to make sure Don't Care Area is not inspected
                    //for (int k = 3; k < m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit].Count; k++)
                    //{
                    //    m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][k].AttachImage(objCrackViewROI);
                    //    ROI objROI = new ROI();
                    //    objROI.LoadROISetting((int)Math.Round((fGaugeCenterX - fGaugeWidth / 2 + m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][k].ref_ROIPositionX), 0, MidpointRounding.AwayFromZero),
                    //                          (int)Math.Round((fGaugeCenterY - fGaugeHeight / 2 + m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][k].ref_ROIPositionY), 0, MidpointRounding.AwayFromZero),
                    //                           m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][k].ref_ROIWidth, m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][k].ref_ROIHeight);
                    //    objROI.AttachImage(m_smVisionInfo.g_objWhiteImage);
                    //    ROI.LogicOperationAddROI(m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][k], objROI);
                    //    //objCrackViewROI.SaveImage("D:\\aaa.bmp");
                    //    objROI.Dispose();
                    //}

                    ROI objDontCareROI = new ROI();
                    //objDontCareROI.LoadROISetting(0, 0, objCrackViewROI.ref_ROIWidth, objCrackViewROI.ref_ROIHeight);
                    // 2020 06 27 - CCENG: objDontCareROI have to start from Package Tolerance bcos g_objDontCareImage_Package_Dark template is start from Package Size Template.
                    if (m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateBrightDarkROITolerance)
                    {
                        objDontCareROI.LoadROISetting(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeft_Dark,
                              m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdge_Dark,
                              objCrackViewROI.ref_ROIWidth, objCrackViewROI.ref_ROIHeight);
                    }
                    else
                    {
                        objDontCareROI.LoadROISetting(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeft,
                              m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdge,
                              objCrackViewROI.ref_ROIWidth, objCrackViewROI.ref_ROIHeight);
                    }
                    objDontCareROI.AttachImage(m_smVisionInfo.g_objDontCareImage_Package_Dark);
                    ImageDrawing objImgDontCare = new ImageDrawing(true, m_smVisionInfo.g_objDontCareImage_Package_Dark.ref_intImageWidth, m_smVisionInfo.g_objDontCareImage_Package_Dark.ref_intImageHeight);
                    ROI.Rotate0Degree_Better(m_smVisionInfo.g_objDontCareImage_Package_Dark, objDontCareROI, -fTotalRotateAngle, 4, ref objImgDontCare);
                    objDontCareROI.AttachImage(objImgDontCare);
                    ROI.LogicOperationAddROI(objCrackViewROI, objDontCareROI);
                    //objCrackViewROI.SaveImage("D:\\aaa.bmp");
                    objDontCareROI.Dispose();
                    objImgDontCare.Dispose();
                }
            }
            if (m_smVisionInfo.g_intPackageDefectInspectionMethod == 0)
            {
                if (!m_smVisionInfo.g_arrPackage[intUnitNo].DoInspection_TopLightView(//m_objGauge_PkgTopView,   // use to measure unit edge
                                                    fGaugeCenterX, fGaugeCenterY,
                                                    fGaugeWidth, fGaugeHeight,
                                                    objCrackViewROI,            // Crack test
                                                    objChipUnitROI2,            // Chipped off test on image 3
                                                    //objVoidUnitROI, // Void Test using Image 3
                                                    m_smVisionInfo.g_arrImages[intTopLightViewImageIndex],       // Image from Top light source
                                                    arrChippedROIPoints,
                                                    m_smVisionInfo.g_objWhiteImage,
                                                    m_smVisionInfo.g_objBlackImage,
                                                    fGaugeAngle + (m_intOrientAngle),
                                                    m_smVisionInfo.g_objBlackWhiteTopImage, m_smVisionInfo.g_objBlackWhiteRightImage, m_smVisionInfo.g_objBlackWhiteBottomImage, m_smVisionInfo.g_objBlackWhiteLeftImage))
                {
                    if (intUnitNo == 1)
                    {
                        m_smVisionInfo.g_strErrorMessageForSecondUnit += GetUnitName(intUnitNo) + m_smVisionInfo.g_arrPackage[intUnitNo].ref_strErrorMessage;
                    }
                    else
                    {
                        m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + m_smVisionInfo.g_arrPackage[intUnitNo].ref_strErrorMessage;
                    }

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 15 PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());

                    if (blnAuto)
                    {
                        SaveRejectImage_AddToBuffer("PackageDefect", m_smVisionInfo.g_arrPackage[intUnitNo].ref_strErrorMessage);
                    }

                    if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                    {
                        if (!m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        {
                            m_objVisionIO.PackageFail.SetOn("V4 PackageFail 3");
                        }
                        //SaveRejectImage_AddToBuffer("PackageDefect", m_smVisionInfo.g_arrPackage[intUnitNo].ref_strErrorMessage);

                        m_smVisionInfo.g_intPkgDefectFailureTotal++;
                        //m_smVisionInfo.g_intTestedTotal++;
                        //m_smVisionInfo.g_intLowYieldUnitCount++;
                        m_blnFailCounterAdded = true;
                        m_blnTotalCounterAdded = false;
                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 15a PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                    }
                    if (blnAuto)
                    {
                        if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        {
                            m_blnPackageFail_Out = true;
                            if (m_intTCPIPResultID == -1)
                                SetPackageResultID(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailResultMask);
                        }
                    }
                    blnResult = false;
                }
            }
            else
            {
                if (!m_smVisionInfo.g_arrPackage[intUnitNo].DoInspection_TopLightView_GrayValueThresholdMethod(//m_objGauge_PkgTopView,   // use to measure unit edge
                                                    fGaugeCenterX, fGaugeCenterY,
                                                    fGaugeWidth, fGaugeHeight,
                                                    objCrackViewROI,            // Crack test
                                                    objChipUnitROI2,            // Chipped off test on image 3
                                                    //objVoidUnitROI, // Void Test using Image 3
                                                    m_smVisionInfo.g_arrImages[intTopLightViewImageIndex],       // Image from Top light source
                                                     m_objGrayValueImage_TopLight,
                                                   m_smVisionInfo.g_intPackageInspectionAreaGrayValueSensitivity,
                                                   m_smVisionInfo.g_intPackageMergeSensitivity,
                                                  m_smVisionInfo.g_intPackageDarkSensitivity, arrChippedROIPoints,
                                                    m_smVisionInfo.g_objWhiteImage,
                                                    m_smVisionInfo.g_objBlackImage,
                                                    fGaugeAngle + (m_intOrientAngle),
                                                    m_smVisionInfo.g_objBlackWhiteTopImage, m_smVisionInfo.g_objBlackWhiteRightImage, m_smVisionInfo.g_objBlackWhiteBottomImage, m_smVisionInfo.g_objBlackWhiteLeftImage))
                {
                    if (intUnitNo == 1)
                    {
                        m_smVisionInfo.g_strErrorMessageForSecondUnit += GetUnitName(intUnitNo) + m_smVisionInfo.g_arrPackage[intUnitNo].ref_strErrorMessage;
                    }
                    else
                    {
                        m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + m_smVisionInfo.g_arrPackage[intUnitNo].ref_strErrorMessage;
                    }

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 15 PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());

                    if (blnAuto)
                    {
                        SaveRejectImage_AddToBuffer("PackageDefect", m_smVisionInfo.g_arrPackage[intUnitNo].ref_strErrorMessage);
                    }

                    if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                    {
                        if (!m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        {
                            m_objVisionIO.PackageFail.SetOn("V4 PackageFail 3");
                        }
                        //SaveRejectImage_AddToBuffer("PackageDefect", m_smVisionInfo.g_arrPackage[intUnitNo].ref_strErrorMessage);

                        m_smVisionInfo.g_intPkgDefectFailureTotal++;
                        //m_smVisionInfo.g_intTestedTotal++;
                        //m_smVisionInfo.g_intLowYieldUnitCount++;
                        m_blnFailCounterAdded = true;
                        m_blnTotalCounterAdded = false;
                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 15a PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                    }
                    if (blnAuto)
                    {
                        if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        {
                            m_blnPackageFail_Out = true;
                            if (m_intTCPIPResultID == -1)
                                SetPackageResultID(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailResultMask);
                        }
                    }
                    blnResult = false;
                }
            }
            //objVoidUnitROI.Dispose();
            objChipUnitROI2.Dispose();
            objCrackViewROI.Dispose();
            m_smVisionInfo.g_blnDrawPkgResult = true;
            m_smVisionInfo.g_blnPackageInspected = true;

            return blnResult;
        }
        
        private void StartTest_MultiThreading(bool blnAuto)
        {
            try
            {
                m_smVisionInfo.g_objProcessTime.Start();

                if (m_smVisionInfo.g_intDelayCheckIO != 0)
                {
                    Thread.Sleep(m_smVisionInfo.g_intDelayCheckIO);
                }

                WaitEventDone(ref m_bSubTh_StartAfterInspect, false, 10000, "A22");

                //m_T1.Start();
                //m_strTrack = "Inside Multithreading";
                //m_fTimingPrev = 0;
                //m_fTiming = 0;

                //m_fTiming = m_T1.Timing;
                //m_strTrack += ", A=" + (m_fTiming - m_fTimingPrev).ToString();
                //m_fTimingPrev = m_fTiming;
                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 1 ");

                // ---------- Reset Variables -------------------------------------------
                for (int u = 0; u < m_smVisionInfo.g_intUnitsOnImage; u++)
                    m_smVisionInfo.g_blnUnitInspected[u] = false;
                bool blnSkip = true;
                m_blnAuto = blnAuto;
                bool blnResultOK = true;
                m_fOrientFinalAngleForLead = 0;
                m_blnPocketPositionResult = false;
                m_bMarkTestDone1 = false;
                m_bMarkTestDone2 = false;
                m_blnOrientGaugeUpdated1 = false;
                m_blnOrientGaugeUpdated2 = false;
                m_blnOrientDataUpdated1 = false;
                m_blnOrientDataUpdated2 = false;
                m_blnRotateImage1Updated = false;
                m_blnRotateImage2Updated = false;
                m_blnRotateImage3Updated = false;
                m_blnRotateImage4Updated = false;
                m_blnRotateImage5Updated = false;
                m_blnRotateImage6Updated = false;
                m_blnRotateImage7Updated = false;
                m_smVisionInfo.g_blnMarkInspected = false;
                m_smVisionInfo.g_blnDrawMarkResult = false;
                m_smVisionInfo.g_blnDrawPkgResult = false;
                m_smVisionInfo.g_blnViewOrientObject = false;
                m_smVisionInfo.g_blnPackageInspected = false;
                m_smVisionInfo.g_blnDrawPocketPositionResult = false;
                m_bPackageSizeTestDone1 = false;
                m_bPackageSizeTestDone2 = false;
                m_bPackageSizePreTestDone1 = false;
                m_bPackageSizePreTestDone2 = false;
                m_bPackageSizePreTestResult1 = false;
                m_bPackageSizePreTestResult2 = false;
                m_bLeadBaseCenterPointDone = false;
                m_bLeadBaseCenterPointResult = false;
                m_intScenario = 0x00;
                m_strPocketPositionTrackingData = "";
                m_smVisionInfo.m_blnUpdateResultUsingByPassSetting = false;

                m_smVisionInfo.g_pMarkROIDrawing[0] = new Point(0, 0);
                m_smVisionInfo.g_pMarkROIDrawing[1] = new Point(0, 0);
                m_smVisionInfo.g_pMarkROIDrawing[2] = new Point(0, 0);
                m_smVisionInfo.g_pMarkROIDrawing[3] = new Point(0, 0);

                m_smVisionInfo.g_pMarkROIDrawing2[0] = new Point(0, 0);
                m_smVisionInfo.g_pMarkROIDrawing2[1] = new Point(0, 0);
                m_smVisionInfo.g_pMarkROIDrawing2[2] = new Point(0, 0);
                m_smVisionInfo.g_pMarkROIDrawing2[3] = new Point(0, 0);

                m_smVisionInfo.g_pMarkROIDrawing_Lead[0] = new Point(0, 0);
                m_smVisionInfo.g_pMarkROIDrawing_Lead[1] = new Point(0, 0);
                m_smVisionInfo.g_pMarkROIDrawing_Lead[2] = new Point(0, 0);
                m_smVisionInfo.g_pMarkROIDrawing_Lead[3] = new Point(0, 0);

                m_smVisionInfo.g_pLeadDontCareRotateCenter = new Point(-1, -1);

                m_smVisionInfo.g_blnGrabbing = true;
                m_bGrabImageFinalResult = m_bGrabImage1Result = m_bGrabImage2Result = m_bGrabImage3Result = m_bGrabImage4Result = m_bGrabImage5Result = m_bGrabImage6Result = m_bGrabImage7Result = false;
                m_bGrabImage1Done = m_bGrabImage2Done = m_bGrabImage3Done = m_bGrabImage4Done = m_bGrabImage5Done = m_bGrabImage6Done = m_bGrabImage7Done = false;
                m_smVisionInfo.g_blnNoGrabTime = false;
                ShowLiterationOnly = m_smVisionInfo.g_blnWantShowLiterationOnly;
                //if (m_smVisionInfo.g_intTestedTotal == 0)
                //    m_intTestCount = 0;

                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 2 ");

                if (m_smVisionInfo.g_blnTrackPocketCounter)
                {
                    if (m_smVisionInfo.g_blnTrackPocketCounter)
                    {
                        if (blnAuto)
                            STTrackLog.WriteLine("----- Start Test - Auto " + m_intTestCount.ToString() + " -----");
                        else
                            STTrackLog.WriteLine("----- Start Test - Offline " + m_intTestCount.ToString() + " -----");
                    }
                }

                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 3 ");

                m_intTestCount++;
                if (!m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                {
                    if (m_objVisionIO.InPocketReTest.IsOff(!m_blnDefaultRetestON))   // Retest OFF mean new unit test.
                    {
                        m_blnPassCounterAdded = false;      // Reset recorded pass counter 
                        m_blnFailCounterAdded = false;      // Reset recorded fail counter
                        m_blnTotalCounterAdded = false;
                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("IO 1-InPocketReTest Off. m_blnPassCounterAdded=" + m_blnPassCounterAdded.ToString() + ", m_blnFailCounterAdded=" + m_blnFailCounterAdded.ToString() + ", m_blnTotalCounterAdded=" + m_blnTotalCounterAdded.ToString());
                    }
                    else if (m_objVisionIO.EndOfReTest.IsOn())  // mean both End Retest ON and Retest ON 
                    {
                        //m_blnPassCounterAdded = false;      // Reset recorded pass counter 
                        m_blnFailCounterAdded = false;      // Reset recorded fail counter
                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("IO 2-InPocketReTest ON, EndOfReTest ON. m_blnPassCounterAdded=" + m_blnPassCounterAdded.ToString() + ", m_blnFailCounterAdded=" + m_blnFailCounterAdded.ToString() + ", m_blnTotalCounterAdded=" + m_blnTotalCounterAdded.ToString());

                    }
                    else if (!m_objVisionIO.InPocketReTest.IsOff(!m_blnDefaultRetestON) && !m_objVisionIO.EndOfReTest.IsOn())
                    {
                        //if (m_blnFailCounterAdded)
                        //    m_blnPassCounterAdded = true;      // Set true to not allow add pass counter
                        //m_blnFailCounterAdded = true;      // Set true to not allow add fail counter
                        //blnAddTotalCounter = false;
                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("IO 3-InPocketReTest ON, EndOfReTest Off. m_blnPassCounterAdded=" + m_blnPassCounterAdded.ToString() + ", m_blnFailCounterAdded=" + m_blnFailCounterAdded.ToString() + ", m_blnTotalCounterAdded=" + m_blnTotalCounterAdded.ToString());

                    }

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 4 ");

                    if (m_objVisionIO.PackageFail != null)
                        if (m_objVisionIO.PackageFail.IsOn())
                            m_objVisionIO.PackageFail.SetOff("V4 PackageFail 100");

                    if (m_objVisionIO.FailOffset != null)
                        if (m_objVisionIO.FailOffset.IsOn())
                            m_objVisionIO.FailOffset.SetOff("V4 FailOffset 101");
                }
                else
                {
                    if (!m_blnInPocketReTest_In)   // Retest OFF mean new unit test.
                    {
                        m_blnPassCounterAdded = false;      // Reset recorded pass counter 
                        m_blnFailCounterAdded = false;      // Reset recorded fail counter
                        m_blnTotalCounterAdded = false;
                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("IO 1-InPocketReTest Off. m_blnPassCounterAdded=" + m_blnPassCounterAdded.ToString() + ", m_blnFailCounterAdded=" + m_blnFailCounterAdded.ToString() + ", m_blnTotalCounterAdded=" + m_blnTotalCounterAdded.ToString());
                    }
                    else if (m_blnInPocketEndOfReTest_In)  // mean both End Retest ON and Retest ON 
                    {
                        //m_blnPassCounterAdded = false;      // Reset recorded pass counter 
                        m_blnFailCounterAdded = false;      // Reset recorded fail counter
                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("IO 2-InPocketReTest ON, EndOfReTest ON. m_blnPassCounterAdded=" + m_blnPassCounterAdded.ToString() + ", m_blnFailCounterAdded=" + m_blnFailCounterAdded.ToString() + ", m_blnTotalCounterAdded=" + m_blnTotalCounterAdded.ToString());

                    }
                    else if (m_blnInPocketReTest_In && !m_blnInPocketEndOfReTest_In)
                    {
                        //if (m_blnFailCounterAdded)
                        //    m_blnPassCounterAdded = true;      // Set true to not allow add pass counter
                        //m_blnFailCounterAdded = true;      // Set true to not allow add fail counter
                        //blnAddTotalCounter = false;
                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("IO 3-InPocketReTest ON, EndOfReTest Off. m_blnPassCounterAdded=" + m_blnPassCounterAdded.ToString() + ", m_blnFailCounterAdded=" + m_blnFailCounterAdded.ToString() + ", m_blnTotalCounterAdded=" + m_blnTotalCounterAdded.ToString());

                    }

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 4 ");

                    m_blnPackageFail_Out = false;

                    m_blnInPocketFailOffset_Out = false;

                }

                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 5 ");
                // ---------- Define m_intScenario to check unit 1 or unit 2 or both -----------------------
                if (blnAuto)
                {
                    //Thread.Sleep(m_smVisionInfo.g_intCameraGrabDelay); //29-05-2019 ZJYEOH : Moved it to After Grabtime Start counting 

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 6 ");

                    if (!m_smProductionInfo.g_blnAllRunWithoutGrabImage)
                    {
                        m_bSubTh1_GrabImage = true;

                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 7 ");
                        // check IO trigger status
                        if (m_smVisionInfo.g_intUnitsOnImage == 1)  // Single In-Pocket
                        {
                            if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 8 ");
                            m_intScenario |= 0x01;

                            if (!m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                                m_objVisionIO.IOPass1.SetOff("V4 IOPass1 102");
                            else
                                m_blnPass1_Out = false;
                        }
                        else // Double In-pocket: check which pocket is going to inspect based on IO signal
                        {
                            if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 9 ");
                            if (m_smVisionInfo.g_blnDebugRUN)   // Check both pocket if Debug Run
                            {
                                m_intScenario |= 0x01;
                                if (!m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                                    m_objVisionIO.IOPass1.SetOff("V4 IOPass1 103");
                                else
                                    m_blnPass1_Out = false;

                                m_intScenario |= 0x02;
                                if (!m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                                    m_objVisionIO.IOPass2.SetOff("V4 IOPass1 104");
                                else
                                    m_blnPass2_Out = false;
                            }

                            if (!m_smCustomizeInfo.g_blnWantUseTCPIPIO && m_objVisionIO.InPocketCheckUnit1.IsOn())
                            {
                                m_intScenario |= 0x01;
                                m_objVisionIO.IOPass1.SetOff("V4 IOPass1 105");
                            }
                            else if (m_smCustomizeInfo.g_blnWantUseTCPIPIO && m_blnInPocketCheckUnit1_In)
                            {
                                m_intScenario |= 0x01;
                                m_blnPass1_Out = false;
                            }

                            if (!m_smCustomizeInfo.g_blnWantUseTCPIPIO && m_objVisionIO.InPocketReCheckUnit2 != null)
                            {
                                if (m_objVisionIO.InPocketReCheckUnit2.IsOn())
                                {
                                    m_intScenario |= 0x02;
                                    m_objVisionIO.IOPass2.SetOff("V4 IOPass1 106");
                                }
                            }
                            else if (m_smCustomizeInfo.g_blnWantUseTCPIPIO && m_blnInPocketReCheckUnit2_In)
                            {
                                m_intScenario |= 0x02;
                                m_blnPass2_Out = false;
                            }
                        }

                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 10 ");
                    }
                    else // Debug run without grab image
                    {
                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 11 ");

                        m_smVisionInfo.g_objGrabTime.Reset();
                        m_smVisionInfo.g_objTransferTime.Reset();
                        m_smVisionInfo.g_blnGrabbing = false;
                        m_bGrabImage1Result = m_bGrabImage2Result = m_bGrabImage3Result = m_bGrabImage4Result = m_bGrabImage5Result = m_bGrabImage6Result = m_bGrabImage7Result = true;
                        m_bGrabImage1Done = m_bGrabImage2Done = m_bGrabImage3Done = m_bGrabImage4Done = m_bGrabImage5Done = m_bGrabImage6Done = m_bGrabImage7Done = true;
                        m_smVisionInfo.g_blnNoGrabTime = true;
                        m_blnGrabbing_Out = false;
                        m_blnSentGrabDone = false;

                        if (m_smVisionInfo.g_intUnitsOnImage == 1)
                            m_intScenario = 0x01;
                        else
                            m_intScenario = 0x03;

                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 12 ");
                    }

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 13 m_intScenario:" + m_intScenario.ToString());
                }
                else
                {
                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 14 ");

                    if (m_smVisionInfo.g_intUnitsOnImage == 1)
                        m_intScenario = 0x01;
                    else
                        m_intScenario = 0x03;

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 15 ");
                    if (m_smVisionInfo.MN_PR_GrabImage)
                    {
                        m_smVisionInfo.MN_PR_GrabImage = false;

                        m_bSubTh1_GrabImage = true;
                    }
                    else
                    {
                        m_smVisionInfo.g_objGrabTime.Reset();
                        m_smVisionInfo.g_objTransferTime.Reset();
                        m_smVisionInfo.g_blnGrabbing = false;
                        m_bGrabImage1Result = m_bGrabImage2Result = m_bGrabImage3Result = m_bGrabImage4Result = m_bGrabImage5Result = m_bGrabImage6Result = m_bGrabImage7Result = true;
                        m_bGrabImage1Done = m_bGrabImage2Done = m_bGrabImage3Done = m_bGrabImage4Done = m_bGrabImage5Done = m_bGrabImage6Done = m_bGrabImage7Done = true;
                        m_smVisionInfo.g_blnNoGrabTime = true;
                    }

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 16 ");
                }

                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 17 ");
                // ----------- Define what test going to do --------------------------------------------
                if ((m_smCustomizeInfo.g_intWantPackage & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
                {
                    if (!m_blnWantPackageTest)
                        m_blnWantPackageTest = true;
                }
                else
                {
                    if (m_blnWantPackageTest)
                        m_blnWantPackageTest = false;
                }

                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 18 ");

                if ((m_smCustomizeInfo.g_intWantPositioning & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
                {
                    if (!m_blnWantPositioning)
                        m_blnWantPositioning = true;
                }
                else
                {
                    if (m_blnWantPositioning)
                        m_blnWantPositioning = false;
                }

                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 19 ");

                if ((m_smCustomizeInfo.g_intWantOrient & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
                {
                    if (!m_blnWantOrientTest)
                        m_blnWantOrientTest = true;
                }
                else
                {
                    if (m_blnWantOrientTest)
                        m_blnWantOrientTest = false;
                }

                if ((m_smCustomizeInfo.g_intWantMark & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
                {
                    if (!m_blnWantMarkTest)
                        m_blnWantMarkTest = true;
                }
                else
                {
                    if (m_blnWantMarkTest)
                        m_blnWantMarkTest = false;
                }

                if (m_smVisionInfo.g_blnWantCheckPocketPosition)
                {
                    m_smVisionInfo.g_blnDrawPocketPositionResult = false;
                    if (!m_blnWantPocketPositionTest)
                        m_blnWantPocketPositionTest = true;
                }
                else
                {
                    m_smVisionInfo.g_blnDrawPocketPositionResult = false;
                    if (m_blnWantPocketPositionTest)
                        m_blnWantPocketPositionTest = false;
                }

                if ((m_smCustomizeInfo.g_intWantLead & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
                {
                    if (!m_blnWantLeadTest)
                        m_blnWantLeadTest = true;
                }
                else
                {
                    if (m_blnWantLeadTest)
                        m_blnWantLeadTest = false;
                }

                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 20 ");
                // If retest, counter will not add. Counter only add if EndOfReTest if ON
                if (m_smCustomizeInfo.g_blnShareHandlerPC)
                {
                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 21 ");
#if(RTXDebug || RTXRelease)

                    if (SRMSingleLock("IPM1_EndOfRetest"))
                        m_smVisionInfo.g_blnInPocketRetestEnd = true;
                    else
                        m_smVisionInfo.g_blnInPocketRetestEnd = false;
#endif
                }
                else
                {
                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 22 ");
                    if (m_smVisionInfo.g_intUnitsOnImage == 1) // 02-07-2019 ZJYEOH: Wont use Auto Replace Counter anymore || m_smVisionInfo.g_blnUseAutoRepalceCounter)
                    {
                        if (!m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        {
                            if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 23 ");
                            if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 23a m_objVisionIO.EndOfReTest.IsOn(m_smVisionInfo.g_blnDebugRUN)= " + m_objVisionIO.EndOfReTest.IsOn(m_smVisionInfo.g_blnDebugRUN).ToString());
                            if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 23b m_objVisionIO.RollbackRetest.IsOff(m_smVisionInfo.g_blnDebugRUN)= " + m_objVisionIO.RollbackRetest.IsOff(m_smVisionInfo.g_blnDebugRUN).ToString());
                            //if (m_objVisionIO.EndOfReTest.IsOn(m_smVisionInfo.g_blnDebugRUN) && m_objVisionIO.RollbackRetest.IsOff(m_smVisionInfo.g_blnDebugRUN))                       // Use EndOfReTest when exist both EndOfRetest and Retest IO.
                            if (m_objVisionIO.EndOfReTest.IsOn(m_smVisionInfo.g_blnDebugRUN))
                            {
                                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 23c ");
                                m_smVisionInfo.g_blnInPocketRetestEnd = true;
                            }
                            else
                            {
                                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 23c ");
                                m_smVisionInfo.g_blnInPocketRetestEnd = false;
                            }

                            if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 24 ");
                            m_blnRollback = m_objVisionIO.RollbackRetest.IsOn();
                        }
                        else
                        {
                            if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 23 ");
                            if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 23a m_blnInPocketEndOfReTest_In= " + m_blnInPocketEndOfReTest_In.ToString());
                            if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 23b m_blnInPocketRollbackRetest_In= " + m_blnInPocketRollbackRetest_In.ToString());
                            //if (m_objVisionIO.EndOfReTest.IsOn(m_smVisionInfo.g_blnDebugRUN) && m_objVisionIO.RollbackRetest.IsOff(m_smVisionInfo.g_blnDebugRUN))                       // Use EndOfReTest when exist both EndOfRetest and Retest IO.
                            if (m_blnInPocketEndOfReTest_In)
                            {
                                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 23c ");
                                m_smVisionInfo.g_blnInPocketRetestEnd = true;
                            }
                            else
                            {
                                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 23c ");
                                m_smVisionInfo.g_blnInPocketRetestEnd = false;
                            }

                            if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 24 ");
                            m_blnRollback = m_blnInPocketRollbackRetest_In;
                        }
                    }
                    else
                    {
                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 25 ");
                        if (!m_smCustomizeInfo.g_blnWantUseTCPIPIO && m_objVisionIO.InPocketReTest.IsOn(m_blnDefaultRetestON) && m_objVisionIO.RollbackRetest.IsOff())                    // Use Retest IO bcos no EndOfRetest IO in MarkOrient IPM.
                        {
                            m_smVisionInfo.g_blnInPocketRetestEnd = true;
                        }
                        else if (m_smCustomizeInfo.g_blnWantUseTCPIPIO && m_blnInPocketEndOfReTest_In && !m_blnInPocketRollbackRetest_In)                    // Use Retest IO bcos no EndOfRetest IO in MarkOrient IPM.
                        {
                            m_smVisionInfo.g_blnInPocketRetestEnd = true;
                        }
                        else
                        {
                            m_smVisionInfo.g_blnInPocketRetestEnd = false;
                        }

                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 22 ");
                    }

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 27 ");
                    if ((blnAuto && !m_smCustomizeInfo.g_blnWantUseTCPIPIO && m_objVisionIO.CheckEmpty != null && m_objVisionIO.CheckEmpty.IsOn() && m_smVisionInfo.g_blnWantCheckEmpty) ||
                        (!blnAuto && (m_smVisionInfo.MN_PR_CheckEmptyUnit && m_smVisionInfo.g_blnWantCheckEmpty)))
                    {
                        m_blnCheckEmpty = true;
                    }
                    else if ((blnAuto && m_smCustomizeInfo.g_blnWantUseTCPIPIO && m_blnInPocketCheckEmpty_In && m_smVisionInfo.g_blnWantCheckEmpty) ||
                        (!blnAuto && (m_smVisionInfo.MN_PR_CheckEmptyUnit && m_smVisionInfo.g_blnWantCheckEmpty)))
                    {
                        m_blnCheckEmpty = true;
                    }
                    else
                    {
                        m_blnCheckEmpty = false;
                    }

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 28 ");

                    if (m_smVisionInfo.g_blnTrackPocketCounter && !m_smCustomizeInfo.g_blnWantUseTCPIPIO) STTrackLog.WriteLine("2.1 EndRetest " + m_objVisionIO.EndOfReTest.IsOn().ToString() + ", Rollback " + m_objVisionIO.RollbackRetest.IsOn().ToString() + ", blnInPocketRetestEn=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString());
                    if (m_smVisionInfo.g_blnTrackPocketCounter && m_smCustomizeInfo.g_blnWantUseTCPIPIO) STTrackLog.WriteLine("2.1 EndRetest " + m_blnInPocketEndOfReTest_In.ToString() + ", Rollback " + m_blnInPocketRollbackRetest_In.ToString() + ", blnInPocketRetestEn=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString());

                }

                // ------------------ Reset Inspection data ----------------------------------------------
                if (m_blnWantPackageTest)
                {
                    for (int i = 0; i < m_smVisionInfo.g_arrPackage.Count; i++)
                        m_smVisionInfo.g_arrPackage[i].ResetPackageInspectionData();
                }

                if (m_smVisionInfo.g_blnWantPin1)
                {
                    for (int i = 0; i < m_smVisionInfo.g_arrPin1.Count; i++)
                    {
                        m_smVisionInfo.g_arrPin1[i].ResetInspectionData();
                    }
                }

                if (m_blnWantLeadTest)
                {
                    m_smVisionInfo.g_fPreciseAngle = 0;
                    for (int i = 0; i < m_smVisionInfo.g_arrLead.Length; i++)
                    {
                        if (i == 0)
                            m_smVisionInfo.g_arrLead[i].ResetInspectionData();

                        if (!m_smVisionInfo.g_arrLead[i].ref_blnSelected)
                        {
                            // 2021 08 23 - CCENG: Make sure inspection data are cleared also when user change lead inspection direction from left right <> top bottom
                            //                     If no clear it, user will see the number display on image at point gauge profile form.
                            m_smVisionInfo.g_arrLead[i].ResetNoInspectionData();
                            continue;
                        }

                        m_smVisionInfo.g_arrLead[i].ref_blnLock = true;

                        // Reset previous inspection data
                        m_smVisionInfo.g_arrLead[i].ResetInspectionData();
                    }
                }

                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 29 ");

                // ---------- Wait for image 1 grab done
                //WaitEventDone(ref m_bGrabImage1Done, true);

                // AttachImageToROI();

                switch (m_intScenario)
                {
                    //only check unit 1,normal run case
                    case 1:

                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 30 ");
                        m_smVisionInfo.g_intScenario = 0x01;

                        if (false) // 02-07-2019 ZJYEOH: Wont use Auto Replace Counter anymore   (m_smVisionInfo.g_blnUseAutoRepalceCounter)   // ------------ For Single IPM with 2 mirror Auto Replace Only----------------------------------------------
                        {
                            if (newCheckUnit1(blnAuto, ref blnSkip))
                            {
                                // Add pass counter if Retest off or Pass counter is not added yet.
                                //if (blnAuto && (m_objVisionIO.InPocketReTest.IsOff() || (!m_blnPassCounterAdded && !m_blnFailCounterAdded)))
                                //{
                                //    if (m_objVisionIO.CheckEmpty == null || (m_objVisionIO.CheckEmpty != null && !m_objVisionIO.CheckEmpty.IsOn()))   // 2018 08 16 - CCENG: No add pass total if check empty pass.
                                //    {
                                //        //m_smVisionInfo.g_intPassTotal++; // 04-06-2019 ZJYEOH : removed to solve pass counter and total not tally
                                //        //m_smVisionInfo.g_intTestedTotal++;
                                //        //m_smVisionInfo.g_intLowYieldUnitCount++;
                                //        m_blnPassCounterAdded = true;   // Prevent pass counter add again after machine stop run again.
                                //    }
                                //}

                                // Set display
                                //if ((blnAuto && m_objVisionIO.CheckEmpty != null && m_objVisionIO.CheckEmpty.IsOn()) ||
                                //    (!blnAuto && m_smVisionInfo.MN_PR_CheckEmptyUnit))
                                //    m_smVisionInfo.g_strResult = "Empty";
                                //else
                                //    m_smVisionInfo.g_strResult = "Pass";

                                //m_smVisionInfo.g_strResult2 = "----";

                                m_smVisionInfo.g_blnPocket1Pass = true;
                            }
                            else
                            {
                                if ((!m_smCustomizeInfo.g_blnWantUseTCPIPIO && m_objVisionIO.EndOfReTest.IsOn()) || (m_smCustomizeInfo.g_blnWantUseTCPIPIO && m_blnInPocketEndOfReTest_In))     //For Single IPM with 2 mirror Auto Replace Only
                                {
                                    if (m_blnPositionResult)
                                    {
                                        if (m_intContinueEndReTestCounter < 3)
                                            m_intContinueEndReTestCounter++;
                                        else
                                            m_intContinueEndReTestCounter = 0;
                                    }
                                    else
                                        m_intContinueEndReTestCounter = 0;
                                }
                               
                                m_smVisionInfo.g_blnPocket1Pass = false;
                                blnResultOK = false;
                            }
                        }
                        else // For Default Single or Double InPocket
                        {
                            if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 33 ");
                            if (newCheckUnit1(blnAuto, ref blnSkip))
                            {
                                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 34 ");
                                if (m_smVisionInfo.g_intUnitsOnImage == 1)
                                {
                                    //if (blnAuto && m_objVisionIO.InPocketReTest.IsOff() && (!m_blnPassCounterAdded && !m_blnFailCounterAdded))
                                    //{
                                    //    //m_smVisionInfo.g_intPassTotal++; // 04-06-2019 ZJYEOH : removed to solve pass counter and total not tally
                                    //    //m_smVisionInfo.g_intTestedTotal++;
                                    //    //m_smVisionInfo.g_intLowYieldUnitCount++;
                                    //    m_blnPassCounterAdded = true;
                                    //}
                                }
                                else
                                {
                                    if (blnAuto)
                                    {
                                        //m_smVisionInfo.g_intPassTotal++; // 04-06-2019 ZJYEOH : removed to solve pass counter and total not tally
                                        //m_smVisionInfo.g_intTestedTotal++;
                                        //m_smVisionInfo.g_intLowYieldUnitCount++;
                                    }
                                }


                                //if ((blnAuto && m_objVisionIO.CheckEmpty != null && m_objVisionIO.CheckEmpty.IsOn()) ||
                                //    (!blnAuto && m_smVisionInfo.MN_PR_CheckEmptyUnit))
                                //    m_smVisionInfo.g_strResult = "Empty";
                                //else
                                //    m_smVisionInfo.g_strResult = "Pass";

                                //m_smVisionInfo.g_strResult2 = "----";

                                m_smVisionInfo.g_blnPocket1Pass = true;
                                blnResultOK = true;

                                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 35 ");
                            }
                            else
                            {
                                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 36 ");
                                m_smVisionInfo.g_blnPocket1Pass = false;
                                blnResultOK = false;

                                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                                    if (m_intTCPIPResultID == -1)
                                        m_intTCPIPResultID = (int)TCPIPResulID.Fail;// FailEmpty;
                            }

                            if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 37 ");
                        }

                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 38 ");
                        break;
                        ////only check unit 2,start from stop case, retest unit and last unit 
                        //case 2:

                        //    if (CheckUnit2(blnAuto))
                        //    {
                        //        //unit 1 index and its fail,reinspect update test result
                        //        if (m_smVisionInfo.g_blnPocket2Pass == false && m_smVisionInfo.g_blnPocket1Pass == false && m_smVisionInfo.g_intScenario == 0x03)
                        //        {
                        //            if (blnAuto)
                        //            {
                        //                m_smVisionInfo.g_intPassTotal++;
                        //                m_smVisionInfo.g_intTestedTotal++;
                        //                m_smVisionInfo.g_intLowYieldUnitCount++;
                        //            }
                        //            if (!m_smVisionInfo.g_blnInPocketLastUnit)
                        //                m_smVisionInfo.g_blnPocket1Pass = true;

                        //            m_smVisionInfo.g_blnPocket2Pass = true;
                        //            m_smVisionInfo.g_blnInPocketLastUnit = false;
                        //        }
                        //        else if (m_smVisionInfo.g_blnPocket2Pass == true && m_smVisionInfo.g_blnPocket1Pass == false)
                        //        {
                        //            if (CheckIsLastUnit())
                        //            {
                        //                if (blnAuto)
                        //                {
                        //                    m_smVisionInfo.g_intPassTotal++;
                        //                    m_smVisionInfo.g_intTestedTotal++;
                        //                    m_smVisionInfo.g_intLowYieldUnitCount++;
                        //                }
                        //                if (!m_smVisionInfo.g_blnInPocketLastUnit)
                        //                    m_smVisionInfo.g_blnPocket1Pass = true;

                        //                m_smVisionInfo.g_blnPocket2Pass = true;

                        //                m_smVisionInfo.g_blnInPocketLastUnit = false;
                        //            }
                        //        }

                        //        m_smVisionInfo.g_strResult = "----";
                        //        m_smVisionInfo.g_strResult2 = "Pass";

                        //    }
                        //    break;

                        ////check unit 1 and unit 2,happen when previous unit 1 fail, if unit 2 fail at this then return
                        //case 3:

                        //    //means unit 1 index already
                        //    m_smVisionInfo.g_intScenario = 0x03;

                        //    if (CheckUnit2(blnAuto))
                        //    {
                        //        if (blnAuto)
                        //        {
                        //            m_smVisionInfo.g_intPassTotal++;
                        //            m_smVisionInfo.g_intTestedTotal++;
                        //            m_smVisionInfo.g_intLowYieldUnitCount++;
                        //        }
                        //        m_smVisionInfo.g_strResult2 = "Pass";
                        //        m_smVisionInfo.g_blnPocket2Pass = true;
                        //    }
                        //    else
                        //    {
                        //        m_smVisionInfo.g_blnInPocketLastUnit = true;
                        //        m_smVisionInfo.g_blnPocket1Pass = false;
                        //        m_smVisionInfo.g_blnPocket2Pass = false;
                        //        m_smVisionInfo.g_strResult = "----";
                        //        if (blnAuto)
                        //            break;
                        //    }

                        //    if (CheckUnit1(blnAuto))
                        //    {
                        //        if (blnAuto)
                        //        {
                        //            m_smVisionInfo.g_intPassTotal++;
                        //            m_smVisionInfo.g_intTestedTotal++;
                        //            m_smVisionInfo.g_intLowYieldUnitCount++;
                        //        }

                        //        if ((blnAuto && m_objVisionIO.CheckEmpty != null && m_objVisionIO.CheckEmpty.IsOn()) ||
                        //            (!blnAuto && m_smVisionInfo.MN_PR_CheckEmptyUnit))
                        //            m_smVisionInfo.g_strResult = "Empty";
                        //        else
                        //            m_smVisionInfo.g_strResult = "Pass";

                        //        m_smVisionInfo.g_blnPocket1Pass = true;
                        //    }
                        //    else
                        //    {
                        //        m_smVisionInfo.g_blnInPocketLastUnit = true;
                        //        m_smVisionInfo.g_blnPocket1Pass = false;
                        //    }

                        //    break;
                }

                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 39 ");
                if (!blnSkip)
                {
                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 40 ");
                    // ----------------- Trigger Sub Thread test now -----------------------------------------
#if (DEBUG || Debug_2_12 || RTXDebug)
                    if (m_blnWantMarkTest || m_blnWantOrientTest)
                    {
                        m_bSubTh_MarkTest = true;
                    }
                    else
                    {
                        m_bSubTh_MarkTest_Result = true;
                    }

                    if (m_blnWantPackageTest)
                    {
                        m_bSubTh_PackageTest_MarkLightView = true;

                        m_bSubTh_PackageTest_SideLightView = true;
                        m_bSubTh_PackageTest_TopLightView = true;
                        //m_bSubTh_PackageTest_SideLightView_Result = true;
                        //m_bSubTh_PackageTest_TopLightView_Result = true;
                    }
                    else
                    {
                        m_bSubTh_PackageTest_MarkLightView_Result = true;
                        m_bSubTh_PackageTest_SideLightView_Result = true;
                        m_bSubTh_PackageTest_TopLightView_Result = true;
                    }

                    if (m_blnWantLeadTest)
                    {
                        if (m_smVisionInfo.VM_PR_ByPassUnit)
                        {
                            m_bSubTh_LeadTest_Result = true;    // No lead test if Press ByPass. 
                        }
                        else
                            m_bSubTh_LeadTest = true;
                    }
                    else
                    {
                        m_bSubTh_LeadTest_Result = true;
                    }

                    if (m_blnCustomWantColor)
                    {
                        m_bSubTh_PackageColorTest = true;
                    }
                    else
                    {
                        m_bSubTh_PackageColorTest_Result = true;
                    }
#else
                     // 2020 08 01 - CCENG: Goodark customer request to check minimum mark score when press bypass button in IPM
                    //if (m_smVisionInfo.VM_PR_ByPassUnit)
                    //{
                    //    m_smVisionInfo.VM_PR_ByPassUnit = false;

                    //    Thread.Sleep(10);   // Sleep 10 to make sure EOV signal OFF enough long to be detected by handler

                    //    m_bSubTh_MarkTest_Result = true;
                    //    m_bSubTh_PackageTest_MarkLightView_Result = true;
                    //    m_bSubTh_PackageTest_SideLightView_Result = true;
                    //    m_bSubTh_PackageTest_TopLightView_Result = true;
                    //    m_bSubTh_LeadTest_Result = true;
                    //}
                    //else
                    {
                        if (m_blnWantMarkTest || m_blnWantOrientTest)
                        {
                            m_bSubTh_MarkTest = true;
                        }
                        else
                        {
                            m_bSubTh_MarkTest_Result = true;
                        }

                        if (m_blnWantPackageTest)
                        {
                            m_bSubTh_PackageTest_MarkLightView = true;
                            m_bSubTh_PackageTest_SideLightView = true;
                            m_bSubTh_PackageTest_TopLightView = true;
                        }
                        else
                        {
                            m_bSubTh_PackageTest_MarkLightView_Result = true;
                            m_bSubTh_PackageTest_SideLightView_Result = true;
                            m_bSubTh_PackageTest_TopLightView_Result = true;
                        }

                        if (m_blnWantLeadTest)
                        {
                            if (m_smVisionInfo.VM_PR_ByPassUnit)
                            {
                                m_bSubTh_LeadTest_Result = true;    // No lead test if Press ByPass. 
                            }
                            else
                                m_bSubTh_LeadTest = true;
                        }
                        else
                        {
                            m_bSubTh_LeadTest_Result = true;
                        }
                    
                        if (m_blnCustomWantColor)
                        {
                            m_bSubTh_PackageColorTest = true;
                        }
                        else
                        {
                            m_bSubTh_PackageColorTest_Result = true;
                        }
                    }
#endif
                    // ------------------ Wait Sub Thread Test done --------------------------------------------------

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 41 ");
                    bool blnInspectionDone = false;
                    HiPerfTimer timeout = new HiPerfTimer();
                    timeout.Start();
                    while (true)
                    {
                        if (!m_bSubTh_MarkTest &&
                            !m_bSubTh_PackageTest_MarkLightView &&
                            !m_bSubTh_PackageTest_SideLightView &&
                            !m_bSubTh_PackageTest_TopLightView &&
                            !m_bSubTh_LeadTest &&
                            !m_bSubTh_PackageColorTest)
                        {

                            blnInspectionDone = true;
                            break;
                        }

#if (RELEASE || RTXRelease || Release_2_12)
                        if (timeout.Timing > 10000) // 2020 02 18 - CCENG: Change to 10ms to prevent inspection time out due to debug run too fast.
                        {
                            string strFileName = DateTime.Now.ToString("yyyy-MM-dd_HH-mm");
                            for (int m = 0; m < m_smVisionInfo.g_arrImages.Count; m++)
                            {
                                m_smVisionInfo.g_arrImages[m].SaveImage("D:\\ErrorImage\\image_" + strFileName + "_" + m.ToString() + ".bmp");
                            }
                            STTrackLog.WriteLine(">>>>>>>>>>>>> Vision 4 a - time out 7.");
                            STTrackLog.WriteLine(">>>>>>>>>>>>> Vision 4 a - m_bSubTh_MarkTest=" + m_bSubTh_MarkTest.ToString());
                            STTrackLog.WriteLine(">>>>>>>>>>>>> Vision 4 a - m_bSubTh_PackageTest_MarkLightView=" + m_bSubTh_PackageTest_MarkLightView.ToString());
                            STTrackLog.WriteLine(">>>>>>>>>>>>> Vision 4 a - m_bSubTh_PackageTest_SideLightView=" + m_bSubTh_PackageTest_SideLightView.ToString());
                            STTrackLog.WriteLine(">>>>>>>>>>>>> Vision 4 a - m_bSubTh_PackageTest_TopLightView=" + m_bSubTh_PackageTest_TopLightView.ToString());
                            STTrackLog.WriteLine(">>>>>>>>>>>>> Vision 4 a - m_bSubTh_LeadTest=" + m_bSubTh_LeadTest.ToString());
                            STTrackLog.WriteLine(">>>>>>>>>>>>> Vision 4 a - m_bSubTh_PackageColorTest=" + m_bSubTh_PackageColorTest.ToString());
                            
                            break;
                        }
#endif
                        Thread.Sleep(1);
                    }

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 42 ");

                    // ---------------------- Action after Sub Thread Test Done -----------------------------------------------------------
                    if (m_smVisionInfo.g_blnUnitInspected.Length > 0)
                        m_smVisionInfo.g_blnUnitInspected[0] = true;

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 43 ");
                    // ------------------ Set IO to handler (set before save image for faster UPH) ----------------------------------------
                    // Define Final result is pass or fail.
                    if (blnInspectionDone &&
                        m_bSubTh_MarkTest_Result &&
                        m_bSubTh_PackageTest_MarkLightView_Result &&
                        m_bSubTh_PackageTest_SideLightView_Result &&
                        m_bSubTh_PackageTest_TopLightView_Result &&
                        m_bSubTh_LeadTest_Result &&
                        m_bSubTh_PackageColorTest_Result
                       /* && m_smVisionInfo.g_intForceFailCounter == 0*/)
                    {
                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 44 ");
                        if (blnAuto)
                        {
                            WaitEventDone(ref m_blnGrabbing_Out, false, 10000, "m_blnGrabbing_Out");//2021-03-24 ZJYEOH : Wait grab done send to handler first

                            if (!m_blnSentGrabDone)
                            {
                                m_blnSentGrabDone = true;
                                float fGrabDelay = 5 - m_smVisionInfo.g_objGrabTime.Timing;
                                if (fGrabDelay >= 1)
                                    Thread.Sleep((int)fGrabDelay);

                                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO && m_blnAuto) //2021-11-16 ZJYEOH : Change m_smVisionInfo.g_intMachineStatus == 2 to m_blnAuto
                                {
                                    m_smTCPIPIO.Send(m_smVisionInfo.g_intVisionIndex, "GRBRP", true, -1);
                                }
                            }

                            if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 45 ");

                            if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                            {
                                //2021-03-24 ZJYEOH : Wait at least 5ms before send result
                                float fDelay = 5 - Math.Max(0, m_smVisionInfo.g_objTotalTime.Timing - m_smVisionInfo.g_objGrabTime.Duration);
                                if (fDelay >= 1)
                                    Thread.Sleep((int)fDelay);

                                m_blnPass1_Out = true;
                                if (m_blnCheckOffset_In)
                                    m_smTCPIPIO.Send_ResultForCheckOffset(m_smVisionInfo.g_intVisionIndex, true, m_blnOrientResult1_Out, m_blnOrientResult2_Out, m_fOffsetX, m_fOffsetY, m_fOffsetAngle, m_blnPocketPositionResult);
                                else
                                    m_smTCPIPIO.Send_Result(m_smVisionInfo.g_intVisionIndex, true, m_blnOrientResult1_Out, m_blnOrientResult2_Out, m_intTCPIPResultID);
                            }
                            else
                            {
                                WaitEventDone(ref m_blnGrabbing_Out, false, 10000, "m_blnGrabbing_Out");
                                float fGrabDelay = 5 - m_smVisionInfo.g_objGrabDoneTime.Timing;
                                if (fGrabDelay >= 1)
                                    Thread.Sleep((int)fGrabDelay);

                                if (!m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                                    m_objVisionIO.IOPass1.SetOn("V4 IOPass1 4");
                            }

                            if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 46 ");
                        }

                        blnResultOK = true;
                    }
                    else
                    {
                        //if (m_smVisionInfo.g_intForceFailCounter > 0)
                        //{
                        //    SaveRejectImage_AddToBuffer("ForceLeadFail", m_smVisionInfo.g_strErrorMessage);
                        //    if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                        //    {
                        //        m_smVisionInfo.g_intLeadFailureTotal++;
                        //        m_blnFailCounterAdded = true;
                        //        m_blnTotalCounterAdded = false;
                        //        //SaveRejectImage_AddToBuffer("LeadSpan", m_smVisionInfo.g_arrLead[0].GetLeadSpanFailTestDisplayResult());
                        //    }
                        //    m_smVisionInfo.g_intForceFailCounter--;
                        //}
                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 47 ");
                        if (blnAuto)
                        {
                            if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 48 ");
                            if (m_blnWantPocketPositionTest)
                            {
                                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 49 ");
                                // 2020 02 23 - CCENG: if unit fail, no need to set FailOffset ON. (FailOffset is used to trigger handle do pocket auto correct position.)
                                if (!m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                                {
                                    if (m_objVisionIO.FailOffset != null)
                                        if (m_objVisionIO.FailOffset.IsOn())
                                            m_objVisionIO.FailOffset.SetOff();
                                }
                            }

                            if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                            {
                                WaitEventDone(ref m_blnGrabbing_Out, false, 10000, "m_blnGrabbing_Out");//2021-03-24 ZJYEOH : Wait grab done send to handler first

                                if (!m_blnSentGrabDone)
                                {
                                    m_blnSentGrabDone = true;
                                    float fGrabDelay = 5 - m_smVisionInfo.g_objGrabTime.Timing;
                                    if (fGrabDelay >= 1)
                                        Thread.Sleep((int)fGrabDelay);

                                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO && m_blnAuto) //2021-11-16 ZJYEOH : Change m_smVisionInfo.g_intMachineStatus == 2 to m_blnAuto
                                    {
                                        m_smTCPIPIO.Send(m_smVisionInfo.g_intVisionIndex, "GRBRP", true, -1);
                                    }
                                    // 20220713 Add by Theam
                                    if (m_intTCPIPResultID == -1)
                                        m_intTCPIPResultID = (int)TCPIPResulID.Fail;
                                }

                                //2021-03-24 ZJYEOH : Wait at least 5ms before send result
                                float fDelay = 5 - Math.Max(0, m_smVisionInfo.g_objTotalTime.Timing - m_smVisionInfo.g_objGrabTime.Duration);
                                if (fDelay >= 1)
                                    Thread.Sleep((int)fDelay);

                                if (m_blnWantPocketPositionTest)
                                    m_blnInPocketFailOffset_Out = false;

                                if (m_blnCheckOffset_In)
                                    m_smTCPIPIO.Send_ResultForCheckOffset(m_smVisionInfo.g_intVisionIndex, false, m_blnOrientResult1_Out, m_blnOrientResult2_Out, m_fOffsetX, m_fOffsetY, m_fOffsetAngle, m_blnPocketPositionResult);
                                else
                                    m_smTCPIPIO.Send_Result(m_smVisionInfo.g_intVisionIndex, false, m_blnOrientResult1_Out, m_blnOrientResult2_Out, m_intTCPIPResultID);

                            }
                        }

                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 50 ");

                        blnResultOK = false;
                    }
                    if (!m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    {
                        m_objVisionIO.IOEndVision.SetOn("V4 IOEndVision 5");
                    }
                    else
                    {
                        m_blnEndVision_Out = true;
                    }
                    // Wait all images grab done to make sure latest images are saved.   
                }

                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 51 ");
                if (m_smVisionInfo.g_blnTrackPocketPosition)
                {
                    TrackLog objTL = new TrackLog();
                    if (!m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    {
                        objTL.WriteLine(m_strPocketPositionTrackingData + ", Unit Result=" + blnResultOK + ", IO=" + m_objVisionIO.FailOffset.IsOn());
                    }
                    else
                    {
                        objTL.WriteLine(m_strPocketPositionTrackingData + ", Unit Result=" + blnResultOK + ", IO=" + m_blnInPocketFailOffset_Out);
                    }
                }

                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 52 ");
                WaitAllImageGrabDone();
                m_smVisionInfo.g_blnGrabbing = false;

                if (blnResultOK)
                {
                    m_smVisionInfo.g_strResult = "Pass";

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 53 ");
                    if (blnAuto)
                    {
                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 54 ");

                        if (m_smVisionInfo.g_blnTrackPocketCounter && !m_smCustomizeInfo.g_blnWantUseTCPIPIO) STTrackLog.WriteLine("Pass 1 g_intPassTotal=" + m_smVisionInfo.g_intPassTotal.ToString() + ", m_blnPassCounterAdded=" + m_blnPassCounterAdded.ToString() + ", m_blnFailCounterAdded=" + m_blnFailCounterAdded.ToString() + ", Rollb=" + m_objVisionIO.RollbackRetest.IsOn().ToString());
                        if (m_smVisionInfo.g_blnTrackPocketCounter && m_smCustomizeInfo.g_blnWantUseTCPIPIO) STTrackLog.WriteLine("Pass 1 g_intPassTotal=" + m_smVisionInfo.g_intPassTotal.ToString() + ", m_blnPassCounterAdded=" + m_blnPassCounterAdded.ToString() + ", m_blnFailCounterAdded=" + m_blnFailCounterAdded.ToString() + ", Rollb=" + m_blnInPocketRollbackRetest_In.ToString());

                        if (blnSkip)
                        {
                            if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Empty");

                            if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                            {
                                WaitEventDone(ref m_blnGrabbing_Out, false, 10000, "m_blnGrabbing_Out");//2021-03-24 ZJYEOH : Wait grab done send to handler first

                                if (!m_blnSentGrabDone)
                                {
                                    m_blnSentGrabDone = true;
                                    float fGrabDelay = 5 - m_smVisionInfo.g_objGrabTime.Timing;
                                    if (fGrabDelay >= 1)
                                        Thread.Sleep((int)fGrabDelay);

                                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO && m_blnAuto) //2021-11-16 ZJYEOH : Change m_smVisionInfo.g_intMachineStatus == 2 to m_blnAuto
                                    {
                                        m_smTCPIPIO.Send(m_smVisionInfo.g_intVisionIndex, "GRBRP", true, -1);
                                    }
                                }

                                //2021-03-24 ZJYEOH : Wait at least 5ms before send result
                                float fDelay = 5 - Math.Max(0, m_smVisionInfo.g_objTotalTime.Timing - m_smVisionInfo.g_objGrabTime.Duration);
                                if (fDelay >= 1)
                                    Thread.Sleep((int)fDelay);

                                if (m_blnCheckOffset_In)
                                    m_smTCPIPIO.Send_ResultForCheckOffset(m_smVisionInfo.g_intVisionIndex, true, m_blnOrientResult1_Out, m_blnOrientResult2_Out, m_fOffsetX, m_fOffsetY, m_fOffsetAngle, m_blnPocketPositionResult);
                                else
                                    m_smTCPIPIO.Send_Result(m_smVisionInfo.g_intVisionIndex, true, m_blnOrientResult1_Out, m_blnOrientResult2_Out, m_intTCPIPResultID);
                            }
                        }

                        //if (!blnSkip && !m_blnPassCounterAdded && !m_blnFailCounterAdded)   // 2019 06 05 - CCENG: blnSkip true mean check empty and Pass counter not going to add
                        //if (!blnSkip && !m_blnPassCounterAdded)   // 2019 06 05 - CCENG: blnSkip true mean check empty and Pass counter not going to add
                        if (!blnSkip && !m_blnPassCounterAdded && !m_blnRollback) // 2020 02 12 - CCENG: Make sure Rollback is Off 
                        {
                            m_smVisionInfo.g_intPassTotal++;
                            m_smVisionInfo.g_intContinuousPassUnitCount++;
                            m_blnPassCounterAdded = true;
                            m_blnTotalCounterAdded = false;
                            if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Pass 1a g_intPassTotal=" + m_smVisionInfo.g_intPassTotal.ToString() + ", m_blnPassCounterAdded=" + m_blnPassCounterAdded.ToString() + ", m_blnFailCounterAdded=" + m_blnFailCounterAdded.ToString());

                        }

                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 55 ");
                        //SavePassImage_AddToBuffer();
                    }
                    else
                    {
                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 56 ");
                        m_smVisionInfo.g_cErrorMessageColor = Color.Black;
                        m_smVisionInfo.g_strErrorMessage = "Offline Test Pass!";
                    }
                }
                else
                {
                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 57 ");
                    m_smVisionInfo.g_strResult = "Fail";
                    if (blnAuto)
                    {
                        if (!blnSkip)
                            m_smVisionInfo.g_intContinuousFailUnitCount++;
                        else
                        {

                            if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                            {
                                WaitEventDone(ref m_blnGrabbing_Out, false, 10000, "m_blnGrabbing_Out");//2021-03-24 ZJYEOH : Wait grab done send to handler first

                                if (!m_blnSentGrabDone)
                                {
                                    m_blnSentGrabDone = true;
                                    float fGrabDelay = 5 - m_smVisionInfo.g_objGrabTime.Timing;
                                    if (fGrabDelay >= 1)
                                        Thread.Sleep((int)fGrabDelay);

                                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO && m_blnAuto) //2021-11-16 ZJYEOH : Change m_smVisionInfo.g_intMachineStatus == 2 to m_blnAuto
                                    {
                                        m_smTCPIPIO.Send(m_smVisionInfo.g_intVisionIndex, "GRBRP", true, -1);
                                    }
                                }

                                //2021-03-24 ZJYEOH : Wait at least 5ms before send result
                                float fDelay = 5 - Math.Max(0, m_smVisionInfo.g_objTotalTime.Timing - m_smVisionInfo.g_objGrabTime.Duration);
                                if (fDelay >= 1)
                                    Thread.Sleep((int)fDelay);

                                if (m_blnWantPocketPositionTest)
                                    m_blnInPocketFailOffset_Out = false;

                                if (m_blnCheckOffset_In)
                                    m_smTCPIPIO.Send_ResultForCheckOffset(m_smVisionInfo.g_intVisionIndex, false, m_blnOrientResult1_Out, m_blnOrientResult2_Out, m_fOffsetX, m_fOffsetY, m_fOffsetAngle, m_blnPocketPositionResult);
                                else
                                    m_smTCPIPIO.Send_Result(m_smVisionInfo.g_intVisionIndex, false, m_blnOrientResult1_Out, m_blnOrientResult2_Out, m_intTCPIPResultID);

                            }
                        }
                    }
                    else
                    {
                        m_smVisionInfo.g_strErrorMessage = "Offline Test Fail! " + m_smVisionInfo.g_strErrorMessage;
                    }

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 58 ");
                }

                m_smVisionInfo.g_blnUnitInspected[0] = true;

                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 59 ");
                if (blnResultOK)
                {
                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 60 ");
                    if (blnAuto)
                    {
                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 61 ");

                        if (!m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                            m_objVisionIO.IOPass1.SetOn("V4 IOPass1 6");
                        else
                            m_blnPass1_Out = true;

                        //if (m_objVisionIO.CheckEmpty != null && m_objVisionIO.CheckEmpty.IsOn() && m_smVisionInfo.g_blnWantCheckEmpty)
                        if (m_blnCheckEmpty)
                        {
                            m_smVisionInfo.g_strResult = "Empty";
                            m_smVisionInfo.g_strErrorMessage = "*EmptyPass";
                            m_smVisionInfo.g_cErrorMessageColor = Color.Black;

                            SaveRejectImage_AddToBuffer("EmptyPass", m_smVisionInfo.g_strErrorMessage);
                        }
                        else
                            SavePassImage_AddToBuffer(0);

                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 62 ");
                    }
                    else
                    {
                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 63 ");
                        // m_smVisionInfo.g_blnWantCheckEmpty is from Advance Setting
                        // MN_PR_CheckEmptyUnit is from Vision4OfflinePage's Check Empty check box.
                        if (m_smVisionInfo.g_blnWantCheckEmpty && m_smVisionInfo.MN_PR_CheckEmptyUnit)
                        {
                            m_smVisionInfo.g_strResult = "Empty";
                            m_smVisionInfo.g_strErrorMessage = "*EmptyPass";
                            m_smVisionInfo.g_cErrorMessageColor = Color.Black;
                        }
                        else
                        {
                            m_smVisionInfo.g_strResult = "Pass";
                            if (blnAuto)
                                m_smVisionInfo.g_strErrorMessage = "*Pass";
                            else
                                m_smVisionInfo.g_strErrorMessage = "*Offline Test Pass!";
                            m_smVisionInfo.g_cErrorMessageColor = Color.Black;
                        }

                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 64 ");
                    }
                }
                else
                {
                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 65 ");
                    //if ((blnAuto && m_objVisionIO.CheckEmpty != null && m_objVisionIO.CheckEmpty.IsOn() && m_smVisionInfo.g_blnWantCheckEmpty) ||
                    //(!blnAuto && (m_smVisionInfo.MN_PR_CheckEmptyUnit && m_smVisionInfo.g_blnWantCheckEmpty)))
                    if (m_blnCheckEmpty)
                    {
                        if (m_smVisionInfo.g_blnWantUseEmptyThreshold || m_smVisionInfo.g_blnWantUseEmptyPattern)
                        {
                            m_smVisionInfo.g_strResult = "NoEmpty";
                            m_smVisionInfo.g_strErrorMessage = m_strErrorMsg;
                        }
                        else
                        {
                            m_smVisionInfo.g_strResult = "Fail";
                            m_smVisionInfo.g_strErrorMessage = "No Check Empty Method Selected!";
                        }

                    }
                    else //if (m_smVisionInfo.g_intUnitsOnImage == 1)   // 2016-06-08: Command it in order to support intUnitOnImage = 2 case.
                    {
                        m_smVisionInfo.g_strResult = "Fail";
                    }

                    if (blnAuto)
                    {
                        //if (m_objVisionIO.CheckEmpty != null && m_objVisionIO.CheckEmpty.IsOn() && m_smVisionInfo.g_blnWantCheckEmpty)
                        if (m_blnCheckEmpty)
                            SaveRejectImage_AddToBuffer("EmptyFail", m_smVisionInfo.g_strErrorMessage);
                    }

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 66 ");
                    m_smVisionInfo.g_blnPocket1Pass = false;
                }

                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 67 ");
                if (blnAuto)
                {
                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Total g_intTestedTotal=" + m_smVisionInfo.g_intTestedTotal.ToString() + ", blnAddTotalCounter=" + m_blnTotalCounterAdded.ToString());
                    if (!blnSkip && !m_blnTotalCounterAdded && (m_blnPassCounterAdded || m_blnFailCounterAdded))
                    {
                        m_smVisionInfo.g_intTestedTotal++;
                        m_smVisionInfo.g_intLowYieldUnitCount++;
                        m_blnTotalCounterAdded = true;
                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Total a g_intTestedTotal=" + m_smVisionInfo.g_intTestedTotal.ToString() + ", blnAddTotalCounter=" + m_blnTotalCounterAdded.ToString());
                    }
                    CheckLowYield();
                    CheckContinuousPass();
                    CheckContinuousFail();
                }

                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 68 ");
                // 2019 05 30 - JBTAN: Temporary solution for multi view test rotated images no update and show black image
                //// 2019 01 28 - CCENG: Not need purposely rotate image for user view.
                if (!m_blnRotateImage1Updated)
                {
                    if (m_smVisionInfo.g_arrImages.Count > 0)
                        m_smVisionInfo.g_arrImages[0].CopyTo(ref m_smVisionInfo.g_arrRotatedImages, 0);
                }

                if (!m_blnRotateImage2Updated)
                {
                    if (m_smVisionInfo.g_arrImages.Count > 1)
                        m_smVisionInfo.g_arrImages[1].CopyTo(ref m_smVisionInfo.g_arrRotatedImages, 1);
                }

                if (!m_blnRotateImage3Updated)
                {
                    if (m_smVisionInfo.g_arrImages.Count > 2)
                        m_smVisionInfo.g_arrImages[2].CopyTo(ref m_smVisionInfo.g_arrRotatedImages, 2);
                }

                if (!m_blnRotateImage4Updated)
                {
                    if (m_smVisionInfo.g_arrImages.Count > 3)
                        m_smVisionInfo.g_arrImages[3].CopyTo(ref m_smVisionInfo.g_arrRotatedImages, 3);
                }

                if (!m_blnRotateImage5Updated)
                {
                    if (m_smVisionInfo.g_arrImages.Count > 4)
                        m_smVisionInfo.g_arrImages[4].CopyTo(ref m_smVisionInfo.g_arrRotatedImages, 4);
                }

                if (!m_blnRotateImage6Updated)
                {
                    if (m_smVisionInfo.g_arrImages.Count > 5)
                        m_smVisionInfo.g_arrImages[5].CopyTo(ref m_smVisionInfo.g_arrRotatedImages, 5);
                }

                if (!m_blnRotateImage7Updated)
                {
                    if (m_smVisionInfo.g_arrImages.Count > 6)
                        m_smVisionInfo.g_arrImages[6].CopyTo(ref m_smVisionInfo.g_arrRotatedImages, 6);
                }

                if (((m_smCustomizeInfo.g_intWantPackage & (1 << m_smVisionInfo.g_intVisionPos)) > 0) || ((m_smCustomizeInfo.g_intWantLead & (1 << m_smVisionInfo.g_intVisionPos)) > 0))
                    m_bSubTh_StartAfterInspect = true;

                m_smVisionInfo.g_objProcessTime.Stop();

                if (m_smVisionInfo.VM_PR_ByPassUnit)
                {
                    m_smVisionInfo.m_blnUpdateResultUsingByPassSetting = true;
                    m_smVisionInfo.VM_PR_ByPassUnit = false;
                }

                m_smVisionInfo.VS_AT_UpdateQuantity = true;
                m_smVisionInfo.PR_VM_UpdateQuantity = true;

                if (m_blnWantPackageTest)
                {
                    m_smVisionInfo.g_blnDrawPkgResult = true;
                    m_smVisionInfo.g_blnPackageInspected = true;
                }
                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - 69 ");
                m_smVisionInfo.g_arrblnImageRotated[0] = m_blnRotateImage1Updated;
                m_smVisionInfo.g_arrblnImageRotated[1] = m_blnRotateImage2Updated;
                m_smVisionInfo.g_arrblnImageRotated[2] = m_blnRotateImage3Updated;
                m_smVisionInfo.g_arrblnImageRotated[3] = m_blnRotateImage4Updated;
                m_smVisionInfo.g_arrblnImageRotated[4] = m_blnRotateImage5Updated;
                m_smVisionInfo.g_arrblnImageRotated[5] = m_blnRotateImage6Updated;
                m_smVisionInfo.g_arrblnImageRotated[6] = m_blnRotateImage7Updated;

                // 2020 12 18 - CCENG: No need check also if ByPassUnit is true.
                if ((m_smCustomizeInfo.g_intWantLead & (1 << m_smVisionInfo.g_intVisionPos)) > 0 && m_smVisionInfo.g_arrLead[0].GetWantInspectLead() && !m_smVisionInfo.VM_PR_ByPassUnit)
                {
                    m_smVisionInfo.g_arrLead[0].ref_fCenterUnitCompensateAngle_ForDrawing = m_fOrientFinalAngleForLead - m_fLeadPatternAngle;
                }

                m_smVisionInfo.ALL_VM_UpdatePictureBox = true;

                //CheckLowYield();

                //m_fTiming = m_T1.Timing;
                //m_strTrack += ", Total=" + m_smVisionInfo.g_objProcessTime.Duration.ToString();
                //m_fTimingPrev = m_fTiming;

                //string[] spilt = m_strTrack.Split(',');
                //TrackLog t = new TrackLog();
                //for (int i = 0; i < spilt.Length; i++)
                //    t.WriteLine(spilt[i]);
                ////STTrackLog.WriteLine(m_strTrack);
            }
            catch (Exception ex)
            {
                SRMMessageBox.Show("Vision4Process StartTest :" + ex.ToString());
            }
            return;
        }

        private void StartTest_MultiThreading_2Units(bool blnAuto)
        {
            try
            {
                m_smVisionInfo.g_objProcessTime.Start();

                //m_T1.Start();
                //m_strTrack = "Inside Multithreading";
                //m_fTimingPrev = 0;
                //m_fTiming = 0;

                //m_fTiming = m_T1.Timing;
                //m_strTrack += ", A=" + (m_fTiming - m_fTimingPrev).ToString();
                //m_fTimingPrev = m_fTiming;


                // ---------- Reset Variables -------------------------------------------
                for (int u = 0; u < m_smVisionInfo.g_intUnitsOnImage; u++)
                    m_smVisionInfo.g_blnUnitInspected[u] = false;
                bool blnSkip = false;
                m_blnAuto = blnAuto;
                bool blnResultOK = true;
                bool blnResultOK2 = true;
                m_bMarkTestDone1 = false;
                m_bMarkTestDone2 = false;
                m_blnPocketPositionResult = false;
                m_blnOrientGaugeUpdated1 = false;
                m_blnOrientGaugeUpdated2 = false;
                m_blnOrientDataUpdated1 = false;
                m_blnOrientDataUpdated2 = false;
                m_blnRotateImage1Updated = false;
                m_blnRotateImage2Updated = false;
                m_blnRotateImage3Updated = false;
                m_blnRotateImage4Updated = false;
                m_blnRotateImage5Updated = false;
                m_blnRotateImage6Updated = false;
                m_blnRotateImage7Updated = false;
                m_smVisionInfo.g_blnMarkInspected = false;
                m_smVisionInfo.g_blnDrawMarkResult = false;
                m_smVisionInfo.g_blnDrawPkgResult = false;
                m_smVisionInfo.g_blnViewOrientObject = false;
                m_smVisionInfo.g_blnPackageInspected = false;
                m_bPackageSizeTestDone1 = false;
                m_bPackageSizeTestDone2 = false;
                m_bPackageSizePreTestDone1 = false;
                m_bPackageSizePreTestDone2 = false;
                m_bPackageSizePreTestResult1 = false;
                m_bPackageSizePreTestResult2 = false;
                m_intScenario = 0x00;
                m_smVisionInfo.m_blnUpdateResultUsingByPassSetting = false;

                m_smVisionInfo.g_blnGrabbing = true;
                m_bGrabImageFinalResult = m_bGrabImage1Result = m_bGrabImage2Result = m_bGrabImage3Result = m_bGrabImage4Result = m_bGrabImage5Result = m_bGrabImage6Result = m_bGrabImage7Result = false;
                m_bGrabImage1Done = m_bGrabImage2Done = m_bGrabImage3Done = m_bGrabImage4Done = m_bGrabImage5Done = m_bGrabImage6Done = m_bGrabImage7Done = false;
                m_smVisionInfo.g_blnNoGrabTime = false;

                //if (m_smVisionInfo.g_intTestedTotal == 0)
                //    m_intTestCount = 0;

                if (m_smVisionInfo.g_blnTrackPocketCounter)
                {
                    if (blnAuto)
                        STTrackLog.WriteLine("----- Start Test2 - Auto " + m_intTestCount.ToString() + " -----");
                    else
                        STTrackLog.WriteLine("----- Start Test2 - Offline " + m_intTestCount.ToString() + " -----");
                }

                m_intTestCount++;

                if (!m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                {
                    if (m_objVisionIO.InPocketReTest.IsOff(!m_blnDefaultRetestON))   // Retest OFF mean new unit test.
                    {
                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("1. Retest Off = false, false, false");
                        m_blnPassCounterAdded = false;      // Reset recorded pass counter 
                        m_blnFailCounterAdded = false;      // Reset recorded fail counter
                        m_blnTotalCounterAdded = false;
                    }
                    else
                    {
                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("1. Retest ON = __, false, false");
                        m_blnFailCounterAdded = false;
                        m_blnTotalCounterAdded = false;
                    }

                    if (m_objVisionIO.PackageFail != null)
                        if (m_objVisionIO.PackageFail.IsOn())
                            m_objVisionIO.PackageFail.SetOff("V4 PackageFail 100");

                    if (m_objVisionIO.FailOffset != null)
                        if (m_objVisionIO.FailOffset.IsOn())
                            m_objVisionIO.FailOffset.SetOff("V4 FailOffset 101");
                }
                else
                {
                    if (!m_blnInPocketReTest_In)   // Retest OFF mean new unit test.
                    {
                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("1. Retest Off = false, false, false");
                        m_blnPassCounterAdded = false;      // Reset recorded pass counter 
                        m_blnFailCounterAdded = false;      // Reset recorded fail counter
                        m_blnTotalCounterAdded = false;
                    }
                    else
                    {
                        m_blnFailCounterAdded = false;
                        m_blnTotalCounterAdded = false;
                    }

                    m_blnPackageFail_Out = false;

                    m_blnInPocketFailOffset_Out = false;
                }

                // ---------- Define m_intScenario to check unit 1 or unit 2 or both -----------------------
                if (blnAuto)
                {
                    //Thread.Sleep(m_smVisionInfo.g_intCameraGrabDelay); //29-05-2019 ZJYEOH : Moved it to After Grabtime Start counting 

                    if (!m_smProductionInfo.g_blnAllRunWithoutGrabImage)
                    {
                        m_bSubTh1_GrabImage = true;

                        // check IO trigger status
                        if (m_smVisionInfo.g_blnDebugRUN)   // Check both pocket if Debug Run
                        {
                            m_intScenario |= 0x01;
                            if (!m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                                m_objVisionIO.IOPass1.SetOff("V4 IOPass1 103");
                            else
                                m_blnPass1_Out = false;

                            m_intScenario |= 0x02;
                            if (!m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                                m_objVisionIO.IOPass2.SetOff("V4 IOPass2 104");
                            else
                                m_blnPass2_Out = false;
                        }

                        if (!m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        {
                            if (m_objVisionIO.InPocketCheckUnit1.IsOn())
                            {
                                m_intScenario |= 0x01;
                                m_objVisionIO.IOPass1.SetOff("V4 IOPass1 105");
                                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("IOPass1.SetOff");
                            }

                            if (m_objVisionIO.InPocketReCheckUnit2 != null)
                                if (m_objVisionIO.InPocketReCheckUnit2.IsOn())
                                {
                                    m_intScenario |= 0x02;
                                    m_objVisionIO.IOPass2.SetOff("V4 IOPass2 106");
                                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("IOPass2.SetOff");

                                    // 23-07-2019 ZJYEOH : if only check unit 2 means retest, no need add any counter
                                    if (m_intScenario == 2)
                                    {
                                        m_blnFailCounterAdded = true;
                                        m_blnPassCounterAdded = true;
                                        m_blnTotalCounterAdded = true;
                                    }
                                }

                            if (m_objVisionIO.InPocketReTest.IsOn(m_blnDefaultRetestON)) // 23-07-2019 ZJYEOH : if Retest IO On, need reset fail and total counter boolean
                            {
                                m_blnFailCounterAdded = false;
                                //m_blnTotalCounterAdded = false;
                            }
                        }
                        else
                        {
                            if (m_blnInPocketCheckUnit1_In)
                            {
                                m_intScenario |= 0x01;
                                m_blnPass1_Out = false;
                                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("IOPass1.SetOff");
                            }

                            if (m_blnInPocketReCheckUnit2_In)
                            {
                                m_intScenario |= 0x02;
                                m_blnPass2_Out = false;
                                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("IOPass2.SetOff");

                                // 23-07-2019 ZJYEOH : if only check unit 2 means retest, no need add any counter
                                if (m_intScenario == 2)
                                {
                                    m_blnFailCounterAdded = true;
                                    m_blnPassCounterAdded = true;
                                    m_blnTotalCounterAdded = true;
                                }
                            }

                            if (m_blnInPocketReTest_In) // 23-07-2019 ZJYEOH : if Retest IO On, need reset fail and total counter boolean
                            {
                                m_blnFailCounterAdded = false;
                                //m_blnTotalCounterAdded = false;
                            }
                        }

                    }
                    else // Debug run without grab image
                    {
                        m_smVisionInfo.g_objGrabTime.Reset();
                        m_smVisionInfo.g_objTransferTime.Reset();
                        m_smVisionInfo.g_blnGrabbing = false;
                        m_bGrabImage1Result = m_bGrabImage2Result = m_bGrabImage3Result = m_bGrabImage4Result = m_bGrabImage5Result = m_bGrabImage6Result = m_bGrabImage7Result = true;
                        m_bGrabImage1Done = m_bGrabImage2Done = m_bGrabImage3Done = m_bGrabImage4Done = m_bGrabImage5Done = m_bGrabImage6Done = m_bGrabImage7Done = true;
                        m_smVisionInfo.g_blnNoGrabTime = true;

                        m_intScenario = 0x03;

                        // 23-07-2019 ZJYEOH : if only check unit 2 means retest, if Retest IO Off, mean not last retest, Fail counter no need to add.
                        //                     if only check unit 2 means retest, if Retest IO ON, mean last retest, Fail counter no need to add if test fail.
                        if (m_intScenario == 2)
                        {
                            m_blnFailCounterAdded = true;
                            m_blnTotalCounterAdded = true;
                            m_blnPassCounterAdded = true;
                        }

                        if (m_objVisionIO.InPocketReTest.IsOn(m_blnDefaultRetestON)) // 23-07-2019 ZJYEOH : if Retest IO On, need reset fail and total counter boolean
                        {
                            m_blnFailCounterAdded = false;
                            //m_blnTotalCounterAdded = false;   // 2021 07 12 - CCENG: No need set m_blnTotalCounterAdded to false. m_blnTotalCounterAdded will be set to false when Fail Counter ++. 
                        }

                        m_blnPassCounterAdded = true;
                    }
                }
                else
                {
                    m_intScenario = 0x03;

                    if (m_smVisionInfo.MN_PR_GrabImage)
                    {
                        m_smVisionInfo.MN_PR_GrabImage = false;

                        m_bSubTh1_GrabImage = true;
                    }
                    else
                    {
                        m_smVisionInfo.g_objGrabTime.Reset();
                        m_smVisionInfo.g_objTransferTime.Reset();
                        m_smVisionInfo.g_blnGrabbing = false;
                        m_bGrabImage1Result = m_bGrabImage2Result = m_bGrabImage3Result = m_bGrabImage4Result = m_bGrabImage5Result = m_bGrabImage6Result = m_bGrabImage7Result = true;
                        m_bGrabImage1Done = m_bGrabImage2Done = m_bGrabImage3Done = m_bGrabImage4Done = m_bGrabImage5Done = m_bGrabImage6Done = m_bGrabImage7Done = true;
                        m_smVisionInfo.g_blnNoGrabTime = true;
                    }
                }

                //STTrackLog.WriteLine("Senario: " + m_intScenario.ToString());

                // ----------- Define what test going to do --------------------------------------------
                if ((m_smCustomizeInfo.g_intWantPackage & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
                {
                    if (!m_blnWantPackageTest)
                        m_blnWantPackageTest = true;
                }
                else
                {
                    if (m_blnWantPackageTest)
                        m_blnWantPackageTest = false;
                }


                if ((m_smCustomizeInfo.g_intWantPositioning & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
                {
                    if (!m_blnWantPositioning)
                        m_blnWantPositioning = true;
                }
                else
                {
                    if (m_blnWantPositioning)
                        m_blnWantPositioning = false;
                }

                if ((m_smCustomizeInfo.g_intWantOrient & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
                {
                    if (!m_blnWantOrientTest)
                        m_blnWantOrientTest = true;
                }
                else
                {
                    if (m_blnWantOrientTest)
                        m_blnWantOrientTest = false;
                }

                if ((m_smCustomizeInfo.g_intWantMark & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
                {
                    if (!m_blnWantMarkTest)
                        m_blnWantMarkTest = true;
                }
                else
                {
                    if (m_blnWantMarkTest)
                        m_blnWantMarkTest = false;
                }

                if ((m_smCustomizeInfo.g_intWantLead & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
                {
                    if (!m_blnWantLeadTest)
                        m_blnWantLeadTest = true;
                }
                else
                {
                    if (m_blnWantLeadTest)
                        m_blnWantLeadTest = false;
                }

                // If retest, counter will not add. Counter only add if EndOfReTest if ON
                if (m_smCustomizeInfo.g_blnShareHandlerPC)
                {
#if(RTXDebug || RTXRelease)

                    if (SRMSingleLock("IPM1_EndOfRetest"))
                        m_smVisionInfo.g_blnInPocketRetestEnd = true;
                    else
                        m_smVisionInfo.g_blnInPocketRetestEnd = false;
#endif
                }
                else
                {
                    // 2019 07 17 - JBTAN: Copy from XP version way of handling 2 units
                    if (!m_smCustomizeInfo.g_blnWantUseTCPIPIO && m_objVisionIO.InPocketReTest.IsOn(m_blnDefaultRetestON))                   // Use Retest IO bcos no EndOfRetest IO in MarkOrient IPM.
                    {
                        m_smVisionInfo.g_blnInPocketRetestEnd = true;
                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("InPocketReTest is On");
                    }
                    else if (m_smCustomizeInfo.g_blnWantUseTCPIPIO && m_blnInPocketReTest_In)                   // Use Retest IO bcos no EndOfRetest IO in MarkOrient IPM.
                    {
                        m_smVisionInfo.g_blnInPocketRetestEnd = true;
                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("InPocketReTest is On");
                    }
                    else
                    {
                        m_smVisionInfo.g_blnInPocketRetestEnd = false;
                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("InPocketReTest is Off");
                    }

                    if (m_smVisionInfo.g_blnTrackPocketCounter && !m_smCustomizeInfo.g_blnWantUseTCPIPIO) STTrackLog.WriteLine("2.1a EndRetest IO" + m_objVisionIO.EndOfReTest.IsOn().ToString() + ", Rollback IO" + m_objVisionIO.RollbackRetest.IsOn().ToString() + ", blnInPocketRetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString());
                    if (m_smVisionInfo.g_blnTrackPocketCounter && m_smCustomizeInfo.g_blnWantUseTCPIPIO) STTrackLog.WriteLine("2.1b EndRetest IO" + m_blnInPocketEndOfReTest_In.ToString() + ", Rollback IO" + m_blnInPocketRollbackRetest_In.ToString() + ", blnInPocketRetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString());
                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("m_blnPassCounterAdded=" + m_blnPassCounterAdded.ToString() + ", m_blnFailCounterAdded=" + m_blnFailCounterAdded.ToString() + ", m_blnTotalCounterAdded=" + m_blnTotalCounterAdded.ToString());
                }

                // ------------------ Reset Inspection data ----------------------------------------------
                if (m_blnWantPackageTest)
                {
                    for (int i = 0; i < m_smVisionInfo.g_arrPackage.Count; i++)
                        m_smVisionInfo.g_arrPackage[i].ResetPackageInspectionData();
                }

                if (m_smVisionInfo.g_blnWantPin1)
                {
                    for (int i = 0; i < m_smVisionInfo.g_arrPin1.Count; i++)
                    {
                        m_smVisionInfo.g_arrPin1[i].ResetInspectionData();
                    }
                }

                if (!blnSkip)
                {
                    // ----------------- Trigger Sub Thread test now -----------------------------------------
#if (DEBUG || Debug_2_12 || RTXDebug)
                    if (m_blnWantMarkTest || m_blnWantOrientTest)
                    {
                        m_bSubTh_MarkTest = true;
                    }
                    else
                    {
                        m_bSubTh_MarkTest_Result = true;
                        m_bSubTh_MarkTest_Result2 = true;
                    }

                    if (m_blnWantPackageTest)
                    {
                        m_bSubTh_PackageTest_MarkLightView = true;

                        m_bSubTh_PackageTest_SideLightView = true;
                        m_bSubTh_PackageTest_TopLightView = true;
                        //m_bSubTh_PackageTest_SideLightView_Result = true;
                        //m_bSubTh_PackageTest_TopLightView_Result = true;
                    }
                    else
                    {
                        m_bSubTh_PackageTest_MarkLightView_Result = true;
                        m_bSubTh_PackageTest_SideLightView_Result = true;
                        m_bSubTh_PackageTest_TopLightView_Result = true;
                        m_bSubTh_PackageTest_MarkLightView_Result2 = true;
                        m_bSubTh_PackageTest_SideLightView_Result2 = true;
                        m_bSubTh_PackageTest_TopLightView_Result2 = true;
                    }

                    if (m_blnWantLeadTest)
                    {
                        m_bSubTh_LeadTest = true;
                    }
                    else
                    {
                        m_bSubTh_LeadTest_Result = true;
                    }

#else
                   // 2020 08 01 - CCENG: Goodark customer request to check minimum mark score when press bypass button in IPM
                    //if (m_smVisionInfo.VM_PR_ByPassUnit)
                    //{
                    //    m_smVisionInfo.VM_PR_ByPassUnit = false;

                    //    Thread.Sleep(10);   // Sleep 10 to make sure EOV signal OFF enough long to be detected by handler

                    //    m_bSubTh_MarkTest_Result = true;
                    //    m_bSubTh_PackageTest_MarkLightView_Result = true;
                    //    m_bSubTh_PackageTest_SideLightView_Result = true;
                    //    m_bSubTh_PackageTest_TopLightView_Result = true;
                    //    m_bSubTh_LeadTest_Result = true;
                    //    m_bSubTh_MarkTest_Result2 = true;
                    //    //m_bSubTh_PackageTest_MarkLightView_Result2 = true;
                    //    //m_bSubTh_PackageTest_SideLightView_Result2 = true;
                    //    //m_bSubTh_PackageTest_TopLightView_Result2 = true;
                    //    //m_bSubTh_LeadTest_Result2 = true;
                    //}
                    //else
                    {
                        if (m_blnWantMarkTest || m_blnWantOrientTest)
                        {
                            m_bSubTh_MarkTest = true;
                        }
                        else
                        {
                            m_bSubTh_MarkTest_Result = true;
                            m_bSubTh_MarkTest_Result2 = true;
                        }

                        if (m_blnWantPackageTest)
                        {
                            m_bSubTh_PackageTest_MarkLightView = true;
                            m_bSubTh_PackageTest_SideLightView = true;
                            m_bSubTh_PackageTest_TopLightView = true;
                        }
                        else
                        {
                            m_bSubTh_PackageTest_MarkLightView_Result = true;
                            m_bSubTh_PackageTest_SideLightView_Result = true;
                            m_bSubTh_PackageTest_TopLightView_Result = true;
                            m_bSubTh_PackageTest_MarkLightView_Result2 = true;
                            m_bSubTh_PackageTest_SideLightView_Result2 = true;
                            m_bSubTh_PackageTest_TopLightView_Result2 = true;
                        }

                        if (m_blnWantLeadTest)
                        {
                            m_bSubTh_LeadTest = true;
                        }
                        else
                        {
                            m_bSubTh_LeadTest_Result = true;
                            //m_bSubTh_LeadTest_Result2 = true;
                        }
                    }
#endif
                    // ------------------ Wait Sub Thread Test done --------------------------------------------------
                    //STTrackLog.WriteLine("m_blnWantPackageTest = " + m_blnWantPackageTest.ToString());
                    //STTrackLog.WriteLine("m_bSubTh_MarkTest Before infinite loop = " + m_bSubTh_MarkTest.ToString());
                    bool blnInspectionDone = false;
                    HiPerfTimer timeout = new HiPerfTimer();
                    timeout.Start();
                    while (true)
                    {
                        if (!m_bSubTh_MarkTest
                            &&
                            !m_bSubTh_PackageTest_MarkLightView &&
                            !m_bSubTh_PackageTest_SideLightView &&
                            !m_bSubTh_PackageTest_TopLightView
                            //&&
                            //!m_bSubTh_LeadTest
                            )
                        {

                            blnInspectionDone = true;
                            break;
                        }

#if (RELEASE || RTXRelease || Release_2_12)
                        if (timeout.Timing > 10000) // 2020 02 18 - CCENG: Change to 10ms to prevent inspection time out due to debug run too fast.
                    {
                        STTrackLog.WriteLine(">>>>>>>>>>>>> Vision 4 - time out 7");
                        break;
                    }
#endif
                        Thread.Sleep(1);
                    }

                    //STTrackLog.WriteLine("blnInspectionDone = " + blnInspectionDone.ToString());
                    //STTrackLog.WriteLine("m_bSubTh_MarkTest After infinite loop = " + m_bSubTh_MarkTest.ToString());
                    // ---------------------- Action after Sub Thread Test Done -----------------------------------------------------------
                    if (m_smVisionInfo.g_blnUnitInspected.Length > 0 && m_intScenario != 2)
                        m_smVisionInfo.g_blnUnitInspected[0] = true;

                    if (m_smVisionInfo.g_blnUnitInspected.Length > 1 && m_smVisionInfo.g_intUnitsOnImage == 2 && m_intScenario > 1)
                        m_smVisionInfo.g_blnUnitInspected[1] = true;

                    // ------------------ Set IO to handler (set before save image for faster UPH) ----------------------------------------
                    switch (m_intScenario)
                    {
                        case 1:
                            m_smVisionInfo.g_intScenario = 0x01;

                            // Define Final result is pass or fail for unit 1.
                            if (blnInspectionDone &&
                                m_bSubTh_MarkTest_Result
                                &&
                                m_bSubTh_PackageTest_MarkLightView_Result &&
                                m_bSubTh_PackageTest_SideLightView_Result &&
                                m_bSubTh_PackageTest_TopLightView_Result
                                //&&
                                //m_bSubTh_LeadTest_Result
                                )
                            {
                                if (blnAuto)
                                {
                                    if (!m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                                        m_objVisionIO.IOPass1.SetOn("V4 IOPass1 4");
                                    else
                                        m_blnPass1_Out = true;
                                    //STTrackLog.WriteLine("IOPass1.SetOn");
                                }

                                blnResultOK = true;
                                m_smVisionInfo.g_blnPocket1Pass = true;
                            }
                            else
                            {
                                blnResultOK = false;
                                m_smVisionInfo.g_blnPocket1Pass = false;
                            }
                            //blnResultOK2 = false;
                            break;
                        case 2:
                            // Define Final result is pass or fail for unit 2.
                            if (blnInspectionDone && m_bSubTh_MarkTest_Result2
                             &&
                            m_bSubTh_PackageTest_MarkLightView_Result2 &&
                            m_bSubTh_PackageTest_SideLightView_Result2 &&
                            m_bSubTh_PackageTest_TopLightView_Result2
                            //&&
                            //m_bSubTh_LeadTest_Result2
                            )
                            {
                                if (blnAuto)
                                {
                                    if (!m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                                        m_objVisionIO.IOPass2.SetOn("V4 IOPass2 4");
                                    else
                                        m_blnPass2_Out = true;
                                    //STTrackLog.WriteLine("IOPass2.SetOn");
                                }

                                //unit 1 index and its fail,reinspect update test result
                                if (m_smVisionInfo.g_blnPocket2Pass == false && m_smVisionInfo.g_intScenario == 0x03)
                                {
                                    if (blnAuto)
                                    {
                                        m_blnPassCounterAdded = false;
                                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("100 Set m_blnPassCounterAdded=" + m_blnPassCounterAdded.ToString());
                                    }
                                    if (!m_smVisionInfo.g_blnInPocketLastUnit)
                                        m_smVisionInfo.g_blnPocket1Pass = true;

                                    m_smVisionInfo.g_blnPocket2Pass = true;
                                    m_smVisionInfo.g_blnInPocketLastUnit = false;
                                }
                                else if (m_smVisionInfo.g_blnPocket2Pass == true)
                                {
                                    if (CheckIsLastUnit())
                                    {
                                        //STTrackLog.WriteLine("Is last unit");

                                        if (blnAuto)
                                        {
                                            m_blnPassCounterAdded = false;
                                            if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("101 Set m_blnPassCounterAdded=" + m_blnPassCounterAdded.ToString());
                                        }
                                        if (!m_smVisionInfo.g_blnInPocketLastUnit)
                                            m_smVisionInfo.g_blnPocket1Pass = true;

                                        m_smVisionInfo.g_blnPocket2Pass = true;

                                        m_smVisionInfo.g_blnInPocketLastUnit = false;
                                    }
                                }

                                blnResultOK2 = true;
                            }
                            else
                                blnResultOK2 = false;
                            //blnResultOK = false;
                            break;
                        case 3:
                            //means unit 1 index already
                            m_smVisionInfo.g_intScenario = 0x03;

                            // Define Final result is pass or fail for unit 2.
                            if (blnInspectionDone && m_bSubTh_MarkTest_Result2
                             &&
                            m_bSubTh_PackageTest_MarkLightView_Result2 &&
                            m_bSubTh_PackageTest_SideLightView_Result2 &&
                            m_bSubTh_PackageTest_TopLightView_Result2
                            //&&
                            //m_bSubTh_LeadTest_Result2
                            )
                            {
                                if (blnAuto)
                                {
                                    if (!m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                                        m_objVisionIO.IOPass2.SetOn("V4 IOPass2 4");
                                    else
                                        m_blnPass2_Out = true;
                                    //STTrackLog.WriteLine("IOPass2.SetOn");
                                    m_blnPassCounterAdded = false;
                                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("102 Set m_blnPassCounterAdded=" + m_blnPassCounterAdded.ToString());
                                }

                                m_smVisionInfo.g_blnPocket2Pass = true;
                                blnResultOK2 = true;
                            }
                            else
                            {
                                m_smVisionInfo.g_blnInPocketLastUnit = true;
                                m_smVisionInfo.g_blnPocket1Pass = false;
                                m_smVisionInfo.g_blnPocket2Pass = false;
                                blnResultOK2 = false;
                                //if (blnAuto)
                                //    break;
                            }

                            // Define Final result is pass or fail for unit 1.
                            if (blnInspectionDone &&
                                m_bSubTh_MarkTest_Result
                                &&
                                m_bSubTh_PackageTest_MarkLightView_Result &&
                                m_bSubTh_PackageTest_SideLightView_Result &&
                                m_bSubTh_PackageTest_TopLightView_Result
                                //&&
                                //m_bSubTh_LeadTest_Result
                                )
                            {
                                if (blnAuto)
                                {
                                    if (!m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                                        m_objVisionIO.IOPass1.SetOn("V4 IOPass1 4");
                                    else
                                        m_blnPass1_Out = true;
                                    //STTrackLog.WriteLine("IOPass1.SetOn");
                                    m_blnPassCounterAdded = false;
                                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("103 Set m_blnPassCounterAdded=" + m_blnPassCounterAdded.ToString());
                                }

                                m_smVisionInfo.g_blnPocket1Pass = true;
                                blnResultOK = true;
                            }
                            else
                            {
                                m_smVisionInfo.g_blnInPocketLastUnit = true;
                                m_smVisionInfo.g_blnPocket1Pass = false;
                                blnResultOK = false;
                            }
                            break;
                    }
                    if (!m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        m_objVisionIO.IOEndVision.SetOn("V4 IOEndVision 5");
                    else
                        m_blnEndVision_Out = true;
                    // Wait all images grab done to make sure latest images are saved.   
                }

                //2020-11-13 ZJYEOH : Reset retry count for fail image name when unit 2 pass
                if (!m_smCustomizeInfo.g_blnWantUseTCPIPIO && m_objVisionIO.IOPass2.IsOn())
                {
                    m_intRetryCount = 0;
                }
                else if (m_smCustomizeInfo.g_blnWantUseTCPIPIO && m_blnPass2_Out)
                {
                    m_intRetryCount = 0;
                }

                WaitAllImageGrabDone();
                m_smVisionInfo.g_blnGrabbing = false;

                switch (m_intScenario)
                {
                    case 1:
                        if (blnResultOK)
                        {
                            m_smVisionInfo.g_strResult = "Pass";
                            m_smVisionInfo.g_strResult2 = "----";

                            if (blnAuto)
                            {
                                if (m_smVisionInfo.g_blnTrackPocketCounter)
                                    STTrackLog.WriteLine("Pass 1 g_intPassTotal=" + m_smVisionInfo.g_intPassTotal.ToString() + ", m_blnPassCounterAdded=" + m_blnPassCounterAdded.ToString() + ", m_blnFailCounterAdded=" + m_blnFailCounterAdded.ToString());
                                //if (!blnSkip && !m_blnPassCounterAdded && !m_blnFailCounterAdded)   // 2019 06 05 - CCENG: blnSkip true mean check empty and Pass counter not going to add
                                if (!blnSkip && !m_blnPassCounterAdded)   // 2019 06 05 - CCENG: blnSkip true mean check empty and Pass counter not going to add
                                {
                                    m_smVisionInfo.g_intPassTotal++;
                                    m_smVisionInfo.g_intContinuousPassUnitCount++;
                                    m_blnPassCounterAdded = true;
                                    m_blnTotalCounterAdded = false;
                                    if (m_smVisionInfo.g_blnTrackPocketCounter)
                                        STTrackLog.WriteLine("Pass 1a g_intPassTotal=" + m_smVisionInfo.g_intPassTotal.ToString() + ", m_blnPassCounterAdded=" + m_blnPassCounterAdded.ToString() + ", m_blnFailCounterAdded=" + m_blnFailCounterAdded.ToString());

                                }
                                //SavePassImage_AddToBuffer();
                            }
                            else
                            {
                                m_smVisionInfo.g_cErrorMessageColor = Color.Black;
                                m_smVisionInfo.g_strErrorMessage = "Offline Test 1 Pass!";
                            }
                        }
                        else
                        {
                            m_smVisionInfo.g_strResult = "Fail";
                            m_smVisionInfo.g_strResult2 = "----";
                            if (!blnSkip && blnAuto)
                                m_smVisionInfo.g_intContinuousFailUnitCount++;
                        }

                        break;
                    case 2:
                        if (blnResultOK2)
                        {
                            m_smVisionInfo.g_strResult = "----";
                            m_smVisionInfo.g_strResult2 = "Pass";

                            if (blnAuto)
                            {
                                if (m_smVisionInfo.g_blnTrackPocketCounter)
                                    STTrackLog.WriteLine("Pass 2 g_intPassTotal=" + m_smVisionInfo.g_intPassTotal.ToString() + ", m_blnPassCounterAdded=" + m_blnPassCounterAdded.ToString() + ", m_blnFailCounterAdded=" + m_blnFailCounterAdded.ToString());
                                //if (!blnSkip && !m_blnPassCounterAdded && !m_blnFailCounterAdded)   // 2019 06 05 - CCENG: blnSkip true mean check empty and Pass counter not going to add
                                if (!blnSkip && !m_blnPassCounterAdded)   // 2019 06 05 - CCENG: blnSkip true mean check empty and Pass counter not going to add
                                {
                                    m_smVisionInfo.g_intPassTotal++;
                                    m_smVisionInfo.g_intContinuousPassUnitCount++;
                                    m_blnPassCounterAdded = true;
                                    m_blnTotalCounterAdded = false;
                                    if (m_smVisionInfo.g_blnTrackPocketCounter)
                                        STTrackLog.WriteLine("Pass 2a g_intPassTotal=" + m_smVisionInfo.g_intPassTotal.ToString() + ", m_blnPassCounterAdded=" + m_blnPassCounterAdded.ToString() + ", m_blnFailCounterAdded=" + m_blnFailCounterAdded.ToString());

                                }
                                //SavePassImage_AddToBuffer();
                            }
                            else
                            {
                                m_smVisionInfo.g_cErrorMessageColor = Color.Black;
                                m_smVisionInfo.g_strErrorMessage = "Offline Test 2 Pass!";
                            }
                        }
                        else
                        {
                            m_smVisionInfo.g_strResult = "----";
                            m_smVisionInfo.g_strResult2 = "Fail";
                            if (!blnSkip && blnAuto)
                                m_smVisionInfo.g_intContinuousFailUnitCount++;
                        }
                        break;
                    case 3:
                        if (blnResultOK2)
                        {
                            m_smVisionInfo.g_strResult2 = "Pass";

                            if (blnAuto)
                            {
                                if (m_smVisionInfo.g_blnTrackPocketCounter)
                                    STTrackLog.WriteLine("Pass 3.2 g_intPassTotal=" + m_smVisionInfo.g_intPassTotal.ToString() + ", m_blnPassCounterAdded=" + m_blnPassCounterAdded.ToString() + ", m_blnFailCounterAdded=" + m_blnFailCounterAdded.ToString());
                                if (!blnSkip && !m_blnPassCounterAdded)   // 2019 06 05 - CCENG: blnSkip true mean check empty and Pass counter not going to add
                                {
                                    m_smVisionInfo.g_intPassTotal++;
                                    m_smVisionInfo.g_intContinuousPassUnitCount++;
                                    m_blnPassCounterAdded = true;
                                    m_blnTotalCounterAdded = false;
                                    if (m_smVisionInfo.g_blnTrackPocketCounter)
                                        STTrackLog.WriteLine("Pass 3.2a g_intPassTotal=" + m_smVisionInfo.g_intPassTotal.ToString() + ", m_blnPassCounterAdded=" + m_blnPassCounterAdded.ToString() + ", m_blnFailCounterAdded=" + m_blnFailCounterAdded.ToString());

                                }
                                //SavePassImage_AddToBuffer();
                            }
                            else
                            {
                                m_smVisionInfo.g_cErrorMessageColorForSecondUnit = Color.Black;
                                m_smVisionInfo.g_strErrorMessageForSecondUnit = GetUnitName(1) + "Offline ReTest Pass!";
                            }
                        }
                        else
                        {
                            m_smVisionInfo.g_strResult2 = "Fail";
                            //m_smVisionInfo.g_strResult = "----";
                            if (!blnSkip && blnAuto)
                                m_smVisionInfo.g_intContinuousFailUnitCount++;
                            //if (blnAuto)
                            //    break; //Break if unit 2 fail
                        }

                        if (blnResultOK)
                        {
                            m_smVisionInfo.g_strResult = "Pass";

                            if (blnAuto)
                            {
                                if (m_smVisionInfo.g_blnTrackPocketCounter)
                                    STTrackLog.WriteLine("Pass 3.1 g_intPassTotal=" + m_smVisionInfo.g_intPassTotal.ToString() + ", m_blnPassCounterAdded=" + m_blnPassCounterAdded.ToString() + ", m_blnFailCounterAdded=" + m_blnFailCounterAdded.ToString());
                                //if (!blnSkip && !m_blnPassCounterAdded && !m_blnFailCounterAdded)   // 2019 06 05 - CCENG: blnSkip true mean check empty and Pass counter not going to add
                                if (!blnSkip)   // 2019 06 05 - CCENG: blnSkip true mean check empty and Pass counter not going to add
                                {
                                    m_smVisionInfo.g_intPassTotal++;
                                    m_smVisionInfo.g_intContinuousPassUnitCount++;
                                    m_blnPassCounterAdded = true;
                                    m_blnTotalCounterAdded = false;
                                    if (m_smVisionInfo.g_blnTrackPocketCounter)
                                        STTrackLog.WriteLine("Pass 3.1a g_intPassTotal=" + m_smVisionInfo.g_intPassTotal.ToString() + ", m_blnPassCounterAdded=" + m_blnPassCounterAdded.ToString() + ", m_blnFailCounterAdded=" + m_blnFailCounterAdded.ToString());

                                }
                                //SavePassImage_AddToBuffer();
                            }
                            else
                            {
                                //if (blnResultOK2)
                                //    m_smVisionInfo.g_cErrorMessageColor = Color.Black;
                                //else
                                //    m_smVisionInfo.g_cErrorMessageColor = Color.Red;
                                m_smVisionInfo.g_cErrorMessageColor = Color.Black;
                                m_smVisionInfo.g_strErrorMessage += GetUnitName(0) + "Offline Test Pass!";
                            }
                        }
                        else
                        {
                            m_smVisionInfo.g_strResult = "Fail";
                            if (!blnSkip && blnAuto)
                                m_smVisionInfo.g_intContinuousFailUnitCount++;
                        }

                        break;
                }

                //for (int u = 0; u < m_smVisionInfo.g_intUnitsOnImage; u++)
                //    m_smVisionInfo.g_blnUnitInspected[u] = true;

                if (blnResultOK && blnResultOK2)
                //if (false)
                {
                    if (blnAuto)
                    {
                        if (!m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                            m_objVisionIO.IOPass1.SetOn("V4 IOPass1 6");
                        else
                            m_blnPass1_Out = true;

                        //if (m_objVisionIO.CheckEmpty != null && m_objVisionIO.CheckEmpty.IsOn() && m_smVisionInfo.g_blnWantCheckEmpty)
                        if (m_blnCheckEmpty)
                        {
                            m_smVisionInfo.g_strResult = "Empty";
                            m_smVisionInfo.g_strErrorMessage = "*EmptyPass";
                            m_smVisionInfo.g_cErrorMessageColor = Color.Black;

                            SaveRejectImage_AddToBuffer("EmptyPass", m_smVisionInfo.g_strErrorMessage);
                        }
                        else
                            SavePassImage_AddToBuffer(0);


                    }
                    //else
                    //{
                    //    // m_smVisionInfo.g_blnWantCheckEmpty is from Advance Setting
                    //    // MN_PR_CheckEmptyUnit is from Vision4OfflinePage's Check Empty check box.
                    //    if (m_smVisionInfo.g_blnWantCheckEmpty && m_smVisionInfo.MN_PR_CheckEmptyUnit)
                    //    {
                    //        m_smVisionInfo.g_strResult = "Empty";
                    //        m_smVisionInfo.g_strErrorMessage = "*EmptyPass";
                    //        m_smVisionInfo.g_cErrorMessageColor = Color.Black;
                    //    }
                    //    else
                    //    {
                    //        m_smVisionInfo.g_strResult = "Pass";
                    //        m_smVisionInfo.g_strErrorMessage = "*Pass";
                    //        m_smVisionInfo.g_cErrorMessageColor = Color.Black;
                    //    }
                    //}
                }
                else
                {
                    if (!m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    {
                        if (blnAuto)
                        {
                            if (m_objVisionIO.CheckEmpty != null && m_objVisionIO.CheckEmpty.IsOn() && m_smVisionInfo.g_blnWantCheckEmpty)
                                SaveRejectImage_AddToBuffer("EmptyFail", m_smVisionInfo.g_strErrorMessage);
                        }

                        if ((blnAuto && m_objVisionIO.CheckEmpty != null && m_objVisionIO.CheckEmpty.IsOn() && m_smVisionInfo.g_blnWantCheckEmpty) ||
                        (!blnAuto && (m_smVisionInfo.MN_PR_CheckEmptyUnit && m_smVisionInfo.g_blnWantCheckEmpty)))
                        {
                            if (m_smVisionInfo.g_blnWantUseEmptyThreshold || m_smVisionInfo.g_blnWantUseEmptyPattern)
                            {
                                m_smVisionInfo.g_strResult = "NoEmpty";
                                m_smVisionInfo.g_strErrorMessage = m_strErrorMsg;
                            }
                            else
                            {
                                m_smVisionInfo.g_strResult = "Fail";
                                m_smVisionInfo.g_strErrorMessage = "No Check Empty Method Selected!";
                            }

                        }
                    }
                    else
                    {
                        if (blnAuto)
                        {
                            if (m_blnInPocketCheckEmpty_In && m_smVisionInfo.g_blnWantCheckEmpty)
                                SaveRejectImage_AddToBuffer("EmptyFail", m_smVisionInfo.g_strErrorMessage);
                        }

                        if ((blnAuto && m_blnInPocketCheckEmpty_In && m_smVisionInfo.g_blnWantCheckEmpty) ||
                        (!blnAuto && (m_smVisionInfo.MN_PR_CheckEmptyUnit && m_smVisionInfo.g_blnWantCheckEmpty)))
                        {
                            if (m_smVisionInfo.g_blnWantUseEmptyThreshold || m_smVisionInfo.g_blnWantUseEmptyPattern)
                            {
                                m_smVisionInfo.g_strResult = "NoEmpty";
                                m_smVisionInfo.g_strErrorMessage = m_strErrorMsg;
                            }
                            else
                            {
                                m_smVisionInfo.g_strResult = "Fail";
                                m_smVisionInfo.g_strErrorMessage = "No Check Empty Method Selected!";
                            }

                        }
                    }
                    
                }
                
                if (blnAuto)
                {
                    switch (m_intScenario)
                    {
                        case 1:
                            if (m_smVisionInfo.g_blnTrackPocketCounter)
                                STTrackLog.WriteLine("Total 1 g_intTestedTotal=" + m_smVisionInfo.g_intTestedTotal.ToString() + ", m_blnTotalCounterAdded=" + m_blnTotalCounterAdded.ToString() + ", m_blnPassCounterAdded=" + m_blnPassCounterAdded.ToString() + ", m_blnFailCounterAdded=" + m_blnFailCounterAdded.ToString());
                            if (!blnSkip && !m_blnTotalCounterAdded && m_blnPassCounterAdded)
                            {
                                m_smVisionInfo.g_intTestedTotal++;
                                m_smVisionInfo.g_intLowYieldUnitCount++;

                                m_blnTotalCounterAdded = true;
                                if (m_smVisionInfo.g_blnTrackPocketCounter)
                                    STTrackLog.WriteLine("Total 1a g_intTestedTotal=" + m_smVisionInfo.g_intTestedTotal.ToString() + ", m_blnTotalCounterAdded=" + m_blnTotalCounterAdded.ToString() + ", m_blnPassCounterAdded=" + m_blnPassCounterAdded.ToString() + ", m_blnFailCounterAdded=" + m_blnFailCounterAdded.ToString());
                            }
                            break;
                        case 2:
                            if (m_smVisionInfo.g_blnTrackPocketCounter)
                                STTrackLog.WriteLine("Total 2 g_intTestedTotal=" + m_smVisionInfo.g_intTestedTotal.ToString() + ", m_blnTotalCounterAdded=" + m_blnTotalCounterAdded.ToString() + ", m_blnPassCounterAdded=" + m_blnPassCounterAdded.ToString() + ", m_blnFailCounterAdded=" + m_blnFailCounterAdded.ToString());
                            if (!blnSkip && !m_blnTotalCounterAdded && (m_blnPassCounterAdded || m_blnFailCounterAdded))
                            {
                                m_smVisionInfo.g_intTestedTotal++;
                                m_smVisionInfo.g_intLowYieldUnitCount++;

                                m_blnTotalCounterAdded = true;
                                if (m_smVisionInfo.g_blnTrackPocketCounter)
                                    STTrackLog.WriteLine("Total 2a g_intTestedTotal=" + m_smVisionInfo.g_intTestedTotal.ToString() + ", m_blnTotalCounterAdded=" + m_blnTotalCounterAdded.ToString() + ", m_blnPassCounterAdded=" + m_blnPassCounterAdded.ToString() + ", m_blnFailCounterAdded=" + m_blnFailCounterAdded.ToString());
                            }
                            break;
                        case 3:
                            if (!blnSkip && !m_blnTotalCounterAdded)
                            {
                                if (m_smVisionInfo.g_blnTrackPocketCounter)
                                    STTrackLog.WriteLine("Total 3 g_intTestedTotal=" + m_smVisionInfo.g_intTestedTotal.ToString() + ", m_blnTotalCounterAdded=" + m_blnTotalCounterAdded.ToString() + ", m_blnPassCounterAdded=" + m_blnPassCounterAdded.ToString() + ", m_blnFailCounterAdded=" + m_blnFailCounterAdded.ToString());
                                if (m_blnPassCounterAdded)
                                {
                                    if (blnResultOK2 && blnResultOK)
                                    {
                                        m_smVisionInfo.g_intTestedTotal += 2;
                                        m_smVisionInfo.g_intLowYieldUnitCount += 2;
                                    }
                                    else
                                    {
                                        m_smVisionInfo.g_intTestedTotal++;
                                        m_smVisionInfo.g_intLowYieldUnitCount++;
                                    }

                                    m_blnTotalCounterAdded = true;
                                    if (m_smVisionInfo.g_blnTrackPocketCounter)
                                        STTrackLog.WriteLine("Total 3a g_intTestedTotal=" + m_smVisionInfo.g_intTestedTotal.ToString() + ", m_blnTotalCounterAdded=" + m_blnTotalCounterAdded.ToString() + ", m_blnPassCounterAdded=" + m_blnPassCounterAdded.ToString() + ", m_blnFailCounterAdded=" + m_blnFailCounterAdded.ToString());
                                }
                                else if (m_blnFailCounterAdded)
                                {
                                    m_smVisionInfo.g_intTestedTotal++;
                                    m_smVisionInfo.g_intLowYieldUnitCount++;

                                    m_blnTotalCounterAdded = true;
                                    if (m_smVisionInfo.g_blnTrackPocketCounter)
                                        STTrackLog.WriteLine("Total 3b g_intTestedTotal=" + m_smVisionInfo.g_intTestedTotal.ToString() + ", m_blnTotalCounterAdded=" + m_blnTotalCounterAdded.ToString() + ", m_blnPassCounterAdded=" + m_blnPassCounterAdded.ToString() + ", m_blnFailCounterAdded=" + m_blnFailCounterAdded.ToString());
                                }
                            }
                            break;
                    }

                    CheckLowYield();
                    CheckContinuousPass();
                    CheckContinuousFail();
                }

                // 2019 05 30 - JBTAN: Temporary solution for multi view test rotated images no update and show black image
                //// 2019 01 28 - CCENG: Not need purposely rotate image for user view.
                if (!m_blnRotateImage1Updated)
                {
                    if (m_smVisionInfo.g_arrImages.Count > 0)
                        m_smVisionInfo.g_arrImages[0].CopyTo(ref m_smVisionInfo.g_arrRotatedImages, 0);
                }

                if (!m_blnRotateImage2Updated)
                {
                    if (m_smVisionInfo.g_arrImages.Count > 1)
                        m_smVisionInfo.g_arrImages[1].CopyTo(ref m_smVisionInfo.g_arrRotatedImages, 1);
                }

                if (!m_blnRotateImage3Updated)
                {
                    if (m_smVisionInfo.g_arrImages.Count > 2)
                        m_smVisionInfo.g_arrImages[2].CopyTo(ref m_smVisionInfo.g_arrRotatedImages, 2);
                }

                if (!m_blnRotateImage4Updated)
                {
                    if (m_smVisionInfo.g_arrImages.Count > 3)
                        m_smVisionInfo.g_arrImages[3].CopyTo(ref m_smVisionInfo.g_arrRotatedImages, 3);
                }

                if (!m_blnRotateImage5Updated)
                {
                    if (m_smVisionInfo.g_arrImages.Count > 4)
                        m_smVisionInfo.g_arrImages[4].CopyTo(ref m_smVisionInfo.g_arrRotatedImages, 4);
                }

                if (!m_blnRotateImage6Updated)
                {
                    if (m_smVisionInfo.g_arrImages.Count > 5)
                        m_smVisionInfo.g_arrImages[5].CopyTo(ref m_smVisionInfo.g_arrRotatedImages, 5);
                }

                if (!m_blnRotateImage7Updated)
                {
                    if (m_smVisionInfo.g_arrImages.Count > 6)
                        m_smVisionInfo.g_arrImages[6].CopyTo(ref m_smVisionInfo.g_arrRotatedImages, 6);
                }

                m_smVisionInfo.g_objProcessTime.Stop();

                if (m_smVisionInfo.VM_PR_ByPassUnit)
                {
                    m_smVisionInfo.m_blnUpdateResultUsingByPassSetting = true;
                    m_smVisionInfo.VM_PR_ByPassUnit = false;
                }

                m_smVisionInfo.VS_AT_UpdateQuantity = true;
                m_smVisionInfo.PR_VM_UpdateQuantity = true;

                if (m_blnWantPackageTest)
                {
                    m_smVisionInfo.g_blnDrawPkgResult = true;
                    m_smVisionInfo.g_blnPackageInspected = true;
                }

                m_smVisionInfo.g_arrblnImageRotated[0] = m_blnRotateImage1Updated;
                m_smVisionInfo.g_arrblnImageRotated[1] = m_blnRotateImage2Updated;
                m_smVisionInfo.g_arrblnImageRotated[2] = m_blnRotateImage3Updated;
                m_smVisionInfo.g_arrblnImageRotated[3] = m_blnRotateImage4Updated;
                m_smVisionInfo.g_arrblnImageRotated[4] = m_blnRotateImage5Updated;
                m_smVisionInfo.g_arrblnImageRotated[5] = m_blnRotateImage6Updated;
                m_smVisionInfo.g_arrblnImageRotated[6] = m_blnRotateImage7Updated;

                m_smVisionInfo.ALL_VM_UpdatePictureBox = true;

                //CheckLowYield();

                //m_fTiming = m_T1.Timing;
                //m_strTrack += ", Total=" + m_smVisionInfo.g_objProcessTime.Duration.ToString();
                //m_fTimingPrev = m_fTiming;

                //string[] spilt = m_strTrack.Split(',');
                //TrackLog t = new TrackLog();
                //for (int i = 0; i < spilt.Length; i++)
                //    t.WriteLine(spilt[i]);
                ////STTrackLog.WriteLine(m_strTrack);
            }
            catch (Exception ex)
            {
                SRMMessageBox.Show("Vision4Process StartTest :" + ex.ToString());
            }
            return;
        }

        private void SaveTestImage(string strFolderName, bool blnSaveSearchROI)
        {

            string strImageFolderPath = m_smVisionInfo.g_strSaveImageLocation +
                 m_smProductionInfo.g_strLotID + "_" + m_smProductionInfo.g_strLotStartTime + "\\" +
                 m_smVisionInfo.g_strVisionName + "\\";

            if (!Directory.Exists(strImageFolderPath + strFolderName))
                Directory.CreateDirectory(strImageFolderPath + strFolderName);

            string[] strFileName = Directory.GetFiles(strImageFolderPath + strFolderName, "Image*");


            int intLength = Directory.GetFiles(strImageFolderPath + strFolderName, "Image*").Length;
            int intSelectedIndex = intLength;
            if (intLength >= 1000)
            {
                DateTime dtEaries = DateTime.MaxValue;
                for (int i = 0; i < intLength; i++)
                {
                    DateTime dt = Directory.GetLastWriteTime(strFileName[i]);
                    if (dtEaries > dt)
                    {
                        dtEaries = dt;
                        intSelectedIndex = i;
                    }
                }
            }

            m_smVisionInfo.g_arrImages[0].SaveImage(strImageFolderPath + strFolderName + "\\Image" + intSelectedIndex + ".bmp");
        }
        private bool newCheckUnit1(bool blnAuto, ref bool blnSkip)
        {

            bool blnResult = true;
            m_blnPositionResult = true;

            // -------------  Check Tape Pocket Positionig --------------------------------------------- 
            if (m_blnWantPositioning)
            {
                WaitEventDone(ref m_bGrabImage1Done, true, 10000, "AAA23");

                AttachImageToROI();
                //if (blnAuto || (!blnAuto && m_smVisionInfo.MN_PR_CheckPosition))
                if (m_smVisionInfo.MN_PR_CheckPosition)
                {

                    bool blnWantAccuratePosition;
                    if (m_smVisionInfo.g_strVisionName == "InPocketPkgPos")
                        blnWantAccuratePosition = true;
                    else
                        blnWantAccuratePosition = false;

                    if (!m_smVisionInfo.g_objPositioning.DoInspection_InPocket(m_smVisionInfo.g_arrImages[m_smVisionInfo.g_objPositioning.ref_intPositionImageIndex],
                                                  m_smVisionInfo.g_arrPositioningROIs,
                                                  m_smVisionInfo.g_arrPositioningGauges,
                                                  m_smVisionInfo.g_fCalibPixelXInUM,
                                                  m_smVisionInfo.g_fCalibPixelYInUM,
                                                  false,    // UseBlobsToFindPreLocation
                                                  true,     // IncludeLimitInspection
                                                  blnWantAccuratePosition,
                                                  false,    // CheckDoubleUnit
                                                  false,    // CheckEmptyUnit
                                                  false))   // CheckUnitFlip
                    {
                        m_blnPositionResult = false;
                        blnResult = false;
                        m_smVisionInfo.g_strErrorMessage = "*Positioning Fail. " + m_smVisionInfo.g_objPositioning.ref_strErrorMessage;

                        if (blnAuto)
                            SaveRejectImage_AddToBuffer("Position", m_smVisionInfo.g_strErrorMessage);
                    }

                }

               
                //    m_blnPositionResult = true;
#if(RTXDebug || RTXRelease)

                RS232.RTXSendData(GetTCPPositionResult(m_blnPositionResult), m_smVisionInfo.g_intVisionPos);

                if (blnAuto)
                    SaveTestImage("IPMPkgPosImage", false);
#else
                if (m_smVisionInfo.g_strVisionName == "InPocketPkgPos")
                {
                    if (!m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        m_smComThread.Send(GetTCPPositionResult(m_blnPositionResult));

                }
#endif

                if (!m_blnPositionResult)
                {
                    if (!m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    {
                        m_objVisionIO.PackageFail.SetOn("V4 PackageFail 7");
                    }
                    else
                    {
                        m_blnPackageFail_Out = true;
                        if (m_intTCPIPResultID == -1)
                            m_intTCPIPResultID = (int)TCPIPResulID.FailPosition;
                    }
                    
                    blnSkip = true;
                    goto FINALRESULT;
                }

                //if ((blnAuto && m_objVisionIO.CheckEmpty != null && m_objVisionIO.CheckEmpty.IsOn() && m_smVisionInfo.g_blnWantCheckEmpty) ||
                //(!blnAuto && (m_smVisionInfo.MN_PR_CheckEmptyUnit || m_smVisionInfo.g_blnWantCheckEmpty)))
                if (m_blnCheckEmpty)
                {
                    m_smVisionInfo.g_arrPositioningROIs[0].AttachImage(m_smVisionInfo.g_arrImages[m_smVisionInfo.g_objPositioning.ref_intEmptyImageIndex]);
                    blnResult = m_smVisionInfo.g_objPositioning.IsEmptyUnit_InPocket(m_smVisionInfo.g_arrPositioningROIs[0]);

                    //blnResult = StartEmptyUnitTest(blnAuto, 0);
                    blnSkip = true;
                    goto FINALRESULT;
                }
                //else if (m_smVisionInfo.g_blnWantCheckUnitSitProper)
                //{
                //    m_smVisionInfo.g_arrPositioningROIs[0].AttachImage(m_smVisionInfo.g_arrImages[m_smVisionInfo.g_objPositioning.ref_intEmptyImageIndex]);
                //    if (m_smVisionInfo.g_objPositioning.IsEmptyUnit_InPocket(m_smVisionInfo.g_arrPositioningROIs[0]))
                //    {
                //        blnResult = false;
                //        if (blnAuto)
                //            SaveRejectImage_AddToBuffer("Empty");
                //        m_smVisionInfo.g_strErrorMessage = "* Fail Pocket Empty Unit.";

                //    }
                //}

            }
            else
            {
                WaitEventDone(ref m_bGrabImage1Done, true, 10000, "AAA24");

                AttachImageToROI();


                //if ((blnAuto && m_objVisionIO.CheckEmpty != null && m_objVisionIO.CheckEmpty.IsOn() && m_smVisionInfo.g_blnWantCheckEmpty) ||
                //   (!blnAuto && m_smVisionInfo.MN_PR_CheckEmptyUnit && m_smVisionInfo.g_blnWantCheckEmpty))
                if (m_blnCheckEmpty)
                {
                    //if (blnAuto)
                    //    STTrackLog.WriteLine("----- Check Empty -----");

                    if (m_smVisionInfo.g_arrPositioningROIs.Count == 0)
                    {
                        SRMMessageBox.Show("Please Learn Empty Template first!");

                        if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                            if (m_intTCPIPResultID == -1)
                                m_intTCPIPResultID = (int)TCPIPResulID.Fail;//FailEmpty;

                        return false;
                    }
                    if (!(m_smVisionInfo.g_blnWantUseEmptyThreshold || m_smVisionInfo.g_blnWantUseEmptyPattern))
                    {
                        SRMMessageBox.Show("Please select threshold or pattern checking method to continue!");

                        if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                            if (m_intTCPIPResultID == -1)
                                m_intTCPIPResultID = (int)TCPIPResulID.Fail;//FailEmpty;

                        return false;
                    }
                    m_smVisionInfo.g_arrPositioningROIs[0].AttachImage(m_smVisionInfo.g_arrImages[m_smVisionInfo.g_objPositioning.ref_intEmptyImageIndex]);

                    bool blnResult1 = false;
                    bool blnResult2 = false;
                    m_strErrorMsg = "";

                    if (m_smVisionInfo.g_arrPositioningROIs.Count >= 2)
                    {

                        if (m_smVisionInfo.g_blnWantUseEmptyThreshold)
                        {
                            blnResult = blnResult1 = m_smVisionInfo.g_objPositioning.IsUnitEmptyAfterThreshold_InPocket(m_smVisionInfo.g_arrPositioningROIs[1]); // Index 1 for Empty ROI. 
                            if (!blnResult1)
                            {
                                m_strErrorMsg += "*" + m_smVisionInfo.g_objPositioning.ref_strErrorMessage;
                            }
                        }
                        if (m_smVisionInfo.g_blnWantUseEmptyPattern)
                        {
                            blnResult = blnResult2 = m_smVisionInfo.g_objPositioning.IsEmptyUnit_InPocket(m_smVisionInfo.g_arrPositioningROIs[0]);  // Index 0 for search ROI

                            if (!blnResult)
                            {
                                m_strErrorMsg += "*" + m_smVisionInfo.g_objPositioning.ref_strErrorMessage;
                            }
                        }
                        //blnResult = StartEmptyUnitTest(blnAuto, 0);
                        if (m_smVisionInfo.g_blnWantUseEmptyThreshold && m_smVisionInfo.g_blnWantUseEmptyPattern)
                            blnResult = blnResult1 & blnResult2;
                    }
                    else
                    {
                        m_strErrorMsg += "*" + "Empty Template Not Ready";
                        blnResult = false;
                    }

                    if (m_blnWantPocketPositionTest)
                    {
                        bool blnPocketPisitonResult = true;
                        if (!StartPocketPositionTest(m_blnAuto, true))   // Pocket Position Test
                        {
                            blnPocketPisitonResult = false;    // 2019 12 27 - CCENG: Pocket Position result should not affecting empty result.
                        }

                        if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        {
                            m_fOffsetX = m_smVisionInfo.g_objPocketPosition.ref_fResultXDistance;
                            m_fOffsetY = m_smVisionInfo.g_objPocketPosition.ref_fResultYDistance;
                            m_fOffsetAngle = 0;
                        }

                        m_smVisionInfo.g_blnDrawPocketPositionResult = true;
                        //if (m_blnAuto)
                        if(!m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                            m_smComThread.Send(GetTCPPocketPositionResult(blnPocketPisitonResult));

                        //if (blnPocketPisitonResult && m_objVisionIO.InPocketReTest.IsOff(true))
                        //{
                        //    if (m_smVisionInfo.g_bPocketPositionMeanStatisticAnalysisON)
                        //    {
                        //        m_smVisionInfo.g_intPocketPositionMeanStatisticAnalysisCount++;
                        //        m_smVisionInfo.g_bPocketPositionMeanStatisticAnalysisUpdateInfo = true;

                        //        while (true)
                        //        {
                        //            if (!m_smVisionInfo.g_bPocketPositionMeanStatisticAnalysisUpdateInfo)
                        //                break;

                        //            Thread.Sleep(1);
                        //        }
                        //    }
                        //}
                    }

                    blnSkip = true;
                    goto FINALRESULT;
                }
                //else if (m_smVisionInfo.g_blnWantCheckUnitSitProper)
                //{
                //    m_smVisionInfo.g_arrPositioningROIs[0].AttachImage(m_smVisionInfo.g_arrImages[m_smVisionInfo.g_objPositioning.ref_intEmptyImageIndex]);
                //    if (m_smVisionInfo.g_objPositioning.IsEmptyUnit_InPocket(m_smVisionInfo.g_arrPositioningROIs[0]))
                //    {
                //        blnResult = false;
                //        if (blnAuto)
                //            SaveRejectImage_AddToBuffer("Empty");
                //        m_smVisionInfo.g_strErrorMessage = "* Fail Pocket Empty Unit.";

                //    }
                //}
            }

            blnSkip = false;

            FINALRESULT:

            return blnResult;
        }

        private bool newCheckUnit2(bool blnAuto)
        {
            bool blnResult = true;

            //2019 07 16 - JBTAN: Current project which use double unit does not require check empty
            //if want to check empty need to update check empty function
            //if ((blnAuto && m_objVisionIO.CheckEmpty != null && m_objVisionIO.CheckEmpty.IsOn() && m_smVisionInfo.g_blnWantCheckEmpty) ||
            //(!blnAuto && (m_smVisionInfo.MN_PR_CheckEmptyUnit || m_smVisionInfo.g_blnWantCheckEmpty)))
            if (m_blnCheckEmpty)
            {
                blnResult = StartEmptyUnitTest(blnAuto, 1);
                //goto FINALRESULT;
            }

            // not bypass checking
            //if (!m_smVisionInfo.VM_PR_ByPassUnit)
            //{
            //    // Checking Orientation
            //    if (m_smVisionInfo.g_blnUseAutoRepalceCounter || m_blnWantPackageTest)
            //    {
            //        if (!StartOrientTest_IPM(blnAuto, 1))
            //            blnResult = false;
            //    }
            //    else // Default
            //    {
            //        // For SRM-IPM (Single/Double Pocket)
            //        if (!StartOrientTest(blnAuto, 1))
            //            blnResult = false;
            //    }

            //    if (m_smVisionInfo.g_blnWantPin1)
            //    {
            //        if (blnResult && !StartPin1Test(blnAuto, 1))
            //        {
            //            blnResult = false;
            //        }
            //    }

            //    if (!m_smVisionInfo.g_blnWantSkipMark)
            //    {
            //        if ((m_smCustomizeInfo.g_intWantOCR & (0x01 << m_smVisionInfo.g_intVisionPos)) == 0)
            //        {
            //            // Checking Mark
            //            if (m_smVisionInfo.g_blnUseAutoRepalceCounter || m_blnWantPackageTest)
            //            {
            //                if (!m_smVisionInfo.g_blnWantSkipMark && blnResult && !StartMarkTest(blnAuto, 1))
            //                    blnResult = false;
            //            }
            //            else
            //            {
            //                // For SRM-IPM (Single/Double Pocket)
            //                if (!m_smVisionInfo.g_blnWantSkipMark && blnResult && !StartMarkTest(blnAuto, 1))
            //                    blnResult = false;
            //            }
            //        }
            //        else
            //        {
            //            // Checking Mark OCR
            //            if (!m_smVisionInfo.g_blnWantSkipMark && blnResult && !StartMarkOCRTest(blnAuto, 1))
            //                blnResult = false;
            //        }
            //    }
            //}

            //// Checking Package
            //if (blnResult)
            //{
            //    if (!StartPackageTest(blnAuto, 1))
            //        blnResult = false;
            //}

            //FINALRESULT:

            //m_smVisionInfo.g_blnUnitInspected[1] = true;

            //if (blnResult)
            //{
            //    if (blnAuto)
            //    {
            //        m_objVisionIO.IOPass2.SetOn("V4 ");
            //        if (m_objVisionIO.CheckEmpty != null && m_objVisionIO.CheckEmpty.IsOn())
            //            SaveRejectImage_AddToBuffer("EmptyPass");
            //        else
            //            SavePassImage_AddToBuffer(1);
            //    }
            //}
            //else
            //{
            //    if (blnAuto)
            //    {
            //        if (m_objVisionIO.CheckEmpty != null && m_objVisionIO.CheckEmpty.IsOn())
            //        {
            //            SaveRejectImage_AddToBuffer("EmptyFail");
            //        }
            //    }
            //    m_smVisionInfo.g_strResult2 = "Fail";
            //}

            return blnResult;
        }
        private string GetTCPPocketPositionResult(bool blnResult)
        {
            string strMessage = "<POSRP,POS0";

            if (!blnResult)
                strMessage += "FN00000N00000";
            else
            {
                strMessage += "P";

                float fObjectOffsetX = m_smVisionInfo.g_objPocketPosition.ref_fResultXDistance;
                fObjectOffsetX = fObjectOffsetX * 1000 / m_smVisionInfo.g_fCalibPixelX; // Convert to micron

                if (Math.Abs(Math.Round(fObjectOffsetX)) > 100000)
                    fObjectOffsetX = 0;

                if (!m_blnCheckEmpty)   // 2020 02 19 - CCENG: no need to offset pocket if check empty
                {
                    if (Math.Abs(fObjectOffsetX - m_smVisionInfo.g_objPocketPosition.ref_intPocketPositionReference) > m_smVisionInfo.g_objPocketPosition.ref_intPocketPositionTolerance)
                    {
                        m_objVisionIO.FailOffset.SetOn();
                    }
                }
                if (m_objVisionIO.OffsetDone != null)
                    m_objVisionIO.OffsetDone.SetOff("V4 Offset done 102");

                if (m_smVisionInfo.g_blnTrackPocketPosition)
                {
                    if (m_objVisionIO.CheckEmpty.IsOn())
                        m_strPocketPositionTrackingData = "X=" + fObjectOffsetX.ToString() + ", IO=" + m_objVisionIO.FailOffset.IsOn() + ", Empty";
                    else if (m_blnRollback)
                        m_strPocketPositionTrackingData = "X=" + fObjectOffsetX.ToString() + ", IO=" + m_objVisionIO.FailOffset.IsOn() + ", Rollback ON";
                    else
                        m_strPocketPositionTrackingData = "X=" + fObjectOffsetX.ToString() + ", IO=" + m_objVisionIO.FailOffset.IsOn();
                }

                if (fObjectOffsetX < 0)
                    strMessage += "N";
                else
                    strMessage += "P";
                strMessage += string.Format("{0:00000}", Math.Abs(Math.Round(fObjectOffsetX)));


                float fObjectOffsetY = m_smVisionInfo.g_objPocketPosition.ref_fResultYDistance;
                fObjectOffsetY = fObjectOffsetY * 1000 / m_smVisionInfo.g_fCalibPixelY;// Convert to micron
                fObjectOffsetY = 0; //2019-12-11 ZJYEOH : Temparory set to zero because no Y Data
                if (Math.Abs(Math.Round(fObjectOffsetX)) > 100000)
                    fObjectOffsetX = 0;

                if ((fObjectOffsetY) < 0)
                    strMessage += "N";
                else
                    strMessage += "P";
                strMessage += string.Format("{0:00000}", Math.Abs(Math.Round(fObjectOffsetY)));
                
            }

            //strMessage += "*ANG00000,1>";
            strMessage += "*ANG00000*REF";

            strMessage += string.Format("{0:00000}", Math.Abs(m_smVisionInfo.g_objPocketPosition.ref_intPocketPositionReference));

            strMessage += ",1>";
            return strMessage;
        }
        private string GetTCPPositionResult(bool blnResult)
        {
            string strMessage = "<T";

            if (!blnResult)
                strMessage += "FN0000N0000";
            else
            {
                if (m_smVisionInfo.g_intForceZero == 0)
                {
                    strMessage += "P";
                    if (m_smVisionInfo.g_objPositioning.ref_fObjectOffsetX < 0)
                        strMessage += "N";
                    else
                        strMessage += "P";
                    strMessage += string.Format("{0:0000}", Math.Abs(Math.Round(m_smVisionInfo.g_objPositioning.ref_fObjectOffsetX)));
                }
                else
                {
                    strMessage += "PP0000";
                }

                if (m_smVisionInfo.g_intForceYZero == 0)
                {
                    float fObjectOffsetY = m_smVisionInfo.g_objPositioning.ref_fObjectOffsetY;

                    if ((fObjectOffsetY) < 0)
                        strMessage += "N";
                    else
                        strMessage += "P";
                    strMessage += string.Format("{0:0000}", Math.Abs(Math.Round(fObjectOffsetY)));
                }
                else
                {
                    strMessage += "P0000";
                }
            }

            strMessage += ">";

            return strMessage;
        }


        private bool CheckIsLastUnit()
        {
            //Pocket is considered last unit if pocket pixel avarage value lower than template
            if (((ROI)m_smVisionInfo.g_arrMarkROIs[0][1]).CompareROIArea(m_smCustomizeInfo.g_intEmptyPocketTole))
                return false;
            else
                return true;
        }

        private bool StartMarkOCRTest(bool blnAuto, int intUnitNo)
        {
            // Make sure template exist
            if (m_smVisionInfo.g_arrMarks[intUnitNo].GetNumPatterns() == 0)
            { // 2020 04 15 - JBTAN: check mark option enable only will set result fail
                if (m_smVisionInfo.g_arrMarks[intUnitNo].ref_blnCheckMark)
                {
                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 20 g_intMarkFailureTotal=" + m_smVisionInfo.g_intMarkFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                    m_smVisionInfo.g_strErrorMessage += "*Mark : No Template Found";
                    if ((intUnitNo == 1 || m_smVisionInfo.g_intUnitsOnImage == 1) && blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)
                    {
                        m_smVisionInfo.g_intNoTemplateFailureTotal++;
                        //m_smVisionInfo.g_intTestedTotal++;
                        //m_smVisionInfo.g_intLowYieldUnitCount++;
                        m_blnFailCounterAdded = true;
                        m_blnTotalCounterAdded = false;
                    }
                }
                return false;
            }

            ROI objSearchROI = (ROI)m_smVisionInfo.g_arrMarkROIs[intUnitNo][0];
            ROI objTrainROI = (ROI)m_smVisionInfo.g_arrMarkROIs[intUnitNo][1];

            //no orient check
            if (((m_smCustomizeInfo.g_intWantOrient & (0x01 << m_smVisionInfo.g_intVisionPos)) == 0))
            {
                //got gauge check
                if (m_smVisionInfo.g_blnWantGauge)
                {
                    objSearchROI.AttachImage(m_smVisionInfo.g_arrImages[0]);
                    // Rotate unit to exact 0 degree
                    float fGaugeAngle = ((RectGauge)m_smVisionInfo.g_arrMarkGauge[intUnitNo]).Measure(objSearchROI, 10);
                    ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[0], objSearchROI, fGaugeAngle, m_smVisionInfo.g_intRotationInterpolation_Mark, ref m_smVisionInfo.g_arrRotatedImages, 0);
                    //m_smVisionInfo.g_arrRotatedImages[0] = ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[0], objSearchROI, fGaugeAngle);
                    objSearchROI.AttachImage(m_smVisionInfo.g_arrRotatedImages[0]);
                }
            }
            else
            {
                objSearchROI.AttachImage(m_smVisionInfo.g_arrRotatedImages[0]);
            }

            if (m_smVisionInfo.g_blnWantGauge)
            {
                // Measure search roi to get unit center point
                ((RectGauge)m_smVisionInfo.g_arrMarkGauge[intUnitNo]).Measure(objSearchROI, 10);

                // Get object width and height measured by gauge
                int intGaugeWidth = (int)(((RectGauge)m_smVisionInfo.g_arrMarkGauge[intUnitNo]).ref_ObjectWidth);
                int intGaugeHeight = (int)(((RectGauge)m_smVisionInfo.g_arrMarkGauge[intUnitNo]).ref_ObjectHeight);

                int intROIWidth = objTrainROI.ref_ROIWidth;
                int intROIHeight = objTrainROI.ref_ROIHeight;

                if (intROIWidth >= intGaugeWidth)
                    intROIWidth -= (intROIWidth - intGaugeWidth) / 2;
                if (intROIHeight >= intGaugeHeight)
                    intROIHeight -= (intROIHeight - intGaugeHeight) / 2;

                int intROIOriX = (int)(((RectGauge)m_smVisionInfo.g_arrMarkGauge[intUnitNo]).ref_ObjectCenterX - intROIWidth / 2) - objSearchROI.ref_ROIPositionX;
                int intROIOriY = (int)(((RectGauge)m_smVisionInfo.g_arrMarkGauge[intUnitNo]).ref_ObjectCenterY - intROIHeight / 2) - objSearchROI.ref_ROIPositionY;


                // Set train roi start point
                if ((intROIOriX > 0) &&
                    (intROIOriX < objTrainROI.ref_ROIWidth) &&
                    (intROIOriY > 0) &&
                    (intROIOriY < objTrainROI.ref_ROIHeight))
                {
                    objTrainROI.ref_ROIPositionX = intROIOriX;
                    objTrainROI.ref_ROIPositionY = intROIOriY;
                }
                else
                {
                    // if start point out of range, then set train roi position same as position during learning
                    objTrainROI.ref_ROIPositionX = objTrainROI.ref_ROIOriPositionX;
                    objTrainROI.ref_ROIPositionY = objTrainROI.ref_ROIOriPositionY;
                }
            }
            else
            {
                // Attach search roi to main image
                objSearchROI.AttachImage(m_smVisionInfo.g_arrImages[0]);
            }

            m_smVisionInfo.g_arrMarks[intUnitNo].InspectOCRMark(m_smVisionInfo.g_arrRotatedImages[0], objTrainROI, m_smVisionInfo.g_blnWantRecogPosition);

            m_smVisionInfo.g_blnUnitInspected[intUnitNo] = true;
            m_smVisionInfo.g_blnMarkInspected = true;
            m_smVisionInfo.g_blnDrawMarkResult = true;

            if (m_smVisionInfo.g_arrMarks[intUnitNo].ref_intFailResultMask > 0)
            {
                if (false)// 02-07-2019 ZJYEOH: Wont use Auto Replace Counter anymore  (m_smVisionInfo.g_blnUseAutoRepalceCounter)
                {
                    //STTrackLog.WriteLine("Fail 21 g_intMarkFailureTotal=" + m_smVisionInfo.g_intMarkFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());

                    // ------------ For Single IPM with 2 mirror Auto Replace Only----------------------------------------------
                    if ((intUnitNo == 1 || m_smVisionInfo.g_intUnitsOnImage == 1) && blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)
                    {
                        m_smVisionInfo.g_intMarkFailureTotal++;
                        //m_smVisionInfo.g_intTestedTotal++;
                        //m_smVisionInfo.g_intLowYieldUnitCount++;
                        m_blnFailCounterAdded = true;
                        m_blnTotalCounterAdded = false;
                        SaveRejectImage_AddToBuffer("Mark", m_smVisionInfo.g_arrMarks[intUnitNo].GetInspectionMessage(intUnitNo, m_smVisionInfo.VM_PR_ByPassUnit, m_smVisionInfo.g_intMinMarkScore, m_smVisionInfo.g_intUnitsOnImage));
                    }
                    //=====================================================================
                }
                else
                {
                    //STTrackLog.WriteLine("Fail 22 g_intMarkFailureTotal=" + m_smVisionInfo.g_intMarkFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                    if ((intUnitNo == 1 || m_smVisionInfo.g_intUnitsOnImage == 1) && blnAuto)
                    {
                        SaveRejectImage_AddToBuffer("Mark", m_smVisionInfo.g_arrMarks[intUnitNo].GetInspectionMessage(intUnitNo, m_smVisionInfo.VM_PR_ByPassUnit, m_smVisionInfo.g_intMinMarkScore, m_smVisionInfo.g_intUnitsOnImage));
                    }
                    if ((intUnitNo == 1 || m_smVisionInfo.g_intUnitsOnImage == 1) && blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)
                    {
                        m_smVisionInfo.g_intMarkFailureTotal++;
                        //m_smVisionInfo.g_intTestedTotal++;
                        //m_smVisionInfo.g_intLowYieldUnitCount++;
                        m_blnFailCounterAdded = true;
                        m_blnTotalCounterAdded = false;
                        //SaveRejectImage_AddToBuffer("Mark", m_smVisionInfo.g_arrMarks[intUnitNo].GetInspectionMessage(intUnitNo));
                    }
                }
                m_smVisionInfo.g_strErrorMessage = m_smVisionInfo.g_arrMarks[intUnitNo].GetInspectionMessage(intUnitNo, m_smVisionInfo.VM_PR_ByPassUnit, m_smVisionInfo.g_intMinMarkScore, m_smVisionInfo.g_intUnitsOnImage);
            }

            return true;
        }
        private bool StartPocketPositionTest(bool blnAuto, bool blnWithEmpty)
        {
            try
            {
                bool blnResult = true;

                if (m_smVisionInfo.g_blnWantUsePocketPattern && !m_smVisionInfo.g_objPocketPosition.IsPatternLearnt())
                {
                    m_smVisionInfo.g_strErrorMessage += "*Pocket Position Pattern Not Found";

                    //if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)
                    //{
                    //    m_smVisionInfo.g_intNoTemplateFailureTotal++;
                    //    //m_smVisionInfo.g_intTestedTotal++;
                    //    //m_smVisionInfo.g_intLowYieldUnitCount++;
                    //    m_blnFailCounterAdded = true;
                    //}

                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        if (m_intTCPIPResultID == -1)
                            m_intTCPIPResultID = (int)TCPIPResulID.FailPosition;
                    m_blnPocketPositionResult = false;
                    return false;
                }
                if (m_smVisionInfo.g_arrPocketPositionROIs.Count < 4 || m_smVisionInfo.g_arrPocketPositionGauges.Count < 2)
                {
                    m_smVisionInfo.g_strErrorMessage += "*Pocket Position Template Not Found";

                    //if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)
                    //{
                    //    m_smVisionInfo.g_intNoTemplateFailureTotal++;
                    //    //m_smVisionInfo.g_intTestedTotal++;
                    //    //m_smVisionInfo.g_intLowYieldUnitCount++;
                    //    m_blnFailCounterAdded = true;
                    //}

                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        if (m_intTCPIPResultID == -1)
                            m_intTCPIPResultID = (int)TCPIPResulID.FailPosition;
                    m_blnPocketPositionResult = false;
                    return false;
                }

                m_smVisionInfo.g_objPocketPosition.ResetData();

                int intPocketPatternAndGaugeIndex = m_smVisionInfo.g_objPocketPosition.GetGrabImageIndex(0);
                int intPlateGaugeIndex = m_smVisionInfo.g_objPocketPosition.GetGrabImageIndex(1);

                if (blnWithEmpty) // 2019-12-27 ZJYEOH : If check together with Empty, need add 1 to image view number as pocket position image will grab after grab empty
                {
                    intPocketPatternAndGaugeIndex = 1;
                    intPlateGaugeIndex = 2;
                }

                if (m_smVisionInfo.g_blnWantUsePocketPattern && !m_smVisionInfo.g_blnWantUsePocketGauge)
                {
                    if(intPocketPatternAndGaugeIndex == 0)
                        WaitEventDone(ref m_bGrabImage1Done, true, 10000, "AAA25");
                    else if (intPocketPatternAndGaugeIndex == 1)
                        WaitEventDone(ref m_bGrabImage2Done, true, 10000, "AAA26");
                    else if (intPocketPatternAndGaugeIndex == 2)
                        WaitEventDone(ref m_bGrabImage3Done, true, 10000, "AAA27");
                    else if (intPocketPatternAndGaugeIndex == 3)
                        WaitEventDone(ref m_bGrabImage4Done, true, 10000, "AAA28");
                    else if (intPocketPatternAndGaugeIndex == 4)
                        WaitEventDone(ref m_bGrabImage5Done, true, 10000, "AAA29");
                    else if (intPocketPatternAndGaugeIndex == 5)
                        WaitEventDone(ref m_bGrabImage6Done, true, 10000, "AAA30");
                    else if (intPocketPatternAndGaugeIndex == 6)
                        WaitEventDone(ref m_bGrabImage7Done, true, 10000, "AAA31");

                    if (intPlateGaugeIndex == 0)
                        WaitEventDone(ref m_bGrabImage1Done, true, 10000, "AAA32");
                    else if (intPlateGaugeIndex == 1)
                        WaitEventDone(ref m_bGrabImage2Done, true, 10000, "AAA33");
                    else if (intPlateGaugeIndex == 2)
                        WaitEventDone(ref m_bGrabImage3Done, true, 10000, "AAA34");
                    else if (intPlateGaugeIndex == 3)
                        WaitEventDone(ref m_bGrabImage4Done, true, 10000, "AAA35");
                    else if (intPlateGaugeIndex == 4)
                        WaitEventDone(ref m_bGrabImage5Done, true, 10000, "AAA36");
                    else if (intPlateGaugeIndex == 5)
                        WaitEventDone(ref m_bGrabImage6Done, true, 10000, "AAA37");
                    else if (intPlateGaugeIndex == 6)
                        WaitEventDone(ref m_bGrabImage7Done, true, 10000, "AAA38");
                }
                if (!m_smVisionInfo.g_blnWantUsePocketPattern && m_smVisionInfo.g_blnWantUsePocketGauge)
                {
                    if (intPocketPatternAndGaugeIndex == 0)
                        WaitEventDone(ref m_bGrabImage1Done, true, 10000, "AAA39 1");
                    else if (intPocketPatternAndGaugeIndex == 1)
                        WaitEventDone(ref m_bGrabImage2Done, true, 10000, "AAA39 2");
                    else if (intPocketPatternAndGaugeIndex == 2)
                        WaitEventDone(ref m_bGrabImage3Done, true, 10000, "AAA39 3");
                    else if (intPocketPatternAndGaugeIndex == 3)
                        WaitEventDone(ref m_bGrabImage4Done, true, 10000, "AAA39 4");
                    else if (intPocketPatternAndGaugeIndex == 4)
                        WaitEventDone(ref m_bGrabImage5Done, true, 10000, "AAA39 5");
                    else if (intPocketPatternAndGaugeIndex == 5)
                        WaitEventDone(ref m_bGrabImage6Done, true, 10000, "AAA39 6");
                    else if (intPocketPatternAndGaugeIndex == 6)
                        WaitEventDone(ref m_bGrabImage7Done, true, 10000, "AAA39 7");

                    if (intPlateGaugeIndex == 0)
                        WaitEventDone(ref m_bGrabImage1Done, true, 10000, "AAA40 1");
                    else if (intPlateGaugeIndex == 1)
                        WaitEventDone(ref m_bGrabImage2Done, true, 10000, "AAA40 2");
                    else if (intPlateGaugeIndex == 2)
                        WaitEventDone(ref m_bGrabImage3Done, true, 10000, "AAA40 3");
                    else if (intPlateGaugeIndex == 3)
                        WaitEventDone(ref m_bGrabImage4Done, true, 10000, "AAA40 4");
                    else if (intPlateGaugeIndex == 4)
                        WaitEventDone(ref m_bGrabImage5Done, true, 10000, "AAA40 5");
                    else if (intPlateGaugeIndex == 5)
                        WaitEventDone(ref m_bGrabImage6Done, true, 10000, "AAA40 6");
                    else if (intPlateGaugeIndex == 6)
                        WaitEventDone(ref m_bGrabImage7Done, true, 10000, "AAA40 7");
                }
                if (m_smVisionInfo.g_blnWantUsePocketPattern && m_smVisionInfo.g_blnWantUsePocketGauge)
                {
                    if (intPocketPatternAndGaugeIndex == 0)
                        WaitEventDone(ref m_bGrabImage1Done, true, 10000, "AAA41 1");
                    else if (intPocketPatternAndGaugeIndex == 1)
                        WaitEventDone(ref m_bGrabImage2Done, true, 10000, "AAA41 2");
                    else if (intPocketPatternAndGaugeIndex == 2)
                        WaitEventDone(ref m_bGrabImage3Done, true, 10000, "AAA41 3");
                    else if (intPocketPatternAndGaugeIndex == 3)
                        WaitEventDone(ref m_bGrabImage4Done, true, 10000, "AAA41 4");
                    else if (intPocketPatternAndGaugeIndex == 4)
                        WaitEventDone(ref m_bGrabImage5Done, true, 10000, "AAA41 5");
                    else if (intPocketPatternAndGaugeIndex == 5)
                        WaitEventDone(ref m_bGrabImage6Done, true, 10000, "AAA41 6");
                    else if (intPocketPatternAndGaugeIndex == 6)
                        WaitEventDone(ref m_bGrabImage7Done, true, 10000, "AAA41 7");

                    if (intPlateGaugeIndex == 0)
                        WaitEventDone(ref m_bGrabImage1Done, true, 10000, "AAA42 1");
                    else if (intPlateGaugeIndex == 1)
                        WaitEventDone(ref m_bGrabImage2Done, true, 10000, "AAA42 2");
                    else if (intPlateGaugeIndex == 2)
                        WaitEventDone(ref m_bGrabImage3Done, true, 10000, "AAA42 3");
                    else if (intPlateGaugeIndex == 3)
                        WaitEventDone(ref m_bGrabImage4Done, true, 10000, "AAA42 4");
                    else if (intPlateGaugeIndex == 4)
                        WaitEventDone(ref m_bGrabImage5Done, true, 10000, "AAA42 5");
                    else if (intPlateGaugeIndex == 5)
                        WaitEventDone(ref m_bGrabImage6Done, true, 10000, "AAA42 6");
                    else if (intPlateGaugeIndex == 6)
                        WaitEventDone(ref m_bGrabImage7Done, true, 10000, "AAA42 7");
                }

                m_smVisionInfo.g_arrPocketPositionROIs[0].AttachImage(m_smVisionInfo.g_arrImages[intPocketPatternAndGaugeIndex]);
                m_smVisionInfo.g_arrPocketPositionROIs[1].AttachImage(m_smVisionInfo.g_arrPocketPositionROIs[0]);
                m_smVisionInfo.g_arrPocketPositionROIs[2].AttachImage(m_smVisionInfo.g_arrImages[intPocketPatternAndGaugeIndex]);
                m_smVisionInfo.g_arrPocketPositionROIs[3].AttachImage(m_smVisionInfo.g_arrImages[intPlateGaugeIndex]);

                if (m_smVisionInfo.g_blnWantUsePocketPattern && !m_smVisionInfo.g_blnWantUsePocketGauge)
                {
                    if (m_smVisionInfo.g_objPocketPosition.MatchPocketPattern(m_smVisionInfo.g_arrPocketPositionROIs[0]))
                    {
                        if (m_smVisionInfo.g_objPocketPosition.MeasurePlatePosition(m_smVisionInfo.g_arrImages[intPlateGaugeIndex], m_smVisionInfo.g_arrPocketPositionGauges, true, false))
                        {
                            blnResult = true;
                        }
                        else
                        {
                            blnResult = false;
                        }
                    }
                    else
                    {
                        blnResult = false;
                    }

                }

                if (!m_smVisionInfo.g_blnWantUsePocketPattern && m_smVisionInfo.g_blnWantUsePocketGauge)
                {
                    if (m_smVisionInfo.g_objPocketPosition.MeasurePocketPosition(m_smVisionInfo.g_arrImages[intPocketPatternAndGaugeIndex], m_smVisionInfo.g_arrPocketPositionGauges))
                    {
                        if (m_smVisionInfo.g_objPocketPosition.MeasurePlatePosition(m_smVisionInfo.g_arrImages[intPlateGaugeIndex], m_smVisionInfo.g_arrPocketPositionGauges, false, true))
                        {
                            blnResult = true;
                        }
                        else
                        {
                            blnResult = false;
                        }
                    }
                    else
                    {
                        blnResult = false;
                    }

                }

                if (m_smVisionInfo.g_blnWantUsePocketPattern && m_smVisionInfo.g_blnWantUsePocketGauge)
                {
                    if (m_smVisionInfo.g_objPocketPosition.MatchPocketPattern(m_smVisionInfo.g_arrPocketPositionROIs[0]))
                    {
                        //#region This part is match pattern then directly place ROI on the pattern center
                        //m_smVisionInfo.g_arrPocketPositionROIs[2].SetPosition_Center(m_smVisionInfo.g_arrPocketPositionROIs[0].ref_ROITotalX + m_smVisionInfo.g_objPocketPosition.GetMatchingCenterX(),
                        //    m_smVisionInfo.g_arrPocketPositionROIs[0].ref_ROITotalY + m_smVisionInfo.g_objPocketPosition.GetMatchingCenterY());
                        //m_smVisionInfo.g_arrPocketPositionGauges[0].SetGaugeCenter(m_smVisionInfo.g_arrPocketPositionROIs[0].ref_ROITotalX + m_smVisionInfo.g_objPocketPosition.GetMatchingCenterX(),
                        //    m_smVisionInfo.g_arrPocketPositionROIs[0].ref_ROITotalY + m_smVisionInfo.g_objPocketPosition.GetMatchingCenterY());
                        //#endregion

                        #region This part is place ROI based on the pattern and gauge offset

                        m_smVisionInfo.g_arrPocketPositionROIs[2].LoadROISetting((int)(m_smVisionInfo.g_arrPocketPositionROIs[0].ref_ROITotalX + m_smVisionInfo.g_objPocketPosition.GetMatchingCenterX() + m_smVisionInfo.g_objPocketPosition.ref_fPatternGaugeOffsetX - (m_smVisionInfo.g_arrPocketPositionROIs[2].ref_ROIWidth / 2)),
                       (int)(m_smVisionInfo.g_arrPocketPositionROIs[0].ref_ROITotalY + m_smVisionInfo.g_objPocketPosition.GetMatchingCenterY() + m_smVisionInfo.g_objPocketPosition.ref_fPatternGaugeOffsetY - (m_smVisionInfo.g_arrPocketPositionROIs[2].ref_ROIHeight / 2)),
                       m_smVisionInfo.g_arrPocketPositionROIs[2].ref_ROIWidth, m_smVisionInfo.g_arrPocketPositionROIs[2].ref_ROIHeight);

                        m_smVisionInfo.g_arrPocketPositionGauges[0].SetGaugeCenter(m_smVisionInfo.g_arrPocketPositionROIs[0].ref_ROITotalX + m_smVisionInfo.g_objPocketPosition.GetMatchingCenterX() + m_smVisionInfo.g_objPocketPosition.ref_fPatternGaugeOffsetX,
                            m_smVisionInfo.g_arrPocketPositionROIs[0].ref_ROITotalY + m_smVisionInfo.g_objPocketPosition.GetMatchingCenterY() + m_smVisionInfo.g_objPocketPosition.ref_fPatternGaugeOffsetY);
                        #endregion
                        if (m_smVisionInfo.g_objPocketPosition.MeasurePlate(m_smVisionInfo.g_arrImages[intPlateGaugeIndex], m_smVisionInfo.g_arrPocketPositionGauges, true, true))
                        {
                            if ((m_smVisionInfo.g_arrPocketPositionGauges[0].ref_GaugeCenterX + m_smVisionInfo.g_arrPocketPositionGauges[0].ref_GaugeTolerance) > m_smVisionInfo.g_arrPocketPositionGauges[1].ref_ObjectCenterX)
                            {
                                #region This part is place ROI and gauge before measure plate gauge center

                                m_smVisionInfo.g_arrPocketPositionROIs[2].LoadROISetting((int)(m_smVisionInfo.g_arrPocketPositionGauges[1].ref_ObjectCenterX - m_smVisionInfo.g_arrPocketPositionROIs[2].ref_ROIWidth - 5),
                                 (int)(m_smVisionInfo.g_arrPocketPositionROIs[2].ref_ROITotalY),
                                 m_smVisionInfo.g_arrPocketPositionROIs[2].ref_ROIWidth, m_smVisionInfo.g_arrPocketPositionROIs[2].ref_ROIHeight);

                                m_smVisionInfo.g_arrPocketPositionGauges[0].SetGaugeCenter(m_smVisionInfo.g_arrPocketPositionGauges[1].ref_ObjectCenterX - m_smVisionInfo.g_arrPocketPositionGauges[0].ref_GaugeTolerance - 5,
                                    m_smVisionInfo.g_arrPocketPositionGauges[0].ref_GaugeCenterY);
                                #endregion
                            }

                            if (m_smVisionInfo.g_objPocketPosition.MeasurePocketPosition(m_smVisionInfo.g_arrImages[intPocketPatternAndGaugeIndex], m_smVisionInfo.g_arrPocketPositionGauges))
                            {
                                if (m_smVisionInfo.g_objPocketPosition.MeasurePlatePosition(m_smVisionInfo.g_arrImages[intPlateGaugeIndex], m_smVisionInfo.g_arrPocketPositionGauges, true, true))
                                {
                                    blnResult = true;
                                }
                                else
                                {
                                    blnResult = false;
                                }
                            }
                            else
                            {
                                blnResult = false;
                            }
                        }
                        else
                        {
                            blnResult = false;
                        }
                    }
                    else
                    {
                        blnResult = false;//2019-12-26 ZJYEOH : Directly fail if pattern fail, because may found valid point too if check at original gauge position
                        //#region This part is place ROI based on the pattern and gauge offset

                        //m_smVisionInfo.g_arrPocketPositionROIs[2].LoadROISetting((int)(m_smVisionInfo.g_arrPocketPositionROIs[0].ref_ROITotalX + m_smVisionInfo.g_arrPocketPositionROIs[1].ref_ROICenterX + m_smVisionInfo.g_objPocketPosition.ref_fPatternGaugeOffsetX - (m_smVisionInfo.g_arrPocketPositionROIs[2].ref_ROIWidth / 2)),
                        // (int)(m_smVisionInfo.g_arrPocketPositionROIs[0].ref_ROITotalY + m_smVisionInfo.g_arrPocketPositionROIs[1].ref_ROICenterY + m_smVisionInfo.g_objPocketPosition.ref_fPatternGaugeOffsetY - (m_smVisionInfo.g_arrPocketPositionROIs[2].ref_ROIHeight / 2)),
                        // m_smVisionInfo.g_arrPocketPositionROIs[2].ref_ROIWidth, m_smVisionInfo.g_arrPocketPositionROIs[2].ref_ROIHeight);

                        //m_smVisionInfo.g_arrPocketPositionGauges[0].SetGaugeCenter(m_smVisionInfo.g_arrPocketPositionROIs[0].ref_ROITotalX + m_smVisionInfo.g_arrPocketPositionROIs[1].ref_ROICenterX + m_smVisionInfo.g_objPocketPosition.ref_fPatternGaugeOffsetX,
                        //    m_smVisionInfo.g_arrPocketPositionROIs[0].ref_ROITotalY + m_smVisionInfo.g_arrPocketPositionROIs[1].ref_ROICenterY + m_smVisionInfo.g_objPocketPosition.ref_fPatternGaugeOffsetY);
                        //#endregion

                        //if (m_smVisionInfo.g_objPocketPosition.MeasurePocketPosition(m_smVisionInfo.g_arrImages[m_smVisionInfo.g_objPocketPosition.GetGrabImageIndex(0)], m_smVisionInfo.g_arrPocketPositionGauges))
                        //{
                        //    if (m_smVisionInfo.g_objPocketPosition.MeasurePlatePosition(m_smVisionInfo.g_arrImages[m_smVisionInfo.g_objPocketPosition.GetGrabImageIndex(1)], m_smVisionInfo.g_arrPocketPositionGauges, true, true))
                        //    {
                        //        blnResult = true;
                        //    }
                        //    else
                        //    {
                        //        blnResult = false;
                        //    }
                        //}
                        //else
                        //{
                        //    blnResult = false;
                        //}
                    }

                    //Set back to original position
                    #region This part is place ROI based on the pattern and gauge offset

                    m_smVisionInfo.g_arrPocketPositionROIs[2].LoadROISetting((int)(m_smVisionInfo.g_arrPocketPositionROIs[0].ref_ROITotalX + m_smVisionInfo.g_arrPocketPositionROIs[1].ref_ROICenterX + m_smVisionInfo.g_objPocketPosition.ref_fPatternGaugeOffsetX - (m_smVisionInfo.g_arrPocketPositionROIs[2].ref_ROIWidth / 2)),
                     (int)(m_smVisionInfo.g_arrPocketPositionROIs[0].ref_ROITotalY + m_smVisionInfo.g_arrPocketPositionROIs[1].ref_ROICenterY + m_smVisionInfo.g_objPocketPosition.ref_fPatternGaugeOffsetY - (m_smVisionInfo.g_arrPocketPositionROIs[2].ref_ROIHeight / 2)),
                     m_smVisionInfo.g_arrPocketPositionROIs[2].ref_ROIWidth, m_smVisionInfo.g_arrPocketPositionROIs[2].ref_ROIHeight);

                    m_smVisionInfo.g_arrPocketPositionGauges[0].SetGaugeCenter(m_smVisionInfo.g_arrPocketPositionROIs[0].ref_ROITotalX + m_smVisionInfo.g_arrPocketPositionROIs[1].ref_ROICenterX + m_smVisionInfo.g_objPocketPosition.ref_fPatternGaugeOffsetX,
                        m_smVisionInfo.g_arrPocketPositionROIs[0].ref_ROITotalY + m_smVisionInfo.g_arrPocketPositionROIs[1].ref_ROICenterY + m_smVisionInfo.g_objPocketPosition.ref_fPatternGaugeOffsetY);
                    #endregion
                }


                m_blnPocketPositionResult = blnResult;
                
                if (!blnResult)
                {
                    if (blnAuto)
                    {
                        SaveRejectImage_AddToBuffer("Pocket Position", m_smVisionInfo.g_objPocketPosition.ref_strErrorMessage);
                        //if (m_smVisionInfo.g_intUnitsOnImage == 1 && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)
                        //{
                        //    //m_smVisionInfo.g_intMarkFailureTotal++;
                           
                        //    m_blnFailCounterAdded = true;
                        //}


                    }
                    m_smVisionInfo.g_strErrorMessage = m_smVisionInfo.g_objPocketPosition.ref_strErrorMessage;
                    return blnResult;
                }


                return blnResult;

            }
            catch (Exception ex)
            {
                m_blnPocketPositionResult = false;
                return false;
            }
        }

        private bool StartMarkTest_using4LGauge_OcvAngleAndPackageAngle(bool blnAuto, int intUnitNo)
        {
            try
            {
                if ((m_smCustomizeInfo.g_intWantMark & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
                {
                    if (m_smVisionInfo.g_arrMarks[intUnitNo].GetNumTemplates() == 0)
                    {
                        // 2020 04 15 - JBTAN: check mark option enable only will set result fail
                        if (m_smVisionInfo.g_arrMarks[intUnitNo].ref_blnCheckMark)
                        {
                            if (m_smVisionInfo.g_intUnitsOnImage == 1)
                                m_smVisionInfo.g_strErrorMessage += "*Unit " + (intUnitNo + 1) + ":*Mark Template Not Found";
                            else
                                m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + ":*Mark Template Not Found";

                            if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 23 g_intMarkFailureTotal=" + m_smVisionInfo.g_intMarkFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());

                            if ((intUnitNo == 1 || m_smVisionInfo.g_intUnitsOnImage == 1) && blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)
                            {
                                m_smVisionInfo.g_intNoTemplateFailureTotal++;
                                //m_smVisionInfo.g_intTestedTotal++;
                                //m_smVisionInfo.g_intLowYieldUnitCount++;
                                m_blnFailCounterAdded = true;

                                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                                    if (m_intTCPIPResultID == -1)
                                        m_intTCPIPResultID = (int)TCPIPResulID.Fail;//FailMark;

                                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 23a g_intMarkFailureTotal=" + m_smVisionInfo.g_intMarkFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                            }
                        }
                        else
                        {
                            // 2020-06-30 ZJYEOH : Just to fix no parameter in package inspection
                            if (m_smVisionInfo.g_arrMarkROIs.Count > intUnitNo)
                            {
                                if (m_smVisionInfo.g_arrMarkROIs[intUnitNo].Count > 0)
                                {
                                    m_objMarkSearchROI = m_smVisionInfo.g_arrMarkROIs[intUnitNo][0];
                                }

                                if (m_objMarkTrainROI == null)
                                    m_objMarkTrainROI = new ROI();
                                m_objMarkTrainROI.AttachImage(m_objMarkSearchROI);
                                if (m_smVisionInfo.g_arrMarkROIs[intUnitNo].Count > 1)
                                {
                                    m_objMarkTrainROI.LoadROISetting(m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIPositionX, m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIPositionY,
                                                                m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIWidth, m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIHeight);
                                }
                            }

                        }
                        return false;
                    }

                    m_arrDontCareLeadAreaStartX.Clear();
                    m_arrDontCareLeadAreaStartY.Clear();
                    m_arrDontCareLeadAreaEndX.Clear();
                    m_arrDontCareLeadAreaEndY.Clear();
                    m_arrDontCareLeadDirection.Clear();

                    m_objMarkSearchROI = m_smVisionInfo.g_arrMarkROIs[intUnitNo][0];
                    if (m_objMarkTrainROI == null)
                        m_objMarkTrainROI = new ROI();
                    m_objMarkTrainROI.AttachImage(m_objMarkSearchROI);
                    m_objMarkTrainROI.LoadROISetting(m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIPositionX, m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIPositionY,
                                               m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIWidth, m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIHeight);

                    if (m_objMarkOcvSearchROI == null)
                        m_objMarkOcvSearchROI = new ROI();
                    m_objMarkOcvSearchROI.AttachImage(m_smVisionInfo.g_objMarkImage);
                    m_objMarkOcvSearchROI.LoadROISetting(m_objMarkSearchROI.ref_ROIPositionX, m_objMarkSearchROI.ref_ROIPositionY,
                                                             m_objMarkSearchROI.ref_ROIWidth, m_objMarkSearchROI.ref_ROIHeight);

                    if (m_smVisionInfo.g_arrOrients[intUnitNo][0].ref_intCorrectAngleMethod == 0)
                    {
                        //no orient check
                        if (((m_smCustomizeInfo.g_intWantOrient & (1 << m_smVisionInfo.g_intVisionPos)) == 0))
                        {
                            //got gauge check
                            if (m_smVisionInfo.g_blnWantGauge)
                            {
                                m_objMarkSearchROI.AttachImage(m_smVisionInfo.g_arrImages[0]);
                                m_smVisionInfo.g_arrMarkGaugeM4L[intUnitNo].Measure_WithDontCareArea(m_smVisionInfo.g_arrImages, m_smVisionInfo.g_objWhiteImage);
                                // Rotate unit to exact 0 degree
                                float fGaugeAngle = m_smVisionInfo.g_arrMarkGaugeM4L[intUnitNo].ref_fRectAngle;

                                ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[0], m_objMarkSearchROI, fGaugeAngle, m_smVisionInfo.g_intRotationInterpolation_Mark, ref m_smVisionInfo.g_arrRotatedImages, 0);
                                m_objMarkSearchROI.AttachImage(m_smVisionInfo.g_arrRotatedImages[0]);
                            }
                        }
                        else
                        {
                            // Attach search ROI to rotated image
                            m_objMarkSearchROI.AttachImage(m_smVisionInfo.g_arrRotatedImages[0]);

                            // Relocated search roi according the orient gauge measurement object center point.
                            if (m_smVisionInfo.g_blnWantGauge)
                            {
                                if (m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].ref_pRectCenterPoint.X.ToString() != "NaN" && m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].ref_pRectCenterPoint.Y.ToString() != "NaN" &&
                                m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].ref_pRectCenterPoint.X.ToString() != "-NaN" && m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].ref_pRectCenterPoint.Y.ToString() != "-NaN" &&
                                m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].ref_pRectCenterPoint.X.ToString() != "Infinity" && m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].ref_pRectCenterPoint.Y.ToString() != "Infinity" &&
                                m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].ref_pRectCenterPoint.X.ToString() != "-Infinity" && m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].ref_pRectCenterPoint.Y.ToString() != "-Infinity")
                                    m_objMarkSearchROI.LoadROISetting(
                                (int)Math.Round(m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].ref_pRectCenterPoint.X -
                                m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIWidth / 2, 0, MidpointRounding.AwayFromZero),
                                (int)Math.Round(m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].ref_pRectCenterPoint.Y -
                                m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIHeight / 2, 0, MidpointRounding.AwayFromZero),
                                m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIWidth,
                                m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIHeight);
                            }
                        }

                        if (m_smVisionInfo.g_blnWantGauge)
                        {
                            RectGaugeM4L objGauge;
                            if (m_blnWantOrientTest)
                            {
                                objGauge = m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo];
                            }
                            else
                            {
                                objGauge = m_smVisionInfo.g_arrMarkGaugeM4L[intUnitNo];

                                if (m_blnWantPositioning)
                                {
                                    objGauge.SetGaugePlace_BasedOnEdgeROI();

                                    m_objMarkSearchROI.LoadROISetting(
                                        (int)Math.Round(m_smVisionInfo.g_objPositioning.ref_fObjectCenterX -
                                         m_objMarkSearchROI.ref_ROIWidth / 2, 0, MidpointRounding.AwayFromZero),
                                         (int)Math.Round(m_smVisionInfo.g_objPositioning.ref_fObjectCenterY -
                                        m_objMarkSearchROI.ref_ROIHeight / 2, 0, MidpointRounding.AwayFromZero),
                                        m_objMarkSearchROI.ref_ROIWidth,
                                        m_objMarkSearchROI.ref_ROIHeight);
                                }

                                // Measure search roi to get unit center point
                                objGauge.Measure_WithDontCareArea(m_smVisionInfo.g_arrRotatedImages, m_objMarkSearchROI, m_smVisionInfo.g_objWhiteImage);
                            }

                            // Get mark gauge measure size
                            int intGaugeWidth = (int)(objGauge.ref_fRectWidth);
                            int intGaugeHeight = (int)(objGauge.ref_fRectHeight);

                            // Get Mark ROI size
                            int intROIWidth = m_objMarkTrainROI.ref_ROIWidth;
                            int intROIHeight = m_objMarkTrainROI.ref_ROIHeight;

                            if (intROIWidth >= intGaugeWidth)
                                intROIWidth -= (intROIWidth - intGaugeWidth) / 2;
                            if (intROIHeight >= intGaugeHeight)
                                intROIHeight -= (intROIHeight - intGaugeHeight) / 2;

                            int intROIOriX = (int)(objGauge.ref_pRectCenterPoint.X - intROIWidth / 2) - m_objMarkSearchROI.ref_ROIPositionX;
                            int intROIOriY = (int)(objGauge.ref_pRectCenterPoint.Y - intROIHeight / 2) - m_objMarkSearchROI.ref_ROIPositionY;


                            // Set train roi start point
                            if ((intROIOriX > 0) &&
                              ((intROIOriX + m_objMarkTrainROI.ref_ROIWidth) <= m_objMarkSearchROI.ref_ROIWidth) &&
                              (intROIOriY > 0) &&
                              ((intROIOriY + m_objMarkTrainROI.ref_ROIHeight) <= m_objMarkSearchROI.ref_ROIHeight))
                            {
                                m_objMarkTrainROI.ref_ROIPositionX = intROIOriX;
                                m_objMarkTrainROI.ref_ROIPositionY = intROIOriY;
                            }
                            else
                            {
                                m_objMarkTrainROI.ref_ROIPositionX = m_objMarkTrainROI.ref_ROIOriPositionX;
                                m_objMarkTrainROI.ref_ROIPositionY = m_objMarkTrainROI.ref_ROIOriPositionY;
                            }
                        }
                        //else if (m_smVisionInfo.g_arrMarkROIs[intUnitNo].Count > 3)    // Mean Unit Surface ROI exist
                        //{
                        //    // Get offset value between Unit Surface ROI and Mark ROI center points
                        //    int intMarkROIOffsetX = m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROICenterX - m_smVisionInfo.g_arrMarkROIs[intUnitNo][3].ref_ROICenterX;
                        //    int intMarkROIOffsetY = m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROICenterY - m_smVisionInfo.g_arrMarkROIs[intUnitNo][3].ref_ROICenterY;

                        //    // Find unit ROI (Train ROI)
                        //    m_objMarkTrainROI.ref_ROIPositionX = (int)Math.Round(m_smVisionInfo.g_fUnitCenterX[intUnitNo] - (float)m_objMarkTrainROI.ref_ROIWidth / 2 + intMarkROIOffsetX, 0, MidpointRounding.AwayFromZero);   // 2018 10 09 - CCENG: change g_fOrientCenterXY to g_fUnitCenterXY because g_fOrientCenter is used to keep Orient matcher result center point, not orient gauge unit center point.
                        //    m_objMarkTrainROI.ref_ROIPositionY = (int)Math.Round(m_smVisionInfo.g_fUnitCenterY[intUnitNo] - (float)m_objMarkTrainROI.ref_ROIHeight / 2 + intMarkROIOffsetY, 0, MidpointRounding.AwayFromZero);
                        //}
                        else //No gauge
                        {
                            /* 2019 07 12 - CCENG: 
                             * No gauge mean dun know where is the unit.
                             * Mark ROI will be relocated according to orient PR result + offset between orient ROI and mark ROI
                             */
                            //if (m_smVisionInfo.g_fOrientCenterX[intUnitNo] != -1 && m_smVisionInfo.g_fOrientCenterY[intUnitNo] != -1)    // Orient test able to get position
                            //{
                            //    // Set Mark Train ROI position to "Orient center + Offset btw Orient ROI and Mark ROI"
                            //    m_objMarkTrainROI.LoadROISetting((int)m_smVisionInfo.g_fOrientCenterX[intUnitNo] +                  // Orient Result Object Center X
                            //                                       m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROICenterX -      // Mark ROI Center X
                            //                                       m_smVisionInfo.g_arrOrientROIs[intUnitNo][1].ref_ROICenterX -    // Orient ROI Center X
                            //                                       m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIWidth / 2,     // Half of Mark ROI Size X
                            //                                       (int)m_smVisionInfo.g_fOrientCenterY[intUnitNo] +
                            //                                       m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROICenterY -
                            //                                       m_smVisionInfo.g_arrOrientROIs[intUnitNo][1].ref_ROICenterY -
                            //                                       m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIHeight / 2,
                            //                                       m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIWidth, m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIHeight);
                            //}
                            //else
                            //{
                            //    // Set Mark Train ROI position to Search ROI center point since cannot find Orient center.
                            //    m_objMarkTrainROI.LoadROISetting(m_objMarkSearchROI.ref_ROIWidth / 2 -
                            //                                       m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIWidth / 2,     // Half of Mark ROI Size X
                            //                                       m_objMarkSearchROI.ref_ROIHeight / 2 -
                            //                                       m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIHeight / 2,
                            //                                       m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIWidth, m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIHeight);
                            //}

                            bool blnUsePackageCenterPoint = false;
                            if (m_blnWantPackageTest && ((m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailMask & 0x1000) > 0 || m_smVisionInfo.g_arrPackage[intUnitNo].GetWantInspectPackage())) // 2020-06-23 ZJYEOH : If inspection option got tick Check package size just can use pkg gauge
                            {
                                if (intUnitNo == 0)
                                {
                                    WaitEventDone(ref m_bPackageSizePreTestDone1, true, 10000, "AAA44");

                                    if (m_bPackageSizePreTestResult1)
                                    {
                                        blnUsePackageCenterPoint = true;
                                    }
                                }
                                else
                                {
                                    WaitEventDone(ref m_bPackageSizePreTestDone2, true, 10000, "AAA45");

                                    if (m_bPackageSizePreTestResult2)
                                    {
                                        blnUsePackageCenterPoint = true;
                                    }
                                }
                            }

                            bool blnUseLeadBaseCenterPoint = false;
                            if (!blnUsePackageCenterPoint)  // if no use package center point, then try use lead base center point
                            {
                                // 2020 12 18 - CCENG: No need check also if ByPassUnit is true.
                                if ((m_smCustomizeInfo.g_intWantLead & (1 << m_smVisionInfo.g_intVisionPos)) > 0 && m_smVisionInfo.g_arrLead[0].GetWantInspectLead() && !m_smVisionInfo.VM_PR_ByPassUnit)
                                {
                                    WaitEventDone(ref m_bLeadBaseCenterPointDone, true, 10000, "AAA46");

                                    if (m_bLeadBaseCenterPointResult)
                                    {
                                        blnUseLeadBaseCenterPoint = true;

                                        m_arrDontCareLeadAreaStartX.Clear();
                                        m_arrDontCareLeadAreaStartY.Clear();
                                        m_arrDontCareLeadAreaEndX.Clear();
                                        m_arrDontCareLeadAreaEndY.Clear();
                                        m_arrDontCareLeadDirection.Clear();

                                        for (int j = 0; j < m_smVisionInfo.g_arrLead.Length; j++)
                                        {
                                            if (m_smVisionInfo.g_arrLead[j].ref_blnSelected)
                                            {
                                                for (int k = 0; k < m_smVisionInfo.g_arrLead[j].ref_intNumberOfLead; k++)
                                                {
                                                    float fStartX = 0, fStartY = 0, fEndX = 0, fEndY = 0;
                                                    int intLeadDirection = 0;
                                                    m_smVisionInfo.g_arrLead[j].GetSampleLeadArea(k,
                                                                                                  m_smVisionInfo.g_arrInspectLeadROI[j].ref_ROITotalX,
                                                                                                  m_smVisionInfo.g_arrInspectLeadROI[j].ref_ROITotalY,
                                                                                                  m_smVisionInfo.g_arrLead[0].ref_fRotateCenterX_ForDrawing,
                                                                                                  m_smVisionInfo.g_arrLead[0].ref_fRotateCenterY_ForDrawing,
                                                                                                   m_fOrientFinalAngleForLead - m_fLeadPatternAngle,
                                                                                                  ref fStartX, ref fStartY, ref fEndX, ref fEndY, ref intLeadDirection);

                                                    m_arrDontCareLeadAreaStartX.Add(fStartX);
                                                    m_arrDontCareLeadAreaStartY.Add(fStartY);
                                                    m_arrDontCareLeadAreaEndX.Add(fEndX);
                                                    m_arrDontCareLeadAreaEndY.Add(fEndY);
                                                    m_arrDontCareLeadDirection.Add(intLeadDirection);
                                                }
                                            }
                                        }

                                    }
                                    else
                                        return true;//2021-09-09 ZJYEOH : Should return true instead of false, so that can fail lead or package 
                                }
                            }

                            if (blnUsePackageCenterPoint)
                            {
                                RectGaugeM4L objGauge;
                                if (intUnitNo == 0)
                                    objGauge = m_smVisionInfo.g_objGauge_PkgSize;
                                else
                                    objGauge = m_smVisionInfo.g_objGauge_PkgSize2;
                                if (m_smVisionInfo.g_fOrientCenterX[intUnitNo] != -1 && m_smVisionInfo.g_fOrientCenterY[intUnitNo] != -1)    // Orient test able to get position
                                {
                                    // 2019 10 15 - CCENG: Use m_smVisionInfo.g_objGauge_PkgSize measurement center point as rotation center point reference to get mark train roi "0 orient direction and 0 deg" center points.
                                    float CenterX = (float)(objGauge.ref_pRectCenterPoint.X - m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIPositionX);
                                    float CenterY = (float)(objGauge.ref_pRectCenterPoint.Y - m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIPositionY);

                                    float Angle = m_smVisionInfo.g_fOrientAngle[intUnitNo] + (m_intOrientAngle); // this formula is based on clockwise rotation so the angle need to be inverted, 
                                    Angle = -Angle;
                                    float fXAfterRotated = (float)((CenterX) + ((m_smVisionInfo.g_fOrientCenterX[intUnitNo] - CenterX) * Math.Cos(Angle * Math.PI / 180)) - ((m_smVisionInfo.g_fOrientCenterY[intUnitNo] - CenterY) * Math.Sin(Angle * Math.PI / 180)));

                                    float fYAfterRotated = (float)((CenterY) + ((m_smVisionInfo.g_fOrientCenterX[intUnitNo] - CenterX) * Math.Sin(Angle * Math.PI / 180)) + ((m_smVisionInfo.g_fOrientCenterY[intUnitNo] - CenterY) * Math.Cos(Angle * Math.PI / 180)));

                                    m_fCenterX = //m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalX + m_smVisionInfo.g_fOrientCenterX[0] + m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROICenterX - m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROICenterX;
                                    m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROITotalX + fXAfterRotated + m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROICenterX - m_smVisionInfo.g_arrOrientROIs[intUnitNo][1].ref_ROICenterX;
                                    m_fCenterY = //m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalY + m_smVisionInfo.g_fOrientCenterY[0] + m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROICenterY - m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROICenterY;
                                    m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROITotalY + fYAfterRotated + m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROICenterY - m_smVisionInfo.g_arrOrientROIs[intUnitNo][1].ref_ROICenterY;
                                    //m_objMarkTrainROI.SaveImage("D:\\TS\\MarkROI.bmp");
                                    m_objMarkTrainROI.LoadROISetting((int)fXAfterRotated +                  // Orient Result Object Center X
                                                                    m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROICenterX -      // Mark ROI Center X
                                                                    m_smVisionInfo.g_arrOrientROIs[intUnitNo][1].ref_ROICenterX -    // Orient ROI Center X
                                                                    m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIWidth / 2,     // Half of Mark ROI Size X
                                                                    (int)fYAfterRotated +
                                                                    m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROICenterY -
                                                                    m_smVisionInfo.g_arrOrientROIs[intUnitNo][1].ref_ROICenterY -
                                                                    m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIHeight / 2,
                                                                    m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIWidth, m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIHeight);

                                    //m_objMarkTrainROI.SaveImage("D:\\TS\\MarkROI2.bmp");
                                }
                                else
                                {
                                    m_objMarkTrainROI.LoadROISetting(m_objMarkSearchROI.ref_ROIWidth / 2 -    // Orient ROI Center X
                                                                    m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIWidth / 2,     // Half of Mark ROI Size X
                                                                    m_objMarkSearchROI.ref_ROIHeight / 2 -
                                                                    m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIHeight / 2,
                                                                    m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIWidth, m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIHeight);
                                }

                                // // 2019-11-08 ZJYEOH : Limit Mark inspection ROI within package size area, so that extra mark wont happen outside the package size area

                                // if (m_objMarkTrainROI.ref_ROITotalX < (m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X - m_smVisionInfo.g_objGauge_PkgSize.ref_fRectWidth / 2))
                                // {
                                //     m_objMarkTrainROI.LoadROISetting(m_objMarkTrainROI.ref_ROIPositionX + (int)(m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X - m_smVisionInfo.g_objGauge_PkgSize.ref_fRectWidth / 2) - m_objMarkTrainROI.ref_ROITotalX,
                                // m_objMarkTrainROI.ref_ROIPositionY,
                                // m_objMarkTrainROI.ref_ROIWidth - ((int)(m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X - m_smVisionInfo.g_objGauge_PkgSize.ref_fRectWidth / 2) - m_objMarkTrainROI.ref_ROITotalX), m_objMarkTrainROI.ref_ROIHeight);
                                // }

                                // if (m_objMarkTrainROI.ref_ROITotalY < (m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y - m_smVisionInfo.g_objGauge_PkgSize.ref_fRectHeight / 2))
                                // {
                                //     m_objMarkTrainROI.LoadROISetting(m_objMarkTrainROI.ref_ROIPositionX,
                                //m_objMarkTrainROI.ref_ROIPositionY + (int)(m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y - m_smVisionInfo.g_objGauge_PkgSize.ref_fRectHeight / 2) - m_objMarkTrainROI.ref_ROITotalY,
                                // m_objMarkTrainROI.ref_ROIWidth, m_objMarkTrainROI.ref_ROIHeight - ((int)(m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y - m_smVisionInfo.g_objGauge_PkgSize.ref_fRectHeight / 2) - m_objMarkTrainROI.ref_ROITotalY));
                                // }

                                // if (m_objMarkTrainROI.ref_ROITotalY + m_objMarkTrainROI.ref_ROIHeight > (m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y + m_smVisionInfo.g_objGauge_PkgSize.ref_fRectHeight / 2))
                                // {
                                //     m_objMarkTrainROI.LoadROISetting(m_objMarkTrainROI.ref_ROIPositionX, m_objMarkTrainROI.ref_ROIPositionY,
                                // m_objMarkTrainROI.ref_ROIWidth, m_objMarkTrainROI.ref_ROIHeight - (int)(m_objMarkTrainROI.ref_ROITotalY + m_objMarkTrainROI.ref_ROIHeight - (m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y + m_smVisionInfo.g_objGauge_PkgSize.ref_fRectHeight / 2)));
                                // }

                                // if (m_objMarkTrainROI.ref_ROITotalX + m_objMarkTrainROI.ref_ROIWidth > (m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X + m_smVisionInfo.g_objGauge_PkgSize.ref_fRectWidth / 2))
                                // {
                                //     m_objMarkTrainROI.LoadROISetting(m_objMarkTrainROI.ref_ROIPositionX, m_objMarkTrainROI.ref_ROIPositionY,
                                // m_objMarkTrainROI.ref_ROIWidth - (int)(m_objMarkTrainROI.ref_ROITotalX + m_objMarkTrainROI.ref_ROIWidth - (m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X + m_smVisionInfo.g_objGauge_PkgSize.ref_fRectWidth / 2)), m_objMarkTrainROI.ref_ROIHeight);
                                // }
                               
                                int intROITolerance_Top = 0, intROITolerance_Right = 0, intROITolerance_Bottom = 0, intROITolerance_Left = 0;
                                if (m_smVisionInfo.g_blnWhiteOnBlack || !m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateBrightDarkROITolerance)
                                {
                                    intROITolerance_Top = m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdge;
                                    intROITolerance_Right = m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromRight;
                                    intROITolerance_Bottom = m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromBottom;
                                    intROITolerance_Left = m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeft;
                                }
                                else
                                {
                                    intROITolerance_Top = m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdge_Dark;
                                    intROITolerance_Right = m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromRight_Dark;
                                    intROITolerance_Bottom = m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromBottom_Dark;
                                    intROITolerance_Left = m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeft_Dark;
                                }

                                float fEdgeLimit = objGauge.ref_pRectCenterPoint.X - objGauge.ref_fRectWidth / 2 + intROITolerance_Left;
                                if (m_objMarkTrainROI.ref_ROITotalX < fEdgeLimit)
                                {
                                    m_objMarkTrainROI.LoadROISetting(m_objMarkTrainROI.ref_ROIPositionX + (int)Math.Round(fEdgeLimit - m_objMarkTrainROI.ref_ROITotalX, 0, MidpointRounding.AwayFromZero),
                                                                     m_objMarkTrainROI.ref_ROIPositionY,
                                                                     m_objMarkTrainROI.ref_ROIWidth - (int)Math.Round(fEdgeLimit - m_objMarkTrainROI.ref_ROITotalX, 0, MidpointRounding.AwayFromZero),
                                                                     m_objMarkTrainROI.ref_ROIHeight);
                                }

                                fEdgeLimit = objGauge.ref_pRectCenterPoint.Y - objGauge.ref_fRectHeight / 2 + intROITolerance_Top;
                                if (m_objMarkTrainROI.ref_ROITotalY < fEdgeLimit)
                                {
                                    m_objMarkTrainROI.LoadROISetting(m_objMarkTrainROI.ref_ROIPositionX,
                                                                     m_objMarkTrainROI.ref_ROIPositionY + (int)Math.Round(fEdgeLimit - m_objMarkTrainROI.ref_ROITotalY, 0, MidpointRounding.AwayFromZero),
                                                                     m_objMarkTrainROI.ref_ROIWidth,
                                                                     m_objMarkTrainROI.ref_ROIHeight - ((int)fEdgeLimit - m_objMarkTrainROI.ref_ROITotalY));
                                }

                                fEdgeLimit = objGauge.ref_pRectCenterPoint.Y + objGauge.ref_fRectHeight / 2 - intROITolerance_Bottom;
                                if (m_objMarkTrainROI.ref_ROITotalY + m_objMarkTrainROI.ref_ROIHeight > fEdgeLimit)
                                {
                                    m_objMarkTrainROI.LoadROISetting(m_objMarkTrainROI.ref_ROIPositionX, m_objMarkTrainROI.ref_ROIPositionY,
                                                                     m_objMarkTrainROI.ref_ROIWidth,
                                                                     m_objMarkTrainROI.ref_ROIHeight - (int)Math.Round(m_objMarkTrainROI.ref_ROITotalY + m_objMarkTrainROI.ref_ROIHeight - fEdgeLimit, 0, MidpointRounding.AwayFromZero));
                                }

                                fEdgeLimit = objGauge.ref_pRectCenterPoint.X + objGauge.ref_fRectWidth / 2 - intROITolerance_Right;
                                if (m_objMarkTrainROI.ref_ROITotalX + m_objMarkTrainROI.ref_ROIWidth > fEdgeLimit)
                                {
                                    m_objMarkTrainROI.LoadROISetting(m_objMarkTrainROI.ref_ROIPositionX,
                                                                     m_objMarkTrainROI.ref_ROIPositionY,
                                                                     m_objMarkTrainROI.ref_ROIWidth - (int)Math.Round(m_objMarkTrainROI.ref_ROITotalX + m_objMarkTrainROI.ref_ROIWidth - fEdgeLimit, 0, MidpointRounding.AwayFromZero),
                                                                     m_objMarkTrainROI.ref_ROIHeight);
                                }

                            }
                            #region 2021-08-25 : Hide this because no more using Lead base point to offset mark ROI
                            //else if (blnUseLeadBaseCenterPoint && m_blnWantLeadTest && (!m_blnWantPackageTest || (m_blnWantPackageTest && ((m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailMask & 0x1000) == 0 && !m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetWantInspectPackage()))) && m_smVisionInfo.g_blnWantUseLeadPointOffsetMarkROI)
                            //{
                            //    m_smVisionInfo.g_arrRotatedImages[0].CopyTo(ref m_objMarkTestImage);
                            //    m_objMarkSearchROI.AttachImage(m_objMarkTestImage);

                            //    PointF pLeadRefBasePoint = new PointF();
                            //    if (m_smVisionInfo.g_arrLead[1].ref_blnSelected && m_smVisionInfo.g_arrLead[3].ref_blnSelected)
                            //    {
                            //        pLeadRefBasePoint = m_smVisionInfo.g_arrLead[1].GetSampleLeadBaseCenterPoint(false);

                            //        pLeadRefBasePoint = new PointF(m_smVisionInfo.g_arrInspectLeadROI[1].ref_ROITotalX + pLeadRefBasePoint.X,
                            //                                       m_smVisionInfo.g_arrInspectLeadROI[1].ref_ROITotalY + pLeadRefBasePoint.Y);
                            //    }
                            //    else if (m_smVisionInfo.g_arrLead[2].ref_blnSelected && m_smVisionInfo.g_arrLead[4].ref_blnSelected)
                            //    {
                            //        pLeadRefBasePoint = m_smVisionInfo.g_arrLead[4].GetSampleLeadBaseCenterPoint(true);
                            //        pLeadRefBasePoint = new PointF(m_smVisionInfo.g_arrInspectLeadROI[4].ref_ROITotalX + pLeadRefBasePoint.X,
                            //                                       m_smVisionInfo.g_arrInspectLeadROI[4].ref_ROITotalY + pLeadRefBasePoint.Y);
                            //    }

                            //    //float fOffsetX1 = -60;
                            //    //float fOffsetY1 = 30;
                            //    //float fOffsetX2 = 300;
                            //    //float fOffsetY2 = 180;
                            //    float fOffsetX1 = m_smVisionInfo.g_arrMarks[0].ref_intMarkROIOffsetLeft;
                            //    float fOffsetY1 = m_smVisionInfo.g_arrMarks[0].ref_intMarkROIOffsetTop;
                            //    float fOffsetX2 = m_smVisionInfo.g_arrMarks[0].ref_intMarkROIOffsetRight;
                            //    float fOffsetY2 = m_smVisionInfo.g_arrMarks[0].ref_intMarkROIOffsetBottom;
                            //    PointF pStart = new PointF(pLeadRefBasePoint.X + fOffsetX1, pLeadRefBasePoint.Y + fOffsetY1);
                            //    PointF pEnd = new PointF(pLeadRefBasePoint.X + fOffsetX2, pLeadRefBasePoint.Y + fOffsetY2);
                            //    List<PointF> arrPoints = new List<PointF>(); // 0:Top Left, 1: Top Right, 2:Bottom Left, 3:Bottom Right
                            //    arrPoints.Add(new PointF(pStart.X, pStart.Y));
                            //    arrPoints.Add(new PointF(pEnd.X, pStart.Y));
                            //    arrPoints.Add(new PointF(pStart.X, pEnd.Y));
                            //    arrPoints.Add(new PointF(pEnd.X, pEnd.Y));

                            //    m_objMarkTrainROI.LoadROISetting((int)Math.Round(arrPoints[0].X - m_objMarkSearchROI.ref_ROIPositionX), (int)Math.Round(arrPoints[0].Y - m_objMarkSearchROI.ref_ROIPositionY),
                            //        (int)Math.Round(arrPoints[3].X - arrPoints[0].X), (int)Math.Round(arrPoints[2].Y - arrPoints[0].Y));
                            //    //m_objMarkTrainROI.SaveImage("D:\\m_objMarkTrainROI1.bmp");

                            //    PointF pTemp = new PointF();
                            //    //2021-04-07 ZJYEOH : Get Mark inspect ROI points for drawing during display lead image
                            //    Math2.GetNewXYAfterRotate_360deg(m_objMarkTrainROI.ref_ROITotalCenterX,
                            //                                m_objMarkTrainROI.ref_ROITotalCenterY,
                            //                                arrPoints[0],
                            //                                (m_fOrientFinalAngleForLead),
                            //                                ref pTemp);
                            //    m_smVisionInfo.g_pMarkROIDrawing_Lead[0] = pTemp;

                            //    Math2.GetNewXYAfterRotate_360deg(m_objMarkTrainROI.ref_ROITotalCenterX,
                            //                                     m_objMarkTrainROI.ref_ROITotalCenterY,
                            //                                     arrPoints[1],
                            //                                     (m_fOrientFinalAngleForLead),
                            //                                     ref pTemp);
                            //    m_smVisionInfo.g_pMarkROIDrawing_Lead[1] = pTemp;

                            //    Math2.GetNewXYAfterRotate_360deg(m_objMarkTrainROI.ref_ROITotalCenterX,
                            //                                     m_objMarkTrainROI.ref_ROITotalCenterY,
                            //                                     arrPoints[2],
                            //                                     (m_fOrientFinalAngleForLead),
                            //                                     ref pTemp);
                            //    m_smVisionInfo.g_pMarkROIDrawing_Lead[2] = pTemp;

                            //    Math2.GetNewXYAfterRotate_360deg(m_objMarkTrainROI.ref_ROITotalCenterX,
                            //                                     m_objMarkTrainROI.ref_ROITotalCenterY,
                            //                                     arrPoints[3],
                            //                                     (m_fOrientFinalAngleForLead),
                            //                                     ref pTemp);
                            //    m_smVisionInfo.g_pMarkROIDrawing_Lead[3] = pTemp;

                            //    //PointF pTemp = new PointF();
                            //    Math2.GetNewXYAfterRotate_360deg(m_smVisionInfo.g_arrLead[0].ref_fRotateCenterX_ForDrawing,
                            //                                     m_smVisionInfo.g_arrLead[0].ref_fRotateCenterY_ForDrawing,
                            //                                     arrPoints[0],
                            //                                     -(m_fOrientFinalAngleForLead - m_fLeadPatternAngle),
                            //                                     ref pTemp);
                            //    arrPoints[0] = pTemp;

                            //    Math2.GetNewXYAfterRotate_360deg(m_smVisionInfo.g_arrLead[0].ref_fRotateCenterX_ForDrawing,
                            //                                     m_smVisionInfo.g_arrLead[0].ref_fRotateCenterY_ForDrawing,
                            //                                     arrPoints[1],
                            //                                     -(m_fOrientFinalAngleForLead - m_fLeadPatternAngle),
                            //                                     ref pTemp);
                            //    arrPoints[1] = pTemp;

                            //    Math2.GetNewXYAfterRotate_360deg(m_smVisionInfo.g_arrLead[0].ref_fRotateCenterX_ForDrawing,
                            //                                     m_smVisionInfo.g_arrLead[0].ref_fRotateCenterY_ForDrawing,
                            //                                     arrPoints[2],
                            //                                     -(m_fOrientFinalAngleForLead - m_fLeadPatternAngle),
                            //                                     ref pTemp);
                            //    arrPoints[2] = pTemp;

                            //    Math2.GetNewXYAfterRotate_360deg(m_smVisionInfo.g_arrLead[0].ref_fRotateCenterX_ForDrawing,
                            //                                     m_smVisionInfo.g_arrLead[0].ref_fRotateCenterY_ForDrawing,
                            //                                     arrPoints[3],
                            //                                     -(m_fOrientFinalAngleForLead - m_fLeadPatternAngle),
                            //                                     ref pTemp);
                            //    arrPoints[3] = pTemp;

                            //    //2021-04-07 ZJYEOH : Get Mark inspect ROI points for drawing during display lead image
                            //    //m_smVisionInfo.g_pMarkROIDrawing_Lead[0] = arrPoints[0];
                            //    //m_smVisionInfo.g_pMarkROIDrawing_Lead[1] = arrPoints[1];
                            //    //m_smVisionInfo.g_pMarkROIDrawing_Lead[2] = arrPoints[2];
                            //    //m_smVisionInfo.g_pMarkROIDrawing_Lead[3] = arrPoints[3];

                            //    if (m_smVisionInfo.g_blnWhiteOnBlack)
                            //    {
                            //        DontCareWithoutRotateImage.ProduceImage(arrPoints, m_objMarkSearchROI, m_objMarkTrainROI, m_objMarkTestImage
                            //            , m_smVisionInfo.g_objBlackWhiteTopImage, m_smVisionInfo.g_objBlackWhiteRightImage, m_smVisionInfo.g_objBlackWhiteBottomImage, m_smVisionInfo.g_objBlackWhiteLeftImage, false);
                            //    }
                            //    else
                            //    {
                            //        DontCareWithoutRotateImage.ProduceImage(arrPoints, m_objMarkSearchROI, m_objMarkTrainROI, m_objMarkTestImage
                            //            , m_smVisionInfo.g_objBlackWhiteTopImage, m_smVisionInfo.g_objBlackWhiteRightImage, m_smVisionInfo.g_objBlackWhiteBottomImage, m_smVisionInfo.g_objBlackWhiteLeftImage, true);
                            //    }
                          
                            //}
                            #endregion
                            else
                            {
                                if ((m_smCustomizeInfo.g_intWantLead & (1 << m_smVisionInfo.g_intVisionPos)) > 0 && m_smVisionInfo.g_arrLead[0].GetWantInspectLead())
                                    m_smVisionInfo.g_arrRotatedImages[0].CopyTo(ref m_objMarkTestImage);

                                if (m_smVisionInfo.g_fOrientCenterX[intUnitNo] != -1 && m_smVisionInfo.g_fOrientCenterY[intUnitNo] != -1)    // Orient test able to get position
                                {

                                    // 2019 08 16 ZJYEOH : To load the Mark ROI without gauge, the center point cannot use directly from m_smVisionInfo.g_fOrientCenterX[0] as this point is before rotated
                                    float CenterX = (float)(m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROICenterX - m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIPositionX);
                                    float CenterY = (float)(m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROICenterY - m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIPositionY);

                                    float Angle = m_smVisionInfo.g_fOrientAngle[intUnitNo] + (m_intOrientAngle); // this formula is based on clockwise rotation so the angle need to be inverted, 
                                    Angle = -Angle;
                                    float fXAfterRotated = (float)((CenterX) + ((m_smVisionInfo.g_fOrientCenterX[intUnitNo] - CenterX) * Math.Cos(Angle * Math.PI / 180)) - ((m_smVisionInfo.g_fOrientCenterY[intUnitNo] - CenterY) * Math.Sin(Angle * Math.PI / 180)));

                                    float fYAfterRotated = (float)((CenterY) + ((m_smVisionInfo.g_fOrientCenterX[intUnitNo] - CenterX) * Math.Sin(Angle * Math.PI / 180)) + ((m_smVisionInfo.g_fOrientCenterY[intUnitNo] - CenterY) * Math.Cos(Angle * Math.PI / 180)));

                                    m_fCenterX = //m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalX + m_smVisionInfo.g_fOrientCenterX[0] + m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROICenterX - m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROICenterX;
                                    m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROITotalX + fXAfterRotated + m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROICenterX - m_smVisionInfo.g_arrOrientROIs[intUnitNo][1].ref_ROICenterX;
                                    m_fCenterY = //m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalY + m_smVisionInfo.g_fOrientCenterY[0] + m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROICenterY - m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROICenterY;
                                    m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROITotalY + fYAfterRotated + m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROICenterY - m_smVisionInfo.g_arrOrientROIs[intUnitNo][1].ref_ROICenterY;

                                    m_objMarkTrainROI.LoadROISetting((int)fXAfterRotated +                  // Orient Result Object Center X
                                                                    m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROICenterX -      // Mark ROI Center X
                                                                    m_smVisionInfo.g_arrOrientROIs[intUnitNo][1].ref_ROICenterX -    // Orient ROI Center X
                                                                    m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIWidth / 2,     // Half of Mark ROI Size X
                                                                    (int)fYAfterRotated +
                                                                    m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROICenterY -
                                                                    m_smVisionInfo.g_arrOrientROIs[intUnitNo][1].ref_ROICenterY -
                                                                    m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIHeight / 2,
                                                                    m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIWidth, m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIHeight);
                                }
                                else
                                {
                                    m_objMarkTrainROI.LoadROISetting(m_objMarkSearchROI.ref_ROIWidth / 2 -    // Orient ROI Center X
                                                                    m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIWidth / 2,     // Half of Mark ROI Size X
                                                                    m_objMarkSearchROI.ref_ROIHeight / 2 -
                                                                    m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIHeight / 2,
                                                                    m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIWidth, m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIHeight);
                                }
                            }
                        }
                    }
                    else
                    {
                        m_objMarkSearchROI.AttachImage(m_smVisionInfo.g_arrRotatedImages[0]);

                        if (m_blnWantOrientTest && m_blnWantPackageTest)
                        {
                            // Find unit ROI (Train ROI)
                            m_objMarkTrainROI.ref_ROIPositionX = (int)Math.Round(m_smVisionInfo.g_fUnitCenterX[intUnitNo] - (float)m_objMarkTrainROI.ref_ROIWidth / 2, 0, MidpointRounding.AwayFromZero);   // 2018 10 09 - CCENG: change g_fOrientCenterXY to g_fUnitCenterXY because g_fOrientCenter is used to keep Orient matcher result center point, not orient gauge unit center point.
                            m_objMarkTrainROI.ref_ROIPositionY = (int)Math.Round(m_smVisionInfo.g_fUnitCenterY[intUnitNo] - (float)m_objMarkTrainROI.ref_ROIHeight / 2, 0, MidpointRounding.AwayFromZero);
                        }
                    }

                    //2020-11-11 ZJYEOH : Collect ROI Data for later use
                    if (intUnitNo == 1)
                    {
                        m_pMarkTrainROIPoint_Unit2 = new Point(m_objMarkTrainROI.ref_ROITotalX, m_objMarkTrainROI.ref_ROITotalY);
                        m_sMarkTrainROISize_Unit2 = new Size(m_objMarkTrainROI.ref_ROIWidth, m_objMarkTrainROI.ref_ROIHeight);
                    }

                    //2020-11-04 ZJYEOH : Get Mark inspect ROI points for drawing
                    if (intUnitNo == 0)
                    {
                        if (m_smVisionInfo.g_pMarkROIDrawing[0] == new Point(0, 0))
                            m_smVisionInfo.g_pMarkROIDrawing[0] = new Point(m_objMarkTrainROI.ref_ROITotalX, m_objMarkTrainROI.ref_ROITotalY);
                        if (m_smVisionInfo.g_pMarkROIDrawing[1] == new Point(0, 0))
                            m_smVisionInfo.g_pMarkROIDrawing[1] = new Point(m_objMarkTrainROI.ref_ROITotalX + m_objMarkTrainROI.ref_ROIWidth, m_objMarkTrainROI.ref_ROITotalY);
                        if (m_smVisionInfo.g_pMarkROIDrawing[2] == new Point(0, 0))
                            m_smVisionInfo.g_pMarkROIDrawing[2] = new Point(m_objMarkTrainROI.ref_ROITotalX, m_objMarkTrainROI.ref_ROITotalY + m_objMarkTrainROI.ref_ROIHeight);
                        if (m_smVisionInfo.g_pMarkROIDrawing[3] == new Point(0, 0))
                            m_smVisionInfo.g_pMarkROIDrawing[3] = new Point(m_objMarkTrainROI.ref_ROITotalX + m_objMarkTrainROI.ref_ROIWidth, m_objMarkTrainROI.ref_ROITotalY + m_objMarkTrainROI.ref_ROIHeight);
                    }
                    else
                    {
                        if (m_smVisionInfo.g_pMarkROIDrawing2[0] == new Point(0, 0))
                            m_smVisionInfo.g_pMarkROIDrawing2[0] = new Point(m_objMarkTrainROI.ref_ROITotalX, m_objMarkTrainROI.ref_ROITotalY);
                        if (m_smVisionInfo.g_pMarkROIDrawing2[1] == new Point(0, 0))
                            m_smVisionInfo.g_pMarkROIDrawing2[1] = new Point(m_objMarkTrainROI.ref_ROITotalX + m_objMarkTrainROI.ref_ROIWidth, m_objMarkTrainROI.ref_ROITotalY);
                        if (m_smVisionInfo.g_pMarkROIDrawing2[2] == new Point(0, 0))
                            m_smVisionInfo.g_pMarkROIDrawing2[2] = new Point(m_objMarkTrainROI.ref_ROITotalX, m_objMarkTrainROI.ref_ROITotalY + m_objMarkTrainROI.ref_ROIHeight);
                        if (m_smVisionInfo.g_pMarkROIDrawing2[3] == new Point(0, 0))
                            m_smVisionInfo.g_pMarkROIDrawing2[3] = new Point(m_objMarkTrainROI.ref_ROITotalX + m_objMarkTrainROI.ref_ROIWidth, m_objMarkTrainROI.ref_ROITotalY + m_objMarkTrainROI.ref_ROIHeight);
                    }

                    //if (m_smVisionInfo.g_blnWantDontCareArea_Mark)
                    //{
                    //    m_smVisionInfo.g_arrRotatedImages[0].CopyTo(ref m_objMarkTestImage);
                    //    m_objMarkSearchROI.AttachImage(m_objMarkTestImage);
                    //    //ROI objDontCareROI = new ROI();
                    //    //objDontCareROI.LoadROISetting(0, 0, m_objMarkTrainROI.ref_ROIWidth, m_objMarkTrainROI.ref_ROIHeight);
                    //    //objDontCareROI.AttachImage(m_smVisionInfo.g_objDontCareImage_Mark);
                    //    //ROI.SubtractROI(m_objMarkTrainROI, objDontCareROI);
                    //    //objDontCareROI.Dispose();


                    //    //if (m_smVisionInfo.g_blnWantGauge)
                    //    //    m_smVisionInfo.g_arrMarks[intUnitNo].InspectOCVMark_NewMethodForMultiExcessMark_IPM(blnAuto, m_objMarkTestImage, m_objMarkTrainROI, !m_smVisionInfo.g_blnWantGauge, m_smVisionInfo.g_objWhiteImage, m_smVisionInfo.g_objBlackImage);
                    //    //else if (m_smVisionInfo.g_arrMarkROIs[0].Count > 3)    // Mean Unit Surface ROI exist
                    //    //    m_smVisionInfo.g_arrMarks[intUnitNo].InspectOCVMark_NewMethodForMultiExcessMark_IPM(blnAuto, m_objMarkTestImage, m_objMarkTrainROI, !m_smVisionInfo.g_blnWantGauge, m_smVisionInfo.g_objWhiteImage, m_smVisionInfo.g_objBlackImage);
                    //    //else
                    //    //    m_smVisionInfo.g_arrMarks[intUnitNo].InspectOCVMark_NewMethodForMultiExcessMark_IPM(blnAuto, m_objMarkTestImage, m_objMarkTrainROI, !m_smVisionInfo.g_blnWantGauge, m_smVisionInfo.g_objWhiteImage, m_smVisionInfo.g_objBlackImage); //m_objMarkSearchROI

                    //    if (m_smVisionInfo.g_blnWantGauge)
                    //        m_smVisionInfo.g_arrMarks[intUnitNo].InspectOCVMark_NewMethodForMultiExcessMark(blnAuto, m_objMarkTestImage, m_objMarkSearchROI, m_objMarkTrainROI, !m_smVisionInfo.g_blnWantGauge, m_smVisionInfo.g_objWhiteImage, m_smVisionInfo.g_objBlackImage, false, m_smVisionInfo.g_blnWantCheckContourOnMark, m_smVisionInfo.VM_PR_ByPassUnit, m_smVisionInfo.g_intMinMarkScore);
                    //    else if (m_smVisionInfo.g_arrMarkROIs[intUnitNo].Count > 3 && (((m_smCustomizeInfo.g_intWantPositioningIndex & (1 << m_smVisionInfo.g_intVisionPos)) > 0) ||
                    //                ((m_smCustomizeInfo.g_intWantLead & (1 << m_smVisionInfo.g_intVisionPos)) > 0)))    // Mean Unit Surface ROI exist
                    //        m_smVisionInfo.g_arrMarks[intUnitNo].InspectOCVMark_NewMethodForMultiExcessMark(blnAuto, m_objMarkTestImage, m_objMarkSearchROI, m_objMarkTrainROI, !m_smVisionInfo.g_blnWantGauge, m_smVisionInfo.g_objWhiteImage, m_smVisionInfo.g_objBlackImage, false, m_smVisionInfo.g_blnWantCheckContourOnMark, m_smVisionInfo.VM_PR_ByPassUnit, m_smVisionInfo.g_intMinMarkScore);
                    //    else
                    //        m_smVisionInfo.g_arrMarks[intUnitNo].InspectOCVMark_NewMethodForMultiExcessMark(blnAuto, m_objMarkTestImage, m_objMarkSearchROI, m_objMarkTrainROI, !m_smVisionInfo.g_blnWantGauge, m_smVisionInfo.g_objWhiteImage, m_smVisionInfo.g_objBlackImage, false, m_smVisionInfo.g_blnWantCheckContourOnMark, m_smVisionInfo.VM_PR_ByPassUnit, m_smVisionInfo.g_intMinMarkScore); // m_objMarkSearchROI
                    //}
                    //else
                    {
                        //m_objMarkOcvSearchROI.SaveImage("D:\\TS\\m_objMarkOcvSearchROI.bmp");
                        //m_objMarkSearchROI.SaveImage("D:\\TS\\m_objMarkSearchROI.bmp");
                        //m_objMarkTrainROI.SaveImage("D:\\TS\\m_objMarkTrainROI.bmp");

                        PointF pPackageCenterPoint = new PointF(-1, -1);
                        SizeF SPackageSize = new SizeF(-1, -1);
                        float fPackageAngle = 0;
                        if (m_blnWantPackageTest && ((m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailMask & 0x1000) > 0 || m_smVisionInfo.g_arrPackage[intUnitNo].GetWantInspectPackage())) // 2020-06-23 ZJYEOH : If inspection option got tick Check package size just can use pkg gauge
                        {
                            if (intUnitNo == 0)
                            {
                                pPackageCenterPoint = m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint;
                                fPackageAngle = m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle;
                                SPackageSize = new SizeF(m_smVisionInfo.g_objGauge_PkgSize.ref_fRectWidth, m_smVisionInfo.g_objGauge_PkgSize.ref_fRectHeight);
                            }
                            else
                            {
                                pPackageCenterPoint = m_smVisionInfo.g_objGauge_PkgSize2.ref_pRectCenterPoint;
                                fPackageAngle = m_smVisionInfo.g_objGauge_PkgSize2.ref_fRectAngle;
                                SPackageSize = new SizeF(m_smVisionInfo.g_objGauge_PkgSize2.ref_fRectWidth, m_smVisionInfo.g_objGauge_PkgSize2.ref_fRectHeight);
                            }
                        }

                        // 2021-08-25 : Hide this because no more using Lead base point to offset mark ROI
                        //if (m_blnWantLeadTest && (!m_blnWantPackageTest || (m_blnWantPackageTest && ((m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailMask & 0x1000) == 0 && !m_smVisionInfo.g_arrPackage[intUnitNo].GetWantInspectPackage()))) && m_smVisionInfo.g_blnWantUseLeadPointOffsetMarkROI)
                        //{
                        //    ImageDrawing objRotatedPackageImage = m_objMarkTestImage;//m_smVisionInfo.g_arrRotatedImages[0]; //2020-11-03 ZJYEOH : if no package and got lead, then rotatedpackageimage will follow mark Angle
                        //    m_smVisionInfo.g_arrMarks[intUnitNo].InspectOCVMark_NewMethodForMultiExcessMark_OcvAngleAndPackageAngle_Lead(blnAuto,
                        //        ref objRotatedPackageImage,
                        //        m_smVisionInfo.g_objMarkImage,
                        //        m_objMarkOcvSearchROI,
                        //        m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIWidth,
                        //        m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIHeight,
                        //        m_objMarkSearchROI,
                        //        m_objMarkTrainROI,
                        //        !m_smVisionInfo.g_blnWantGauge, m_smVisionInfo.g_objWhiteImage, m_smVisionInfo.g_objBlackImage,
                        //        m_smVisionInfo.g_blnWantCheckNoMark, m_smVisionInfo.g_blnWantCheckContourOnMark, m_smVisionInfo.g_blnWantCheckMarkBroken,//m_smVisionInfo.g_blnWantCheckCharBrokenMark,
                        //        pPackageCenterPoint,
                        //        SPackageSize,
                        //        fPackageAngle,
                        //        m_smVisionInfo.g_arrOrients[intUnitNo][m_smVisionInfo.g_intSelectedOcv[0]].ref_fDegAngleResult,
                        //        m_smVisionInfo.g_intMarkDefectInspectionMethod,
                        //        m_smVisionInfo.g_intMarkInspectionAreaGrayValueSensitivity,
                        //        m_smVisionInfo.g_intMarkBrightSensitivity,
                        //        m_smVisionInfo.VM_PR_ByPassUnit, m_smVisionInfo.g_intMinMarkScore, m_smVisionInfo.g_arrMarkDontCareROIs
                        //        , m_smVisionInfo.g_objBlackWhiteTopImage, m_smVisionInfo.g_objBlackWhiteRightImage, m_smVisionInfo.g_objBlackWhiteBottomImage, m_smVisionInfo.g_objBlackWhiteLeftImage);
                        //}
                        //else
                        {
                            ImageDrawing objRotatedPackageImage = m_smVisionInfo.g_arrRotatedImages[0];
                            m_smVisionInfo.g_arrMarks[intUnitNo].InspectOCVMark_NewMethodForMultiExcessMark_OcvAngleAndPackageAngle(blnAuto,
                                ref objRotatedPackageImage,
                                m_smVisionInfo.g_objMarkImage,
                                m_objMarkOcvSearchROI,
                                m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIWidth,
                                m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIHeight,
                                m_objMarkSearchROI,
                                m_objMarkTrainROI,
                                !m_smVisionInfo.g_blnWantGauge, m_smVisionInfo.g_objWhiteImage, m_smVisionInfo.g_objBlackImage,
                                m_smVisionInfo.g_blnWantCheckNoMark, m_smVisionInfo.g_blnWantCheckContourOnMark, m_smVisionInfo.g_blnWantCheckMarkBroken,//m_smVisionInfo.g_blnWantCheckCharBrokenMark,
                                pPackageCenterPoint,
                                SPackageSize,
                                fPackageAngle,
                                m_smVisionInfo.g_arrOrients[intUnitNo][m_smVisionInfo.g_intSelectedOcv[0]].ref_fDegAngleResult,
                                m_smVisionInfo.g_intMarkDefectInspectionMethod,
                                m_smVisionInfo.g_intMarkInspectionAreaGrayValueSensitivity,
                                m_smVisionInfo.g_intMarkBrightSensitivity,
                                m_smVisionInfo.VM_PR_ByPassUnit, m_smVisionInfo.g_intMinMarkScore,
                                m_arrDontCareLeadAreaStartX, m_arrDontCareLeadAreaStartY, m_arrDontCareLeadAreaEndX, m_arrDontCareLeadAreaEndY, m_arrDontCareLeadDirection, m_smVisionInfo.g_arrMarkDontCareROIs
                                , m_smVisionInfo.g_objBlackWhiteTopImage, m_smVisionInfo.g_objBlackWhiteRightImage, m_smVisionInfo.g_objBlackWhiteBottomImage, m_smVisionInfo.g_objBlackWhiteLeftImage,
                                false, "", ShowLiterationOnly);
                        }

                        //if (m_smVisionInfo.g_blnWantGauge)
                        //    m_smVisionInfo.g_arrMarks[0].InspectOCVMark_NewMethodForMultiExcessMark(blnAuto, m_smVisionInfo.g_arrRotatedImages[0], m_objMarkSearchROI, m_objMarkTrainROI, !m_smVisionInfo.g_blnWantGauge, m_smVisionInfo.g_objWhiteImage, m_smVisionInfo.g_objBlackImage, false, m_smVisionInfo.g_blnWantCheckContourOnMark);
                        //else if (m_smVisionInfo.g_arrMarkROIs[0].Count > 3 && (((m_smCustomizeInfo.g_intWantPositioningIndex & (1 << m_smVisionInfo.g_intVisionPos)) > 0) ||
                        //            ((m_smCustomizeInfo.g_intWantLead & (1 << m_smVisionInfo.g_intVisionPos)) > 0)))    // Mean Unit Surface ROI exist
                        //    m_smVisionInfo.g_arrMarks[0].InspectOCVMark_NewMethodForMultiExcessMark(blnAuto, m_smVisionInfo.g_arrRotatedImages[0], m_objMarkSearchROI, m_objMarkTrainROI, !m_smVisionInfo.g_blnWantGauge, m_smVisionInfo.g_objWhiteImage, m_smVisionInfo.g_objBlackImage, false, m_smVisionInfo.g_blnWantCheckContourOnMark);
                        //else
                        //    m_smVisionInfo.g_arrMarks[0].InspectOCVMark_NewMethodForMultiExcessMark(blnAuto, m_smVisionInfo.g_arrRotatedImages[0], m_objMarkSearchROI, m_objMarkTrainROI, !m_smVisionInfo.g_blnWantGauge, m_smVisionInfo.g_objWhiteImage, m_smVisionInfo.g_objBlackImage, false, m_smVisionInfo.g_blnWantCheckContourOnMark); // m_objMarkSearchROI
                    }


                    // 2020 04 15 - JBTAN: check mark option enable only will set result fail
                    if (m_smVisionInfo.g_arrMarks[intUnitNo].ref_blnCheckMark)
                    {
                        m_smVisionInfo.g_blnMarkInspected = true;
                        m_smVisionInfo.g_blnDrawMarkResult = true;

                        if (m_smVisionInfo.g_arrMarks[intUnitNo].ref_intFailResultMask > 0)
                        {
                            if (blnAuto)
                            {
                                SaveRejectImage_AddToBuffer("Mark", m_smVisionInfo.g_arrMarks[intUnitNo].GetInspectionMessage(intUnitNo, m_smVisionInfo.VM_PR_ByPassUnit, m_smVisionInfo.g_intMinMarkScore, m_smVisionInfo.g_intUnitsOnImage));

                                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 24 g_intMarkFailureTotal=" + m_smVisionInfo.g_intMarkFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                                if (m_smVisionInfo.g_intUnitsOnImage == 1 && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)
                                {
                                    m_smVisionInfo.g_intMarkFailureTotal++;
                                    //m_smVisionInfo.g_intTestedTotal++;
                                    //m_smVisionInfo.g_intLowYieldUnitCount++;
                                    m_blnFailCounterAdded = true;
                                    //m_blnFailCounterAddedForUnit2 = true;
                                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 24a g_intMarkFailureTotal=" + m_smVisionInfo.g_intMarkFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                                }

                                // 17-07-2019 ZJYEOH : Added this condition so that fail counter will increment, when enter this condition means retest pass and current unit fail 
                                if ((intUnitNo == 1 && m_smVisionInfo.g_intUnitsOnImage == 2) && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)
                                {
                                    m_smVisionInfo.g_intMarkFailureTotal++;
                                    //m_smVisionInfo.g_intTestedTotal++;
                                    //m_smVisionInfo.g_intLowYieldUnitCount++;
                                    m_blnFailCounterAdded = true;
                                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 24b g_intMarkFailureTotal=" + m_smVisionInfo.g_intMarkFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                                }

                                //if ((intUnitNo == 1 || m_smVisionInfo.g_intUnitsOnImage == 1) && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)
                                //{
                                //    m_smVisionInfo.g_intMarkFailureTotal++;
                                //    //m_smVisionInfo.g_intTestedTotal++;
                                //    //m_smVisionInfo.g_intLowYieldUnitCount++;
                                //    m_blnFailCounterAdded = true;
                                //    m_blnFailCounterAddedForUnit2 = true;
                                //    //STTrackLog.WriteLine("Fail 24a g_intMarkFailureTotal=" + m_smVisionInfo.g_intMarkFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                                //}

                                //// 17-07-2019 ZJYEOH : Added this condition so that fail counter will increment, when enter this condition means retest pass and current unit fail 
                                //if ((intUnitNo == 0 && m_smVisionInfo.g_intUnitsOnImage == 2) && m_smVisionInfo.g_blnInPocketRetestEnd && (!m_blnFailCounterAdded || m_blnFailCounterAddedForUnit2))
                                //{
                                //    m_smVisionInfo.g_intMarkFailureTotal++;
                                //    //m_smVisionInfo.g_intTestedTotal++;
                                //    //m_smVisionInfo.g_intLowYieldUnitCount++;
                                //    m_blnFailCounterAdded = true;
                                //    //STTrackLog.WriteLine("Fail 24a g_intMarkFailureTotal=" + m_smVisionInfo.g_intMarkFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                                //}
                            }

                            if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                                if (m_intTCPIPResultID == -1)
                                    m_intTCPIPResultID = (int)TCPIPResulID.Fail;//FailMark;

                            m_smVisionInfo.g_strErrorMessage = m_smVisionInfo.g_arrMarks[intUnitNo].GetInspectionMessage(intUnitNo, m_smVisionInfo.VM_PR_ByPassUnit, m_smVisionInfo.g_intMinMarkScore, m_smVisionInfo.g_intUnitsOnImage);
                            return false;
                        }
                    }
                }

                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - A10 ");
                // -------- Check Mark Text Shifted ----------------------------
                // 2019 07 21 - When no gauge during mark test, it is not possible to check Mark Texted Shifted.
                //            - So need to rely on Package Size result to check Mark Text Shifted.
                if (!m_smVisionInfo.g_blnWantGauge)
                {
                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - A11 ");
                    bool blnWantCheckMarkTextShifted = false;
                    if (m_smVisionInfo.g_arrMarks != null && m_smVisionInfo.g_arrMarks.Count > 0)
                    {
                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - A12 ");
                        blnWantCheckMarkTextShifted = m_smVisionInfo.g_arrMarks[intUnitNo].ref_blnCheckMark && m_smVisionInfo.g_arrMarks[intUnitNo].WantCheckMarkTextShifted();
                    }

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - A13 ");
                    if (blnWantCheckMarkTextShifted)
                    {
                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - A14 ");
                        if (intUnitNo == 0)
                        {
                            if (m_bPackageSizePreTestResult1) // Only need to check text shifted if mark result pass, and package size inspection pass
                            {
                                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - A15 ");
                                if (!m_smVisionInfo.g_arrMarks[intUnitNo].CheckTextShifted2(
                                    (int)Math.Round(m_smVisionInfo.g_arrPackage[intUnitNo].ref_fPackageResultCenterX - m_smVisionInfo.g_arrPackage[intUnitNo].ref_fPackageResultWidth_px / 2, 0, MidpointRounding.AwayFromZero),
                                    (int)Math.Round(m_smVisionInfo.g_arrPackage[intUnitNo].ref_fPackageResultCenterY - m_smVisionInfo.g_arrPackage[intUnitNo].ref_fPackageResultHeight_px / 2, 0, MidpointRounding.AwayFromZero),
                                    (int)Math.Round(m_smVisionInfo.g_arrPackage[intUnitNo].ref_fPackageResultCenterX + m_smVisionInfo.g_arrPackage[intUnitNo].ref_fPackageResultWidth_px / 2, 0, MidpointRounding.AwayFromZero),
                                    (int)Math.Round(m_smVisionInfo.g_arrPackage[intUnitNo].ref_fPackageResultCenterY + m_smVisionInfo.g_arrPackage[intUnitNo].ref_fPackageResultHeight_px / 2, 0, MidpointRounding.AwayFromZero)))
                                {
                                    //WaitEventDone(ref m_bPackageSizeTestDone1, true); //2021-03-09 ZJYEOH : No need to wait package result as mark will fail priority, waiting here cause software fall into infinite loop as package also waiting mark done inspection
                                    //if (m_bSubTh_PackageTest_PackageSize_Result)
                                    {
                                        m_smVisionInfo.g_strErrorMessage += "*Mark Shifted";
                                        if (blnAuto)
                                        {
                                            SaveRejectImage_AddToBuffer("Mark", m_smVisionInfo.g_strErrorMessage);

                                            m_smVisionInfo.g_intMarkFailureTotal++;
                                        }
                                    }

                                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                                        if (m_intTCPIPResultID == -1)
                                            m_intTCPIPResultID = (int)TCPIPResulID.Fail;//FailMark;

                                    return false;
                                }
                                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - A16 ");
                            }
                        }
                        else
                        {
                            if (m_bPackageSizePreTestResult2) // Only need to check text shifted if mark result pass, and package size inspection pass
                            {
                                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - A15 ");
                                if (!m_smVisionInfo.g_arrMarks[intUnitNo].CheckTextShifted2(
                                    (int)Math.Round(m_smVisionInfo.g_arrPackage[intUnitNo].ref_fPackageResultCenterX - m_smVisionInfo.g_arrPackage[intUnitNo].ref_fPackageResultWidth_px / 2, 0, MidpointRounding.AwayFromZero),
                                    (int)Math.Round(m_smVisionInfo.g_arrPackage[intUnitNo].ref_fPackageResultCenterY - m_smVisionInfo.g_arrPackage[intUnitNo].ref_fPackageResultHeight_px / 2, 0, MidpointRounding.AwayFromZero),
                                    (int)Math.Round(m_smVisionInfo.g_arrPackage[intUnitNo].ref_fPackageResultCenterX + m_smVisionInfo.g_arrPackage[intUnitNo].ref_fPackageResultWidth_px / 2, 0, MidpointRounding.AwayFromZero),
                                    (int)Math.Round(m_smVisionInfo.g_arrPackage[intUnitNo].ref_fPackageResultCenterY + m_smVisionInfo.g_arrPackage[intUnitNo].ref_fPackageResultHeight_px / 2, 0, MidpointRounding.AwayFromZero)))
                                {
                                    //WaitEventDone(ref m_bPackageSizeTestDone2, true);//2021-03-09 ZJYEOH : No need to wait package result as mark will fail priority, waiting here cause software fall into infinite loop as package also waiting mark done inspection
                                    //if (m_bSubTh_PackageTest_PackageSize_Result2)
                                    {
                                        m_smVisionInfo.g_strErrorMessage += "*Mark Shifted";
                                        if (blnAuto)
                                        {
                                            SaveRejectImage_AddToBuffer("Mark", m_smVisionInfo.g_strErrorMessage);

                                            m_smVisionInfo.g_intMarkFailureTotal++;
                                        }
                                    }

                                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                                        if (m_intTCPIPResultID == -1)
                                            m_intTCPIPResultID = (int)TCPIPResulID.Fail;//FailMark;

                                    return false;
                                }
                                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - A16 ");
                            }
                        }
                    }
                }

                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - A17 ");
                // --------------- End Check Mark Text Shifted ---------------------------------------------

                return true;

            }
            catch (Exception ex)
            {
                //objTL1.WriteLine("Vision4Process StartMarkTest ex: " + ex.ToString());
                return false;
            }
        }
        private bool StartMarkTest_using4LGauge_OcvAngleAndPackageAngle_WithoutRotate(bool blnAuto, int intUnitNo)
        {
            try
            {
                if ((m_smCustomizeInfo.g_intWantMark & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
                {
                    if (m_smVisionInfo.g_arrMarks[intUnitNo].GetNumTemplates() == 0)
                    {
                        // 2020 04 15 - JBTAN: check mark option enable only will set result fail
                        if (m_smVisionInfo.g_arrMarks[intUnitNo].ref_blnCheckMark)
                        {
                            if (m_smVisionInfo.g_intUnitsOnImage == 1)
                                m_smVisionInfo.g_strErrorMessage += "*Unit " + (intUnitNo + 1) + ":*Mark Template Not Found";
                            else
                                m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + ":*Mark Template Not Found";

                            if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 23 g_intMarkFailureTotal=" + m_smVisionInfo.g_intMarkFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());

                            if ((intUnitNo == 1 || m_smVisionInfo.g_intUnitsOnImage == 1) && blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)
                            {
                                m_smVisionInfo.g_intNoTemplateFailureTotal++;
                                //m_smVisionInfo.g_intTestedTotal++;
                                //m_smVisionInfo.g_intLowYieldUnitCount++;
                                m_blnFailCounterAdded = true;

                                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                                    if (m_intTCPIPResultID == -1)
                                        m_intTCPIPResultID = (int)TCPIPResulID.Fail;//FailMark;

                                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 23a g_intMarkFailureTotal=" + m_smVisionInfo.g_intMarkFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                            }
                        }
                        else
                        {
                            // 2020-06-30 ZJYEOH : Just to fix no parameter in package inspection
                            if (m_smVisionInfo.g_arrMarkROIs.Count > intUnitNo)
                            {
                                if (m_smVisionInfo.g_arrMarkROIs[intUnitNo].Count > 0)
                                {
                                    m_objMarkSearchROI = m_smVisionInfo.g_arrMarkROIs[intUnitNo][0];
                                }

                                if (m_objMarkTrainROI == null)
                                    m_objMarkTrainROI = new ROI();
                                m_objMarkTrainROI.AttachImage(m_objMarkSearchROI);
                                if (m_smVisionInfo.g_arrMarkROIs[intUnitNo].Count > 1)
                                {
                                    m_objMarkTrainROI.LoadROISetting(m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIPositionX, m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIPositionY,
                                                                m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIWidth, m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIHeight);
                                }
                            }

                        }
                        return false;
                    }

                    m_arrDontCareLeadAreaStartX.Clear();
                    m_arrDontCareLeadAreaStartY.Clear();
                    m_arrDontCareLeadAreaEndX.Clear();
                    m_arrDontCareLeadAreaEndY.Clear();
                    m_arrDontCareLeadDirection.Clear();

                    m_objMarkSearchROI = m_smVisionInfo.g_arrMarkROIs[intUnitNo][0];
                    if (m_objMarkTrainROI == null)
                        m_objMarkTrainROI = new ROI();
                    m_objMarkTrainROI.AttachImage(m_objMarkSearchROI);
                    m_objMarkTrainROI.LoadROISetting(m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIPositionX, m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIPositionY,
                                               m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIWidth, m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIHeight);

                    if (m_objMarkOcvSearchROI == null)
                        m_objMarkOcvSearchROI = new ROI();
                    m_objMarkOcvSearchROI.AttachImage(m_smVisionInfo.g_objMarkImage);
                    m_objMarkOcvSearchROI.LoadROISetting(m_objMarkSearchROI.ref_ROIPositionX, m_objMarkSearchROI.ref_ROIPositionY,
                                                             m_objMarkSearchROI.ref_ROIWidth, m_objMarkSearchROI.ref_ROIHeight);

                    if (m_smVisionInfo.g_arrOrients[intUnitNo][0].ref_intCorrectAngleMethod == 0)
                    {
                        //no orient check
                        if (((m_smCustomizeInfo.g_intWantOrient & (1 << m_smVisionInfo.g_intVisionPos)) == 0))
                        {
                            //got gauge check
                            if (m_smVisionInfo.g_blnWantGauge)
                            {
                                m_objMarkSearchROI.AttachImage(m_smVisionInfo.g_arrImages[0]);
                                m_smVisionInfo.g_arrMarkGaugeM4L[intUnitNo].Measure_WithDontCareArea(m_smVisionInfo.g_arrImages, m_smVisionInfo.g_objWhiteImage);
                                // Rotate unit to exact 0 degree
                                float fGaugeAngle = m_smVisionInfo.g_arrMarkGaugeM4L[intUnitNo].ref_fRectAngle;

                                //ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[0], m_objMarkSearchROI, fGaugeAngle, m_smVisionInfo.g_intRotationInterpolation_Mark, ref m_smVisionInfo.g_arrRotatedImages, 0);
                                //m_objMarkSearchROI.AttachImage(m_smVisionInfo.g_arrRotatedImages[0]);
                            }
                        }
                        else
                        {
                            // Attach search ROI to rotated image
                            m_objMarkSearchROI.AttachImage(m_smVisionInfo.g_arrImages[0]);

                            // Relocated search roi according the orient gauge measurement object center point.
                            if (m_smVisionInfo.g_blnWantGauge)
                            {
                                if (m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].ref_pRectCenterPoint.X.ToString() != "NaN" && m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].ref_pRectCenterPoint.Y.ToString() != "NaN" &&
                                m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].ref_pRectCenterPoint.X.ToString() != "-NaN" && m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].ref_pRectCenterPoint.Y.ToString() != "-NaN" &&
                                m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].ref_pRectCenterPoint.X.ToString() != "Infinity" && m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].ref_pRectCenterPoint.Y.ToString() != "Infinity" &&
                                m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].ref_pRectCenterPoint.X.ToString() != "-Infinity" && m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].ref_pRectCenterPoint.Y.ToString() != "-Infinity")
                                    m_objMarkSearchROI.LoadROISetting(
                                (int)Math.Round(m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].ref_pRectCenterPoint.X -
                                m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIWidth / 2, 0, MidpointRounding.AwayFromZero),
                                (int)Math.Round(m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].ref_pRectCenterPoint.Y -
                                m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIHeight / 2, 0, MidpointRounding.AwayFromZero),
                                m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIWidth,
                                m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIHeight);
                            }
                        }

                        if (m_smVisionInfo.g_blnWantGauge)
                        {
                            RectGaugeM4L objGauge;
                            if (m_blnWantOrientTest)
                            {
                                objGauge = m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo];
                            }
                            else
                            {
                                objGauge = m_smVisionInfo.g_arrMarkGaugeM4L[intUnitNo];

                                if (m_blnWantPositioning)
                                {
                                    objGauge.SetGaugePlace_BasedOnEdgeROI();

                                    m_objMarkSearchROI.LoadROISetting(
                                        (int)Math.Round(m_smVisionInfo.g_objPositioning.ref_fObjectCenterX -
                                         m_objMarkSearchROI.ref_ROIWidth / 2, 0, MidpointRounding.AwayFromZero),
                                         (int)Math.Round(m_smVisionInfo.g_objPositioning.ref_fObjectCenterY -
                                        m_objMarkSearchROI.ref_ROIHeight / 2, 0, MidpointRounding.AwayFromZero),
                                        m_objMarkSearchROI.ref_ROIWidth,
                                        m_objMarkSearchROI.ref_ROIHeight);
                                }

                                // Measure search roi to get unit center point
                                objGauge.Measure_WithDontCareArea(m_smVisionInfo.g_arrImages, m_objMarkSearchROI, m_smVisionInfo.g_objWhiteImage);
                            }

                            // Get mark gauge measure size
                            int intGaugeWidth = (int)(objGauge.ref_fRectWidth);
                            int intGaugeHeight = (int)(objGauge.ref_fRectHeight);

                            // Get Mark ROI size
                            int intROIWidth = m_objMarkTrainROI.ref_ROIWidth;
                            int intROIHeight = m_objMarkTrainROI.ref_ROIHeight;

                            if (intROIWidth >= intGaugeWidth)
                                intROIWidth -= (intROIWidth - intGaugeWidth) / 2;
                            if (intROIHeight >= intGaugeHeight)
                                intROIHeight -= (intROIHeight - intGaugeHeight) / 2;

                            int intROIOriX = (int)(objGauge.ref_pRectCenterPoint.X - intROIWidth / 2) - m_objMarkSearchROI.ref_ROIPositionX;
                            int intROIOriY = (int)(objGauge.ref_pRectCenterPoint.Y - intROIHeight / 2) - m_objMarkSearchROI.ref_ROIPositionY;


                            // Set train roi start point
                            if ((intROIOriX > 0) &&
                              ((intROIOriX + m_objMarkTrainROI.ref_ROIWidth) <= m_objMarkSearchROI.ref_ROIWidth) &&
                              (intROIOriY > 0) &&
                              ((intROIOriY + m_objMarkTrainROI.ref_ROIHeight) <= m_objMarkSearchROI.ref_ROIHeight))
                            {
                                m_objMarkTrainROI.ref_ROIPositionX = intROIOriX;
                                m_objMarkTrainROI.ref_ROIPositionY = intROIOriY;
                            }
                            else
                            {
                                m_objMarkTrainROI.ref_ROIPositionX = m_objMarkTrainROI.ref_ROIOriPositionX;
                                m_objMarkTrainROI.ref_ROIPositionY = m_objMarkTrainROI.ref_ROIOriPositionY;
                            }
                        }
                        //else if (m_smVisionInfo.g_arrMarkROIs[intUnitNo].Count > 3)    // Mean Unit Surface ROI exist
                        //{
                        //    // Get offset value between Unit Surface ROI and Mark ROI center points
                        //    int intMarkROIOffsetX = m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROICenterX - m_smVisionInfo.g_arrMarkROIs[intUnitNo][3].ref_ROICenterX;
                        //    int intMarkROIOffsetY = m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROICenterY - m_smVisionInfo.g_arrMarkROIs[intUnitNo][3].ref_ROICenterY;

                        //    // Find unit ROI (Train ROI)
                        //    m_objMarkTrainROI.ref_ROIPositionX = (int)Math.Round(m_smVisionInfo.g_fUnitCenterX[intUnitNo] - (float)m_objMarkTrainROI.ref_ROIWidth / 2 + intMarkROIOffsetX, 0, MidpointRounding.AwayFromZero);   // 2018 10 09 - CCENG: change g_fOrientCenterXY to g_fUnitCenterXY because g_fOrientCenter is used to keep Orient matcher result center point, not orient gauge unit center point.
                        //    m_objMarkTrainROI.ref_ROIPositionY = (int)Math.Round(m_smVisionInfo.g_fUnitCenterY[intUnitNo] - (float)m_objMarkTrainROI.ref_ROIHeight / 2 + intMarkROIOffsetY, 0, MidpointRounding.AwayFromZero);
                        //}
                        else //No gauge
                        {
                            /* 2019 07 12 - CCENG: 
                             * No gauge mean dun know where is the unit.
                             * Mark ROI will be relocated according to orient PR result + offset between orient ROI and mark ROI
                             */
                            //if (m_smVisionInfo.g_fOrientCenterX[intUnitNo] != -1 && m_smVisionInfo.g_fOrientCenterY[intUnitNo] != -1)    // Orient test able to get position
                            //{
                            //    // Set Mark Train ROI position to "Orient center + Offset btw Orient ROI and Mark ROI"
                            //    m_objMarkTrainROI.LoadROISetting((int)m_smVisionInfo.g_fOrientCenterX[intUnitNo] +                  // Orient Result Object Center X
                            //                                       m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROICenterX -      // Mark ROI Center X
                            //                                       m_smVisionInfo.g_arrOrientROIs[intUnitNo][1].ref_ROICenterX -    // Orient ROI Center X
                            //                                       m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIWidth / 2,     // Half of Mark ROI Size X
                            //                                       (int)m_smVisionInfo.g_fOrientCenterY[intUnitNo] +
                            //                                       m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROICenterY -
                            //                                       m_smVisionInfo.g_arrOrientROIs[intUnitNo][1].ref_ROICenterY -
                            //                                       m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIHeight / 2,
                            //                                       m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIWidth, m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIHeight);
                            //}
                            //else
                            //{
                            //    // Set Mark Train ROI position to Search ROI center point since cannot find Orient center.
                            //    m_objMarkTrainROI.LoadROISetting(m_objMarkSearchROI.ref_ROIWidth / 2 -
                            //                                       m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIWidth / 2,     // Half of Mark ROI Size X
                            //                                       m_objMarkSearchROI.ref_ROIHeight / 2 -
                            //                                       m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIHeight / 2,
                            //                                       m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIWidth, m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIHeight);
                            //}

                            bool blnUsePackageCenterPoint = false;
                            if (m_blnWantPackageTest && ((m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailMask & 0x1000) > 0 || m_smVisionInfo.g_arrPackage[intUnitNo].GetWantInspectPackage())) // 2020-06-23 ZJYEOH : If inspection option got tick Check package size just can use pkg gauge
                            {
                                if (intUnitNo == 0)
                                {
                                    WaitEventDone(ref m_bPackageSizePreTestDone1, true, 10000, "AAA47");

                                    if (m_bPackageSizePreTestResult1)
                                    {
                                        blnUsePackageCenterPoint = true;
                                    }
                                }
                                else
                                {
                                    WaitEventDone(ref m_bPackageSizePreTestDone2, true, 10000, "AAA48");

                                    if (m_bPackageSizePreTestResult2)
                                    {
                                        blnUsePackageCenterPoint = true;
                                    }
                                }
                            }

                            bool blnUseLeadBaseCenterPoint = false;
                            if (!blnUsePackageCenterPoint)  // if no use package center point, then try use lead base center point
                            {
                                // 2020 12 18 - CCENG: No need check also if ByPassUnit is true.
                                if ((m_smCustomizeInfo.g_intWantLead & (1 << m_smVisionInfo.g_intVisionPos)) > 0 && m_smVisionInfo.g_arrLead[0].GetWantInspectLead() && !m_smVisionInfo.VM_PR_ByPassUnit)
                                {
                                    WaitEventDone(ref m_bLeadBaseCenterPointDone, true, 10000, "AAA49");

                                    if (m_bLeadBaseCenterPointResult)
                                    {
                                        blnUseLeadBaseCenterPoint = true;

                                        m_arrDontCareLeadAreaStartX.Clear();
                                        m_arrDontCareLeadAreaStartY.Clear();
                                        m_arrDontCareLeadAreaEndX.Clear();
                                        m_arrDontCareLeadAreaEndY.Clear();
                                        m_arrDontCareLeadDirection.Clear();

                                        for (int j = 0; j < m_smVisionInfo.g_arrLead.Length; j++)
                                        {
                                            if (m_smVisionInfo.g_arrLead[j].ref_blnSelected)
                                            {
                                                for (int k = 0; k < m_smVisionInfo.g_arrLead[j].ref_intNumberOfLead; k++)
                                                {
                                                    float fStartX = 0, fStartY = 0, fEndX = 0, fEndY = 0;
                                                    int intLeadDirection = 0;
                                                    m_smVisionInfo.g_arrLead[j].GetSampleLeadArea(k,
                                                                                                  m_smVisionInfo.g_arrInspectLeadROI[j].ref_ROITotalX,
                                                                                                  m_smVisionInfo.g_arrInspectLeadROI[j].ref_ROITotalY,
                                                                                                  m_smVisionInfo.g_arrLead[0].ref_fRotateCenterX_ForDrawing,
                                                                                                  m_smVisionInfo.g_arrLead[0].ref_fRotateCenterY_ForDrawing,
                                                                                                   m_fOrientFinalAngleForLead - m_fLeadPatternAngle,
                                                                                                  ref fStartX, ref fStartY, ref fEndX, ref fEndY, ref intLeadDirection);

                                                    m_arrDontCareLeadAreaStartX.Add(fStartX);
                                                    m_arrDontCareLeadAreaStartY.Add(fStartY);
                                                    m_arrDontCareLeadAreaEndX.Add(fEndX);
                                                    m_arrDontCareLeadAreaEndY.Add(fEndY);
                                                    m_arrDontCareLeadDirection.Add(intLeadDirection);
                                                }
                                            }
                                        }

                                    }
                                    else
                                        return true;//2021-09-09 ZJYEOH : Should return true instead of false, so that can fail lead or package 
                                }
                            }

                            if (blnUsePackageCenterPoint)
                            {
                                RectGaugeM4L objGauge;
                                if (intUnitNo == 0)
                                    objGauge = m_smVisionInfo.g_objGauge_PkgSize;
                                else
                                    objGauge = m_smVisionInfo.g_objGauge_PkgSize2;
                                if (m_smVisionInfo.g_fOrientCenterX[intUnitNo] != -1 && m_smVisionInfo.g_fOrientCenterY[intUnitNo] != -1)    // Orient test able to get position
                                {
                                    //// 2019 10 15 - CCENG: Use m_smVisionInfo.g_objGauge_PkgSize measurement center point as rotation center point reference to get mark train roi "0 orient direction and 0 deg" center points.
                                    //float CenterX = (float)(m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X - m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIPositionX);
                                    //float CenterY = (float)(m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y - m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIPositionY);

                                    //float Angle = m_smVisionInfo.g_fOrientAngle[intUnitNo] + (m_intOrientAngle); // this formula is based on clockwise rotation so the angle need to be inverted, 
                                    //Angle = -Angle;
                                    //float fXAfterRotated = (float)((CenterX) + ((m_smVisionInfo.g_fOrientCenterX[intUnitNo] - CenterX) * Math.Cos(Angle * Math.PI / 180)) - ((m_smVisionInfo.g_fOrientCenterY[intUnitNo] - CenterY) * Math.Sin(Angle * Math.PI / 180)));

                                    //float fYAfterRotated = (float)((CenterY) + ((m_smVisionInfo.g_fOrientCenterX[intUnitNo] - CenterX) * Math.Sin(Angle * Math.PI / 180)) + ((m_smVisionInfo.g_fOrientCenterY[intUnitNo] - CenterY) * Math.Cos(Angle * Math.PI / 180)));

                                    //m_fCenterX = //m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalX + m_smVisionInfo.g_fOrientCenterX[0] + m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROICenterX - m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROICenterX;
                                    //m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROITotalX + fXAfterRotated + m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROICenterX - m_smVisionInfo.g_arrOrientROIs[intUnitNo][1].ref_ROICenterX;
                                    //m_fCenterY = //m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalY + m_smVisionInfo.g_fOrientCenterY[0] + m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROICenterY - m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROICenterY;
                                    //m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROITotalY + fYAfterRotated + m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROICenterY - m_smVisionInfo.g_arrOrientROIs[intUnitNo][1].ref_ROICenterY;
                                    ////m_objMarkTrainROI.SaveImage("D:\\TS\\MarkROI.bmp");
                                    m_objMarkTrainROI.LoadROISetting((int)m_smVisionInfo.g_fOrientCenterX[intUnitNo] +                  // Orient Result Object Center X
                                                                    m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROICenterX -      // Mark ROI Center X
                                                                    m_smVisionInfo.g_arrOrientROIs[intUnitNo][1].ref_ROICenterX -    // Orient ROI Center X
                                                                    m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIWidth / 2,     // Half of Mark ROI Size X
                                                                    (int)m_smVisionInfo.g_fOrientCenterY[intUnitNo] +
                                                                    m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROICenterY -
                                                                    m_smVisionInfo.g_arrOrientROIs[intUnitNo][1].ref_ROICenterY -
                                                                    m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIHeight / 2,
                                                                    m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIWidth, m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIHeight);

                                    //m_objMarkTrainROI.SaveImage("D:\\TS\\MarkROI2.bmp");
                                }
                                else
                                {
                                    m_objMarkTrainROI.LoadROISetting(m_objMarkSearchROI.ref_ROIWidth / 2 -    // Orient ROI Center X
                                                                    m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIWidth / 2,     // Half of Mark ROI Size X
                                                                    m_objMarkSearchROI.ref_ROIHeight / 2 -
                                                                    m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIHeight / 2,
                                                                    m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIWidth, m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIHeight);
                                }

                                // // 2019-11-08 ZJYEOH : Limit Mark inspection ROI within package size area, so that extra mark wont happen outside the package size area

                                // if (m_objMarkTrainROI.ref_ROITotalX < (m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X - m_smVisionInfo.g_objGauge_PkgSize.ref_fRectWidth / 2))
                                // {
                                //     m_objMarkTrainROI.LoadROISetting(m_objMarkTrainROI.ref_ROIPositionX + (int)(m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X - m_smVisionInfo.g_objGauge_PkgSize.ref_fRectWidth / 2) - m_objMarkTrainROI.ref_ROITotalX,
                                // m_objMarkTrainROI.ref_ROIPositionY,
                                // m_objMarkTrainROI.ref_ROIWidth - ((int)(m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X - m_smVisionInfo.g_objGauge_PkgSize.ref_fRectWidth / 2) - m_objMarkTrainROI.ref_ROITotalX), m_objMarkTrainROI.ref_ROIHeight);
                                // }

                                // if (m_objMarkTrainROI.ref_ROITotalY < (m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y - m_smVisionInfo.g_objGauge_PkgSize.ref_fRectHeight / 2))
                                // {
                                //     m_objMarkTrainROI.LoadROISetting(m_objMarkTrainROI.ref_ROIPositionX,
                                //m_objMarkTrainROI.ref_ROIPositionY + (int)(m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y - m_smVisionInfo.g_objGauge_PkgSize.ref_fRectHeight / 2) - m_objMarkTrainROI.ref_ROITotalY,
                                // m_objMarkTrainROI.ref_ROIWidth, m_objMarkTrainROI.ref_ROIHeight - ((int)(m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y - m_smVisionInfo.g_objGauge_PkgSize.ref_fRectHeight / 2) - m_objMarkTrainROI.ref_ROITotalY));
                                // }

                                // if (m_objMarkTrainROI.ref_ROITotalY + m_objMarkTrainROI.ref_ROIHeight > (m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y + m_smVisionInfo.g_objGauge_PkgSize.ref_fRectHeight / 2))
                                // {
                                //     m_objMarkTrainROI.LoadROISetting(m_objMarkTrainROI.ref_ROIPositionX, m_objMarkTrainROI.ref_ROIPositionY,
                                // m_objMarkTrainROI.ref_ROIWidth, m_objMarkTrainROI.ref_ROIHeight - (int)(m_objMarkTrainROI.ref_ROITotalY + m_objMarkTrainROI.ref_ROIHeight - (m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y + m_smVisionInfo.g_objGauge_PkgSize.ref_fRectHeight / 2)));
                                // }

                                // if (m_objMarkTrainROI.ref_ROITotalX + m_objMarkTrainROI.ref_ROIWidth > (m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X + m_smVisionInfo.g_objGauge_PkgSize.ref_fRectWidth / 2))
                                // {
                                //     m_objMarkTrainROI.LoadROISetting(m_objMarkTrainROI.ref_ROIPositionX, m_objMarkTrainROI.ref_ROIPositionY,
                                // m_objMarkTrainROI.ref_ROIWidth - (int)(m_objMarkTrainROI.ref_ROITotalX + m_objMarkTrainROI.ref_ROIWidth - (m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X + m_smVisionInfo.g_objGauge_PkgSize.ref_fRectWidth / 2)), m_objMarkTrainROI.ref_ROIHeight);
                                // }
                                
                                int intROITolerance_Top = 0, intROITolerance_Right = 0, intROITolerance_Bottom = 0, intROITolerance_Left = 0;
                                if (m_smVisionInfo.g_blnWhiteOnBlack || !m_smVisionInfo.g_arrPackage[intUnitNo].ref_blnSeperateBrightDarkROITolerance)
                                {
                                    intROITolerance_Top = m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdge;
                                    intROITolerance_Right = m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromRight;
                                    intROITolerance_Bottom = m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromBottom;
                                    intROITolerance_Left = m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeft;
                                }
                                else
                                {
                                    intROITolerance_Top = m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromEdge_Dark;
                                    intROITolerance_Right = m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromRight_Dark;
                                    intROITolerance_Bottom = m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromBottom_Dark;
                                    intROITolerance_Left = m_smVisionInfo.g_arrPackage[intUnitNo].ref_intStartPixelFromLeft_Dark;
                                }

                                float fEdgeLimit = objGauge.ref_pRectCenterPoint.X - objGauge.ref_fRectWidth / 2 + intROITolerance_Left;
                                if (m_objMarkTrainROI.ref_ROITotalX < fEdgeLimit)
                                {
                                    m_objMarkTrainROI.LoadROISetting(m_objMarkTrainROI.ref_ROIPositionX + (int)Math.Round(fEdgeLimit - m_objMarkTrainROI.ref_ROITotalX, 0, MidpointRounding.AwayFromZero),
                                                                     m_objMarkTrainROI.ref_ROIPositionY,
                                                                     m_objMarkTrainROI.ref_ROIWidth - (int)Math.Round(fEdgeLimit - m_objMarkTrainROI.ref_ROITotalX, 0, MidpointRounding.AwayFromZero),
                                                                     m_objMarkTrainROI.ref_ROIHeight);
                                }

                                fEdgeLimit = objGauge.ref_pRectCenterPoint.Y - objGauge.ref_fRectHeight / 2 + intROITolerance_Top;
                                if (m_objMarkTrainROI.ref_ROITotalY < fEdgeLimit)
                                {
                                    m_objMarkTrainROI.LoadROISetting(m_objMarkTrainROI.ref_ROIPositionX,
                                                                     m_objMarkTrainROI.ref_ROIPositionY + (int)Math.Round(fEdgeLimit - m_objMarkTrainROI.ref_ROITotalY, 0, MidpointRounding.AwayFromZero),
                                                                     m_objMarkTrainROI.ref_ROIWidth,
                                                                     m_objMarkTrainROI.ref_ROIHeight - ((int)fEdgeLimit - m_objMarkTrainROI.ref_ROITotalY));
                                }

                                fEdgeLimit = objGauge.ref_pRectCenterPoint.Y + objGauge.ref_fRectHeight / 2 - intROITolerance_Bottom;
                                if (m_objMarkTrainROI.ref_ROITotalY + m_objMarkTrainROI.ref_ROIHeight > fEdgeLimit)
                                {
                                    m_objMarkTrainROI.LoadROISetting(m_objMarkTrainROI.ref_ROIPositionX, m_objMarkTrainROI.ref_ROIPositionY,
                                                                     m_objMarkTrainROI.ref_ROIWidth,
                                                                     m_objMarkTrainROI.ref_ROIHeight - (int)Math.Round(m_objMarkTrainROI.ref_ROITotalY + m_objMarkTrainROI.ref_ROIHeight - fEdgeLimit, 0, MidpointRounding.AwayFromZero));
                                }

                                fEdgeLimit = objGauge.ref_pRectCenterPoint.X + objGauge.ref_fRectWidth / 2 - intROITolerance_Right;
                                if (m_objMarkTrainROI.ref_ROITotalX + m_objMarkTrainROI.ref_ROIWidth > fEdgeLimit)
                                {
                                    m_objMarkTrainROI.LoadROISetting(m_objMarkTrainROI.ref_ROIPositionX,
                                                                     m_objMarkTrainROI.ref_ROIPositionY,
                                                                     m_objMarkTrainROI.ref_ROIWidth - (int)Math.Round(m_objMarkTrainROI.ref_ROITotalX + m_objMarkTrainROI.ref_ROIWidth - fEdgeLimit, 0, MidpointRounding.AwayFromZero),
                                                                     m_objMarkTrainROI.ref_ROIHeight);
                                }
                            
                                m_smVisionInfo.g_arrImages[0].CopyTo(ref m_objMarkTestImage);
                                m_objMarkSearchROI.AttachImage(m_objMarkTestImage);

                                PointF pStart = new PointF(m_objMarkTrainROI.ref_ROITotalX, m_objMarkTrainROI.ref_ROITotalY);
                                PointF pEnd = new PointF(m_objMarkTrainROI.ref_ROITotalX + m_objMarkTrainROI.ref_ROIWidth, m_objMarkTrainROI.ref_ROITotalY + m_objMarkTrainROI.ref_ROIHeight);
                                List<PointF> arrPoints = new List<PointF>(); // 0:Top Left, 1: Top Right, 2:Bottom Left, 3:Bottom Right
                                arrPoints.Add(new PointF(pStart.X, pStart.Y));
                                arrPoints.Add(new PointF(pEnd.X, pStart.Y));
                                arrPoints.Add(new PointF(pStart.X, pEnd.Y));
                                arrPoints.Add(new PointF(pEnd.X, pEnd.Y));

                                //m_objMarkTrainROI.SaveImage("D:\\m_objMarkTrainROI1.bmp");

                                PointF pTemp = new PointF();
                                Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2,
                                                                 (pEnd.Y + pStart.Y) / 2,
                                                                 arrPoints[0],
                                                                 (objGauge.ref_fRectAngle + (m_intOrientAngle)),
                                                                 ref pTemp);
                                arrPoints[0] = pTemp;

                                Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2,
                                                                 (pEnd.Y + pStart.Y) / 2,
                                                                 arrPoints[1],
                                                                 (objGauge.ref_fRectAngle + (m_intOrientAngle)),
                                                                 ref pTemp);
                                arrPoints[1] = pTemp;

                                Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2,
                                                                 (pEnd.Y + pStart.Y) / 2,
                                                                 arrPoints[2],
                                                                 (objGauge.ref_fRectAngle + (m_intOrientAngle)),
                                                                 ref pTemp);
                                arrPoints[2] = pTemp;

                                Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2,
                                                                 (pEnd.Y + pStart.Y) / 2,
                                                                 arrPoints[3],
                                                                 (objGauge.ref_fRectAngle + (m_intOrientAngle)),
                                                                 ref pTemp);
                                arrPoints[3] = pTemp;

                                //2020-11-04 ZJYEOH : Get Mark inspect ROI points for drawing
                                if (intUnitNo == 0)
                                {
                                    m_smVisionInfo.g_pMarkROIDrawing[0] = arrPoints[0];// new PointF(m_objMarkSearchROI.ref_ROIPositionX + arrPoints[0].X, m_objMarkSearchROI.ref_ROIPositionY + arrPoints[0].Y);
                                    m_smVisionInfo.g_pMarkROIDrawing[1] = arrPoints[1];//new PointF(m_objMarkSearchROI.ref_ROIPositionX + arrPoints[1].X, m_objMarkSearchROI.ref_ROIPositionY + arrPoints[1].Y);
                                    m_smVisionInfo.g_pMarkROIDrawing[2] = arrPoints[2];//new PointF(m_objMarkSearchROI.ref_ROIPositionX + arrPoints[2].X, m_objMarkSearchROI.ref_ROIPositionY + arrPoints[2].Y);
                                    m_smVisionInfo.g_pMarkROIDrawing[3] = arrPoints[3];//new PointF(m_objMarkSearchROI.ref_ROIPositionX + arrPoints[3].X, m_objMarkSearchROI.ref_ROIPositionY + arrPoints[3].Y);
                                }
                                else
                                {
                                    m_smVisionInfo.g_pMarkROIDrawing2[0] = arrPoints[0];// new PointF(m_objMarkSearchROI.ref_ROIPositionX + arrPoints[0].X, m_objMarkSearchROI.ref_ROIPositionY + arrPoints[0].Y);
                                    m_smVisionInfo.g_pMarkROIDrawing2[1] = arrPoints[1];//new PointF(m_objMarkSearchROI.ref_ROIPositionX + arrPoints[1].X, m_objMarkSearchROI.ref_ROIPositionY + arrPoints[1].Y);
                                    m_smVisionInfo.g_pMarkROIDrawing2[2] = arrPoints[2];//new PointF(m_objMarkSearchROI.ref_ROIPositionX + arrPoints[2].X, m_objMarkSearchROI.ref_ROIPositionY + arrPoints[2].Y);
                                    m_smVisionInfo.g_pMarkROIDrawing2[3] = arrPoints[3];//new PointF(m_objMarkSearchROI.ref_ROIPositionX + arrPoints[3].X, m_objMarkSearchROI.ref_ROIPositionY + arrPoints[3].Y);
                                }

                                if (m_smVisionInfo.g_blnWhiteOnBlack)
                                {
                                    DontCareWithoutRotateImage.ProduceImage(arrPoints, m_objMarkSearchROI, m_objMarkTrainROI, m_objMarkTestImage
                                    , m_smVisionInfo.g_objBlackWhiteTopImage, m_smVisionInfo.g_objBlackWhiteRightImage, m_smVisionInfo.g_objBlackWhiteBottomImage, m_smVisionInfo.g_objBlackWhiteLeftImage, false);
                                }
                                else
                                {
                                    DontCareWithoutRotateImage.ProduceImage(arrPoints, m_objMarkSearchROI, m_objMarkTrainROI, m_objMarkTestImage
                                    , m_smVisionInfo.g_objBlackWhiteTopImage, m_smVisionInfo.g_objBlackWhiteRightImage, m_smVisionInfo.g_objBlackWhiteBottomImage, m_smVisionInfo.g_objBlackWhiteLeftImage, true);
                                }

                            }
                            #region 2021-08-25 : Hide this because no more using Lead base point to offset mark ROI
                            //else if (blnUseLeadBaseCenterPoint && m_blnWantLeadTest && (!m_blnWantPackageTest || (m_blnWantPackageTest && ((m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailMask & 0x1000) == 0 && !m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetWantInspectPackage()))) && m_smVisionInfo.g_blnWantUseLeadPointOffsetMarkROI)
                            //{
                            //    m_smVisionInfo.g_arrRotatedImages[0].CopyTo(ref m_objMarkTestImage);
                            //    m_objMarkSearchROI.AttachImage(m_objMarkTestImage);

                            //    PointF pLeadRefBasePoint = new PointF();
                            //    if (m_smVisionInfo.g_arrLead[1].ref_blnSelected && m_smVisionInfo.g_arrLead[3].ref_blnSelected)
                            //    {
                            //        pLeadRefBasePoint = m_smVisionInfo.g_arrLead[1].GetSampleLeadBaseCenterPoint(false);

                            //        pLeadRefBasePoint = new PointF(m_smVisionInfo.g_arrInspectLeadROI[1].ref_ROITotalX + pLeadRefBasePoint.X,
                            //                                       m_smVisionInfo.g_arrInspectLeadROI[1].ref_ROITotalY + pLeadRefBasePoint.Y);
                            //    }
                            //    else if (m_smVisionInfo.g_arrLead[2].ref_blnSelected && m_smVisionInfo.g_arrLead[4].ref_blnSelected)
                            //    {
                            //        pLeadRefBasePoint = m_smVisionInfo.g_arrLead[4].GetSampleLeadBaseCenterPoint(true);
                            //        pLeadRefBasePoint = new PointF(m_smVisionInfo.g_arrInspectLeadROI[4].ref_ROITotalX + pLeadRefBasePoint.X,
                            //                                       m_smVisionInfo.g_arrInspectLeadROI[4].ref_ROITotalY + pLeadRefBasePoint.Y);
                            //    }

                            //    //float fOffsetX1 = -60;
                            //    //float fOffsetY1 = 30;
                            //    //float fOffsetX2 = 300;
                            //    //float fOffsetY2 = 180;
                            //    float fOffsetX1 = m_smVisionInfo.g_arrMarks[0].ref_intMarkROIOffsetLeft;
                            //    float fOffsetY1 = m_smVisionInfo.g_arrMarks[0].ref_intMarkROIOffsetTop;
                            //    float fOffsetX2 = m_smVisionInfo.g_arrMarks[0].ref_intMarkROIOffsetRight;
                            //    float fOffsetY2 = m_smVisionInfo.g_arrMarks[0].ref_intMarkROIOffsetBottom;
                            //    PointF pStart = new PointF(pLeadRefBasePoint.X + fOffsetX1, pLeadRefBasePoint.Y + fOffsetY1);
                            //    PointF pEnd = new PointF(pLeadRefBasePoint.X + fOffsetX2, pLeadRefBasePoint.Y + fOffsetY2);
                            //    List<PointF> arrPoints = new List<PointF>(); // 0:Top Left, 1: Top Right, 2:Bottom Left, 3:Bottom Right
                            //    arrPoints.Add(new PointF(pStart.X, pStart.Y));
                            //    arrPoints.Add(new PointF(pEnd.X, pStart.Y));
                            //    arrPoints.Add(new PointF(pStart.X, pEnd.Y));
                            //    arrPoints.Add(new PointF(pEnd.X, pEnd.Y));

                            //    m_objMarkTrainROI.LoadROISetting((int)Math.Round(arrPoints[0].X - m_objMarkSearchROI.ref_ROIPositionX), (int)Math.Round(arrPoints[0].Y - m_objMarkSearchROI.ref_ROIPositionY),
                            //        (int)Math.Round(arrPoints[3].X - arrPoints[0].X), (int)Math.Round(arrPoints[2].Y - arrPoints[0].Y));
                            //    //m_objMarkTrainROI.SaveImage("D:\\m_objMarkTrainROI1.bmp");

                            //    PointF pTemp = new PointF();
                            //    Math2.GetNewXYAfterRotate_360deg(m_smVisionInfo.g_arrLead[0].ref_fRotateCenterX_ForDrawing,
                            //                                     m_smVisionInfo.g_arrLead[0].ref_fRotateCenterY_ForDrawing,
                            //                                     arrPoints[0],
                            //                                     -(m_fOrientFinalAngleForLead - m_fLeadPatternAngle),
                            //                                     ref pTemp);
                            //    arrPoints[0] = pTemp;

                            //    Math2.GetNewXYAfterRotate_360deg(m_smVisionInfo.g_arrLead[0].ref_fRotateCenterX_ForDrawing,
                            //                                     m_smVisionInfo.g_arrLead[0].ref_fRotateCenterY_ForDrawing,
                            //                                     arrPoints[1],
                            //                                     -(m_fOrientFinalAngleForLead - m_fLeadPatternAngle),
                            //                                     ref pTemp);
                            //    arrPoints[1] = pTemp;

                            //    Math2.GetNewXYAfterRotate_360deg(m_smVisionInfo.g_arrLead[0].ref_fRotateCenterX_ForDrawing,
                            //                                     m_smVisionInfo.g_arrLead[0].ref_fRotateCenterY_ForDrawing,
                            //                                     arrPoints[2],
                            //                                     -(m_fOrientFinalAngleForLead - m_fLeadPatternAngle),
                            //                                     ref pTemp);
                            //    arrPoints[2] = pTemp;

                            //    Math2.GetNewXYAfterRotate_360deg(m_smVisionInfo.g_arrLead[0].ref_fRotateCenterX_ForDrawing,
                            //                                     m_smVisionInfo.g_arrLead[0].ref_fRotateCenterY_ForDrawing,
                            //                                     arrPoints[3],
                            //                                     -(m_fOrientFinalAngleForLead - m_fLeadPatternAngle),
                            //                                     ref pTemp);
                            //    arrPoints[3] = pTemp;

                            //    //2021-04-07 ZJYEOH : Get Mark inspect ROI points for drawing during display lead image
                            //    m_smVisionInfo.g_pMarkROIDrawing_Lead[0] = arrPoints[0];
                            //    m_smVisionInfo.g_pMarkROIDrawing_Lead[1] = arrPoints[1];
                            //    m_smVisionInfo.g_pMarkROIDrawing_Lead[2] = arrPoints[2];
                            //    m_smVisionInfo.g_pMarkROIDrawing_Lead[3] = arrPoints[3];

                            //    ////2020-11-04 ZJYEOH : Get Mark inspect ROI points for drawing
                            //    //if (intUnitNo == 0)
                            //    //{
                            //    //    m_smVisionInfo.g_pMarkROIDrawing[0] = arrPoints[0];
                            //    //    m_smVisionInfo.g_pMarkROIDrawing[1] = arrPoints[1];
                            //    //    m_smVisionInfo.g_pMarkROIDrawing[2] = arrPoints[2];
                            //    //    m_smVisionInfo.g_pMarkROIDrawing[3] = arrPoints[3];
                            //    //}
                            //    //else
                            //    //{
                            //    //    m_smVisionInfo.g_pMarkROIDrawing2[0] = arrPoints[0];
                            //    //    m_smVisionInfo.g_pMarkROIDrawing2[1] = arrPoints[1];
                            //    //    m_smVisionInfo.g_pMarkROIDrawing2[2] = arrPoints[2];
                            //    //    m_smVisionInfo.g_pMarkROIDrawing2[3] = arrPoints[3];
                            //    //}

                            //    if (m_smVisionInfo.g_blnWhiteOnBlack)
                            //    {
                            //        DontCareWithoutRotateImage.ProduceImage(arrPoints, m_objMarkSearchROI, m_objMarkTrainROI, m_objMarkTestImage
                            //        , m_smVisionInfo.g_objBlackWhiteTopImage, m_smVisionInfo.g_objBlackWhiteRightImage, m_smVisionInfo.g_objBlackWhiteBottomImage, m_smVisionInfo.g_objBlackWhiteLeftImage, false);
                            //    }
                            //    else
                            //    {
                            //        DontCareWithoutRotateImage.ProduceImage(arrPoints, m_objMarkSearchROI, m_objMarkTrainROI, m_objMarkTestImage
                            //        , m_smVisionInfo.g_objBlackWhiteTopImage, m_smVisionInfo.g_objBlackWhiteRightImage, m_smVisionInfo.g_objBlackWhiteBottomImage, m_smVisionInfo.g_objBlackWhiteLeftImage, true);
                            //    }

                            //}
                            #endregion
                            else
                            {
                                if (m_smVisionInfo.g_fOrientCenterX[intUnitNo] != -1 && m_smVisionInfo.g_fOrientCenterY[intUnitNo] != -1)    // Orient test able to get position
                                {

                                    //// 2019 08 16 ZJYEOH : To load the Mark ROI without gauge, the center point cannot use directly from m_smVisionInfo.g_fOrientCenterX[0] as this point is before rotated
                                    //float CenterX = (float)(m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROICenterX - m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIPositionX);
                                    //float CenterY = (float)(m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROICenterY - m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIPositionY);

                                    //float Angle = m_smVisionInfo.g_fOrientAngle[intUnitNo] + (m_intOrientAngle); // this formula is based on clockwise rotation so the angle need to be inverted, 
                                    //Angle = -Angle;
                                    //float fXAfterRotated = (float)((CenterX) + ((m_smVisionInfo.g_fOrientCenterX[intUnitNo] - CenterX) * Math.Cos(Angle * Math.PI / 180)) - ((m_smVisionInfo.g_fOrientCenterY[intUnitNo] - CenterY) * Math.Sin(Angle * Math.PI / 180)));

                                    //float fYAfterRotated = (float)((CenterY) + ((m_smVisionInfo.g_fOrientCenterX[intUnitNo] - CenterX) * Math.Sin(Angle * Math.PI / 180)) + ((m_smVisionInfo.g_fOrientCenterY[intUnitNo] - CenterY) * Math.Cos(Angle * Math.PI / 180)));

                                    //m_fCenterX = //m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalX + m_smVisionInfo.g_fOrientCenterX[0] + m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROICenterX - m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROICenterX;
                                    //m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROITotalX + fXAfterRotated + m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROICenterX - m_smVisionInfo.g_arrOrientROIs[intUnitNo][1].ref_ROICenterX;
                                    //m_fCenterY = //m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalY + m_smVisionInfo.g_fOrientCenterY[0] + m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROICenterY - m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROICenterY;
                                    //m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROITotalY + fYAfterRotated + m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROICenterY - m_smVisionInfo.g_arrOrientROIs[intUnitNo][1].ref_ROICenterY;

                                    m_objMarkTrainROI.LoadROISetting((int)m_smVisionInfo.g_fOrientCenterX[intUnitNo] +                  // Orient Result Object Center X
                                                                    m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROICenterX -      // Mark ROI Center X
                                                                    m_smVisionInfo.g_arrOrientROIs[intUnitNo][1].ref_ROICenterX -    // Orient ROI Center X
                                                                    m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIWidth / 2,     // Half of Mark ROI Size X
                                                                    (int)m_smVisionInfo.g_fOrientCenterY[intUnitNo] +
                                                                    m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROICenterY -
                                                                    m_smVisionInfo.g_arrOrientROIs[intUnitNo][1].ref_ROICenterY -
                                                                    m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIHeight / 2,
                                                                    m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIWidth, m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIHeight);
                                }
                                else
                                {
                                    m_objMarkTrainROI.LoadROISetting(m_objMarkSearchROI.ref_ROIWidth / 2 -    // Orient ROI Center X
                                                                    m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIWidth / 2,     // Half of Mark ROI Size X
                                                                    m_objMarkSearchROI.ref_ROIHeight / 2 -
                                                                    m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIHeight / 2,
                                                                    m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIWidth, m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIHeight);
                                }

                                m_smVisionInfo.g_arrImages[0].CopyTo(ref m_objMarkTestImage);
                                m_objMarkSearchROI.AttachImage(m_objMarkTestImage);
                                
                                PointF pStart = new PointF(m_objMarkTrainROI.ref_ROITotalX, m_objMarkTrainROI.ref_ROITotalY);
                                PointF pEnd = new PointF(m_objMarkTrainROI.ref_ROITotalX + m_objMarkTrainROI.ref_ROIWidth, m_objMarkTrainROI.ref_ROITotalY + m_objMarkTrainROI.ref_ROIHeight);
                                List<PointF> arrPoints = new List<PointF>(); // 0:Top Left, 1: Top Right, 2:Bottom Left, 3:Bottom Right
                                arrPoints.Add(new PointF(pStart.X, pStart.Y));
                                arrPoints.Add(new PointF(pEnd.X, pStart.Y));
                                arrPoints.Add(new PointF(pStart.X, pEnd.Y));
                                arrPoints.Add(new PointF(pEnd.X, pEnd.Y));

                                //m_objMarkTrainROI.SaveImage("D:\\m_objMarkTrainROI1.bmp");

                                PointF pTemp = new PointF();
                                Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2,
                                                                 (pEnd.Y + pStart.Y) / 2,
                                                                 arrPoints[0],
                                                                 (m_smVisionInfo.g_fOrientAngle[intUnitNo] + (m_intOrientAngle)),
                                                                 ref pTemp);
                                arrPoints[0] = pTemp;

                                Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2,
                                                                 (pEnd.Y + pStart.Y) / 2,
                                                                 arrPoints[1],
                                                                 (m_smVisionInfo.g_fOrientAngle[intUnitNo] + (m_intOrientAngle)),
                                                                 ref pTemp);
                                arrPoints[1] = pTemp;

                                Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2,
                                                                 (pEnd.Y + pStart.Y) / 2,
                                                                 arrPoints[2],
                                                                 (m_smVisionInfo.g_fOrientAngle[intUnitNo] + (m_intOrientAngle)),
                                                                 ref pTemp);
                                arrPoints[2] = pTemp;

                                Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2,
                                                                 (pEnd.Y + pStart.Y) / 2,
                                                                 arrPoints[3],
                                                                 (m_smVisionInfo.g_fOrientAngle[intUnitNo] + (m_intOrientAngle)),
                                                                 ref pTemp);
                                arrPoints[3] = pTemp;

                                //2020-11-04 ZJYEOH : Get Mark inspect ROI points for drawing
                                if (intUnitNo == 0)
                                {
                                    m_smVisionInfo.g_pMarkROIDrawing[0] = arrPoints[0];// new PointF(m_objMarkSearchROI.ref_ROIPositionX + arrPoints[0].X, m_objMarkSearchROI.ref_ROIPositionY + arrPoints[0].Y);
                                    m_smVisionInfo.g_pMarkROIDrawing[1] = arrPoints[1];//new PointF(m_objMarkSearchROI.ref_ROIPositionX + arrPoints[1].X, m_objMarkSearchROI.ref_ROIPositionY + arrPoints[1].Y);
                                    m_smVisionInfo.g_pMarkROIDrawing[2] = arrPoints[2];//new PointF(m_objMarkSearchROI.ref_ROIPositionX + arrPoints[2].X, m_objMarkSearchROI.ref_ROIPositionY + arrPoints[2].Y);
                                    m_smVisionInfo.g_pMarkROIDrawing[3] = arrPoints[3];//new PointF(m_objMarkSearchROI.ref_ROIPositionX + arrPoints[3].X, m_objMarkSearchROI.ref_ROIPositionY + arrPoints[3].Y);
                                }
                                else
                                {
                                    m_smVisionInfo.g_pMarkROIDrawing2[0] = arrPoints[0];// new PointF(m_objMarkSearchROI.ref_ROIPositionX + arrPoints[0].X, m_objMarkSearchROI.ref_ROIPositionY + arrPoints[0].Y);
                                    m_smVisionInfo.g_pMarkROIDrawing2[1] = arrPoints[1];//new PointF(m_objMarkSearchROI.ref_ROIPositionX + arrPoints[1].X, m_objMarkSearchROI.ref_ROIPositionY + arrPoints[1].Y);
                                    m_smVisionInfo.g_pMarkROIDrawing2[2] = arrPoints[2];//new PointF(m_objMarkSearchROI.ref_ROIPositionX + arrPoints[2].X, m_objMarkSearchROI.ref_ROIPositionY + arrPoints[2].Y);
                                    m_smVisionInfo.g_pMarkROIDrawing2[3] = arrPoints[3];//new PointF(m_objMarkSearchROI.ref_ROIPositionX + arrPoints[3].X, m_objMarkSearchROI.ref_ROIPositionY + arrPoints[3].Y);
                                }

                                if (m_smVisionInfo.g_blnWhiteOnBlack)
                                {
                                    DontCareWithoutRotateImage.ProduceImage(arrPoints, m_objMarkSearchROI, m_objMarkTrainROI, m_objMarkTestImage
                                    , m_smVisionInfo.g_objBlackWhiteTopImage, m_smVisionInfo.g_objBlackWhiteRightImage, m_smVisionInfo.g_objBlackWhiteBottomImage, m_smVisionInfo.g_objBlackWhiteLeftImage, false);
                                }
                                else
                                {
                                    DontCareWithoutRotateImage.ProduceImage(arrPoints, m_objMarkSearchROI, m_objMarkTrainROI, m_objMarkTestImage
                                    , m_smVisionInfo.g_objBlackWhiteTopImage, m_smVisionInfo.g_objBlackWhiteRightImage, m_smVisionInfo.g_objBlackWhiteBottomImage, m_smVisionInfo.g_objBlackWhiteLeftImage, true);
                                }

                            }
                        }
                    }
                    else
                    {
                        m_objMarkSearchROI.AttachImage(m_smVisionInfo.g_arrImages[0]);

                        if (m_blnWantOrientTest && m_blnWantPackageTest)
                        {
                            // Find unit ROI (Train ROI)
                            m_objMarkTrainROI.ref_ROIPositionX = (int)Math.Round(m_smVisionInfo.g_fUnitCenterX[intUnitNo] - (float)m_objMarkTrainROI.ref_ROIWidth / 2, 0, MidpointRounding.AwayFromZero);   // 2018 10 09 - CCENG: change g_fOrientCenterXY to g_fUnitCenterXY because g_fOrientCenter is used to keep Orient matcher result center point, not orient gauge unit center point.
                            m_objMarkTrainROI.ref_ROIPositionY = (int)Math.Round(m_smVisionInfo.g_fUnitCenterY[intUnitNo] - (float)m_objMarkTrainROI.ref_ROIHeight / 2, 0, MidpointRounding.AwayFromZero);
                        }
                    }

                    //2020-11-11 ZJYEOH : Collect ROI Data for later use
                    if (intUnitNo == 1)
                    {
                        m_pMarkTrainROIPoint_Unit2 = new Point(m_objMarkTrainROI.ref_ROITotalX, m_objMarkTrainROI.ref_ROITotalY);
                        m_sMarkTrainROISize_Unit2 = new Size(m_objMarkTrainROI.ref_ROIWidth, m_objMarkTrainROI.ref_ROIHeight);
                    }

                    //2020-11-04 ZJYEOH : Get Mark inspect ROI points for drawing
                    if (intUnitNo == 0)
                    {
                        if (m_smVisionInfo.g_pMarkROIDrawing[0] == new Point(0, 0))
                            m_smVisionInfo.g_pMarkROIDrawing[0] = new Point(m_objMarkTrainROI.ref_ROITotalX, m_objMarkTrainROI.ref_ROITotalY);
                        if (m_smVisionInfo.g_pMarkROIDrawing[1] == new Point(0, 0))
                            m_smVisionInfo.g_pMarkROIDrawing[1] = new Point(m_objMarkTrainROI.ref_ROITotalX + m_objMarkTrainROI.ref_ROIWidth, m_objMarkTrainROI.ref_ROITotalY);
                        if (m_smVisionInfo.g_pMarkROIDrawing[2] == new Point(0, 0))
                            m_smVisionInfo.g_pMarkROIDrawing[2] = new Point(m_objMarkTrainROI.ref_ROITotalX, m_objMarkTrainROI.ref_ROITotalY + m_objMarkTrainROI.ref_ROIHeight);
                        if (m_smVisionInfo.g_pMarkROIDrawing[3] == new Point(0, 0))
                            m_smVisionInfo.g_pMarkROIDrawing[3] = new Point(m_objMarkTrainROI.ref_ROITotalX + m_objMarkTrainROI.ref_ROIWidth, m_objMarkTrainROI.ref_ROITotalY + m_objMarkTrainROI.ref_ROIHeight);
                    }
                    else
                    {
                        if (m_smVisionInfo.g_pMarkROIDrawing2[0] == new Point(0, 0))
                            m_smVisionInfo.g_pMarkROIDrawing2[0] = new Point(m_objMarkTrainROI.ref_ROITotalX, m_objMarkTrainROI.ref_ROITotalY);
                        if (m_smVisionInfo.g_pMarkROIDrawing2[1] == new Point(0, 0))
                            m_smVisionInfo.g_pMarkROIDrawing2[1] = new Point(m_objMarkTrainROI.ref_ROITotalX + m_objMarkTrainROI.ref_ROIWidth, m_objMarkTrainROI.ref_ROITotalY);
                        if (m_smVisionInfo.g_pMarkROIDrawing2[2] == new Point(0, 0))
                            m_smVisionInfo.g_pMarkROIDrawing2[2] = new Point(m_objMarkTrainROI.ref_ROITotalX, m_objMarkTrainROI.ref_ROITotalY + m_objMarkTrainROI.ref_ROIHeight);
                        if (m_smVisionInfo.g_pMarkROIDrawing2[3] == new Point(0, 0))
                            m_smVisionInfo.g_pMarkROIDrawing2[3] = new Point(m_objMarkTrainROI.ref_ROITotalX + m_objMarkTrainROI.ref_ROIWidth, m_objMarkTrainROI.ref_ROITotalY + m_objMarkTrainROI.ref_ROIHeight);
                    }

                    //if (m_smVisionInfo.g_blnWantDontCareArea_Mark)
                    //{
                    //    m_smVisionInfo.g_arrImages[0].CopyTo(ref m_objMarkTestImage);
                    //    m_objMarkSearchROI.AttachImage(m_objMarkTestImage);
                    //    //ROI objDontCareROI = new ROI();
                    //    //objDontCareROI.LoadROISetting(0, 0, m_objMarkTrainROI.ref_ROIWidth, m_objMarkTrainROI.ref_ROIHeight);
                    //    //objDontCareROI.AttachImage(m_smVisionInfo.g_objDontCareImage_Mark);
                    //    //ROI.SubtractROI(m_objMarkTrainROI, objDontCareROI);
                    //    //objDontCareROI.Dispose();


                    //    //if (m_smVisionInfo.g_blnWantGauge)
                    //    //    m_smVisionInfo.g_arrMarks[intUnitNo].InspectOCVMark_NewMethodForMultiExcessMark_IPM(blnAuto, m_objMarkTestImage, m_objMarkTrainROI, !m_smVisionInfo.g_blnWantGauge, m_smVisionInfo.g_objWhiteImage, m_smVisionInfo.g_objBlackImage);
                    //    //else if (m_smVisionInfo.g_arrMarkROIs[0].Count > 3)    // Mean Unit Surface ROI exist
                    //    //    m_smVisionInfo.g_arrMarks[intUnitNo].InspectOCVMark_NewMethodForMultiExcessMark_IPM(blnAuto, m_objMarkTestImage, m_objMarkTrainROI, !m_smVisionInfo.g_blnWantGauge, m_smVisionInfo.g_objWhiteImage, m_smVisionInfo.g_objBlackImage);
                    //    //else
                    //    //    m_smVisionInfo.g_arrMarks[intUnitNo].InspectOCVMark_NewMethodForMultiExcessMark_IPM(blnAuto, m_objMarkTestImage, m_objMarkTrainROI, !m_smVisionInfo.g_blnWantGauge, m_smVisionInfo.g_objWhiteImage, m_smVisionInfo.g_objBlackImage); //m_objMarkSearchROI

                    //    if (m_smVisionInfo.g_blnWantGauge)
                    //        m_smVisionInfo.g_arrMarks[0].InspectOCVMark_NewMethodForMultiExcessMark(blnAuto, m_objMarkTestImage, m_objMarkSearchROI, m_objMarkTrainROI, !m_smVisionInfo.g_blnWantGauge, m_smVisionInfo.g_objWhiteImage, m_smVisionInfo.g_objBlackImage, false, m_smVisionInfo.g_blnWantCheckContourOnMark, m_smVisionInfo.VM_PR_ByPassUnit, m_smVisionInfo.g_intMinMarkScore);
                    //    else if (m_smVisionInfo.g_arrMarkROIs[0].Count > 3 && (((m_smCustomizeInfo.g_intWantPositioningIndex & (1 << m_smVisionInfo.g_intVisionPos)) > 0) ||
                    //                ((m_smCustomizeInfo.g_intWantLead & (1 << m_smVisionInfo.g_intVisionPos)) > 0)))    // Mean Unit Surface ROI exist
                    //        m_smVisionInfo.g_arrMarks[0].InspectOCVMark_NewMethodForMultiExcessMark(blnAuto, m_objMarkTestImage, m_objMarkSearchROI, m_objMarkTrainROI, !m_smVisionInfo.g_blnWantGauge, m_smVisionInfo.g_objWhiteImage, m_smVisionInfo.g_objBlackImage, false, m_smVisionInfo.g_blnWantCheckContourOnMark, m_smVisionInfo.VM_PR_ByPassUnit, m_smVisionInfo.g_intMinMarkScore);
                    //    else
                    //        m_smVisionInfo.g_arrMarks[0].InspectOCVMark_NewMethodForMultiExcessMark(blnAuto, m_objMarkTestImage, m_objMarkSearchROI, m_objMarkTrainROI, !m_smVisionInfo.g_blnWantGauge, m_smVisionInfo.g_objWhiteImage, m_smVisionInfo.g_objBlackImage, false, m_smVisionInfo.g_blnWantCheckContourOnMark, m_smVisionInfo.VM_PR_ByPassUnit, m_smVisionInfo.g_intMinMarkScore); // m_objMarkSearchROI
                    //}
                    //else
                    {
                        //m_objMarkOcvSearchROI.SaveImage("D:\\TS\\m_objMarkOcvSearchROI.bmp");
                        //m_objMarkSearchROI.SaveImage("D:\\TS\\m_objMarkSearchROI.bmp");
                        //m_objMarkTrainROI.SaveImage("D:\\TS\\m_objMarkTrainROI.bmp");

                        PointF pPackageCenterPoint = new PointF(-1, -1);
                        SizeF SPackageSize = new SizeF(-1, -1);
                        float fPackageAngle = 0;
                        if (m_blnWantPackageTest && ((m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailMask & 0x1000) > 0 || m_smVisionInfo.g_arrPackage[intUnitNo].GetWantInspectPackage())) // 2020-06-23 ZJYEOH : If inspection option got tick Check package size just can use pkg gauge
                        {
                            if (intUnitNo == 0 && m_bPackageSizePreTestResult1)
                            {
                                pPackageCenterPoint = m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint;
                                fPackageAngle = m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle;
                                SPackageSize = new SizeF(m_smVisionInfo.g_objGauge_PkgSize.ref_fRectWidth, m_smVisionInfo.g_objGauge_PkgSize.ref_fRectHeight);
                            }
                            else if (intUnitNo == 1 && m_bPackageSizePreTestResult2)
                            {
                                pPackageCenterPoint = m_smVisionInfo.g_objGauge_PkgSize2.ref_pRectCenterPoint;
                                fPackageAngle = m_smVisionInfo.g_objGauge_PkgSize2.ref_fRectAngle;
                                SPackageSize = new SizeF(m_smVisionInfo.g_objGauge_PkgSize2.ref_fRectWidth, m_smVisionInfo.g_objGauge_PkgSize2.ref_fRectHeight);
                            }
                        }

                        //if (m_blnWantLeadTest && !m_blnWantPackageTest && m_smVisionInfo.g_blnWantUseLeadPointOffsetMarkROI)
                        //{
                        //    ImageDrawing objRotatedPackageImage = m_objMarkTestImage;//m_smVisionInfo.g_arrRotatedImages[0]; //2020-11-03 ZJYEOH : if no package and got lead, then rotatedpackageimage will follow mark Angle
                        //    m_smVisionInfo.g_arrMarks[intUnitNo].InspectOCVMark_NewMethodForMultiExcessMark_OcvAngleAndPackageAngle_Lead(blnAuto,
                        //        ref objRotatedPackageImage,
                        //        m_smVisionInfo.g_objMarkImage,
                        //        m_objMarkOcvSearchROI,
                        //        m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIWidth,
                        //        m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIHeight,
                        //        m_objMarkSearchROI,
                        //        m_objMarkTrainROI,
                        //        !m_smVisionInfo.g_blnWantGauge, m_smVisionInfo.g_objWhiteImage, m_smVisionInfo.g_objBlackImage,
                        //        m_smVisionInfo.g_blnWantCheckNoMark, m_smVisionInfo.g_blnWantCheckContourOnMark,
                        //        pPackageCenterPoint,
                        //        fPackageAngle,
                        //        m_smVisionInfo.g_arrOrients[intUnitNo][m_smVisionInfo.g_intSelectedOcv[0]].ref_fDegAngleResult,
                        //        m_smVisionInfo.g_intMarkDefectInspectionMethod,
                        //        m_smVisionInfo.g_intMarkInspectionAreaGrayValueSensitivity,
                        //        m_smVisionInfo.g_intMarkBrightSensitivity,
                        //        m_smVisionInfo.VM_PR_ByPassUnit, m_smVisionInfo.g_intMinMarkScore, m_smVisionInfo.g_arrMarkDontCareROIs
                        //        , m_smVisionInfo.g_objBlackWhiteTopImage, m_smVisionInfo.g_objBlackWhiteRightImage, m_smVisionInfo.g_objBlackWhiteBottomImage, m_smVisionInfo.g_objBlackWhiteLeftImage);
                        //}
                        //else
                        {
                            ImageDrawing objRotatedPackageImage = m_objMarkTestImage;//m_smVisionInfo.g_arrImages[0];
                            m_smVisionInfo.g_arrMarks[intUnitNo].InspectOCVMark_NewMethodForMultiExcessMark_OcvAngleAndPackageAngle_NonRotate(blnAuto,
                                ref objRotatedPackageImage,
                                m_smVisionInfo.g_objMarkImage,
                                m_objMarkOcvSearchROI,
                                m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIWidth,
                                m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIHeight,
                                m_objMarkSearchROI,
                                m_objMarkTrainROI,
                                !m_smVisionInfo.g_blnWantGauge, m_smVisionInfo.g_objWhiteImage, m_smVisionInfo.g_objBlackImage,
                                m_smVisionInfo.g_blnWantCheckNoMark, m_smVisionInfo.g_blnWantCheckContourOnMark, m_smVisionInfo.g_blnWantCheckMarkBroken,//m_smVisionInfo.g_blnWantCheckCharBrokenMark,
                                pPackageCenterPoint,
                                SPackageSize,
                                fPackageAngle,
                                m_smVisionInfo.g_arrOrients[intUnitNo][m_smVisionInfo.g_intSelectedOcv[0]].ref_fDegAngleResult,
                                m_smVisionInfo.g_intMarkDefectInspectionMethod,
                                m_smVisionInfo.g_intMarkInspectionAreaGrayValueSensitivity,
                                m_smVisionInfo.g_intMarkBrightSensitivity,
                                m_smVisionInfo.VM_PR_ByPassUnit, m_smVisionInfo.g_intMinMarkScore,
                                m_arrDontCareLeadAreaStartX, m_arrDontCareLeadAreaStartY, m_arrDontCareLeadAreaEndX, m_arrDontCareLeadAreaEndY, m_arrDontCareLeadDirection,
                                m_intOrientAngle, m_smVisionInfo.g_arrMarkDontCareROIs
                                , m_smVisionInfo.g_objBlackWhiteTopImage, m_smVisionInfo.g_objBlackWhiteRightImage, m_smVisionInfo.g_objBlackWhiteBottomImage, m_smVisionInfo.g_objBlackWhiteLeftImage, ShowLiterationOnly);
                        }

                        //if (m_smVisionInfo.g_blnWantGauge)
                        //    m_smVisionInfo.g_arrMarks[0].InspectOCVMark_NewMethodForMultiExcessMark(blnAuto, m_smVisionInfo.g_arrRotatedImages[0], m_objMarkSearchROI, m_objMarkTrainROI, !m_smVisionInfo.g_blnWantGauge, m_smVisionInfo.g_objWhiteImage, m_smVisionInfo.g_objBlackImage, false, m_smVisionInfo.g_blnWantCheckContourOnMark);
                        //else if (m_smVisionInfo.g_arrMarkROIs[0].Count > 3 && (((m_smCustomizeInfo.g_intWantPositioningIndex & (1 << m_smVisionInfo.g_intVisionPos)) > 0) ||
                        //            ((m_smCustomizeInfo.g_intWantLead & (1 << m_smVisionInfo.g_intVisionPos)) > 0)))    // Mean Unit Surface ROI exist
                        //    m_smVisionInfo.g_arrMarks[0].InspectOCVMark_NewMethodForMultiExcessMark(blnAuto, m_smVisionInfo.g_arrRotatedImages[0], m_objMarkSearchROI, m_objMarkTrainROI, !m_smVisionInfo.g_blnWantGauge, m_smVisionInfo.g_objWhiteImage, m_smVisionInfo.g_objBlackImage, false, m_smVisionInfo.g_blnWantCheckContourOnMark);
                        //else
                        //    m_smVisionInfo.g_arrMarks[0].InspectOCVMark_NewMethodForMultiExcessMark(blnAuto, m_smVisionInfo.g_arrRotatedImages[0], m_objMarkSearchROI, m_objMarkTrainROI, !m_smVisionInfo.g_blnWantGauge, m_smVisionInfo.g_objWhiteImage, m_smVisionInfo.g_objBlackImage, false, m_smVisionInfo.g_blnWantCheckContourOnMark); // m_objMarkSearchROI
                    }


                    // 2020 04 15 - JBTAN: check mark option enable only will set result fail
                    if (m_smVisionInfo.g_arrMarks[intUnitNo].ref_blnCheckMark)
                    {
                        m_smVisionInfo.g_blnMarkInspected = true;
                        m_smVisionInfo.g_blnDrawMarkResult = true;

                        if (m_smVisionInfo.g_arrMarks[intUnitNo].ref_intFailResultMask > 0)
                        {
                            if (blnAuto)
                            {
                                SaveRejectImage_AddToBuffer("Mark", m_smVisionInfo.g_arrMarks[intUnitNo].GetInspectionMessage(intUnitNo, m_smVisionInfo.VM_PR_ByPassUnit, m_smVisionInfo.g_intMinMarkScore, m_smVisionInfo.g_intUnitsOnImage));

                                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 24 g_intMarkFailureTotal=" + m_smVisionInfo.g_intMarkFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                                if (m_smVisionInfo.g_intUnitsOnImage == 1 && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)
                                {
                                    m_smVisionInfo.g_intMarkFailureTotal++;
                                    //m_smVisionInfo.g_intTestedTotal++;
                                    //m_smVisionInfo.g_intLowYieldUnitCount++;
                                    m_blnFailCounterAdded = true;
                                    //m_blnFailCounterAddedForUnit2 = true;
                                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 24a g_intMarkFailureTotal=" + m_smVisionInfo.g_intMarkFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                                }

                                // 17-07-2019 ZJYEOH : Added this condition so that fail counter will increment, when enter this condition means retest pass and current unit fail 
                                if ((intUnitNo == 1 && m_smVisionInfo.g_intUnitsOnImage == 2) && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)
                                {
                                    m_smVisionInfo.g_intMarkFailureTotal++;
                                    //m_smVisionInfo.g_intTestedTotal++;
                                    //m_smVisionInfo.g_intLowYieldUnitCount++;
                                    m_blnFailCounterAdded = true;
                                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 24b g_intMarkFailureTotal=" + m_smVisionInfo.g_intMarkFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                                }

                                //if ((intUnitNo == 1 || m_smVisionInfo.g_intUnitsOnImage == 1) && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)
                                //{
                                //    m_smVisionInfo.g_intMarkFailureTotal++;
                                //    //m_smVisionInfo.g_intTestedTotal++;
                                //    //m_smVisionInfo.g_intLowYieldUnitCount++;
                                //    m_blnFailCounterAdded = true;
                                //    m_blnFailCounterAddedForUnit2 = true;
                                //    //STTrackLog.WriteLine("Fail 24a g_intMarkFailureTotal=" + m_smVisionInfo.g_intMarkFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                                //}

                                //// 17-07-2019 ZJYEOH : Added this condition so that fail counter will increment, when enter this condition means retest pass and current unit fail 
                                //if ((intUnitNo == 0 && m_smVisionInfo.g_intUnitsOnImage == 2) && m_smVisionInfo.g_blnInPocketRetestEnd && (!m_blnFailCounterAdded || m_blnFailCounterAddedForUnit2))
                                //{
                                //    m_smVisionInfo.g_intMarkFailureTotal++;
                                //    //m_smVisionInfo.g_intTestedTotal++;
                                //    //m_smVisionInfo.g_intLowYieldUnitCount++;
                                //    m_blnFailCounterAdded = true;
                                //    //STTrackLog.WriteLine("Fail 24a g_intMarkFailureTotal=" + m_smVisionInfo.g_intMarkFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                                //}
                            }

                            if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                                if (m_intTCPIPResultID == -1)
                                    m_intTCPIPResultID = (int)TCPIPResulID.Fail;//FailMark;

                            m_smVisionInfo.g_strErrorMessage = m_smVisionInfo.g_arrMarks[intUnitNo].GetInspectionMessage(intUnitNo, m_smVisionInfo.VM_PR_ByPassUnit, m_smVisionInfo.g_intMinMarkScore, m_smVisionInfo.g_intUnitsOnImage);
                            return false;
                        }
                    }
                }

                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - A10 ");
                // -------- Check Mark Text Shifted ----------------------------
                // 2019 07 21 - When no gauge during mark test, it is not possible to check Mark Texted Shifted.
                //            - So need to rely on Package Size result to check Mark Text Shifted.
                if (!m_smVisionInfo.g_blnWantGauge)
                {
                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - A11 ");
                    bool blnWantCheckMarkTextShifted = false;
                    if (m_smVisionInfo.g_arrMarks != null && m_smVisionInfo.g_arrMarks.Count > 0)
                    {
                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - A12 ");
                        blnWantCheckMarkTextShifted = m_smVisionInfo.g_arrMarks[intUnitNo].ref_blnCheckMark && m_smVisionInfo.g_arrMarks[intUnitNo].WantCheckMarkTextShifted();
                    }

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - A13 ");
                    if (blnWantCheckMarkTextShifted)
                    {
                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - A14 ");
                        if (intUnitNo == 0)
                        {
                            if (m_bPackageSizePreTestResult1) // Only need to check text shifted if mark result pass, and package size inspection pass
                            {
                                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - A15 ");
                                if (!m_smVisionInfo.g_arrMarks[intUnitNo].CheckTextShifted2(
                                    (int)Math.Round(m_smVisionInfo.g_arrPackage[intUnitNo].ref_fPackageResultCenterX - m_smVisionInfo.g_arrPackage[intUnitNo].ref_fPackageResultWidth_px / 2, 0, MidpointRounding.AwayFromZero),
                                    (int)Math.Round(m_smVisionInfo.g_arrPackage[intUnitNo].ref_fPackageResultCenterY - m_smVisionInfo.g_arrPackage[intUnitNo].ref_fPackageResultHeight_px / 2, 0, MidpointRounding.AwayFromZero),
                                    (int)Math.Round(m_smVisionInfo.g_arrPackage[intUnitNo].ref_fPackageResultCenterX + m_smVisionInfo.g_arrPackage[intUnitNo].ref_fPackageResultWidth_px / 2, 0, MidpointRounding.AwayFromZero),
                                    (int)Math.Round(m_smVisionInfo.g_arrPackage[intUnitNo].ref_fPackageResultCenterY + m_smVisionInfo.g_arrPackage[intUnitNo].ref_fPackageResultHeight_px / 2, 0, MidpointRounding.AwayFromZero)))
                                {
                                    //WaitEventDone(ref m_bPackageSizeTestDone1, true);//2021-03-09 ZJYEOH : No need to wait package result as mark will fail priority, waiting here cause software fall into infinite loop as package also waiting mark done inspection
                                    //if (m_bSubTh_PackageTest_PackageSize_Result)
                                    {
                                        m_smVisionInfo.g_strErrorMessage += "*Mark Shifted";
                                        if (blnAuto)
                                        {
                                            SaveRejectImage_AddToBuffer("Mark", m_smVisionInfo.g_strErrorMessage);

                                            m_smVisionInfo.g_intMarkFailureTotal++;
                                        }
                                    }

                                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                                        if (m_intTCPIPResultID == -1)
                                            m_intTCPIPResultID = (int)TCPIPResulID.Fail;//FailMark;

                                    return false;
                                }
                                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - A16 ");
                            }
                        }
                        else
                        {
                            if (m_bPackageSizePreTestResult2) // Only need to check text shifted if mark result pass, and package size inspection pass
                            {
                                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - A15 ");
                                if (!m_smVisionInfo.g_arrMarks[intUnitNo].CheckTextShifted2(
                                    (int)Math.Round(m_smVisionInfo.g_arrPackage[intUnitNo].ref_fPackageResultCenterX - m_smVisionInfo.g_arrPackage[intUnitNo].ref_fPackageResultWidth_px / 2, 0, MidpointRounding.AwayFromZero),
                                    (int)Math.Round(m_smVisionInfo.g_arrPackage[intUnitNo].ref_fPackageResultCenterY - m_smVisionInfo.g_arrPackage[intUnitNo].ref_fPackageResultHeight_px / 2, 0, MidpointRounding.AwayFromZero),
                                    (int)Math.Round(m_smVisionInfo.g_arrPackage[intUnitNo].ref_fPackageResultCenterX + m_smVisionInfo.g_arrPackage[intUnitNo].ref_fPackageResultWidth_px / 2, 0, MidpointRounding.AwayFromZero),
                                    (int)Math.Round(m_smVisionInfo.g_arrPackage[intUnitNo].ref_fPackageResultCenterY + m_smVisionInfo.g_arrPackage[intUnitNo].ref_fPackageResultHeight_px / 2, 0, MidpointRounding.AwayFromZero)))
                                {
                                    //WaitEventDone(ref m_bPackageSizeTestDone2, true);//2021-03-09 ZJYEOH : No need to wait package result as mark will fail priority, waiting here cause software fall into infinite loop as package also waiting mark done inspection
                                    //if (m_bSubTh_PackageTest_PackageSize_Result2)
                                    {
                                        m_smVisionInfo.g_strErrorMessage += "*Mark Shifted";
                                        if (blnAuto)
                                        {
                                            SaveRejectImage_AddToBuffer("Mark", m_smVisionInfo.g_strErrorMessage);

                                            m_smVisionInfo.g_intMarkFailureTotal++;
                                        }
                                    }

                                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                                        if (m_intTCPIPResultID == -1)
                                            m_intTCPIPResultID = (int)TCPIPResulID.Fail;//FailMark;

                                    return false;
                                }
                                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - A16 ");
                            }
                        }
                    }
                }

                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - A17 ");
                // --------------- End Check Mark Text Shifted ---------------------------------------------

                return true;

            }
            catch (Exception ex)
            {
                //objTL1.WriteLine("Vision4Process StartMarkTest ex: " + ex.ToString());
                return false;
            }
        }

        private bool StartEmptyUnitTest(bool blnAuto, int intUnitNo)
        {
            if (m_smVisionInfo.g_arrOrients[intUnitNo][0].IsPocketEmpty(m_smVisionInfo.g_arrOrientROIs[intUnitNo][0]))
            {
                return true;
            }
            else
            {
                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        m_intTCPIPResultID = (int)TCPIPResulID.Fail;//FailEmpty;

                return false;
            }
        }
        
        private bool StartOrientTest_using4LGauge_OcvAngleAndPackageAngle(bool blnAuto, int intUnitNo)
        {
            if ((m_smCustomizeInfo.g_intWantOrient & (1 << m_smVisionInfo.g_intVisionPos)) == 0)
                return true;

            // make sure template learn
            if (m_smVisionInfo.g_arrOrients[intUnitNo].Count == 0)
            {
                if (m_smVisionInfo.g_intUnitsOnImage == 1)
                    m_smVisionInfo.g_strErrorMessage += "*Unit" + (intUnitNo + 1) + " Orient : No Template Found";
                else
                    m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + " Orient : No Template Found";
                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 29 g_intOrientFailureTotal=" + m_smVisionInfo.g_intOrientFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                if ((intUnitNo == 1 || m_smVisionInfo.g_intUnitsOnImage == 1) && blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)
                {
                    m_smVisionInfo.g_intNoTemplateFailureTotal++;
                    //m_smVisionInfo.g_intTestedTotal++;
                    //m_smVisionInfo.g_intLowYieldUnitCount++;
                    m_blnFailCounterAdded = true;
                    m_blnTotalCounterAdded = false;

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 29a g_intOrientFailureTotal=" + m_smVisionInfo.g_intOrientFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                }

                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        m_intTCPIPResultID = (int)TCPIPResulID.Fail;

                return false;
            }

            // reset all inspection data
            for (int i = 0; i < m_smVisionInfo.g_arrOrients[intUnitNo].Count; i++)
            {
                ((Orient)m_smVisionInfo.g_arrOrients[intUnitNo][i]).ResetInspectionData();
            }

            float fUnitSurfaceOffsetX = 0;
            float fUnitSurfaceOffsetY = 0;
            float fUnitPRResultCenterX = 0;
            float fUnitPRResultCenterY = 0;
            float fUnitPRResultAngle = 0;

            // Use Gauge to find unit angle and rotate it to 0 deg
            if (m_smVisionInfo.g_blnWantGauge) // Use
            {
                if (!blnAuto)
                    m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].AttachImage(m_smVisionInfo.g_arrImages[0]);

                // Reallocate gauge position to inpocket position
                if (m_blnWantPositioning)
                {
                    if (m_smVisionInfo.MN_PR_CheckPosition)
                    {
                        m_smVisionInfo.g_arrOrientGauge[intUnitNo].SetRectGaugePlacement(
                            m_smVisionInfo.g_objPositioning.ref_fObjectCenterX,
                            m_smVisionInfo.g_objPositioning.ref_fObjectCenterY);

                        m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].LoadROISetting(
                            (int)Math.Round(m_smVisionInfo.g_objPositioning.ref_fObjectCenterX -
                             m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIWidth / 2, 0, MidpointRounding.AwayFromZero),
                             (int)Math.Round(m_smVisionInfo.g_objPositioning.ref_fObjectCenterY -
                            m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIHeight / 2, 0, MidpointRounding.AwayFromZero),
                            m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIWidth,
                            m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIHeight);
                    }
                }
                if (m_smVisionInfo.g_blnWantUseUnitPRFindGauge)// (m_smVisionInfo.g_arrOrientROIs[intUnitNo].Count > 2)
                {
                    if (m_smVisionInfo.g_arrOrients[intUnitNo][0].MatchWithTemplateUnitPR(m_smVisionInfo.g_arrOrientROIs[intUnitNo][0]))
                    {
                        // Changed m_smVisionInfo.g_arrOrients[intUnitNo][m_smVisionInfo.g_intSelectedTemplate] to m_smVisionInfo.g_arrOrients[intUnitNo][0]
                        // because when user select different template during offline test, will have different result, need to look into this case in future as may have different mark learnt as template
                        fUnitPRResultCenterX = m_smVisionInfo.g_arrOrients[intUnitNo][0].GetUnitPRResultCenterX() + m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIPositionX;
                        fUnitPRResultCenterY = m_smVisionInfo.g_arrOrients[intUnitNo][0].GetUnitPRResultCenterY() + m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIPositionY;
                        int intUnitPRWidth = m_smVisionInfo.g_arrOrients[intUnitNo][0].GetUnitPRWidth();
                        int intUnitPRHeight = m_smVisionInfo.g_arrOrients[intUnitNo][0].GetUnitPRHeight();

                        if (m_smVisionInfo.g_arrOrientGaugeM4L.Count > intUnitNo)
                            m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].SetEdgeROIPlacementLimit2(m_smVisionInfo.g_arrOrientROIs[intUnitNo][0], (int)fUnitPRResultCenterX, (int)fUnitPRResultCenterY, intUnitPRWidth, intUnitPRHeight);

                        if (m_smVisionInfo.g_arrMarkGaugeM4L.Count > intUnitNo)
                            m_smVisionInfo.g_arrMarkGaugeM4L[intUnitNo].SetEdgeROIPlacementLimit2(m_smVisionInfo.g_arrOrientROIs[intUnitNo][0], (int)fUnitPRResultCenterX, (int)fUnitPRResultCenterY, intUnitPRWidth, intUnitPRHeight);

                        if (m_smVisionInfo.g_arrPackageGaugeM4L.Count > intUnitNo)
                            m_smVisionInfo.g_arrPackageGaugeM4L[intUnitNo].SetEdgeROIPlacementLimit2(m_smVisionInfo.g_arrOrientROIs[intUnitNo][0], (int)fUnitPRResultCenterX, (int)fUnitPRResultCenterY, intUnitPRWidth, intUnitPRHeight);

                        if (m_smVisionInfo.g_arrPackageGauge2M4L.Count > intUnitNo)
                            m_smVisionInfo.g_arrPackageGauge2M4L[intUnitNo].SetEdgeROIPlacementLimit2(m_smVisionInfo.g_arrOrientROIs[intUnitNo][0], (int)fUnitPRResultCenterX, (int)fUnitPRResultCenterY, intUnitPRWidth, intUnitPRHeight);
                    }
                    else
                    {
                        //2019-10-14 ZJYEOH : If matching fail, load gauge using template unit position center 

                        if (m_smVisionInfo.g_arrOrientGaugeM4L.Count > intUnitNo)
                            m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].SetEdgeROIPlacementLimit2(m_smVisionInfo.g_arrOrientROIs[intUnitNo][0],
                                (int)m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].ref_f4LGaugeCenterPointX, (int)m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].ref_f4LGaugeCenterPointY,
                                (int)m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].ref_f4LGaugeUnitWidth, (int)m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].ref_f4LGaugeUnitHeight);

                        if (m_smVisionInfo.g_arrMarkGaugeM4L.Count > intUnitNo)
                            m_smVisionInfo.g_arrMarkGaugeM4L[intUnitNo].SetEdgeROIPlacementLimit2(m_smVisionInfo.g_arrOrientROIs[intUnitNo][0],
                                (int)m_smVisionInfo.g_arrMarkGaugeM4L[intUnitNo].ref_f4LGaugeCenterPointX, (int)m_smVisionInfo.g_arrMarkGaugeM4L[intUnitNo].ref_f4LGaugeCenterPointY,
                                (int)m_smVisionInfo.g_arrMarkGaugeM4L[intUnitNo].ref_f4LGaugeUnitWidth, (int)m_smVisionInfo.g_arrMarkGaugeM4L[intUnitNo].ref_f4LGaugeUnitHeight);

                        if (m_smVisionInfo.g_arrPackageGaugeM4L.Count > intUnitNo)
                            m_smVisionInfo.g_arrPackageGaugeM4L[intUnitNo].SetEdgeROIPlacementLimit2(m_smVisionInfo.g_arrOrientROIs[intUnitNo][0],
                                (int)m_smVisionInfo.g_arrPackageGaugeM4L[intUnitNo].ref_f4LGaugeCenterPointX, (int)m_smVisionInfo.g_arrPackageGaugeM4L[intUnitNo].ref_f4LGaugeCenterPointY,
                                (int)m_smVisionInfo.g_arrPackageGaugeM4L[intUnitNo].ref_f4LGaugeUnitWidth, (int)m_smVisionInfo.g_arrPackageGaugeM4L[intUnitNo].ref_f4LGaugeUnitHeight);

                        if (m_smVisionInfo.g_arrPackageGauge2M4L.Count > intUnitNo)
                            m_smVisionInfo.g_arrPackageGauge2M4L[intUnitNo].SetEdgeROIPlacementLimit2(m_smVisionInfo.g_arrOrientROIs[intUnitNo][0],
                                (int)m_smVisionInfo.g_arrPackageGauge2M4L[intUnitNo].ref_f4LGaugeCenterPointX, (int)m_smVisionInfo.g_arrPackageGauge2M4L[intUnitNo].ref_f4LGaugeCenterPointY,
                                (int)m_smVisionInfo.g_arrPackageGauge2M4L[intUnitNo].ref_f4LGaugeUnitWidth, (int)m_smVisionInfo.g_arrPackageGauge2M4L[intUnitNo].ref_f4LGaugeUnitHeight);

                    }
                }

                if (intUnitNo == 0)
                    m_blnOrientGaugeUpdated1 = true;
                else
                    m_blnOrientGaugeUpdated2 = true;

                // Add gain value to image and attached all position ROI to gain image.
                float fGaugeAngle;
                bool blnGaugeResult = false;
                //if (m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].ref_fGainValue != 1000)
                //{
                //    m_smVisionInfo.g_arrImages[0].AddGain(ref m_objOrientGainImage, m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].ref_fGainValue / 1000);
                //    m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].SetGaugePlace_BasedOnEdgeROI();
                //    blnGaugeResult = m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].Measure_WithDontCareArea(m_objOrientGainImage, m_smVisionInfo.g_objWhiteImage);
                //    fGaugeAngle = m_fOrientGauge = m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].ref_fRectAngle;
                //}
                //else
                {
                    m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].SetGaugePlace_BasedOnEdgeROI();
                    blnGaugeResult = m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].Measure_WithDontCareArea(m_smVisionInfo.g_arrImages, m_smVisionInfo.g_objWhiteImage);
                    fGaugeAngle = m_fOrientGauge = m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].ref_fRectAngle;
                }
                if (!blnGaugeResult)
                {
                    m_smVisionInfo.g_strErrorMessage += "*Orient : " + m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].ref_strErrorMessage;
                    // if (blnAuto)
                    if (blnAuto)
                    {
                        SaveRejectImage_AddToBuffer("EdgeNotFound", "*Orient : " + m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].ref_strErrorMessage);
                    }
                    if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                    {
                        m_smVisionInfo.g_intEdgeNotFoundFailureTotal++;
                        //SaveRejectImage_AddToBuffer("EdgeNotFound", "*Orient : " + m_smVisionInfo.g_arrOrientGaugeM4L[0].ref_strErrorMessage);
                        m_blnFailCounterAdded = true;
                        m_blnTotalCounterAdded = false;
                    }

                    m_smVisionInfo.g_blnViewGaugeNotFound = true;
                    m_smVisionInfo.g_blnViewOrientObject = true;

                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        if (m_intTCPIPResultID == -1)
                            m_intTCPIPResultID = (int)TCPIPResulID.Fail;

                    return false;
                }
                // RotateROI has same center point with gauge measure center point.
                ROI objRotateROI = new ROI();
                objRotateROI.AttachImage(m_smVisionInfo.g_arrImages[0]);
                objRotateROI.LoadROISetting(
                    (int)Math.Round(m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].ref_pRectCenterPoint.X -
                    m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIWidth / 2, 0, MidpointRounding.AwayFromZero),
                    (int)Math.Round(m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].ref_pRectCenterPoint.Y -
                    m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIHeight / 2, 0, MidpointRounding.AwayFromZero),
                    m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIWidth,
                    m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIHeight);

                if (intUnitNo == 1)
                {

                    ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[0], objRotateROI, fGaugeAngle, 0, ref m_smVisionInfo.g_arrRotatedImages, 0);
                }
                else
                {

                    if (((m_intScenario & 0x02) > 0) || !blnAuto)
                    {
                        // Rotate from rotated image if unit 1 is tested
                        m_smVisionInfo.g_arrRotatedImages[0].CopyTo(ref m_objPreviousRotatedImage);
                        ROI.Rotate0Degree(m_objPreviousRotatedImage, objRotateROI, fGaugeAngle, 0, ref m_smVisionInfo.g_arrRotatedImages, 0);
                    }
                    else
                    {
                        // Rotate from main image if unit 1 no tested (scenario == 0x02)
                        ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[0], objRotateROI, fGaugeAngle, 0, ref m_smVisionInfo.g_arrRotatedImages, 0);
                    }

                }

                objRotateROI.Dispose();
            }
            else // No rect gauge
            {
                //2021-08-20 ZJYEOH : No need purpose rotate
                //// If Lead Unit, use unit lead pattern to find unit surface ROI
                //if (((m_smCustomizeInfo.g_intWantLead & (1 << m_smVisionInfo.g_intVisionPos)) > 0) && m_smVisionInfo.g_arrOrients[intUnitNo][m_smVisionInfo.g_intSelectedTemplate].ref_blnUnitPRMatcherExist)
                //{
                //    m_smVisionInfo.g_arrOrients[intUnitNo][m_smVisionInfo.g_intSelectedTemplate].MatchWithTemplateUnitPR(m_smVisionInfo.g_arrOrientROIs[intUnitNo][0]);
                //    fUnitPRResultCenterX = m_smVisionInfo.g_arrOrients[intUnitNo][m_smVisionInfo.g_intSelectedTemplate].GetUnitPRResultCenterX();
                //    fUnitPRResultCenterY = m_smVisionInfo.g_arrOrients[intUnitNo][m_smVisionInfo.g_intSelectedTemplate].GetUnitPRResultCenterY();
                //    fUnitPRResultAngle = m_smVisionInfo.g_arrOrients[intUnitNo][m_smVisionInfo.g_intSelectedTemplate].GetUnitPRResultAngle();
                //    fUnitSurfaceOffsetX = m_smVisionInfo.g_arrOrients[intUnitNo][m_smVisionInfo.g_intSelectedTemplate].ref_intUnitSurfaceOffsetX;
                //    fUnitSurfaceOffsetY = m_smVisionInfo.g_arrOrients[intUnitNo][m_smVisionInfo.g_intSelectedTemplate].ref_intUnitSurfaceOffsetY;

                //    if (!Math2.GetNewXYAfterRotate(m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROITotalX + fUnitPRResultCenterX,
                //                                  m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROITotalY + fUnitPRResultCenterY,
                //                                  fUnitSurfaceOffsetX,
                //                                  fUnitSurfaceOffsetY,
                //                                  fUnitPRResultAngle,
                //                                  ref fUnitSurfaceOffsetX,
                //                                  ref fUnitSurfaceOffsetY))
                //    { }

                //    ROI objRotateROI = new ROI();
                //    objRotateROI.AttachImage(m_smVisionInfo.g_arrImages[0]);
                //    objRotateROI.LoadROISetting(
                //        (int)Math.Round(m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROITotalX +
                //        fUnitPRResultCenterX -
                //        m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIWidth / 2 +
                //        fUnitSurfaceOffsetX, 0, MidpointRounding.AwayFromZero),
                //        (int)Math.Round(m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROITotalY +
                //        fUnitPRResultCenterY -
                //        m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIHeight / 2 +
                //        fUnitSurfaceOffsetY, 0, MidpointRounding.AwayFromZero),
                //        m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIWidth,
                //        m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIHeight);


                //    // Rotate unit to exact 0 degree (m_fOrientGauge used in Package)
                //    ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[0], objRotateROI, fUnitPRResultAngle, 0, ref m_smVisionInfo.g_arrRotatedImages, 0); // Clear image is not so important in Orient Matching. Use interpolation 0 to save rotation time.

                //    objRotateROI.Dispose();
                //}
                //else // if not lead unit, mean it is QFN. There is no way to find unit surface ROI without gauge tool.
                {
                    m_smVisionInfo.g_arrImages[0].CopyTo(m_smVisionInfo.g_arrRotatedImages[0]);
                    if (intUnitNo == 0)
                        m_blnOrientGaugeUpdated1 = true;
                    else
                        m_blnOrientGaugeUpdated2 = true;
                }
            }

            int intMatchCount = 0;
            bool blnRecipeCorrupted = false;
            m_smVisionInfo.g_intOrientResult[intUnitNo] = -1;  // 0:0deg, 1:90deg, 2:180deg, 3:-90, 4:Fail
            m_arrFinalPreciseAnglePass.Clear();
            // Single template test
            if (!blnAuto && !m_smVisionInfo.g_blnInspectAllTemplate)
            {
                m_smVisionInfo.g_intOrientResult[intUnitNo] = m_smVisionInfo.g_arrOrients[intUnitNo][m_smVisionInfo.g_intSelectedTemplate].MatchWithTemplate(
                    m_smVisionInfo.g_arrOrientROIs[intUnitNo][0], m_smVisionInfo.g_arrRotatedImages[0], true);
                m_smVisionInfo.g_intSelectedOcv[intUnitNo] = m_smVisionInfo.g_intSelectedTemplate;
                m_smVisionInfo.g_fOrientScore[intUnitNo] = m_smVisionInfo.g_arrOrients[intUnitNo][m_smVisionInfo.g_intSelectedTemplate].GetMinScore();
            }
            else // Whole active templates test
            {
                float fHighestScore = -1;

                do
                {
                    int intTemplateIndex = (int)((m_smVisionInfo.g_intTemplatePriority >> (0x04 * intMatchCount)) & 0x0F) - 1;
                    if (intTemplateIndex >= 0)
                    {
                        int intAngle;
                        m_arrFinalPreciseAnglePass.Add(true);
                        bool blnPreciseAngleResult = true;
                        if (m_smVisionInfo.g_intTemplateMask == 0 || (m_smVisionInfo.g_intTemplateMask & (1 << intTemplateIndex)) > 0)
                        {
                            if (((m_smCustomizeInfo.g_intWantMark & (1 << m_smVisionInfo.g_intVisionPos)) > 0) || ((m_smCustomizeInfo.g_intWantOCR & (1 << m_smVisionInfo.g_intVisionPos)) > 0) ||
                                (m_smCustomizeInfo.g_intWantPackage & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
                            {
                                m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].AttachImage(m_smVisionInfo.g_arrRotatedImages[0]);

                                intAngle = m_smVisionInfo.g_arrOrients[intUnitNo][intTemplateIndex].DoOrientationInspection(
                                m_smVisionInfo.g_arrOrientROIs[intUnitNo][0], m_smVisionInfo.g_intFinalReduction_Direction, m_smVisionInfo.g_intFinalReduction_MarkDeg, false, !m_smVisionInfo.g_blnWantGauge, //m_smVisionInfo.g_arrOrientROIs[0][0], 2, !m_smVisionInfo.g_blnWantGauge,
                                m_smVisionInfo.g_arrMarks[intUnitNo].GetMarkAngleTolerance(0, intTemplateIndex),
                                ref blnPreciseAngleResult, ((m_smCustomizeInfo.g_intWantLead & (1 << m_smVisionInfo.g_intVisionPos)) > 0),
                                !m_smVisionInfo.g_blnWhiteOnBlack);  // Use FinalReduction=2 because match center point is not very important in MarkOrient Test.

                                if (!blnPreciseAngleResult)
                                    m_arrFinalPreciseAnglePass[intTemplateIndex] = false;

                                //intAngle = m_smVisionInfo.g_arrOrients[intUnitNo][intTemplateIndex].DoOrientationInspection(
                                //    m_smVisionInfo.g_arrOrientROIs[intUnitNo][0], 2, !m_smVisionInfo.g_blnWantGauge);   // Use FinalReduction=2 because match center point is not very important in MarkOrient Test.
                            }
                            else
                            {
                                intAngle = m_smVisionInfo.g_arrOrients[intUnitNo][intTemplateIndex].MatchWithTemplate(
                                    m_smVisionInfo.g_arrOrientROIs[intUnitNo][0], m_smVisionInfo.g_arrRotatedImages[0], true, fHighestScore, false,
                                    m_smVisionInfo.g_blnWantSubROI && (m_smVisionInfo.g_arrOrientROIs[intUnitNo].Count > 2));
                            }

                            if (m_smVisionInfo.g_arrOrients[intUnitNo][intTemplateIndex].GetMinScore() > fHighestScore)
                            {
                                fHighestScore = m_smVisionInfo.g_fOrientScore[intUnitNo] = m_smVisionInfo.g_arrOrients[intUnitNo][intTemplateIndex].GetMinScore();
                                m_smVisionInfo.g_intSelectedOcv[intUnitNo] = intTemplateIndex;
                                m_smVisionInfo.g_intOrientResult[intUnitNo] = intAngle;

                            }
                        }
                    }
                    else
                        blnRecipeCorrupted = true;
                    intMatchCount++;
                //} while ((fHighestScore < 0.8) && (intMatchCount < m_smVisionInfo.g_arrOrients[intUnitNo].Count));
                } while (intMatchCount < m_smVisionInfo.g_arrOrients[intUnitNo].Count);
            }

            Orient objOrient = m_smVisionInfo.g_arrOrients[intUnitNo][m_smVisionInfo.g_intSelectedOcv[intUnitNo]];

            m_smVisionInfo.g_fOrientCenterX[intUnitNo] = objOrient.ref_fObjectX;
            m_smVisionInfo.g_fOrientCenterY[intUnitNo] = objOrient.ref_fObjectY;
            m_smVisionInfo.g_fOrientAngle[intUnitNo] = objOrient.ref_fDegAngleResult;
            m_smVisionInfo.g_fOrientScore[intUnitNo] = objOrient.GetMinScore();
            m_smVisionInfo.g_blnViewOrientObject = true;

            if ((m_smCustomizeInfo.g_intWantRotatorSignal & (0x01 << m_smVisionInfo.g_intVisionPos)) > 0)
            {
                bool blnResult = false;
                if (!m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                {
                    switch (m_smVisionInfo.g_intOrientResult[intUnitNo])
                    {
                        case 0:
                            if (m_objVisionIO.RotatorSignal1.IsOff() && m_objVisionIO.RotatorSignal2.IsOff())
                                blnResult = true;
                            break;
                        case 1:
                            if (m_objVisionIO.RotatorSignal1.IsOn() && m_objVisionIO.RotatorSignal2.IsOff())
                                blnResult = true;
                            break;
                        case 2:
                            if (m_objVisionIO.RotatorSignal1.IsOn() && m_objVisionIO.RotatorSignal2.IsOn())
                                blnResult = true;
                            break;
                        case 3:
                            if (m_objVisionIO.RotatorSignal1.IsOff() && m_objVisionIO.RotatorSignal2.IsOn())
                                blnResult = true;
                            break;
                    }
                }
                else
                {
                    switch (m_smVisionInfo.g_intOrientResult[intUnitNo])
                    {
                        case 0:
                            if (!m_blnRotatorSignal1_In && !m_blnRotatorSignal2_In)
                                blnResult = true;
                            break;
                        case 1:
                            if (m_blnRotatorSignal1_In && !m_blnRotatorSignal2_In)
                                blnResult = true;
                            break;
                        case 2:
                            if (m_blnRotatorSignal1_In && m_blnRotatorSignal2_In)
                                blnResult = true;
                            break;
                        case 3:
                            if (!m_blnRotatorSignal1_In && m_blnRotatorSignal2_In)
                                blnResult = true;
                            break;
                    }
                }

                if (blnResult)
                {
                    if (objOrient.ref_strErrorMessage == "")
                    {
                        if (m_smVisionInfo.g_intUnitsOnImage == 1)
                            m_smVisionInfo.g_strErrorMessage += "*Unit" + (intUnitNo + 1) + " Fail Orient!";
                        else
                            m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + " Fail Orient!";
                    }
                    else
                    {
                        if (m_smVisionInfo.g_intUnitsOnImage == 1)
                            m_smVisionInfo.g_strErrorMessage += "*Unit" + (intUnitNo + 1) + " " + objOrient.ref_strErrorMessage;
                        else
                            m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + objOrient.ref_strErrorMessage;
                    }

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 30 g_intOrientFailureTotal=" + m_smVisionInfo.g_intOrientFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                    if (blnAuto)
                    {
                        if (objOrient.ref_strErrorMessage == "")
                        {
                            if (m_smVisionInfo.g_intUnitsOnImage == 1)
                                SaveRejectImage_AddToBuffer("Orient", "*Unit" + (intUnitNo + 1) + " Fail Orient!");
                            else
                                SaveRejectImage_AddToBuffer("Orient", GetUnitName(intUnitNo) + " Fail Orient!");
                        }
                        else
                        {
                            if (m_smVisionInfo.g_intUnitsOnImage == 1)
                                SaveRejectImage_AddToBuffer("Orient", "*Unit" + (intUnitNo + 1) + " " + objOrient.ref_strErrorMessage);
                            else
                                SaveRejectImage_AddToBuffer("Orient", GetUnitName(intUnitNo) + " " + objOrient.ref_strErrorMessage);
                        }

                        if (m_smVisionInfo.g_intUnitsOnImage == 1 && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)
                        {
                            m_smVisionInfo.g_intOrientFailureTotal++;
                            //m_smVisionInfo.g_intTestedTotal++;
                            //m_smVisionInfo.g_intLowYieldUnitCount++;
                            m_blnFailCounterAdded = true;
                            m_blnTotalCounterAdded = false;
                            //m_blnFailCounterAddedForUnit2 = true;
                            if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 30a g_intMarkFailureTotal=" + m_smVisionInfo.g_intMarkFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                        }

                        // 17-07-2019 ZJYEOH : Added this condition so that fail counter will increment, when enter this condition means retest pass and current unit fail 
                        if ((intUnitNo == 1 && m_smVisionInfo.g_intUnitsOnImage == 2) && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)
                        {
                            m_smVisionInfo.g_intOrientFailureTotal++;
                            //m_smVisionInfo.g_intTestedTotal++;
                            //m_smVisionInfo.g_intLowYieldUnitCount++;
                            m_blnFailCounterAdded = true;
                            m_blnTotalCounterAdded = false;
                            if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 30b g_intMarkFailureTotal=" + m_smVisionInfo.g_intMarkFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                        }

                        //if ((intUnitNo == 1 || m_smVisionInfo.g_intUnitsOnImage == 1) && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)
                        //{
                        //    m_smVisionInfo.g_intOrientFailureTotal++;
                        //    //m_smVisionInfo.g_intTestedTotal++;
                        //    //m_smVisionInfo.g_intLowYieldUnitCount++;
                        //    m_blnFailCounterAdded = true;
                        //    m_blnTotalCounterAdded = false;
                        //    m_blnFailCounterAddedForUnit2 = true;
                        //    //STTrackLog.WriteLine("Fail 30a g_intOrientFailureTotal=" + m_smVisionInfo.g_intOrientFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                        //}

                        //// 17-07-2019 ZJYEOH : Added this condition so that fail counter will increment, when enter this condition means retest pass and current unit fail 
                        //if ((intUnitNo == 0 && m_smVisionInfo.g_intUnitsOnImage == 2) && m_smVisionInfo.g_blnInPocketRetestEnd && (!m_blnFailCounterAdded || m_blnFailCounterAddedForUnit2))
                        //{
                        //    m_smVisionInfo.g_intOrientFailureTotal++;
                        //    //m_smVisionInfo.g_intTestedTotal++;
                        //    //m_smVisionInfo.g_intLowYieldUnitCount++;
                        //    m_blnFailCounterAdded = true;
                        //    m_blnTotalCounterAdded = false;
                        //    //STTrackLog.WriteLine("Fail 30a g_intOrientFailureTotal=" + m_smVisionInfo.g_intOrientFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                        //}
                    }

                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        if (m_intTCPIPResultID == -1)
                            m_intTCPIPResultID = (int)TCPIPResulID.Fail;

                    return false;
                }
                else                      // End ByPass1
                {
                    objOrient.ref_objRotatedImage.CopyTo(m_smVisionInfo.g_arrRotatedImages[0]);
                }
            }
            else
            {
                // 2020 05 09 - CCENG : let orientation result always 0
                m_smVisionInfo.g_intOrientResult[intUnitNo] = 0;

                // Unit fail if angle is 90, 180, -90
                if (m_smVisionInfo.g_intOrientResult[intUnitNo] != 0)
                {
                    if ((!m_blnWantPackageTest || (m_blnWantPackageTest && ((m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailMask & 0x1000) == 0 && !m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetWantInspectPackage()))) && !m_blnWantLeadTest)
                        m_blnRotateImage1Updated = true; // 2020-02-18 ZJYEOH : Need to update this parameter to draw rotated image
                    //if ((m_smCustomizeInfo.g_intWantOrient0Deg & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
                    //{
                    return true; // always return true, because InPocket no display orient result
                    //}

                    if (objOrient.ref_strErrorMessage == "")
                    {
                        if (blnRecipeCorrupted)
                            m_smVisionInfo.g_strErrorMessage = "*Recipe is corrupted. Please relearn.";
                        else
                        {
                            if (m_smVisionInfo.g_intUnitsOnImage == 1)
                                m_smVisionInfo.g_strErrorMessage += "*Unit" + (intUnitNo + 1) + " Fail Orient!";
                            else
                                m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + " Fail Orient!";
                        }
                    }
                    else
                    {
                        if (m_smVisionInfo.g_intUnitsOnImage == 1)
                            m_smVisionInfo.g_strErrorMessage += "*Unit" + (intUnitNo + 1) + " " + objOrient.ref_strErrorMessage;
                        else
                            m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + objOrient.ref_strErrorMessage;
                    }

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 31 g_intOrientFailureTotal=" + m_smVisionInfo.g_intOrientFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                    if (blnAuto)
                    {
                        if (objOrient.ref_strErrorMessage == "")
                        {
                            if (blnRecipeCorrupted)
                                SaveRejectImage_AddToBuffer("Orient", "*Recipe is corrupted. Please relearn.");
                            else
                            {
                                if (m_smVisionInfo.g_intUnitsOnImage == 1)
                                    SaveRejectImage_AddToBuffer("Orient", "*Unit" + (intUnitNo + 1) + " Fail Orient!");
                                else
                                    SaveRejectImage_AddToBuffer("Orient", GetUnitName(intUnitNo) + " Fail Orient!");
                            }
                        }
                        else
                        {
                            if (m_smVisionInfo.g_intUnitsOnImage == 1)
                                SaveRejectImage_AddToBuffer("Orient", "*Unit" + (intUnitNo + 1) + " " + objOrient.ref_strErrorMessage);
                            else
                                SaveRejectImage_AddToBuffer("Orient", GetUnitName(intUnitNo) + objOrient.ref_strErrorMessage);
                        }

                        if (m_smVisionInfo.g_intUnitsOnImage == 1 && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)
                        {
                            m_smVisionInfo.g_intOrientFailureTotal++;
                            //m_smVisionInfo.g_intTestedTotal++;
                            //m_smVisionInfo.g_intLowYieldUnitCount++;
                            m_blnFailCounterAdded = true;
                            m_blnTotalCounterAdded = false;
                            //m_blnFailCounterAddedForUnit2 = true;
                            if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 31a g_intMarkFailureTotal=" + m_smVisionInfo.g_intMarkFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                        }

                        // 17-07-2019 ZJYEOH : Added this condition so that fail counter will increment, when enter this condition means retest pass and current unit fail 
                        if ((intUnitNo == 1 && m_smVisionInfo.g_intUnitsOnImage == 2) && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)
                        {
                            m_smVisionInfo.g_intOrientFailureTotal++;
                            //m_smVisionInfo.g_intTestedTotal++;
                            //m_smVisionInfo.g_intLowYieldUnitCount++;
                            m_blnFailCounterAdded = true;
                            m_blnTotalCounterAdded = false;
                            if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 31b g_intMarkFailureTotal=" + m_smVisionInfo.g_intMarkFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                        }

                        //if ((intUnitNo == 1 || m_smVisionInfo.g_intUnitsOnImage == 1) && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)
                        //{
                        //    m_smVisionInfo.g_intOrientFailureTotal++;
                        //    //m_smVisionInfo.g_intTestedTotal++;
                        //    //m_smVisionInfo.g_intLowYieldUnitCount++;
                        //    m_blnFailCounterAdded = true;
                        //    m_blnTotalCounterAdded = false;
                        //    m_blnFailCounterAddedForUnit2 = true;
                        //    //STTrackLog.WriteLine("Fail 31a g_intOrientFailureTotal=" + m_smVisionInfo.g_intOrientFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                        //}

                        //// 17-07-2019 ZJYEOH : Added this condition so that fail counter will increment, when enter this condition means retest pass and current unit fail 
                        //if ((intUnitNo == 0 && m_smVisionInfo.g_intUnitsOnImage == 2) && m_smVisionInfo.g_blnInPocketRetestEnd && (!m_blnFailCounterAdded || m_blnFailCounterAddedForUnit2))
                        //{
                        //    m_smVisionInfo.g_intOrientFailureTotal++;
                        //    //m_smVisionInfo.g_intTestedTotal++;
                        //    //m_smVisionInfo.g_intLowYieldUnitCount++;
                        //    m_blnFailCounterAdded = true;
                        //    m_blnTotalCounterAdded = false;
                        //    //STTrackLog.WriteLine("Fail 30a g_intOrientFailureTotal=" + m_smVisionInfo.g_intOrientFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                        //}
                    }

                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        if (m_intTCPIPResultID == -1)
                            m_intTCPIPResultID = (int)TCPIPResulID.Fail;

                    return false;
                }
                else
                {
                    //objOrient.ref_objRotatedImage.CopyTo(m_smVisionInfo.g_arrRotatedImages[0]);
                }
            }

            if (m_blnWantMarkTest || m_blnWantLeadTest)
            {
                if (m_smVisionInfo.g_intOrientResult[intUnitNo] < 4)
                {
                    // Get OffSet between Orient PRS object center point and Unit Center Point 
                    int intOffSetX, intOffSetY, m_intOrientAngle;
                    switch (m_smVisionInfo.g_intOrientResult[intUnitNo])
                    {
                        default:
                        case 0:
                            intOffSetX = m_smVisionInfo.g_arrOrients[intUnitNo][0].ref_intMatcherOffSetCenterX;
                            intOffSetY = m_smVisionInfo.g_arrOrients[intUnitNo][0].ref_intMatcherOffSetCenterY;
                            m_intOrientAngle = 0;
                            break;
                        case 1:
                            intOffSetX = m_smVisionInfo.g_arrOrients[intUnitNo][0].ref_intMatcherOffSetCenterY;
                            intOffSetY = -m_smVisionInfo.g_arrOrients[intUnitNo][0].ref_intMatcherOffSetCenterX;
                            m_intOrientAngle = -90;
                            break;
                        case 2:
                            intOffSetX = -m_smVisionInfo.g_arrOrients[intUnitNo][0].ref_intMatcherOffSetCenterX;
                            intOffSetY = -m_smVisionInfo.g_arrOrients[intUnitNo][0].ref_intMatcherOffSetCenterY;
                            m_intOrientAngle = 180;
                            break;
                        case 3:
                            intOffSetX = -m_smVisionInfo.g_arrOrients[intUnitNo][0].ref_intMatcherOffSetCenterY;
                            intOffSetY = m_smVisionInfo.g_arrOrients[intUnitNo][0].ref_intMatcherOffSetCenterX;
                            m_intOrientAngle = 90;
                            break;
                    }

                    if (intUnitNo == 0)
                        m_blnOrientDataUpdated1 = true;
                    else
                        m_blnOrientDataUpdated2 = true;

                    // Get image index for measurement unit size
                    int intUnitEdgeImageIndex = 0;  //m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetGrabImageIndex(0);

                    ROI objRotatedROI = new ROI();
                    float fTotalRotateAngle = 0;
                    if (m_smVisionInfo.g_blnWantGauge)
                    {
                        RectGaugeM4L objGauge = m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo];

                        // Get Orient Center Point (Final result for next MarkTest and PackageTest)
                        m_smVisionInfo.g_fUnitCenterX[intUnitNo] = objGauge.ref_pRectCenterPoint.X - m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROITotalX;
                        m_smVisionInfo.g_fUnitCenterY[intUnitNo] = objGauge.ref_pRectCenterPoint.Y - m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROITotalY;

                        // Calculate total angle 
                        fTotalRotateAngle = m_intOrientAngle + objGauge.ref_fRectAngle;

                        // Get RotateROI where the ROI center point == Unit Center Point
                        objRotatedROI.AttachImage(m_smVisionInfo.g_arrImages[0]);

                        float fSizeX, fSizeY;
                        if ((objGauge.ref_fRectWidth + m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIWidth) > m_smVisionInfo.g_arrImages[0].ref_intImageWidth ||
                            (objGauge.ref_fRectHeight + m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIHeight) > m_smVisionInfo.g_arrImages[0].ref_intImageHeight)
                        {
                            fSizeX = m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIWidth - m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIWidth % 2; // why %2? To get "even" number
                            fSizeY = m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIHeight - m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIHeight % 2;
                        }
                        else
                        {
                            fSizeX = objGauge.ref_fRectWidth + m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIWidth - m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIWidth % 2; // why %2? To get "even" number
                            fSizeY = objGauge.ref_fRectHeight + m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIHeight - m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIHeight % 2;
                        }

                        objRotatedROI.LoadROISetting((int)Math.Round(objGauge.ref_pRectCenterPoint.X - fSizeX / 2, 0, MidpointRounding.AwayFromZero),
                                                     (int)Math.Round(objGauge.ref_pRectCenterPoint.Y - fSizeY / 2, 0, MidpointRounding.AwayFromZero),
                                                     (int)Math.Round(fSizeX, 0, MidpointRounding.AwayFromZero),
                                                     (int)Math.Round(fSizeY, 0, MidpointRounding.AwayFromZero));
                    }
                    else
                    {
                        if (m_smVisionInfo.g_arrOrientROIs[intUnitNo].Count > 3)    // Mean Unit Surface ROI exist
                        {
                            // Get Unit Surface Center Point (Final result for next MarkTest and PackageTest)
                            m_smVisionInfo.g_fUnitCenterX[intUnitNo] = fUnitPRResultCenterX + fUnitSurfaceOffsetX;
                            m_smVisionInfo.g_fUnitCenterY[intUnitNo] = fUnitPRResultCenterY + fUnitSurfaceOffsetY;

                            // Calculate total angle 
                            fTotalRotateAngle = m_intOrientAngle + fUnitPRResultAngle;

                            // Get RotateROI where the ROI center point == Unit Center Point
                            objRotatedROI.AttachImage(m_smVisionInfo.g_arrImages[0]);

                            float fSizeX, fSizeY;
                            fSizeX = m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIWidth - m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIWidth % 2; // why %2? To get "even" number
                            fSizeY = m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIHeight - m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIHeight % 2;

                            objRotatedROI.LoadROISetting(m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROITotalX +
                                                            (int)Math.Round(m_smVisionInfo.g_arrOrients[intUnitNo][m_smVisionInfo.g_intSelectedTemplate].GetUnitPRResultCenterX() -
                                                            fSizeX / 2 +
                                                            m_smVisionInfo.g_arrOrients[intUnitNo][m_smVisionInfo.g_intSelectedTemplate].ref_intUnitSurfaceOffsetX, 0, MidpointRounding.AwayFromZero),
                                                         m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROITotalY +
                                                            (int)Math.Round(m_smVisionInfo.g_arrOrients[intUnitNo][m_smVisionInfo.g_intSelectedTemplate].GetUnitPRResultCenterY() -
                                                            fSizeY / 2 +
                                                            m_smVisionInfo.g_arrOrients[intUnitNo][m_smVisionInfo.g_intSelectedTemplate].ref_intUnitSurfaceOffsetY, 0, MidpointRounding.AwayFromZero),
                                                         (int)Math.Round(fSizeX, 0, MidpointRounding.AwayFromZero),
                                                         (int)Math.Round(fSizeY, 0, MidpointRounding.AwayFromZero));
                        }
                        else
                        {

                            // Calculate total angle 
                            fTotalRotateAngle = m_intOrientAngle + m_smVisionInfo.g_arrOrients[intUnitNo][m_smVisionInfo.g_intSelectedOcv[intUnitNo]].ref_fDegAngleResult;

                            // Get RotateROI where the ROI center point == Unit Center Point
                            objRotatedROI.AttachImage(m_smVisionInfo.g_arrImages[0]);

                            float fSizeX, fSizeY;
                            fSizeX = m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIWidth - m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIWidth % 2; // why %2? To get "even" number
                            fSizeY = m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIHeight - m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIHeight % 2;

                            if (m_blnWantPackageTest && ((m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailMask & 0x1000) > 0 || m_smVisionInfo.g_arrPackage[intUnitNo].GetWantInspectPackage())) // 2020-06-23 ZJYEOH : If inspection option got tick Check package size just can use pkg gauge
                            {
                                if (intUnitNo == 0)
                                {
                                    WaitEventDone(ref m_bPackageSizePreTestDone1, true, 10000, "AAA50");

                                    if (m_bPackageSizePreTestResult1)
                                    {
                                        // Get RotateROI center point where the ROI center point == Package Unit Center Point

                                        objRotatedROI.LoadROISetting((int)Math.Round(m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X - fSizeX / 2, 0, MidpointRounding.AwayFromZero),
                                                                     (int)Math.Round(m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y - fSizeY / 2, 0, MidpointRounding.AwayFromZero),
                                                                     (int)Math.Round(fSizeX, 0, MidpointRounding.AwayFromZero),
                                                                     (int)Math.Round(fSizeY, 0, MidpointRounding.AwayFromZero));
                                       
                                        // 2020 03 03 - CCENG: Enable this command to use package angle instead of mark angle. 
                                        // 2020 05 02 - No longer need this feature because mark and package angle are separated to different images.
                                        //if (m_smVisionInfo.g_blnWantRotateMarkImageUsingPkgAngle)
                                        //    fTotalRotateAngle = m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle;
                                    }
                                    else
                                    {
                                        // 2019 09 06 - CCENG: If no package size center point, then use Orient Search ROI Center Point
                                        objRotatedROI.LoadROISetting((int)Math.Round(m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROITotalCenterX - fSizeX / 2, 0, MidpointRounding.AwayFromZero),
                                                                    (int)Math.Round(m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROITotalCenterY - fSizeY / 2, 0, MidpointRounding.AwayFromZero),
                                                                    (int)Math.Round(fSizeX, 0, MidpointRounding.AwayFromZero),
                                                                    (int)Math.Round(fSizeY, 0, MidpointRounding.AwayFromZero));
                                    }
                                }
                                else
                                {
                                    WaitEventDone(ref m_bPackageSizePreTestDone2, true, 10000, "AAA51");

                                    if (m_bPackageSizePreTestResult2)
                                    {
                                        // Get RotateROI center point where the ROI center point == Package Unit Center Point

                                        objRotatedROI.LoadROISetting((int)Math.Round(m_smVisionInfo.g_objGauge_PkgSize2.ref_pRectCenterPoint.X - fSizeX / 2, 0, MidpointRounding.AwayFromZero),
                                                                     (int)Math.Round(m_smVisionInfo.g_objGauge_PkgSize2.ref_pRectCenterPoint.Y - fSizeY / 2, 0, MidpointRounding.AwayFromZero),
                                                                     (int)Math.Round(fSizeX, 0, MidpointRounding.AwayFromZero),
                                                                     (int)Math.Round(fSizeY, 0, MidpointRounding.AwayFromZero));
                                        
                                        // 2020 03 03 - CCENG: Enable this command to use package angle instead of mark angle. 
                                        // 2020 05 02 - No longer need this feature because mark and package angle are separated to different images.
                                        //if (m_smVisionInfo.g_blnWantRotateMarkImageUsingPkgAngle)
                                        //    fTotalRotateAngle = m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle;
                                    }
                                    else
                                    {
                                        // 2019 09 06 - CCENG: If no package size center point, then use Orient Search ROI Center Point
                                        objRotatedROI.LoadROISetting((int)Math.Round(m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROITotalCenterX - fSizeX / 2, 0, MidpointRounding.AwayFromZero),
                                                                    (int)Math.Round(m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROITotalCenterY - fSizeY / 2, 0, MidpointRounding.AwayFromZero),
                                                                    (int)Math.Round(fSizeX, 0, MidpointRounding.AwayFromZero),
                                                                    (int)Math.Round(fSizeY, 0, MidpointRounding.AwayFromZero));
                                    }
                                }
                            }
                            else
                            {
                                // 2019 09 06 - CCENG: If no package size center point, then use Orient Search ROI Center Point
                                objRotatedROI.LoadROISetting((int)Math.Round(m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROITotalCenterX - fSizeX / 2, 0, MidpointRounding.AwayFromZero),
                                                             (int)Math.Round(m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROITotalCenterY - fSizeY / 2, 0, MidpointRounding.AwayFromZero),
                                                             (int)Math.Round(fSizeX, 0, MidpointRounding.AwayFromZero),
                                                             (int)Math.Round(fSizeY, 0, MidpointRounding.AwayFromZero));

                            }

                        }
                    }

                    // Start Rotate image 1, 2 and 3 to zero orientation and zero angle degree.
                    if (intUnitNo == 1)
                    {
                        // 2020 05 02 - CCENG: Not sure how to handle this ocv angle and package angle 
                        //ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[0], objRotatedROI, fTotalRotateAngle, ref m_smVisionInfo.g_arrRotatedImages, 0);

                        if (m_blnWantPackageTest && ((m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailMask & 0x1000) > 0 || m_smVisionInfo.g_arrPackage[intUnitNo].GetWantInspectPackage())) // 2020-06-23 ZJYEOH : If inspection option got tick Check package size just can use pkg gauge
                        {
                            //2020-11-07 ZJYEOH : Need to wait package gauge measure finish just can take the angle 
                            WaitEventDone(ref m_bPackageSizePreTestDone2, true, 10000, "AAA52");

                            if (m_bPackageSizePreTestResult2)
                            {
                                ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[0], objRotatedROI, m_smVisionInfo.g_objGauge_PkgSize2.ref_fRectAngle, m_smVisionInfo.g_intRotationInterpolation_Mark, ref m_smVisionInfo.g_arrRotatedImages, 0);
                            }
                            else
                                ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[0], objRotatedROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_Mark, ref m_smVisionInfo.g_arrRotatedImages, 0);
                        }
                        else
                            ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[0], objRotatedROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_Mark, ref m_smVisionInfo.g_arrRotatedImages, 0);

                        m_blnRotateImage1Updated = true;

                        // 2020 04 19 - cceng: Rotate image to mark 0 deg
                        ROI.Rotate0Degree_Better(m_smVisionInfo.g_arrImages[0], objRotatedROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_Mark, ref m_smVisionInfo.g_objMarkImage);

                    }
                    else
                    {
                        if (m_smVisionInfo.g_intUnitsOnImage > 1 && (((m_intScenario & 0x02) > 0) || !blnAuto))
                        {
                            if (m_smVisionInfo.g_blnWantGauge)
                            {
                                // 2020 05 02 - Not sure how to handle this ocv angle and package angle 
                                // Rotate from rotated image if unit 1 is tested
                                ROI.Rotate0Degree(m_objPreviousRotatedImage, objRotatedROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_Mark, ref m_smVisionInfo.g_arrRotatedImages, 0);
                            }
                            else
                            {
                                // 2020 05 02 - Not sure how to handle this ocv angle and package angle 
                                // Rotate from main image if unit 1 no tested (scenario == 0x02)
                                m_smVisionInfo.g_arrRotatedImages[0].CopyTo(ref m_objPreviousRotatedImage);//2020-11-11 ZJYEOH : Use rotated image to rotate so that both unit will rotate
                                ROI.Rotate0Degree(m_objPreviousRotatedImage, objRotatedROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_Mark, ref m_smVisionInfo.g_arrRotatedImages, 0);
                            }
                        }
                        else
                        {
                            // Rotate from main image if unit 1 no tested (scenario == 0x02)
                            //ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[0], objRotatedROI, fTotalRotateAngle, ref m_smVisionInfo.g_arrRotatedImages, 0);

                            if (m_blnWantPackageTest && ((m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailMask & 0x1000) > 0 || m_smVisionInfo.g_arrPackage[intUnitNo].GetWantInspectPackage())) // 2020-06-23 ZJYEOH : If inspection option got tick Check package size just can use pkg gauge
                            {
                                //2020-11-07 ZJYEOH : Need to wait package gauge measure finish just can take the angle 
                                WaitEventDone(ref m_bPackageSizePreTestDone1, true, 10000, "AAA53");

                                if (m_bPackageSizePreTestResult1)
                                {
                                    ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[0], objRotatedROI, m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle, m_smVisionInfo.g_intRotationInterpolation_Mark, ref m_smVisionInfo.g_arrRotatedImages, 0);
                                }
                                else
                                    ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[0], objRotatedROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_Mark, ref m_smVisionInfo.g_arrRotatedImages, 0);

                            }
                            else
                                ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[0], objRotatedROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_Mark, ref m_smVisionInfo.g_arrRotatedImages, 0);

                            m_blnRotateImage1Updated = true;

                            // 2020 04 19 - cceng: Rotate image to mark 0 deg
                            ROI.Rotate0Degree_Better(m_smVisionInfo.g_arrImages[0], objRotatedROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_Mark, ref m_smVisionInfo.g_objMarkImage);

                            //if (m_blnWantLeadTest)
                            //{
                            //    if (m_smVisionInfo.g_arrImages.Count > m_smVisionInfo.g_arrLead[0].ref_intImageViewNo)
                            //    {
                            //        ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo], objRotatedROI, fTotalRotateAngle, ref m_smVisionInfo.g_arrRotatedImages, m_smVisionInfo.g_arrLead[0].ref_intImageViewNo);
                            //        if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 0)
                            //            m_blnRotateImage1Updated = true;
                            //        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 1)
                            //            m_blnRotateImage2Updated = true;
                            //        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 2)
                            //            m_blnRotateImage3Updated = true;
                            //        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 3)
                            //            m_blnRotateImage4Updated = true;
                            //        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 4)
                            //            m_blnRotateImage5Updated = true;
                            //    }
                            //}
                        }

                    }
                    m_fOrientFinalAngleForLead = fTotalRotateAngle - m_intOrientAngle; //2020-07-23 ZJYEOH: For later use in Lead function
                    objRotatedROI.Dispose();
                    m_blnRotateImage1Updated = true;

                    if (m_smVisionInfo.g_blnWantCheckMarkAngle)
                    {
                        int intFailMask = m_smVisionInfo.g_arrMarks[intUnitNo].GetFailOptionMask(0, m_smVisionInfo.g_intSelectedOcv[intUnitNo]);
                        if ((intFailMask & 0x2000) > 0)   // 0x2000=Mark Angle
                        {
                            if (m_smVisionInfo.g_intOrientResult[intUnitNo] < 4)    // Will only check Mark Angle if Orientation Pass
                            {
                                if (m_blnWantPackageTest && ((m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailMask & 0x1000) > 0 || m_smVisionInfo.g_arrPackage[intUnitNo].GetWantInspectPackage())) // 2020-06-23 ZJYEOH : If inspection option got tick Check package size just can use pkg gauge
                                {
                                    if (intUnitNo == 0)
                                    {
                                        WaitEventDone(ref m_bPackageSizePreTestDone1, true, 10000, "AAA54");

                                        if (m_bPackageSizePreTestResult1)
                                            m_smVisionInfo.g_fOrientAngle[intUnitNo] = m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle - m_smVisionInfo.g_fOrientAngle[intUnitNo];
                                    }
                                    else
                                    {
                                        WaitEventDone(ref m_bPackageSizePreTestDone2, true, 10000, "AAA55");

                                        if (m_bPackageSizePreTestResult2)
                                            m_smVisionInfo.g_fOrientAngle[intUnitNo] = m_smVisionInfo.g_objGauge_PkgSize2.ref_fRectAngle - m_smVisionInfo.g_fOrientAngle[intUnitNo];
                                    }

                                    if (Math.Abs(m_smVisionInfo.g_fOrientAngle[intUnitNo]) > m_smVisionInfo.g_arrMarks[intUnitNo].GetMarkAngleTolerance(0, m_smVisionInfo.g_intSelectedOcv[intUnitNo]))
                                    {
                                        m_smVisionInfo.g_strErrorMessage += "*Fail Mark Angle : Set = " +
                                                                        m_smVisionInfo.g_arrMarks[intUnitNo].GetMarkAngleTolerance(0, m_smVisionInfo.g_intSelectedOcv[intUnitNo]).ToString("f4") +
                                                                        " , Result = " + m_smVisionInfo.g_fOrientAngle[intUnitNo].ToString("f4");
                                        m_smVisionInfo.g_arrMarks[intUnitNo].ref_intTemplateIndex = m_smVisionInfo.g_intSelectedOcv[intUnitNo];

                                        m_smVisionInfo.g_blnMarkInspected = true;
                                        //2021-01-04 ZJYEOH : increase angle fail counter and save fail angle image if in production mode
                                        if (blnAuto)
                                        {
                                            m_smVisionInfo.g_intAngleFailureTotal++;
                                            SaveRejectImage_AddToBuffer("Angle", m_smVisionInfo.g_strErrorMessage);
                                        }

                                        if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                                            if (m_intTCPIPResultID == -1)
                                                m_intTCPIPResultID = (int)TCPIPResulID.Fail;//FailMark;

                                        return false;
                                    }
                                }
                                else
                                {
                                    if (!m_arrFinalPreciseAnglePass[m_smVisionInfo.g_intSelectedOcv[intUnitNo]])  // Check selected Orient have precise angle pass or not
                                    {
                                        m_smVisionInfo.g_strErrorMessage += "*Fail Mark Angle : Set = " +
                                                                        m_smVisionInfo.g_arrMarks[intUnitNo].GetMarkAngleTolerance(0, m_smVisionInfo.g_intSelectedOcv[intUnitNo]).ToString("f4") +
                                                                        " , Result = " + m_smVisionInfo.g_fOrientAngle[intUnitNo].ToString("f4");
                                        m_smVisionInfo.g_arrMarks[intUnitNo].ref_intTemplateIndex = m_smVisionInfo.g_intSelectedOcv[intUnitNo];

                                        m_smVisionInfo.g_blnMarkInspected = true;
                                        //2021-01-04 ZJYEOH : increase angle fail counter and save fail angle image if in production mode
                                        if (blnAuto)
                                        {
                                            m_smVisionInfo.g_intAngleFailureTotal++;
                                            SaveRejectImage_AddToBuffer("Angle", m_smVisionInfo.g_strErrorMessage);
                                        }

                                        if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                                            if (m_intTCPIPResultID == -1)
                                                m_intTCPIPResultID = (int)TCPIPResulID.Fail;//FailMark;

                                        return false;
                                    }
                                }
                            }
                        }
                    }
                }
                else
                {
                    m_smVisionInfo.g_arrImages[0].CopyTo(m_smVisionInfo.g_objMarkImage);
                }
            }
            else
            {
                m_smVisionInfo.g_fOrientCenterX[intUnitNo] = m_smVisionInfo.g_arrOrients[intUnitNo][m_smVisionInfo.g_intSelectedOcv[intUnitNo]].ref_fObjectX;
                m_smVisionInfo.g_fOrientCenterY[intUnitNo] = m_smVisionInfo.g_arrOrients[intUnitNo][m_smVisionInfo.g_intSelectedOcv[intUnitNo]].ref_fObjectY;
            }
            return true;
        }
        private bool StartOrientTest_using4LGauge_OcvAngleAndPackageAngle_WithoutRotate(bool blnAuto, int intUnitNo)
        {
            if ((m_smCustomizeInfo.g_intWantOrient & (1 << m_smVisionInfo.g_intVisionPos)) == 0)
                return true;

            // make sure template learn
            if (m_smVisionInfo.g_arrOrients[intUnitNo].Count == 0)
            {
                if (m_smVisionInfo.g_intUnitsOnImage == 1)
                    m_smVisionInfo.g_strErrorMessage += "*Unit" + (intUnitNo + 1) + " Orient : No Template Found";
                else
                    m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + " Orient : No Template Found";
                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 29 g_intOrientFailureTotal=" + m_smVisionInfo.g_intOrientFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                if ((intUnitNo == 1 || m_smVisionInfo.g_intUnitsOnImage == 1) && blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)
                {
                    m_smVisionInfo.g_intNoTemplateFailureTotal++;
                    //m_smVisionInfo.g_intTestedTotal++;
                    //m_smVisionInfo.g_intLowYieldUnitCount++;
                    m_blnFailCounterAdded = true;
                    m_blnTotalCounterAdded = false;

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 29a g_intOrientFailureTotal=" + m_smVisionInfo.g_intOrientFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                }
                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        m_intTCPIPResultID = (int)TCPIPResulID.Fail;

                return false;
            }

            // reset all inspection data
            for (int i = 0; i < m_smVisionInfo.g_arrOrients[intUnitNo].Count; i++)
            {
                ((Orient)m_smVisionInfo.g_arrOrients[intUnitNo][i]).ResetInspectionData();
            }

            float fUnitSurfaceOffsetX = 0;
            float fUnitSurfaceOffsetY = 0;
            float fUnitPRResultCenterX = 0;
            float fUnitPRResultCenterY = 0;
            float fUnitPRResultAngle = 0;

            // Use Gauge to find unit angle and rotate it to 0 deg
            if (m_smVisionInfo.g_blnWantGauge) // Use
            {
                if (!blnAuto)
                    m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].AttachImage(m_smVisionInfo.g_arrImages[0]);

                // Reallocate gauge position to inpocket position
                if (m_blnWantPositioning)
                {
                    if (m_smVisionInfo.MN_PR_CheckPosition)
                    {
                        m_smVisionInfo.g_arrOrientGauge[intUnitNo].SetRectGaugePlacement(
                            m_smVisionInfo.g_objPositioning.ref_fObjectCenterX,
                            m_smVisionInfo.g_objPositioning.ref_fObjectCenterY);

                        m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].LoadROISetting(
                            (int)Math.Round(m_smVisionInfo.g_objPositioning.ref_fObjectCenterX -
                             m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIWidth / 2, 0, MidpointRounding.AwayFromZero),
                             (int)Math.Round(m_smVisionInfo.g_objPositioning.ref_fObjectCenterY -
                            m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIHeight / 2, 0, MidpointRounding.AwayFromZero),
                            m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIWidth,
                            m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIHeight);
                    }
                }
                if (m_smVisionInfo.g_blnWantUseUnitPRFindGauge)// (m_smVisionInfo.g_arrOrientROIs[intUnitNo].Count > 2)
                {
                    if (m_smVisionInfo.g_arrOrients[intUnitNo][0].MatchWithTemplateUnitPR(m_smVisionInfo.g_arrOrientROIs[intUnitNo][0]))
                    {
                        // Changed m_smVisionInfo.g_arrOrients[intUnitNo][m_smVisionInfo.g_intSelectedTemplate] to m_smVisionInfo.g_arrOrients[intUnitNo][0]
                        // because when user select different template during offline test, will have different result, need to look into this case in future as may have different mark learnt as template
                        fUnitPRResultCenterX = m_smVisionInfo.g_arrOrients[intUnitNo][0].GetUnitPRResultCenterX() + m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIPositionX;
                        fUnitPRResultCenterY = m_smVisionInfo.g_arrOrients[intUnitNo][0].GetUnitPRResultCenterY() + m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIPositionY;
                        int intUnitPRWidth = m_smVisionInfo.g_arrOrients[intUnitNo][0].GetUnitPRWidth();
                        int intUnitPRHeight = m_smVisionInfo.g_arrOrients[intUnitNo][0].GetUnitPRHeight();

                        if (m_smVisionInfo.g_arrOrientGaugeM4L.Count > intUnitNo)
                            m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].SetEdgeROIPlacementLimit2(m_smVisionInfo.g_arrOrientROIs[intUnitNo][0], (int)fUnitPRResultCenterX, (int)fUnitPRResultCenterY, intUnitPRWidth, intUnitPRHeight);

                        if (m_smVisionInfo.g_arrMarkGaugeM4L.Count > intUnitNo)
                            m_smVisionInfo.g_arrMarkGaugeM4L[intUnitNo].SetEdgeROIPlacementLimit2(m_smVisionInfo.g_arrOrientROIs[intUnitNo][0], (int)fUnitPRResultCenterX, (int)fUnitPRResultCenterY, intUnitPRWidth, intUnitPRHeight);

                        if (m_smVisionInfo.g_arrPackageGaugeM4L.Count > intUnitNo)
                            m_smVisionInfo.g_arrPackageGaugeM4L[intUnitNo].SetEdgeROIPlacementLimit2(m_smVisionInfo.g_arrOrientROIs[intUnitNo][0], (int)fUnitPRResultCenterX, (int)fUnitPRResultCenterY, intUnitPRWidth, intUnitPRHeight);

                        if (m_smVisionInfo.g_arrPackageGauge2M4L.Count > intUnitNo)
                            m_smVisionInfo.g_arrPackageGauge2M4L[intUnitNo].SetEdgeROIPlacementLimit2(m_smVisionInfo.g_arrOrientROIs[intUnitNo][0], (int)fUnitPRResultCenterX, (int)fUnitPRResultCenterY, intUnitPRWidth, intUnitPRHeight);
                    }
                    else
                    {
                        //2019-10-14 ZJYEOH : If matching fail, load gauge using template unit position center 

                        if (m_smVisionInfo.g_arrOrientGaugeM4L.Count > intUnitNo)
                            m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].SetEdgeROIPlacementLimit2(m_smVisionInfo.g_arrOrientROIs[intUnitNo][0],
                                (int)m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].ref_f4LGaugeCenterPointX, (int)m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].ref_f4LGaugeCenterPointY,
                                (int)m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].ref_f4LGaugeUnitWidth, (int)m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].ref_f4LGaugeUnitHeight);

                        if (m_smVisionInfo.g_arrMarkGaugeM4L.Count > intUnitNo)
                            m_smVisionInfo.g_arrMarkGaugeM4L[intUnitNo].SetEdgeROIPlacementLimit2(m_smVisionInfo.g_arrOrientROIs[intUnitNo][0],
                                (int)m_smVisionInfo.g_arrMarkGaugeM4L[intUnitNo].ref_f4LGaugeCenterPointX, (int)m_smVisionInfo.g_arrMarkGaugeM4L[intUnitNo].ref_f4LGaugeCenterPointY,
                                (int)m_smVisionInfo.g_arrMarkGaugeM4L[intUnitNo].ref_f4LGaugeUnitWidth, (int)m_smVisionInfo.g_arrMarkGaugeM4L[intUnitNo].ref_f4LGaugeUnitHeight);

                        if (m_smVisionInfo.g_arrPackageGaugeM4L.Count > intUnitNo)
                            m_smVisionInfo.g_arrPackageGaugeM4L[intUnitNo].SetEdgeROIPlacementLimit2(m_smVisionInfo.g_arrOrientROIs[intUnitNo][0],
                                (int)m_smVisionInfo.g_arrPackageGaugeM4L[intUnitNo].ref_f4LGaugeCenterPointX, (int)m_smVisionInfo.g_arrPackageGaugeM4L[intUnitNo].ref_f4LGaugeCenterPointY,
                                (int)m_smVisionInfo.g_arrPackageGaugeM4L[intUnitNo].ref_f4LGaugeUnitWidth, (int)m_smVisionInfo.g_arrPackageGaugeM4L[intUnitNo].ref_f4LGaugeUnitHeight);

                        if (m_smVisionInfo.g_arrPackageGauge2M4L.Count > intUnitNo)
                            m_smVisionInfo.g_arrPackageGauge2M4L[intUnitNo].SetEdgeROIPlacementLimit2(m_smVisionInfo.g_arrOrientROIs[intUnitNo][0],
                                (int)m_smVisionInfo.g_arrPackageGauge2M4L[intUnitNo].ref_f4LGaugeCenterPointX, (int)m_smVisionInfo.g_arrPackageGauge2M4L[intUnitNo].ref_f4LGaugeCenterPointY,
                                (int)m_smVisionInfo.g_arrPackageGauge2M4L[intUnitNo].ref_f4LGaugeUnitWidth, (int)m_smVisionInfo.g_arrPackageGauge2M4L[intUnitNo].ref_f4LGaugeUnitHeight);

                    }
                }

                if (intUnitNo == 0)
                    m_blnOrientGaugeUpdated1 = true;
                else
                    m_blnOrientGaugeUpdated2 = true;

                // Add gain value to image and attached all position ROI to gain image.
                float fGaugeAngle;
                bool blnGaugeResult = false;
                //if (m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].ref_fGainValue != 1000)
                //{
                //    m_smVisionInfo.g_arrImages[0].AddGain(ref m_objOrientGainImage, m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].ref_fGainValue / 1000);
                //    m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].SetGaugePlace_BasedOnEdgeROI();
                //    blnGaugeResult = m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].Measure_WithDontCareArea(m_objOrientGainImage, m_smVisionInfo.g_objWhiteImage);
                //    fGaugeAngle = m_fOrientGauge = m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].ref_fRectAngle;
                //}
                //else
                {
                    m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].SetGaugePlace_BasedOnEdgeROI();
                    blnGaugeResult = m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].Measure_WithDontCareArea(m_smVisionInfo.g_arrImages, m_smVisionInfo.g_objWhiteImage);
                    fGaugeAngle = m_fOrientGauge = m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].ref_fRectAngle;
                }
                if (!blnGaugeResult)
                {
                    m_smVisionInfo.g_strErrorMessage += "*Orient : " + m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].ref_strErrorMessage;
                    // if (blnAuto)
                    if (blnAuto)
                    {
                        SaveRejectImage_AddToBuffer("EdgeNotFound", "*Orient : " + m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].ref_strErrorMessage);
                    }
                    if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                    {
                        m_smVisionInfo.g_intEdgeNotFoundFailureTotal++;
                        //SaveRejectImage_AddToBuffer("EdgeNotFound", "*Orient : " + m_smVisionInfo.g_arrOrientGaugeM4L[0].ref_strErrorMessage);
                        m_blnFailCounterAdded = true;
                        m_blnTotalCounterAdded = false;
                    }

                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        if (m_intTCPIPResultID == -1)
                            m_intTCPIPResultID = (int)TCPIPResulID.Fail;

                    m_smVisionInfo.g_blnViewGaugeNotFound = true;
                    m_smVisionInfo.g_blnViewOrientObject = true;
                    return false;
                }

                //// RotateROI has same center point with gauge measure center point.
                //ROI objRotateROI = new ROI();
                //objRotateROI.AttachImage(m_smVisionInfo.g_arrImages[0]);
                //objRotateROI.LoadROISetting(
                //    (int)Math.Round(m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].ref_pRectCenterPoint.X -
                //    m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIWidth / 2, 0, MidpointRounding.AwayFromZero),
                //    (int)Math.Round(m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo].ref_pRectCenterPoint.Y -
                //    m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIHeight / 2, 0, MidpointRounding.AwayFromZero),
                //    m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIWidth,
                //    m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIHeight);

                //if (intUnitNo == 1)
                //{

                //    ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[0], objRotateROI, fGaugeAngle, 0, ref m_smVisionInfo.g_arrRotatedImages, 0);
                //}
                //else
                //{

                //    if (((m_intScenario & 0x02) > 0) || !blnAuto)
                //    {
                //        // Rotate from rotated image if unit 1 is tested
                //        m_smVisionInfo.g_arrRotatedImages[0].CopyTo(ref m_objPreviousRotatedImage);
                //        ROI.Rotate0Degree(m_objPreviousRotatedImage, objRotateROI, fGaugeAngle, 0, ref m_smVisionInfo.g_arrRotatedImages, 0);
                //    }
                //    else
                //    {
                //        // Rotate from main image if unit 1 no tested (scenario == 0x02)
                //        ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[0], objRotateROI, fGaugeAngle, 0, ref m_smVisionInfo.g_arrRotatedImages, 0);
                //    }

                //}

                //objRotateROI.Dispose();

                m_smVisionInfo.g_arrImages[0].CopyTo(ref m_objPreviousRotatedImage);
            }
            else // No rect gauge
            {
                //2021-08-20 ZJYEOH : No need purpose rotate
                //// If Lead Unit, use unit lead pattern to find unit surface ROI
                //if (((m_smCustomizeInfo.g_intWantLead & (1 << m_smVisionInfo.g_intVisionPos)) > 0) && m_smVisionInfo.g_arrOrients[intUnitNo][m_smVisionInfo.g_intSelectedTemplate].ref_blnUnitPRMatcherExist)
                //{
                //    m_smVisionInfo.g_arrOrients[intUnitNo][m_smVisionInfo.g_intSelectedTemplate].MatchWithTemplateUnitPR(m_smVisionInfo.g_arrOrientROIs[intUnitNo][0]);
                //    fUnitPRResultCenterX = m_smVisionInfo.g_arrOrients[intUnitNo][m_smVisionInfo.g_intSelectedTemplate].GetUnitPRResultCenterX();
                //    fUnitPRResultCenterY = m_smVisionInfo.g_arrOrients[intUnitNo][m_smVisionInfo.g_intSelectedTemplate].GetUnitPRResultCenterY();
                //    fUnitPRResultAngle = m_smVisionInfo.g_arrOrients[intUnitNo][m_smVisionInfo.g_intSelectedTemplate].GetUnitPRResultAngle();
                //    fUnitSurfaceOffsetX = m_smVisionInfo.g_arrOrients[intUnitNo][m_smVisionInfo.g_intSelectedTemplate].ref_intUnitSurfaceOffsetX;
                //    fUnitSurfaceOffsetY = m_smVisionInfo.g_arrOrients[intUnitNo][m_smVisionInfo.g_intSelectedTemplate].ref_intUnitSurfaceOffsetY;

                //    if (!Math2.GetNewXYAfterRotate(m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROITotalX + fUnitPRResultCenterX,
                //                                  m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROITotalY + fUnitPRResultCenterY,
                //                                  fUnitSurfaceOffsetX,
                //                                  fUnitSurfaceOffsetY,
                //                                  fUnitPRResultAngle,
                //                                  ref fUnitSurfaceOffsetX,
                //                                  ref fUnitSurfaceOffsetY))
                //    { }

                //    //ROI objRotateROI = new ROI();
                //    //objRotateROI.AttachImage(m_smVisionInfo.g_arrImages[0]);
                //    //objRotateROI.LoadROISetting(
                //    //    (int)Math.Round(m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROITotalX +
                //    //    fUnitPRResultCenterX -
                //    //    m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIWidth / 2 +
                //    //    fUnitSurfaceOffsetX, 0, MidpointRounding.AwayFromZero),
                //    //    (int)Math.Round(m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROITotalY +
                //    //    fUnitPRResultCenterY -
                //    //    m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIHeight / 2 +
                //    //    fUnitSurfaceOffsetY, 0, MidpointRounding.AwayFromZero),
                //    //    m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIWidth,
                //    //    m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIHeight);


                //    //// Rotate unit to exact 0 degree (m_fOrientGauge used in Package)
                //    //ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[0], objRotateROI, fUnitPRResultAngle, 0, ref m_smVisionInfo.g_arrRotatedImages, 0); // Clear image is not so important in Orient Matching. Use interpolation 0 to save rotation time.

                //    //objRotateROI.Dispose();
                //}
                //else // if not lead unit, mean it is QFN. There is no way to find unit surface ROI without gauge tool.
                {
                    m_smVisionInfo.g_arrImages[0].CopyTo(m_smVisionInfo.g_arrRotatedImages[0]);
                    if (intUnitNo == 0)
                        m_blnOrientGaugeUpdated1 = true;
                    else
                        m_blnOrientGaugeUpdated2 = true;
                }
            }

            int intMatchCount = 0;
            bool blnRecipeCorrupted = false;
            m_smVisionInfo.g_intOrientResult[intUnitNo] = -1;  // 0:0deg, 1:90deg, 2:180deg, 3:-90, 4:Fail
            m_arrFinalPreciseAnglePass.Clear();
            // Single template test
            if (!blnAuto && !m_smVisionInfo.g_blnInspectAllTemplate)
            {
                m_smVisionInfo.g_intOrientResult[intUnitNo] = m_smVisionInfo.g_arrOrients[intUnitNo][m_smVisionInfo.g_intSelectedTemplate].MatchWithTemplate(
                    m_smVisionInfo.g_arrOrientROIs[intUnitNo][0], m_smVisionInfo.g_arrImages[0], true);
                m_smVisionInfo.g_intSelectedOcv[intUnitNo] = m_smVisionInfo.g_intSelectedTemplate;
                m_smVisionInfo.g_fOrientScore[intUnitNo] = m_smVisionInfo.g_arrOrients[intUnitNo][m_smVisionInfo.g_intSelectedTemplate].GetMinScore();
            }
            else // Whole active templates test
            {
                float fHighestScore = -1;

                do
                {
                    int intTemplateIndex = (int)((m_smVisionInfo.g_intTemplatePriority >> (0x04 * intMatchCount)) & 0x0F) - 1;
                    if (intTemplateIndex >= 0)
                    {
                        int intAngle;
                        m_arrFinalPreciseAnglePass.Add(true);
                        bool blnPreciseAngleResult = true;
                        if (m_smVisionInfo.g_intTemplateMask == 0 || (m_smVisionInfo.g_intTemplateMask & (1 << intTemplateIndex)) > 0)
                        {
                            if (((m_smCustomizeInfo.g_intWantMark & (1 << m_smVisionInfo.g_intVisionPos)) > 0) || ((m_smCustomizeInfo.g_intWantOCR & (1 << m_smVisionInfo.g_intVisionPos)) > 0) ||
                                (m_smCustomizeInfo.g_intWantPackage & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
                            {
                                m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].AttachImage(m_smVisionInfo.g_arrImages[0]);

                                intAngle = m_smVisionInfo.g_arrOrients[intUnitNo][intTemplateIndex].DoOrientationInspection(
                                m_smVisionInfo.g_arrOrientROIs[intUnitNo][0], m_smVisionInfo.g_intFinalReduction_Direction, m_smVisionInfo.g_intFinalReduction_MarkDeg, false, !m_smVisionInfo.g_blnWantGauge, //m_smVisionInfo.g_arrOrientROIs[0][0], 2, !m_smVisionInfo.g_blnWantGauge,
                                m_smVisionInfo.g_arrMarks[intUnitNo].GetMarkAngleTolerance(0, intTemplateIndex),
                                ref blnPreciseAngleResult, ((m_smCustomizeInfo.g_intWantLead & (1 << m_smVisionInfo.g_intVisionPos)) > 0),
                                !m_smVisionInfo.g_blnWhiteOnBlack);  // Use FinalReduction=2 because match center point is not very important in MarkOrient Test.

                                if (!blnPreciseAngleResult)
                                    m_arrFinalPreciseAnglePass[intTemplateIndex] = false;

                                //intAngle = m_smVisionInfo.g_arrOrients[intUnitNo][intTemplateIndex].DoOrientationInspection(
                                //    m_smVisionInfo.g_arrOrientROIs[intUnitNo][0], 2, !m_smVisionInfo.g_blnWantGauge);   // Use FinalReduction=2 because match center point is not very important in MarkOrient Test.
                            }
                            else
                            {
                                intAngle = m_smVisionInfo.g_arrOrients[intUnitNo][intTemplateIndex].MatchWithTemplate(
                                    m_smVisionInfo.g_arrOrientROIs[intUnitNo][0], m_smVisionInfo.g_arrImages[0], true, fHighestScore, false,
                                    m_smVisionInfo.g_blnWantSubROI && (m_smVisionInfo.g_arrOrientROIs[intUnitNo].Count > 2));
                            }

                            if (m_smVisionInfo.g_arrOrients[intUnitNo][intTemplateIndex].GetMinScore() > fHighestScore)
                            {
                                fHighestScore = m_smVisionInfo.g_fOrientScore[intUnitNo] = m_smVisionInfo.g_arrOrients[intUnitNo][intTemplateIndex].GetMinScore();
                                m_smVisionInfo.g_intSelectedOcv[intUnitNo] = intTemplateIndex;
                                m_smVisionInfo.g_intOrientResult[intUnitNo] = intAngle;

                            }
                        }
                    }
                    else
                        blnRecipeCorrupted = true;
                    intMatchCount++;
                    //} while ((fHighestScore < 0.8) && (intMatchCount < m_smVisionInfo.g_arrOrients[intUnitNo].Count));
                } while (intMatchCount < m_smVisionInfo.g_arrOrients[intUnitNo].Count);
            }

            Orient objOrient = m_smVisionInfo.g_arrOrients[intUnitNo][m_smVisionInfo.g_intSelectedOcv[intUnitNo]];

            m_smVisionInfo.g_fOrientCenterX[intUnitNo] = objOrient.ref_fObjectX;
            m_smVisionInfo.g_fOrientCenterY[intUnitNo] = objOrient.ref_fObjectY;
            m_smVisionInfo.g_fOrientAngle[intUnitNo] = objOrient.ref_fDegAngleResult;
            m_smVisionInfo.g_fOrientScore[intUnitNo] = objOrient.GetMinScore();
            m_smVisionInfo.g_blnViewOrientObject = true;

            if ((m_smCustomizeInfo.g_intWantRotatorSignal & (0x01 << m_smVisionInfo.g_intVisionPos)) > 0)
            {
                bool blnResult = false;
                if (!m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                {
                    switch (m_smVisionInfo.g_intOrientResult[intUnitNo])
                    {
                        case 0:
                            if (m_objVisionIO.RotatorSignal1.IsOff() && m_objVisionIO.RotatorSignal2.IsOff())
                                blnResult = true;
                            break;
                        case 1:
                            if (m_objVisionIO.RotatorSignal1.IsOn() && m_objVisionIO.RotatorSignal2.IsOff())
                                blnResult = true;
                            break;
                        case 2:
                            if (m_objVisionIO.RotatorSignal1.IsOn() && m_objVisionIO.RotatorSignal2.IsOn())
                                blnResult = true;
                            break;
                        case 3:
                            if (m_objVisionIO.RotatorSignal1.IsOff() && m_objVisionIO.RotatorSignal2.IsOn())
                                blnResult = true;
                            break;
                    }
                }
                else
                {
                    switch (m_smVisionInfo.g_intOrientResult[intUnitNo])
                    {
                        case 0:
                            if (!m_blnRotatorSignal1_In && !m_blnRotatorSignal2_In)
                                blnResult = true;
                            break;
                        case 1:
                            if (m_blnRotatorSignal1_In && !m_blnRotatorSignal2_In)
                                blnResult = true;
                            break;
                        case 2:
                            if (m_blnRotatorSignal1_In && m_blnRotatorSignal2_In)
                                blnResult = true;
                            break;
                        case 3:
                            if (!m_blnRotatorSignal1_In && m_blnRotatorSignal2_In)
                                blnResult = true;
                            break;
                    }
                }

                if (blnResult)
                {
                    if (objOrient.ref_strErrorMessage == "")
                    {
                        if (m_smVisionInfo.g_intUnitsOnImage == 1)
                            m_smVisionInfo.g_strErrorMessage += "*Unit" + (intUnitNo + 1) + " Fail Orient!";
                        else
                            m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + " Fail Orient!";
                    }
                    else
                    {
                        if (m_smVisionInfo.g_intUnitsOnImage == 1)
                            m_smVisionInfo.g_strErrorMessage += "*Unit" + (intUnitNo + 1) + " " + objOrient.ref_strErrorMessage;
                        else
                            m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + objOrient.ref_strErrorMessage;
                    }

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 30 g_intOrientFailureTotal=" + m_smVisionInfo.g_intOrientFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                    if (blnAuto)
                    {
                        if (objOrient.ref_strErrorMessage == "")
                        {
                            if (m_smVisionInfo.g_intUnitsOnImage == 1)
                                SaveRejectImage_AddToBuffer("Orient", "*Unit" + (intUnitNo + 1) + " Fail Orient!");
                            else
                                SaveRejectImage_AddToBuffer("Orient", GetUnitName(intUnitNo) + " Fail Orient!");
                        }
                        else
                        {
                            if (m_smVisionInfo.g_intUnitsOnImage == 1)
                                SaveRejectImage_AddToBuffer("Orient", "*Unit" + (intUnitNo + 1) + " " + objOrient.ref_strErrorMessage);
                            else
                                SaveRejectImage_AddToBuffer("Orient", GetUnitName(intUnitNo) + " " + objOrient.ref_strErrorMessage);
                        }

                        if (m_smVisionInfo.g_intUnitsOnImage == 1 && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)
                        {
                            m_smVisionInfo.g_intOrientFailureTotal++;
                            //m_smVisionInfo.g_intTestedTotal++;
                            //m_smVisionInfo.g_intLowYieldUnitCount++;
                            m_blnFailCounterAdded = true;
                            m_blnTotalCounterAdded = false;
                            //m_blnFailCounterAddedForUnit2 = true;
                            if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 30a g_intMarkFailureTotal=" + m_smVisionInfo.g_intMarkFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                        }

                        // 17-07-2019 ZJYEOH : Added this condition so that fail counter will increment, when enter this condition means retest pass and current unit fail 
                        if ((intUnitNo == 1 && m_smVisionInfo.g_intUnitsOnImage == 2) && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)
                        {
                            m_smVisionInfo.g_intOrientFailureTotal++;
                            //m_smVisionInfo.g_intTestedTotal++;
                            //m_smVisionInfo.g_intLowYieldUnitCount++;
                            m_blnFailCounterAdded = true;
                            m_blnTotalCounterAdded = false;
                            if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 30b g_intMarkFailureTotal=" + m_smVisionInfo.g_intMarkFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                        }

                        //if ((intUnitNo == 1 || m_smVisionInfo.g_intUnitsOnImage == 1) && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)
                        //{
                        //    m_smVisionInfo.g_intOrientFailureTotal++;
                        //    //m_smVisionInfo.g_intTestedTotal++;
                        //    //m_smVisionInfo.g_intLowYieldUnitCount++;
                        //    m_blnFailCounterAdded = true;
                        //    m_blnTotalCounterAdded = false;
                        //    m_blnFailCounterAddedForUnit2 = true;
                        //    //STTrackLog.WriteLine("Fail 30a g_intOrientFailureTotal=" + m_smVisionInfo.g_intOrientFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                        //}

                        //// 17-07-2019 ZJYEOH : Added this condition so that fail counter will increment, when enter this condition means retest pass and current unit fail 
                        //if ((intUnitNo == 0 && m_smVisionInfo.g_intUnitsOnImage == 2) && m_smVisionInfo.g_blnInPocketRetestEnd && (!m_blnFailCounterAdded || m_blnFailCounterAddedForUnit2))
                        //{
                        //    m_smVisionInfo.g_intOrientFailureTotal++;
                        //    //m_smVisionInfo.g_intTestedTotal++;
                        //    //m_smVisionInfo.g_intLowYieldUnitCount++;
                        //    m_blnFailCounterAdded = true;
                        //    m_blnTotalCounterAdded = false;
                        //    //STTrackLog.WriteLine("Fail 30a g_intOrientFailureTotal=" + m_smVisionInfo.g_intOrientFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                        //}
                    }

                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        if (m_intTCPIPResultID == -1)
                            m_intTCPIPResultID = (int)TCPIPResulID.Fail;

                    return false;
                }
                else                      // End ByPass1
                {
                    objOrient.ref_objRotatedImage.CopyTo(m_smVisionInfo.g_arrRotatedImages[0]);
                }
            }
            else
            {
                // 2020 05 09 - CCENG : let orientation result always 0
                m_smVisionInfo.g_intOrientResult[intUnitNo] = 0;

                // Unit fail if angle is 90, 180, -90
                if (m_smVisionInfo.g_intOrientResult[intUnitNo] != 0)
                {
                    if ((!m_blnWantPackageTest || (m_blnWantPackageTest && ((m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailMask & 0x1000) == 0 && !m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetWantInspectPackage()))) && !m_blnWantLeadTest)
                        m_blnRotateImage1Updated = true; // 2020-02-18 ZJYEOH : Need to update this parameter to draw rotated image
                    //if ((m_smCustomizeInfo.g_intWantOrient0Deg & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
                    //{
                    return true; // always return true, because InPocket no display orient result
                    //}

                    if (objOrient.ref_strErrorMessage == "")
                    {
                        if (blnRecipeCorrupted)
                            m_smVisionInfo.g_strErrorMessage = "*Recipe is corrupted. Please relearn.";
                        else
                        {
                            if (m_smVisionInfo.g_intUnitsOnImage == 1)
                                m_smVisionInfo.g_strErrorMessage += "*Unit" + (intUnitNo + 1) + " Fail Orient!";
                            else
                                m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + " Fail Orient!";
                        }
                    }
                    else
                    {
                        if (m_smVisionInfo.g_intUnitsOnImage == 1)
                            m_smVisionInfo.g_strErrorMessage += "*Unit" + (intUnitNo + 1) + " " + objOrient.ref_strErrorMessage;
                        else
                            m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + objOrient.ref_strErrorMessage;
                    }

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 31 g_intOrientFailureTotal=" + m_smVisionInfo.g_intOrientFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                    if (blnAuto)
                    {
                        if (objOrient.ref_strErrorMessage == "")
                        {
                            if (blnRecipeCorrupted)
                                SaveRejectImage_AddToBuffer("Orient", "*Recipe is corrupted. Please relearn.");
                            else
                            {
                                if (m_smVisionInfo.g_intUnitsOnImage == 1)
                                    SaveRejectImage_AddToBuffer("Orient", "*Unit" + (intUnitNo + 1) + " Fail Orient!");
                                else
                                    SaveRejectImage_AddToBuffer("Orient", GetUnitName(intUnitNo) + " Fail Orient!");
                            }
                        }
                        else
                        {
                            if (m_smVisionInfo.g_intUnitsOnImage == 1)
                                SaveRejectImage_AddToBuffer("Orient", "*Unit" + (intUnitNo + 1) + " " + objOrient.ref_strErrorMessage);
                            else
                                SaveRejectImage_AddToBuffer("Orient", GetUnitName(intUnitNo) + objOrient.ref_strErrorMessage);
                        }

                        if (m_smVisionInfo.g_intUnitsOnImage == 1 && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)
                        {
                            m_smVisionInfo.g_intOrientFailureTotal++;
                            //m_smVisionInfo.g_intTestedTotal++;
                            //m_smVisionInfo.g_intLowYieldUnitCount++;
                            m_blnFailCounterAdded = true;
                            m_blnTotalCounterAdded = false;
                            //m_blnFailCounterAddedForUnit2 = true;
                            if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 31a g_intMarkFailureTotal=" + m_smVisionInfo.g_intMarkFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                        }

                        // 17-07-2019 ZJYEOH : Added this condition so that fail counter will increment, when enter this condition means retest pass and current unit fail 
                        if ((intUnitNo == 1 && m_smVisionInfo.g_intUnitsOnImage == 2) && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)
                        {
                            m_smVisionInfo.g_intOrientFailureTotal++;
                            //m_smVisionInfo.g_intTestedTotal++;
                            //m_smVisionInfo.g_intLowYieldUnitCount++;
                            m_blnFailCounterAdded = true;
                            m_blnTotalCounterAdded = false;
                            if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 31b g_intMarkFailureTotal=" + m_smVisionInfo.g_intMarkFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                        }

                        //if ((intUnitNo == 1 || m_smVisionInfo.g_intUnitsOnImage == 1) && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)
                        //{
                        //    m_smVisionInfo.g_intOrientFailureTotal++;
                        //    //m_smVisionInfo.g_intTestedTotal++;
                        //    //m_smVisionInfo.g_intLowYieldUnitCount++;
                        //    m_blnFailCounterAdded = true;
                        //    m_blnTotalCounterAdded = false;
                        //    m_blnFailCounterAddedForUnit2 = true;
                        //    //STTrackLog.WriteLine("Fail 31a g_intOrientFailureTotal=" + m_smVisionInfo.g_intOrientFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                        //}

                        //// 17-07-2019 ZJYEOH : Added this condition so that fail counter will increment, when enter this condition means retest pass and current unit fail 
                        //if ((intUnitNo == 0 && m_smVisionInfo.g_intUnitsOnImage == 2) && m_smVisionInfo.g_blnInPocketRetestEnd && (!m_blnFailCounterAdded || m_blnFailCounterAddedForUnit2))
                        //{
                        //    m_smVisionInfo.g_intOrientFailureTotal++;
                        //    //m_smVisionInfo.g_intTestedTotal++;
                        //    //m_smVisionInfo.g_intLowYieldUnitCount++;
                        //    m_blnFailCounterAdded = true;
                        //    m_blnTotalCounterAdded = false;
                        //    //STTrackLog.WriteLine("Fail 30a g_intOrientFailureTotal=" + m_smVisionInfo.g_intOrientFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                        //}
                    }
                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        if (m_intTCPIPResultID == -1)
                            m_intTCPIPResultID = (int)TCPIPResulID.Fail;

                    return false;
                }
                else
                {
                    //objOrient.ref_objRotatedImage.CopyTo(m_smVisionInfo.g_arrRotatedImages[0]);
                }
            }

            if (m_blnWantMarkTest || m_blnWantLeadTest)
            {
                if (m_smVisionInfo.g_intOrientResult[intUnitNo] < 4)
                {
                    // Get OffSet between Orient PRS object center point and Unit Center Point 
                    int intOffSetX, intOffSetY, m_intOrientAngle;
                    switch (m_smVisionInfo.g_intOrientResult[intUnitNo])
                    {
                        default:
                        case 0:
                            intOffSetX = m_smVisionInfo.g_arrOrients[intUnitNo][0].ref_intMatcherOffSetCenterX;
                            intOffSetY = m_smVisionInfo.g_arrOrients[intUnitNo][0].ref_intMatcherOffSetCenterY;
                            m_intOrientAngle = 0;
                            break;
                        case 1:
                            intOffSetX = m_smVisionInfo.g_arrOrients[intUnitNo][0].ref_intMatcherOffSetCenterY;
                            intOffSetY = -m_smVisionInfo.g_arrOrients[intUnitNo][0].ref_intMatcherOffSetCenterX;
                            m_intOrientAngle = -90;
                            break;
                        case 2:
                            intOffSetX = -m_smVisionInfo.g_arrOrients[intUnitNo][0].ref_intMatcherOffSetCenterX;
                            intOffSetY = -m_smVisionInfo.g_arrOrients[intUnitNo][0].ref_intMatcherOffSetCenterY;
                            m_intOrientAngle = 180;
                            break;
                        case 3:
                            intOffSetX = -m_smVisionInfo.g_arrOrients[intUnitNo][0].ref_intMatcherOffSetCenterY;
                            intOffSetY = m_smVisionInfo.g_arrOrients[intUnitNo][0].ref_intMatcherOffSetCenterX;
                            m_intOrientAngle = 90;
                            break;
                    }

                    if (intUnitNo == 0)
                        m_blnOrientDataUpdated1 = true;
                    else
                        m_blnOrientDataUpdated2 = true;

                    // Get image index for measurement unit size
                    int intUnitEdgeImageIndex = 0;  //m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetGrabImageIndex(0);

                    //ROI objRotatedROI = new ROI();
                    float fTotalRotateAngle = 0;
                    if (m_smVisionInfo.g_blnWantGauge)
                    {
                        RectGaugeM4L objGauge = m_smVisionInfo.g_arrOrientGaugeM4L[intUnitNo];

                        // Get Orient Center Point (Final result for next MarkTest and PackageTest)
                        m_smVisionInfo.g_fUnitCenterX[intUnitNo] = objGauge.ref_pRectCenterPoint.X - m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROITotalX;
                        m_smVisionInfo.g_fUnitCenterY[intUnitNo] = objGauge.ref_pRectCenterPoint.Y - m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROITotalY;

                        // Calculate total angle 
                        fTotalRotateAngle = m_intOrientAngle + objGauge.ref_fRectAngle;

                        //// Get RotateROI where the ROI center point == Unit Center Point
                        //objRotatedROI.AttachImage(m_smVisionInfo.g_arrImages[0]);

                        //float fSizeX, fSizeY;
                        //if ((objGauge.ref_fRectWidth + m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIWidth) > m_smVisionInfo.g_arrImages[0].ref_intImageWidth ||
                        //    (objGauge.ref_fRectHeight + m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIHeight) > m_smVisionInfo.g_arrImages[0].ref_intImageHeight)
                        //{
                        //    fSizeX = m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIWidth - m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIWidth % 2; // why %2? To get "even" number
                        //    fSizeY = m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIHeight - m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIHeight % 2;
                        //}
                        //else
                        //{
                        //    fSizeX = objGauge.ref_fRectWidth + m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIWidth - m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIWidth % 2; // why %2? To get "even" number
                        //    fSizeY = objGauge.ref_fRectHeight + m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIHeight - m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIHeight % 2;
                        //}

                        //objRotatedROI.LoadROISetting((int)Math.Round(objGauge.ref_pRectCenterPoint.X - fSizeX / 2, 0, MidpointRounding.AwayFromZero),
                        //                             (int)Math.Round(objGauge.ref_pRectCenterPoint.Y - fSizeY / 2, 0, MidpointRounding.AwayFromZero),
                        //                             (int)Math.Round(fSizeX, 0, MidpointRounding.AwayFromZero),
                        //                             (int)Math.Round(fSizeY, 0, MidpointRounding.AwayFromZero));
                    }
                    else
                    {
                        if (m_smVisionInfo.g_arrOrientROIs[intUnitNo].Count > 3)    // Mean Unit Surface ROI exist
                        {
                            // Get Unit Surface Center Point (Final result for next MarkTest and PackageTest)
                            m_smVisionInfo.g_fUnitCenterX[intUnitNo] = fUnitPRResultCenterX + fUnitSurfaceOffsetX;
                            m_smVisionInfo.g_fUnitCenterY[intUnitNo] = fUnitPRResultCenterY + fUnitSurfaceOffsetY;

                            // Calculate total angle 
                            fTotalRotateAngle = m_intOrientAngle + fUnitPRResultAngle;

                            //// Get RotateROI where the ROI center point == Unit Center Point
                            //objRotatedROI.AttachImage(m_smVisionInfo.g_arrImages[0]);

                            //float fSizeX, fSizeY;
                            //fSizeX = m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIWidth - m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIWidth % 2; // why %2? To get "even" number
                            //fSizeY = m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIHeight - m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIHeight % 2;

                            //objRotatedROI.LoadROISetting(m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROITotalX +
                            //                                (int)Math.Round(m_smVisionInfo.g_arrOrients[intUnitNo][m_smVisionInfo.g_intSelectedTemplate].GetUnitPRResultCenterX() -
                            //                                fSizeX / 2 +
                            //                                m_smVisionInfo.g_arrOrients[intUnitNo][m_smVisionInfo.g_intSelectedTemplate].ref_intUnitSurfaceOffsetX, 0, MidpointRounding.AwayFromZero),
                            //                             m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROITotalY +
                            //                                (int)Math.Round(m_smVisionInfo.g_arrOrients[intUnitNo][m_smVisionInfo.g_intSelectedTemplate].GetUnitPRResultCenterY() -
                            //                                fSizeY / 2 +
                            //                                m_smVisionInfo.g_arrOrients[intUnitNo][m_smVisionInfo.g_intSelectedTemplate].ref_intUnitSurfaceOffsetY, 0, MidpointRounding.AwayFromZero),
                            //                             (int)Math.Round(fSizeX, 0, MidpointRounding.AwayFromZero),
                            //                             (int)Math.Round(fSizeY, 0, MidpointRounding.AwayFromZero));
                        }
                        else
                        {

                            // Calculate total angle 
                            fTotalRotateAngle = m_intOrientAngle + m_smVisionInfo.g_arrOrients[intUnitNo][m_smVisionInfo.g_intSelectedOcv[intUnitNo]].ref_fDegAngleResult;

                            //// Get RotateROI where the ROI center point == Unit Center Point
                            //objRotatedROI.AttachImage(m_smVisionInfo.g_arrImages[0]);

                            //float fSizeX, fSizeY;
                            //fSizeX = m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIWidth - m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIWidth % 2; // why %2? To get "even" number
                            //fSizeY = m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIHeight - m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROIHeight % 2;

                            //if (m_blnWantPackageTest && ((m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailMask & 0x1000) > 0)) // 2020-06-23 ZJYEOH : If inspection option got tick Check package size just can use pkg gauge
                            //{
                            //    WaitEventDone(ref m_bPackageSizePreTestDone, true);

                            //    if (m_bPackageSizePreTestResult)
                            //    {
                            //        // Get RotateROI center point where the ROI center point == Package Unit Center Point
                            //        objRotatedROI.LoadROISetting((int)Math.Round(m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X - fSizeX / 2, 0, MidpointRounding.AwayFromZero),
                            //                                     (int)Math.Round(m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y - fSizeY / 2, 0, MidpointRounding.AwayFromZero),
                            //                                     (int)Math.Round(fSizeX, 0, MidpointRounding.AwayFromZero),
                            //                                     (int)Math.Round(fSizeY, 0, MidpointRounding.AwayFromZero));

                            //        // 2020 03 03 - CCENG: Enable this command to use package angle instead of mark angle. 
                            //        // 2020 05 02 - No longer need this feature because mark and package angle are separated to different images.
                            //        //if (m_smVisionInfo.g_blnWantRotateMarkImageUsingPkgAngle)
                            //        //    fTotalRotateAngle = m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle;
                            //    }
                            //    else
                            //    {
                            //        // 2019 09 06 - CCENG: If no package size center point, then use Orient Search ROI Center Point
                            //        objRotatedROI.LoadROISetting((int)Math.Round(m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROITotalCenterX - fSizeX / 2, 0, MidpointRounding.AwayFromZero),
                            //                                    (int)Math.Round(m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROITotalCenterY - fSizeY / 2, 0, MidpointRounding.AwayFromZero),
                            //                                    (int)Math.Round(fSizeX, 0, MidpointRounding.AwayFromZero),
                            //                                    (int)Math.Round(fSizeY, 0, MidpointRounding.AwayFromZero));
                            //    }

                            //}
                            //else
                            //{
                            //    // 2019 09 06 - CCENG: If no package size center point, then use Orient Search ROI Center Point
                            //    objRotatedROI.LoadROISetting((int)Math.Round(m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROITotalCenterX - fSizeX / 2, 0, MidpointRounding.AwayFromZero),
                            //                                 (int)Math.Round(m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].ref_ROITotalCenterY - fSizeY / 2, 0, MidpointRounding.AwayFromZero),
                            //                                 (int)Math.Round(fSizeX, 0, MidpointRounding.AwayFromZero),
                            //                                 (int)Math.Round(fSizeY, 0, MidpointRounding.AwayFromZero));

                            //}

                        }
                    }

                    //// Start Rotate image 1, 2 and 3 to zero orientation and zero angle degree.
                    //if (intUnitNo == 1)
                    //{
                    //    // 2020 05 02 - CCENG: Not sure how to handle this ocv angle and package angle 
                    //    //ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[0], objRotatedROI, fTotalRotateAngle, ref m_smVisionInfo.g_arrRotatedImages, 0);

                    //    if (m_blnWantPackageTest && ((m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailMask & 0x1000) > 0)) // 2020-06-23 ZJYEOH : If inspection option got tick Check package size just can use pkg gauge
                    //    {
                    //        //2020-11-07 ZJYEOH : Need to wait package gauge measure finish just can take the angle 
                    //        WaitEventDone(ref m_bPackageSizePreTestDone, true);

                    //        if (m_bPackageSizePreTestResult)
                    //        {
                    //            ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[0], objRotatedROI, m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle, m_smVisionInfo.g_intRotationInterpolation_Mark, ref m_smVisionInfo.g_arrRotatedImages, 0);
                    //        }
                    //        else
                    //            ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[0], objRotatedROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_Mark, ref m_smVisionInfo.g_arrRotatedImages, 0);
                    //    }
                    //    else
                    //        ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[0], objRotatedROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_Mark, ref m_smVisionInfo.g_arrRotatedImages, 0);

                    //    m_blnRotateImage1Updated = true;

                    //    // 2020 04 19 - cceng: Rotate image to mark 0 deg
                    //    ROI.Rotate0Degree_Better(m_smVisionInfo.g_arrImages[0], objRotatedROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_Mark, ref m_smVisionInfo.g_objMarkImage);

                    //}
                    //else
                    //{
                    //    if (m_smVisionInfo.g_intUnitsOnImage > 1 && (((m_intScenario & 0x02) > 0) || !blnAuto))
                    //    {
                    //        if (m_smVisionInfo.g_blnWantGauge)
                    //        {
                    //            // 2020 05 02 - Not sure how to handle this ocv angle and package angle 
                    //            // Rotate from rotated image if unit 1 is tested
                    //            ROI.Rotate0Degree(m_objPreviousRotatedImage, objRotatedROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_Mark, ref m_smVisionInfo.g_arrRotatedImages, 0);
                    //        }
                    //        else
                    //        {
                    //            // 2020 05 02 - Not sure how to handle this ocv angle and package angle 
                    //            // Rotate from main image if unit 1 no tested (scenario == 0x02)
                    //            ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[0], objRotatedROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_Mark, ref m_smVisionInfo.g_arrRotatedImages, 0);
                    //        }
                    //    }
                    //    else
                    //    {
                    //        // Rotate from main image if unit 1 no tested (scenario == 0x02)
                    //        //ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[0], objRotatedROI, fTotalRotateAngle, ref m_smVisionInfo.g_arrRotatedImages, 0);

                    //        if (m_blnWantPackageTest && ((m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailMask & 0x1000) > 0)) // 2020-06-23 ZJYEOH : If inspection option got tick Check package size just can use pkg gauge
                    //        {
                    //            //2020-11-07 ZJYEOH : Need to wait package gauge measure finish just can take the angle 
                    //            WaitEventDone(ref m_bPackageSizePreTestDone, true);

                    //            if (m_bPackageSizePreTestResult)
                    //            {
                    //                ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[0], objRotatedROI, m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle, m_smVisionInfo.g_intRotationInterpolation_Mark, ref m_smVisionInfo.g_arrRotatedImages, 0);
                    //            }
                    //            else
                    //                ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[0], objRotatedROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_Mark, ref m_smVisionInfo.g_arrRotatedImages, 0);

                    //        }
                    //        else
                    //            ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[0], objRotatedROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_Mark, ref m_smVisionInfo.g_arrRotatedImages, 0);

                    //        m_blnRotateImage1Updated = true;

                    //        // 2020 04 19 - cceng: Rotate image to mark 0 deg
                    //        ROI.Rotate0Degree_Better(m_smVisionInfo.g_arrImages[0], objRotatedROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_Mark, ref m_smVisionInfo.g_objMarkImage);

                    //        //if (m_blnWantLeadTest)
                    //        //{
                    //        //    if (m_smVisionInfo.g_arrImages.Count > m_smVisionInfo.g_arrLead[0].ref_intImageViewNo)
                    //        //    {
                    //        //        ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo], objRotatedROI, fTotalRotateAngle, ref m_smVisionInfo.g_arrRotatedImages, m_smVisionInfo.g_arrLead[0].ref_intImageViewNo);
                    //        //        if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 0)
                    //        //            m_blnRotateImage1Updated = true;
                    //        //        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 1)
                    //        //            m_blnRotateImage2Updated = true;
                    //        //        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 2)
                    //        //            m_blnRotateImage3Updated = true;
                    //        //        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 3)
                    //        //            m_blnRotateImage4Updated = true;
                    //        //        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 4)
                    //        //            m_blnRotateImage5Updated = true;
                    //        //    }
                    //        //}
                    //    }

                    //}
                    m_smVisionInfo.g_arrImages[0].CopyTo(m_smVisionInfo.g_objMarkImage);
                    m_fOrientFinalAngleForLead = fTotalRotateAngle - m_intOrientAngle; //2020-07-23 ZJYEOH: For later use in Lead function
                    //objRotatedROI.Dispose();
                    m_blnRotateImage1Updated = true;

                    if (m_smVisionInfo.g_blnWantCheckMarkAngle)
                    {
                        int intFailMask = m_smVisionInfo.g_arrMarks[intUnitNo].GetFailOptionMask(0, m_smVisionInfo.g_intSelectedOcv[intUnitNo]);
                        if ((intFailMask & 0x2000) > 0)   // 0x2000=Mark Angle
                        {
                            if (m_smVisionInfo.g_intOrientResult[intUnitNo] < 4)    // Will only check Mark Angle if Orientation Pass
                            {
                                if (m_blnWantPackageTest && ((m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailMask & 0x1000) > 0 || m_smVisionInfo.g_arrPackage[intUnitNo].GetWantInspectPackage())) // 2020-06-23 ZJYEOH : If inspection option got tick Check package size just can use pkg gauge
                                {
                                    if (intUnitNo == 0)
                                    {
                                        WaitEventDone(ref m_bPackageSizePreTestDone1, true, 10000, "AAA56");

                                        if (m_bPackageSizePreTestResult1)
                                            m_smVisionInfo.g_fOrientAngle[intUnitNo] = m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle - m_smVisionInfo.g_fOrientAngle[intUnitNo];
                                    }
                                    else
                                    {
                                        WaitEventDone(ref m_bPackageSizePreTestDone2, true, 10000, "AAA57");

                                        if (m_bPackageSizePreTestResult2)
                                            m_smVisionInfo.g_fOrientAngle[intUnitNo] = m_smVisionInfo.g_objGauge_PkgSize2.ref_fRectAngle - m_smVisionInfo.g_fOrientAngle[intUnitNo];
                                    }

                                    //m_smVisionInfo.g_fOrientAngle[intUnitNo] = m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle - m_smVisionInfo.g_fOrientAngle[intUnitNo];

                                    if (Math.Abs(m_smVisionInfo.g_fOrientAngle[intUnitNo]) > m_smVisionInfo.g_arrMarks[intUnitNo].GetMarkAngleTolerance(0, m_smVisionInfo.g_intSelectedOcv[intUnitNo]))
                                    {
                                        m_smVisionInfo.g_strErrorMessage += "*Fail Mark Angle : Set = " +
                                                                        m_smVisionInfo.g_arrMarks[intUnitNo].GetMarkAngleTolerance(0, m_smVisionInfo.g_intSelectedOcv[intUnitNo]).ToString("f4") +
                                                                        " , Result = " + m_smVisionInfo.g_fOrientAngle[intUnitNo].ToString("f4");
                                        m_smVisionInfo.g_arrMarks[intUnitNo].ref_intTemplateIndex = m_smVisionInfo.g_intSelectedOcv[intUnitNo];

                                        m_smVisionInfo.g_blnMarkInspected = true;
                                        //2021-01-04 ZJYEOH : increase angle fail counter and save fail angle image if in production mode
                                        if (blnAuto)
                                        {
                                            m_smVisionInfo.g_intAngleFailureTotal++;
                                            SaveRejectImage_AddToBuffer("Angle", m_smVisionInfo.g_strErrorMessage);
                                        }
                                        if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                                            if (m_intTCPIPResultID == -1)
                                                m_intTCPIPResultID = (int)TCPIPResulID.Fail;//FailMark;

                                        return false;
                                    }
                                }
                                else
                                {
                                    if (!m_arrFinalPreciseAnglePass[m_smVisionInfo.g_intSelectedOcv[intUnitNo]])  // Check selected Orient have precise angle pass or not
                                    {
                                        m_smVisionInfo.g_strErrorMessage += "*Fail Mark Angle : Set = " +
                                                                        m_smVisionInfo.g_arrMarks[intUnitNo].GetMarkAngleTolerance(0, m_smVisionInfo.g_intSelectedOcv[intUnitNo]).ToString("f4") +
                                                                        " , Result = " + m_smVisionInfo.g_fOrientAngle[intUnitNo].ToString("f4");
                                        m_smVisionInfo.g_arrMarks[intUnitNo].ref_intTemplateIndex = m_smVisionInfo.g_intSelectedOcv[intUnitNo];

                                        m_smVisionInfo.g_blnMarkInspected = true;
                                        //2021-01-04 ZJYEOH : increase angle fail counter and save fail angle image if in production mode
                                        if (blnAuto)
                                        {
                                            m_smVisionInfo.g_intAngleFailureTotal++;
                                            SaveRejectImage_AddToBuffer("Angle", m_smVisionInfo.g_strErrorMessage);
                                        }
                                        if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                                            if (m_intTCPIPResultID == -1)
                                                m_intTCPIPResultID = (int)TCPIPResulID.Fail;//FailMark;

                                        return false;
                                    }
                                }
                            }
                        }
                    }
                }
                else
                {
                    m_smVisionInfo.g_arrImages[0].CopyTo(m_smVisionInfo.g_objMarkImage);
                }
            }
            else
            {
                m_smVisionInfo.g_fOrientCenterX[intUnitNo] = m_smVisionInfo.g_arrOrients[intUnitNo][m_smVisionInfo.g_intSelectedOcv[intUnitNo]].ref_fObjectX;
                m_smVisionInfo.g_fOrientCenterY[intUnitNo] = m_smVisionInfo.g_arrOrients[intUnitNo][m_smVisionInfo.g_intSelectedOcv[intUnitNo]].ref_fObjectY;
            }
            return true;
        }

        private bool StartPin1Test(bool blnAuto, int intUnitNo)
        {
            // make sure template learn
            if (m_smVisionInfo.g_arrPin1[intUnitNo].ref_arrTemplateSetting.Count == 0)
            {
                m_smVisionInfo.g_strErrorMessage += "*Pin1 : No Template Found";
                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 33 g_intPin1FailureTotal=" + m_smVisionInfo.g_intPin1FailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                {
                    m_smVisionInfo.g_intNoTemplateFailureTotal++;
                    m_blnFailCounterAdded = true;
                    m_blnTotalCounterAdded = false;

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 33a g_intPin1FailureTotal=" + m_smVisionInfo.g_intPin1FailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                }

                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        m_intTCPIPResultID = (int)TCPIPResulID.Fail;

                return false;
            }

            m_smVisionInfo.g_arrPin1[intUnitNo].ResetInspectionData();
            m_smVisionInfo.g_arrOrientROIs[intUnitNo][0].AttachImage(m_smVisionInfo.g_arrRotatedImages[0]);

            int intMatchCount = 0;
            bool blnResult;
            string strErrorMessage = "";
            int intTemplateIndex;
            // Single template test
            if (!blnAuto && !m_smVisionInfo.g_blnInspectAllTemplate)
            {
                intTemplateIndex = m_smVisionInfo.g_intSelectedTemplate;
                if (m_smVisionInfo.g_arrPin1[intUnitNo].ref_objTestROI == null)
                    m_smVisionInfo.g_arrPin1[intUnitNo].ref_objTestROI = new ROI();

                m_smVisionInfo.g_arrPin1[intUnitNo].ref_objTestROI.AttachImage(m_smVisionInfo.g_arrOrientROIs[intUnitNo][0]);
                m_smVisionInfo.g_arrPin1[intUnitNo].ref_objTestROI.LoadROISetting(
                    (int)(m_smVisionInfo.g_fOrientCenterX[intUnitNo] -
                    m_smVisionInfo.g_arrPin1[intUnitNo].GetPin1PatternWidth(intTemplateIndex) - m_smVisionInfo.g_arrPin1[intUnitNo].GetRefOffsetX(intTemplateIndex)),
                    (int)(m_smVisionInfo.g_fOrientCenterY[intUnitNo] -
                    m_smVisionInfo.g_arrPin1[intUnitNo].GetPin1PatternHeight(intTemplateIndex) - m_smVisionInfo.g_arrPin1[intUnitNo].GetRefOffsetY(intTemplateIndex)),
                    (int)m_smVisionInfo.g_arrPin1[intUnitNo].GetPin1PatternWidth(intTemplateIndex) * 2,
                    (int)m_smVisionInfo.g_arrPin1[intUnitNo].GetPin1PatternHeight(intTemplateIndex) * 2);

                m_smVisionInfo.g_arrPin1[intUnitNo].ref_blnFinalResultPassFail = m_smVisionInfo.g_arrPin1[intUnitNo].MatchWithTemplate(m_smVisionInfo.g_arrPin1[intUnitNo].ref_objTestROI, m_smVisionInfo.g_intSelectedTemplate);
                m_smVisionInfo.g_arrPin1[intUnitNo].ref_intFinalResultSelectedTemplate = intTemplateIndex;
                strErrorMessage = m_smVisionInfo.g_arrPin1[intUnitNo].ref_strErrorMessage;
            }
            else // Whole active templates test
            {
                float fHighestScore = 0;
                do
                {
                    //float fHighestScore = 0; // 2020-04-15 ZJYEOH : move outside the loop so that highest score will not reset
                    intTemplateIndex = (int)((m_smVisionInfo.g_intTemplatePriority >> (0x04 * intMatchCount)) & 0x0F) - 1;
                    if (intTemplateIndex >= 0)
                    {
                        if (m_smVisionInfo.g_intTemplateMask == 0 || (m_smVisionInfo.g_intTemplateMask & (1 << intTemplateIndex)) > 0)
                        {
                            if (m_smVisionInfo.g_arrPin1[intUnitNo].ref_objTestROI == null)
                                m_smVisionInfo.g_arrPin1[intUnitNo].ref_objTestROI = new ROI();

                            m_smVisionInfo.g_arrPin1[intUnitNo].ref_objTestROI.AttachImage(m_smVisionInfo.g_arrOrientROIs[intUnitNo][0]);
                            m_smVisionInfo.g_arrPin1[intUnitNo].ref_objTestROI.LoadROISetting(
                                (int)(m_smVisionInfo.g_fOrientCenterX[intUnitNo] -
                                m_smVisionInfo.g_arrPin1[intUnitNo].GetPin1PatternWidth(intTemplateIndex) - m_smVisionInfo.g_arrPin1[intUnitNo].GetRefOffsetX(intTemplateIndex)),
                                (int)(m_smVisionInfo.g_fOrientCenterY[intUnitNo] -
                                m_smVisionInfo.g_arrPin1[intUnitNo].GetPin1PatternHeight(intTemplateIndex) - m_smVisionInfo.g_arrPin1[intUnitNo].GetRefOffsetY(intTemplateIndex)),
                                (int)m_smVisionInfo.g_arrPin1[intUnitNo].GetPin1PatternWidth(intTemplateIndex) * 2,
                                (int)m_smVisionInfo.g_arrPin1[intUnitNo].GetPin1PatternHeight(intTemplateIndex) * 2);

                            blnResult = m_smVisionInfo.g_arrPin1[intUnitNo].MatchWithTemplate(m_smVisionInfo.g_arrPin1[intUnitNo].ref_objTestROI, intTemplateIndex);

                            if (m_smVisionInfo.g_arrPin1[intUnitNo].GetResultScore(intTemplateIndex) > 0 &&
                                m_smVisionInfo.g_arrPin1[intUnitNo].GetResultScore(intTemplateIndex) > fHighestScore)
                            {
                                fHighestScore = m_smVisionInfo.g_arrPin1[intUnitNo].GetResultScore(intTemplateIndex);
                                m_smVisionInfo.g_arrPin1[intUnitNo].ref_blnFinalResultPassFail = blnResult;
                                m_smVisionInfo.g_arrPin1[intUnitNo].ref_intFinalResultSelectedTemplate = intTemplateIndex;
                                strErrorMessage = m_smVisionInfo.g_arrPin1[intUnitNo].ref_strErrorMessage;
                            }
                        }
                    }
                    intMatchCount++;
                } while (intMatchCount < m_smVisionInfo.g_arrPin1[intUnitNo].ref_arrTemplateSetting.Count);
            }

            m_smVisionInfo.g_blnDrawPin1Result = true;

            if (m_smVisionInfo.g_arrPin1[intUnitNo].ref_blnFinalResultPassFail)
            {
                return true;
            }
            else
            {
                if (m_smVisionInfo.g_intUnitsOnImage == 1)
                    m_smVisionInfo.g_strErrorMessage += "*Unit" + (intUnitNo + 1) + " " + strErrorMessage;
                else
                    m_smVisionInfo.g_strErrorMessage += GetUnitName(intUnitNo) + strErrorMessage;

                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 34 g_intPin1FailureTotal=" + m_smVisionInfo.g_intPin1FailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());

                if (blnAuto)
                {
                    SaveRejectImage_AddToBuffer("Pin1", strErrorMessage);
                }

                if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                {
                    m_smVisionInfo.g_intPin1FailureTotal++;
                    m_blnFailCounterAdded = true;
                    m_blnTotalCounterAdded = false;

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 34a g_intPin1FailureTotal=" + m_smVisionInfo.g_intPin1FailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                }

                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        m_intTCPIPResultID = (int)TCPIPResulID.Fail;

                return false;
            }
        }
        
        private void GaugeMeasureUnit(RectGauge objGauge, ImageDrawing objMeasuredImage)
        {
            if (m_blnWantPositioning)
            {
                objGauge.SetRectGaugePlacement(
                    m_smVisionInfo.g_objPositioning.ref_fObjectCenterX,
                    m_smVisionInfo.g_objPositioning.ref_fObjectCenterY);

                m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][0].LoadROISetting(
                   (int)Math.Round(m_smVisionInfo.g_objPositioning.ref_fObjectCenterX -
                    m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][0].ref_ROIWidth / 2, 0, MidpointRounding.AwayFromZero),
                    (int)Math.Round(m_smVisionInfo.g_objPositioning.ref_fObjectCenterY -
                   m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][0].ref_ROIHeight / 2, 0, MidpointRounding.AwayFromZero),
                   m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][0].ref_ROIWidth,
                   m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][0].ref_ROIHeight);
            }

            if (objGauge.ref_fGainValue != 1000)
            {
                lock (m_objLock)
                {
                    objMeasuredImage.AddGain(ref m_objPkgSizeGainImage, objGauge.ref_fGainValue / 1000);
                    objGauge.Measure(m_objPkgSizeGainImage);
                }
            }
            else
                objGauge.Measure(objMeasuredImage);
        }

        private bool GaugeMeasureUnit(RectGaugeM4L objGauge, List<ImageDrawing> arrMeasuredImage, int intUnitNo)
        {
            bool blnResult = true;
            //if (objGauge.ref_fGainValue != 1000)
            //{
            //    lock (m_objLock)
            //    {
            //        objMeasuredImage.AddGain(ref m_objPkgSizeGainImage, objGauge.ref_fGainValue / 1000);
            //        blnResult = objGauge.Measure_WithDontCareArea(m_objPkgSizeGainImage, m_smVisionInfo.g_objWhiteImage);
            //    }
            //}
            //else
                blnResult = objGauge.Measure_WithDontCareArea(arrMeasuredImage, m_smVisionInfo.g_objWhiteImage, 
                            true,
                            m_smVisionInfo.g_arrPackage[intUnitNo].ref_fTemplateUnitSizeX,
                            m_smVisionInfo.g_arrPackage[intUnitNo].ref_fTemplateUnitSizeY);
            return blnResult;
        }

        //private void GaugeMeasureUnit(RectGaugeM4L objGauge, ImageDrawing objMeasuredImage, ref bool result)
        //{
        //    if (objGauge.ref_fGainValue != 1000)
        //    {
        //        lock (m_objLock)
        //        {
        //            objMeasuredImage.AddGain(ref m_objPkgSizeGainImage, objGauge.ref_fGainValue / 1000);
        //            result = objGauge.Measure_WithDontCareArea(m_objPkgSizeGainImage, m_smVisionInfo.g_objWhiteImage);
        //        }
        //    }
        //    else
        //        result = objGauge.Measure_WithDontCareArea(objMeasuredImage, m_smVisionInfo.g_objWhiteImage);

        //}
        private bool IsUnitSeatedNotProper(int intUnitNo, int intThresholdValue)
        {
            // Check is gauge size measurement 30% out of of unit size?
            if (m_smVisionInfo.g_arrOrientGauge[intUnitNo].VerifyGaugeValid(10))
            {
                if (m_smVisionInfo.g_arrOrientGauge[intUnitNo].ref_ObjectWidth > 0 || m_smVisionInfo.g_arrOrientGauge[intUnitNo].ref_ObjectHeight > 0)
                {
                    if ((Math.Abs(m_smVisionInfo.g_arrOrientGauge[intUnitNo].ref_ObjectWidth - m_smVisionInfo.g_arrOrientGauge[intUnitNo].ref_TemplateObjectWidth) /
                        m_smVisionInfo.g_arrOrientGauge[intUnitNo].ref_TemplateObjectWidth) > 0.2)
                    {
                        return true;
                    }
                    else if ((Math.Abs(m_smVisionInfo.g_arrOrientGauge[intUnitNo].ref_ObjectHeight - m_smVisionInfo.g_arrOrientGauge[intUnitNo].ref_TemplateObjectHeight) /
                        m_smVisionInfo.g_arrOrientGauge[intUnitNo].ref_TemplateObjectHeight) > 0.2)
                    {
                        return true;
                    }
                }
            }

            // Check is "edge" line object exist at the center of unit
            // Define Unit ROI
            ROI objUnitROI = new ROI();
            objUnitROI.AttachImage(m_smVisionInfo.g_arrRotatedImages[0]);
            objUnitROI.LoadROISetting(
                                (int)Math.Round(m_smVisionInfo.g_arrOrientGauge[intUnitNo].ref_ObjectCenterX -
                                m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIWidth / 2, 0, MidpointRounding.AwayFromZero),
                                (int)Math.Round(m_smVisionInfo.g_arrOrientGauge[intUnitNo].ref_ObjectCenterY -
                                m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIHeight / 2, 0, MidpointRounding.AwayFromZero),
                                m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIWidth,
                                m_smVisionInfo.g_arrMarkROIs[intUnitNo][1].ref_ROIHeight);

            if (objUnitROI.IsUnitEdgeOnCenterUnitSurface(intThresholdValue))
            {
                objUnitROI.Dispose();
                return true;
            }

            objUnitROI.Dispose();
            return false;
        }

        private string GetLeadDefinition(int intLeadIndex)
        {
            switch (intLeadIndex)
            {
                case 1:
                    return "*Top ROI: ";
                case 2:
                    return "*Right ROI: ";
                case 3:
                    return "*Bottom ROI: ";
                case 4:
                    return "*Left ROI: ";
                default:
                    SRMMessageBox.Show("GetLeadDefinition()->Lead Index " + intLeadIndex.ToString() + " no exist.");
                    return "";
            }
        }

        //find unit by pattern matching
        private bool FindUnit(int intLeadIndex, int intAngleTolerance, bool blnRecordPatternAngle)
        {
            {
                if (m_smVisionInfo.g_arrLeadROIs[0].Count > 0)
                {
                    m_smVisionInfo.g_arrLeadROIs[0][0].AttachImage(m_smVisionInfo.g_objLeadImage);
                }

                //HiPerfTimer timer = new HiPerfTimer();
                //timer.Start();

                if (!m_smVisionInfo.g_arrLead[intLeadIndex].FindUnitUsingPRS(m_smVisionInfo.g_arrLeadROIs[0][0], intAngleTolerance, false, intLeadIndex, m_smVisionInfo.g_arrLeadROIs[intLeadIndex][0])) // Side Lead angle is a bit only
                {
                    m_smVisionInfo.g_strErrorMessage += "*Lead : Fail to find unit." + m_smVisionInfo.g_arrLead[intLeadIndex].ref_strErrorMessage;

                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        if (m_intTCPIPResultID == -1)
                            m_intTCPIPResultID = (int)TCPIPResulID.Fail;

                    return false;
                }
                if (m_smVisionInfo.g_arrLead[intLeadIndex].ref_fUnitScore >= m_fLeadPatternScore)
                {
                    m_fLeadPatternScore = m_smVisionInfo.g_arrLead[intLeadIndex].ref_fUnitScore;
                    if (blnRecordPatternAngle)
                        m_fLeadPatternAngle = m_smVisionInfo.g_arrLead[intLeadIndex].ref_fUnitAngle;
                }
                //timer.Stop();
                //STTrackLog.WriteLine("Pattern Match Duration = " + timer.Duration.ToString());
                //timer.Start();

                //if (!m_smVisionInfo.g_arrLead[intLeadIndex].FindUnitUsingFinder(m_smVisionInfo.g_arrLeadROIs[intLeadIndex][0], 2, false)) // Side Lead angle is a bit only
                //{
                //    m_smVisionInfo.g_strErrorMessage += "*Fail to find unit." + m_smVisionInfo.g_arrLead[intLeadIndex].ref_strErrorMessage;
                //    return false;
                //}

                //timer.Stop();
                //STTrackLog.WriteLine("Pattern Finder Duration = " + timer.Duration.ToString());

                return true;
            }
        }
        private bool FindFixPocket(int intLeadIndex)
        {
            if (m_smVisionInfo.g_arrLeadPocketDontCareROIsFix.Count < intLeadIndex)
            {
                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        m_intTCPIPResultID = (int)TCPIPResulID.Fail;

                m_smVisionInfo.g_strErrorMessage += "*Lead : Please Learn Dont Care ROI first.";
                return false;
            }

            if (m_smVisionInfo.g_arrLeadPocketDontCareROIsFix[intLeadIndex].Count == 0)
            {
                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        m_intTCPIPResultID = (int)TCPIPResulID.Fail;

                m_smVisionInfo.g_strErrorMessage += "*Lead : Please Learn Dont Care ROI first.";
                return false;
            }

            //ROI objDontCareROI = new ROI();
            m_smVisionInfo.g_arrLeadPocketDontCareROIsFix[intLeadIndex][0].AttachImage(m_smVisionInfo.g_objLeadImage);
            m_smVisionInfo.g_arrLeadPocketDontCareROIsFix[intLeadIndex][0].LoadROISetting(m_smVisionInfo.g_arrLeadPocketDontCareROIsFix[intLeadIndex][0].ref_ROIPositionX, m_smVisionInfo.g_arrLeadPocketDontCareROIsFix[intLeadIndex][0].ref_ROIPositionY,
                                                                                          m_smVisionInfo.g_arrLeadPocketDontCareROIsFix[intLeadIndex][0].ref_ROIWidth, m_smVisionInfo.g_arrLeadPocketDontCareROIsFix[intLeadIndex][0].ref_ROIHeight);
            //m_smVisionInfo.g_objLeadImage.SaveImage("D:\\Img1.bmp");
            ROI.SubtractROI(m_smVisionInfo.g_arrLeadPocketDontCareROIsFix[intLeadIndex][0], m_smVisionInfo.g_arrLeadPocketDontCareROIsFix[intLeadIndex][0]);
            //m_smVisionInfo.g_objLeadImage.SaveImage("D:\\Img2.bmp");
            //objDontCareROI.Dispose();
            return true;

        }
        private bool FindPocketShadowBlob(int intLeadIndex, ref List<float> arrInwardDontCareROILimit)
        {
            if (m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob.Count < intLeadIndex)
            {
                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        m_intTCPIPResultID = (int)TCPIPResulID.Fail;

                m_smVisionInfo.g_strErrorMessage += "*Lead : Please Learn Dont Care ROI first.";
                return false;
            }

            if (m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[intLeadIndex].Count == 0)
            {
                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        m_intTCPIPResultID = (int)TCPIPResulID.Fail;

                m_smVisionInfo.g_strErrorMessage += "*Lead : Please Learn Dont Care ROI first.";
                return false;
            }

            if (m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[0].Count > 0)
            {
                m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[0][0].AttachImage(m_smVisionInfo.g_objLeadImage);
            }

            for (int i = 0; i < m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob.Count; i++)
            {
                for (int j = 0; j < m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[i].Count; j++)
                {
                    m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[i][j].AttachImage(m_smVisionInfo.g_objLeadImage);
                    //m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[i][j].SaveImage("D:\\TS\\LeadPocketDontCareROI_" + i.ToString() + "_" + j.ToString() + ".bmp");
                }
            }

            ROI objROI = new ROI();
            objROI.AttachImage(m_smVisionInfo.g_objLeadImage);
            switch (intLeadIndex)
            {
                case 1:
                    objROI.LoadROISetting(m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[intLeadIndex][0].ref_ROITotalX,
                            m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[intLeadIndex][0].ref_ROITotalY,
                            m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[intLeadIndex][0].ref_ROIWidth,
                            m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[intLeadIndex][0].ref_ROIHeight + m_smVisionInfo.g_arrLead[intLeadIndex].ref_intDontCareBlobROIInward);
                    break;
                case 2:
                    objROI.LoadROISetting(m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[intLeadIndex][0].ref_ROITotalX - m_smVisionInfo.g_arrLead[intLeadIndex].ref_intDontCareBlobROIInward,
                            m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[intLeadIndex][0].ref_ROITotalY,
                            m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[intLeadIndex][0].ref_ROIWidth + m_smVisionInfo.g_arrLead[intLeadIndex].ref_intDontCareBlobROIInward,
                            m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[intLeadIndex][0].ref_ROIHeight);
                    break;
                case 3:
                    objROI.LoadROISetting(m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[intLeadIndex][0].ref_ROITotalX,
                                    m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[intLeadIndex][0].ref_ROITotalY - m_smVisionInfo.g_arrLead[intLeadIndex].ref_intDontCareBlobROIInward,
                                    m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[intLeadIndex][0].ref_ROIWidth,
                                    m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[intLeadIndex][0].ref_ROIHeight + m_smVisionInfo.g_arrLead[intLeadIndex].ref_intDontCareBlobROIInward);
                    break;
                case 4:
                    objROI.LoadROISetting(m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[intLeadIndex][0].ref_ROITotalX,
                            m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[intLeadIndex][0].ref_ROITotalY,
                            m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[intLeadIndex][0].ref_ROIWidth + m_smVisionInfo.g_arrLead[intLeadIndex].ref_intDontCareBlobROIInward,
                            m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[intLeadIndex][0].ref_ROIHeight);
                    break;
            }

            //objROI.SaveImage("D:\\TS\\objROI.bmp");

            //STTrackLog.WriteLine("C: " + m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[intLeadIndex][0].ref_ROIPositionX.ToString() + ", " +
            //                             m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[intLeadIndex][0].ref_ROIPositionY.ToString() + ", " +
            //                             m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[intLeadIndex][0].ref_ROIWidth.ToString() + ", " +
            //                             m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[intLeadIndex][0].ref_ROIHeight.ToString());

            //STTrackLog.WriteLine("D: " + objROI.ref_ROIPositionX.ToString() + ", " +
            //                             objROI.ref_ROIPositionY.ToString() + ", " +
            //                             objROI.ref_ROIWidth.ToString() + ", " +
            //                             objROI.ref_ROIHeight.ToString());

            arrInwardDontCareROILimit[intLeadIndex] = m_smVisionInfo.g_arrLead[intLeadIndex].BuildDontCareArea(objROI, false);

            if (arrInwardDontCareROILimit[intLeadIndex] != -1f)
            {
                ROI objDontCareROI = new ROI();
                objDontCareROI.AttachImage(m_smVisionInfo.g_objLeadImage);
                switch (intLeadIndex)
                {
                    case 1:
                        objDontCareROI.LoadROISetting(objROI.ref_ROITotalX,
                                objROI.ref_ROITotalY,
                                objROI.ref_ROIWidth,
                                (int)arrInwardDontCareROILimit[intLeadIndex]);
                        break;
                    case 2:
                        objDontCareROI.LoadROISetting(objROI.ref_ROITotalX + (int)arrInwardDontCareROILimit[intLeadIndex],
                                objROI.ref_ROITotalY,
                                objROI.ref_ROIWidth,
                                objROI.ref_ROIHeight);
                        break;
                    case 3:
                        objDontCareROI.LoadROISetting(objROI.ref_ROITotalX,
                                        objROI.ref_ROITotalY + (int)arrInwardDontCareROILimit[intLeadIndex],
                                        objROI.ref_ROIWidth,
                                        objROI.ref_ROIHeight);
                        break;
                    case 4:
                        objDontCareROI.LoadROISetting(objROI.ref_ROITotalX,
                                objROI.ref_ROITotalY,
                                (int)arrInwardDontCareROILimit[intLeadIndex],
                                objROI.ref_ROIHeight);
                        break;
                }


                //m_smVisionInfo.g_objLeadImage.SaveImage("D:\\TS\\Img1.bmp");
                ROI.SubtractROI(objDontCareROI, objDontCareROI);
                //m_smVisionInfo.g_objLeadImage.SaveImage("D:\\TS\\Img2_" + intLeadIndex.ToString() + ".bmp");
                objDontCareROI.Dispose();
            }
            //objDontCareROI.Dispose();
            objROI.Dispose();
            return true;

        }
        private void FlipToOpposite_DontCareBlob(List<float> arrInwardDontCareROILimit)
        {
            if (((m_smVisionInfo.g_intLeadPocketDontCareROIBlobMask & 0x01) > 0) && ((m_smVisionInfo.g_intLeadPocketDontCareROIBlobMask & 0x04) > 0) &&
                ((arrInwardDontCareROILimit[1] == -1 && arrInwardDontCareROILimit[3] == -1) || (arrInwardDontCareROILimit[1] != -1 && arrInwardDontCareROILimit[3] != -1)))
                return;
            else if (((m_smVisionInfo.g_intLeadPocketDontCareROIBlobMask & 0x02) > 0) && ((m_smVisionInfo.g_intLeadPocketDontCareROIBlobMask & 0x08) > 0) &&
                ((arrInwardDontCareROILimit[2] == -1 && arrInwardDontCareROILimit[4] == -1) || (arrInwardDontCareROILimit[2] != -1 && arrInwardDontCareROILimit[4] != -1)))
                return;

            int intOffset = 0;

            if (((m_smVisionInfo.g_intLeadPocketDontCareROIBlobMask & 0x01) > 0) && ((m_smVisionInfo.g_intLeadPocketDontCareROIBlobMask & 0x04) > 0) && m_smVisionInfo.g_intLeadPocketDontCareROIBlobDistanceY > 0)
            {
                if (arrInwardDontCareROILimit[1] == -1)
                {
                    intOffset = (int)arrInwardDontCareROILimit[3] - m_smVisionInfo.g_arrLead[3].ref_intDontCareBlobROIInward;
                    ROI objDontCareROI = new ROI();
                    objDontCareROI.AttachImage(m_smVisionInfo.g_objLeadImage);
                    objDontCareROI.LoadROISetting(m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[1][0].ref_ROITotalX,
                            m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[3][0].ref_ROITotalY - m_smVisionInfo.g_arrLead[3].ref_intDontCareBlobROIInward + (int)arrInwardDontCareROILimit[3] - m_smVisionInfo.g_intLeadPocketDontCareROIBlobDistanceY - intOffset - m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[1][0].ref_ROIHeight,
                            m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[1][0].ref_ROIWidth,
                            m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[1][0].ref_ROIHeight);

                    //m_smVisionInfo.g_objLeadImage.SaveImage("D:\\TS\\ImgTop_1.bmp");
                    ROI.SubtractROI(objDontCareROI, objDontCareROI);
                    //m_smVisionInfo.g_objLeadImage.SaveImage("D:\\TS\\ImgTop_2.bmp");
                    objDontCareROI.Dispose();
                }
                else if (arrInwardDontCareROILimit[3] == -1)
                {
                    intOffset = m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[1][0].ref_ROIHeight - (int)arrInwardDontCareROILimit[1];
                    ROI objDontCareROI = new ROI();
                    objDontCareROI.AttachImage(m_smVisionInfo.g_objLeadImage);
                    objDontCareROI.LoadROISetting(m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[3][0].ref_ROITotalX,
                                m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[1][0].ref_ROITotalY + (int)arrInwardDontCareROILimit[1] + m_smVisionInfo.g_intLeadPocketDontCareROIBlobDistanceY + intOffset,
                                m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[3][0].ref_ROIWidth,
                                m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[3][0].ref_ROIHeight);

                    //m_smVisionInfo.g_objLeadImage.SaveImage("D:\\TS\\ImgBottom_1.bmp");
                    ROI.SubtractROI(objDontCareROI, objDontCareROI);
                    //m_smVisionInfo.g_objLeadImage.SaveImage("D:\\TS\\ImgBottom_2.bmp");
                    objDontCareROI.Dispose();
                }
            }
            else if (((m_smVisionInfo.g_intLeadPocketDontCareROIBlobMask & 0x02) > 0) && ((m_smVisionInfo.g_intLeadPocketDontCareROIBlobMask & 0x08) > 0) && m_smVisionInfo.g_intLeadPocketDontCareROIBlobDistanceX > 0)
            {
                if (arrInwardDontCareROILimit[2] == -1)
                {
                    intOffset = m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[4][0].ref_ROIWidth - (int)arrInwardDontCareROILimit[4];
                    ROI objDontCareROI = new ROI();
                    objDontCareROI.AttachImage(m_smVisionInfo.g_objLeadImage);
                    objDontCareROI.LoadROISetting(m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[4][0].ref_ROITotalX + (int)arrInwardDontCareROILimit[4] + m_smVisionInfo.g_intLeadPocketDontCareROIBlobDistanceX + intOffset,
                            m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[2][0].ref_ROITotalY,
                            m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[2][0].ref_ROIWidth,
                            m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[2][0].ref_ROIHeight);

                    //m_smVisionInfo.g_objLeadImage.SaveImage("D:\\TS\\ImgRight_1.bmp");
                    ROI.SubtractROI(objDontCareROI, objDontCareROI);
                    //m_smVisionInfo.g_objLeadImage.SaveImage("D:\\TS\\ImgRight_2.bmp");
                    objDontCareROI.Dispose();
                }
                else if (arrInwardDontCareROILimit[4] == -1)
                {
                    intOffset = (int)arrInwardDontCareROILimit[2] - m_smVisionInfo.g_arrLead[2].ref_intDontCareBlobROIInward;
                    ROI objDontCareROI = new ROI();
                    objDontCareROI.AttachImage(m_smVisionInfo.g_objLeadImage);
                    objDontCareROI.LoadROISetting(m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[2][0].ref_ROITotalX - m_smVisionInfo.g_arrLead[2].ref_intDontCareBlobROIInward + (int)arrInwardDontCareROILimit[2] - m_smVisionInfo.g_intLeadPocketDontCareROIBlobDistanceX - intOffset - m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[4][0].ref_ROIWidth,
                        m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[4][0].ref_ROITotalY,
                        m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[4][0].ref_ROIWidth,
                        m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[4][0].ref_ROIHeight);

                    //m_smVisionInfo.g_objLeadImage.SaveImage("D:\\TS\\ImgLeft_1.bmp");
                    ROI.SubtractROI(objDontCareROI, objDontCareROI);
                    //m_smVisionInfo.g_objLeadImage.SaveImage("D:\\TS\\ImgLeft_2.bmp");
                    objDontCareROI.Dispose();
                }
            }

        }

        private bool FindManualPocketReference(int intLeadIndex)
        {
            if (m_smVisionInfo.g_arrLeadPocketDontCareROIsManual[0].Count > 0)
            {
                m_smVisionInfo.g_arrLeadPocketDontCareROIsManual[0][0].AttachImage(m_smVisionInfo.g_objLeadImage);
            }
           
            if(m_smVisionInfo.g_arrLeadPocketDontCareROIsManual.Count < intLeadIndex)
            {
                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        m_intTCPIPResultID = (int)TCPIPResulID.Fail;

                m_smVisionInfo.g_strErrorMessage += "*Lead : Please Learn Dont Care ROI first.";
                return false;
            }

            if (m_smVisionInfo.g_arrLeadPocketDontCareROIsManual[intLeadIndex].Count == 0)
            {
                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        m_intTCPIPResultID = (int)TCPIPResulID.Fail;

                m_smVisionInfo.g_strErrorMessage += "*Lead : Please Learn Dont Care ROI first.";
                return false;
            }

            PointF pPatternCenter = new PointF(0, 0);
            if (!m_smVisionInfo.g_arrLead[intLeadIndex].FindManualPocketReferencePattern(m_smVisionInfo.g_arrLeadPocketDontCareROIsManual[0][0], ref pPatternCenter))
            {
                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        m_intTCPIPResultID = (int)TCPIPResulID.Fail;

                m_smVisionInfo.g_strErrorMessage += "*Lead : Fail to find Reference." + m_smVisionInfo.g_arrLead[intLeadIndex].ref_strErrorMessage;
                return false;
            }

            //ROI objDontCareROI = new ROI();
            m_smVisionInfo.g_arrLeadPocketDontCareROIsManual[intLeadIndex][0].AttachImage(m_smVisionInfo.g_objLeadImage);
            m_smVisionInfo.g_arrLeadPocketDontCareROIsManual[intLeadIndex][0].LoadROISetting((int)Math.Round((pPatternCenter.X - m_smVisionInfo.g_arrLead[intLeadIndex].ref_fManualPocketReferenceOffsetX) - (m_smVisionInfo.g_arrLeadPocketDontCareROIsManual[intLeadIndex][0].ref_ROIWidth / 2)),
                (int)Math.Round((pPatternCenter.Y - m_smVisionInfo.g_arrLead[intLeadIndex].ref_fManualPocketReferenceOffsetY) - (m_smVisionInfo.g_arrLeadPocketDontCareROIsManual[intLeadIndex][0].ref_ROIHeight / 2)),
                m_smVisionInfo.g_arrLeadPocketDontCareROIsManual[intLeadIndex][0].ref_ROIWidth, m_smVisionInfo.g_arrLeadPocketDontCareROIsManual[intLeadIndex][0].ref_ROIHeight);
            //m_smVisionInfo.g_objLeadImage.SaveImage("D:\\Img1.bmp");
            ROI.SubtractROI(m_smVisionInfo.g_arrLeadPocketDontCareROIsManual[intLeadIndex][0], m_smVisionInfo.g_arrLeadPocketDontCareROIsManual[intLeadIndex][0]);
            //m_smVisionInfo.g_objLeadImage.SaveImage("D:\\Img2.bmp");
            //objDontCareROI.Dispose();
            return true;

        }
        private bool FindAutoPocketReference(int intLeadIndex, ImageDrawing objImg)
        {
            if (m_smVisionInfo.g_arrLeadPocketDontCareROIsAuto[0].Count > 0)
            {
                m_smVisionInfo.g_arrLeadPocketDontCareROIsAuto[0][0].AttachImage(m_smVisionInfo.g_objLeadImage);
            }

            if (m_smVisionInfo.g_arrLeadPocketDontCareROIsAuto.Count < intLeadIndex)
            {
                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        m_intTCPIPResultID = (int)TCPIPResulID.Fail;

                m_smVisionInfo.g_strErrorMessage += "*Lead : Please Learn Dont Care ROI first.";
                return false;
            }

            if (m_smVisionInfo.g_arrLeadPocketDontCareROIsAuto[intLeadIndex].Count == 0)
            {
                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        m_intTCPIPResultID = (int)TCPIPResulID.Fail;

                m_smVisionInfo.g_strErrorMessage += "*Lead : Please Learn Dont Care ROI first.";
                return false;
            }

            PointF pPatternCenter = new PointF(0, 0);
            if (!m_smVisionInfo.g_arrLead[intLeadIndex].FindAutoPocketReferencePattern(m_smVisionInfo.g_arrLeadPocketDontCareROIsAuto[0][0], ref pPatternCenter))
            {
                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        m_intTCPIPResultID = (int)TCPIPResulID.Fail;

                m_smVisionInfo.g_strErrorMessage += "*Lead : Fail to find Reference." + m_smVisionInfo.g_arrLead[intLeadIndex].ref_strErrorMessage;
                return false;
            }

            //ROI objGaugeROI = new ROI();

            m_smVisionInfo.g_arrLeadPocketDontCareROIsAuto[intLeadIndex][0].AttachImage(objImg);
            m_smVisionInfo.g_arrLeadPocketDontCareROIsAuto[intLeadIndex][0].LoadROISetting((int)Math.Round((pPatternCenter.X - m_smVisionInfo.g_arrLead[intLeadIndex].ref_fAutoPocketReferenceOffsetX) - (m_smVisionInfo.g_arrLeadPocketDontCareROIsAuto[intLeadIndex][0].ref_ROIWidth / 2)),
                (int)Math.Round((pPatternCenter.Y - m_smVisionInfo.g_arrLead[intLeadIndex].ref_fAutoPocketReferenceOffsetY) - (m_smVisionInfo.g_arrLeadPocketDontCareROIsAuto[intLeadIndex][0].ref_ROIHeight / 2)),
                m_smVisionInfo.g_arrLeadPocketDontCareROIsAuto[intLeadIndex][0].ref_ROIWidth, m_smVisionInfo.g_arrLeadPocketDontCareROIsAuto[intLeadIndex][0].ref_ROIHeight);

            m_smVisionInfo.g_arrLead[intLeadIndex].ref_objPocketEdgeGauge.SetPGaugePlace(
                m_smVisionInfo.g_arrLeadPocketDontCareROIsAuto[intLeadIndex][0].ref_ROIPositionX,
                m_smVisionInfo.g_arrLeadPocketDontCareROIsAuto[intLeadIndex][0].ref_ROIPositionY,
                m_smVisionInfo.g_arrLeadPocketDontCareROIsAuto[intLeadIndex][0].ref_ROIWidth,
                m_smVisionInfo.g_arrLeadPocketDontCareROIsAuto[intLeadIndex][0].ref_ROIHeight);

            int m_intWidthLimit = m_smVisionInfo.g_arrLeadPocketDontCareROIsAuto[intLeadIndex][0].ref_ROIWidth;
            int m_intHeightLimit = m_smVisionInfo.g_arrLeadPocketDontCareROIsAuto[intLeadIndex][0].ref_ROIHeight;
            int m_intStartX = m_smVisionInfo.g_arrLeadPocketDontCareROIsAuto[intLeadIndex][0].ref_ROIPositionX;
            int m_intStartY = m_smVisionInfo.g_arrLeadPocketDontCareROIsAuto[intLeadIndex][0].ref_ROIPositionY;

            m_smVisionInfo.g_arrLeadPocketDontCareROIsAuto[intLeadIndex][0].GainTo_ROIToROISamePosition(ref objImg, m_smVisionInfo.g_arrLead[intLeadIndex].ref_objPocketEdgeGauge.ref_fGaugeImageGain);
            m_smVisionInfo.g_arrLeadPocketDontCareROIsAuto[intLeadIndex][0].ThresholdTo_ROIToROISamePosition(ref objImg, m_smVisionInfo.g_arrLead[intLeadIndex].ref_objPocketEdgeGauge.ref_intGaugeImageThreshold);
            
            if (m_smVisionInfo.g_blnViewPackageImage)
                m_smVisionInfo.g_arrLead[intLeadIndex].ref_objPocketEdgeGauge.MeasurePGauge(m_smVisionInfo.g_arrLeadPocketDontCareROIsAuto[intLeadIndex][0], m_smVisionInfo.g_objPackageImage);
            else
                m_smVisionInfo.g_arrLead[intLeadIndex].ref_objPocketEdgeGauge.MeasurePGauge(m_smVisionInfo.g_arrLeadPocketDontCareROIsAuto[intLeadIndex][0], m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo]);

            ROI objDontCareROI = new ROI();
            objDontCareROI.AttachImage(m_smVisionInfo.g_objLeadImage);

            if (intLeadIndex == 1)
            {
                float intStartY = m_smVisionInfo.g_arrLead[intLeadIndex].ref_objPocketEdgeGauge.ref_objLine.GetPointY(m_intStartX);
                float intEndY = m_smVisionInfo.g_arrLead[intLeadIndex].ref_objPocketEdgeGauge.ref_objLine.GetPointY(m_intStartX + m_intWidthLimit);
                if (!float.IsNaN(intStartY) && !float.IsInfinity(intStartY) && !float.IsNaN(intEndY) && !float.IsInfinity(intEndY))
                {
                 
                    objDontCareROI.LoadROISetting(m_intStartX, (int)Math.Round(intStartY + m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLineOffset), m_intWidthLimit, m_smVisionInfo.g_arrLead[intLeadIndex].ref_intMaskThickness);
                    
                }
            }
            else if (intLeadIndex == 2)
            {
                float intStartX = m_smVisionInfo.g_arrLead[intLeadIndex].ref_objPocketEdgeGauge.ref_objLine.GetPointX(m_intStartY);
                float intEndX = m_smVisionInfo.g_arrLead[intLeadIndex].ref_objPocketEdgeGauge.ref_objLine.GetPointX(m_intStartY + m_intHeightLimit);
                if (!float.IsNaN(intStartX) && !float.IsInfinity(intStartX) && !float.IsNaN(intEndX) && !float.IsInfinity(intEndX))
                {

                    objDontCareROI.LoadROISetting((int)Math.Round(intStartX - m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLineOffset - m_smVisionInfo.g_arrLead[intLeadIndex].ref_intMaskThickness), m_intStartY, m_smVisionInfo.g_arrLead[intLeadIndex].ref_intMaskThickness, m_intHeightLimit);
                    
                }
            }
            else if (intLeadIndex == 3)
            {
                float intStartY = m_smVisionInfo.g_arrLead[intLeadIndex].ref_objPocketEdgeGauge.ref_objLine.GetPointY(m_intStartX);
                float intEndY = m_smVisionInfo.g_arrLead[intLeadIndex].ref_objPocketEdgeGauge.ref_objLine.GetPointY(m_intStartX + m_intWidthLimit);
                if (!float.IsNaN(intStartY) && !float.IsInfinity(intStartY) && !float.IsNaN(intEndY) && !float.IsInfinity(intEndY))
                {

                    objDontCareROI.LoadROISetting(m_intStartX, (int)Math.Round(intStartY - m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLineOffset - m_smVisionInfo.g_arrLead[intLeadIndex].ref_intMaskThickness), m_intWidthLimit, m_smVisionInfo.g_arrLead[intLeadIndex].ref_intMaskThickness);
                    
                }
            }
            else if (intLeadIndex == 4)
            {
                float intStartX = m_smVisionInfo.g_arrLead[intLeadIndex].ref_objPocketEdgeGauge.ref_objLine.GetPointX(m_intStartY);
                float intEndX = m_smVisionInfo.g_arrLead[intLeadIndex].ref_objPocketEdgeGauge.ref_objLine.GetPointX(m_intStartY + m_intHeightLimit);
                if (!float.IsNaN(intStartX) && !float.IsInfinity(intStartX) && !float.IsNaN(intEndX) && !float.IsInfinity(intEndX))
                {

                    objDontCareROI.LoadROISetting((int)Math.Round(intStartX + m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLineOffset), m_intStartY, m_smVisionInfo.g_arrLead[intLeadIndex].ref_intMaskThickness, m_intHeightLimit);
                    
                }
            }

            //m_smVisionInfo.g_objLeadImage.SaveImage("D:\\Img1.bmp");
            ROI.SubtractROI(objDontCareROI, objDontCareROI);
            //m_smVisionInfo.g_objLeadImage.SaveImage("D:\\Img2.bmp");
            m_smVisionInfo.g_arrLeadPocketDontCareROIsAuto[intLeadIndex][0].AttachImage(m_smVisionInfo.g_objLeadImage);
            objDontCareROI.Dispose();
            //objGaugeROI.Dispose();
            return true;

        }
        private bool IsLeadOK(int intLeadIndex, ref int intFailType)
        {
            if (!m_smVisionInfo.g_arrLead[0].GetWantInspectLead())//(!m_smVisionInfo.g_blnCheckLead)
                return true;

            if (m_objLeadImage == null)
                m_objLeadImage = new ImageDrawing(true);

            //Copy rotated image to a temp image

            m_smVisionInfo.g_objLeadImage.CopyTo(ref m_objLeadImage);

            // Define Sample Unit ROI attach to sample image          
            m_smVisionInfo.g_arrInspectLeadROI[intLeadIndex].AttachImage(m_objLeadImage);

            // Same size as Unit ROI 
            if (m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Top == 0 &&
                m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Right == 0 &&
                m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Bottom == 0 &&
                m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Left == 0)
            {
                m_smVisionInfo.g_arrInspectLeadROI[intLeadIndex].LoadROISetting(
                   (int)Math.Round(m_smVisionInfo.g_arrLead[intLeadIndex].GetResultCenterPoint_UnitMatcher().X -
                   ((float)m_smVisionInfo.g_arrLeadROIs[intLeadIndex][0].ref_ROIWidth / 2) + m_smVisionInfo.g_arrLead[intLeadIndex].ref_fPatternROIOffsetX, 0, MidpointRounding.AwayFromZero),
                   (int)Math.Round(m_smVisionInfo.g_arrLead[intLeadIndex].GetResultCenterPoint_UnitMatcher().Y -
                   ((float)m_smVisionInfo.g_arrLeadROIs[intLeadIndex][0].ref_ROIHeight / 2) + m_smVisionInfo.g_arrLead[intLeadIndex].ref_fPatternROIOffsetY, 0, MidpointRounding.AwayFromZero),
                   m_smVisionInfo.g_arrLeadROIs[intLeadIndex][0].ref_ROIWidth,
                   m_smVisionInfo.g_arrLeadROIs[intLeadIndex][0].ref_ROIHeight);
            }
            else
            {
                m_smVisionInfo.g_arrInspectLeadROI[intLeadIndex].LoadROISetting(
             (int)Math.Round(m_smVisionInfo.g_arrLead[intLeadIndex].GetResultCenterPoint_UnitMatcher().X -
             ((float)m_smVisionInfo.g_arrLead[intLeadIndex].GetPatternSize_UnitMatcher().Width / 2) - m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Left, 0, MidpointRounding.AwayFromZero),
             (int)Math.Round(m_smVisionInfo.g_arrLead[intLeadIndex].GetResultCenterPoint_UnitMatcher().Y -
             ((float)m_smVisionInfo.g_arrLead[intLeadIndex].GetPatternSize_UnitMatcher().Height / 2) - m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Top, 0, MidpointRounding.AwayFromZero),
             m_smVisionInfo.g_arrLead[intLeadIndex].GetPatternSize_UnitMatcher().Width + m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Left + m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Right,
             m_smVisionInfo.g_arrLead[intLeadIndex].GetPatternSize_UnitMatcher().Height + m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Top + m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Bottom);
            }

            if (m_smVisionInfo.g_arrLead[0].ref_blnWantInspectBaseLead)
            {
                if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == m_smVisionInfo.g_arrLead[0].ref_intImageViewNo)
                    m_smVisionInfo.g_arrInspectLeadROI_BaseLead[intLeadIndex].AttachImage(m_objLeadImage);
                else
                    m_smVisionInfo.g_arrInspectLeadROI_BaseLead[intLeadIndex].AttachImage(m_smVisionInfo.g_arrRotatedImages[m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo]);

                if (m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Top == 0 &&
                m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Right == 0 &&
                m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Bottom == 0 &&
                m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Left == 0)
                {
                    m_smVisionInfo.g_arrInspectLeadROI_BaseLead[intLeadIndex].LoadROISetting(
                      (int)Math.Round(m_smVisionInfo.g_arrLead[intLeadIndex].GetResultCenterPoint_UnitMatcher().X -
                      ((float)m_smVisionInfo.g_arrLeadROIs[intLeadIndex][0].ref_ROIWidth / 2) + m_smVisionInfo.g_arrLead[intLeadIndex].ref_fPatternROIOffsetX, 0, MidpointRounding.AwayFromZero),
                      (int)Math.Round(m_smVisionInfo.g_arrLead[intLeadIndex].GetResultCenterPoint_UnitMatcher().Y -
                      ((float)m_smVisionInfo.g_arrLeadROIs[intLeadIndex][0].ref_ROIHeight / 2) + m_smVisionInfo.g_arrLead[intLeadIndex].ref_fPatternROIOffsetY, 0, MidpointRounding.AwayFromZero),
                      m_smVisionInfo.g_arrLeadROIs[intLeadIndex][0].ref_ROIWidth,
                      m_smVisionInfo.g_arrLeadROIs[intLeadIndex][0].ref_ROIHeight);
                }
                else
                {
                    m_smVisionInfo.g_arrInspectLeadROI_BaseLead[intLeadIndex].LoadROISetting(
                    (int)Math.Round(m_smVisionInfo.g_arrLead[intLeadIndex].GetResultCenterPoint_UnitMatcher().X -
                    (m_smVisionInfo.g_arrLead[intLeadIndex].GetPatternSize_UnitMatcher().Width / 2) - m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Left, 0, MidpointRounding.AwayFromZero),
                    (int)Math.Round(m_smVisionInfo.g_arrLead[intLeadIndex].GetResultCenterPoint_UnitMatcher().Y -
                    ((float)m_smVisionInfo.g_arrLead[intLeadIndex].GetPatternSize_UnitMatcher().Height / 2) - m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Top, 0, MidpointRounding.AwayFromZero),
                    m_smVisionInfo.g_arrLead[intLeadIndex].GetPatternSize_UnitMatcher().Width + m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Left + m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Right,
                    m_smVisionInfo.g_arrLead[intLeadIndex].GetPatternSize_UnitMatcher().Height + m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Top + m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Bottom);
                }
            }
            bool blnWantDebug = false;
            if (blnWantDebug)
            {
                m_smVisionInfo.g_arrInspectLeadROI[intLeadIndex].SaveImage("D:\\TS\\InspectLeadROI.bmp");
            }
            int j = 0;
            List<List<PointF>> arrDontCare = new List<List<PointF>>();


            //Draw don't care ROI edge to make sure Don't Care Area is not inspected
            for (int k = 1; k < m_smVisionInfo.g_arrLeadROIs[intLeadIndex].Count; k++)
            {
                PointF ptTemp;
                List<PointF> arrTemp = new List<PointF>();

                ptTemp = new PointF();
                ptTemp.X = m_smVisionInfo.g_arrLeadROIs[intLeadIndex][k].ref_ROIPositionX;
                ptTemp.Y = m_smVisionInfo.g_arrLeadROIs[intLeadIndex][k].ref_ROIPositionY;

                arrTemp.Add(ptTemp);

                ptTemp = new PointF();
                ptTemp.X = m_smVisionInfo.g_arrLeadROIs[intLeadIndex][k].ref_ROIPositionX + m_smVisionInfo.g_arrLeadROIs[intLeadIndex][k].ref_ROIWidth;
                ptTemp.Y = m_smVisionInfo.g_arrLeadROIs[intLeadIndex][k].ref_ROIPositionY + m_smVisionInfo.g_arrLeadROIs[intLeadIndex][k].ref_ROIHeight;

                arrTemp.Add(ptTemp);

                arrDontCare.Add(new List<PointF>());
                arrDontCare[j].Add(arrTemp[0]);
                arrDontCare[j].Add(arrTemp[1]);

                j++;

                m_smVisionInfo.g_arrLeadROIs[intLeadIndex][k].AttachImage(m_smVisionInfo.g_arrInspectLeadROI[intLeadIndex]);    // Attach to Sample Unit ROI or Package ROI
                m_smVisionInfo.g_arrLeadROIs[intLeadIndex][k].DrawDontCareEdge(0);

                if (m_smVisionInfo.g_arrLead[0].ref_blnWantInspectBaseLead)
                {
                    m_smVisionInfo.g_arrLeadROIs[intLeadIndex][k].AttachImage(m_smVisionInfo.g_arrInspectLeadROI_BaseLead[intLeadIndex]);    // Attach to Sample Unit ROI or Package ROI
                    m_smVisionInfo.g_arrLeadROIs[intLeadIndex][k].DrawDontCareEdge(0);
                }
            }

            bool blnResult = true;

            if (!m_smVisionInfo.g_arrLead[intLeadIndex].InspectLead(
                m_smVisionInfo.g_arrInspectLeadROI[intLeadIndex],
                m_smVisionInfo.g_arrLeadROIs[intLeadIndex],
                arrDontCare))
            {
                intFailType |= 0x01;
                blnResult = false;
            }

            if (blnResult)
            {
                if (m_smVisionInfo.g_arrLead[0].ref_blnWantInspectBaseLead && (((m_smVisionInfo.g_arrLead[0].ref_intFailOptionMask & 0x10000) > 0) || ((m_smVisionInfo.g_arrLead[0].ref_intFailOptionMask & 0x20000) > 0)))
                {
                    //// Wait base lead image (default is image 3) grap done
                    //if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 0)
                    //    blnResult = WaitEventDone(ref m_bGrabImage1Done, true, ref m_bGrabImage1Result, "AAA58 1");
                    //else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 1)
                    //    blnResult = WaitEventDone(ref m_bGrabImage2Done, true, ref m_bGrabImage2Result, "AAA58 2");
                    //else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 2)
                    //    blnResult = WaitEventDone(ref m_bGrabImage3Done, true, ref m_bGrabImage3Result, "AAA58 3");
                    //else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 3)
                    //    blnResult = WaitEventDone(ref m_bGrabImage4Done, true, ref m_bGrabImage4Result, "AAA58 4");
                    //else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 4)
                    //    blnResult = WaitEventDone(ref m_bGrabImage5Done, true, ref m_bGrabImage5Result, "AAA58 5");
                    //else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 5)
                    //    blnResult = WaitEventDone(ref m_bGrabImage6Done, true, ref m_bGrabImage6Result, "AAA58 6");
                    //else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 6)
                    //    blnResult = WaitEventDone(ref m_bGrabImage7Done, true, ref m_bGrabImage7Result, "AAA58 7");

                    if (((m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo != m_smVisionInfo.g_arrLead[0].ref_intImageViewNo) &&
                       (m_blnWantPackageTest && m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetWantInspectPackage() &&
                        (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetGrabImageIndex(2) ||
                        m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetGrabImageIndex(3)))))
                    {
                        // Wait mark inspection done.
                        WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "IsLeadOK Base Lead > m_bSubTh_MarkTest");
                        if (!m_bSubTh_MarkTest_Result)
                        {
                            return blnResult;   // Skip if mark test fail.
                        }
                        // Wait package test done under mark light view 
                        WaitEventDone(ref m_bSubTh_PackageTest_MarkLightView, false, 10000, "IsLeadOK Base Lead > m_bSubTh_PackageTest_MarkLightView");
                        if (!m_bSubTh_PackageTest_MarkLightView_Result)
                        {
                            return blnResult;
                        }

                        if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetGrabImageIndex(2))
                        {
                            // Wait SideLightView Package done
                            WaitEventDone(ref m_bSubTh_PackageTest_SideLightView, false, 10000, "IsLeadOK Base Lead > m_bSubTh_PackageTest_SideLightView");
                            if (!m_bSubTh_PackageTest_SideLightView_Result)
                            {
                                return blnResult;
                            }

                            if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 0)
                                WaitEventDone(ref m_blnRotateImage1Updated, true, 10000, "IsLeadOK Base Lead > m_blnRotateImage1Updated");
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 1)
                                WaitEventDone(ref m_blnRotateImage2Updated, true, 10000, "IsLeadOK Base Lead > m_blnRotateImage2Updated");
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 2)
                                WaitEventDone(ref m_blnRotateImage3Updated, true, 10000, "IsLeadOK Base Lead > m_blnRotateImage3Updated");
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 3)
                                WaitEventDone(ref m_blnRotateImage4Updated, true, 10000, "IsLeadOK Base Lead > m_blnRotateImage4Updated");
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 4)
                                WaitEventDone(ref m_blnRotateImage5Updated, true, 10000, "IsLeadOK Base Lead > m_blnRotateImage5Updated");
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 5)
                                WaitEventDone(ref m_blnRotateImage6Updated, true, 10000, "IsLeadOK Base Lead > m_blnRotateImage6Updated");
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 6)
                                WaitEventDone(ref m_blnRotateImage7Updated, true, 10000, "IsLeadOK Base Lead > m_blnRotateImage7Updated");
                        }
                        else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetGrabImageIndex(3))
                        {
                            // Wait TopLightView Package done
                            WaitEventDone(ref m_bSubTh_PackageTest_TopLightView, false, 10000, "IsLeadOK Base Lead > m_bSubTh_PackageTest_TopLightView");
                            if (!m_bSubTh_PackageTest_TopLightView_Result)
                            {
                                return blnResult;
                            }

                            if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 0)
                                WaitEventDone(ref m_blnRotateImage1Updated, true, 10000, "IsLeadOK Base Lead > m_blnRotateImage1Updated");
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 1)
                                WaitEventDone(ref m_blnRotateImage2Updated, true, 10000, "IsLeadOK Base Lead > m_blnRotateImage2Updated");
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 2)
                                WaitEventDone(ref m_blnRotateImage3Updated, true, 10000, "IsLeadOK Base Lead > m_blnRotateImage3Updated");
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 3)
                                WaitEventDone(ref m_blnRotateImage4Updated, true, 10000, "IsLeadOK Base Lead > m_blnRotateImage4Updated");
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 4)
                                WaitEventDone(ref m_blnRotateImage5Updated, true, 10000, "IsLeadOK Base Lead > m_blnRotateImage5Updated");
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 5)
                                WaitEventDone(ref m_blnRotateImage6Updated, true, 10000, "IsLeadOK Base Lead > m_blnRotateImage6Updated");
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 6)
                                WaitEventDone(ref m_blnRotateImage7Updated, true, 10000, "IsLeadOK Base Lead > m_blnRotateImage7Updated");
                        }
                        

                        m_smVisionInfo.g_arrInspectLeadROI_BaseLead[intLeadIndex].AttachImage(m_smVisionInfo.g_arrRotatedImages[m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo]);
                    }

                    if (blnResult)
                    {
                        if (!m_smVisionInfo.g_arrLead[intLeadIndex].InspectBaseLead(
                                       m_smVisionInfo.g_arrInspectLeadROI_BaseLead[intLeadIndex],
                                       m_smVisionInfo.g_arrLeadROIs[intLeadIndex],
                                       arrDontCare))
                        {
                            intFailType |= 0x02;

                            blnResult = false;
                        }
                    }
                }
            }

            return blnResult;
        }
        private bool IsLeadOK_ForBaseLineRotation(int intLeadIndex)
        {
            if (!m_smVisionInfo.g_arrLead[0].GetWantInspectLead()) //(!m_smVisionInfo.g_blnCheckLead)
                return true;

            if (m_objLeadImage == null)
                m_objLeadImage = new ImageDrawing(true);

            //Copy rotated image to a temp image

            m_smVisionInfo.g_objLeadImage.CopyTo(ref m_objLeadImage);


            // Define Sample Unit ROI attach to sample image          
            m_smVisionInfo.g_arrInspectLeadROI[intLeadIndex].AttachImage(m_objLeadImage);

            // Same size as Unit ROI 
            if (m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Top == 0 &&
                m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Right == 0 &&
                m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Bottom == 0 &&
                m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Left == 0)
            {
                m_smVisionInfo.g_arrInspectLeadROI[intLeadIndex].LoadROISetting(
                   (int)Math.Round(m_smVisionInfo.g_arrLead[intLeadIndex].GetResultCenterPoint_UnitMatcher().X -
                   ((float)m_smVisionInfo.g_arrLeadROIs[intLeadIndex][0].ref_ROIWidth / 2), 0, MidpointRounding.AwayFromZero),
                   (int)Math.Round(m_smVisionInfo.g_arrLead[intLeadIndex].GetResultCenterPoint_UnitMatcher().Y -
                   ((float)m_smVisionInfo.g_arrLeadROIs[intLeadIndex][0].ref_ROIHeight / 2), 0, MidpointRounding.AwayFromZero),
                   m_smVisionInfo.g_arrLeadROIs[intLeadIndex][0].ref_ROIWidth,
                   m_smVisionInfo.g_arrLeadROIs[intLeadIndex][0].ref_ROIHeight);
            }
            else
            {
                m_smVisionInfo.g_arrInspectLeadROI[intLeadIndex].LoadROISetting(
              (int)Math.Round(m_smVisionInfo.g_arrLead[intLeadIndex].GetResultCenterPoint_UnitMatcher().X -
              ((float)m_smVisionInfo.g_arrLead[intLeadIndex].GetPatternSize_UnitMatcher().Width / 2) - m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Left, 0, MidpointRounding.AwayFromZero),
              (int)Math.Round(m_smVisionInfo.g_arrLead[intLeadIndex].GetResultCenterPoint_UnitMatcher().Y -
              ((float)m_smVisionInfo.g_arrLead[intLeadIndex].GetPatternSize_UnitMatcher().Height / 2) - m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Top, 0, MidpointRounding.AwayFromZero),
              m_smVisionInfo.g_arrLead[intLeadIndex].GetPatternSize_UnitMatcher().Width + m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Left + m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Right,
              m_smVisionInfo.g_arrLead[intLeadIndex].GetPatternSize_UnitMatcher().Height + m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Top + m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Bottom);
            }

            //m_smVisionInfo.g_arrInspectLeadROI[intLeadIndex].SaveImage("D:\\TS\\InspectLeadROI1.bmp");
            //m_smVisionInfo.g_arrInspectLeadPkgROI[intLeadIndex][0].SaveImage("D:\\TS\\InspectLeadPkgROI.bmp");

            // 2021-08-20 ZJYEOH : dont care 4 sides of ROI to avoid built noise surrounding Lead because image is not rotated
            {
                if (m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Top == 0 &&
                    m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Right == 0 &&
                    m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Bottom == 0 &&
                    m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Left == 0)
                {
                    float fWidth = m_smVisionInfo.g_arrLead[intLeadIndex].GetPatternSize_UnitMatcher().Width;
                    float fHeight = m_smVisionInfo.g_arrLead[intLeadIndex].GetPatternSize_UnitMatcher().Height;

                    float CenterX = 0;
                    float CenterY = 0;

                    CenterX = m_smVisionInfo.g_arrLead[intLeadIndex].GetResultCenterPoint_UnitMatcher().X;

                    CenterY = m_smVisionInfo.g_arrLead[intLeadIndex].GetResultCenterPoint_UnitMatcher().Y;

                    List<Point> arrPoints = new List<Point>();
                    arrPoints.Add(new Point((int)(CenterX - (fWidth / 2)), (int)(CenterY - (fHeight / 2))));
                    arrPoints.Add(new Point((int)(CenterX + (fWidth / 2)), (int)(CenterY - (fHeight / 2))));
                    arrPoints.Add(new Point((int)(CenterX + (fWidth / 2)), (int)(CenterY + (fHeight / 2))));
                    arrPoints.Add(new Point((int)(CenterX - (fWidth / 2)), (int)(CenterY + (fHeight / 2))));

                    DontCareWithoutRotateImage.ProduceImage_ForLead(arrPoints, m_objLeadImage, m_smVisionInfo.g_objWhiteImage, m_smVisionInfo.g_objBlackImage, m_fLeadPatternAngle, true, m_smVisionInfo.g_arrInspectLeadROI[intLeadIndex]);
                }
                else
                {
                    float fWidth = m_smVisionInfo.g_arrInspectLeadROI[intLeadIndex].ref_ROIWidth;
                    float fHeight = m_smVisionInfo.g_arrInspectLeadROI[intLeadIndex].ref_ROIHeight;

                    float CenterX = 0;
                    float CenterY = 0;

                    CenterX = m_smVisionInfo.g_arrInspectLeadROI[intLeadIndex].ref_ROICenterX;

                    CenterY = m_smVisionInfo.g_arrInspectLeadROI[intLeadIndex].ref_ROICenterY;

                    List<Point> arrPoints = new List<Point>();
                    arrPoints.Add(new Point((int)(CenterX - (fWidth / 2)), (int)(CenterY - (fHeight / 2))));
                    arrPoints.Add(new Point((int)(CenterX + (fWidth / 2)), (int)(CenterY - (fHeight / 2))));
                    arrPoints.Add(new Point((int)(CenterX + (fWidth / 2)), (int)(CenterY + (fHeight / 2))));
                    arrPoints.Add(new Point((int)(CenterX - (fWidth / 2)), (int)(CenterY + (fHeight / 2))));

                    DontCareWithoutRotateImage.ProduceImage_ForLead(arrPoints, m_objLeadImage, m_smVisionInfo.g_objWhiteImage, m_smVisionInfo.g_objBlackImage, m_fLeadPatternAngle, true, m_smVisionInfo.g_arrInspectLeadROI[intLeadIndex]);
                }
                //m_smVisionInfo.g_arrInspectLeadROI[intLeadIndex].SaveImage("D:\\TS\\InspectLeadROI" + intLeadIndex + ".bmp");
            }

            int j = 0;
            List<List<PointF>> arrDontCare = new List<List<PointF>>();


            //Draw don't care ROI edge to make sure Don't Care Area is not inspected
            for (int k = 1; k < m_smVisionInfo.g_arrLeadROIs[intLeadIndex].Count; k++)
            {
                PointF ptTemp;
                List<PointF> arrTemp = new List<PointF>();

                ptTemp = new PointF();
                ptTemp.X = m_smVisionInfo.g_arrLeadROIs[intLeadIndex][k].ref_ROIPositionX;
                ptTemp.Y = m_smVisionInfo.g_arrLeadROIs[intLeadIndex][k].ref_ROIPositionY;

                arrTemp.Add(ptTemp);

                ptTemp = new PointF();
                ptTemp.X = m_smVisionInfo.g_arrLeadROIs[intLeadIndex][k].ref_ROIPositionX + m_smVisionInfo.g_arrLeadROIs[intLeadIndex][k].ref_ROIWidth;
                ptTemp.Y = m_smVisionInfo.g_arrLeadROIs[intLeadIndex][k].ref_ROIPositionY + m_smVisionInfo.g_arrLeadROIs[intLeadIndex][k].ref_ROIHeight;

                arrTemp.Add(ptTemp);

                arrDontCare.Add(new List<PointF>());
                arrDontCare[j].Add(arrTemp[0]);
                arrDontCare[j].Add(arrTemp[1]);

                j++;

                m_smVisionInfo.g_arrLeadROIs[intLeadIndex][k].AttachImage(m_smVisionInfo.g_arrInspectLeadROI[intLeadIndex]);    // Attach to Sample Unit ROI or Package ROI
                m_smVisionInfo.g_arrLeadROIs[intLeadIndex][k].DrawDontCareEdge(0);
            }

            if (!m_smVisionInfo.g_arrLead[intLeadIndex].InspectLead_ForBaseLineRotation(
                m_smVisionInfo.g_arrInspectLeadROI[intLeadIndex],
                m_smVisionInfo.g_arrLeadROIs[intLeadIndex],
                arrDontCare))
            {
                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        m_intTCPIPResultID = (int)TCPIPResulID.Fail;

                return false;
            }

            return true;
        }
        private bool IsUnitLengthVarianceOk()
        {
            float fLengthMinMM = -999;
            float fLengthMaxMM = -999;
            for (int i = 1; i < 5; i++)
            {
                if (m_smVisionInfo.g_arrLead[i].ref_blnSelected)
                {
                    if (m_smVisionInfo.g_arrLead[i].ref_fSampleLengthMinMM != -999)
                    {
                        if (fLengthMinMM == -999 || fLengthMinMM > m_smVisionInfo.g_arrLead[i].ref_fSampleLengthMinMM)
                            fLengthMinMM = m_smVisionInfo.g_arrLead[i].ref_fSampleLengthMinMM;
                    }

                    if (m_smVisionInfo.g_arrLead[i].ref_fSampleLengthMaxMM != -999)
                    {
                        if (fLengthMaxMM == -999 || fLengthMaxMM < m_smVisionInfo.g_arrLead[i].ref_fSampleLengthMaxMM)
                            fLengthMaxMM = m_smVisionInfo.g_arrLead[i].ref_fSampleLengthMaxMM;
                    }
                }
            }

            if (fLengthMinMM != -999 && fLengthMaxMM != -999)
            {
                m_smVisionInfo.g_arrLead[0].ref_fSampleLengthMinMM = fLengthMinMM;
                m_smVisionInfo.g_arrLead[0].ref_fSampleLengthMaxMM = fLengthMaxMM;
                m_smVisionInfo.g_arrLead[0].ref_fSampleLengthVarianceMM = fLengthMaxMM - fLengthMinMM;
            }

            if (m_smVisionInfo.g_arrLead[0].ref_fSampleLengthVarianceMM > m_smVisionInfo.g_arrLead[0].ref_fTemplateLengthVarianceMaxLimit)
            {
                //fail unit length variance
                m_smVisionInfo.g_arrLead[0].ref_intFailResultMask |= 0x800; // 0x800 mean fail variance. Lead index 0 mean comparison of all leads length.
                return false;
            }

            return true;
        }
        private bool IsUnitSpanOk()
        {
            if (m_smVisionInfo.g_arrLead[1].ref_blnSelected && m_smVisionInfo.g_arrLead[3].ref_blnSelected)
            {
                float fsampleUnitSpan = (m_smVisionInfo.g_arrLead[3].ref_fLeadUnitSpanTipCenterXY - m_smVisionInfo.g_arrLead[1].ref_fLeadUnitSpanTipCenterXY) / m_smVisionInfo.g_fCalibPixelX;

                m_smVisionInfo.g_arrLead[0].ref_fLeadSpanResultMM = fsampleUnitSpan;

                if (fsampleUnitSpan < m_smVisionInfo.g_arrLead[0].ref_fTemplateLeadMinSpanLimit || fsampleUnitSpan > m_smVisionInfo.g_arrLead[0].ref_fTemplateLeadMaxSpanLimit)
                {
                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        if (m_intTCPIPResultID == -1)
                            m_intTCPIPResultID = (int)TCPIPResulID.Fail;

                    //fail span
                    m_smVisionInfo.g_arrLead[0].ref_intFailResultMask |= 0x1000;
                    m_smVisionInfo.g_arrLead[1].ref_intFailResultMask |= 0x1000;
                    m_smVisionInfo.g_arrLead[3].ref_intFailResultMask |= 0x1000;
                    return false;
                }
            }
            else if (m_smVisionInfo.g_arrLead[2].ref_blnSelected && m_smVisionInfo.g_arrLead[4].ref_blnSelected)
            {
                float fsampleUnitSpan = (m_smVisionInfo.g_arrLead[2].ref_fLeadUnitSpanTipCenterXY - m_smVisionInfo.g_arrLead[4].ref_fLeadUnitSpanTipCenterXY) / m_smVisionInfo.g_fCalibPixelX;

                m_smVisionInfo.g_arrLead[0].ref_fLeadSpanResultMM = fsampleUnitSpan;

                if (fsampleUnitSpan < m_smVisionInfo.g_arrLead[0].ref_fTemplateLeadMinSpanLimit || fsampleUnitSpan > m_smVisionInfo.g_arrLead[0].ref_fTemplateLeadMaxSpanLimit)
                {
                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        if (m_intTCPIPResultID == -1)
                            m_intTCPIPResultID = (int)TCPIPResulID.Fail;

                    //fail span
                    m_smVisionInfo.g_arrLead[0].ref_intFailResultMask |= 0x1000;
                    m_smVisionInfo.g_arrLead[2].ref_intFailResultMask |= 0x1000;
                    m_smVisionInfo.g_arrLead[4].ref_intFailResultMask |= 0x1000;
                    return false;
                }
            }

            return true;
        }
        //private bool IsUnitSpanOk()
        //{
        //    if (m_smVisionInfo.g_arrLead[1].ref_blnSelected && m_smVisionInfo.g_arrLead[3].ref_blnSelected)
        //    {
        //        float fSampleLeadMinSpanStart = 0;
        //        float fSampleLeadMaxSpanStart = 0;
        //        float fSampleLeadMinSpanEnd = 0;
        //        float fSampleLeadMaxSpanEnd = 0;
        //        float fSampleMinSpan = 0;
        //        float fsampleMaxSpan = 0;

        //        m_smVisionInfo.g_arrLead[1].GetSampleSpanData(1, ref fSampleLeadMinSpanStart, ref fSampleLeadMaxSpanStart);
        //        m_smVisionInfo.g_arrLead[3].GetSampleSpanData(3, ref fSampleLeadMinSpanEnd, ref fSampleLeadMaxSpanEnd);

        //        fSampleMinSpan = (fSampleLeadMinSpanEnd - fSampleLeadMinSpanStart) / m_smVisionInfo.g_fCalibPixelY;
        //        fsampleMaxSpan = (fSampleLeadMaxSpanEnd - fSampleLeadMaxSpanStart) / m_smVisionInfo.g_fCalibPixelY;

        //        for (int i = 0; i < m_smVisionInfo.g_arrLead.Length; i++)
        //        {
        //            m_smVisionInfo.g_arrLead[i].ref_fLeadMinSpanResult = fSampleMinSpan;
        //            m_smVisionInfo.g_arrLead[i].ref_fLeadMaxSpanResult = fsampleMaxSpan;
        //        }

        //        if (fSampleMinSpan < m_smVisionInfo.g_arrLead[0].ref_fTemplateLeadMinSpanLimit || fsampleMaxSpan > m_smVisionInfo.g_arrLead[0].ref_fTemplateLeadMaxSpanLimit)
        //        {
        //            //fail span
        //            m_smVisionInfo.g_arrLead[0].ref_intFailResultMask |= 0x1000;
        //            return false;
        //        }
        //    }
        //    else if (m_smVisionInfo.g_arrLead[2].ref_blnSelected && m_smVisionInfo.g_arrLead[4].ref_blnSelected)
        //    {
        //        float fSampleLeadMinSpanStart = 0;
        //        float fSampleLeadMaxSpanStart = 0;
        //        float fSampleLeadMinSpanEnd = 0;
        //        float fSampleLeadMaxSpanEnd = 0;
        //        float fSampleMinSpan = 0;
        //        float fsampleMaxSpan = 0;

        //        m_smVisionInfo.g_arrLead[4].GetSampleSpanData(4, ref fSampleLeadMinSpanStart, ref fSampleLeadMaxSpanStart);
        //        m_smVisionInfo.g_arrLead[2].GetSampleSpanData(2, ref fSampleLeadMinSpanEnd, ref fSampleLeadMaxSpanEnd);

        //        fSampleMinSpan = (fSampleLeadMinSpanEnd - fSampleLeadMinSpanStart) / m_smVisionInfo.g_fCalibPixelX;
        //        fsampleMaxSpan = (fSampleLeadMaxSpanEnd - fSampleLeadMaxSpanStart) / m_smVisionInfo.g_fCalibPixelX;

        //        for (int i = 0; i < m_smVisionInfo.g_arrLead.Length; i++)
        //        {
        //            m_smVisionInfo.g_arrLead[i].ref_fLeadMinSpanResult = fSampleMinSpan;
        //            m_smVisionInfo.g_arrLead[i].ref_fLeadMaxSpanResult = fsampleMaxSpan;
        //        }

        //        if (fSampleMinSpan < m_smVisionInfo.g_arrLead[0].ref_fTemplateLeadMinSpanLimit || fsampleMaxSpan > m_smVisionInfo.g_arrLead[0].ref_fTemplateLeadMaxSpanLimit)
        //        {
        //            //fail span
        //            m_smVisionInfo.g_arrLead[0].ref_intFailResultMask |= 0x1000;
        //            return false;
        //        }
        //    }

        //    return true;
        //}

        private void TakeAction(string strMessage)
        {
            if (m_smVisionInfo.g_intMachineStatus == 2 && m_smVisionInfo.AT_PR_StartLiveImage && strMessage == "Client disconnected.")
            {
                m_smVisionInfo.AT_PR_StartLiveImage = false;
                m_smVisionInfo.AT_PR_TriggerLiveImage = true;
            }

            if (!(strMessage.StartsWith("<") && strMessage.EndsWith(">")))
                return;

            try
            {
                string[] strString = strMessage.Split(',', '>');
                switch (strString[0])
                {
                    default:
                        break;
                }

            }
            catch (Exception ex)
            {
                SRMMessageBox.Show(ex.ToString());
            }
        }
        private void TakeAction_TCPIPIO(string strMessage)
        {
            if (m_smVisionInfo.g_intMachineStatus == 2 && m_smVisionInfo.AT_PR_StartLiveImage && strMessage == "Client disconnected.")
            {
                m_smVisionInfo.AT_PR_StartLiveImage = false;
                m_smVisionInfo.AT_PR_TriggerLiveImage = true;
            }

            if (!(strMessage.StartsWith("<") && strMessage.EndsWith(">")))
                return;

            try
            {
                strMessage = strMessage.Remove(0, 1);
                string[] strString = strMessage.Split(',', '>');

                if (strString.Length == 0)
                    return;

                int intTestOption = 0;
                if (strString.Length < 2 || !int.TryParse(strString[1], out intTestOption))
                    intTestOption = -1;

                int intVisionIndex = 0;
                if (strString.Length < 3 || !int.TryParse(strString[2], out intVisionIndex))
                    intVisionIndex = -1;

                switch (strString[0])
                {
                    case "SOV":
                        if (intVisionIndex != Math.Pow(2, m_smVisionInfo.g_intVisionIndex) || intTestOption < 0 || m_smVisionInfo.g_intMachineStatus != 2)
                            m_smTCPIPIO.Send(m_smVisionInfo.g_intVisionIndex, "SOVRP", false, -1/*intTestOption*/);
                        else
                        {
                            m_smTCPIPIO.Send(m_smVisionInfo.g_intVisionIndex, "SOVRP", true, intTestOption);

                            if ((intTestOption & 0x01) > 0)
                                m_blnStartVision_In = true;
                            else
                                m_blnStartVision_In = false;

                            if ((intTestOption & 0x02) > 0)
                                m_blnInPocketReTest_In = true;
                            else
                                m_blnInPocketReTest_In = false;

                            if ((intTestOption & 0x04) > 0)
                                m_blnInPocketEndOfReTest_In = true;
                            else
                                m_blnInPocketEndOfReTest_In = false;

                            if ((intTestOption & 0x08) > 0)
                                m_blnInPocketCheckEmpty_In = true;
                            else
                                m_blnInPocketCheckEmpty_In = false;

                            if ((intTestOption & 0x10) > 0)
                                m_blnInPocketRollbackRetest_In = true;
                            else
                                m_blnInPocketRollbackRetest_In = false;

                            if ((intTestOption & 0x40) > 0)
                                m_blnCheckOffset_In = true;
                            else
                                m_blnCheckOffset_In = false;

                            if ((intTestOption & 0x400) > 0)
                                m_blnMarkData0_In = true;
                            else
                                m_blnMarkData0_In = false;

                            if ((intTestOption & 0x800) > 0)
                                m_blnMarkData1_In = true;
                            else
                                m_blnMarkData1_In = false;

                            if ((intTestOption & 0x1000) > 0)
                                m_blnMarkData2_In = true;
                            else
                                m_blnMarkData2_In = false;

                            if ((intTestOption & 0x2000) > 0)
                                m_blnMarkData3_In = true;
                            else
                                m_blnMarkData3_In = false;

                            if ((intTestOption & 0x4000) > 0)
                                m_blnMarkData4_In = true;
                            else
                                m_blnMarkData4_In = false;

                            if ((intTestOption & 0x8000) > 0)
                                m_blnMarkData5_In = true;
                            else
                                m_blnMarkData5_In = false;

                        }
                        break;
                    case "EOV":
                        if (intVisionIndex != Math.Pow(2, m_smVisionInfo.g_intVisionIndex) || m_smVisionInfo.g_intMachineStatus != 2)
                            m_smTCPIPIO.Send(m_smVisionInfo.g_intVisionIndex, "EOVRP", false, intTestOption);
                        else
                        {
                            m_smTCPIPIO.Send(m_smVisionInfo.g_intVisionIndex, "EOVRP", true, intTestOption);
                        }
                        break;
                    default:
                        break;
                }

            }
            catch (Exception ex)
            {
                SRMMessageBox.Show(ex.ToString());
            }
        }
        private void WaitEventDone(ref bool bTriggerEvent, bool bBreakResult, int intTimeout, string strTrackName)
        {
            HiPerfTimer timeout = new HiPerfTimer();
            timeout.Start();

            while (true)
            {
                if (bTriggerEvent == bBreakResult)
                {
                    return;
                }

                if (timeout.Timing > intTimeout)
                {
                    STTrackLog.WriteLine(">>>>>>>>>>>>> Vision 4 time out 9 - " + strTrackName);
                    bTriggerEvent = bBreakResult;
                    break;
                }

                Thread.Sleep(1);    // 2018 10 01 - CCENG: Dun use Sleep(0) as it may cause other internal thread hang especially during waiting for grab image done. (Grab frame timeout happen)
            }

            timeout.Stop();
        }

        private void WaitEventDone(ref bool bTriggerEvent1, ref bool bTriggerEvent2, bool bBreakResult1, bool bBreakResult2, string strTrackName)
        {
            HiPerfTimer timeout = new HiPerfTimer();
            timeout.Start();

            while (true)
            {
                if (bTriggerEvent1 == bBreakResult1)
                {
                    return;
                }

                if (bTriggerEvent2 == bBreakResult2)
                {
                    return;
                }

                if (timeout.Timing > 10000)
                {
                    STTrackLog.WriteLine(">>>>>>>>>>>>> Vision 4 time out 11 - " + strTrackName);
                    bTriggerEvent1 = bBreakResult1;
                    bTriggerEvent2 = bBreakResult2;
                    break;
                }

                Thread.Sleep(1);    // 2018 10 01 - CCENG: Dun use Sleep(0) as it may cause other internal thread hang especially during waiting for grab image done. (Grab frame timeout happen)
            }

            timeout.Stop();
        }

        private bool WaitEventDone(ref bool bTriggerEvent, bool bBreakResult, ref bool bReturnResult, string strTrackName)
        {
            HiPerfTimer timeout = new HiPerfTimer();
            timeout.Start();

            while (true)
            {
                if (bTriggerEvent == bBreakResult)
                {
                    return bReturnResult;
                }

                if (timeout.Timing > 10000)
                {
                    STTrackLog.WriteLine(">>>>>>>>>>>>> Vision 4 time out 10 - " + strTrackName);
                    bTriggerEvent = bBreakResult;
                    break;
                }

                Thread.Sleep(1);    // 2018 10 01 - CCENG: Dun use Sleep(0) as it may cause other internal thread hang especially during waiting for grab image done. (Grab frame timeout happen)
            }

            timeout.Stop();

            return false;
        }
        private void UpdateProgress()
        {
            try
            {
                while (!m_blnStopping)
                {
                    if (!m_blnPause)
                    {
                        if (m_smVisionInfo.MN_PR_GrabImage || m_smVisionInfo.AT_PR_GrabImage)
                        {
                            m_smVisionInfo.g_blnGrabbing = true;
                            if (m_smVisionInfo.AT_PR_GrabImage) // 01-08-2019 ZJYEOH : Only clear drawing result when user pressed grab button, solved "grab before test" no drawings 
                                m_smVisionInfo.g_blnClearResult = true;

                            GrabImage(false);

                            // 2019-12-26 ZJYEOH : Copy Image to Rotated Image so that will not look weird when draw rotated Image
                            for (int i = 0; i < m_smVisionInfo.g_arrImages.Count; i++)
                                m_smVisionInfo.g_arrImages[i].CopyTo(m_smVisionInfo.g_arrRotatedImages[i]);

                            m_smVisionInfo.ALL_VM_UpdatePictureBox = true;
                            m_smVisionInfo.VS_AT_UpdateQuantity = true;
                            m_smVisionInfo.VM_AT_UpdateErrorMessage = true;
                            m_smVisionInfo.g_blnGrabbing = false;
                            m_smVisionInfo.MN_PR_GrabImage = false;
                            m_smVisionInfo.AT_PR_GrabImage = false;
                        }

                        if (m_smVisionInfo.AT_PR_StartLiveImage && !m_smVisionInfo.AT_PR_PauseLiveImage)
                        {
                            m_smVisionInfo.g_blnGrabbing = true;
                            m_smVisionInfo.g_blnClearResult = true;

                            GrabImage(false);

                            // 2019-12-26 ZJYEOH : Copy Image to Rotated Image so that will not look weird when draw rotated Image
                            for (int i = 0; i < m_smVisionInfo.g_arrImages.Count; i++)
                                m_smVisionInfo.g_arrImages[i].CopyTo(m_smVisionInfo.g_arrRotatedImages[i]);

                            m_smVisionInfo.VS_AT_UpdateQuantity = true;
                            m_smVisionInfo.VM_AT_UpdateErrorMessage = true;
                            m_smVisionInfo.g_blnGrabbing = false;
                            System.Threading.Thread.Sleep(50);
                        }

                        if (m_smVisionInfo.AT_PR_AttachImagetoROI)
                        {
                            AttachImageToROI();

                            // 2019-10-14 ZJYEOH : AttachImageToROI for Lead move to here as crash may happen between UpdateSubProgress_MarkTest threading & UpdateSubProgress_LeadTest threading during attach and detach
                            // no need attach to Lead ROI during UpdateSubProgress_MarkTest
                            if ((m_smCustomizeInfo.g_intWantLead & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
                            {
                                if (m_smVisionInfo.g_objLeadImage == null)
                                    m_smVisionInfo.g_objLeadImage = new ImageDrawing(true);

                                m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo].CopyTo(ref m_smVisionInfo.g_objLeadImage);
                                AttachToROI(m_smVisionInfo.g_arrLeadROIs, m_smVisionInfo.g_objLeadImage);
                                //AttachToROI(m_smVisionInfo.g_arrLeadROIs, m_smVisionInfo.g_arrImages, m_smVisionInfo.g_arrLead[0].ref_intImageViewNo);
                            }

                            m_smVisionInfo.AT_PR_AttachImagetoROI = false;
                        }

                        if (m_smVisionInfo.CO_PR_DeleteTemplate)
                        {
                            m_smVisionInfo.CO_PR_DeleteTemplate = false;
                            if (m_smVisionInfo.g_blnWantClearMarkTemplateWhenNewLot)
                                m_smVisionInfo.PR_CO_DeleteProcessSuccess = DeleteTemplate();
                            else
                                m_smVisionInfo.PR_CO_DeleteProcessSuccess = true;
                            m_smVisionInfo.PR_CO_DeleteTemplateDone = true;
                        }

                        if (m_smVisionInfo.MN_PR_StartTest && !m_smVisionInfo.AT_PR_AttachImagetoROI)
                        {
                            //m_smVisionInfo.g_objGrabTime.Reset();
                            //m_smVisionInfo.g_objTransferTime.Reset();
                            m_smVisionInfo.g_objTotalTime.Start();
                            m_smVisionInfo.MN_PR_StartTest = false;

                            if (m_smVisionInfo.g_intUnitsOnImage == 1)
                                StartTest_MultiThreading(false);
                            else
                                StartTest_MultiThreading_2Units(false);

                            m_smVisionInfo.g_objTotalTime.Stop();
                            //m_smVisionInfo.ALL_VM_UpdatePictureBox = true;
                            m_smVisionInfo.PR_MN_TestDone = true;
                            m_smVisionInfo.VM_AT_BlockImageUpdate = false;
                            m_smVisionInfo.PR_MN_UpdateInfo = true;
                            if (m_smVisionInfo.g_intViewInspectionSetting == 0)
                                m_smVisionInfo.VM_AT_UpdateErrorMessage = true;
                            else
                                m_smVisionInfo.g_strErrorMessage = "";
                            //2020-08-12 ZJYEOH : After tolerance orm close just set to false so that when manual test will check all leads
                            //m_smVisionInfo.AT_VM_OfflineTestAllLead = false;
                        }

                        if ((!m_smCustomizeInfo.g_blnWantUseTCPIPIO && m_objVisionIO.IOStartVision.IsOn() && m_smVisionInfo.g_intMachineStatus == 2) ||
                            (m_smCustomizeInfo.g_blnWantUseTCPIPIO && m_blnStartVision_In && m_smVisionInfo.g_intMachineStatus == 2) ||
                            (m_smVisionInfo.g_blnDebugRUN && m_smVisionInfo.g_intMachineStatus == 2))
                        {
                            m_blnDefaultRetestON = false;
                            if (m_smVisionInfo.g_blnDebugRUN && (m_smProductionInfo.g_blnAllRunWithoutGrabImage || m_smProductionInfo.g_blnAllRunGrabWithoutUseImage) && (m_smProductionInfo.g_intDebugImageToUse == 1))
                            {
                                LoadNextImageForDebugRunTest();
                            }

                            //m_smVisionInfo.g_objGrabTime.Reset();
                            //m_smVisionInfo.g_objTransferTime.Reset();
                            m_smVisionInfo.g_objTotalTime.Start();
                            m_smVisionInfo.VS_AT_ProductionTestDone = false;

                            if (!m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                            {
                                m_objVisionIO.IOEndVision.SetOff("V4 IOEndVision 107");
                                if (m_objVisionIO.OffsetDone != null)
                                    m_objVisionIO.OffsetDone.SetOn("V4 Offset done 101");
                            }
                            else
                            {
                                m_blnStartVision_In = false;
                                m_blnEndVision_Out = false;
                                m_blnInPocketOffsetDone_Out = true;
                                m_intTCPIPResultID = -1;
                                m_fOffsetX = 0;
                                m_fOffsetY = 0;
                                m_fOffsetAngle = 0;

                            }
                            m_blnGrabbing_Out = true;
                            //STTrackLog.WriteLine(m_smVisionInfo.g_strVisionName + "------------ Start");

                            if (m_smVisionInfo.g_intUnitsOnImage == 1)
                                StartTest_MultiThreading(true);
                            else
                                StartTest_MultiThreading_2Units(true);
                            //STTrackLog.WriteLine(m_smVisionInfo.g_strVisionName + "------------ End");

                            if (!m_blnForceStopProduction)
                            {
                                if (!m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                                {
                                    if (m_objVisionIO.OffsetDone != null)
                                        m_objVisionIO.OffsetDone.SetOff("V4 Offset done 103");

                                    m_smVisionInfo.g_objTotalTime.Stop();
                                    m_objVisionIO.IOEndVision.SetOn("V4 IOEndVision 9");
                                }
                                else
                                {
                                    m_blnInPocketOffsetDone_Out = false;

                                    m_smVisionInfo.g_objTotalTime.Stop();
                                    m_blnEndVision_Out = true;
                                }
                            }
                            else
                            {
                                STTrackLog.WriteLine("Vision4Process > Force Stop Production");
                                m_blnForceStopProduction = false;
                                m_smVisionInfo.g_intMachineStatus = 1;
                            }


                            m_smProductionInfo.VM_TH_UpdateCount = true;
                            m_smVisionInfo.VM_AT_UpdateErrorMessage = true;

                            m_smVisionInfo.VS_AT_ProductionTestDone = true;

                            if (m_smVisionInfo.g_blnDebugRUN)
                                Thread.Sleep(m_smVisionInfo.g_intSleep);
                            else
                            {
                                if (m_smVisionInfo.g_intSleep > 1)              // Change to > 1 to prevent calling this sleep function during production when not necessary.
                                    Thread.Sleep(m_smVisionInfo.g_intSleep);
                            }

                            if (m_smProductionInfo.g_blnAllRunFromCenter)
                                m_smVisionInfo.g_blnDebugRUN = false;

                        }

#if(RTXDebug || RTXRelease)
                    
                    if (m_smCustomizeInfo.g_blnShareHandlerPC && m_smVisionInfo.g_intMachineStatus == 2 && SRMSingleLock("IPM1_SOV"))
                    {
                        SRMResetEvent("IPM1_EOV");
                        SRMResetEvent("IPM1_Pass1");
                        SRMSetEvent("MOPkg_Grabbing");

                        m_objVisionIO.IOEndVision.SetOff("V4 ");
                        StartTest_MultiThreading(true);
                        
                        m_objVisionIO.IOEndVision.SetOn("V4 ");
                        m_smProductionInfo.VM_TH_UpdateCount = true;
                        m_smVisionInfo.VM_AT_UpdateErrorMessage = true;

                        if (m_smVisionInfo.g_blnDebugRUN)
                            Thread.Sleep(50);

                    }
#endif
                        if (!m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        {
                            if (m_objVisionIO.IOEndVision.IsOn() && m_smVisionInfo.g_intMachineStatus != 2)
                                m_objVisionIO.IOEndVision.SetOff("V4 IOEndVision 10");
                            else if (m_objVisionIO.IOEndVision.IsOff() && m_smVisionInfo.g_intMachineStatus == 2)
                                m_objVisionIO.IOEndVision.SetOn("V4 IOEndVision 11");
                        }
                        else
                        {
                            if (m_blnEndVision_Out && m_smVisionInfo.g_intMachineStatus != 2)
                                m_blnEndVision_Out = false;
                            else if (!m_blnEndVision_Out && m_smVisionInfo.g_intMachineStatus == 2)
                                m_blnEndVision_Out = true;
                        }

                        if (m_smVisionInfo.g_blnWantClearSaveImageInfo)
                        {
                            m_arrPassNoBuffer = new int[m_smVisionInfo.g_intSaveImageBufferSize];
                            m_arrFailNoBuffer = new int[m_smVisionInfo.g_intSaveImageBufferSize];
                            m_arrRejectNameBuffer = new string[m_smVisionInfo.g_intSaveImageBufferSize];
                            m_arrRejectMessageBuffer = new string[m_smVisionInfo.g_intSaveImageBufferSize];

                            m_arrRejectImageListPath.Clear();
                            m_arrRejectImageErrorMessageListPath.Clear();

                            m_smVisionInfo.g_blnWantClearSaveImageInfo = false;
                        }
                    }

                    Thread.Sleep(1);
                }
            }
            catch (Exception ex)
            {
                SRMMessageBox.Show("Vision4Process->UpdateProgress() :" + ex.ToString());
                SRMMessageBox.Show("Vision4Process has been terminated. Please Exit SRMVision software and Run again!", "Vision4Process", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
            finally
            {
                if (m_smVisionInfo.g_strCameraModel == "AVT")
                    m_objAVTFireGrab.OFFCamera();
                else if (m_smVisionInfo.g_strCameraModel == "Teli")
                {
                    if (m_blnCustomWantColor)
                        m_objTeliCamera.OFFCamera_LowLevelAPI();
                    else
                    {
                        if (m_smVisionInfo.g_intGrabMode == 0)
                            m_objTeliCamera.OFFCamera();
                        else
                            m_objTeliCamera.OFFCamera_LowLevelAPI();
                    }
                }
                m_thThread = null;
                m_blnStopped = true;
            }
        }

        private void UpdateSubProgress_GrabImage()
        {
            while (!m_blnStopping)
            {

                try
                {
                    if (m_bSubTh1_GrabImage)
                    {
                        m_bSubTh1_GrabImage = false;
                        GrabImage(m_blnAuto);
                    }

                }
                catch (Exception ex)
                {
                    m_bSubTh1_GrabImage = false;

                    SRMMessageBox.Show("Vision4Process->UpdateSubProgress_GrabImage() :" + ex.ToString());
                }
                Thread.Sleep(1);
            }

            m_thSubThread_GrabImage = null;
            m_blnStopped_GrabImage = true;

        }

        private void UpdateSubProgress_SaveImage()
        {
            while (!m_blnStopping)
            {

                try
                {
                    if ((m_intPassStartNode != m_intPassEndNode) ||
                        (m_intFailStartNode != m_intFailEndNode))
                    {
                        SaveImageBuffer();
                    }
                }
                catch (Exception ex)
                {
                    SRMMessageBox.Show("Vision4Process->UpdateSubProgress_GrabImage() :" + ex.ToString());
                }
                Thread.Sleep(1);
            }

            m_thSubThread_SaveImage = null;
            m_blnStopped_SaveImage = true;
        }
        private void UpdateSubProgress_TransferImage()
        {
            while (!m_blnStopping)
            {

                try
                {
                    if (m_bSubTh1_TransferImage)
                    {
                        //HiPerfTimer tTransfer = new HiPerfTimer();
                        //tTransfer.Start();
                        bool blnStartTransfer = false;
                        for (int i = 0; i < m_intGrabRequire; i++)
                        {
                            blnStartTransfer = false;

                            switch (i)
                            {
                                case 0:
                                    blnStartTransfer = WaitEventDone(ref m_bGrabImage1LoadDone, true, ref m_bGrabImage1LoadResult, "WaitGrab1");
                                    break;
                                case 1:
                                    blnStartTransfer = WaitEventDone(ref m_bGrabImage2LoadDone, true, ref m_bGrabImage2LoadResult, "WaitGrab2");
                                    break;
                                case 2:
                                    blnStartTransfer = WaitEventDone(ref m_bGrabImage3LoadDone, true, ref m_bGrabImage3LoadResult, "WaitGrab3");
                                    break;
                                case 3:
                                    blnStartTransfer = WaitEventDone(ref m_bGrabImage4LoadDone, true, ref m_bGrabImage4LoadResult, "WaitGrab4");
                                    break;
                                case 4:
                                    blnStartTransfer = WaitEventDone(ref m_bGrabImage5LoadDone, true, ref m_bGrabImage5LoadResult, "WaitGrab5");
                                    break;
                                case 5:
                                    blnStartTransfer = WaitEventDone(ref m_bGrabImage6LoadDone, true, ref m_bGrabImage6LoadResult, "WaitGrab6");
                                    break;
                                case 6:
                                    blnStartTransfer = WaitEventDone(ref m_bGrabImage7LoadDone, true, ref m_bGrabImage7LoadResult, "WaitGrab7");
                                    break;
                                default:
                                    blnStartTransfer = false;
                                    break;
                            }

                            if (blnStartTransfer)
                            {
                                if (m_smProductionInfo.g_blnAllRunGrabWithoutUseImage)
                                {
                                    if (m_smVisionInfo.g_blnViewColorImage)
                                    {
                                        if (m_smVisionInfo.g_arrDebugColorImages.Count != m_smVisionInfo.g_arrColorImages.Count)
                                        {
                                            for (int d = 0; d < m_smVisionInfo.g_arrColorImages.Count; d++)
                                            {
                                                m_smVisionInfo.g_arrDebugColorImages.Add(new CImageDrawing(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight));
                                            }
                                        }
                                        m_objTeliCamera.ConvertImage(i);
                                        m_smVisionInfo.g_arrMemoryColorImage[i].LoadImageFromMemory(m_objTeliCamera.GetImagePointer());

                                        if (m_smVisionInfo.g_intRotateFlip == 1)
                                        {
                                            m_smVisionInfo.g_arrMemoryColorImage[i].Rotate180Image(ref m_smVisionInfo.g_arrCRotateImage, i);
                                        }
                                        else if (m_smVisionInfo.g_intRotateFlip == 2)
                                        {
                                            m_smVisionInfo.g_arrMemoryColorImage[i].Rotate90Image(ref m_smVisionInfo.g_arrCRotateImage, i);
                                        }
                                        else if (m_smVisionInfo.g_intRotateFlip == 3)
                                        {
                                            m_smVisionInfo.g_arrMemoryColorImage[i].RotateMinus90Image(ref m_smVisionInfo.g_arrCRotateImage, i);
                                        }
                                        else if (m_smVisionInfo.g_intRotateFlip == 4)
                                        {
                                            m_smVisionInfo.g_arrMemoryColorImage[i].FlipHorizontalImage(ref m_smVisionInfo.g_arrCRotateImage, i);
                                        }
                                        else if (m_smVisionInfo.g_intRotateFlip == 5)
                                        {
                                            m_smVisionInfo.g_arrMemoryColorImage[i].FlipVerticalImage(ref m_smVisionInfo.g_arrCRotateImage, i);
                                        }
                                        else
                                        {
                                            m_smVisionInfo.g_arrMemoryColorImage[i].CopyTo(ref m_smVisionInfo.g_arrCRotateImage, i);
                                        }

                                        m_smVisionInfo.g_arrCRotateImage[i].CopyTo(ref m_smVisionInfo.g_arrDebugColorImages, i);

                                        if (m_smVisionInfo.g_arrImageGain[i] != 1f)
                                        {
                                            m_smVisionInfo.g_arrDebugColorImages[i].AddGain(m_smVisionInfo.g_arrImageGain[i], m_smVisionInfo.g_intColorFormat);
                                        }

                                        if (i == 0)
                                        {
                                            if (m_smVisionInfo.g_blnEnhanceImage_Enable)
                                            {
                                                if (m_smVisionInfo.g_intEnhanceImage_Close > 0)
                                                    m_smVisionInfo.g_arrDebugColorImages[i].AddCloseMorphology(m_smVisionInfo.g_intEnhanceImage_Close);
                                                if (m_smVisionInfo.g_intEnhanceImage_Open > 0)
                                                    m_smVisionInfo.g_arrDebugColorImages[i].AddOpenMorphology(m_smVisionInfo.g_intEnhanceImage_Open);
                                                if (m_smVisionInfo.g_intEnhanceImage_Dilate > 0)
                                                    m_smVisionInfo.g_arrDebugColorImages[i].AddDilate(m_smVisionInfo.g_intEnhanceImage_Dilate);
                                                if (m_smVisionInfo.g_intEnhanceImage_Offset != 0)
                                                    m_smVisionInfo.g_arrDebugColorImages[i].AddOffset(m_smVisionInfo.g_intEnhanceImage_Offset, m_smVisionInfo.g_intColorFormat);
                                                if (m_smVisionInfo.g_fEnhanceImage_Gain != 1f)
                                                    m_smVisionInfo.g_arrDebugColorImages[i].AddGain(m_smVisionInfo.g_fEnhanceImage_Gain, m_smVisionInfo.g_intColorFormat);
                                            }
                                        }

                                        m_smVisionInfo.g_arrDebugColorImages[i].ConvertColorToMono(ref m_smVisionInfo.g_arrDebugImages, i);
                                    }
                                }
                                else
                                {
                                    if (m_smVisionInfo.g_blnViewColorImage)
                                    {
                                        //m_objTeliCamera.ConvertImage(i);
                                        //m_objTeliCamera.ConvertImage(/*m_arrBitmapData[i],*/ m_arrBufferPointer[i]);
                                        m_objTeliCamera.ConvertImage(i);
                                        m_smVisionInfo.g_arrMemoryColorImage[i].LoadImageFromMemory(m_objTeliCamera.GetImagePointer());

                                        if (m_smVisionInfo.g_intRotateFlip == 1)
                                        {
                                            m_smVisionInfo.g_arrMemoryColorImage[i].Rotate180Image(ref m_smVisionInfo.g_arrCRotateImage, i);
                                        }
                                        else if (m_smVisionInfo.g_intRotateFlip == 2)
                                        {
                                            m_smVisionInfo.g_arrMemoryColorImage[i].Rotate90Image(ref m_smVisionInfo.g_arrCRotateImage, i);
                                        }
                                        else if (m_smVisionInfo.g_intRotateFlip == 3)
                                        {
                                            m_smVisionInfo.g_arrMemoryColorImage[i].RotateMinus90Image(ref m_smVisionInfo.g_arrCRotateImage, i);
                                        }
                                        else if (m_smVisionInfo.g_intRotateFlip == 4)
                                        {
                                            m_smVisionInfo.g_arrMemoryColorImage[i].FlipHorizontalImage(ref m_smVisionInfo.g_arrCRotateImage, i);
                                        }
                                        else if (m_smVisionInfo.g_intRotateFlip == 5)
                                        {
                                            m_smVisionInfo.g_arrMemoryColorImage[i].FlipVerticalImage(ref m_smVisionInfo.g_arrCRotateImage, i);
                                        }
                                        else
                                        {
                                            m_smVisionInfo.g_arrMemoryColorImage[i].CopyTo(ref m_smVisionInfo.g_arrCRotateImage, i);
                                        }

                                        m_smVisionInfo.g_arrCRotateImage[i].CopyTo(ref m_smVisionInfo.g_arrColorImages, i);

                                        if (m_smVisionInfo.g_arrImageGain[i] != 1f)
                                        {
                                            m_smVisionInfo.g_arrColorImages[i].AddGain(m_smVisionInfo.g_arrImageGain[i], m_smVisionInfo.g_intColorFormat);
                                        }

                                        if (i == 0)
                                        {
                                            if (m_smVisionInfo.g_blnEnhanceImage_Enable)
                                            {
                                                if (m_smVisionInfo.g_intEnhanceImage_Close > 0)
                                                    m_smVisionInfo.g_arrColorImages[i].AddCloseMorphology(m_smVisionInfo.g_intEnhanceImage_Close);
                                                if (m_smVisionInfo.g_intEnhanceImage_Open > 0)
                                                    m_smVisionInfo.g_arrColorImages[i].AddOpenMorphology(m_smVisionInfo.g_intEnhanceImage_Open);
                                                if (m_smVisionInfo.g_intEnhanceImage_Dilate > 0)
                                                    m_smVisionInfo.g_arrColorImages[i].AddDilate(m_smVisionInfo.g_intEnhanceImage_Dilate);
                                                if (m_smVisionInfo.g_intEnhanceImage_Offset != 0)
                                                    m_smVisionInfo.g_arrColorImages[i].AddOffset(m_smVisionInfo.g_intEnhanceImage_Offset, m_smVisionInfo.g_intColorFormat);
                                                if (m_smVisionInfo.g_fEnhanceImage_Gain != 1f)
                                                    m_smVisionInfo.g_arrColorImages[i].AddGain(m_smVisionInfo.g_fEnhanceImage_Gain, m_smVisionInfo.g_intColorFormat);
                                            }
                                        }

                                        m_smVisionInfo.g_arrColorImages[i].ConvertColorToMono(ref m_smVisionInfo.g_arrImages, i);

                                    }
                                }

                                if (m_smProductionInfo.g_blnAllRunGrabWithoutUseImage)
                                {
                                    if (m_smVisionInfo.g_arrDebugImages.Count != m_smVisionInfo.g_arrImages.Count)
                                    {
                                        for (int d = 0; d < m_smVisionInfo.g_arrImages.Count; d++)
                                        {
                                            m_smVisionInfo.g_arrDebugImages.Add(new ImageDrawing(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight));
                                        }
                                    }
                                    if (!m_smVisionInfo.g_blnViewColorImage)
                                    {
                                        m_smVisionInfo.g_arrRotateImage[i].CopyTo(ref m_smVisionInfo.g_arrDebugImages, i);
                                        m_smVisionInfo.g_arrDebugImages[i].AddGain(m_smVisionInfo.g_arrImageGain[i]);

                                        // 2020 12 30 - CCENG: Do image processing to increase image contrast. (to solve mark no enough contrast case)
                                        if (i == 0)
                                        {
                                            if (m_smVisionInfo.g_blnEnhanceImage_Enable)
                                            {
                                                if (m_smVisionInfo.g_intEnhanceImage_Close > 0)
                                                    m_smVisionInfo.g_arrImages[i].AddCloseMorphology(m_smVisionInfo.g_intEnhanceImage_Close);
                                                if (m_smVisionInfo.g_intEnhanceImage_Open > 0)
                                                    m_smVisionInfo.g_arrImages[i].AddOpenMorphology(m_smVisionInfo.g_intEnhanceImage_Open);
                                                if (m_smVisionInfo.g_intEnhanceImage_Dilate > 0)
                                                    m_smVisionInfo.g_arrImages[i].AddDilate(m_smVisionInfo.g_intEnhanceImage_Dilate);
                                                if (m_smVisionInfo.g_intEnhanceImage_Offset != 0)
                                                    m_smVisionInfo.g_arrImages[i].AddOffset(m_smVisionInfo.g_intEnhanceImage_Offset);
                                                if (m_smVisionInfo.g_fEnhanceImage_Gain != 1f)
                                                    m_smVisionInfo.g_arrImages[i].AddGain(m_smVisionInfo.g_fEnhanceImage_Gain);
                                            }
                                        }
                                    }

                                }
                                else
                                {
                                    if (!m_smVisionInfo.g_blnViewColorImage)
                                    {
                                        m_smVisionInfo.g_arrRotateImage[i].CopyTo(ref m_smVisionInfo.g_arrImages, i);
                                        m_smVisionInfo.g_arrImages[i].AddGain(m_smVisionInfo.g_arrImageGain[i]);

                                        // 2020 12 30 - CCENG: Do image processing to increase image contrast. (to solve mark no enough contrast case)
                                        if (i == 0)
                                        {
                                            if (m_smVisionInfo.g_blnEnhanceImage_Enable)
                                            {
                                                if (m_smVisionInfo.g_intEnhanceImage_Close > 0)
                                                    m_smVisionInfo.g_arrImages[i].AddCloseMorphology(m_smVisionInfo.g_intEnhanceImage_Close);
                                                if (m_smVisionInfo.g_intEnhanceImage_Open > 0)
                                                    m_smVisionInfo.g_arrImages[i].AddOpenMorphology(m_smVisionInfo.g_intEnhanceImage_Open);
                                                if (m_smVisionInfo.g_intEnhanceImage_Dilate > 0)
                                                    m_smVisionInfo.g_arrImages[i].AddDilate(m_smVisionInfo.g_intEnhanceImage_Dilate);
                                                if (m_smVisionInfo.g_intEnhanceImage_Offset != 0)
                                                    m_smVisionInfo.g_arrImages[i].AddOffset(m_smVisionInfo.g_intEnhanceImage_Offset);
                                                if (m_smVisionInfo.g_fEnhanceImage_Gain != 1f)
                                                    m_smVisionInfo.g_arrImages[i].AddGain(m_smVisionInfo.g_fEnhanceImage_Gain);
                                            }
                                        }
                                    }

                                }

                                if (i == 0)
                                {
                                    m_bGrabImage1Result = true;
                                    m_bGrabImage1Done = true;
                                }
                                else if (i == 1)
                                {
                                    m_bGrabImage2Result = true;
                                    m_bGrabImage2Done = true;
                                }
                                else if (i == 2)
                                {
                                    m_bGrabImage3Result = true;
                                    m_bGrabImage3Done = true;
                                }
                                else if (i == 3)
                                {
                                    m_bGrabImage4Result = true;
                                    m_bGrabImage4Done = true;
                                }
                                else if (i == 4)
                                {
                                    m_bGrabImage5Result = true;
                                    m_bGrabImage5Done = true;
                                }
                                else if (i == 5)
                                {
                                    m_bGrabImage6Result = true;
                                    m_bGrabImage6Done = true;
                                }
                                else if (i == 6)
                                {
                                    m_bGrabImage7Result = true;
                                    m_bGrabImage7Done = true;
                                }

                            }
                            else
                            {
                                m_smVisionInfo.g_strErrorMessage = "Image Acquire Fail.";

                                if (i == 0)
                                {
                                    m_bGrabImage1Result = false;
                                    m_bGrabImage1Done = true;
                                }
                                else if (i == 1)
                                {
                                    m_bGrabImage2Result = false;
                                    m_bGrabImage2Done = true;
                                }
                                else if (i == 2)
                                {
                                    m_bGrabImage3Result = false;
                                    m_bGrabImage3Done = true;
                                }
                                else if (i == 3)
                                {
                                    m_bGrabImage4Result = false;
                                    m_bGrabImage4Done = true;
                                }
                                else if (i == 4)
                                {
                                    m_bGrabImage5Result = false;
                                    m_bGrabImage5Done = true;
                                }
                                else if (i == 5)
                                {
                                    m_bGrabImage6Result = false;
                                    m_bGrabImage6Done = true;
                                }
                                else if (i == 6)
                                {
                                    m_bGrabImage7Result = false;
                                    m_bGrabImage7Done = true;
                                }
                            }
                        }

                        m_bGrabImage1Done = m_bGrabImage2Done = m_bGrabImage3Done = m_bGrabImage4Done = m_bGrabImage5Done = m_bGrabImage6Done = m_bGrabImage7Done = true;

                        //tTransfer.Stop();
                        //STTrackLog.WriteLine("Transfer Time = " + tTransfer.Duration.ToString());
                        m_bSubTh1_TransferImage = false;

                    }

                }
                catch (Exception ex)
                {
                    SRMMessageBox.Show("Vision1Process->UpdateSubProgress_TransferImage() :" + ex.ToString());
                }
                Thread.Sleep(1);
            }

            m_thSubThread_TransferImage = null;
            m_blnStopped_TransferImage = true;

        }
        private void UpdateSubProgress_WaitFrame()
        {
            while (!m_blnStopping)
            {

                try
                {
                    if (m_bSubTh1_WaitFrame)
                    {
                        bool blnStartWaitFrame = false;
                        for (int i = 0; i < m_intGrabRequire; i++)
                        {
                            blnStartWaitFrame = false;

                            switch (i)
                            {
                                case 0:
                                    blnStartWaitFrame = WaitEventDone(ref m_bGrabImage1TriggerDone, true, ref m_bGrabImage1TriggerResult, "WaitTrigger1");
                                    break;
                                case 1:
                                    blnStartWaitFrame = WaitEventDone(ref m_bGrabImage2TriggerDone, true, ref m_bGrabImage2TriggerResult, "WaitTrigger2");
                                    break;
                                case 2:
                                    blnStartWaitFrame = WaitEventDone(ref m_bGrabImage3TriggerDone, true, ref m_bGrabImage3TriggerResult, "WaitTrigger3");
                                    break;
                                case 3:
                                    blnStartWaitFrame = WaitEventDone(ref m_bGrabImage4TriggerDone, true, ref m_bGrabImage4TriggerResult, "WaitTrigger4");
                                    break;
                                case 4:
                                    blnStartWaitFrame = WaitEventDone(ref m_bGrabImage5TriggerDone, true, ref m_bGrabImage5TriggerResult, "WaitTrigger5");
                                    break;
                                case 5:
                                    blnStartWaitFrame = WaitEventDone(ref m_bGrabImage6TriggerDone, true, ref m_bGrabImage6TriggerResult, "WaitTrigger6");
                                    break;
                                case 6:
                                    blnStartWaitFrame = WaitEventDone(ref m_bGrabImage7TriggerDone, true, ref m_bGrabImage7TriggerResult, "WaitTrigger7");
                                    break;
                                default:
                                    blnStartWaitFrame = false;
                                    break;
                            }
                            //if (blnStartWaitFrame)
                            //{
                            //    bool StartTriggerRead = false;
                            //    switch (i)
                            //    {
                            //        case 0:
                            //            StartTriggerRead = true;
                            //            break;
                            //        case 1:
                            //            StartTriggerRead = WaitEventDone(ref m_bGrabImage1LoadDone, true, "WaitLoad1");
                            //            break;
                            //        case 2:
                            //            StartTriggerRead = WaitEventDone(ref m_bGrabImage2LoadDone, true, "WaitLoad2");
                            //            break;
                            //        case 3:
                            //            StartTriggerRead = WaitEventDone(ref m_bGrabImage3LoadDone, true, "WaitLoad3");
                            //            break;
                            //        case 4:
                            //            StartTriggerRead = WaitEventDone(ref m_bGrabImage4LoadDone, true, "WaitLoad4");
                            //            break;
                            //    }
                            //    if (StartTriggerRead)
                            //    {
                            //        //STTrackLog.WriteLine("TriggerImageBufferRead = " + i.ToString());
                            //        m_objTeliCamera.TriggerImageBufferRead();
                            //    }
                            //}

                            if (blnStartWaitFrame && m_objTeliCamera.WaitFrameAcquiredReady(i))
                            {
                                //STTrackLog.WriteLine("Get Image Buffer " + (i + 1));
                                //STTrackLog.WriteLine("Get Image Buffer " + m_objTeliCamera.GetBufferPointer());
                                if (m_smVisionInfo.g_blnViewColorImage)
                                {
                                    //m_smVisionInfo.g_objMemoryColorImage.SetImageSize(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight);
                                    //m_smVisionInfo.g_objMemoryColorImage.LoadImageFromMemory(m_objTeliCamera.GetImagePointer());
                                    //m_smVisionInfo.g_objMemoryColorImage.CopyTo(ref m_smVisionInfo.g_arrColorImages, i - 1);
                                    //m_smVisionInfo.g_arrColorImages[i - 1].ConvertColorToMono(ref m_smVisionInfo.g_arrImages, i - 1);
                                    //if (m_smProductionInfo.g_blnAllRunGrabWithoutUseImage)
                                    //    m_smVisionInfo.g_arrColorImages[i - 1].ConvertColorToMono(ref m_smVisionInfo.g_arrDebugImages, i - 1);

                                    //m_smVisionInfo.g_arrMemoryColorImage[i].LoadImageFromMemory(m_objTeliCamera.GetImagePointer());
                                    //m_arrBitmapData.Add(m_objTeliCamera.GetBitmapData());
                                    //m_arrBufferPointer.Add(m_objTeliCamera.GetBufferPointer());
                                }
                                else
                                {
                                    //m_smVisionInfo.g_objMemoryImage.SetImageSize(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight);
                                    //m_smVisionInfo.g_objMemoryImage.LoadImageFromMemory(m_objTeliCamera.GetImagePointer());
                                    m_smVisionInfo.g_arrMemoryImage[i].LoadImageFromMemory(m_objTeliCamera.GetImageBufferPointer(i));//(m_objTeliCamera.GetImagePointer());

                                    if (m_smVisionInfo.g_intRotateFlip == 1)
                                    {
                                        m_smVisionInfo.g_arrMemoryImage[i].Rotate180Image(ref m_smVisionInfo.g_arrRotateImage, i);
                                    }
                                    else if (m_smVisionInfo.g_intRotateFlip == 2)
                                    {
                                        m_smVisionInfo.g_arrMemoryImage[i].Rotate90Image(ref m_smVisionInfo.g_arrRotateImage, i);
                                    }
                                    else if (m_smVisionInfo.g_intRotateFlip == 3)
                                    {
                                        m_smVisionInfo.g_arrMemoryImage[i].RotateMinus90Image(ref m_smVisionInfo.g_arrRotateImage, i);
                                    }
                                    else if (m_smVisionInfo.g_intRotateFlip == 4)
                                    {
                                        m_smVisionInfo.g_arrMemoryImage[i].FlipHorizontalImage(ref m_smVisionInfo.g_arrRotateImage, i);
                                    }
                                    else if (m_smVisionInfo.g_intRotateFlip == 5)
                                    {
                                        m_smVisionInfo.g_arrMemoryImage[i].FlipVerticalImage(ref m_smVisionInfo.g_arrRotateImage, i);
                                    }
                                    else
                                    {
                                        m_smVisionInfo.g_arrMemoryImage[i].CopyTo(ref m_smVisionInfo.g_arrRotateImage, i);
                                    }

                                }


                                if (i == 0)
                                {
                                    m_bGrabImage1LoadResult = true;
                                    m_bGrabImage1LoadDone = true;
                                }
                                else if (i == 1)
                                {
                                    m_bGrabImage2LoadResult = true;
                                    m_bGrabImage2LoadDone = true;
                                }
                                else if (i == 2)
                                {
                                    m_bGrabImage3LoadResult = true;
                                    m_bGrabImage3LoadDone = true;
                                }
                                else if (i == 3)
                                {
                                    m_bGrabImage4LoadResult = true;
                                    m_bGrabImage4LoadDone = true;
                                }
                                else if (i == 4)
                                {
                                    m_bGrabImage5LoadResult = true;
                                    m_bGrabImage5LoadDone = true;
                                }
                                else if (i == 5)
                                {
                                    m_bGrabImage6LoadResult = true;
                                    m_bGrabImage6LoadDone = true;
                                }
                                else if (i == 6)
                                {
                                    m_bGrabImage7LoadResult = true;
                                    m_bGrabImage7LoadDone = true;
                                }

                            }
                            else
                            {
                                m_smVisionInfo.g_strErrorMessage = "Wait Frame Timeout.";

                                //if (m_smVisionInfo.g_blnViewColorImage)
                                //m_arrBufferPointer.Add(IntPtr.Zero);
                                if (i == 0)
                                {
                                    m_bGrabImage1LoadResult = false;
                                    m_bGrabImage1LoadDone = true;
                                }
                                else if (i == 1)
                                {
                                    m_bGrabImage2LoadResult = false;
                                    m_bGrabImage2LoadDone = true;
                                }
                                else if (i == 2)
                                {
                                    m_bGrabImage3LoadResult = false;
                                    m_bGrabImage3LoadDone = true;
                                }
                                else if (i == 3)
                                {
                                    m_bGrabImage4LoadResult = false;
                                    m_bGrabImage4LoadDone = true;
                                }
                                else if (i == 4)
                                {
                                    m_bGrabImage5LoadResult = false;
                                    m_bGrabImage5LoadDone = true;
                                }
                                else if (i == 5)
                                {
                                    m_bGrabImage6LoadResult = false;
                                    m_bGrabImage6LoadDone = true;
                                }
                                else if (i == 6)
                                {
                                    m_bGrabImage7LoadResult = false;
                                    m_bGrabImage7LoadDone = true;
                                }
                            }
                        }

                        m_bGrabImage1LoadDone = m_bGrabImage2LoadDone = m_bGrabImage3LoadDone = m_bGrabImage4LoadDone = m_bGrabImage5LoadDone = m_bGrabImage6LoadDone = m_bGrabImage7LoadDone = true;

                        m_bSubTh1_WaitFrame = false;

                    }

                }
                catch (Exception ex)
                {
                    SRMMessageBox.Show("Vision1Process->UpdateSubProgress_WaitFrame() :" + ex.ToString());
                }
                Thread.Sleep(1);
            }

            m_thSubThread_WaitFrame = null;
            m_blnStopped_WaitFrame = true;

        }

        private void UpdateSubProgress_MarkTest()
        {
            while (!m_blnStopping)
            {

                try
                {
                    if (m_bSubTh_MarkTest)
                    {
                        //m_T1.Start();

                        //m_fTimingPrev = 0;
                        //m_fTiming = 0;
                        //m_strTrack += ",///////////////////Inside UpdateSubProgress_MarkTest////////////////////////";

                        //m_bSubTh_MarkTest_Result = false;


                        WaitEventDone(ref m_bGrabImage1Done, true, 10000, "AAA59");

                        AttachImageToROI();

                        bool blnResultOK = true;
                        bool blnResultOK2 = true;

                        if (m_smVisionInfo.g_blnWantGauge) //If User want use mark gauge
                        {
                            int[] arrUserSelectImageViewIndex;

                            if (m_blnWantOrientTest)
                                arrUserSelectImageViewIndex = m_smVisionInfo.g_arrOrientGaugeM4L[0].GetGaugeImageNoList();
                            else
                                arrUserSelectImageViewIndex = m_smVisionInfo.g_arrMarkGaugeM4L[0].GetGaugeImageNoList();

                            blnResultOK = blnResultOK2 = WaitEventDone(arrUserSelectImageViewIndex, "AAA60");

                            if (m_intScenario > 1 && blnResultOK && blnResultOK2)
                            {
                                int[] arrUserSelectImageViewIndex2;

                                if (m_blnWantOrientTest)
                                    arrUserSelectImageViewIndex2 = m_smVisionInfo.g_arrOrientGaugeM4L[1].GetGaugeImageNoList();
                                else
                                    arrUserSelectImageViewIndex2 = m_smVisionInfo.g_arrMarkGaugeM4L[1].GetGaugeImageNoList();

                                blnResultOK = blnResultOK2 = WaitEventDone(arrUserSelectImageViewIndex2, "AAA61");
                            }
                        }

                        bool blnWantMark = true;
                        
                        // ------------------ Orientation Test ---------------------------------------------------
                        switch (m_intScenario)
                        {
                            case 1:
                                m_bSubTh_MarkTest_Result = false;
                                m_bSubTh_MarkTest_Result2 = true;

                                if (m_smVisionInfo.g_arrMarks != null && m_smVisionInfo.g_arrMarks.Count > 0)
                                {
                                    blnWantMark = m_smVisionInfo.g_arrMarks[0].ref_blnCheckMark;
                                }

                                // 2020 06 28 - Need to check orientation also even though Mark Checking is not selected in option form. Because what user want is check mark but wont fail only.
                                // 2020 07 08 - Roll back to previous method, wont check mark if Mark Checking is not selected.
                                if (blnWantMark || ShowLiterationOnly)
                                {
                                    if (m_smProductionInfo.g_blnWantNonRotateInspection)
                                    {
                                        if (blnResultOK && !StartOrientTest_using4LGauge_OcvAngleAndPackageAngle_WithoutRotate(m_blnAuto, 0))   // Use orient gauge to measure unit location and size from image 1 only. No package here.
                                            blnResultOK = false;
                                    }
                                    else
                                    {
                                        if (blnResultOK && !StartOrientTest_using4LGauge_OcvAngleAndPackageAngle(m_blnAuto, 0))   // Use orient gauge to measure unit location and size from image 1 only. No package here.
                                            blnResultOK = false;
                                    }
                                }
                                m_blnOrientDataUpdated1 = true;
                                m_blnOrientGaugeUpdated1 = true;
                                // ------------------- Pin 1 Test --------------------------------------------------------
                                if (m_smVisionInfo.g_blnWantPin1)
                                {
                                    if (m_smVisionInfo.g_arrPin1[0].getWantCheckPin1(m_smVisionInfo.g_intSelectedTemplate)) // 12-07-2019 ZJYEOH : if inspection option there got tick, then just check pin 1
                                    {
                                        // 2020-11-07 ZJYEOH : Pin 1 should wait wait package gauge done if want check package
                                        if (!blnWantMark)
                                        {
                                            if (m_blnWantPackageTest && ((m_smVisionInfo.g_arrPackage[0].ref_intFailMask & 0x1000) > 0 || m_smVisionInfo.g_arrPackage[0].GetWantInspectPackage()))
                                            {
                                                if (m_smVisionInfo.g_arrPackage[0].GetGrabImageIndex(2) == 0 || m_smVisionInfo.g_arrPackage[0].GetGrabImageIndex(3) == 0)
                                                    WaitEventDone(ref m_bPackageSizePreTestDone1, true, 10000, "AAA62");
                                            }
                                        }

                                        if (blnResultOK && !StartPin1Test(m_blnAuto, 0))
                                            blnResultOK = false;
                                    }
                                }

                                // ------------------ Mark Test ----------------------------------------------------------
                                if (blnWantMark || ShowLiterationOnly)
                                {
                                    if (((m_smCustomizeInfo.g_intWantMark & (1 << m_smVisionInfo.g_intVisionPos)) > 0) && ((m_smCustomizeInfo.g_intWantOCR & (1 << m_smVisionInfo.g_intVisionPos)) == 0))
                                    {
                                        // 2020 04 15 - JBTAN: will continue to check mark even option uncheck check mark option
                                        // Checking Mark
                                        //if (blnWantMark && blnResultOK)
                                        if (blnResultOK)
                                        {
                                            if (m_smProductionInfo.g_blnWantNonRotateInspection)
                                            {
                                                if (!StartMarkTest_using4LGauge_OcvAngleAndPackageAngle_WithoutRotate(m_blnAuto, 0))       // Mark OCV Test
                                                {
                                                    // 2020 04 15 - JBTAN: check mark option enable only will set result fail
                                                    if (blnWantMark)
                                                        blnResultOK = false;
                                                }
                                            }
                                            else
                                            {
                                                if (!StartMarkTest_using4LGauge_OcvAngleAndPackageAngle(m_blnAuto, 0))       // Mark OCV Test
                                                {
                                                    // 2020 04 15 - JBTAN: check mark option enable only will set result fail
                                                    if (blnWantMark)
                                                        blnResultOK = false;
                                                }
                                            }
                                        }
                                    }
                                    else if ((m_smCustomizeInfo.g_intWantOCR & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
                                    {
                                        // 2020 04 15 - JBTAN: will continue to check mark even option uncheck check mark option
                                        // Checking Mark OCR
                                        //if (blnWantMark && blnResultOK)
                                        if (blnResultOK)
                                        {
                                            if (!StartMarkOCRTest(m_blnAuto, 0))   // Mark OCR Test
                                            {
                                                // 2020 04 15 - JBTAN: check mark option enable only will set result fail
                                                if (blnWantMark)
                                                    blnResultOK = false;
                                            }
                                        }
                                    }
                                }
                                m_bMarkTestDone1 = true;

                                m_bSubTh_MarkTest_Result = blnResultOK;
                                m_bSubTh_MarkTest_Result2 = blnResultOK2;

                                if (m_blnWantPocketPositionTest)
                                {
                                    bool blnPocketPisitonResult = true;
                                    if (!StartPocketPositionTest(m_blnAuto, false))   // Pocket Position Test
                                    {
                                        blnPocketPisitonResult = false;
                                    }

                                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                                    {
                                        m_fOffsetX = m_smVisionInfo.g_objPocketPosition.ref_fResultXDistance;
                                        m_fOffsetY = m_smVisionInfo.g_objPocketPosition.ref_fResultYDistance;
                                        m_fOffsetAngle = 0;
                                    }

                                    m_smVisionInfo.g_blnDrawPocketPositionResult = true;
                                    //if (m_blnAuto)
                                    if (!m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                                        m_smComThread.Send(GetTCPPocketPositionResult(blnPocketPisitonResult));

                                    if (blnPocketPisitonResult && ((!m_smCustomizeInfo.g_blnWantUseTCPIPIO && m_objVisionIO.InPocketReTest.IsOff(!m_blnDefaultRetestON)) || (m_smCustomizeInfo.g_blnWantUseTCPIPIO && !m_blnInPocketReTest_In)))
                                    {
                                        if (m_smVisionInfo.g_bPocketPositionMeanStatisticAnalysisON)
                                        {
                                            m_smVisionInfo.g_intPocketPositionMeanStatisticAnalysisCount++;
                                            m_smVisionInfo.g_bPocketPositionMeanStatisticAnalysisUpdateInfo = true;

                                            while (true)
                                            {
                                                if (!m_smVisionInfo.g_bPocketPositionMeanStatisticAnalysisUpdateInfo)
                                                    break;

                                                Thread.Sleep(1);
                                            }
                                        }
                                    }
                                }
                                break;
                            case 2:
                                m_bSubTh_MarkTest_Result = true;
                                m_bSubTh_MarkTest_Result2 = false;

                                if (m_smVisionInfo.g_arrMarks != null && m_smVisionInfo.g_arrMarks.Count > 1)
                                {
                                    blnWantMark = m_smVisionInfo.g_arrMarks[1].ref_blnCheckMark;
                                }

                                if (blnWantMark)
                                {
                                    if (m_smProductionInfo.g_blnWantNonRotateInspection)
                                    {
                                        if (!StartOrientTest_using4LGauge_OcvAngleAndPackageAngle_WithoutRotate(m_blnAuto, 1))   // Use orient gauge to measure unit location and size from image 1 only. No package here.
                                            blnResultOK2 = false;
                                    }
                                    else
                                    {
                                        if (!StartOrientTest_using4LGauge_OcvAngleAndPackageAngle(m_blnAuto, 1))   // Use orient gauge to measure unit location and size from image 1 only. No package here.
                                            blnResultOK2 = false;
                                    }
                                }
                                m_blnOrientDataUpdated2 = true;
                                m_blnOrientGaugeUpdated2 = true;
                                // ------------------- Pin 1 Test --------------------------------------------------------
                                if (m_smVisionInfo.g_blnWantPin1)
                                {
                                    // 2020-11-07 ZJYEOH : Pin 1 should wait wait package gauge done if want check package
                                    if (!blnWantMark)
                                    {
                                        if (m_blnWantPackageTest && ((m_smVisionInfo.g_arrPackage[1].ref_intFailMask & 0x1000) > 0 || m_smVisionInfo.g_arrPackage[1].GetWantInspectPackage()))
                                        {
                                            if (m_smVisionInfo.g_arrPackage[1].GetGrabImageIndex(2) == 0 || m_smVisionInfo.g_arrPackage[1].GetGrabImageIndex(3) == 0)
                                                WaitEventDone(ref m_bPackageSizePreTestDone2, true, 10000, "AAA63");
                                        }
                                    }

                                    if (m_smVisionInfo.g_arrPin1[1].getWantCheckPin1(m_smVisionInfo.g_intSelectedTemplate)) // 12-07-2019 ZJYEOH : if inspection option there got tick, then just check pin 1
                                    {
                                        if (blnResultOK2 && !StartPin1Test(m_blnAuto, 1))
                                            blnResultOK2 = false;
                                    }
                                }

                                // ------------------ Mark Test ----------------------------------------------------------
                                if (blnWantMark)
                                {
                                    if (((m_smCustomizeInfo.g_intWantMark & (1 << m_smVisionInfo.g_intVisionPos)) > 0) && ((m_smCustomizeInfo.g_intWantOCR & (1 << m_smVisionInfo.g_intVisionPos)) == 0))
                                    {
                                        // 2020 04 15 - JBTAN: will continue to check mark even option uncheck check mark option
                                        // Checking Mark
                                        //if (blnWantMark && blnResultOK2)
                                        if (blnResultOK2)
                                        {
                                            if (m_smProductionInfo.g_blnWantNonRotateInspection)
                                            {
                                                if (!StartMarkTest_using4LGauge_OcvAngleAndPackageAngle_WithoutRotate(m_blnAuto, 1))       // Mark OCV Test
                                                {
                                                    // 2020 04 15 - JBTAN: check mark option enable only will set result fail
                                                    if (blnWantMark)
                                                        blnResultOK2 = false;
                                                }
                                            }
                                            else
                                            {
                                                if (!StartMarkTest_using4LGauge_OcvAngleAndPackageAngle(m_blnAuto, 1))       // Mark OCV Test
                                                {
                                                    // 2020 04 15 - JBTAN: check mark option enable only will set result fail
                                                    if (blnWantMark)
                                                        blnResultOK2 = false;
                                                }
                                            }
                                        }
                                    }
                                    else if ((m_smCustomizeInfo.g_intWantOCR & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
                                    {
                                        // 2020 04 15 - JBTAN: will continue to check mark even option uncheck check mark option
                                        // Checking Mark OCR
                                        //if (blnWantMark && blnResultOK2)
                                        if (blnResultOK2)
                                        {
                                            if (!StartMarkOCRTest(m_blnAuto, 1))   // Mark OCR Test
                                            {
                                                // 2020 04 15 - JBTAN: check mark option enable only will set result fail
                                                if (blnWantMark)
                                                    blnResultOK2 = false;
                                            }
                                        }
                                    }
                                }
                                m_bMarkTestDone2 = true;

                                m_bSubTh_MarkTest_Result = blnResultOK;
                                m_bSubTh_MarkTest_Result2 = blnResultOK2;

                                break;
                            case 3:
                                m_bSubTh_MarkTest_Result = false;
                                m_bSubTh_MarkTest_Result2 = false;

                                if (m_smVisionInfo.g_arrMarks != null && m_smVisionInfo.g_arrMarks.Count > 1)
                                {
                                    blnWantMark = m_smVisionInfo.g_arrMarks[1].ref_blnCheckMark;
                                }

                                if (blnWantMark)
                                {
                                    if (m_smProductionInfo.g_blnWantNonRotateInspection)
                                    {
                                        if (!StartOrientTest_using4LGauge_OcvAngleAndPackageAngle_WithoutRotate(m_blnAuto, 1))   // Use orient gauge to measure unit location and size from image 1 only. No package here.
                                            blnResultOK2 = false;
                                    }
                                    else
                                    {
                                        if (!StartOrientTest_using4LGauge_OcvAngleAndPackageAngle(m_blnAuto, 1))   // Use orient gauge to measure unit location and size from image 1 only. No package here.
                                            blnResultOK2 = false;
                                    }
                                }
                                m_blnOrientDataUpdated2 = true;
                                m_blnOrientGaugeUpdated2 = true;
                                // ------------------- Pin 1 Test --------------------------------------------------------
                                if (m_smVisionInfo.g_blnWantPin1)
                                {
                                    // 2020-11-07 ZJYEOH : Pin 1 should wait wait package gauge done if want check package
                                    if (!blnWantMark)
                                    {
                                        if (m_blnWantPackageTest && ((m_smVisionInfo.g_arrPackage[1].ref_intFailMask & 0x1000) > 0 || m_smVisionInfo.g_arrPackage[1].GetWantInspectPackage()))
                                        {
                                            if (m_smVisionInfo.g_arrPackage[1].GetGrabImageIndex(2) == 0 || m_smVisionInfo.g_arrPackage[1].GetGrabImageIndex(3) == 0)
                                                WaitEventDone(ref m_bPackageSizePreTestDone2, true, 10000, "AAA64");
                                        }
                                    }

                                    if (m_smVisionInfo.g_arrPin1[1].getWantCheckPin1(m_smVisionInfo.g_intSelectedTemplate)) // 12-07-2019 ZJYEOH : if inspection option there got tick, then just check pin 1
                                    {
                                        if (blnResultOK2 && !StartPin1Test(m_blnAuto, 1))
                                            blnResultOK2 = false;
                                    }
                                }

                                // ------------------ Mark Test ----------------------------------------------------------
                                if (blnWantMark)
                                {
                                    if (((m_smCustomizeInfo.g_intWantMark & (1 << m_smVisionInfo.g_intVisionPos)) > 0) && ((m_smCustomizeInfo.g_intWantOCR & (1 << m_smVisionInfo.g_intVisionPos)) == 0))
                                    {
                                        // 2020 04 15 - JBTAN: will continue to check mark even option uncheck check mark option
                                        // Checking Mark
                                        //if (blnWantMark && blnResultOK2)
                                        if (blnResultOK2)
                                        {
                                            if (m_smProductionInfo.g_blnWantNonRotateInspection)
                                            {
                                                if (!StartMarkTest_using4LGauge_OcvAngleAndPackageAngle_WithoutRotate(m_blnAuto, 1))       // Mark OCV Test
                                                {
                                                    // 2020 04 15 - JBTAN: check mark option enable only will set result fail
                                                    if (blnWantMark)
                                                        blnResultOK2 = false;
                                                }
                                            }
                                            else
                                            {
                                                if (!StartMarkTest_using4LGauge_OcvAngleAndPackageAngle(m_blnAuto, 1))       // Mark OCV Test
                                                {
                                                    // 2020 04 15 - JBTAN: check mark option enable only will set result fail
                                                    if (blnWantMark)
                                                        blnResultOK2 = false;
                                                }
                                            }
                                        }
                                    }
                                    else if ((m_smCustomizeInfo.g_intWantOCR & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
                                    {
                                        // 2020 04 15 - JBTAN: will continue to check mark even option uncheck check mark option
                                        // Checking Mark OCR
                                        //if (blnWantMark && blnResultOK2)
                                        if (blnResultOK2)
                                        {
                                            if (!StartMarkOCRTest(m_blnAuto, 1))   // Mark OCR Test
                                            {
                                                // 2020 04 15 - JBTAN: check mark option enable only will set result fail
                                                if (blnWantMark)
                                                    blnResultOK2 = false;
                                            }
                                        }
                                    }
                                }
                                m_bMarkTestDone2 = true;

                                m_bSubTh_MarkTest_Result2 = blnResultOK2;
                                if (m_smVisionInfo.g_intUnitsOnImage == 2 && !blnResultOK2)
                                {
                                    if (m_smVisionInfo.g_strErrorMessage.Length > 0)
                                    {
                                        m_smVisionInfo.g_strErrorMessageForSecondUnit = m_smVisionInfo.g_strErrorMessage;
                                        m_smVisionInfo.g_strErrorMessage = "";
                                    }
                                }

                                if (m_smVisionInfo.g_arrMarks != null && m_smVisionInfo.g_arrMarks.Count > 0)
                                {
                                    blnWantMark = m_smVisionInfo.g_arrMarks[0].ref_blnCheckMark;
                                }

                                if (blnWantMark)
                                {
                                    if (m_smProductionInfo.g_blnWantNonRotateInspection)
                                    {
                                        if (!StartOrientTest_using4LGauge_OcvAngleAndPackageAngle_WithoutRotate(m_blnAuto, 0))   // Use orient gauge to measure unit location and size from image 1 only. No package here.
                                            blnResultOK = false;
                                    }
                                    else
                                    {
                                        if (!StartOrientTest_using4LGauge_OcvAngleAndPackageAngle(m_blnAuto, 0))   // Use orient gauge to measure unit location and size from image 1 only. No package here.
                                            blnResultOK = false;
                                    }
                                }
                                m_blnOrientDataUpdated1 = true;
                                m_blnOrientGaugeUpdated1 = true;
                                // ------------------- Pin 1 Test --------------------------------------------------------
                                if (m_smVisionInfo.g_blnWantPin1)
                                {
                                    // 2020-11-07 ZJYEOH : Pin 1 should wait wait package gauge done if want check package
                                    if (!blnWantMark)
                                    {
                                        if (m_blnWantPackageTest && ((m_smVisionInfo.g_arrPackage[0].ref_intFailMask & 0x1000) > 0 || m_smVisionInfo.g_arrPackage[0].GetWantInspectPackage()))
                                        {
                                            if (m_smVisionInfo.g_arrPackage[0].GetGrabImageIndex(2) == 0 || m_smVisionInfo.g_arrPackage[0].GetGrabImageIndex(3) == 0)
                                                WaitEventDone(ref m_bPackageSizePreTestDone1, true, 10000, "AAA65");
                                        }
                                    }

                                    if (m_smVisionInfo.g_arrPin1[0].getWantCheckPin1(m_smVisionInfo.g_intSelectedTemplate)) // 12-07-2019 ZJYEOH : if inspection option there got tick, then just check pin 1
                                    {
                                        if (blnResultOK && !StartPin1Test(m_blnAuto, 0))
                                            blnResultOK = false;
                                    }
                                }

                                // ------------------ Mark Test ----------------------------------------------------------
                                if (blnWantMark)
                                {
                                    if (((m_smCustomizeInfo.g_intWantMark & (1 << m_smVisionInfo.g_intVisionPos)) > 0) && ((m_smCustomizeInfo.g_intWantOCR & (1 << m_smVisionInfo.g_intVisionPos)) == 0))
                                    {
                                        // 2020 04 15 - JBTAN: will continue to check mark even option uncheck check mark option
                                        // Checking Mark
                                        //if (blnWantMark && blnResultOK)
                                        if (blnResultOK)
                                        {
                                            if (m_smProductionInfo.g_blnWantNonRotateInspection)
                                            {
                                                if (!StartMarkTest_using4LGauge_OcvAngleAndPackageAngle_WithoutRotate(m_blnAuto, 0))       // Mark OCV Test
                                                {
                                                    // 2020 04 15 - JBTAN: check mark option enable only will set result fail
                                                    if (blnWantMark)
                                                        blnResultOK = false;
                                                }
                                            }
                                            else
                                            {
                                                if (!StartMarkTest_using4LGauge_OcvAngleAndPackageAngle(m_blnAuto, 0))       // Mark OCV Test
                                                {
                                                    // 2020 04 15 - JBTAN: check mark option enable only will set result fail
                                                    if (blnWantMark)
                                                        blnResultOK = false;
                                                }
                                            }
                                        }
                                    }
                                    else if ((m_smCustomizeInfo.g_intWantOCR & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
                                    {
                                        // 2020 04 15 - JBTAN: will continue to check mark even option uncheck check mark option
                                        // Checking Mark OCR
                                        //if (blnWantMark && blnResultOK)
                                        if (blnResultOK)
                                        {
                                            if (!StartMarkOCRTest(m_blnAuto, 0))   // Mark OCR Test
                                            {
                                                // 2020 04 15 - JBTAN: check mark option enable only will set result fail
                                                if (blnWantMark)
                                                    blnResultOK = false;
                                            }
                                        }
                                    }
                                }
                                m_bMarkTestDone1 = true;

                                m_bSubTh_MarkTest_Result = blnResultOK;
                                //if (m_smVisionInfo.g_intUnitsOnImage == 2 && !blnResultOK)
                                //{
                                //    if (m_smVisionInfo.g_strErrorMessage.Length > 0)
                                //    {
                                //        m_smVisionInfo.g_strErrorMessage = GetUnitName(0) + m_smVisionInfo.g_strErrorMessage;
                                //    }
                                //}

                                break;
                        }

                        //m_bSubTh_MarkTest_Result = blnResultOK;
                        //m_bSubTh_MarkTest_Result2 = blnResultOK2;

                        m_bSubTh_MarkTest = false;

                        //m_fTiming = m_T1.Timing;
                        //m_strTrack += ", After m_bSubTh_MarkTest=" + (m_fTiming - m_fTimingPrev).ToString();
                        //m_fTimingPrev = m_fTiming;
                    }
                }
                catch (Exception ex)
                {
                    m_bSubTh_MarkTest = false;

                    SRMMessageBox.Show("Vision4Process->UpdateSubProgress_MarkTest() :" + ex.ToString());
                }
                Thread.Sleep(1);
            }

            m_thSubThread_MarkTest = null;
            m_blnStopped_MarkTest = true;
        }

        private void UpdateSubProgress_PackageTest_MarkLightView()
        {
            while (!m_blnStopping)
            {

                try
                {
                    if (m_bSubTh_PackageTest_MarkLightView)
                    {
                        //m_T1.Start();

                        //m_fTimingPrev = 0;
                        //m_fTiming = 0;
                        //m_strTrack += ",///////////////////Inside UpdateSubProgress_PackageTest_MarkLightView////////////////////////";

                        //m_bSubTh_PackageTest_MarkLightView_Result = false;

                        bool blnResultOK = true;
                        bool blnResultOK2 = true;

                        switch (m_intScenario)
                        {
                            case 1:
                                WaitEventDone(ref m_blnOrientGaugeUpdated1, ref m_blnOrientDataUpdated1, true, true, "AAA66");
                                m_bSubTh_PackageTest_MarkLightView_Result = false;
                                m_bSubTh_PackageTest_MarkLightView_Result2 = true;
                                // ------------ Package Size Test ------------------------------------------------
                                if (!StartPackageSizeTest(m_blnAuto, 0, ref m_fObjectWidth, ref m_fObjectHeight))
                                {
                                    blnResultOK = false;
                                    m_eInspectionResult_PackageTest_Size = ResulType.FailPackageSize;
                                    m_bSubTh_PackageTest_PackageSize_Result = false;
                                    m_bPackageSizeTestDone1 = true;


                                }
                                else
                                {
                                    if (blnResultOK)
                                    {
                                        m_eInspectionResult_PackageTest_Size = ResulType.Pass;
                                        m_bSubTh_PackageTest_PackageSize_Result = true;
                                        m_bPackageSizeTestDone1 = true;
                                    }

                                    //// -------- Check Mark Text Shifted ----------------------------
                                    //// 2019 07 21 - When no gauge during mark test, it is not possible to check Mark Texted Shifted.
                                    ////            - So need to rely on Package Size result to check Mark Text Shifted.
                                    //if (!m_smVisionInfo.g_blnWantGauge)
                                    //{
                                    //    // 2020 04 25 - CCENG: Need to make sure mark test done before call WantCheckMarkTextShifted(). Bcos WantCheckMarkTextShifted() relay on final m_intTemplateIndex value from mark test.
                                    //    WaitEventDone(ref m_bSubTh_MarkTest, false); // wait mark test done first.

                                    //    bool blnWantCheckMarkTextShifted = false;
                                    //    if (m_smVisionInfo.g_arrMarks != null && m_smVisionInfo.g_arrMarks.Count > 0)
                                    //    {
                                    //        blnWantCheckMarkTextShifted = m_smVisionInfo.g_arrMarks[0].ref_blnCheckMark && m_smVisionInfo.g_arrMarks[0].WantCheckMarkTextShifted();
                                    //    }

                                    //    if (blnWantCheckMarkTextShifted)
                                    //    {
                                    //        WaitEventDone(ref m_bSubTh_MarkTest, false); // wait mark test done first.

                                    //        if (m_bSubTh_MarkTest_Result) // Only need to check text shifted if mark result pass.
                                    //        {
                                    //            if (!m_smVisionInfo.g_arrMarks[0].CheckTextShifted2(
                                    //                (int)Math.Round(m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_fPackageResultCenterX - m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_fPackageResultWidth_px / 2, 0, MidpointRounding.AwayFromZero),
                                    //                (int)Math.Round(m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_fPackageResultCenterY - m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_fPackageResultHeight_px / 2, 0, MidpointRounding.AwayFromZero),
                                    //                (int)Math.Round(m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_fPackageResultCenterX + m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_fPackageResultWidth_px / 2, 0, MidpointRounding.AwayFromZero),
                                    //                (int)Math.Round(m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_fPackageResultCenterY + m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_fPackageResultHeight_px / 2, 0, MidpointRounding.AwayFromZero)))
                                    //            {
                                    //                m_smVisionInfo.g_strErrorMessage += "*Mark Shifted";
                                    //                if (m_blnAuto)
                                    //                {
                                    //                    SaveRejectImage_AddToBuffer("TextShifted", "*Mark Shifted");
                                    //                }
                                    //                if (m_blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                                    //                {
                                    //                    m_smVisionInfo.g_intPkgDefectFailureTotal++;
                                    //                    m_blnFailCounterAdded = true;
                                    //                    m_blnTotalCounterAdded = false;
                                    //                    //SaveRejectImage_AddToBuffer("TextShifted", "*Mark Shifted");
                                    //                }
                                    //                m_eInspectionResult_PackageTest_Size = ResulType.FailPackageSize;
                                    //                m_bSubTh_PackageTest_PackageSize_Result = false;
                                    //                m_bPackageSizeTestDone = true;
                                    //                blnResultOK = false;
                                    //            }
                                    //        }
                                    //    }
                                    //}
                                    //// --------------- End Check Mark Text Shifted ---------------------------------------------

                                    ////RecordGRR2();
                                    //if (blnResultOK)
                                    //{
                                    //    m_eInspectionResult_PackageTest_Size = ResulType.Pass;
                                    //    m_bSubTh_PackageTest_PackageSize_Result = true;
                                    //    m_bPackageSizeTestDone = true;
                                    //}
                                }

                                // 2020-04-28 ZJYEOH : Record Package Size Result
                                if (m_blnAuto && m_smVisionInfo.g_blnWantRecordResult && ((m_smVisionInfo.g_arrPackage[0].ref_intFailMask & 0x1000) > 0) && (m_smVisionInfo.g_intTestedTotal <= m_smVisionInfo.g_intResultLogMaxCount))
                                {
                                    string strLotSaveResultLogPath;
                                    string strVisionResultLogFileName;
                                    string strPath;
                                    if (m_smVisionInfo.g_intVisionResetCount == 0)
                                    {
                                        strLotSaveResultLogPath = m_smProductionInfo.g_strHistoryDataLocation + "ResultLog\\" + m_smProductionInfo.g_strLotID + "_" + m_smProductionInfo.g_strLotStartTime;
                                        strVisionResultLogFileName = m_smVisionInfo.g_strVisionFolderName + "(" + m_smVisionInfo.g_strVisionDisplayName + " " + m_smVisionInfo.g_strVisionNameRemark + ")" + "_" + m_smProductionInfo.g_strLotStartTime;

                                        if (!Directory.Exists(strLotSaveResultLogPath))
                                            Directory.CreateDirectory(strLotSaveResultLogPath);

                                        strPath = strLotSaveResultLogPath + "\\" + strVisionResultLogFileName + ".txt";
                                    }
                                    else
                                    {
                                        strLotSaveResultLogPath = m_smProductionInfo.g_strHistoryDataLocation + "ResultLog\\" + m_smProductionInfo.g_strLotID + "_" + m_smProductionInfo.g_strLotStartTime;
                                        strVisionResultLogFileName = m_smVisionInfo.g_strVisionFolderName + "(" + m_smVisionInfo.g_strVisionDisplayName + " " + m_smVisionInfo.g_strVisionNameRemark + ")" + "_" + m_smVisionInfo.g_strVisionResetCountTime;

                                        if (!Directory.Exists(strLotSaveResultLogPath))
                                            Directory.CreateDirectory(strLotSaveResultLogPath);

                                        strPath = strLotSaveResultLogPath + "\\" + strVisionResultLogFileName + ".txt";
                                    }

                                    STTrackLog.WriteLine_ForResultLog(strLotSaveResultLogPath, strVisionResultLogFileName,// "Number=" + (lines.Count + 1).ToString() + "," +
                                                  "Date Time=" + DateTime.Now.ToString() + "," +
                                                  "Package Unit 1 Width=" + m_smVisionInfo.g_arrPackage[0].ref_fUnitResultWidth.ToString() + "," +
                                                  "Package Unit 1 Height=" + m_smVisionInfo.g_arrPackage[0].ref_fUnitResultHeight.ToString());
                                }

                                //// Check Unit Sit Proper
                                //if (m_bSubTh_PackageTest_PackageSize_Result == false)
                                //{
                                //    if (m_smVisionInfo.g_blnWantCheckUnitSitProper)
                                //    {
                                //        if (!m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].CheckUnitSitProper(m_fObjectWidth, m_fObjectHeight))
                                //        {
                                //            m_smVisionInfo.g_strErrorMessage += m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_strErrorMessage;
                                //            m_objVisionIO.FailOffset.SetOn("V4 FailOffset 12");

                                //            //STTrackLog.WriteLine("Fail 37 g_intOrientFailureTotal=" + m_smVisionInfo.g_intOrientFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                                //            if (m_blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)
                                //            {
                                //                //m_smVisionInfo.g_intOrientFailureTotal++;
                                //                m_blnFailCounterAdded = true;
                                //                m_blnTotalCounterAdded = false;
                                //                //STTrackLog.WriteLine("Fail 37a g_intOrientFailureTotal=" + m_smVisionInfo.g_intOrientFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                                //            }
                                //        }
                                //    }


                                //}

                                // ------------- Package Defect Test on Mark Light View -------------------------
                                WaitEventDone(ref m_bGrabImage1Done, true, 10000, "AAA67");
                                WaitEventDone(ref m_bMarkTestDone1, true, 10000, "AAA68"); //m_bSubTh_MarkTest,false

                                if (m_bPackageSizeTestDone1 && m_bSubTh_PackageTest_PackageSize_Result && m_bSubTh_MarkTest_Result)
                                {
                                    if (m_smProductionInfo.g_blnWantNonRotateInspection)
                                    {
                                        if (!StartPackageTest_MarkLightView_WithoutRotate(m_blnAuto, 0))
                                            blnResultOK = false;
                                    }
                                    else
                                    {
                                        if (!StartPackageTest_MarkLightView(m_blnAuto, 0))
                                            blnResultOK = false;
                                    }

                                }
                                break;
                            case 2:
                                WaitEventDone(ref m_blnOrientGaugeUpdated2, ref m_blnOrientDataUpdated2, true, true, "AAA69");
                                m_bSubTh_PackageTest_MarkLightView_Result = true;
                                m_bSubTh_PackageTest_MarkLightView_Result2 = false;
                                // ------------ Package Size Test ------------------------------------------------
                                if (!StartPackageSizeTest(m_blnAuto, 1, ref m_fObjectWidth, ref m_fObjectHeight))
                                {
                                    blnResultOK2 = false;
                                    m_eInspectionResult_PackageTest_Size = ResulType.FailPackageSize;
                                    m_bSubTh_PackageTest_PackageSize_Result2 = false;
                                    m_bPackageSizeTestDone2 = true;
                                }
                                else
                                {
                                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - B10 ");
                                    //// -------- Check Mark Text Shifted ----------------------------
                                    //// 2019 07 21 - When no gauge during mark test, it is not possible to check Mark Texted Shifted.
                                    ////            - So need to rely on Package Size result to check Mark Text Shifted.
                                    //if (!m_smVisionInfo.g_blnWantGauge)
                                    //{
                                    //    bool blnWantCheckMarkTextShifted = false;
                                    //    if (m_smVisionInfo.g_arrMarks != null && m_smVisionInfo.g_arrMarks.Count > 1)
                                    //    {
                                    //        blnWantCheckMarkTextShifted = m_smVisionInfo.g_arrMarks[1].ref_blnCheckMark && m_smVisionInfo.g_arrMarks[1].WantCheckMarkTextShifted();
                                    //    }

                                    //    if (blnWantCheckMarkTextShifted)
                                    //    {
                                    //        WaitEventDone(ref m_bMarkTestDone2, true); //m_bSubTh_MarkTest,false // wait mark test done first.

                                    //        if (m_bSubTh_MarkTest_Result) // Only need to check text shifted if mark result pass.
                                    //        {
                                    //            if (!m_smVisionInfo.g_arrMarks[1].CheckTextShifted2(
                                    //                (int)Math.Round(m_smVisionInfo.g_arrPackage[1].ref_fPackageResultCenterX - m_smVisionInfo.g_arrPackage[1].ref_fPackageResultWidth_px / 2, 0, MidpointRounding.AwayFromZero),
                                    //                (int)Math.Round(m_smVisionInfo.g_arrPackage[1].ref_fPackageResultCenterY - m_smVisionInfo.g_arrPackage[1].ref_fPackageResultHeight_px / 2, 0, MidpointRounding.AwayFromZero),
                                    //                (int)Math.Round(m_smVisionInfo.g_arrPackage[1].ref_fPackageResultCenterX + m_smVisionInfo.g_arrPackage[1].ref_fPackageResultWidth_px / 2, 0, MidpointRounding.AwayFromZero),
                                    //                (int)Math.Round(m_smVisionInfo.g_arrPackage[1].ref_fPackageResultCenterY + m_smVisionInfo.g_arrPackage[1].ref_fPackageResultHeight_px / 2, 0, MidpointRounding.AwayFromZero)))
                                    //            {
                                    //                m_smVisionInfo.g_strErrorMessage += "*Mark Shifted";
                                    //                if (m_blnAuto)
                                    //                {
                                    //                    SaveRejectImage_AddToBuffer("TextShifted", "*Mark Shifted");
                                    //                }
                                    //                if (m_blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                                    //                {
                                                       
                                    //                    m_smVisionInfo.g_intPkgDefectFailureTotal++;
                                    //                    m_blnFailCounterAdded = true;
                                    //                    m_blnTotalCounterAdded = false;
                                    //                    //SaveRejectImage_AddToBuffer("TextShifted", "*Mark Shifted");
                                    //                }
                                    //                m_eInspectionResult_PackageTest_Size = ResulType.FailPackageSize;
                                    //                m_bSubTh_PackageTest_PackageSize_Result2 = false;
                                    //                m_bPackageSizeTestDone2 = true;
                                    //                blnResultOK2 = false;
                                    //            }
                                    //        }
                                    //    }
                                    //}
                                    // --------------- End Check Mark Text Shifted ---------------------------------------------

                                    //RecordGRR2();
                                    if (blnResultOK2)
                                    {
                                        m_eInspectionResult_PackageTest_Size = ResulType.Pass;
                                        m_bSubTh_PackageTest_PackageSize_Result2 = true;
                                        m_bPackageSizeTestDone2 = true;
                                    }
                                }

                                // 2020-04-28 ZJYEOH : Record Package Size Result
                                if (m_blnAuto && m_smVisionInfo.g_blnWantRecordResult && ((m_smVisionInfo.g_arrPackage[1].ref_intFailMask & 0x1000) > 0) && (m_smVisionInfo.g_intTestedTotal <= m_smVisionInfo.g_intResultLogMaxCount))
                                {
                                    string strLotSaveResultLogPath;
                                    string strVisionResultLogFileName;
                                    string strPath;
                                    if (m_smVisionInfo.g_intVisionResetCount == 0)
                                    {
                                        strLotSaveResultLogPath = m_smProductionInfo.g_strHistoryDataLocation + "ResultLog\\" + m_smProductionInfo.g_strLotID + "_" + m_smProductionInfo.g_strLotStartTime;
                                        strVisionResultLogFileName = m_smVisionInfo.g_strVisionFolderName + "(" + m_smVisionInfo.g_strVisionDisplayName + " " + m_smVisionInfo.g_strVisionNameRemark + ")" + "_" + m_smProductionInfo.g_strLotStartTime;

                                        if (!Directory.Exists(strLotSaveResultLogPath))
                                            Directory.CreateDirectory(strLotSaveResultLogPath);

                                        strPath = strLotSaveResultLogPath + "\\" + strVisionResultLogFileName + ".txt";
                                    }
                                    else
                                    {
                                        strLotSaveResultLogPath = m_smProductionInfo.g_strHistoryDataLocation + "ResultLog\\" + m_smProductionInfo.g_strLotID + "_" + m_smProductionInfo.g_strLotStartTime;
                                        strVisionResultLogFileName = m_smVisionInfo.g_strVisionFolderName + "(" + m_smVisionInfo.g_strVisionDisplayName + " " + m_smVisionInfo.g_strVisionNameRemark + ")" + "_" + m_smVisionInfo.g_strVisionResetCountTime;

                                        if (!Directory.Exists(strLotSaveResultLogPath))
                                            Directory.CreateDirectory(strLotSaveResultLogPath);

                                        strPath = strLotSaveResultLogPath + "\\" + strVisionResultLogFileName + ".txt";
                                    }

                                    STTrackLog.WriteLine_ForResultLog(strLotSaveResultLogPath, strVisionResultLogFileName,// "Number=" + (lines.Count + 1).ToString() + "," +
                                                  "Date Time=" + DateTime.Now.ToString() + "," +
                                                  "Package Unit 2 Width=" + m_smVisionInfo.g_arrPackage[1].ref_fUnitResultWidth.ToString() + "," +
                                                  "Package Unit 2 Height=" + m_smVisionInfo.g_arrPackage[1].ref_fUnitResultHeight.ToString());
                                }

                                //// Check Unit Sit Proper
                                //if (m_bSubTh_PackageTest_PackageSize_Result == false)
                                //{
                                //    if (m_smVisionInfo.g_blnWantCheckUnitSitProper)
                                //    {
                                //        if (!m_smVisionInfo.g_arrPackage[1].CheckUnitSitProper(m_fObjectWidth, m_fObjectHeight))
                                //        {
                                //            m_smVisionInfo.g_strErrorMessage += m_smVisionInfo.g_arrPackage[1].ref_strErrorMessage;
                                //            m_objVisionIO.FailOffset.SetOn("V4 FailOffset 13");
                                //        }
                                //    }
                                //}

                                // ------------- Package Defect Test on Mark Light View -------------------------
                                WaitEventDone(ref m_bGrabImage1Done, true, 10000, "AAA70");
                                WaitEventDone(ref m_bMarkTestDone2, true, 10000, "AAA61");//m_bSubTh_MarkTest,false

                                if (m_bPackageSizeTestDone2 && m_bSubTh_PackageTest_PackageSize_Result2 && m_bSubTh_MarkTest_Result)
                                {
                                    if (m_smProductionInfo.g_blnWantNonRotateInspection)
                                    {
                                        if (!StartPackageTest_MarkLightView_WithoutRotate(m_blnAuto, 1))
                                            blnResultOK2 = false;
                                    }
                                    else
                                    {
                                        if (!StartPackageTest_MarkLightView(m_blnAuto, 1))
                                            blnResultOK2 = false;
                                    }

                                }
                                break;
                            case 3:
                                WaitEventDone(ref m_blnOrientGaugeUpdated2, ref m_blnOrientDataUpdated2, true, true, "AAA72");
                                m_bSubTh_PackageTest_MarkLightView_Result = false;
                                m_bSubTh_PackageTest_MarkLightView_Result2 = false;
                                // ------------ Package Size Test ------------------------------------------------
                                if (!StartPackageSizeTest(m_blnAuto, 1, ref m_fObjectWidth, ref m_fObjectHeight))
                                {
                                    blnResultOK2 = false;
                                    m_eInspectionResult_PackageTest_Size = ResulType.FailPackageSize;
                                    m_bSubTh_PackageTest_PackageSize_Result2 = false;
                                    m_bPackageSizeTestDone2 = true;
                                }
                                else
                                {
                                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - C10 ");
                                    //// -------- Check Mark Text Shifted ----------------------------
                                    //// 2019 07 21 - When no gauge during mark test, it is not possible to check Mark Texted Shifted.
                                    ////            - So need to rely on Package Size result to check Mark Text Shifted.
                                    //if (!m_smVisionInfo.g_blnWantGauge)
                                    //{
                                    //    bool blnWantCheckMarkTextShifted = false;
                                    //    if (m_smVisionInfo.g_arrMarks != null && m_smVisionInfo.g_arrMarks.Count > 1)
                                    //    {
                                    //        blnWantCheckMarkTextShifted = m_smVisionInfo.g_arrMarks[1].ref_blnCheckMark && m_smVisionInfo.g_arrMarks[1].WantCheckMarkTextShifted();
                                    //    }

                                    //    if (blnWantCheckMarkTextShifted)
                                    //    {
                                    //        WaitEventDone(ref m_bMarkTestDone2, true); //m_bSubTh_MarkTest,false // wait mark test done first.

                                    //        if (m_bSubTh_MarkTest_Result) // Only need to check text shifted if mark result pass.
                                    //        {
                                    //            if (!m_smVisionInfo.g_arrMarks[1].CheckTextShifted2(
                                    //                (int)Math.Round(m_smVisionInfo.g_arrPackage[1].ref_fPackageResultCenterX - m_smVisionInfo.g_arrPackage[1].ref_fPackageResultWidth_px / 2, 0, MidpointRounding.AwayFromZero),
                                    //                (int)Math.Round(m_smVisionInfo.g_arrPackage[1].ref_fPackageResultCenterY - m_smVisionInfo.g_arrPackage[1].ref_fPackageResultHeight_px / 2, 0, MidpointRounding.AwayFromZero),
                                    //                (int)Math.Round(m_smVisionInfo.g_arrPackage[1].ref_fPackageResultCenterX + m_smVisionInfo.g_arrPackage[1].ref_fPackageResultWidth_px / 2, 0, MidpointRounding.AwayFromZero),
                                    //                (int)Math.Round(m_smVisionInfo.g_arrPackage[1].ref_fPackageResultCenterY + m_smVisionInfo.g_arrPackage[1].ref_fPackageResultHeight_px / 2, 0, MidpointRounding.AwayFromZero)))
                                    //            {
                                    //                m_smVisionInfo.g_strErrorMessage += "*Mark Shifted";
                                    //                if (m_blnAuto)
                                    //                {
                                    //                    SaveRejectImage_AddToBuffer("TextShifted", "*Mark Shifted");
                                    //                }
                                    //                if (m_blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                                    //                {
                                    //                    m_smVisionInfo.g_intPkgDefectFailureTotal++;
                                    //                    m_blnFailCounterAdded = true;
                                    //                    m_blnTotalCounterAdded = false;
                                    //                    //SaveRejectImage_AddToBuffer("TextShifted", "*Mark Shifted");
                                    //                }
                                    //                m_eInspectionResult_PackageTest_Size = ResulType.FailPackageSize;
                                    //                m_bSubTh_PackageTest_PackageSize_Result2 = false;
                                    //                m_bPackageSizeTestDone2 = true;
                                    //                blnResultOK2 = false;
                                    //            }
                                    //        }
                                    //    }
                                    //}
                                    // --------------- End Check Mark Text Shifted ---------------------------------------------

                                    //RecordGRR2();
                                    if (blnResultOK2)
                                    {
                                        m_eInspectionResult_PackageTest_Size = ResulType.Pass;
                                        m_bSubTh_PackageTest_PackageSize_Result2 = true;
                                        m_bPackageSizeTestDone2 = true;
                                    }
                                }

                                // 2020-04-28 ZJYEOH : Record Package Size Result
                                if (m_blnAuto && m_smVisionInfo.g_blnWantRecordResult && ((m_smVisionInfo.g_arrPackage[1].ref_intFailMask & 0x1000) > 0) && (m_smVisionInfo.g_intTestedTotal <= m_smVisionInfo.g_intResultLogMaxCount))
                                {
                                    string strLotSaveResultLogPath;
                                    string strVisionResultLogFileName;
                                    string strPath;
                                    if (m_smVisionInfo.g_intVisionResetCount == 0)
                                    {
                                        strLotSaveResultLogPath = m_smProductionInfo.g_strHistoryDataLocation + "ResultLog\\" + m_smProductionInfo.g_strLotID + "_" + m_smProductionInfo.g_strLotStartTime;
                                        strVisionResultLogFileName = m_smVisionInfo.g_strVisionFolderName + "(" + m_smVisionInfo.g_strVisionDisplayName + " " + m_smVisionInfo.g_strVisionNameRemark + ")" + "_" + m_smProductionInfo.g_strLotStartTime;

                                        if (!Directory.Exists(strLotSaveResultLogPath))
                                            Directory.CreateDirectory(strLotSaveResultLogPath);

                                        strPath = strLotSaveResultLogPath + "\\" + strVisionResultLogFileName + ".txt";
                                    }
                                    else
                                    {
                                        strLotSaveResultLogPath = m_smProductionInfo.g_strHistoryDataLocation + "ResultLog\\" + m_smProductionInfo.g_strLotID + "_" + m_smProductionInfo.g_strLotStartTime;
                                        strVisionResultLogFileName = m_smVisionInfo.g_strVisionFolderName + "(" + m_smVisionInfo.g_strVisionDisplayName + " " + m_smVisionInfo.g_strVisionNameRemark + ")" + "_" + m_smVisionInfo.g_strVisionResetCountTime;

                                        if (!Directory.Exists(strLotSaveResultLogPath))
                                            Directory.CreateDirectory(strLotSaveResultLogPath);

                                        strPath = strLotSaveResultLogPath + "\\" + strVisionResultLogFileName + ".txt";
                                    }

                                    STTrackLog.Write_ForResultLog(strLotSaveResultLogPath, strVisionResultLogFileName,// "Number=" + (lines.Count + 1).ToString() + "," +
                                                  "Date Time=" + DateTime.Now.ToString() + "," +
                                                  "Package Unit 2 Width=" + m_smVisionInfo.g_arrPackage[1].ref_fUnitResultWidth.ToString() + "," +
                                                  "Package Unit 2 Height=" + m_smVisionInfo.g_arrPackage[1].ref_fUnitResultHeight.ToString() + ",");
                                }

                                //// Check Unit Sit Proper
                                //if (m_bSubTh_PackageTest_PackageSize_Result == false)
                                //{
                                //    if (m_smVisionInfo.g_blnWantCheckUnitSitProper)
                                //    {
                                //        if (!m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].CheckUnitSitProper(m_fObjectWidth, m_fObjectHeight))
                                //        {
                                //            m_smVisionInfo.g_strErrorMessage += m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_strErrorMessage;
                                //            m_objVisionIO.FailOffset.SetOn("V4 FailOffset 14");
                                //        }
                                //    }
                                //}

                                // ------------- Package Defect Test on Mark Light View -------------------------
                                WaitEventDone(ref m_bGrabImage1Done, true, 10000, "AAA73");
                                WaitEventDone(ref m_bMarkTestDone2, true, 10000, "AAA74");//m_bSubTh_MarkTest,false

                                if (m_bPackageSizeTestDone2 && m_bSubTh_PackageTest_PackageSize_Result2 && m_bSubTh_MarkTest_Result)
                                {
                                    if (m_smProductionInfo.g_blnWantNonRotateInspection)
                                    {
                                        if (!StartPackageTest_MarkLightView_WithoutRotate(m_blnAuto, 1))
                                            blnResultOK2 = false;
                                    }
                                    else
                                    {
                                        if (!StartPackageTest_MarkLightView(m_blnAuto, 1))
                                            blnResultOK2 = false;
                                    }
                                }

                                WaitEventDone(ref m_blnOrientGaugeUpdated1, ref m_blnOrientDataUpdated1, true, true, "AAA75");
                                // ------------ Package Size Test ------------------------------------------------
                                if (!StartPackageSizeTest(m_blnAuto, 0, ref m_fObjectWidth, ref m_fObjectHeight))
                                {
                                    blnResultOK = false;
                                    m_eInspectionResult_PackageTest_Size = ResulType.FailPackageSize;
                                    m_bSubTh_PackageTest_PackageSize_Result = false;
                                    m_bPackageSizeTestDone1 = true;
                                }
                                else
                                {
                                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("ST4 - D10 ");
                                    //// -------- Check Mark Text Shifted ----------------------------
                                    //// 2019 07 21 - When no gauge during mark test, it is not possible to check Mark Texted Shifted.
                                    ////            - So need to rely on Package Size result to check Mark Text Shifted.
                                    //if (!m_smVisionInfo.g_blnWantGauge)
                                    //{
                                    //    bool blnWantCheckMarkTextShifted = false;
                                    //    if (m_smVisionInfo.g_arrMarks != null && m_smVisionInfo.g_arrMarks.Count > 0)
                                    //    {
                                    //        blnWantCheckMarkTextShifted = m_smVisionInfo.g_arrMarks[0].ref_blnCheckMark && m_smVisionInfo.g_arrMarks[0].WantCheckMarkTextShifted();
                                    //    }

                                    //    if (blnWantCheckMarkTextShifted)
                                    //    {
                                    //        WaitEventDone(ref m_bMarkTestDone1, true);//m_bSubTh_MarkTest,false // wait mark test done first.

                                    //        if (m_bSubTh_MarkTest_Result) // Only need to check text shifted if mark result pass.
                                    //        {
                                    //            if (!m_smVisionInfo.g_arrMarks[0].CheckTextShifted2(
                                    //                (int)Math.Round(m_smVisionInfo.g_arrPackage[0].ref_fPackageResultCenterX - m_smVisionInfo.g_arrPackage[0].ref_fPackageResultWidth_px / 2, 0, MidpointRounding.AwayFromZero),
                                    //                (int)Math.Round(m_smVisionInfo.g_arrPackage[0].ref_fPackageResultCenterY - m_smVisionInfo.g_arrPackage[0].ref_fPackageResultHeight_px / 2, 0, MidpointRounding.AwayFromZero),
                                    //                (int)Math.Round(m_smVisionInfo.g_arrPackage[0].ref_fPackageResultCenterX + m_smVisionInfo.g_arrPackage[0].ref_fPackageResultWidth_px / 2, 0, MidpointRounding.AwayFromZero),
                                    //                (int)Math.Round(m_smVisionInfo.g_arrPackage[0].ref_fPackageResultCenterY + m_smVisionInfo.g_arrPackage[0].ref_fPackageResultHeight_px / 2, 0, MidpointRounding.AwayFromZero)))
                                    //            {
                                    //                m_smVisionInfo.g_strErrorMessage += "*Mark Shifted";
                                    //                if (m_blnAuto)
                                    //                {
                                    //                    SaveRejectImage_AddToBuffer("TextShifted", "*Mark Shifted");
                                    //                }
                                    //                if (m_blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                                    //                {
                                    //                    m_smVisionInfo.g_intPkgDefectFailureTotal++;
                                    //                    m_blnFailCounterAdded = true;
                                    //                    m_blnTotalCounterAdded = false;
                                    //                    //SaveRejectImage_AddToBuffer("TextShifted", "*Mark Shifted");
                                    //                }
                                    //                m_eInspectionResult_PackageTest_Size = ResulType.FailPackageSize;
                                    //                m_bSubTh_PackageTest_PackageSize_Result = false;
                                    //                m_bPackageSizeTestDone1 = true;
                                    //                blnResultOK = false;
                                    //            }
                                    //        }
                                    //    }
                                    //}
                                    // --------------- End Check Mark Text Shifted ---------------------------------------------

                                    //RecordGRR2();
                                    if (blnResultOK)
                                    {
                                        m_eInspectionResult_PackageTest_Size = ResulType.Pass;
                                        m_bSubTh_PackageTest_PackageSize_Result = true;
                                        m_bPackageSizeTestDone1 = true;
                                    }
                                }

                                // 2020-04-28 ZJYEOH : Record Package Size Result
                                if (m_blnAuto && m_smVisionInfo.g_blnWantRecordResult && ((m_smVisionInfo.g_arrPackage[0].ref_intFailMask & 0x1000) > 0) && (m_smVisionInfo.g_intTestedTotal <= m_smVisionInfo.g_intResultLogMaxCount))
                                {
                                    string strLotSaveResultLogPath;
                                    string strVisionResultLogFileName;
                                    string strPath;
                                    if (m_smVisionInfo.g_intVisionResetCount == 0)
                                    {
                                        strLotSaveResultLogPath = m_smProductionInfo.g_strHistoryDataLocation + "ResultLog\\" + m_smProductionInfo.g_strLotID + "_" + m_smProductionInfo.g_strLotStartTime;
                                        strVisionResultLogFileName = m_smVisionInfo.g_strVisionFolderName + "(" + m_smVisionInfo.g_strVisionDisplayName + " " + m_smVisionInfo.g_strVisionNameRemark + ")" + "_" + m_smProductionInfo.g_strLotStartTime;

                                        if (!Directory.Exists(strLotSaveResultLogPath))
                                            Directory.CreateDirectory(strLotSaveResultLogPath);

                                        strPath = strLotSaveResultLogPath + "\\" + strVisionResultLogFileName + ".txt";
                                    }
                                    else
                                    {
                                        strLotSaveResultLogPath = m_smProductionInfo.g_strHistoryDataLocation + "ResultLog\\" + m_smProductionInfo.g_strLotID + "_" + m_smProductionInfo.g_strLotStartTime;
                                        strVisionResultLogFileName = m_smVisionInfo.g_strVisionFolderName + "(" + m_smVisionInfo.g_strVisionDisplayName + " " + m_smVisionInfo.g_strVisionNameRemark + ")" + "_" + m_smVisionInfo.g_strVisionResetCountTime;

                                        if (!Directory.Exists(strLotSaveResultLogPath))
                                            Directory.CreateDirectory(strLotSaveResultLogPath);

                                        strPath = strLotSaveResultLogPath + "\\" + strVisionResultLogFileName + ".txt";
                                    }

                                    STTrackLog.WriteLine_ForResultLog(strLotSaveResultLogPath, strVisionResultLogFileName,// "Number=" + (lines.Count + 1).ToString() + "," +
                                                  "Date Time=" + DateTime.Now.ToString() + "," +
                                                  "Package Unit 1 Width=" + m_smVisionInfo.g_arrPackage[0].ref_fUnitResultWidth.ToString() + "," +
                                                  "Package Unit 1 Height=" + m_smVisionInfo.g_arrPackage[0].ref_fUnitResultHeight.ToString());
                                }
                                
                                //// Check Unit Sit Proper
                                //if (m_bSubTh_PackageTest_PackageSize_Result == false)
                                //{
                                //    if (m_smVisionInfo.g_blnWantCheckUnitSitProper)
                                //    {
                                //        if (!m_smVisionInfo.g_arrPackage[1].CheckUnitSitProper(m_fObjectWidth, m_fObjectHeight))
                                //        {
                                //            m_smVisionInfo.g_strErrorMessage += m_smVisionInfo.g_arrPackage[1].ref_strErrorMessage;
                                //            m_objVisionIO.FailOffset.SetOn("V4 FailOffset 15");
                                //        }
                                //    }
                                //}
                                // ------------- Package Defect Test on Mark Light View -------------------------
                                WaitEventDone(ref m_bGrabImage1Done, true, 10000, "AAA76");
                                WaitEventDone(ref m_bMarkTestDone1, true, 10000, "AAA77");//m_bSubTh_MarkTest,false

                                if (m_bPackageSizeTestDone1 && m_bSubTh_PackageTest_PackageSize_Result && m_bSubTh_MarkTest_Result)
                                {
                                    if (m_smProductionInfo.g_blnWantNonRotateInspection)
                                    {
                                        if (!StartPackageTest_MarkLightView_WithoutRotate(m_blnAuto, 0))
                                            blnResultOK = false;
                                    }
                                    else
                                    {
                                        if (!StartPackageTest_MarkLightView(m_blnAuto, 0))
                                            blnResultOK = false;
                                    }
                                }
                                break;
                        }
                        m_bSubTh_PackageTest_MarkLightView_Result = blnResultOK;
                        m_bSubTh_PackageTest_MarkLightView_Result2 = blnResultOK2;
                        // -----------------------------------------------------------------------------

                        m_bSubTh_PackageTest_MarkLightView = false;

                        //m_fTiming = m_T1.Timing;
                        //m_strTrack += ", After m_bSubTh_PackageTest_MarkLightView=" + (m_fTiming - m_fTimingPrev).ToString();
                        //m_fTimingPrev = m_fTiming;
                    }
                }
                catch (Exception ex)
                {
                    m_bSubTh_PackageTest_MarkLightView = false;

                    STTrackLog.WriteLine("Vision4Process->UpdateSubProgress_PackageTest_MarkLightView() :" + ex.ToString());
                    STTrackLog.WriteLine(m_strTracking_StartPackageSizeTest);

                    SRMMessageBox.Show("Vision4Process->UpdateSubProgress_PackageTest_MarkLightView() :" + ex.ToString());
                }
                Thread.Sleep(1);
            }

            m_thSubThread_PackageTest_MarkLightView = null;
            m_blnStopped_PackageTest_MarkLightView = true;
        }

        private void UpdateSubProgress_PackageTest_SideLightView()
        {
            while (!m_blnStopping)
            {

                try
                {
                    if (m_bSubTh_PackageTest_SideLightView)
                    {
                        //m_T1.Start();

                        //m_fTimingPrev = 0;
                        //m_fTiming = 0;
                        //m_strTrack += ",///////////////////Inside UpdateSubProgress_PackageTest_SideLightView////////////////////////";

                        //m_bSubTh_PackageTest_SideLightView_Result = false;

                        bool blnResultOK = true;
                        bool blnResultOK2 = true;
                        switch (m_intScenario)
                        {
                            case 1:
                                m_bSubTh_PackageTest_SideLightView_Result = false;
                                m_bSubTh_PackageTest_SideLightView_Result2 = true;
                                WaitEventDone(ref m_bPackageSizeTestDone1, true, 10000, "AAA78");


                                // ------------- Package Defect Test on Side Light View -------------------------
                                if (m_bSubTh_PackageTest_PackageSize_Result)
                                {
                                    if (m_smProductionInfo.g_blnWantNonRotateInspection)
                                    {
                                        if (!StartPackageTest_SideLightView_WithoutRotate(m_blnAuto, 0))
                                            blnResultOK = false;
                                    }
                                    else
                                    {
                                        if (!StartPackageTest_SideLightView(m_blnAuto, 0))
                                            blnResultOK = false;
                                    }
                                }
                                break;

                            case 2:
                                m_bSubTh_PackageTest_SideLightView_Result = true;
                                m_bSubTh_PackageTest_SideLightView_Result2 = false;
                                WaitEventDone(ref m_bPackageSizeTestDone2, true, 10000, "AAA79");

                                // ------------- Package Defect Test on Side Light View -------------------------
                                if (m_bSubTh_PackageTest_PackageSize_Result2)
                                {
                                    if (m_smProductionInfo.g_blnWantNonRotateInspection)
                                    {
                                        if (!StartPackageTest_SideLightView_WithoutRotate(m_blnAuto, 1))
                                            blnResultOK2 = false;
                                    }
                                    else
                                    {
                                        if (!StartPackageTest_SideLightView(m_blnAuto, 1))
                                            blnResultOK2 = false;
                                    }
                                }
                                break;

                            case 3:
                                m_bSubTh_PackageTest_SideLightView_Result = false;
                                m_bSubTh_PackageTest_SideLightView_Result2 = false;
                                WaitEventDone(ref m_bPackageSizeTestDone2, true, 10000, "AAA80");

                                // ------------- Package Defect Test on Side Light View -------------------------
                                if (m_bSubTh_PackageTest_PackageSize_Result2)
                                {
                                    if (m_smProductionInfo.g_blnWantNonRotateInspection)
                                    {
                                        if (!StartPackageTest_SideLightView_WithoutRotate(m_blnAuto, 1))
                                            blnResultOK2 = false;
                                    }
                                    else
                                    {
                                        if (!StartPackageTest_SideLightView(m_blnAuto, 1))
                                            blnResultOK2 = false;
                                    }
                                }


                                WaitEventDone(ref m_bPackageSizeTestDone1, true, 10000, "AAA81");

                                // ------------- Package Defect Test on Side Light View -------------------------
                                if (m_bSubTh_PackageTest_PackageSize_Result)
                                {
                                    if (m_smProductionInfo.g_blnWantNonRotateInspection)
                                    {
                                        if (!StartPackageTest_SideLightView_WithoutRotate(m_blnAuto, 0))
                                            blnResultOK = false;
                                    }
                                    else
                                    {
                                        if (!StartPackageTest_SideLightView(m_blnAuto, 0))
                                            blnResultOK = false;
                                    }
                                }
                                break;
                        }
                        m_bSubTh_PackageTest_SideLightView_Result = blnResultOK;
                        m_bSubTh_PackageTest_SideLightView_Result2 = blnResultOK2;
                        // -----------------------------------------------------------------------------

                        m_bSubTh_PackageTest_SideLightView = false;

                        //m_fTiming = m_T1.Timing;
                        //m_strTrack += ", After m_bSubTh_PackageTest_SideLightView=" + (m_fTiming - m_fTimingPrev).ToString();
                        //m_fTimingPrev = m_fTiming;
                    }
                }
                catch (Exception ex)
                {
                    m_bSubTh_PackageTest_SideLightView = false;

                    SRMMessageBox.Show("Vision4Process->UpdateSubProgress_PackageTest_SideLightView() :" + ex.ToString());
                }
                Thread.Sleep(1);
            }

            m_thSubThread_PackageTest_SideLightView = null;
            m_blnStopped_PackageTest_SideLightView = true;
        }

        private void UpdateSubProgress_PackageTest_TopLightView()
        {
            while (!m_blnStopping)
            {

                try
                {
                    if (m_bSubTh_PackageTest_TopLightView)
                    {
                        //m_T1.Start();

                        //m_fTimingPrev = 0;
                        //m_fTiming = 0;
                        //m_strTrack += ",///////////////////Inside UpdateSubProgress_PackageTest_TopLightView////////////////////////";

                        //m_bSubTh_PackageTest_TopLightView_Result = false;

                        bool blnResultOK = true;
                        bool blnResultOK2 = true;
                        switch (m_intScenario)
                        {
                            case 1:
                                m_bSubTh_PackageTest_TopLightView_Result = false;
                                m_bSubTh_PackageTest_TopLightView_Result2 = true;
                                WaitEventDone(ref m_bPackageSizeTestDone1, true, 10000, "AAA82");

                                // ------------- Package Defect Test on Top Light View -------------------------
                                if (m_bSubTh_PackageTest_PackageSize_Result)
                                {
                                    if (m_smProductionInfo.g_blnWantNonRotateInspection)
                                    {
                                        if (!StartPackageTest_TopLightView_WithoutRotate(m_blnAuto, 0))
                                            blnResultOK = false;
                                    }
                                    else
                                    {
                                        if (!StartPackageTest_TopLightView(m_blnAuto, 0))
                                            blnResultOK = false;
                                    }
                                }
                                break;

                            case 2:
                                m_bSubTh_PackageTest_TopLightView_Result = true;
                                m_bSubTh_PackageTest_TopLightView_Result2 = false;
                                WaitEventDone(ref m_bPackageSizeTestDone2, true, 10000, "AAA83");

                                // ------------- Package Defect Test on Top Light View -------------------------
                                if (m_bSubTh_PackageTest_PackageSize_Result2)
                                {
                                    if (m_smProductionInfo.g_blnWantNonRotateInspection)
                                    {
                                        if (!StartPackageTest_TopLightView_WithoutRotate(m_blnAuto, 1))
                                            blnResultOK2 = false;
                                    }
                                    else
                                    {
                                        if (!StartPackageTest_TopLightView(m_blnAuto, 1))
                                            blnResultOK2 = false;
                                    }
                                }
                                break;

                            case 3:
                                m_bSubTh_PackageTest_TopLightView_Result = false;
                                m_bSubTh_PackageTest_TopLightView_Result2 = false;
                                WaitEventDone(ref m_bPackageSizeTestDone2, true, 10000, "AAA84");

                                // ------------- Package Defect Test on Top Light View -------------------------
                                if (m_bSubTh_PackageTest_PackageSize_Result2)
                                {
                                    if (m_smProductionInfo.g_blnWantNonRotateInspection)
                                    {
                                        if (!StartPackageTest_TopLightView_WithoutRotate(m_blnAuto, 1))
                                            blnResultOK2 = false;
                                    }
                                    else
                                    {
                                        if (!StartPackageTest_TopLightView(m_blnAuto, 1))
                                            blnResultOK2 = false;
                                    }
                                }

                                WaitEventDone(ref m_bPackageSizeTestDone1, true, 10000, "AAA85");

                                // ------------- Package Defect Test on Top Light View -------------------------
                                if (m_bSubTh_PackageTest_PackageSize_Result)
                                {
                                    if (m_smProductionInfo.g_blnWantNonRotateInspection)
                                    {
                                        if (!StartPackageTest_TopLightView_WithoutRotate(m_blnAuto, 0))
                                            blnResultOK = false;
                                    }
                                    else
                                    {
                                        if (!StartPackageTest_TopLightView(m_blnAuto, 0))
                                            blnResultOK = false;
                                    }
                                }
                                break;

                        }
                        m_bSubTh_PackageTest_TopLightView_Result = blnResultOK;
                        m_bSubTh_PackageTest_TopLightView_Result2 = blnResultOK2;

                        m_bSubTh_PackageTest_TopLightView = false;

                        //m_fTiming = m_T1.Timing;
                        //m_strTrack += ", After m_bSubTh_PackageTest_TopLightView=" + (m_fTiming - m_fTimingPrev).ToString();
                        //m_fTimingPrev = m_fTiming;
                    }
                }
                catch (Exception ex)
                {
                    m_bSubTh_PackageTest_TopLightView = false;

                    SRMMessageBox.Show("Vision4Process->UpdateSubProgress_PackageTest_TopLightView() :" + ex.ToString());
                }
                Thread.Sleep(1);
            }

            m_thSubThread_PackageTest_TopLightView = null;
            m_blnStopped_PackageTest_TopLightView = true;
        }
        private void AttachToROI(List<List<ROI>> arrROI, List<ImageDrawing> arrImage, int intLeadImageIndex)
        {
            ROI objROI;

            for (int i = 0; i < arrROI.Count; i++)
            {
                for (int j = 0; j < arrROI[i].Count; j++)
                {
                    objROI = (ROI)arrROI[i][j];

                    switch (objROI.ref_intType)
                    {
                        case 1:
                            if (arrImage.Count > 3)
                                objROI.AttachImage(arrImage[3]); //attach ROI to image 4 if image 4 is available
                            else if (arrImage.Count > 1)
                                objROI.AttachImage(arrImage[intLeadImageIndex]); //attach ROI to image intLeadImageIndex if image 4 is not available
                            else
                                objROI.AttachImage(arrImage[0]);
                            break;
                    }
                    arrROI[i][j] = objROI;
                }
            }

            objROI = null;
        }
        private void UpdateSubProgress_LeadTest()
        {
            while (!m_blnStopping)
            {

                try
                {
                    if (m_bSubTh_LeadTest)
                    {
                        m_bSubTh_LeadTest_Result = false;

                        //WaitEventDone(ref m_bGrabImage1Done, true);
                        bool blnResultOK = true;

                        // STTrackLog.WriteLine("start wait grab image result");
                        if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 0)
                            blnResultOK = WaitEventDone(ref m_bGrabImage1Done, true, ref m_bGrabImage1Result, "AAA86 1");
                        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 1)
                            blnResultOK = WaitEventDone(ref m_bGrabImage2Done, true, ref m_bGrabImage2Result, "AAA86 2");
                        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 2)
                            blnResultOK = WaitEventDone(ref m_bGrabImage3Done, true, ref m_bGrabImage3Result, "AAA86 3");
                        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 3)
                            blnResultOK = WaitEventDone(ref m_bGrabImage4Done, true, ref m_bGrabImage4Result, "AAA86 4");
                        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 4)
                            blnResultOK = WaitEventDone(ref m_bGrabImage5Done, true, ref m_bGrabImage5Result, "AAA86 5");
                        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 5)
                            blnResultOK = WaitEventDone(ref m_bGrabImage6Done, true, ref m_bGrabImage6Result, "AAA86 6");
                        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 6)
                            blnResultOK = WaitEventDone(ref m_bGrabImage7Done, true, ref m_bGrabImage7Result, "AAA86 7");

                        if (m_smVisionInfo.g_arrLead[0].ref_blnWantInspectBaseLead && (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo != m_smVisionInfo.g_arrLead[0].ref_intImageViewNo))
                        {
                            // Wait base lead image (default is image 3) grap done
                            if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 0)
                                blnResultOK = WaitEventDone(ref m_bGrabImage1Done, true, ref m_bGrabImage1Result, "AAA87 1");
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 1)
                                blnResultOK = WaitEventDone(ref m_bGrabImage2Done, true, ref m_bGrabImage2Result, "AAA87 2");
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 2)
                                blnResultOK = WaitEventDone(ref m_bGrabImage3Done, true, ref m_bGrabImage3Result, "AAA87 3");
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 3)
                                blnResultOK = WaitEventDone(ref m_bGrabImage4Done, true, ref m_bGrabImage4Result, "AAA87 4");
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 4)
                                blnResultOK = WaitEventDone(ref m_bGrabImage5Done, true, ref m_bGrabImage5Result, "AAA87 5");
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 5)
                                blnResultOK = WaitEventDone(ref m_bGrabImage6Done, true, ref m_bGrabImage6Result, "AAA87 6");
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 6)
                                blnResultOK = WaitEventDone(ref m_bGrabImage7Done, true, ref m_bGrabImage7Result, "AAA87 7");
                        }

                        //STTrackLog.WriteLine("Get image result = " + blnResultOK.ToString());

                        //AttachImageToROI();
                        if ((m_smCustomizeInfo.g_intWantLead & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
                        {
                            if (m_smVisionInfo.g_objLeadImage == null)
                                m_smVisionInfo.g_objLeadImage = new ImageDrawing(true);

                            m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo].CopyTo(ref m_smVisionInfo.g_objLeadImage);
                            m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo].CopyTo(ref m_smVisionInfo.g_arrRotatedImages, m_smVisionInfo.g_arrLead[0].ref_intImageViewNo);
                            if (m_smVisionInfo.g_arrLead[0].ref_blnWantInspectBaseLead)
                                m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo].CopyTo(ref m_smVisionInfo.g_arrRotatedImages, m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo);
                            AttachToROI(m_smVisionInfo.g_arrLeadROIs, m_smVisionInfo.g_objLeadImage);
                            //AttachToROI(m_smVisionInfo.g_arrLeadROIs, m_smVisionInfo.g_arrImages, m_smVisionInfo.g_arrLead[0].ref_intImageViewNo);
                        }

                        bool blnWantLead = false;
                        if (m_smVisionInfo.g_arrLead != null && m_smVisionInfo.g_arrLead.Length > 0)
                        {
                            blnWantLead = m_smVisionInfo.g_arrLead[0].GetWantInspectLead();// m_smVisionInfo.g_blnCheckLead;
                        }

                        // ------------------ Lead Test ----------------------------------------------------------
                        if (blnWantLead)
                        {
                            if ((m_smCustomizeInfo.g_intWantLead & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
                            {
                                // Checking Lead
                                if (blnWantLead && blnResultOK)
                                {
                                    //if (m_smProductionInfo.g_blnWantNonRotateInspection)
                                    //{
                                    //    if (!StartLeadTest_MultiThreading_WithoutRotate(m_blnAuto))
                                    //        blnResultOK = false;
                                    //}
                                    //else
                                    {
                                        if (!StartLeadTest_MultiThreading(m_blnAuto))
                                        {
                                            blnResultOK = false;
                                        }
                                    }
                                }
                            }

                        }

                        m_bLeadBaseCenterPointDone = true;

                        m_bSubTh_LeadTest_Result = blnResultOK;

                        m_bSubTh_LeadTest = false;
                    }
                }
                catch (Exception ex)
                {
                    m_bSubTh_LeadTest = false;

                    SRMMessageBox.Show("Vision4Process->UpdateSubProgress_LeadTest() :" + ex.ToString());
                }
                Thread.Sleep(1);
            }

            m_thSubThread_LeadTest = null;
            m_blnStopped_LeadTest = true;
        }
        private void UpdateSubProgress_PackageColorTest()
        {
            while (!m_blnStopping)
            {

                try
                {
                    if (m_bSubTh_PackageColorTest)
                    {
                        m_bSubTh_PackageColorTest_Result = false;

                        //WaitEventDone(ref m_bGrabImage1Done, true);
                        bool blnResultOK = true;

                        if (m_smVisionInfo.g_blnCheckPackageColor)
                        {
                            // STTrackLog.WriteLine("start wait grab image result");
                            if (ContainColorSelectedImage(0, m_smVisionInfo.g_intSelectedUnit))
                                blnResultOK = WaitEventDone(ref m_bGrabImage1Done, true, ref m_bGrabImage1Result, "UpdateSubProgress_PackageColorTest > m_bGrabImage1Done f");
                            if (ContainColorSelectedImage(1, m_smVisionInfo.g_intSelectedUnit))
                                blnResultOK = WaitEventDone(ref m_bGrabImage2Done, true, ref m_bGrabImage2Result, "UpdateSubProgress_PackageColorTest > m_bGrabImage2Done f");
                            if (ContainColorSelectedImage(2, m_smVisionInfo.g_intSelectedUnit))
                                blnResultOK = WaitEventDone(ref m_bGrabImage3Done, true, ref m_bGrabImage3Result, "UpdateSubProgress_PackageColorTest > m_bGrabImage3Done f");
                            if (ContainColorSelectedImage(3, m_smVisionInfo.g_intSelectedUnit))
                                blnResultOK = WaitEventDone(ref m_bGrabImage4Done, true, ref m_bGrabImage4Result, "UpdateSubProgress_PackageColorTest > m_bGrabImage4Done f");
                            if (ContainColorSelectedImage(4, m_smVisionInfo.g_intSelectedUnit))
                                blnResultOK = WaitEventDone(ref m_bGrabImage5Done, true, ref m_bGrabImage5Result, "UpdateSubProgress_PackageColorTest > m_bGrabImage5Done f");
                            if (ContainColorSelectedImage(5, m_smVisionInfo.g_intSelectedUnit))
                                blnResultOK = WaitEventDone(ref m_bGrabImage6Done, true, ref m_bGrabImage6Result, "UpdateSubProgress_PackageColorTest > m_bGrabImage6Done f");
                            if (ContainColorSelectedImage(6, m_smVisionInfo.g_intSelectedUnit))
                                blnResultOK = WaitEventDone(ref m_bGrabImage7Done, true, ref m_bGrabImage7Result, "UpdateSubProgress_PackageColorTest > m_bGrabImage7Done f");

                            //STTrackLog.WriteLine("Get image result = " + blnResultOK.ToString());

                            ////AttachImageToROI();
                            //if ((m_smCustomizeInfo.g_intWantLead & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
                            //{
                            //    if (m_smVisionInfo.g_objLeadImage == null)
                            //        m_smVisionInfo.g_objLeadImage = new ImageDrawing(true);

                            //    m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo].CopyTo(ref m_smVisionInfo.g_objLeadImage);
                            //    m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo].CopyTo(ref m_smVisionInfo.g_arrRotatedImages, m_smVisionInfo.g_arrLead[0].ref_intImageViewNo);
                            //    AttachToROI(m_smVisionInfo.g_arrLeadROIs, m_smVisionInfo.g_objLeadImage);
                            //    //AttachToROI(m_smVisionInfo.g_arrLeadROIs, m_smVisionInfo.g_arrImages, m_smVisionInfo.g_arrLead[0].ref_intImageViewNo);
                            //}


                            // 2020-08-11 ZJYEOH : Only need Orient data to rotate when got package
                            WaitEventDone(ref m_blnOrientDataUpdated1, true, 10000, "UpdateSubProgress_PackageColorTest > m_blnOrientDataUpdated 9136");

                            // Get RotateROI where the ROI center point == Unit Center Point
                            CROI objRotatedROI = new CROI();

                            float fSizeX, fSizeY;
                            fSizeX = m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIWidth - m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIWidth % 2; // why %2? To get "even" number
                            fSizeY = m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIHeight - m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIHeight % 2;

                            if (m_blnWantPackageTest && ((m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailMask & 0x1000) > 0 || m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetWantInspectPackage() || GetWantInspectPackageColor(m_smVisionInfo.g_intSelectedUnit))) // 2020-06-23 ZJYEOH : If inspection option got tick Check package size just can use pkg gauge
                            {
                                WaitEventDone(ref m_bPackageSizePreTestDone1, true, 10000, "UpdateSubProgress_PackageColorTest > m_bPackageSizePreTestDone");

                                for (int i = 0; i < m_smVisionInfo.g_arrColorImages.Count; i++)
                                {
                                    if (ContainColorSelectedImage(i, m_smVisionInfo.g_intSelectedUnit))
                                    {
                                        if (m_smProductionInfo.g_blnWantNonRotateInspection)
                                        {
                                            if (m_bPackageSizePreTestResult1)
                                            {
                                                objRotatedROI.AttachImage(m_smVisionInfo.g_arrColorImages[i]);

                                                // Get RotateROI center point where the ROI center point == Package Unit Center Point
                                                objRotatedROI.LoadROISetting((int)Math.Round(m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X - fSizeX / 2, 0, MidpointRounding.AwayFromZero),
                                                                             (int)Math.Round(m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y - fSizeY / 2, 0, MidpointRounding.AwayFromZero),
                                                                             (int)Math.Round(fSizeX, 0, MidpointRounding.AwayFromZero),
                                                                             (int)Math.Round(fSizeY, 0, MidpointRounding.AwayFromZero));

                                                CROI.Rotate0Degree(m_smVisionInfo.g_arrColorImages[i], objRotatedROI, m_intOrientAngle + m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle, 4, ref m_arrColorImage_ForInspection, i);

                                                //m_smVisionInfo.g_arrColorRotatedImages[i].CopyTo(ref m_arrColorImage_ForInspection, i);

                                                SetColorImageRotated(i);

                                            }
                                            else
                                            {
                                                m_smVisionInfo.g_arrColorImages[i].CopyTo(ref m_smVisionInfo.g_arrColorRotatedImages, i);
                                            }
                                        }
                                        else
                                        {
                                            if (m_bPackageSizePreTestResult1)
                                            {
                                                objRotatedROI.AttachImage(m_smVisionInfo.g_arrColorImages[i]);

                                                // Get RotateROI center point where the ROI center point == Package Unit Center Point
                                                objRotatedROI.LoadROISetting((int)Math.Round(m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X - fSizeX / 2, 0, MidpointRounding.AwayFromZero),
                                                                             (int)Math.Round(m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y - fSizeY / 2, 0, MidpointRounding.AwayFromZero),
                                                                             (int)Math.Round(fSizeX, 0, MidpointRounding.AwayFromZero),
                                                                             (int)Math.Round(fSizeY, 0, MidpointRounding.AwayFromZero));

                                                CROI.Rotate0Degree(m_smVisionInfo.g_arrColorImages[i], objRotatedROI, m_intOrientAngle + m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle, 4, ref m_smVisionInfo.g_arrColorRotatedImages, i);

                                                m_smVisionInfo.g_arrColorRotatedImages[i].CopyTo(ref m_arrColorImage_ForInspection, i);

                                                SetColorImageRotated(i);

                                            }
                                            else
                                            {
                                                m_smVisionInfo.g_arrColorImages[i].CopyTo(ref m_smVisionInfo.g_arrColorRotatedImages, i);
                                            }
                                        }
                                    }
                                }
                            }

                            // ------------------ Package Color Test ----------------------------------------------------------

                            if (blnResultOK && m_bPackageSizePreTestResult1)
                            {
                                WaitEventDone(ref m_bPackageSizeTestDone1, true, 10000, "UpdateSubProgress_PackageColorTest > m_bPackageSizeTestDone 8992");

                                // ------------- Package Defect Test on Side Light View -------------------------
                                if (m_bSubTh_PackageTest_PackageSize_Result)
                                {
                                    if (!StartPackageColorTest_MultiThreading(m_blnAuto, 0))
                                    {
                                        blnResultOK = false;
                                    }
                                }
                            }

                            objRotatedROI.Dispose();
                        }

                        m_bSubTh_PackageColorTest_Result = blnResultOK;

                        m_bSubTh_PackageColorTest = false;
                    }
                }
                catch (Exception ex)
                {
                    m_bSubTh_PackageColorTest = false;

                    SRMMessageBox.Show("Vision1Process->UpdateSubProgress_PackageColorTest() :" + ex.ToString());
                }
                Thread.Sleep(1);
            }

            m_thSubThread_PackageColorTest = null;
            m_blnStopped_PackageColorTest = true;
        }
        private void SaveImageBuffer()
        {
            string strTrack = "";
            try
            {
                if (m_intPassStartNode != m_intPassEndNode)
                {
                    STTrackLog.WriteLine("P1 Start=" + m_intPassStartNode.ToString() + ", End=" + m_intPassEndNode.ToString());

                    //string strPath = m_smVisionInfo.g_strSaveImageLocation +
                    //            m_smProductionInfo.g_strLotID + "_" + m_smProductionInfo.g_strLotStartTime +
                    //            "\\" + m_smVisionInfo.g_strVisionFolderName +
                    //            "(" + m_smVisionInfo.g_strVisionDisplayName + " " + m_smVisionInfo.g_strVisionNameRemark + ")" +
                    //            "\\Pass\\";

                    // 2020 03 27 - JBTAN: Save to different folder if reset count
                    string strPath;
                    if (m_smVisionInfo.g_intVisionResetCount == 0)
                    {
                        strPath = m_smVisionInfo.g_strSaveImageLocation +
                                m_smProductionInfo.g_strLotID + "_" + m_smProductionInfo.g_strLotStartTime +
                                "\\" + m_smVisionInfo.g_strVisionFolderName +
                                "(" + m_smVisionInfo.g_strVisionDisplayName + " " + m_smVisionInfo.g_strVisionNameRemark + ")" + "_" + m_smProductionInfo.g_strLotStartTime +
                                "\\Pass\\";
                    }
                    else
                    {
                        string strLotSaveImagePath = m_smVisionInfo.g_strSaveImageLocation + m_smProductionInfo.g_strLotID + "_" + m_smProductionInfo.g_strLotStartTime;
                        string strVisionImageFolderName = m_smVisionInfo.g_strVisionFolderName + "(" + m_smVisionInfo.g_strVisionDisplayName + " " + m_smVisionInfo.g_strVisionNameRemark + ")" + "_" + m_smVisionInfo.g_strVisionResetCountTime;

                        if (!Directory.Exists(strLotSaveImagePath + "\\" + strVisionImageFolderName))
                            Directory.CreateDirectory(strLotSaveImagePath + "\\" + strVisionImageFolderName);
                        if (!Directory.Exists(strLotSaveImagePath + "\\" + strVisionImageFolderName + "\\Pass"))
                            Directory.CreateDirectory(strLotSaveImagePath + "\\" + strVisionImageFolderName + "\\Pass");

                        strPath = strLotSaveImagePath + "\\" + strVisionImageFolderName + "\\Pass\\";
                    }

                    string strDegree = "0";
                    switch (m_arrOrientationBuffer[m_intPassStartNode])
                    {
                        case 0:
                            strDegree = "0";
                            break;
                        case 1:
                            strDegree = "90";
                            break;
                        case 2:
                            strDegree = "180";
                            break;
                        case 3:
                            strDegree = "270";
                            break;
                    }

                    //string strFileName = (m_arrUnitNoBuffer[m_intPassStartNode] + 1) + "_" +
                    //                     m_arrPassNoBuffer[m_intPassStartNode] + "_Pass_" +
                    //                     strDegree + "Degree";
                    string strFileName = m_arrPassNoBuffer[m_intPassStartNode] + "_Pass_" +         // 2019 09 18 - CCENG: Swap m_arrPassNoBuffer with m_arrUnitNoBuffer because image need to be displayed according to total image count 
                                         (m_arrUnitNoBuffer[m_intPassStartNode] + 1) + "_" +
                                         strDegree + "Degree";

                    if (m_smVisionInfo.g_blnViewColorImage)
                    {
                        m_arrPassCImage1Buffer[m_intPassStartNode].SaveImage(strPath + strFileName + ".bmp");
                        //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                        m_arrPassCImage1Buffer[m_intPassStartNode].Dispose();
                        m_arrPassCImage1Buffer[m_intPassStartNode] = new CImageDrawing(true);
                    }
                    else
                    {
                        m_arrPassImage1Buffer[m_intPassStartNode].SaveImage(strPath + strFileName + ".bmp");
                        //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                        m_arrPassImage1Buffer[m_intPassStartNode].Dispose();
                        m_arrPassImage1Buffer[m_intPassStartNode] = new ImageDrawing(true);
                    }

                    if (m_smVisionInfo.g_arrImages.Count > 1)
                    {
                        if (m_smVisionInfo.g_blnViewColorImage)
                        {
                            m_arrPassCImage2Buffer[m_intPassStartNode].SaveImage(strPath + strFileName + "_Image1.bmp");
                            //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                            m_arrPassCImage2Buffer[m_intPassStartNode].Dispose();
                            m_arrPassCImage2Buffer[m_intPassStartNode] = new CImageDrawing(true);
                        }
                        else
                        {
                            m_arrPassImage2Buffer[m_intPassStartNode].SaveImage(strPath + strFileName + "_Image1.bmp");
                            //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                            m_arrPassImage2Buffer[m_intPassStartNode].Dispose();
                            m_arrPassImage2Buffer[m_intPassStartNode] = new ImageDrawing(true);
                        }
                    }

                    if (m_smVisionInfo.g_arrImages.Count > 2)
                    {
                        if (m_smVisionInfo.g_blnViewColorImage)
                        {
                            m_arrPassCImage3Buffer[m_intPassStartNode].SaveImage(strPath + strFileName + "_Image2.bmp");
                            //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                            m_arrPassCImage3Buffer[m_intPassStartNode].Dispose();
                            m_arrPassCImage3Buffer[m_intPassStartNode] = new CImageDrawing(true);
                        }
                        else
                        {
                            m_arrPassImage3Buffer[m_intPassStartNode].SaveImage(strPath + strFileName + "_Image2.bmp");
                            //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                            m_arrPassImage3Buffer[m_intPassStartNode].Dispose();
                            m_arrPassImage3Buffer[m_intPassStartNode] = new ImageDrawing(true);
                        }
                    }

                    if (m_smVisionInfo.g_arrImages.Count > 3)
                    {
                        if (m_smVisionInfo.g_blnViewColorImage)
                        {
                            m_arrPassCImage4Buffer[m_intPassStartNode].SaveImage(strPath + strFileName + "_Image3.bmp");
                            //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                            m_arrPassCImage4Buffer[m_intPassStartNode].Dispose();
                            m_arrPassCImage4Buffer[m_intPassStartNode] = new CImageDrawing(true);
                        }
                        else
                        {
                            m_arrPassImage4Buffer[m_intPassStartNode].SaveImage(strPath + strFileName + "_Image3.bmp");
                            //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                            m_arrPassImage4Buffer[m_intPassStartNode].Dispose();
                            m_arrPassImage4Buffer[m_intPassStartNode] = new ImageDrawing(true);
                        }
                    }

                    if (m_smVisionInfo.g_arrImages.Count > 4)
                    {
                        if (m_smVisionInfo.g_blnViewColorImage)
                        {
                            m_arrPassCImage5Buffer[m_intPassStartNode].SaveImage(strPath + strFileName + "_Image4.bmp");
                            //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                            m_arrPassCImage5Buffer[m_intPassStartNode].Dispose();
                            m_arrPassCImage5Buffer[m_intPassStartNode] = new CImageDrawing(true);
                        }
                        else
                        {
                            m_arrPassImage5Buffer[m_intPassStartNode].SaveImage(strPath + strFileName + "_Image4.bmp");
                            //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                            m_arrPassImage5Buffer[m_intPassStartNode].Dispose();
                            m_arrPassImage5Buffer[m_intPassStartNode] = new ImageDrawing(true);
                        }
                    }

                    if (m_smVisionInfo.g_arrImages.Count > 5)
                    {
                        if (m_smVisionInfo.g_blnViewColorImage)
                        {
                            m_arrPassCImage6Buffer[m_intPassStartNode].SaveImage(strPath + strFileName + "_Image5.bmp");
                            //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                            m_arrPassCImage6Buffer[m_intPassStartNode].Dispose();
                            m_arrPassCImage6Buffer[m_intPassStartNode] = new CImageDrawing(true);
                        }
                        else
                        {
                            m_arrPassImage6Buffer[m_intPassStartNode].SaveImage(strPath + strFileName + "_Image5.bmp");
                            //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                            m_arrPassImage6Buffer[m_intPassStartNode].Dispose();
                            m_arrPassImage6Buffer[m_intPassStartNode] = new ImageDrawing(true);
                        }
                    }

                    if (m_smVisionInfo.g_arrImages.Count > 6)
                    {
                        if (m_smVisionInfo.g_blnViewColorImage)
                        {
                            m_arrPassCImage7Buffer[m_intPassStartNode].SaveImage(strPath + strFileName + "_Image6.bmp");
                            //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                            m_arrPassCImage7Buffer[m_intPassStartNode].Dispose();
                            m_arrPassCImage7Buffer[m_intPassStartNode] = new CImageDrawing(true);
                        }
                        else
                        {
                            m_arrPassImage7Buffer[m_intPassStartNode].SaveImage(strPath + strFileName + "_Image6.bmp");
                            //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                            m_arrPassImage7Buffer[m_intPassStartNode].Dispose();
                            m_arrPassImage7Buffer[m_intPassStartNode] = new ImageDrawing(true);
                        }
                    }

                    m_smVisionInfo.g_strLastImageFolder = strPath;
                    m_smVisionInfo.g_strLastImageName = strFileName + ".bmp";

                    m_intPassStartNode++;
                    if (m_intPassStartNode == m_smVisionInfo.g_intSaveImageBufferSize)
                    {
                        m_intPassStartNode = 0;
                    }

                    STTrackLog.WriteLine("P2 Start=" + m_intPassStartNode.ToString() + ", End=" + m_intPassEndNode.ToString());
                }

                if (m_intFailStartNode != m_intFailEndNode)
                {
                    if (m_smProductionInfo.m_blnTrackON)
                        STTrackLog.WriteLine("F1 Start=" + m_intFailStartNode.ToString() + ", End=" + m_intFailEndNode.ToString());

                    strTrack += "1,";

                    //2021-02-24 ZJYEOH : Should use m_smVisionInfo.g_intFailImageCount to compare
                    if (/*m_arrFailNoBuffer[m_intFailStartNode]*/ m_smVisionInfo.g_intFailImageCount > m_smCustomizeInfo.g_intFailImagePics)//>=
                    {
                        strTrack += "2,";
                        if (!m_blnLoadRejectImageListPath)
                        {
                            strTrack += "3,";
                            LoadRejectImageListPath();
                            strTrack += "14,";
                            m_blnLoadRejectImageListPath = true;
                        }

                        strTrack += "5,";
                        if (m_arrRejectImageListPath.Count > 0)
                        {
                            strTrack += "6,";
                            string strDeleteFile = m_arrRejectImageListPath[0];

                            strTrack += "7,";
                            if (File.Exists(strDeleteFile))
                            {
                                try
                                {
                                    strTrack += "8,";
                                    File.Delete(strDeleteFile);
                                }
                                catch (Exception ex)
                                {
                                    STTrackLog.WriteLine("Vision4Process.cs > SaveImageBuffer Delete _image0 > Ex=" + ex.ToString());
                                }

                            }
                            else
                            {
                                if (m_smProductionInfo.m_blnTrackON)
                                {
                                    STTrackLog.WriteLine("File no exist = " + strDeleteFile);
                                }
                            }

                            strTrack += "9,";
                            if (m_smVisionInfo.g_arrImages.Count > 1)
                            {
                                strTrack += "10,";
                                int intStartIndex = strDeleteFile.LastIndexOf(".bmp");
                                strTrack += "11,";
                                if (intStartIndex > 0)
                                {
                                    string strDeleteFileImage1 = strDeleteFile.Substring(0, intStartIndex) + "_Image1.bmp";
                                    strTrack += "12,";
                                    if (File.Exists(strDeleteFileImage1))
                                    {
                                        try
                                        {
                                            strTrack += "13,";
                                            File.Delete(strDeleteFileImage1);
                                        }
                                        catch (Exception ex)
                                        {
                                            STTrackLog.WriteLine("Vision4Process.cs > SaveImageBuffer Delete _image1 > Ex=" + ex.ToString());
                                        }
                                    }
                                }
                            }

                            strTrack += "14,";

                            if (m_smVisionInfo.g_arrImages.Count > 2)
                            {
                                strTrack += "15,";
                                int intStartIndex = strDeleteFile.LastIndexOf(".bmp");
                                if (intStartIndex > 0)
                                {
                                    strTrack += "16,";
                                    string strDeleteFileImage2 = strDeleteFile.Substring(0, intStartIndex) + "_Image2.bmp";
                                    strTrack += "17,";
                                    if (File.Exists(strDeleteFileImage2))
                                    {
                                        try
                                        {
                                            strTrack += "18,";
                                            File.Delete(strDeleteFileImage2);
                                        }
                                        catch (Exception ex)
                                        {
                                            STTrackLog.WriteLine("Vision4Process.cs > SaveImageBuffer Delete _image2 > Ex=" + ex.ToString());
                                        }
                                    }
                                }
                            }

                            if (m_smVisionInfo.g_arrImages.Count > 3)
                            {
                                int intStartIndex = strDeleteFile.LastIndexOf(".bmp");
                                if (intStartIndex > 0)
                                {
                                    string strDeleteFileImage3 = strDeleteFile.Substring(0, intStartIndex) + "_Image3.bmp";
                                    if (File.Exists(strDeleteFileImage3))
                                    {
                                        try
                                        {
                                            File.Delete(strDeleteFileImage3);
                                        }
                                        catch (Exception ex)
                                        {
                                            STTrackLog.WriteLine("Vision4Process.cs > SaveImageBuffer Delete _image3 > Ex=" + ex.ToString());
                                        }
                                    }
                                }
                            }

                            if (m_smVisionInfo.g_arrImages.Count > 4)
                            {
                                int intStartIndex = strDeleteFile.LastIndexOf(".bmp");
                                if (intStartIndex > 0)
                                {
                                    string strDeleteFileImage4 = strDeleteFile.Substring(0, intStartIndex) + "_Image4.bmp";
                                    if (File.Exists(strDeleteFileImage4))
                                    {
                                        try
                                        {
                                            File.Delete(strDeleteFileImage4);
                                        }
                                        catch (Exception ex)
                                        {
                                            STTrackLog.WriteLine("Vision4Process.cs > SaveImageBuffer Delete _image4 > Ex=" + ex.ToString());
                                        }
                                    }
                                }
                            }

                            if (m_smVisionInfo.g_arrImages.Count > 5)
                            {
                                int intStartIndex = strDeleteFile.LastIndexOf(".bmp");
                                if (intStartIndex > 0)
                                {
                                    string strDeleteFileImage5 = strDeleteFile.Substring(0, intStartIndex) + "_Image5.bmp";
                                    if (File.Exists(strDeleteFileImage5))
                                    {
                                        try
                                        {
                                            File.Delete(strDeleteFileImage5);
                                        }
                                        catch (Exception ex)
                                        {
                                            STTrackLog.WriteLine("Vision4Process.cs > SaveImageBuffer Delete _image5 > Ex=" + ex.ToString());
                                        }
                                    }
                                }
                            }

                            if (m_smVisionInfo.g_arrImages.Count > 6)
                            {
                                int intStartIndex = strDeleteFile.LastIndexOf(".bmp");
                                if (intStartIndex > 0)
                                {
                                    string strDeleteFileImage6 = strDeleteFile.Substring(0, intStartIndex) + "_Image6.bmp";
                                    if (File.Exists(strDeleteFileImage6))
                                    {
                                        try
                                        {
                                            File.Delete(strDeleteFileImage6);
                                        }
                                        catch (Exception ex)
                                        {
                                            STTrackLog.WriteLine("Vision4Process.cs > SaveImageBuffer Delete _image6 > Ex=" + ex.ToString());
                                        }
                                    }
                                }
                            }

                            strTrack += "20,";
                            m_arrRejectImageListPath.RemoveAt(0);

                            strTrack += "21,";
                        }

                        strTrack += "22,";
                        if (m_arrRejectImageErrorMessageListPath.Count > 0)
                        {
                            strTrack += "23,";
                            string strDeleteFile = m_arrRejectImageErrorMessageListPath[0];
                            if (File.Exists(strDeleteFile))
                            {
                                strTrack += "24,";
                                File.Delete(strDeleteFile);

                                strTrack += "25,";
                            }

                            m_arrRejectImageErrorMessageListPath.RemoveAt(0);

                            strTrack += "26,";
                        }
                    }
                    else if (m_arrFailNoBuffer[m_intFailStartNode] == 0)
                    {
                        strTrack += "27,";
                        m_arrRejectImageListPath.Clear();
                        m_arrRejectImageErrorMessageListPath.Clear();

                        strTrack += "28,";
                    }

                    strTrack += "29,";
                    //string strPath = m_smVisionInfo.g_strSaveImageLocation +
                    //            m_smProductionInfo.g_strLotID + "_" + m_smProductionInfo.g_strLotStartTime +
                    //            "\\" + m_smVisionInfo.g_strVisionFolderName +
                    //            "(" + m_smVisionInfo.g_strVisionDisplayName + " " + m_smVisionInfo.g_strVisionNameRemark + ")" +
                    //            "\\" + m_arrRejectNameBuffer[m_intFailStartNode] + "\\";

                    // 2020 03 27 - JBTAN: Save to different folder if reset count
                    string strPath;
                    if (m_smVisionInfo.g_intVisionResetCount == 0)
                    {
                        strPath = m_smVisionInfo.g_strSaveImageLocation +
                            m_smProductionInfo.g_strLotID + "_" + m_smProductionInfo.g_strLotStartTime +
                            "\\" + m_smVisionInfo.g_strVisionFolderName +
                            "(" + m_smVisionInfo.g_strVisionDisplayName + " " + m_smVisionInfo.g_strVisionNameRemark + ")" + "_" + m_smProductionInfo.g_strLotStartTime +
                            "\\" + m_arrRejectNameBuffer[m_intFailStartNode] + "\\";
                    }
                    else
                    {
                        string strLotSaveImagePath = m_smVisionInfo.g_strSaveImageLocation + m_smProductionInfo.g_strLotID + "_" + m_smProductionInfo.g_strLotStartTime;
                        string strVisionImageFolderName = m_smVisionInfo.g_strVisionFolderName + "(" + m_smVisionInfo.g_strVisionDisplayName + " " + m_smVisionInfo.g_strVisionNameRemark + ")" + "_" + m_smVisionInfo.g_strVisionResetCountTime;

                        if (!Directory.Exists(strLotSaveImagePath + "\\" + strVisionImageFolderName))
                            Directory.CreateDirectory(strLotSaveImagePath + "\\" + strVisionImageFolderName);
                        if (!Directory.Exists(strLotSaveImagePath + "\\" + strVisionImageFolderName + "\\" + m_arrRejectNameBuffer[m_intFailStartNode] + "\\"))
                            Directory.CreateDirectory(strLotSaveImagePath + "\\" + strVisionImageFolderName + "\\" + m_arrRejectNameBuffer[m_intFailStartNode] + "\\");

                        strPath = strLotSaveImagePath + "\\" + strVisionImageFolderName + "\\" + m_arrRejectNameBuffer[m_intFailStartNode] + "\\";
                    }

                    strTrack += "30,";
                    string strFileName;
                    if (m_arrRetryCountBuffer[m_intFailStartNode] == 0)
                        strFileName = (m_arrFailNoBuffer[m_intFailStartNode] + "_" + m_arrRejectNameBuffer[m_intFailStartNode]).ToString();
                    else
                        strFileName = (m_arrFailNoBuffer[m_intFailStartNode] + "_" + m_arrRetryCountBuffer[m_intFailStartNode] + "_" + m_arrRejectNameBuffer[m_intFailStartNode]).ToString();

                    strTrack += "31,";

                    if (m_smVisionInfo.g_blnViewColorImage)
                    {
                        m_arrFailCImage1Buffer[m_intFailStartNode].SaveImage(strPath + strFileName + ".bmp");
                        //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                        m_arrFailCImage1Buffer[m_intFailStartNode].Dispose();
                        m_arrFailCImage1Buffer[m_intFailStartNode] = new CImageDrawing(true);
                    }
                    else
                    {
                        m_arrFailImage1Buffer[m_intFailStartNode].SaveImage(strPath + strFileName + ".bmp");
                        //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                        m_arrFailImage1Buffer[m_intFailStartNode].Dispose();
                        m_arrFailImage1Buffer[m_intFailStartNode] = new ImageDrawing(true);
                    }

                    strTrack += "31,";
                    if (m_smVisionInfo.g_arrImages.Count > 1)
                    {
                        if (m_smVisionInfo.g_blnViewColorImage)
                        {
                            m_arrFailCImage2Buffer[m_intFailStartNode].SaveImage(strPath + strFileName + "_Image1.bmp");
                            //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                            m_arrFailCImage2Buffer[m_intFailStartNode].Dispose();
                            m_arrFailCImage2Buffer[m_intFailStartNode] = new CImageDrawing(true);
                        }
                        else
                        {
                            m_arrFailImage2Buffer[m_intFailStartNode].SaveImage(strPath + strFileName + "_Image1.bmp");
                            //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                            m_arrFailImage2Buffer[m_intFailStartNode].Dispose();
                            m_arrFailImage2Buffer[m_intFailStartNode] = new ImageDrawing(true);
                        }
                    }

                    strTrack += "33,";

                    if (m_smVisionInfo.g_arrImages.Count > 2)
                    {
                        if (m_smVisionInfo.g_blnViewColorImage)
                        {
                            m_arrFailCImage3Buffer[m_intFailStartNode].SaveImage(strPath + strFileName + "_Image2.bmp");
                            //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                            m_arrFailCImage3Buffer[m_intFailStartNode].Dispose();
                            m_arrFailCImage3Buffer[m_intFailStartNode] = new CImageDrawing(true);
                        }
                        else
                        {
                            m_arrFailImage3Buffer[m_intFailStartNode].SaveImage(strPath + strFileName + "_Image2.bmp");
                            //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                            m_arrFailImage3Buffer[m_intFailStartNode].Dispose();
                            m_arrFailImage3Buffer[m_intFailStartNode] = new ImageDrawing(true);
                        }
                    }

                    strTrack += "34,";
                    if (m_smVisionInfo.g_arrImages.Count > 3)
                    {
                        if (m_smVisionInfo.g_blnViewColorImage)
                        {
                            m_arrFailCImage4Buffer[m_intFailStartNode].SaveImage(strPath + strFileName + "_Image3.bmp");
                            //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                            m_arrFailCImage4Buffer[m_intFailStartNode].Dispose();
                            m_arrFailCImage4Buffer[m_intFailStartNode] = new CImageDrawing(true);
                        }
                        else
                        {
                            m_arrFailImage4Buffer[m_intFailStartNode].SaveImage(strPath + strFileName + "_Image3.bmp");
                            //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                            m_arrFailImage4Buffer[m_intFailStartNode].Dispose();
                            m_arrFailImage4Buffer[m_intFailStartNode] = new ImageDrawing(true);
                        }
                    }

                    strTrack += "35,";
                    if (m_smVisionInfo.g_arrImages.Count > 4)
                    {
                        if (m_smVisionInfo.g_blnViewColorImage)
                        {
                            m_arrFailCImage5Buffer[m_intFailStartNode].SaveImage(strPath + strFileName + "_Image4.bmp");
                            //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                            m_arrFailCImage5Buffer[m_intFailStartNode].Dispose();
                            m_arrFailCImage5Buffer[m_intFailStartNode] = new CImageDrawing(true);
                        }
                        else
                        {
                            m_arrFailImage5Buffer[m_intFailStartNode].SaveImage(strPath + strFileName + "_Image4.bmp");
                            //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                            m_arrFailImage5Buffer[m_intFailStartNode].Dispose();
                            m_arrFailImage5Buffer[m_intFailStartNode] = new ImageDrawing(true);
                        }
                    }

                    strTrack += "36,";
                    if (m_smVisionInfo.g_arrImages.Count > 5)
                    {
                        if (m_smVisionInfo.g_blnViewColorImage)
                        {
                            m_arrFailCImage6Buffer[m_intFailStartNode].SaveImage(strPath + strFileName + "_Image5.bmp");
                            //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                            m_arrFailCImage6Buffer[m_intFailStartNode].Dispose();
                            m_arrFailCImage6Buffer[m_intFailStartNode] = new CImageDrawing(true);
                        }
                        else
                        {
                            m_arrFailImage6Buffer[m_intFailStartNode].SaveImage(strPath + strFileName + "_Image5.bmp");
                            //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                            m_arrFailImage6Buffer[m_intFailStartNode].Dispose();
                            m_arrFailImage6Buffer[m_intFailStartNode] = new ImageDrawing(true);
                        }
                    }

                    strTrack += "37,";
                    if (m_smVisionInfo.g_arrImages.Count > 6)
                    {
                        if (m_smVisionInfo.g_blnViewColorImage)
                        {
                            m_arrFailCImage7Buffer[m_intFailStartNode].SaveImage(strPath + strFileName + "_Image6.bmp");
                            //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                            m_arrFailCImage7Buffer[m_intFailStartNode].Dispose();
                            m_arrFailCImage7Buffer[m_intFailStartNode] = new CImageDrawing(true);
                        }
                        else
                        {
                            m_arrFailImage7Buffer[m_intFailStartNode].SaveImage(strPath + strFileName + "_Image6.bmp");
                            //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                            m_arrFailImage7Buffer[m_intFailStartNode].Dispose();
                            m_arrFailImage7Buffer[m_intFailStartNode] = new ImageDrawing(true);
                        }
                    }

                    strTrack += "38,";

                    if (m_smCustomizeInfo.g_blnSaveFailImageErrorMessage)
                    {
                        strTrack += "39,";
                        XmlParser objFile = new XmlParser(strPath + m_arrFailNoBuffer[m_intFailStartNode] + "_" + m_arrRejectNameBuffer[m_intFailStartNode] + ".xml");
                        objFile.WriteSectionElement("ErrorMessage");
                        objFile.WriteElement1Value("Message_" + m_arrFailNoBuffer[m_intFailStartNode] + "_" + m_arrRejectNameBuffer[m_intFailStartNode], m_arrRejectMessageBuffer[m_intFailStartNode]);
                        objFile.WriteEndElement();

                        strTrack += "40,";
                    }

                    strTrack += "41,";
                    m_smVisionInfo.g_strLastImageFolder = strPath;
                    m_smVisionInfo.g_strLastImageName = strFileName + ".bmp";
                    strTrack += "42,";
                    m_arrRejectImageListPath.Add(strPath + m_arrFailNoBuffer[m_intFailStartNode] + "_" + m_arrRejectNameBuffer[m_intFailStartNode] + ".bmp");
                    strTrack += "43,";
                    m_arrRejectImageErrorMessageListPath.Add(strPath + m_arrFailNoBuffer[m_intFailStartNode] + "_" + m_arrRejectNameBuffer[m_intFailStartNode] + ".xml");
                    strTrack += "44,";
                    m_intFailStartNode++;

                    if (m_intFailStartNode == m_smVisionInfo.g_intSaveImageBufferSize)
                    {
                        strTrack += "45,";
                        m_intFailStartNode = 0;
                    }

                    strTrack += "46,";
                    if (m_smProductionInfo.m_blnTrackON)
                        STTrackLog.WriteLine("F2 Start=" + m_intFailStartNode.ToString() + ", End=" + m_intFailEndNode.ToString());
                }
            }
            catch (Exception ex)
            {
                if (m_smProductionInfo.m_blnTrackON)
                {
                    STTrackLog.WriteLine("Vision4Process.cs > SaveImageBuffer Ex=" + ex.ToString());
                    STTrackLog.WriteLine("Vision4Process.cs > SaveImageBuffer strck=" + strTrack);
                }
                //SRMMessageBox.Show("Vision4Process.cs > SaveImageBuffer > Ex=" + ex.ToString());
            }
        }

        private void WaitImageBufferClear(ref int intStartNode, ref int intEndNode)
        {
            // 2021 04 02 - CCENG: Commented it bcos seem like this infor is no longer needed.
            //STTrackLog.WriteLine("WaitImageBufferClear : " + intEndNode.ToString() + ", " + intStartNode.ToString() + ", " + BUFFERSIZE.ToString());
            int intLoop = 0;

            while (true)
            {
                int intNextEndNode = intEndNode + 1;    // Get the next end node number
                if (intNextEndNode >= m_smVisionInfo.g_intSaveImageBufferSize)       // End node number set to 0 if value over buffer size
                    intNextEndNode = 0;


                if (intNextEndNode != intStartNode)     // End node around to break if no hit start no. (Hit start node mean image buffer full.
                {
                    return;
                }

                intLoop++;
                if (intLoop >= m_smVisionInfo.g_intSaveImageBufferSize)
                {
                    Thread.Sleep(200);
                    break;
                }

                Thread.Sleep(1);
            }
        }

        private void WaitAllImageGrabDone()
        {
            bool blnReturn = false;

            while (true)
            {
                switch (m_intGrabRequire)
                {
                    case 1:
                        if (m_bGrabImage1Done)
                            blnReturn = true;
                        break;
                    case 2:
                        if (m_bGrabImage2Done)
                            blnReturn = true;
                        break;
                    case 3:
                        if (m_bGrabImage3Done)
                            blnReturn = true;
                        break;
                    case 4:
                        if (m_bGrabImage4Done)
                            blnReturn = true;
                        break;
                    case 5:
                        if (m_bGrabImage5Done)
                            blnReturn = true;
                        break;
                    case 6:
                        if (m_bGrabImage6Done)
                            blnReturn = true;
                        break;
                    case 7:
                        if (m_bGrabImage7Done)
                            blnReturn = true;
                        break;
                }

                if (blnReturn)
                    return;

                Thread.Sleep(1);
            }
        }

        private void LoadRejectImageListPath()
        {
            //string strRejectImageFolderPath = m_smVisionInfo.g_strSaveImageLocation +
            //               m_smProductionInfo.g_strLotID + "_" + m_smProductionInfo.g_strLotStartTime +
            //               "\\" + m_smVisionInfo.g_strVisionFolderName +
            //               "(" + m_smVisionInfo.g_strVisionDisplayName + " " + m_smVisionInfo.g_strVisionNameRemark + ")";

            // 2020 03 27 - JBTAN: Load from different folder if reset count
            string strRejectImageFolderPath;
            if (m_smVisionInfo.g_intVisionResetCount == 0)
            {
                strRejectImageFolderPath = m_smVisionInfo.g_strSaveImageLocation +
                    m_smProductionInfo.g_strLotID + "_" + m_smProductionInfo.g_strLotStartTime +
                    "\\" + m_smVisionInfo.g_strVisionFolderName +
                    "(" + m_smVisionInfo.g_strVisionDisplayName + " " + m_smVisionInfo.g_strVisionNameRemark + ")" + "_" + m_smProductionInfo.g_strLotStartTime;
            }
            else
            {
                strRejectImageFolderPath = m_smVisionInfo.g_strSaveImageLocation +
                    m_smProductionInfo.g_strLotID + "_" + m_smProductionInfo.g_strLotStartTime +
                    "\\" + m_smVisionInfo.g_strVisionFolderName +
                    "(" + m_smVisionInfo.g_strVisionDisplayName + " " + m_smVisionInfo.g_strVisionNameRemark + ")" + "_" + m_smVisionInfo.g_strVisionResetCountTime;
            }

            string[] arrRejectImageFoldderList = Directory.GetDirectories(strRejectImageFolderPath);

            List<int> arrRejectImageNo = new List<int>();
            m_arrRejectImageListPath.Clear();
            m_arrRejectImageErrorMessageListPath.Clear();
            foreach (string strFolderPath in arrRejectImageFoldderList)
            {
                //2021-02-24 ZJYHEOH : No need to delete pass image
                if (strFolderPath.Substring(strFolderPath.LastIndexOf('\\') + 1, strFolderPath.Length - strFolderPath.LastIndexOf('\\') - 1) == "Pass")
                    continue;

                string[] arrRejectImageList = Directory.GetFiles(strFolderPath);

                foreach (string strFilePath in arrRejectImageList)
                {
                    string strFileName = Path.GetFileNameWithoutExtension(strFilePath);

                    if (strFileName.LastIndexOf("_Image") > 0)
                    {
                        continue;
                    }

                    int intFileNo = 0;
                    if (int.TryParse(new string(strFileName
                     .SkipWhile(x => !char.IsDigit(x))
                     .TakeWhile(x => char.IsDigit(x))
                     .ToArray()), out intFileNo))
                    {
                        int intSelectedIndex = arrRejectImageNo.Count;
                        for (int i = 0; i < arrRejectImageNo.Count; i++)
                        {
                            if (intFileNo < arrRejectImageNo[i])
                            {
                                intSelectedIndex = i;
                                break;
                            }

                        }

                        m_arrRejectImageListPath.Insert(intSelectedIndex, strFilePath);
                        arrRejectImageNo.Insert(intSelectedIndex, intFileNo);

                        //for error message xml file
                        string strErrorMessagePath = strFilePath.Replace(".bmp", ".xml");
                        if (File.Exists(strErrorMessagePath))
                        {
                            if (intSelectedIndex > m_arrRejectImageErrorMessageListPath.Count)
                            {
                                if (m_arrRejectImageErrorMessageListPath.Count == 0)
                                    m_arrRejectImageErrorMessageListPath.Insert(0, strErrorMessagePath);
                                else
                                    m_arrRejectImageErrorMessageListPath.Insert(m_arrRejectImageErrorMessageListPath.Count - 1, strErrorMessagePath);
                            }
                            else
                                m_arrRejectImageErrorMessageListPath.Insert(intSelectedIndex, strErrorMessagePath);
                        }
                    }

                }
            }
        }

        public void WaitAllThreadStopped()
        {
            HiPerfTimer timesout = new HiPerfTimer();
            timesout.Start();

            while (true)
            {
                if (m_blnStopped &&
                    m_blnStopped_AfterInspect &&
                    m_blnStopped_SaveImage &&
                    m_blnStopped_GrabImage &&
                    m_blnStopped_MarkTest &&
                    m_blnStopped_PackageTest_MarkLightView &&
                    m_blnStopped_PackageTest_SideLightView &&
                    m_blnStopped_PackageTest_TopLightView &&
                    m_blnStopped_LeadTest
                    )
                {
                    STTrackLog.WriteLine("Vision4Process All threads have stopped.");
                    break;
                }

                if (timesout.Timing > 3000)
                {
                    STTrackLog.WriteLine("Vision4Process : m_blnStopped = " + m_blnStopped.ToString());
                    STTrackLog.WriteLine("Vision4Process : m_blnStopped_AfterInspect = " + m_blnStopped_AfterInspect.ToString());
                    STTrackLog.WriteLine("Vision4Process : m_blnStopped_CenterThread = " + m_blnStopped_MarkTest.ToString());
                    STTrackLog.WriteLine("Vision4Process : m_blnStopped_GrabImage = " + m_blnStopped_GrabImage.ToString());
                    STTrackLog.WriteLine("Vision4Process : m_blnStopped_TransferImage = " + m_blnStopped_PackageTest_MarkLightView.ToString());
                    STTrackLog.WriteLine("Vision4Process : m_blnStopped_WaitFrame = " + m_blnStopped_PackageTest_SideLightView.ToString());
                    STTrackLog.WriteLine("Vision4Process : m_blnStopped_SideBRThread = " + m_blnStopped_PackageTest_TopLightView.ToString());
                    STTrackLog.WriteLine("Vision4Process : m_blnStopped_SideTLThread = " + m_blnStopped_LeadTest.ToString());
                    STTrackLog.WriteLine("Vision4Process : m_blnStopped_SaveImage = " + m_blnStopped_SaveImage.ToString());
                    STTrackLog.WriteLine("Vision4Process : >>>>>>>>>>>>> time out 3");
                    break;
                }

                Thread.Sleep(1);
            }
        }

        private void RecordGRR2()
        {
            // Check GRR turn ON or not
            if (!m_smVisionInfo.g_blnGRRON)
                return;

            try
            {

                string[] strSampleFeature = new string[100];

                int intRecordIndex = 0;

                for (int p = 0; p < m_smVisionInfo.g_arrPackage.Count; p++)
                {

                    //for (int i = 0; i < 2; i++)
                    //{
                    //    if (i == 0)
                    //    {
                    if (!m_smVisionInfo.g_objGRR.Record(0, intRecordIndex, "In Pocket Package", Convert.ToSingle(m_smVisionInfo.g_arrPackage[p].ref_fUnitResultWidth)))
                        return;
                    //  }
                    //  if (i == 1)
                    //   {
                    if (!m_smVisionInfo.g_objGRR.Record(1, intRecordIndex, "In Pocket Package", Convert.ToSingle(m_smVisionInfo.g_arrPackage[p].ref_fUnitResultHeight)))
                        return;
                    //  }

                    intRecordIndex++;
                    // }
                }

                m_smVisionInfo.g_objGRR.NextIndex();
            }
            catch (Exception ex)
            {
                SRMMessageBox.Show("Vision 4 GRR Error: " + ex.ToString());
            }
        }

        private void LoadNextImageForDebugRunTest()
        {
            if (m_smVisionInfo.g_arrImageFiles.Count == 0)
                return;

            if (m_smVisionInfo.g_intFileIndex < 0 || m_smVisionInfo.g_intFileIndex >= m_smVisionInfo.g_arrImageFiles.Count)
                m_smVisionInfo.g_intFileIndex = 0;

            string strFileName = m_smVisionInfo.g_arrImageFiles[m_smVisionInfo.g_intFileIndex].ToString();

            if (!m_smVisionInfo.g_blnViewColorImage)
            {
                m_smVisionInfo.g_arrImages[0].LoadImage(strFileName);
                for (int i = 1; i < m_smVisionInfo.g_arrImages.Count; i++)
                {
                    string strDirPath = Path.GetDirectoryName(strFileName);
                    string strPkgView = strDirPath + "\\" + Path.GetFileNameWithoutExtension(strFileName) + "_Image" + i.ToString() + ".BMP";

                    if (File.Exists(strPkgView))
                        m_smVisionInfo.g_arrImages[i].LoadImage(strPkgView);
                    else
                        m_smVisionInfo.g_arrImages[i].LoadImage(strFileName);
                }
            }
            else
            {
                m_smVisionInfo.g_arrColorImages[0].LoadImage(strFileName);
                m_smVisionInfo.g_arrColorImages[0].ConvertColorToMono(ref m_smVisionInfo.g_arrImages, 0);
                for (int i = 1; i < m_smVisionInfo.g_arrColorImages.Count; i++)
                {
                    string strDirPath = Path.GetDirectoryName(strFileName);
                    string strPkgView = strDirPath + "\\" + Path.GetFileNameWithoutExtension(strFileName) + "_Image" + i.ToString() + ".BMP";

                    if (File.Exists(strPkgView))
                        m_smVisionInfo.g_arrColorImages[i].LoadImage(strPkgView);
                    else
                        m_smVisionInfo.g_arrColorImages[i].LoadImage(strFileName);
                    m_smVisionInfo.g_arrColorImages[i].ConvertColorToMono(ref m_smVisionInfo.g_arrImages, i);
                }
            }

            if (++m_smVisionInfo.g_intFileIndex == m_smVisionInfo.g_arrImageFiles.Count)
                m_smVisionInfo.g_intFileIndex = 0;
        }

        private void InitSaveImageBuffer(int intGrabRequire)
        {
            if (m_smVisionInfo.g_blnViewColorImage)
            {
                if (intGrabRequire > 0)
                    m_arrPassCImage1Buffer = new CImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];
                if (intGrabRequire > 1)
                    m_arrPassCImage2Buffer = new CImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];
                if (intGrabRequire > 2)
                    m_arrPassCImage3Buffer = new CImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];
                if (intGrabRequire > 3)
                    m_arrPassCImage4Buffer = new CImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];
                if (intGrabRequire > 4)
                    m_arrPassCImage5Buffer = new CImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];
                if (intGrabRequire > 5)
                    m_arrPassCImage6Buffer = new CImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];
                if (intGrabRequire > 6)
                    m_arrPassCImage7Buffer = new CImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];

                if (intGrabRequire > 0)
                    m_arrFailCImage1Buffer = new CImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];
                if (intGrabRequire > 1)
                    m_arrFailCImage2Buffer = new CImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];
                if (intGrabRequire > 2)
                    m_arrFailCImage3Buffer = new CImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];
                if (intGrabRequire > 3)
                    m_arrFailCImage4Buffer = new CImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];
                if (intGrabRequire > 4)
                    m_arrFailCImage5Buffer = new CImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];
                if (intGrabRequire > 5)
                    m_arrFailCImage6Buffer = new CImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];
                if (intGrabRequire > 6)
                    m_arrFailCImage7Buffer = new CImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];

                for (int i = 0; i < m_smVisionInfo.g_intSaveImageBufferSize; i++)
                {
                    if (intGrabRequire > 0)
                        m_arrPassCImage1Buffer[i] = new CImageDrawing(true);
                    if (intGrabRequire > 1)
                        m_arrPassCImage2Buffer[i] = new CImageDrawing(true);
                    if (intGrabRequire > 2)
                        m_arrPassCImage3Buffer[i] = new CImageDrawing(true);
                    if (intGrabRequire > 3)
                        m_arrPassCImage4Buffer[i] = new CImageDrawing(true);
                    if (intGrabRequire > 4)
                        m_arrPassCImage5Buffer[i] = new CImageDrawing(true);
                    if (intGrabRequire > 5)
                        m_arrPassCImage6Buffer[i] = new CImageDrawing(true);
                    if (intGrabRequire > 6)
                        m_arrPassCImage7Buffer[i] = new CImageDrawing(true);

                    if (intGrabRequire > 0)
                        m_arrFailCImage1Buffer[i] = new CImageDrawing(true);
                    if (intGrabRequire > 1)
                        m_arrFailCImage2Buffer[i] = new CImageDrawing(true);
                    if (intGrabRequire > 2)
                        m_arrFailCImage3Buffer[i] = new CImageDrawing(true);
                    if (intGrabRequire > 3)
                        m_arrFailCImage4Buffer[i] = new CImageDrawing(true);
                    if (intGrabRequire > 4)
                        m_arrFailCImage5Buffer[i] = new CImageDrawing(true);
                    if (intGrabRequire > 5)
                        m_arrFailCImage6Buffer[i] = new CImageDrawing(true);
                    if (intGrabRequire > 6)
                        m_arrFailCImage7Buffer[i] = new CImageDrawing(true);
                }
            }
            else
            {
                if (intGrabRequire > 0)
                    m_arrPassImage1Buffer = new ImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];
                if (intGrabRequire > 1)
                    m_arrPassImage2Buffer = new ImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];
                if (intGrabRequire > 2)
                    m_arrPassImage3Buffer = new ImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];
                if (intGrabRequire > 3)
                    m_arrPassImage4Buffer = new ImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];
                if (intGrabRequire > 4)
                    m_arrPassImage5Buffer = new ImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];
                if (intGrabRequire > 5)
                    m_arrPassImage6Buffer = new ImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];
                if (intGrabRequire > 6)
                    m_arrPassImage7Buffer = new ImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];

                if (intGrabRequire > 0)
                    m_arrFailImage1Buffer = new ImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];
                if (intGrabRequire > 1)
                    m_arrFailImage2Buffer = new ImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];
                if (intGrabRequire > 2)
                    m_arrFailImage3Buffer = new ImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];
                if (intGrabRequire > 3)
                    m_arrFailImage4Buffer = new ImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];
                if (intGrabRequire > 4)
                    m_arrFailImage5Buffer = new ImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];
                if (intGrabRequire > 5)
                    m_arrFailImage6Buffer = new ImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];
                if (intGrabRequire > 6)
                    m_arrFailImage7Buffer = new ImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];

                for (int i = 0; i < m_smVisionInfo.g_intSaveImageBufferSize; i++)
                {
                    if (intGrabRequire > 0)
                        m_arrPassImage1Buffer[i] = new ImageDrawing(true);
                    if (intGrabRequire > 1)
                        m_arrPassImage2Buffer[i] = new ImageDrawing(true);
                    if (intGrabRequire > 2)
                        m_arrPassImage3Buffer[i] = new ImageDrawing(true);
                    if (intGrabRequire > 3)
                        m_arrPassImage4Buffer[i] = new ImageDrawing(true);
                    if (intGrabRequire > 4)
                        m_arrPassImage5Buffer[i] = new ImageDrawing(true);
                    if (intGrabRequire > 5)
                        m_arrPassImage6Buffer[i] = new ImageDrawing(true);
                    if (intGrabRequire > 6)
                        m_arrPassImage7Buffer[i] = new ImageDrawing(true);

                    if (intGrabRequire > 0)
                        m_arrFailImage1Buffer[i] = new ImageDrawing(true);
                    if (intGrabRequire > 1)
                        m_arrFailImage2Buffer[i] = new ImageDrawing(true);
                    if (intGrabRequire > 2)
                        m_arrFailImage3Buffer[i] = new ImageDrawing(true);
                    if (intGrabRequire > 3)
                        m_arrFailImage4Buffer[i] = new ImageDrawing(true);
                    if (intGrabRequire > 4)
                        m_arrFailImage5Buffer[i] = new ImageDrawing(true);
                    if (intGrabRequire > 5)
                        m_arrFailImage6Buffer[i] = new ImageDrawing(true);
                    if (intGrabRequire > 6)
                        m_arrFailImage7Buffer[i] = new ImageDrawing(true);
                }
            }
            m_arrPassNoBuffer = new int[m_smVisionInfo.g_intSaveImageBufferSize];
            m_arrFailNoBuffer = new int[m_smVisionInfo.g_intSaveImageBufferSize];
            m_arrOrientationBuffer = new int[m_smVisionInfo.g_intSaveImageBufferSize];
            m_arrUnitNoBuffer = new int[m_smVisionInfo.g_intSaveImageBufferSize];
            m_arrRetryCountBuffer = new int[m_smVisionInfo.g_intSaveImageBufferSize];
            m_arrRejectNameBuffer = new string[m_smVisionInfo.g_intSaveImageBufferSize];
            m_arrRejectMessageBuffer = new string[m_smVisionInfo.g_intSaveImageBufferSize];
        }

        private bool StartLeadTest_MultiThreading(bool blnAuto)
        {
            bool blnWantDebug = false;
            bool bWholeTestFail = false;
            m_fLeadPatternScore = 0;
            m_fLeadPatternAngle = 0;
            if ((m_smCustomizeInfo.g_intWantLead & (1 << m_smVisionInfo.g_intVisionPos)) == 0 || !m_smVisionInfo.g_arrLead[0].GetWantInspectLead())//!m_smVisionInfo.g_blnCheckLead
                return true;
            if (m_smVisionInfo.g_arrLeadROIs[0].Count == 0)
            {
                m_bLeadBaseCenterPointDone = true;
                m_bLeadBaseCenterPointResult = false;

                if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                {
                    WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_MarkTest 1");
                    if (!m_bSubTh_MarkTest_Result)
                    {
                        return false;
                    }

                    WaitEventDone(ref m_bSubTh_PackageTest_MarkLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_MarkLightView 1");
                    if (!m_bSubTh_PackageTest_MarkLightView_Result)
                    {
                        return false;
                    }

                    WaitEventDone(ref m_bSubTh_PackageTest_SideLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_SideLightView 1");
                    if (!m_bSubTh_PackageTest_SideLightView_Result)
                    {
                        return false;
                    }

                    WaitEventDone(ref m_bSubTh_PackageTest_TopLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_TopLightView 1");
                    if (!m_bSubTh_PackageTest_TopLightView_Result)
                    {
                        return false;
                    }
                }

                m_smVisionInfo.g_strErrorMessage += "*Lead : No Template Found";
                if (m_blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                {
                    m_smVisionInfo.g_intNoTemplateFailureTotal++;
                    m_blnFailCounterAdded = true;
                    m_blnTotalCounterAdded = false;

                }
                if (blnAuto)
                {
                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        if (m_intTCPIPResultID == -1)
                            m_intTCPIPResultID = (int)TCPIPResulID.Fail;
                }
                return false;
            }
            // Reset inspection drawing
            for (int i = 0; i < m_smVisionInfo.g_arrLead.Length; i++)
            {
                m_smVisionInfo.g_arrLead[i].ref_blnViewLeadResultDrawing = false;

                if (!m_smVisionInfo.g_arrLead[i].ref_blnSelected)
                    continue;

                if ((m_smVisionInfo.g_arrLead[i].GetBlobsFeaturesNumber() == 0) || (m_smVisionInfo.g_arrLead[0].ref_blnWantInspectBaseLead && (m_smVisionInfo.g_arrLead[i].GetBlobsFeaturesNumber_BaseLead() == 0)))
                {
                    m_bLeadBaseCenterPointDone = true;
                    m_bLeadBaseCenterPointResult = false;

                    if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                    {
                        WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_MarkTest 1");
                        if (!m_bSubTh_MarkTest_Result)
                        {
                            return false;
                        }

                        WaitEventDone(ref m_bSubTh_PackageTest_MarkLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_MarkLightView 1");
                        if (!m_bSubTh_PackageTest_MarkLightView_Result)
                        {
                            return false;
                        }

                        WaitEventDone(ref m_bSubTh_PackageTest_SideLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_SideLightView 1");
                        if (!m_bSubTh_PackageTest_SideLightView_Result)
                        {
                            return false;
                        }

                        WaitEventDone(ref m_bSubTh_PackageTest_TopLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_TopLightView 1");
                        if (!m_bSubTh_PackageTest_TopLightView_Result)
                        {
                            return false;
                        }
                    }

                    if (m_smVisionInfo.g_arrLead[0].ref_blnWantInspectBaseLead && (m_smVisionInfo.g_arrLead[i].GetBlobsFeaturesNumber_BaseLead() == 0))
                        m_smVisionInfo.g_strErrorMessage += "*Lead : Base Lead Template is Empty";
                    else
                        m_smVisionInfo.g_strErrorMessage += "*Lead : Lead Template is Empty";
                    if (m_blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                    {
                        m_smVisionInfo.g_intNoTemplateFailureTotal++;
                        m_blnFailCounterAdded = true;
                        m_blnTotalCounterAdded = false;

                    }
                    if (blnAuto)
                    {
                        if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                            if (m_intTCPIPResultID == -1)
                                m_intTCPIPResultID = (int)TCPIPResulID.Fail;
                    }
                    return false;
                }
            }
            //m_smVisionInfo.g_objLeadImage.SaveImage("D:\\LeadImage1.bmp");
            //m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo].CopyTo(ref m_smVisionInfo.g_objLeadImage);

            bool blnFailPocketReference = false;
            if (m_smVisionInfo.g_blnWantPocketDontCareAreaFix_Lead)
            {
                for (int i = 1; i < m_smVisionInfo.g_arrLead.Length; i++)
                {
                    string strPosition = GetLeadDefinition(i);

                    if ((i == 1) && ((m_smVisionInfo.g_intLeadPocketDontCareROIFixMask & 0x01) == 0))
                        continue;
                    else if ((i == 2) && ((m_smVisionInfo.g_intLeadPocketDontCareROIFixMask & 0x02) == 0))
                        continue;
                    else if ((i == 3) && ((m_smVisionInfo.g_intLeadPocketDontCareROIFixMask & 0x04) == 0))
                        continue;
                    else if ((i == 4) && ((m_smVisionInfo.g_intLeadPocketDontCareROIFixMask & 0x08) == 0))
                        continue;

                    if (!FindFixPocket(i))
                    {
                        if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                        {
                            m_bLeadBaseCenterPointDone = true;
                            m_bLeadBaseCenterPointResult = false;

                            WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_MarkTest 1");
                            if (!m_bSubTh_MarkTest_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_MarkLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_MarkLightView 1");
                            if (!m_bSubTh_PackageTest_MarkLightView_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_SideLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_SideLightView 1");
                            if (!m_bSubTh_PackageTest_SideLightView_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_TopLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_TopLightView 1");
                            if (!m_bSubTh_PackageTest_TopLightView_Result)
                            {
                                return false;
                            }
                        }

                        blnFailPocketReference = true;
                        bWholeTestFail = true;
                        m_smVisionInfo.g_strErrorMessage = strPosition + m_smVisionInfo.g_strErrorMessage;

                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 35 g_intPositionFailureTotal=" + m_smVisionInfo.g_intPositionFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                        if (blnAuto)
                        {
                            SaveRejectImage_AddToBuffer("Lead", m_smVisionInfo.g_strErrorMessage);    // Should save then
                        }
                        if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                        {
                            //m_smVisionInfo.g_intPositionFailureTotal++;
                            m_smVisionInfo.g_intLeadFailureTotal++;
                            m_blnFailCounterAdded = true;
                            m_blnTotalCounterAdded = false;
                            //SaveRejectImage_AddToBuffer("Position", m_smVisionInfo.g_strErrorMessage);    // Should save then
                            if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 35a g_intPositionFailureTotal=" + m_smVisionInfo.g_intPositionFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                        }
                        if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                            break;
                    }
                }
            }
            else if (m_smVisionInfo.g_blnWantPocketDontCareAreaManual_Lead)
            {
                for (int i = 1; i < m_smVisionInfo.g_arrLead.Length; i++)
                {
                    string strPosition = GetLeadDefinition(i);

                    if ((i == 1) && ((m_smVisionInfo.g_intLeadPocketDontCareROIManualMask & 0x01) == 0))
                        continue;
                    else if ((i == 2) && ((m_smVisionInfo.g_intLeadPocketDontCareROIManualMask & 0x02) == 0))
                        continue;
                    else if ((i == 3) && ((m_smVisionInfo.g_intLeadPocketDontCareROIManualMask & 0x04) == 0))
                        continue;
                    else if ((i == 4) && ((m_smVisionInfo.g_intLeadPocketDontCareROIManualMask & 0x08) == 0))
                        continue;

                    if (!FindManualPocketReference(i))
                    {
                        if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                        {
                            m_bLeadBaseCenterPointDone = true;
                            m_bLeadBaseCenterPointResult = false;

                            WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_MarkTest 1");
                            if (!m_bSubTh_MarkTest_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_MarkLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_MarkLightView 1");
                            if (!m_bSubTh_PackageTest_MarkLightView_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_SideLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_SideLightView 1");
                            if (!m_bSubTh_PackageTest_SideLightView_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_TopLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_TopLightView 1");
                            if (!m_bSubTh_PackageTest_TopLightView_Result)
                            {
                                return false;
                            }
                        }

                        blnFailPocketReference = true;
                        bWholeTestFail = true;
                        m_smVisionInfo.g_strErrorMessage = strPosition + m_smVisionInfo.g_strErrorMessage;

                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 35 g_intPositionFailureTotal=" + m_smVisionInfo.g_intPositionFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                        if (blnAuto)
                        {
                            SaveRejectImage_AddToBuffer("Lead", m_smVisionInfo.g_strErrorMessage);    // Should save then
                        }
                        if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                        {
                            //m_smVisionInfo.g_intPositionFailureTotal++;
                            m_smVisionInfo.g_intLeadFailureTotal++;
                            m_blnFailCounterAdded = true;
                            m_blnTotalCounterAdded = false;
                            //SaveRejectImage_AddToBuffer("Position", m_smVisionInfo.g_strErrorMessage);    // Should save then
                            if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 35a g_intPositionFailureTotal=" + m_smVisionInfo.g_intPositionFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                        }
                        if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                            break;
                    }
                }
            }
            else if (m_smVisionInfo.g_blnWantPocketDontCareAreaAuto_Lead)
            {
                if (blnWantDebug)
                {
                    m_smVisionInfo.g_objLeadImage.SaveImage("D:\\TS\\1.g_objLeadImage.bmp");
                }
                ImageDrawing objImg = new ImageDrawing(true);
                m_smVisionInfo.g_objLeadImage.CopyTo(objImg);
                for (int i = 1; i < m_smVisionInfo.g_arrLead.Length; i++)
                {
                    string strPosition = GetLeadDefinition(i);

                    if ((i == 1) && ((m_smVisionInfo.g_intLeadPocketDontCareROIAutoMask & 0x01) == 0))
                        continue;
                    else if ((i == 2) && ((m_smVisionInfo.g_intLeadPocketDontCareROIAutoMask & 0x02) == 0))
                        continue;
                    else if ((i == 3) && ((m_smVisionInfo.g_intLeadPocketDontCareROIAutoMask & 0x04) == 0))
                        continue;
                    else if ((i == 4) && ((m_smVisionInfo.g_intLeadPocketDontCareROIAutoMask & 0x08) == 0))
                        continue;

                    if (!FindAutoPocketReference(i, objImg))
                    {
                        if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                        {
                            m_bLeadBaseCenterPointDone = true;
                            m_bLeadBaseCenterPointResult = false;

                            WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_MarkTest 1");
                            if (!m_bSubTh_MarkTest_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_MarkLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_MarkLightView 1");
                            if (!m_bSubTh_PackageTest_MarkLightView_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_SideLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_SideLightView 1");
                            if (!m_bSubTh_PackageTest_SideLightView_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_TopLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_TopLightView 1");
                            if (!m_bSubTh_PackageTest_TopLightView_Result)
                            {
                                return false;
                            }
                        }

                        blnFailPocketReference = true;
                        bWholeTestFail = true;
                        m_smVisionInfo.g_strErrorMessage = strPosition + m_smVisionInfo.g_strErrorMessage;

                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 35 g_intPositionFailureTotal=" + m_smVisionInfo.g_intPositionFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                        if (blnAuto)
                        {
                            SaveRejectImage_AddToBuffer("Lead", m_smVisionInfo.g_strErrorMessage);    // Should save then
                        }
                        if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                        {
                            //m_smVisionInfo.g_intPositionFailureTotal++;
                            m_smVisionInfo.g_intLeadFailureTotal++;
                            m_blnFailCounterAdded = true;
                            m_blnTotalCounterAdded = false;
                            //SaveRejectImage_AddToBuffer("Position", m_smVisionInfo.g_strErrorMessage);    // Should save then
                            if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 35a g_intPositionFailureTotal=" + m_smVisionInfo.g_intPositionFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                        }
                        if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                            break;
                    }
                }
                objImg.Dispose();

                if (blnWantDebug)
                {
                    m_smVisionInfo.g_objLeadImage.SaveImage("D:\\TS\\2.g_objLeadImage.bmp");
                }
            }
            else if (m_smVisionInfo.g_blnWantPocketDontCareAreaBlob_Lead)
            {
                m_smVisionInfo.g_arrInwardDontCareROIBlobLimit = new List<float>(5) { 0, 0, 0, 0, 0 };

                for (int i = 1; i < m_smVisionInfo.g_arrLead.Length; i++)
                {
                    string strPosition = GetLeadDefinition(i);

                    if ((i == 1) && ((m_smVisionInfo.g_intLeadPocketDontCareROIBlobMask & 0x01) == 0))
                        continue;
                    else if ((i == 2) && ((m_smVisionInfo.g_intLeadPocketDontCareROIBlobMask & 0x02) == 0))
                        continue;
                    else if ((i == 3) && ((m_smVisionInfo.g_intLeadPocketDontCareROIBlobMask & 0x04) == 0))
                        continue;
                    else if ((i == 4) && ((m_smVisionInfo.g_intLeadPocketDontCareROIBlobMask & 0x08) == 0))
                        continue;

                    FindPocketShadowBlob(i, ref m_smVisionInfo.g_arrInwardDontCareROIBlobLimit);
                }

                if (blnWantDebug)
                {
                    m_smVisionInfo.g_objLeadImage.SaveImage("D:\\TS\\1.g_objLeadImage.bmp");
                }

                if (m_smVisionInfo.g_arrLead[0].ref_blnFlipToOppositeFunction && m_smVisionInfo.g_arrInwardDontCareROIBlobLimit.Contains(-1))
                {
                    FlipToOpposite_DontCareBlob(m_smVisionInfo.g_arrInwardDontCareROIBlobLimit);
                    if (blnWantDebug)
                    {
                        m_smVisionInfo.g_objLeadImage.SaveImage("D:\\TS\\2.g_objLeadImage.bmp");
                    }
                }
            }

            if (!blnFailPocketReference || m_smVisionInfo.AT_VM_OfflineTestAllLead)
            {
                // 2020-08-11 ZJYEOH : Only need Orient data to rotate when got package
                if (m_blnWantPackageTest)
                    WaitEventDone(ref m_blnOrientDataUpdated1, true, 10000, "AAA88");

                if (m_blnWantPackageTest && ((m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailMask & 0x1000) > 0 || m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetWantInspectPackage()))
                {
                    //2019-10-02 ZJYEOH : If Lead Image not same with Package, then use package gauge angle to rotate
                    WaitEventDone(ref m_bPackageSizePreTestDone1, true, 10000, "AAA89");

                    if (!m_bPackageSizePreTestResult1 && !m_smVisionInfo.AT_VM_OfflineTestAllLead)
                        return true; // No need to check lead anymore if package size fail

                    if (m_bPackageSizePreTestResult1)
                    {
                        float fTotalRotateAngle = m_intOrientAngle + m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle;
                        m_fLeadPatternAngle = m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle;
                        // Get RotateROI where the ROI center point == Unit Center Point
                        ROI objROI = new ROI();
                        objROI.LoadROISetting(m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIPositionX, m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIPositionY, m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIWidth, m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIHeight);
                        objROI.AttachImage(m_smVisionInfo.g_objLeadImage);
                        objROI.SetPosition_Center(m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X, m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y);

                        ROI.Rotate0Degree(objROI, fTotalRotateAngle, 4, ref m_smVisionInfo.g_objLeadImage);

                        if (m_smVisionInfo.g_pLeadDontCareRotateCenter == new Point(-1, -1))
                            m_smVisionInfo.g_pLeadDontCareRotateCenter = new Point(objROI.ref_ROITotalCenterX, objROI.ref_ROITotalCenterY);

                        m_smVisionInfo.g_arrLeadROIs[0][0].AttachImage(m_smVisionInfo.g_objLeadImage);

                        if (m_smVisionInfo.g_arrLead[0].ref_blnWantInspectBaseLead &&
                            ((m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo != m_smVisionInfo.g_arrLead[0].ref_intImageViewNo) &&
                            (!m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetWantInspectPackage() ||
                             (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo != m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetGrabImageIndex(2) &&
                              m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo != m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetGrabImageIndex(3)))))
                        {
                            objROI.AttachImage(m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo]);
                            ROI.Rotate0Degree(objROI, fTotalRotateAngle, 4, ref m_smVisionInfo.g_arrRotatedImages, m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo);

                            if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 0)
                                m_blnRotateImage1Updated = true;
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 1)
                                m_blnRotateImage2Updated = true;
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 2)
                                m_blnRotateImage3Updated = true;
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 3)
                                m_blnRotateImage4Updated = true;
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 4)
                                m_blnRotateImage5Updated = true;
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 5)
                                m_blnRotateImage6Updated = true;
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 6)
                                m_blnRotateImage7Updated = true;
                        }

                        m_smVisionInfo.g_arrLead[0].ref_fRotateCenterX_ForDrawing = objROI.ref_ROITotalCenterX;
                        m_smVisionInfo.g_arrLead[0].ref_fRotateCenterY_ForDrawing = objROI.ref_ROITotalCenterY;

                        objROI.Dispose();
                    }
                    else
                    {
                        m_smVisionInfo.g_arrLeadROIs[0][0].AttachImage(m_smVisionInfo.g_objLeadImage);
                    }

                    for (int i = 1; i < m_smVisionInfo.g_arrLead.Length; i++)
                    {
                        if (!m_smVisionInfo.g_arrLead[i].ref_blnSelected)
                            continue;

                        m_smVisionInfo.g_arrLeadROIs[i][0].AttachImage(m_smVisionInfo.g_objLeadImage);
                    }

                    //2020-07-23 ZJYEOH : In case not same image with package then need Copy To m_smVisionInfo.g_arrRotatedImages so that displayed image is rotated
                    if (!m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetWantInspectPackage() || ((m_smVisionInfo.g_arrLead[0].ref_intImageViewNo != m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetGrabImageIndex(2)
                        && m_smVisionInfo.g_arrLead[0].ref_intImageViewNo != m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetGrabImageIndex(3))))
                    {
                        //m_smVisionInfo.g_objLeadImage.CopyTo(m_smVisionInfo.g_arrRotatedImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo]);

                        float fTotalRotateAngle = m_intOrientAngle + m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle;
                        ROI objROI = new ROI();
                        objROI.LoadROISetting(m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIPositionX, m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIPositionY, m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIWidth, m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIHeight);
                        objROI.AttachImage(m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo]);
                        objROI.SetPosition_Center(m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X, m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y);

                        ROI.Rotate0Degree(objROI, fTotalRotateAngle, 4, ref m_smVisionInfo.g_arrRotatedImages, m_smVisionInfo.g_arrLead[0].ref_intImageViewNo);

                        objROI.Dispose();

                        if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 0)
                            m_blnRotateImage1Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 1)
                            m_blnRotateImage2Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 2)
                            m_blnRotateImage3Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 3)
                            m_blnRotateImage4Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 4)
                            m_blnRotateImage5Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 5)
                            m_blnRotateImage6Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 6)
                            m_blnRotateImage7Updated = true;

                    }

                    for (int j = 0; j < m_smVisionInfo.g_arrLead.Length; j++)
                    {
                        if (m_smVisionInfo.g_arrLead[j].ref_blnSelected)
                        {
                            if (m_smVisionInfo.g_arrLead[0].ref_blnWantUsePkgToBaseTolerance)
                                m_smVisionInfo.g_arrLead[j].AssignLineGaugeDataFromPackageGaugeM4L(m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X, m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y, m_smVisionInfo.g_objGauge_PkgSize.ref_fRectWidth, m_smVisionInfo.g_objGauge_PkgSize.ref_fRectHeight, m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle);
                        }
                    }
                }

                //m_smVisionInfo.g_objLeadImage.SaveImage("D:\\LeadImage2.bmp");

                if (m_blnWantPackageTest && ((m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailMask & 0x1000) == 0 && !m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetWantInspectPackage()) && (m_smVisionInfo.g_arrLead[0].ref_intRotationMethod == 2 || m_smVisionInfo.g_arrLead[0].ref_blnWantUsePkgToBaseTolerance))//&& m_smVisionInfo.g_arrLead[0].ref_blnWantUsePkgToBaseTolerance)
                {
                    if (m_smVisionInfo.g_objGauge_PkgSize == null)
                    {
                        m_smVisionInfo.g_objGauge_PkgSize = new RectGaugeM4L(m_smVisionInfo.g_WorldShape, 0, m_smVisionInfo.g_intVisionIndex);
                    }
                    m_smVisionInfo.g_arrPackageGaugeM4L[m_smVisionInfo.g_intSelectedUnit].CopyTo(ref m_smVisionInfo.g_objGauge_PkgSize);

                    bool blnResult = true;
                    blnResult = m_smVisionInfo.g_objGauge_PkgSize.Measure_WithDontCareArea(m_smVisionInfo.g_arrImages, m_smVisionInfo.g_objWhiteImage);

                    if (!blnResult)
                    {
                        m_bLeadBaseCenterPointDone = true;
                        m_bLeadBaseCenterPointResult = false;

                        if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                        {
                            WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_MarkTest 1");
                            if (!m_bSubTh_MarkTest_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_MarkLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_MarkLightView 1");
                            if (!m_bSubTh_PackageTest_MarkLightView_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_SideLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_SideLightView 1");
                            if (!m_bSubTh_PackageTest_SideLightView_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_TopLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_TopLightView 1");
                            if (!m_bSubTh_PackageTest_TopLightView_Result)
                            {
                                return false;
                            }
                        }

                        bWholeTestFail = true;
                        m_smVisionInfo.g_strErrorMessage = m_smVisionInfo.g_strErrorMessage + m_smVisionInfo.g_objGauge_PkgSize.ref_strErrorMessage;

                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 35 g_intPositionFailureTotal=" + m_smVisionInfo.g_intPositionFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                        if (blnAuto)
                        {
                            SaveRejectImage_AddToBuffer("EdgeNotFound", m_smVisionInfo.g_strErrorMessage);    // Should save then
                        }
                        if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                        {
                            //m_smVisionInfo.g_intPositionFailureTotal++;
                            m_smVisionInfo.g_intEdgeNotFoundFailureTotal++;
                            m_blnFailCounterAdded = true;
                            m_blnTotalCounterAdded = false;
                            //SaveRejectImage_AddToBuffer("Position", m_smVisionInfo.g_strErrorMessage);    // Should save then
                            if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 35a g_intPositionFailureTotal=" + m_smVisionInfo.g_intPositionFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                        }
                        blnFailPocketReference = true;
                        bWholeTestFail = true;
                    }
                    else
                    {
                        for (int j = 0; j < m_smVisionInfo.g_arrLead.Length; j++)
                        {
                            if (m_smVisionInfo.g_arrLead[j].ref_blnSelected)
                            {
                                if (m_smVisionInfo.g_arrLead[0].ref_blnWantUsePkgToBaseTolerance)
                                    m_smVisionInfo.g_arrLead[j].AssignLineGaugeDataFromPackageGaugeM4L(m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X, m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y, m_smVisionInfo.g_objGauge_PkgSize.ref_fRectWidth, m_smVisionInfo.g_objGauge_PkgSize.ref_fRectHeight, m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle);
                            }
                        }

                    }
                }
                else if (!m_blnWantPackageTest && m_smVisionInfo.g_arrLead[0].ref_intRotationMethod == 2)//&& m_smVisionInfo.g_arrLead[0].ref_blnWantUsePkgToBaseTolerance)
                {
                    if (m_smVisionInfo.g_objGauge_PkgSize == null)
                    {
                        m_smVisionInfo.g_objGauge_PkgSize = new RectGaugeM4L(m_smVisionInfo.g_WorldShape, 0, m_smVisionInfo.g_intVisionIndex);
                    }
                    m_smVisionInfo.g_arrPackageGaugeM4L[m_smVisionInfo.g_intSelectedUnit].CopyTo(ref m_smVisionInfo.g_objGauge_PkgSize);

                    //HiPerfTimer t1 = new HiPerfTimer();
                    //t1.Start();
                    //float fPrev = 0;
                    //string strT = "";
                    //float fTime;

                    bool blnResult = true;
                    blnResult = m_smVisionInfo.g_objGauge_PkgSize.Measure_WithDontCareArea(m_smVisionInfo.g_arrImages, m_smVisionInfo.g_arrLeadROIs[0][0], m_smVisionInfo.g_objWhiteImage);

                    //fTime = t1.Timing;
                    //strT += ", M=" + (fTime - fPrev).ToString("F4");
                    //t1.Stop();
                    //float fT = t1.Duration;

                    if (!blnResult)
                    {
                        m_bLeadBaseCenterPointDone = true;
                        m_bLeadBaseCenterPointResult = false;

                        if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                        {
                            WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_MarkTest 1");
                            if (!m_bSubTh_MarkTest_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_MarkLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_MarkLightView 1");
                            if (!m_bSubTh_PackageTest_MarkLightView_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_SideLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_SideLightView 1");
                            if (!m_bSubTh_PackageTest_SideLightView_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_TopLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_TopLightView 1");
                            if (!m_bSubTh_PackageTest_TopLightView_Result)
                            {
                                return false;
                            }
                        }

                        bWholeTestFail = true;
                        m_smVisionInfo.g_strErrorMessage = m_smVisionInfo.g_strErrorMessage + m_smVisionInfo.g_objGauge_PkgSize.ref_strErrorMessage;

                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 35 g_intPositionFailureTotal=" + m_smVisionInfo.g_intPositionFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                        if (blnAuto)
                        {
                            SaveRejectImage_AddToBuffer("EdgeNotFound", m_smVisionInfo.g_strErrorMessage);    // Should save then
                        }
                        if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                        {
                            //m_smVisionInfo.g_intPositionFailureTotal++;
                            m_smVisionInfo.g_intEdgeNotFoundFailureTotal++;
                            m_blnFailCounterAdded = true;
                            m_blnTotalCounterAdded = false;
                            //SaveRejectImage_AddToBuffer("Position", m_smVisionInfo.g_strErrorMessage);    // Should save then
                            if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 35a g_intPositionFailureTotal=" + m_smVisionInfo.g_intPositionFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                        }
                        blnFailPocketReference = true;
                        bWholeTestFail = true;
                    }
                    else
                    {
                        for (int j = 0; j < m_smVisionInfo.g_arrLead.Length; j++)
                        {
                            if (m_smVisionInfo.g_arrLead[j].ref_blnSelected)
                            {
                                if (m_smVisionInfo.g_arrLead[0].ref_blnWantUsePkgToBaseTolerance)
                                    m_smVisionInfo.g_arrLead[j].AssignLineGaugeDataFromPackageGaugeM4L(m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X, m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y, m_smVisionInfo.g_objGauge_PkgSize.ref_fRectWidth, m_smVisionInfo.g_objGauge_PkgSize.ref_fRectHeight, m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle);
                            }
                        }

                    }
                }
            }

            float fTotalX = 0, fTotalY = 0;
            int intCount = 0;
            // Reset each arrLead[] inspection data
            // find unit usign Partition Unit PR 
            // Record match angle using the highest score of partition Unit PR
            // Total up the match partition unit PR center point.
            if (!blnFailPocketReference || m_smVisionInfo.AT_VM_OfflineTestAllLead)
            {
                //HiPerfTimer t1 = new HiPerfTimer();
                //t1.Start();
                //float fPrev = 0;
                //string strT = "";
                //float fTime;
                // Loop Lead Test From Up, Right, Down to Left
                for (int i = 0; i < m_smVisionInfo.g_arrLead.Length; i++)
                {
                    if (i == 0)
                        m_smVisionInfo.g_arrLead[i].ResetInspectionData();

                    if (!m_smVisionInfo.g_arrLead[i].ref_blnSelected)
                        continue;

                    m_smVisionInfo.g_arrLead[i].ref_blnLock = true;

                    // Reset previous inspection data
                    m_smVisionInfo.g_arrLead[i].ResetInspectionData();

                    // Identify Lead definition for displaying fail message
                    string strPosition = GetLeadDefinition(i);

                    //fTime = t1.Timing;
                    //strT += ", M=" + (fTime - fPrev).ToString("F4");
                    //fPrev = fTime;
                    bool blnRecordPatternAngle = true;
                    if (m_blnWantPackageTest && ((m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailMask & 0x1000) > 0 || m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetWantInspectPackage() || GetWantInspectPackageColor(m_smVisionInfo.g_intSelectedUnit)))
                        blnRecordPatternAngle = false;
                    //Find unit
                    if (!FindUnit(i, m_smVisionInfo.g_arrLead[i].ref_intLeadAngleTolerance, blnRecordPatternAngle))
                    {
                        if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                        {
                            m_bLeadBaseCenterPointDone = true;
                            m_bLeadBaseCenterPointResult = false;

                            WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_MarkTest 1");
                            if (!m_bSubTh_MarkTest_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_MarkLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_MarkLightView 1");
                            if (!m_bSubTh_PackageTest_MarkLightView_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_SideLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_SideLightView 1");
                            if (!m_bSubTh_PackageTest_SideLightView_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_TopLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_TopLightView 1");
                            if (!m_bSubTh_PackageTest_TopLightView_Result)
                            {
                                return false;
                            }
                        }

                        bWholeTestFail = true;
                        m_smVisionInfo.g_strErrorMessage = strPosition + m_smVisionInfo.g_strErrorMessage;

                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 35 g_intPositionFailureTotal=" + m_smVisionInfo.g_intPositionFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                        if (blnAuto)
                        {
                            SaveRejectImage_AddToBuffer("Lead", m_smVisionInfo.g_strErrorMessage);    // Should save then
                        }
                        if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                        {
                            //m_smVisionInfo.g_intPositionFailureTotal++;
                            m_smVisionInfo.g_intLeadFailureTotal++;
                            m_blnFailCounterAdded = true;
                            m_blnTotalCounterAdded = false;
                            //SaveRejectImage_AddToBuffer("Position", m_smVisionInfo.g_strErrorMessage);    // Should save then
                            if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 35a g_intPositionFailureTotal=" + m_smVisionInfo.g_intPositionFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                        }
                        if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                            break;
                    }
                    fTotalX += m_smVisionInfo.g_arrLead[i].GetResultCenterPoint_UnitMatcher().X;
                    fTotalY += m_smVisionInfo.g_arrLead[i].GetResultCenterPoint_UnitMatcher().Y;
                    intCount++;
                }
            }
            //t1.Stop();
            //float fT = t1.Duration;

            //t1.Start();
            // Attach g_arrLeadROIs[0][0] (whole unit search ROI ) to g_objLeadImage
            // Rotate g_arrLeadROIs[0][0] (whole unit search ROI ) to 0 deg based on highest score partition matcher angle.
            // Attach g_arrLeadROIs[i][0] (partition unit ROI) to 
            if (!bWholeTestFail || m_smVisionInfo.AT_VM_OfflineTestAllLead)
            {
                if ((!m_blnWantPackageTest || (m_blnWantPackageTest && ((m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailMask & 0x1000) == 0 && !m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetWantInspectPackage())))
                    && m_smVisionInfo.g_arrLead[0].ref_intRotationMethod == 0) // Unit PR
                {
                    m_smVisionInfo.g_arrLeadROIs[0][0].AttachImage(m_smVisionInfo.g_objLeadImage);

                    if (blnWantDebug)
                    {
                        m_smVisionInfo.g_objLeadImage.SaveImage("D:\\TS\\1.g_objLeadImage.bmp");
                    }
                    ROI.Rotate0Degree(m_smVisionInfo.g_arrLeadROIs[0][0], m_fLeadPatternAngle, 4, ref m_smVisionInfo.g_objLeadImage);

                    if (blnWantDebug)
                    {
                        m_smVisionInfo.g_objLeadImage.SaveImage("D:\\TS\\2.g_objLeadImage.bmp");
                    }

                    //m_smVisionInfo.g_arrLead[0].ref_fRotateCenterX_ForDrawing = m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROITotalCenterX;
                    //m_smVisionInfo.g_arrLead[0].ref_fRotateCenterY_ForDrawing = m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROITotalCenterY;

                    for (int i = 1; i < m_smVisionInfo.g_arrLead.Length; i++)
                    {
                        if (!m_smVisionInfo.g_arrLead[i].ref_blnSelected)
                            continue;

                        m_smVisionInfo.g_arrLeadROIs[i][0].AttachImage(m_smVisionInfo.g_objLeadImage);
                    }

                    // Get equal size of center point
                    float fSizeX, fSizeY;
                    fSizeX = m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIWidth - m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIWidth % 2; // why %2? To get "even" number
                    fSizeY = m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIHeight - m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIHeight % 2;
                    
                    ROI objROI = new ROI();
                    //objROI.LoadROISetting(m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIPositionX, m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIPositionY, m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIWidth, m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIHeight);
                    objROI.LoadROISetting((int)Math.Round(m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROITotalCenterX - fSizeX / 2, 0, MidpointRounding.AwayFromZero),
                            (int)Math.Round(m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROITotalCenterY - fSizeY / 2, 0, MidpointRounding.AwayFromZero),
                            (int)Math.Round(fSizeX, 0, MidpointRounding.AwayFromZero),
                            (int)Math.Round(fSizeY, 0, MidpointRounding.AwayFromZero));
                    
                        objROI.AttachImage(m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo]);

                        if (blnWantDebug)
                        {
                            m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo].SaveImage("D:\\TS\\3a.arrImage.bmp");
                            m_smVisionInfo.g_arrRotatedImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo].SaveImage("D:\\TS\\3b.arrRotatedImage.bmp");

                        }

                        ROI.Rotate0Degree(objROI, m_fLeadPatternAngle, 4, ref m_smVisionInfo.g_arrRotatedImages, m_smVisionInfo.g_arrLead[0].ref_intImageViewNo);

                    if (m_smVisionInfo.g_pLeadDontCareRotateCenter == new Point(-1, -1))
                        m_smVisionInfo.g_pLeadDontCareRotateCenter = new Point(objROI.ref_ROITotalCenterX, objROI.ref_ROITotalCenterY);

                    if (blnWantDebug)
                        {
                            m_smVisionInfo.g_arrRotatedImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo].SaveImage("D:\\TS\\3c.arrRotatedImage.bmp");
                            m_smVisionInfo.g_arrImages[0].SaveImage("D:\\TS\\4a.arrImage.bmp");
                        }

                        if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 0)
                            m_blnRotateImage1Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 1)
                            m_blnRotateImage2Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 2)
                            m_blnRotateImage3Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 3)
                            m_blnRotateImage4Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 4)
                            m_blnRotateImage5Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 5)
                            m_blnRotateImage6Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 6)
                            m_blnRotateImage7Updated = true;

                        //if (!m_blnWantPackageTest)
                        //{
                        //    objROI.AttachImage(m_smVisionInfo.g_arrImages[0]);
                        //    ROI.Rotate0Degree(objROI, m_fLeadPatternAngle, 4, ref m_smVisionInfo.g_arrRotatedImages, 0);
                        //}

                        if (blnWantDebug)
                        {
                            m_smVisionInfo.g_objLeadImage.SaveImage("D:\\TS\\5.g_objLeadImage.bmp");
                            m_smVisionInfo.g_arrRotatedImages[0].SaveImage("D:\\TS\\4b.arrRotatedImage0.bmp");
                        }

                        m_smVisionInfo.g_arrLead[0].ref_fRotateCenterX_ForDrawing = objROI.ref_ROITotalCenterX;
                        m_smVisionInfo.g_arrLead[0].ref_fRotateCenterY_ForDrawing = objROI.ref_ROITotalCenterY;
                   
                    if (m_smVisionInfo.g_arrLead[0].ref_blnWantInspectBaseLead && (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo != m_smVisionInfo.g_arrLead[0].ref_intImageViewNo))
                    {

                        objROI.AttachImage(m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo]);
                        ROI.Rotate0Degree(objROI, m_fLeadPatternAngle, 4, ref m_smVisionInfo.g_arrRotatedImages, m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo);
                        
                        if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 0)
                            m_blnRotateImage1Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 1)
                            m_blnRotateImage2Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 2)
                            m_blnRotateImage3Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 3)
                            m_blnRotateImage4Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 4)
                            m_blnRotateImage5Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 5)
                            m_blnRotateImage6Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 6)
                            m_blnRotateImage7Updated = true;

                    }

                    objROI.Dispose();

                    fTotalX = 0;
                    fTotalY = 0;
                    intCount = 0;

                    for (int i = 0; i < m_smVisionInfo.g_arrLead.Length; i++)
                    {
                        if (!m_smVisionInfo.g_arrLead[i].ref_blnSelected)
                            continue;

                        m_smVisionInfo.g_arrLead[i].ref_blnLock = true;

                        // Reset previous inspection data
                        m_smVisionInfo.g_arrLead[i].ResetInspectionData();

                        // Identify Lead definition for displaying fail message
                        string strPosition = GetLeadDefinition(i);

                        //fTime = t1.Timing;
                        //strT += ", M=" + (fTime - fPrev).ToString("F4");
                        //fPrev = fTime;

                        //Find unit
                        if (!FindUnit(i, 0, false))
                        {
                            if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                            {
                                m_bLeadBaseCenterPointDone = true;
                                m_bLeadBaseCenterPointResult = false;

                                WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_MarkTest 1");
                                if (!m_bSubTh_MarkTest_Result)
                                {
                                    return false;
                                }

                                WaitEventDone(ref m_bSubTh_PackageTest_MarkLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_MarkLightView 1");
                                if (!m_bSubTh_PackageTest_MarkLightView_Result)
                                {
                                    return false;
                                }

                                WaitEventDone(ref m_bSubTh_PackageTest_SideLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_SideLightView 1");
                                if (!m_bSubTh_PackageTest_SideLightView_Result)
                                {
                                    return false;
                                }

                                WaitEventDone(ref m_bSubTh_PackageTest_TopLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_TopLightView 1");
                                if (!m_bSubTh_PackageTest_TopLightView_Result)
                                {
                                    return false;
                                }
                            }

                            bWholeTestFail = true;
                            m_smVisionInfo.g_strErrorMessage = strPosition + m_smVisionInfo.g_strErrorMessage;

                            if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 35 g_intPositionFailureTotal=" + m_smVisionInfo.g_intPositionFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                            if (blnAuto)
                            {
                                SaveRejectImage_AddToBuffer("Lead", m_smVisionInfo.g_strErrorMessage);    // Should save then
                            }
                            if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                            {
                                //m_smVisionInfo.g_intPositionFailureTotal++;
                                m_smVisionInfo.g_intLeadFailureTotal++;
                                m_blnFailCounterAdded = true;
                                m_blnTotalCounterAdded = false;
                                //SaveRejectImage_AddToBuffer("Position", m_smVisionInfo.g_strErrorMessage);    // Should save then
                                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 35a g_intPositionFailureTotal=" + m_smVisionInfo.g_intPositionFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                            }
                            if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                                break;
                        }
                        fTotalX += m_smVisionInfo.g_arrLead[i].GetResultCenterPoint_UnitMatcher().X;
                        fTotalY += m_smVisionInfo.g_arrLead[i].GetResultCenterPoint_UnitMatcher().Y;
                        intCount++;
                    }
                    //m_smVisionInfo.g_objLeadImage.SaveImage("D:\\objImg.bmp");
                    //m_smVisionInfo.g_arrRotatedImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo].SaveImage("D:\\objImg2.bmp");
                }
                else if ((!m_blnWantPackageTest || (m_blnWantPackageTest && ((m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailMask & 0x1000) == 0 && !m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetWantInspectPackage())))
                          && m_smVisionInfo.g_arrLead[0].ref_intRotationMethod == 1) //Base Line
                {
                    List<Line> arrBaseLine = new List<Line>();
                    for (int i = 0; i < m_smVisionInfo.g_arrLead.Length; i++)
                    {
                        if (!m_smVisionInfo.g_arrLead[i].ref_blnSelected)
                            continue;
                        
                        m_smVisionInfo.g_arrLead[i].ref_blnViewLeadResultDrawing = true;

                        if (IsLeadOK_ForBaseLineRotation(i))
                        {
                            // 2020 08 14 - CCENG: cannot add line to arrBaseLine if cannot find the reference point. Bcos the arrBaseLine will be used to calculate unit angle. 
                            if (m_smVisionInfo.g_arrLead[i].ref_fSampleReferencePointStartX != -999 && m_smVisionInfo.g_arrLead[i].ref_fSampleReferencePointStartY != -999 &&
                                m_smVisionInfo.g_arrLead[i].ref_fSampleReferencePointEndX != -999 && m_smVisionInfo.g_arrLead[i].ref_fSampleReferencePointEndY != -999)
                            {
                                Line objLine = new Line();
                                objLine.CalculateStraightLine(new PointF(m_smVisionInfo.g_arrLead[i].ref_fSampleReferencePointStartX, m_smVisionInfo.g_arrLead[i].ref_fSampleReferencePointStartY),
                                    new PointF(m_smVisionInfo.g_arrLead[i].ref_fSampleReferencePointEndX, m_smVisionInfo.g_arrLead[i].ref_fSampleReferencePointEndY));
                                arrBaseLine.Add(objLine);
                            }
                        }
                    }

                    if (arrBaseLine.Count > 0)
                    {
                        m_smVisionInfo.g_arrLeadROIs[0][0].AttachImage(m_smVisionInfo.g_objLeadImage);

                        float fAngle = 0;
                        for (int j = 0; j< arrBaseLine.Count;j++)
                        {
                            float angle = (float)arrBaseLine[j].ref_dAngle;
                            if(angle >= 90)
                            {
                                angle -= 90;
                            }
                            else if (angle < 90 && angle > 45)
                            {
                                angle -= 90;
                            }
                            else if (angle <= -90 )
                            {
                                angle += 90;
                            }
                            else if (angle > -90 && angle < -45)
                            {
                                angle += 90;
                            }

                            fAngle += angle;
                        }
                        fAngle /= arrBaseLine.Count;

                        //2021-05-26 ZJYEOH : Need update m_fLeadPatternAngle with Base Line Angle
                        m_fLeadPatternAngle = fAngle;
                      
                        ROI.Rotate0Degree(m_smVisionInfo.g_arrLeadROIs[0][0], fAngle, 4, ref m_smVisionInfo.g_objLeadImage);
                        //m_smVisionInfo.g_objLeadImage.SaveImage("D:\\LeadImg.bmp");
                        for (int i = 1; i < m_smVisionInfo.g_arrLead.Length; i++)
                        {
                            if (!m_smVisionInfo.g_arrLead[i].ref_blnSelected)
                                continue;

                            m_smVisionInfo.g_arrLeadROIs[i][0].AttachImage(m_smVisionInfo.g_objLeadImage);
                        }

                        ROI objROI = new ROI();
                        objROI.LoadROISetting(m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIPositionX, m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIPositionY, m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIWidth, m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIHeight);
                        
                            objROI.AttachImage(m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo]);

                            ROI.Rotate0Degree(objROI, fAngle, 4, ref m_smVisionInfo.g_arrRotatedImages, m_smVisionInfo.g_arrLead[0].ref_intImageViewNo);

                        if (m_smVisionInfo.g_pLeadDontCareRotateCenter == new Point(-1, -1))
                            m_smVisionInfo.g_pLeadDontCareRotateCenter = new Point(objROI.ref_ROITotalCenterX, objROI.ref_ROITotalCenterY);

                        if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 0)
                                m_blnRotateImage1Updated = true;
                            else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 1)
                                m_blnRotateImage2Updated = true;
                            else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 2)
                                m_blnRotateImage3Updated = true;
                            else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 3)
                                m_blnRotateImage4Updated = true;
                            else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 4)
                                m_blnRotateImage5Updated = true;
                            else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 5)
                                m_blnRotateImage6Updated = true;
                            else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 6)
                                m_blnRotateImage7Updated = true;

                            m_smVisionInfo.g_arrLead[0].ref_fRotateCenterX_ForDrawing = objROI.ref_ROITotalCenterX;
                            m_smVisionInfo.g_arrLead[0].ref_fRotateCenterY_ForDrawing = objROI.ref_ROITotalCenterY;
                        
                        if (m_smVisionInfo.g_arrLead[0].ref_blnWantInspectBaseLead && (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo != m_smVisionInfo.g_arrLead[0].ref_intImageViewNo))
                        {

                            objROI.AttachImage(m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo]);
                            ROI.Rotate0Degree(objROI, fAngle, 4, ref m_smVisionInfo.g_arrRotatedImages, m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo);

                            if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 0)
                                m_blnRotateImage1Updated = true;
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 1)
                                m_blnRotateImage2Updated = true;
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 2)
                                m_blnRotateImage3Updated = true;
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 3)
                                m_blnRotateImage4Updated = true;
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 4)
                                m_blnRotateImage5Updated = true;
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 5)
                                m_blnRotateImage6Updated = true;
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 6)
                                m_blnRotateImage7Updated = true;

                        }

                        objROI.Dispose();

                    }
                    //m_smVisionInfo.g_objLeadImage.SaveImage("D:\\objImg.bmp");
                    //m_smVisionInfo.g_arrRotatedImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo].SaveImage("D:\\objImg2.bmp");

                    fTotalX = 0;
                    fTotalY = 0;
                    intCount = 0;

                    for (int i = 0; i < m_smVisionInfo.g_arrLead.Length; i++)
                    {
                        if (!m_smVisionInfo.g_arrLead[i].ref_blnSelected)
                            continue;

                        m_smVisionInfo.g_arrLead[i].ref_blnLock = true;

                        // Reset previous inspection data
                        m_smVisionInfo.g_arrLead[i].ResetInspectionData();

                        // Identify Lead definition for displaying fail message
                        string strPosition = GetLeadDefinition(i);

                        //fTime = t1.Timing;
                        //strT += ", M=" + (fTime - fPrev).ToString("F4");
                        //fPrev = fTime;

                        //Find unit
                        if (!FindUnit(i, 0, false))//2021-05-26 ZJYEOH : changed true to false, because no need record pattern angle as now pattern angle sure 0
                        {
                            if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                            {
                                m_bLeadBaseCenterPointDone = true;
                                m_bLeadBaseCenterPointResult = false;

                                WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_MarkTest 1");
                                if (!m_bSubTh_MarkTest_Result)
                                {
                                    return false;
                                }

                                WaitEventDone(ref m_bSubTh_PackageTest_MarkLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_MarkLightView 1");
                                if (!m_bSubTh_PackageTest_MarkLightView_Result)
                                {
                                    return false;
                                }

                                WaitEventDone(ref m_bSubTh_PackageTest_SideLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_SideLightView 1");
                                if (!m_bSubTh_PackageTest_SideLightView_Result)
                                {
                                    return false;
                                }

                                WaitEventDone(ref m_bSubTh_PackageTest_TopLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_TopLightView 1");
                                if (!m_bSubTh_PackageTest_TopLightView_Result)
                                {
                                    return false;
                                }
                            }

                            bWholeTestFail = true;
                            m_smVisionInfo.g_strErrorMessage = strPosition + m_smVisionInfo.g_strErrorMessage;

                            if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 35 g_intPositionFailureTotal=" + m_smVisionInfo.g_intPositionFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                            if (blnAuto)
                            {
                                SaveRejectImage_AddToBuffer("Position", m_smVisionInfo.g_strErrorMessage);    // Should save then
                            }
                            if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                            {
                                //m_smVisionInfo.g_intPositionFailureTotal++;
                                m_smVisionInfo.g_intLeadFailureTotal++;
                                m_blnFailCounterAdded = true;
                                m_blnTotalCounterAdded = false;
                                //SaveRejectImage_AddToBuffer("Position", m_smVisionInfo.g_strErrorMessage);    // Should save then
                                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 35a g_intPositionFailureTotal=" + m_smVisionInfo.g_intPositionFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                            }
                            if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                                break;
                        }
                        fTotalX += m_smVisionInfo.g_arrLead[i].GetResultCenterPoint_UnitMatcher().X;
                        fTotalY += m_smVisionInfo.g_arrLead[i].GetResultCenterPoint_UnitMatcher().Y;
                        intCount++;
                    }
                }
                else if ((!m_blnWantPackageTest || (m_blnWantPackageTest && ((m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailMask & 0x1000) == 0 && !m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetWantInspectPackage())))
                          &&/*!m_blnWantPackageTest && */(m_smVisionInfo.g_arrLead[0].ref_intRotationMethod == 2 || m_smVisionInfo.g_arrLead[0].ref_blnWantUsePkgToBaseTolerance)) // Gauge
                {
                    m_smVisionInfo.g_arrLeadROIs[0][0].AttachImage(m_smVisionInfo.g_objLeadImage);

                    //HiPerfTimer t1 = new HiPerfTimer();
                    //t1.Start();
                    //float fPrev = 0;
                    //string strT = "";
                    //float fTime;

                    //2021-05-26 ZJYEOH : Need update m_fLeadPatternAngle with m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle
                    m_fLeadPatternAngle = m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle;

                    ROI.Rotate0Degree(m_smVisionInfo.g_arrLeadROIs[0][0], m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle, 4, ref m_smVisionInfo.g_objLeadImage);

                    //fTime = t1.Timing;
                    //strT += ", M=" + (fTime - fPrev).ToString("F4");
                    //t1.Stop();
                    //float fT = t1.Duration;

                    for (int i = 1; i < m_smVisionInfo.g_arrLead.Length; i++)
                    {
                        if (!m_smVisionInfo.g_arrLead[i].ref_blnSelected)
                            continue;

                        m_smVisionInfo.g_arrLeadROIs[i][0].AttachImage(m_smVisionInfo.g_objLeadImage);
                    }

                    ROI objROI = new ROI();
                    objROI.LoadROISetting(m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIPositionX, m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIPositionY, m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIWidth, m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIHeight);
                    objROI.AttachImage(m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo]);

                        ROI.Rotate0Degree(objROI, m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle, 4, ref m_smVisionInfo.g_arrRotatedImages, m_smVisionInfo.g_arrLead[0].ref_intImageViewNo);

                    if (m_smVisionInfo.g_pLeadDontCareRotateCenter == new Point(-1, -1))
                        m_smVisionInfo.g_pLeadDontCareRotateCenter = new Point(objROI.ref_ROITotalCenterX, objROI.ref_ROITotalCenterY);

                    if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 0)
                            m_blnRotateImage1Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 1)
                            m_blnRotateImage2Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 2)
                            m_blnRotateImage3Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 3)
                            m_blnRotateImage4Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 4)
                            m_blnRotateImage5Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 5)
                            m_blnRotateImage6Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 6)
                            m_blnRotateImage7Updated = true;

                        m_smVisionInfo.g_arrLead[0].ref_fRotateCenterX_ForDrawing = objROI.ref_ROITotalCenterX;
                        m_smVisionInfo.g_arrLead[0].ref_fRotateCenterY_ForDrawing = objROI.ref_ROITotalCenterY;
                  
                    if (m_smVisionInfo.g_arrLead[0].ref_blnWantInspectBaseLead && (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo != m_smVisionInfo.g_arrLead[0].ref_intImageViewNo))
                    {

                        objROI.AttachImage(m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo]);
                        ROI.Rotate0Degree(objROI, m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle, 4, ref m_smVisionInfo.g_arrRotatedImages, m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo);

                        if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 0)
                            m_blnRotateImage1Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 1)
                            m_blnRotateImage2Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 2)
                            m_blnRotateImage3Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 3)
                            m_blnRotateImage4Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 4)
                            m_blnRotateImage5Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 5)
                            m_blnRotateImage6Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 6)
                            m_blnRotateImage7Updated = true;

                    }

                    objROI.Dispose();

                    fTotalX = 0;
                    fTotalY = 0;
                    intCount = 0;

                    for (int i = 0; i < m_smVisionInfo.g_arrLead.Length; i++)
                    {
                        if (!m_smVisionInfo.g_arrLead[i].ref_blnSelected)
                            continue;

                        m_smVisionInfo.g_arrLead[i].ref_blnLock = true;

                        // Reset previous inspection data
                        m_smVisionInfo.g_arrLead[i].ResetInspectionData();

                        // Identify Lead definition for displaying fail message
                        string strPosition = GetLeadDefinition(i);

                        //fTime = t1.Timing;
                        //strT += ", M=" + (fTime - fPrev).ToString("F4");
                        //fPrev = fTime;

                        //Find unit
                        if (!FindUnit(i, 0, false))//2021-05-26 ZJYEOH : changed true to false, because no need record pattern angle as now pattern angle sure 0
                        {
                            if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                            {
                                m_bLeadBaseCenterPointDone = true;
                                m_bLeadBaseCenterPointResult = false;

                                WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_MarkTest 1");
                                if (!m_bSubTh_MarkTest_Result)
                                {
                                    return false;
                                }

                                WaitEventDone(ref m_bSubTh_PackageTest_MarkLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_MarkLightView 1");
                                if (!m_bSubTh_PackageTest_MarkLightView_Result)
                                {
                                    return false;
                                }

                                WaitEventDone(ref m_bSubTh_PackageTest_SideLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_SideLightView 1");
                                if (!m_bSubTh_PackageTest_SideLightView_Result)
                                {
                                    return false;
                                }

                                WaitEventDone(ref m_bSubTh_PackageTest_TopLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_TopLightView 1");
                                if (!m_bSubTh_PackageTest_TopLightView_Result)
                                {
                                    return false;
                                }
                            }

                            bWholeTestFail = true;
                            m_smVisionInfo.g_strErrorMessage = strPosition + m_smVisionInfo.g_strErrorMessage;

                            if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 35 g_intPositionFailureTotal=" + m_smVisionInfo.g_intPositionFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                            if (blnAuto)
                            {
                                SaveRejectImage_AddToBuffer("Position", m_smVisionInfo.g_strErrorMessage);    // Should save then
                            }
                            if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                            {
                                //m_smVisionInfo.g_intPositionFailureTotal++;
                                m_smVisionInfo.g_intLeadFailureTotal++;
                                m_blnFailCounterAdded = true;
                                m_blnTotalCounterAdded = false;
                                //SaveRejectImage_AddToBuffer("Position", m_smVisionInfo.g_strErrorMessage);    // Should save then
                                if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 35a g_intPositionFailureTotal=" + m_smVisionInfo.g_intPositionFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                            }
                            if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                                break;
                        }
                        fTotalX += m_smVisionInfo.g_arrLead[i].GetResultCenterPoint_UnitMatcher().X;
                        fTotalY += m_smVisionInfo.g_arrLead[i].GetResultCenterPoint_UnitMatcher().Y;
                        intCount++;
                    }
                    //m_smVisionInfo.g_objLeadImage.SaveImage("D:\\objImg.bmp");
                    //m_smVisionInfo.g_arrRotatedImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo].SaveImage("D:\\objImg2.bmp");
                }

                m_smVisionInfo.g_fPreciseAngle = m_intOrientAngle - m_fLeadPatternAngle;

                if (!bWholeTestFail || m_smVisionInfo.AT_VM_OfflineTestAllLead)
                {
                    m_smVisionInfo.g_intSelectedLeadExtraBlobID = 0;
                    int Count = 0;
                    // Loop Lead Test From Up, Right, Down to Left
                    for (int i = 0; i < m_smVisionInfo.g_arrLead.Length; i++)
                    {
                        if (!m_smVisionInfo.g_arrLead[i].ref_blnSelected)
                            continue;

                        m_smVisionInfo.g_arrLead[i].ref_intExtraBlobID = Count;

                        m_smVisionInfo.g_arrLead[i].ref_blnViewLeadResultDrawing = true;

                        // Identify Lead definition for displaying fail message
                        string strPosition = GetLeadDefinition(i);

                        m_smVisionInfo.g_arrLead[i].ref_fUnitAverageCenterX = fTotalX / intCount;
                        m_smVisionInfo.g_arrLead[i].ref_fUnitAverageCenterY = fTotalY / intCount;
                        int intFailType = 0;
                        if (!IsLeadOK(i, ref intFailType))
                        {
                            if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                            {
                                m_bLeadBaseCenterPointDone = true;
                                m_bLeadBaseCenterPointResult = false;

                                WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_MarkTest 1");
                                if (!m_bSubTh_MarkTest_Result)
                                {
                                    return false;
                                }

                                WaitEventDone(ref m_bSubTh_PackageTest_MarkLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_MarkLightView 1");
                                if (!m_bSubTh_PackageTest_MarkLightView_Result)
                                {
                                    return false;
                                }

                                WaitEventDone(ref m_bSubTh_PackageTest_SideLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_SideLightView 1");
                                if (!m_bSubTh_PackageTest_SideLightView_Result)
                                {
                                    return false;
                                }

                                WaitEventDone(ref m_bSubTh_PackageTest_TopLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_TopLightView 1");
                                if (!m_bSubTh_PackageTest_TopLightView_Result)
                                {
                                    return false;
                                }
                            }

                            bWholeTestFail = true;
                            if (blnAuto)
                            {
                                if ((intFailType & 0x01) > 0)
                                    SaveRejectImage_AddToBuffer("Lead", m_smVisionInfo.g_arrLead[i].GetLeadFailTestDisplayResult(strPosition));
                                else if(m_smVisionInfo.g_arrLead[i].ref_blnWantInspectBaseLead)
                                    SaveRejectImage_AddToBuffer("Lead", m_smVisionInfo.g_arrLead[i].GetLeadFailTestDisplayResult_BaseLead(strPosition));
                            }
                            if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                            {
                                m_smVisionInfo.g_intLeadFailureTotal++;
                                m_blnFailCounterAdded = true;
                                m_blnTotalCounterAdded = false;
                                //SaveRejectImage_AddToBuffer("Lead", m_smVisionInfo.g_arrLead[i].GetLeadFailTestDisplayResult(strPosition));
                            }

                            m_smVisionInfo.g_strErrorMessage += m_smVisionInfo.g_arrLead[i].GetLeadFailTestDisplayResult(strPosition);
                            if (m_smVisionInfo.g_arrLead[0].ref_blnWantInspectBaseLead)
                            {
                                m_smVisionInfo.g_strErrorMessage += m_smVisionInfo.g_arrLead[i].GetLeadFailTestDisplayResult_BaseLead(strPosition);
                            }
                            if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                                break;
                        }
                        Count = m_smVisionInfo.g_arrLead[i].ref_intExtraBlobID;
                    }
                }
            }

            //if (!bWholeTestFail)
            //{
            //    if (m_smVisionInfo.g_arrLead[1].ref_blnSelected && m_smVisionInfo.g_arrLead[3].ref_blnSelected)
            //    {
            //    }
            //    else if (m_smVisionInfo.g_arrLead[2].ref_blnSelected && m_smVisionInfo.g_arrLead[4].ref_blnSelected)
            //    {
            //    }

            //    //m_smVisionInfo.g_arrLead[0].CalculateUnitCenterPointReferingToLeadBaseCenterX()
            //}

            m_bLeadBaseCenterPointResult = !bWholeTestFail;
            m_bLeadBaseCenterPointDone = true;

            // Check Length Variance
            if (!bWholeTestFail || m_smVisionInfo.AT_VM_OfflineTestAllLead)
            {
                if ((m_smVisionInfo.g_arrLead[0].ref_intFailOptionMask & 0x800) > 0)
                {
                    //Check Span only if 2 opposite lead is use
                    if (!IsUnitLengthVarianceOk())
                    {
                        if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                        {
                            WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_MarkTest 1");
                            if (!m_bSubTh_MarkTest_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_MarkLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_MarkLightView 1");
                            if (!m_bSubTh_PackageTest_MarkLightView_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_SideLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_SideLightView 1");
                            if (!m_bSubTh_PackageTest_SideLightView_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_TopLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_TopLightView 1");
                            if (!m_bSubTh_PackageTest_TopLightView_Result)
                            {
                                return false;
                            }
                        }

                        bWholeTestFail = true;

                        if (blnAuto)
                        {
                            SaveRejectImage_AddToBuffer("Lead", m_smVisionInfo.g_arrLead[0].GetUnitLengthVarianceFailTestDisplayResult());
                        }

                        if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                        {
                            m_smVisionInfo.g_intLeadFailureTotal++;
                            m_blnFailCounterAdded = true;
                            m_blnTotalCounterAdded = false;
                        }

                        m_smVisionInfo.g_strErrorMessage += m_smVisionInfo.g_arrLead[0].GetUnitLengthVarianceFailTestDisplayResult();
                    }
                }
            }

            //Check Lead Span here
            if (!bWholeTestFail || m_smVisionInfo.AT_VM_OfflineTestAllLead)
            {
                if ((m_smVisionInfo.g_arrLead[0].ref_intFailOptionMask & 0x1000) > 0)
                {
                    //Check Span only if 2 opposite lead is use
                    if (!IsUnitSpanOk())
                    {
                        if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                        {
                            WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_MarkTest 1");
                            if (!m_bSubTh_MarkTest_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_MarkLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_MarkLightView 1");
                            if (!m_bSubTh_PackageTest_MarkLightView_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_SideLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_SideLightView 1");
                            if (!m_bSubTh_PackageTest_SideLightView_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_TopLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_TopLightView 1");
                            if (!m_bSubTh_PackageTest_TopLightView_Result)
                            {
                                return false;
                            }
                        }

                        bWholeTestFail = true;
                        if (blnAuto)
                        {
                            SaveRejectImage_AddToBuffer("LeadSpan", m_smVisionInfo.g_arrLead[0].GetLeadSpanFailTestDisplayResult());
                        }
                        if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                        {
                            m_smVisionInfo.g_intLeadFailureTotal++;
                            m_blnFailCounterAdded = true;
                            m_blnTotalCounterAdded = false;
                            //SaveRejectImage_AddToBuffer("LeadSpan", m_smVisionInfo.g_arrLead[0].GetLeadSpanFailTestDisplayResult());
                        }

                        m_smVisionInfo.g_strErrorMessage += m_smVisionInfo.g_arrLead[0].GetLeadSpanFailTestDisplayResult("Unit ");
                    }
                }
            }


            if (m_smVisionInfo.g_intViewInspectionSetting == 0)
            {
                m_smVisionInfo.g_blnViewLeadInspection = true;
                //m_smVisionInfo.VM_AT_UpdateErrorMessage = true;   // 2020 10 23 - CCENG: Set this event after all inspection done, Do not set here bcos error msg will be displayed weird.
            }
            else
                m_smVisionInfo.g_strErrorMessage = "";

            m_smVisionInfo.g_blnLeadInspected = true;

            if (bWholeTestFail)
            {
                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        m_intTCPIPResultID = (int)TCPIPResulID.Fail;

                return false;
            }
            else
                return true;
        }
        private bool StartLeadTest_MultiThreading_WithoutRotate(bool blnAuto)
        {
            bool blnWantDebug = false;
            bool bWholeTestFail = false;
            m_fLeadPatternScore = 0;
            m_fLeadPatternAngle = 0;
            if ((m_smCustomizeInfo.g_intWantLead & (1 << m_smVisionInfo.g_intVisionPos)) == 0 || !m_smVisionInfo.g_arrLead[0].GetWantInspectLead())//!m_smVisionInfo.g_blnCheckLead
                return true;
            if (m_smVisionInfo.g_arrLeadROIs[0].Count == 0)
            {
                m_bLeadBaseCenterPointDone = true;
                m_bLeadBaseCenterPointResult = false;

                if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                {
                    WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_MarkTest 1");
                    if (!m_bSubTh_MarkTest_Result)
                    {
                        return false;
                    }

                    WaitEventDone(ref m_bSubTh_PackageTest_MarkLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_MarkLightView 1");
                    if (!m_bSubTh_PackageTest_MarkLightView_Result)
                    {
                        return false;
                    }

                    WaitEventDone(ref m_bSubTh_PackageTest_SideLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_SideLightView 1");
                    if (!m_bSubTh_PackageTest_SideLightView_Result)
                    {
                        return false;
                    }

                    WaitEventDone(ref m_bSubTh_PackageTest_TopLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_TopLightView 1");
                    if (!m_bSubTh_PackageTest_TopLightView_Result)
                    {
                        return false;
                    }
                }

                m_smVisionInfo.g_strErrorMessage += "*Lead : No Template Found";
                if (m_blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                {
                    m_smVisionInfo.g_intNoTemplateFailureTotal++;
                    m_blnFailCounterAdded = true;
                    m_blnTotalCounterAdded = false;

                }
                if (blnAuto)
                {
                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        if (m_intTCPIPResultID == -1)
                            m_intTCPIPResultID = (int)TCPIPResulID.Fail;
                }
                return false;
            }
            // Reset inspection drawing
            for (int i = 0; i < m_smVisionInfo.g_arrLead.Length; i++)
            {
                m_smVisionInfo.g_arrLead[i].ref_blnViewLeadResultDrawing = false;

                if (!m_smVisionInfo.g_arrLead[i].ref_blnSelected)
                    continue;

                if ((m_smVisionInfo.g_arrLead[i].GetBlobsFeaturesNumber() == 0) || (m_smVisionInfo.g_arrLead[0].ref_blnWantInspectBaseLead && (m_smVisionInfo.g_arrLead[i].GetBlobsFeaturesNumber_BaseLead() == 0)))
                {
                    m_bLeadBaseCenterPointDone = true;
                    m_bLeadBaseCenterPointResult = false;

                    if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                    {
                        WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_MarkTest 1");
                        if (!m_bSubTh_MarkTest_Result)
                        {
                            return false;
                        }

                        WaitEventDone(ref m_bSubTh_PackageTest_MarkLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_MarkLightView 1");
                        if (!m_bSubTh_PackageTest_MarkLightView_Result)
                        {
                            return false;
                        }

                        WaitEventDone(ref m_bSubTh_PackageTest_SideLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_SideLightView 1");
                        if (!m_bSubTh_PackageTest_SideLightView_Result)
                        {
                            return false;
                        }

                        WaitEventDone(ref m_bSubTh_PackageTest_TopLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_TopLightView 1");
                        if (!m_bSubTh_PackageTest_TopLightView_Result)
                        {
                            return false;
                        }
                    }

                    if (m_smVisionInfo.g_arrLead[0].ref_blnWantInspectBaseLead && (m_smVisionInfo.g_arrLead[i].GetBlobsFeaturesNumber_BaseLead() == 0))
                        m_smVisionInfo.g_strErrorMessage += "*Lead : Base Lead Template is Empty";
                    else
                        m_smVisionInfo.g_strErrorMessage += "*Lead : Lead Template is Empty";
                    if (m_blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                    {
                        m_smVisionInfo.g_intNoTemplateFailureTotal++;
                        m_blnFailCounterAdded = true;
                        m_blnTotalCounterAdded = false;

                    }
                    if (blnAuto)
                    {
                        if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                            if (m_intTCPIPResultID == -1)
                                m_intTCPIPResultID = (int)TCPIPResulID.Fail;
                    }
                    return false;
                }
            }
            //m_smVisionInfo.g_objLeadImage.SaveImage("D:\\LeadImage1.bmp");
            //m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo].CopyTo(ref m_smVisionInfo.g_objLeadImage);

            bool blnFailPocketReference = false;
            if (m_smVisionInfo.g_blnWantPocketDontCareAreaFix_Lead)
            {
                for (int i = 1; i < m_smVisionInfo.g_arrLead.Length; i++)
                {
                    string strPosition = GetLeadDefinition(i);

                    if ((i == 1) && ((m_smVisionInfo.g_intLeadPocketDontCareROIFixMask & 0x01) == 0))
                        continue;
                    else if ((i == 2) && ((m_smVisionInfo.g_intLeadPocketDontCareROIFixMask & 0x02) == 0))
                        continue;
                    else if ((i == 3) && ((m_smVisionInfo.g_intLeadPocketDontCareROIFixMask & 0x04) == 0))
                        continue;
                    else if ((i == 4) && ((m_smVisionInfo.g_intLeadPocketDontCareROIFixMask & 0x08) == 0))
                        continue;

                    if (!FindFixPocket(i))
                    {
                        if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                        {
                            m_bLeadBaseCenterPointDone = true;
                            m_bLeadBaseCenterPointResult = false;

                            WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_MarkTest 1");
                            if (!m_bSubTh_MarkTest_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_MarkLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_MarkLightView 1");
                            if (!m_bSubTh_PackageTest_MarkLightView_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_SideLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_SideLightView 1");
                            if (!m_bSubTh_PackageTest_SideLightView_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_TopLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_TopLightView 1");
                            if (!m_bSubTh_PackageTest_TopLightView_Result)
                            {
                                return false;
                            }
                        }

                        blnFailPocketReference = true;
                        bWholeTestFail = true;
                        m_smVisionInfo.g_strErrorMessage = strPosition + m_smVisionInfo.g_strErrorMessage;

                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 35 g_intPositionFailureTotal=" + m_smVisionInfo.g_intPositionFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                        if (blnAuto)
                        {
                            SaveRejectImage_AddToBuffer("Lead", m_smVisionInfo.g_strErrorMessage);    // Should save then
                        }
                        if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                        {
                            //m_smVisionInfo.g_intPositionFailureTotal++;
                            m_smVisionInfo.g_intLeadFailureTotal++;
                            m_blnFailCounterAdded = true;
                            m_blnTotalCounterAdded = false;
                            //SaveRejectImage_AddToBuffer("Position", m_smVisionInfo.g_strErrorMessage);    // Should save then
                            if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 35a g_intPositionFailureTotal=" + m_smVisionInfo.g_intPositionFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                        }
                        if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                            break;
                    }
                }
            }
            else if (m_smVisionInfo.g_blnWantPocketDontCareAreaManual_Lead)
            {
                for (int i = 1; i < m_smVisionInfo.g_arrLead.Length; i++)
                {
                    string strPosition = GetLeadDefinition(i);

                    if ((i == 1) && ((m_smVisionInfo.g_intLeadPocketDontCareROIManualMask & 0x01) == 0))
                        continue;
                    else if ((i == 2) && ((m_smVisionInfo.g_intLeadPocketDontCareROIManualMask & 0x02) == 0))
                        continue;
                    else if ((i == 3) && ((m_smVisionInfo.g_intLeadPocketDontCareROIManualMask & 0x04) == 0))
                        continue;
                    else if ((i == 4) && ((m_smVisionInfo.g_intLeadPocketDontCareROIManualMask & 0x08) == 0))
                        continue;

                    if (!FindManualPocketReference(i))
                    {
                        if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                        {
                            m_bLeadBaseCenterPointDone = true;
                            m_bLeadBaseCenterPointResult = false;

                            WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_MarkTest 1");
                            if (!m_bSubTh_MarkTest_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_MarkLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_MarkLightView 1");
                            if (!m_bSubTh_PackageTest_MarkLightView_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_SideLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_SideLightView 1");
                            if (!m_bSubTh_PackageTest_SideLightView_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_TopLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_TopLightView 1");
                            if (!m_bSubTh_PackageTest_TopLightView_Result)
                            {
                                return false;
                            }
                        }

                        blnFailPocketReference = true;
                        bWholeTestFail = true;
                        m_smVisionInfo.g_strErrorMessage = strPosition + m_smVisionInfo.g_strErrorMessage;

                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 35 g_intPositionFailureTotal=" + m_smVisionInfo.g_intPositionFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                        if (blnAuto)
                        {
                            SaveRejectImage_AddToBuffer("Lead", m_smVisionInfo.g_strErrorMessage);    // Should save then
                        }
                        if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                        {
                            //m_smVisionInfo.g_intPositionFailureTotal++;
                            m_smVisionInfo.g_intLeadFailureTotal++;
                            m_blnFailCounterAdded = true;
                            m_blnTotalCounterAdded = false;
                            //SaveRejectImage_AddToBuffer("Position", m_smVisionInfo.g_strErrorMessage);    // Should save then
                            if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 35a g_intPositionFailureTotal=" + m_smVisionInfo.g_intPositionFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                        }
                        if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                            break;
                    }
                }
            }
            else if (m_smVisionInfo.g_blnWantPocketDontCareAreaAuto_Lead)
            {
                if (blnWantDebug)
                {
                    m_smVisionInfo.g_objLeadImage.SaveImage("D:\\TS\\1.g_objLeadImage.bmp");
                }
                ImageDrawing objImg = new ImageDrawing(true);
                m_smVisionInfo.g_objLeadImage.CopyTo(objImg);
                for (int i = 1; i < m_smVisionInfo.g_arrLead.Length; i++)
                {
                    string strPosition = GetLeadDefinition(i);

                    if ((i == 1) && ((m_smVisionInfo.g_intLeadPocketDontCareROIAutoMask & 0x01) == 0))
                        continue;
                    else if ((i == 2) && ((m_smVisionInfo.g_intLeadPocketDontCareROIAutoMask & 0x02) == 0))
                        continue;
                    else if ((i == 3) && ((m_smVisionInfo.g_intLeadPocketDontCareROIAutoMask & 0x04) == 0))
                        continue;
                    else if ((i == 4) && ((m_smVisionInfo.g_intLeadPocketDontCareROIAutoMask & 0x08) == 0))
                        continue;

                    if (!FindAutoPocketReference(i, objImg))
                    {
                        if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                        {
                            m_bLeadBaseCenterPointDone = true;
                            m_bLeadBaseCenterPointResult = false;

                            WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_MarkTest 1");
                            if (!m_bSubTh_MarkTest_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_MarkLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_MarkLightView 1");
                            if (!m_bSubTh_PackageTest_MarkLightView_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_SideLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_SideLightView 1");
                            if (!m_bSubTh_PackageTest_SideLightView_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_TopLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_TopLightView 1");
                            if (!m_bSubTh_PackageTest_TopLightView_Result)
                            {
                                return false;
                            }
                        }

                        blnFailPocketReference = true;
                        bWholeTestFail = true;
                        m_smVisionInfo.g_strErrorMessage = strPosition + m_smVisionInfo.g_strErrorMessage;

                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 35 g_intPositionFailureTotal=" + m_smVisionInfo.g_intPositionFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                        if (blnAuto)
                        {
                            SaveRejectImage_AddToBuffer("Lead", m_smVisionInfo.g_strErrorMessage);    // Should save then
                        }
                        if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                        {
                            //m_smVisionInfo.g_intPositionFailureTotal++;
                            m_smVisionInfo.g_intLeadFailureTotal++;
                            m_blnFailCounterAdded = true;
                            m_blnTotalCounterAdded = false;
                            //SaveRejectImage_AddToBuffer("Position", m_smVisionInfo.g_strErrorMessage);    // Should save then
                            if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 35a g_intPositionFailureTotal=" + m_smVisionInfo.g_intPositionFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                        }
                        if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                            break;
                    }
                }
                objImg.Dispose();

                if (blnWantDebug)
                {
                    m_smVisionInfo.g_objLeadImage.SaveImage("D:\\TS\\2.g_objLeadImage.bmp");
                }
            }

            // 2020-08-11 ZJYEOH : Only need Orient data to rotate when got package
            if (m_blnWantPackageTest)
                WaitEventDone(ref m_blnOrientDataUpdated1, true, 10000, "AAA88");

            if (m_blnWantPackageTest && ((m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailMask & 0x1000) > 0 || m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetWantInspectPackage()))
            {
                //2019-10-02 ZJYEOH : If Lead Image not same with Package, then use package gauge angle to rotate
                WaitEventDone(ref m_bPackageSizePreTestDone1, true, 10000, "AAA89");

                if (!m_bPackageSizePreTestResult1 && !m_smVisionInfo.AT_VM_OfflineTestAllLead)
                    return true; // No need to check lead anymore if package size fail

                if (m_bPackageSizePreTestResult1)
                {
                    float fTotalRotateAngle = m_intOrientAngle + m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle;
                    m_fLeadPatternAngle = m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle;
                    //// Get RotateROI where the ROI center point == Unit Center Point
                    //ROI objROI = new ROI();
                    //objROI.LoadROISetting(m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIPositionX, m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIPositionY, m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIWidth, m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIHeight);
                    //objROI.AttachImage(m_smVisionInfo.g_objLeadImage);
                    //objROI.SetPosition_Center(m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X, m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y);

                    //ROI.Rotate0Degree(objROI, fTotalRotateAngle, 4, ref m_smVisionInfo.g_objLeadImage);

                    //m_smVisionInfo.g_arrLeadROIs[0][0].AttachImage(m_smVisionInfo.g_objLeadImage);

                    if (m_smVisionInfo.g_arrLead[0].ref_blnWantInspectBaseLead &&
                      ((m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo != m_smVisionInfo.g_arrLead[0].ref_intImageViewNo) &&
                      (!m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetWantInspectPackage() ||
                       (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo != m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetGrabImageIndex(2) &&
                        m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo != m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetGrabImageIndex(3)))))
                    {
                        //objROI.AttachImage(m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo]);
                        //ROI.Rotate0Degree(objROI, fTotalRotateAngle, 4, ref m_smVisionInfo.g_arrRotatedImages, m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo);

                        if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 0)
                            m_blnRotateImage1Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 1)
                            m_blnRotateImage2Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 2)
                            m_blnRotateImage3Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 3)
                            m_blnRotateImage4Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 4)
                            m_blnRotateImage5Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 5)
                            m_blnRotateImage6Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 6)
                            m_blnRotateImage7Updated = true;
                    }

                    m_smVisionInfo.g_arrLead[0].ref_fRotateCenterX_ForDrawing = m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X;
                    m_smVisionInfo.g_arrLead[0].ref_fRotateCenterY_ForDrawing = m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y;

                    //objROI.Dispose();
                }
                else
                {
                    m_smVisionInfo.g_arrLeadROIs[0][0].AttachImage(m_smVisionInfo.g_objLeadImage);
                }

                for (int i = 1; i < m_smVisionInfo.g_arrLead.Length; i++)
                {
                    if (!m_smVisionInfo.g_arrLead[i].ref_blnSelected)
                        continue;

                    m_smVisionInfo.g_arrLeadROIs[i][0].AttachImage(m_smVisionInfo.g_objLeadImage);
                }

                //2020-07-23 ZJYEOH : In case not same image with package then need Copy To m_smVisionInfo.g_arrRotatedImages so that displayed image is rotated
                if (!m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetWantInspectPackage() || ((m_smVisionInfo.g_arrLead[0].ref_intImageViewNo != m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetGrabImageIndex(2)
                    && m_smVisionInfo.g_arrLead[0].ref_intImageViewNo != m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetGrabImageIndex(3))))
                {
                    //m_smVisionInfo.g_objLeadImage.CopyTo(m_smVisionInfo.g_arrRotatedImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo]);

                    float fTotalRotateAngle = m_intOrientAngle + m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle;
                    //ROI objROI = new ROI();
                    //objROI.LoadROISetting(m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIPositionX, m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIPositionY, m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIWidth, m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIHeight);
                    //objROI.AttachImage(m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo]);
                    //objROI.SetPosition_Center(m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X, m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y);

                    //ROI.Rotate0Degree(objROI, fTotalRotateAngle, 4, ref m_smVisionInfo.g_arrRotatedImages, m_smVisionInfo.g_arrLead[0].ref_intImageViewNo);

                    //objROI.Dispose();

                    if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 0)
                        m_blnRotateImage1Updated = true;
                    else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 1)
                        m_blnRotateImage2Updated = true;
                    else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 2)
                        m_blnRotateImage3Updated = true;
                    else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 3)
                        m_blnRotateImage4Updated = true;
                    else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 4)
                        m_blnRotateImage5Updated = true;
                    else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 5)
                        m_blnRotateImage6Updated = true;
                    else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 6)
                        m_blnRotateImage7Updated = true;

                }

            }

            //m_smVisionInfo.g_objLeadImage.SaveImage("D:\\LeadImage2.bmp");

            if (m_blnWantPackageTest && ((m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailMask & 0x1000) == 0 && !m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetWantInspectPackage()) && m_smVisionInfo.g_arrLead[0].ref_intRotationMethod == 2)//&& m_smVisionInfo.g_arrLead[0].ref_blnWantUsePkgToBaseTolerance)
            {
                if (m_smVisionInfo.g_objGauge_PkgSize == null)
                {
                    m_smVisionInfo.g_objGauge_PkgSize = new RectGaugeM4L(m_smVisionInfo.g_WorldShape, 0, m_smVisionInfo.g_intVisionIndex);
                }
                m_smVisionInfo.g_arrPackageGaugeM4L[m_smVisionInfo.g_intSelectedUnit].CopyTo(ref m_smVisionInfo.g_objGauge_PkgSize);

                bool blnResult = true;
                blnResult = m_smVisionInfo.g_objGauge_PkgSize.Measure_WithDontCareArea(m_smVisionInfo.g_arrImages, m_smVisionInfo.g_objWhiteImage);

                if (!blnResult)
                {
                    m_bLeadBaseCenterPointDone = true;
                    m_bLeadBaseCenterPointResult = false;

                    if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                    {
                        WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_MarkTest 1");
                        if (!m_bSubTh_MarkTest_Result)
                        {
                            return false;
                        }

                        WaitEventDone(ref m_bSubTh_PackageTest_MarkLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_MarkLightView 1");
                        if (!m_bSubTh_PackageTest_MarkLightView_Result)
                        {
                            return false;
                        }

                        WaitEventDone(ref m_bSubTh_PackageTest_SideLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_SideLightView 1");
                        if (!m_bSubTh_PackageTest_SideLightView_Result)
                        {
                            return false;
                        }

                        WaitEventDone(ref m_bSubTh_PackageTest_TopLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_TopLightView 1");
                        if (!m_bSubTh_PackageTest_TopLightView_Result)
                        {
                            return false;
                        }
                    }

                    bWholeTestFail = true;
                    m_smVisionInfo.g_strErrorMessage = m_smVisionInfo.g_strErrorMessage + m_smVisionInfo.g_objGauge_PkgSize.ref_strErrorMessage;

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 35 g_intPositionFailureTotal=" + m_smVisionInfo.g_intPositionFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                    if (blnAuto)
                    {
                        SaveRejectImage_AddToBuffer("EdgeNotFound", m_smVisionInfo.g_strErrorMessage);    // Should save then
                    }
                    if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                    {
                        //m_smVisionInfo.g_intPositionFailureTotal++;
                        m_smVisionInfo.g_intEdgeNotFoundFailureTotal++;
                        m_blnFailCounterAdded = true;
                        m_blnTotalCounterAdded = false;
                        //SaveRejectImage_AddToBuffer("Position", m_smVisionInfo.g_strErrorMessage);    // Should save then
                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 35a g_intPositionFailureTotal=" + m_smVisionInfo.g_intPositionFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                    }
                    blnFailPocketReference = true;
                    bWholeTestFail = true;
                }
                else
                {
                    for (int j = 0; j < m_smVisionInfo.g_arrLead.Length; j++)
                    {
                        if (m_smVisionInfo.g_arrLead[j].ref_blnSelected)
                        {
                            if (m_smVisionInfo.g_arrLead[0].ref_blnWantUsePkgToBaseTolerance)
                                m_smVisionInfo.g_arrLead[j].AssignLineGaugeDataFromPackageGaugeM4L(m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X, m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y, m_smVisionInfo.g_objGauge_PkgSize.ref_fRectWidth, m_smVisionInfo.g_objGauge_PkgSize.ref_fRectHeight, m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle);
                        }
                    }

                }
            }
            else if (!m_blnWantPackageTest && m_smVisionInfo.g_arrLead[0].ref_intRotationMethod == 2)//&& m_smVisionInfo.g_arrLead[0].ref_blnWantUsePkgToBaseTolerance)
            {
                if (m_smVisionInfo.g_objGauge_PkgSize == null)
                {
                    m_smVisionInfo.g_objGauge_PkgSize = new RectGaugeM4L(m_smVisionInfo.g_WorldShape, 0, m_smVisionInfo.g_intVisionIndex);
                }
                m_smVisionInfo.g_arrPackageGaugeM4L[m_smVisionInfo.g_intSelectedUnit].CopyTo(ref m_smVisionInfo.g_objGauge_PkgSize);
                
                bool blnResult = true;
                blnResult = m_smVisionInfo.g_objGauge_PkgSize.Measure_WithDontCareArea(m_smVisionInfo.g_arrImages, m_smVisionInfo.g_arrLeadROIs[0][0], m_smVisionInfo.g_objWhiteImage);
                
                if (!blnResult)
                {
                    m_bLeadBaseCenterPointDone = true;
                    m_bLeadBaseCenterPointResult = false;

                    if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                    {
                        WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_MarkTest 1");
                        if (!m_bSubTh_MarkTest_Result)
                        {
                            return false;
                        }

                        WaitEventDone(ref m_bSubTh_PackageTest_MarkLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_MarkLightView 1");
                        if (!m_bSubTh_PackageTest_MarkLightView_Result)
                        {
                            return false;
                        }

                        WaitEventDone(ref m_bSubTh_PackageTest_SideLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_SideLightView 1");
                        if (!m_bSubTh_PackageTest_SideLightView_Result)
                        {
                            return false;
                        }

                        WaitEventDone(ref m_bSubTh_PackageTest_TopLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_TopLightView 1");
                        if (!m_bSubTh_PackageTest_TopLightView_Result)
                        {
                            return false;
                        }
                    }

                    bWholeTestFail = true;
                    m_smVisionInfo.g_strErrorMessage = m_smVisionInfo.g_strErrorMessage + m_smVisionInfo.g_objGauge_PkgSize.ref_strErrorMessage;

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 35 g_intPositionFailureTotal=" + m_smVisionInfo.g_intPositionFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                    if (blnAuto)
                    {
                        SaveRejectImage_AddToBuffer("EdgeNotFound", m_smVisionInfo.g_strErrorMessage);    // Should save then
                    }
                    if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                    {
                        //m_smVisionInfo.g_intPositionFailureTotal++;
                        m_smVisionInfo.g_intEdgeNotFoundFailureTotal++;
                        m_blnFailCounterAdded = true;
                        m_blnTotalCounterAdded = false;
                        //SaveRejectImage_AddToBuffer("Position", m_smVisionInfo.g_strErrorMessage);    // Should save then
                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 35a g_intPositionFailureTotal=" + m_smVisionInfo.g_intPositionFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                    }
                    blnFailPocketReference = true;
                    bWholeTestFail = true;
                }
                else
                {
                    for (int j = 0; j < m_smVisionInfo.g_arrLead.Length; j++)
                    {
                        if (m_smVisionInfo.g_arrLead[j].ref_blnSelected)
                        {
                            if (m_smVisionInfo.g_arrLead[0].ref_blnWantUsePkgToBaseTolerance)
                                m_smVisionInfo.g_arrLead[j].AssignLineGaugeDataFromPackageGaugeM4L(m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X, m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y, m_smVisionInfo.g_objGauge_PkgSize.ref_fRectWidth, m_smVisionInfo.g_objGauge_PkgSize.ref_fRectHeight, m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle);
                        }
                    }

                }
            }

            float fTotalX = 0, fTotalY = 0;
            int intCount = 0;
            // Reset each arrLead[] inspection data
            // find unit usign Partition Unit PR 
            // Record match angle using the highest score of partition Unit PR
            // Total up the match partition unit PR center point.
            if (!blnFailPocketReference || m_smVisionInfo.AT_VM_OfflineTestAllLead)
            {
                // Loop Lead Test From Up, Right, Down to Left
                for (int i = 0; i < m_smVisionInfo.g_arrLead.Length; i++)
                {
                    if (i == 0)
                        m_smVisionInfo.g_arrLead[i].ResetInspectionData();

                    if (!m_smVisionInfo.g_arrLead[i].ref_blnSelected)
                        continue;

                    m_smVisionInfo.g_arrLead[i].ref_blnLock = true;

                    // Reset previous inspection data
                    m_smVisionInfo.g_arrLead[i].ResetInspectionData();

                    // Identify Lead definition for displaying fail message
                    string strPosition = GetLeadDefinition(i);
                    bool blnRecordPatternAngle = true;
                    if (m_blnWantPackageTest && ((m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailMask & 0x1000) > 0 || m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetWantInspectPackage() || GetWantInspectPackageColor(m_smVisionInfo.g_intSelectedUnit)))
                        blnRecordPatternAngle = false;
                    //Find unit
                    if (!FindUnit(i, m_smVisionInfo.g_arrLead[i].ref_intLeadAngleTolerance, blnRecordPatternAngle))
                    {
                        if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                        {
                            m_bLeadBaseCenterPointDone = true;
                            m_bLeadBaseCenterPointResult = false;

                            WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_MarkTest 1");
                            if (!m_bSubTh_MarkTest_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_MarkLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_MarkLightView 1");
                            if (!m_bSubTh_PackageTest_MarkLightView_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_SideLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_SideLightView 1");
                            if (!m_bSubTh_PackageTest_SideLightView_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_TopLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_TopLightView 1");
                            if (!m_bSubTh_PackageTest_TopLightView_Result)
                            {
                                return false;
                            }
                        }

                        bWholeTestFail = true;
                        m_smVisionInfo.g_strErrorMessage = strPosition + m_smVisionInfo.g_strErrorMessage;

                        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 35 g_intPositionFailureTotal=" + m_smVisionInfo.g_intPositionFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                        if (blnAuto)
                        {
                            SaveRejectImage_AddToBuffer("Lead", m_smVisionInfo.g_strErrorMessage);    // Should save then
                        }
                        if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                        {
                            //m_smVisionInfo.g_intPositionFailureTotal++;
                            m_smVisionInfo.g_intLeadFailureTotal++;
                            m_blnFailCounterAdded = true;
                            m_blnTotalCounterAdded = false;
                            //SaveRejectImage_AddToBuffer("Position", m_smVisionInfo.g_strErrorMessage);    // Should save then
                            if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 35a g_intPositionFailureTotal=" + m_smVisionInfo.g_intPositionFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                        }
                        if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                            break;
                    }
                    fTotalX += m_smVisionInfo.g_arrLead[i].GetResultCenterPoint_UnitMatcher().X;
                    fTotalY += m_smVisionInfo.g_arrLead[i].GetResultCenterPoint_UnitMatcher().Y;
                    intCount++;
                }
            }
            
            // Attach g_arrLeadROIs[0][0] (whole unit search ROI ) to g_objLeadImage
            // Rotate g_arrLeadROIs[0][0] (whole unit search ROI ) to 0 deg based on highest score partition matcher angle.
            // Attach g_arrLeadROIs[i][0] (partition unit ROI) to 
            if (!bWholeTestFail || m_smVisionInfo.AT_VM_OfflineTestAllLead)
            {
                //fTotalX = 0;
                //fTotalY = 0;
                //intCount = 0;
                if ((!m_blnWantPackageTest || (m_blnWantPackageTest && ((m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailMask & 0x1000) == 0 && !m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetWantInspectPackage())))
                    && m_smVisionInfo.g_arrLead[0].ref_intRotationMethod == 0) // Unit PR
                {
                    m_smVisionInfo.g_arrLeadROIs[0][0].AttachImage(m_smVisionInfo.g_objLeadImage);

                    //if (blnWantDebug)
                    //{
                    //    m_smVisionInfo.g_objLeadImage.SaveImage("D:\\TS\\1.g_objLeadImage.bmp");
                    //}
                    //ROI.Rotate0Degree(m_smVisionInfo.g_arrLeadROIs[0][0], m_fLeadPatternAngle, 4, ref m_smVisionInfo.g_objLeadImage);

                    //if (blnWantDebug)
                    //{
                    //    m_smVisionInfo.g_objLeadImage.SaveImage("D:\\TS\\2.g_objLeadImage.bmp");
                    //}

                    ////m_smVisionInfo.g_arrLead[0].ref_fRotateCenterX_ForDrawing = m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROITotalCenterX;
                    ////m_smVisionInfo.g_arrLead[0].ref_fRotateCenterY_ForDrawing = m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROITotalCenterY;

                    for (int i = 1; i < m_smVisionInfo.g_arrLead.Length; i++)
                    {
                        if (!m_smVisionInfo.g_arrLead[i].ref_blnSelected)
                            continue;

                        m_smVisionInfo.g_arrLeadROIs[i][0].AttachImage(m_smVisionInfo.g_objLeadImage);
                    }

                    //// Get equal size of center point
                    //float fSizeX, fSizeY;
                    //fSizeX = m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIWidth - m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIWidth % 2; // why %2? To get "even" number
                    //fSizeY = m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIHeight - m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIHeight % 2;

                    //ROI objROI = new ROI();
                    ////objROI.LoadROISetting(m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIPositionX, m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIPositionY, m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIWidth, m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIHeight);
                    //objROI.LoadROISetting((int)Math.Round(m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROITotalCenterX - fSizeX / 2, 0, MidpointRounding.AwayFromZero),
                    //        (int)Math.Round(m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROITotalCenterY - fSizeY / 2, 0, MidpointRounding.AwayFromZero),
                    //        (int)Math.Round(fSizeX, 0, MidpointRounding.AwayFromZero),
                    //        (int)Math.Round(fSizeY, 0, MidpointRounding.AwayFromZero));
                    
                        //objROI.AttachImage(m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo]);

                        //if (blnWantDebug)
                        //{
                        //    m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo].SaveImage("D:\\TS\\3a.arrImage.bmp");
                        //    m_smVisionInfo.g_arrRotatedImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo].SaveImage("D:\\TS\\3b.arrRotatedImage.bmp");

                        //}

                        //ROI.Rotate0Degree(objROI, m_fLeadPatternAngle, 4, ref m_smVisionInfo.g_arrRotatedImages, m_smVisionInfo.g_arrLead[0].ref_intImageViewNo);

                        //if (blnWantDebug)
                        //{
                        //    m_smVisionInfo.g_arrRotatedImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo].SaveImage("D:\\TS\\3c.arrRotatedImage.bmp");
                        //    m_smVisionInfo.g_arrImages[0].SaveImage("D:\\TS\\4a.arrImage.bmp");
                        //}

                        //if (!m_blnWantPackageTest)
                        //{
                        //    objROI.AttachImage(m_smVisionInfo.g_arrImages[0]);
                        //    ROI.Rotate0Degree(objROI, m_fLeadPatternAngle, 4, ref m_smVisionInfo.g_arrRotatedImages, 0);
                        //}

                        //if (blnWantDebug)
                        //{
                        //    m_smVisionInfo.g_objLeadImage.SaveImage("D:\\TS\\5.g_objLeadImage.bmp");
                        //    m_smVisionInfo.g_arrRotatedImages[0].SaveImage("D:\\TS\\4b.arrRotatedImage0.bmp");
                        //}

                        if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 0)
                            m_blnRotateImage1Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 1)
                            m_blnRotateImage2Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 2)
                            m_blnRotateImage3Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 3)
                            m_blnRotateImage4Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 4)
                            m_blnRotateImage5Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 5)
                            m_blnRotateImage6Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 6)
                            m_blnRotateImage7Updated = true;

                        //m_smVisionInfo.g_arrLead[0].ref_fRotateCenterX_ForDrawing = objROI.ref_ROITotalCenterX;
                        //m_smVisionInfo.g_arrLead[0].ref_fRotateCenterY_ForDrawing = objROI.ref_ROITotalCenterY;

                        m_smVisionInfo.g_arrLead[0].ref_fRotateCenterX_ForDrawing = m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROITotalCenterX;
                        m_smVisionInfo.g_arrLead[0].ref_fRotateCenterY_ForDrawing = m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROITotalCenterY;
                  
                    if (m_smVisionInfo.g_arrLead[0].ref_blnWantInspectBaseLead && (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo != m_smVisionInfo.g_arrLead[0].ref_intImageViewNo))
                    {

                        //objROI.AttachImage(m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo]);
                        //ROI.Rotate0Degree(objROI, m_fLeadPatternAngle, 4, ref m_smVisionInfo.g_arrRotatedImages, m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo);

                        if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 0)
                            m_blnRotateImage1Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 1)
                            m_blnRotateImage2Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 2)
                            m_blnRotateImage3Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 3)
                            m_blnRotateImage4Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 4)
                            m_blnRotateImage5Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 5)
                            m_blnRotateImage6Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 6)
                            m_blnRotateImage7Updated = true;

                    }

                    //objROI.Dispose();

                    //for (int i = 0; i < m_smVisionInfo.g_arrLead.Length; i++)
                    //{
                    //    if (!m_smVisionInfo.g_arrLead[i].ref_blnSelected)
                    //        continue;

                    //    m_smVisionInfo.g_arrLead[i].ref_blnLock = true;

                    //    // Reset previous inspection data
                    //    m_smVisionInfo.g_arrLead[i].ResetInspectionData();

                    //    // Identify Lead definition for displaying fail message
                    //    string strPosition = GetLeadDefinition(i);

                    //    //fTime = t1.Timing;
                    //    //strT += ", M=" + (fTime - fPrev).ToString("F4");
                    //    //fPrev = fTime;

                    //    //Find unit
                    //    if (!FindUnit(i, 0, false))
                    //    {
                    //        bWholeTestFail = true;
                    //        m_smVisionInfo.g_strErrorMessage = strPosition + m_smVisionInfo.g_strErrorMessage;

                    //        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 35 g_intPositionFailureTotal=" + m_smVisionInfo.g_intPositionFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                    //        if (blnAuto)
                    //        {
                    //            SaveRejectImage_AddToBuffer("Lead", m_smVisionInfo.g_strErrorMessage);    // Should save then
                    //        }
                    //        if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                    //        {
                    //            //m_smVisionInfo.g_intPositionFailureTotal++;
                    //            m_smVisionInfo.g_intLeadFailureTotal++;
                    //            m_blnFailCounterAdded = true;
                    //            m_blnTotalCounterAdded = false;
                    //            //SaveRejectImage_AddToBuffer("Position", m_smVisionInfo.g_strErrorMessage);    // Should save then
                    //            if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 35a g_intPositionFailureTotal=" + m_smVisionInfo.g_intPositionFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                    //        }
                    //        if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                    //            break;
                    //    }
                    //    fTotalX += m_smVisionInfo.g_arrLead[i].GetResultCenterPoint_UnitMatcher().X;
                    //    fTotalY += m_smVisionInfo.g_arrLead[i].GetResultCenterPoint_UnitMatcher().Y;
                    //    intCount++;
                    //}
                    //m_smVisionInfo.g_objLeadImage.SaveImage("D:\\objImg.bmp");
                    //m_smVisionInfo.g_arrRotatedImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo].SaveImage("D:\\objImg2.bmp");
                }
                else if ((!m_blnWantPackageTest || (m_blnWantPackageTest && ((m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailMask & 0x1000) == 0 && !m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetWantInspectPackage())))
                          && m_smVisionInfo.g_arrLead[0].ref_intRotationMethod == 1) //Base Line
                {
                    List<Line> arrBaseLine = new List<Line>();
                    for (int i = 0; i < m_smVisionInfo.g_arrLead.Length; i++)
                    {
                        if (!m_smVisionInfo.g_arrLead[i].ref_blnSelected)
                            continue;

                        m_smVisionInfo.g_arrLead[i].ref_blnViewLeadResultDrawing = true;

                        if (IsLeadOK_ForBaseLineRotation(i))
                        {
                            // 2020 08 14 - CCENG: cannot add line to arrBaseLine if cannot find the reference point. Bcos the arrBaseLine will be used to calculate unit angle. 
                            if (m_smVisionInfo.g_arrLead[i].ref_fSampleReferencePointStartX != -999 && m_smVisionInfo.g_arrLead[i].ref_fSampleReferencePointStartY != -999 &&
                                m_smVisionInfo.g_arrLead[i].ref_fSampleReferencePointEndX != -999 && m_smVisionInfo.g_arrLead[i].ref_fSampleReferencePointEndY != -999)
                            {
                                Line objLine = new Line();
                                objLine.CalculateStraightLine(new PointF(m_smVisionInfo.g_arrLead[i].ref_fSampleReferencePointStartX, m_smVisionInfo.g_arrLead[i].ref_fSampleReferencePointStartY),
                                    new PointF(m_smVisionInfo.g_arrLead[i].ref_fSampleReferencePointEndX, m_smVisionInfo.g_arrLead[i].ref_fSampleReferencePointEndY));
                                arrBaseLine.Add(objLine);
                            }
                        }
                    }

                    if (arrBaseLine.Count > 0)
                    {
                        m_smVisionInfo.g_arrLeadROIs[0][0].AttachImage(m_smVisionInfo.g_objLeadImage);

                        float fAngle = 0;
                        for (int j = 0; j < arrBaseLine.Count; j++)
                        {
                            float angle = (float)arrBaseLine[j].ref_dAngle;
                            if (angle >= 90)
                            {
                                angle -= 90;
                            }
                            else if (angle < 90 && angle > 45)
                            {
                                angle -= 90;
                            }
                            else if (angle <= -90)
                            {
                                angle += 90;
                            }
                            else if (angle > -90 && angle < -45)
                            {
                                angle += 90;
                            }

                            fAngle += angle;
                        }
                        fAngle /= arrBaseLine.Count;

                        //2021-05-26 ZJYEOH : Need update m_fLeadPatternAngle with Base Line Angle
                        m_fLeadPatternAngle = fAngle;

                        //ROI.Rotate0Degree(m_smVisionInfo.g_arrLeadROIs[0][0], fAngle, 4, ref m_smVisionInfo.g_objLeadImage);
                        //m_smVisionInfo.g_objLeadImage.SaveImage("D:\\LeadImg.bmp");
                        for (int i = 1; i < m_smVisionInfo.g_arrLead.Length; i++)
                        {
                            if (!m_smVisionInfo.g_arrLead[i].ref_blnSelected)
                                continue;

                            m_smVisionInfo.g_arrLeadROIs[i][0].AttachImage(m_smVisionInfo.g_objLeadImage);
                        }

                        //ROI objROI = new ROI();
                        //objROI.LoadROISetting(m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIPositionX, m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIPositionY, m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIWidth, m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIHeight);
                        
                            //objROI.AttachImage(m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo]);

                            //ROI.Rotate0Degree(objROI, fAngle, 4, ref m_smVisionInfo.g_arrRotatedImages, m_smVisionInfo.g_arrLead[0].ref_intImageViewNo);

                            //m_smVisionInfo.g_arrLead[0].ref_fRotateCenterX_ForDrawing = objROI.ref_ROITotalCenterX;
                            //m_smVisionInfo.g_arrLead[0].ref_fRotateCenterY_ForDrawing = objROI.ref_ROITotalCenterY;

                            if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 0)
                                m_blnRotateImage1Updated = true;
                            else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 1)
                                m_blnRotateImage2Updated = true;
                            else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 2)
                                m_blnRotateImage3Updated = true;
                            else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 3)
                                m_blnRotateImage4Updated = true;
                            else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 4)
                                m_blnRotateImage5Updated = true;
                            else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 5)
                                m_blnRotateImage6Updated = true;
                            else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 6)
                                m_blnRotateImage7Updated = true;

                            m_smVisionInfo.g_arrLead[0].ref_fRotateCenterX_ForDrawing = m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROITotalCenterX;
                            m_smVisionInfo.g_arrLead[0].ref_fRotateCenterY_ForDrawing = m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROITotalCenterY;
                        
                        if (m_smVisionInfo.g_arrLead[0].ref_blnWantInspectBaseLead && (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo != m_smVisionInfo.g_arrLead[0].ref_intImageViewNo))
                        {

                            //objROI.AttachImage(m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo]);
                            //ROI.Rotate0Degree(objROI, fAngle, 4, ref m_smVisionInfo.g_arrRotatedImages, m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo);

                            if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 0)
                                m_blnRotateImage1Updated = true;
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 1)
                                m_blnRotateImage2Updated = true;
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 2)
                                m_blnRotateImage3Updated = true;
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 3)
                                m_blnRotateImage4Updated = true;
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 4)
                                m_blnRotateImage5Updated = true;
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 5)
                                m_blnRotateImage6Updated = true;
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 6)
                                m_blnRotateImage7Updated = true;

                        }

                        //objROI.Dispose();

                    }
                    //m_smVisionInfo.g_objLeadImage.SaveImage("D:\\objImg.bmp");
                    //m_smVisionInfo.g_arrRotatedImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo].SaveImage("D:\\objImg2.bmp");

                    //for (int i = 0; i < m_smVisionInfo.g_arrLead.Length; i++)
                    //{
                    //    if (!m_smVisionInfo.g_arrLead[i].ref_blnSelected)
                    //        continue;

                    //    m_smVisionInfo.g_arrLead[i].ref_blnLock = true;

                    //    // Reset previous inspection data
                    //    m_smVisionInfo.g_arrLead[i].ResetInspectionData();

                    //    // Identify Lead definition for displaying fail message
                    //    string strPosition = GetLeadDefinition(i);

                    //    //fTime = t1.Timing;
                    //    //strT += ", M=" + (fTime - fPrev).ToString("F4");
                    //    //fPrev = fTime;

                    //    //Find unit
                    //    if (!FindUnit(i, 0, false))//2021-05-26 ZJYEOH : changed true to false, because no need record pattern angle as now pattern angle sure 0
                    //    {
                    //        bWholeTestFail = true;
                    //        m_smVisionInfo.g_strErrorMessage = strPosition + m_smVisionInfo.g_strErrorMessage;

                    //        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 35 g_intPositionFailureTotal=" + m_smVisionInfo.g_intPositionFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                    //        if (blnAuto)
                    //        {
                    //            SaveRejectImage_AddToBuffer("Position", m_smVisionInfo.g_strErrorMessage);    // Should save then
                    //        }
                    //        if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                    //        {
                    //            //m_smVisionInfo.g_intPositionFailureTotal++;
                    //            m_smVisionInfo.g_intLeadFailureTotal++;
                    //            m_blnFailCounterAdded = true;
                    //            m_blnTotalCounterAdded = false;
                    //            //SaveRejectImage_AddToBuffer("Position", m_smVisionInfo.g_strErrorMessage);    // Should save then
                    //            if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 35a g_intPositionFailureTotal=" + m_smVisionInfo.g_intPositionFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                    //        }
                    //        if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                    //            break;
                    //    }
                    //    fTotalX += m_smVisionInfo.g_arrLead[i].GetResultCenterPoint_UnitMatcher().X;
                    //    fTotalY += m_smVisionInfo.g_arrLead[i].GetResultCenterPoint_UnitMatcher().Y;
                    //    intCount++;
                    //}
                }
                else if ((!m_blnWantPackageTest || (m_blnWantPackageTest && ((m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailMask & 0x1000) == 0 && !m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetWantInspectPackage())))
                          && /*!m_blnWantPackageTest && */m_smVisionInfo.g_arrLead[0].ref_intRotationMethod == 2) // Gauge
                {
                    m_smVisionInfo.g_arrLeadROIs[0][0].AttachImage(m_smVisionInfo.g_objLeadImage);
                    
                    //2021-05-26 ZJYEOH : Need update m_fLeadPatternAngle with m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle
                    m_fLeadPatternAngle = m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle;

                    //ROI.Rotate0Degree(m_smVisionInfo.g_arrLeadROIs[0][0], m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle, 4, ref m_smVisionInfo.g_objLeadImage);
                    
                    for (int i = 1; i < m_smVisionInfo.g_arrLead.Length; i++)
                    {
                        if (!m_smVisionInfo.g_arrLead[i].ref_blnSelected)
                            continue;

                        m_smVisionInfo.g_arrLeadROIs[i][0].AttachImage(m_smVisionInfo.g_objLeadImage);
                    }

                    //ROI objROI = new ROI();
                    //objROI.LoadROISetting(m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIPositionX, m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIPositionY, m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIWidth, m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIHeight);
                    
                        //objROI.AttachImage(m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo]);

                        //ROI.Rotate0Degree(objROI, m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle, 4, ref m_smVisionInfo.g_arrRotatedImages, m_smVisionInfo.g_arrLead[0].ref_intImageViewNo);

                        //m_smVisionInfo.g_arrLead[0].ref_fRotateCenterX_ForDrawing = objROI.ref_ROITotalCenterX;
                        //m_smVisionInfo.g_arrLead[0].ref_fRotateCenterY_ForDrawing = objROI.ref_ROITotalCenterY;

                        if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 0)
                            m_blnRotateImage1Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 1)
                            m_blnRotateImage2Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 2)
                            m_blnRotateImage3Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 3)
                            m_blnRotateImage4Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 4)
                            m_blnRotateImage5Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 5)
                            m_blnRotateImage6Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 6)
                            m_blnRotateImage7Updated = true;
                        
                    m_smVisionInfo.g_arrLead[0].ref_fRotateCenterX_ForDrawing = m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X;
                    m_smVisionInfo.g_arrLead[0].ref_fRotateCenterY_ForDrawing = m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y;

                    if (m_smVisionInfo.g_arrLead[0].ref_blnWantInspectBaseLead && (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo != m_smVisionInfo.g_arrLead[0].ref_intImageViewNo))
                    {

                        //objROI.AttachImage(m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo]);
                        //ROI.Rotate0Degree(objROI, m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle, 4, ref m_smVisionInfo.g_arrRotatedImages, m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo);

                        if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 0)
                            m_blnRotateImage1Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 1)
                            m_blnRotateImage2Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 2)
                            m_blnRotateImage3Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 3)
                            m_blnRotateImage4Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 4)
                            m_blnRotateImage5Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 5)
                            m_blnRotateImage6Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 6)
                            m_blnRotateImage7Updated = true;

                    }

                    //objROI.Dispose();

                    //for (int i = 0; i < m_smVisionInfo.g_arrLead.Length; i++)
                    //{
                    //    if (!m_smVisionInfo.g_arrLead[i].ref_blnSelected)
                    //        continue;

                    //    m_smVisionInfo.g_arrLead[i].ref_blnLock = true;

                    //    // Reset previous inspection data
                    //    m_smVisionInfo.g_arrLead[i].ResetInspectionData();

                    //    // Identify Lead definition for displaying fail message
                    //    string strPosition = GetLeadDefinition(i);

                    //    //fTime = t1.Timing;
                    //    //strT += ", M=" + (fTime - fPrev).ToString("F4");
                    //    //fPrev = fTime;

                    //    //Find unit
                    //    if (!FindUnit(i, 0, false))//2021-05-26 ZJYEOH : changed true to false, because no need record pattern angle as now pattern angle sure 0
                    //    {
                    //        bWholeTestFail = true;
                    //        m_smVisionInfo.g_strErrorMessage = strPosition + m_smVisionInfo.g_strErrorMessage;

                    //        if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 35 g_intPositionFailureTotal=" + m_smVisionInfo.g_intPositionFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                    //        if (blnAuto)
                    //        {
                    //            SaveRejectImage_AddToBuffer("Position", m_smVisionInfo.g_strErrorMessage);    // Should save then
                    //        }
                    //        if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                    //        {
                    //            //m_smVisionInfo.g_intPositionFailureTotal++;
                    //            m_smVisionInfo.g_intLeadFailureTotal++;
                    //            m_blnFailCounterAdded = true;
                    //            m_blnTotalCounterAdded = false;
                    //            //SaveRejectImage_AddToBuffer("Position", m_smVisionInfo.g_strErrorMessage);    // Should save then
                    //            if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 35a g_intPositionFailureTotal=" + m_smVisionInfo.g_intPositionFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                    //        }
                    //        if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                    //            break;
                    //    }
                    //    fTotalX += m_smVisionInfo.g_arrLead[i].GetResultCenterPoint_UnitMatcher().X;
                    //    fTotalY += m_smVisionInfo.g_arrLead[i].GetResultCenterPoint_UnitMatcher().Y;
                    //    intCount++;
                    //}
                    //m_smVisionInfo.g_objLeadImage.SaveImage("D:\\objImg.bmp");
                    //m_smVisionInfo.g_arrRotatedImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo].SaveImage("D:\\objImg2.bmp");
                }

                if (m_smVisionInfo.g_pLeadDontCareRotateCenter == new Point(-1, -1))
                    m_smVisionInfo.g_pLeadDontCareRotateCenter = new Point(m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROITotalCenterX, m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROITotalCenterY);

                m_smVisionInfo.g_fPreciseAngle = m_intOrientAngle - m_fLeadPatternAngle;

                if (!bWholeTestFail || m_smVisionInfo.AT_VM_OfflineTestAllLead)
                {
                    m_smVisionInfo.g_intSelectedLeadExtraBlobID = 0;
                    int Count = 0;
                    // Loop Lead Test From Up, Right, Down to Left
                    for (int i = 0; i < m_smVisionInfo.g_arrLead.Length; i++)
                    {
                        if (!m_smVisionInfo.g_arrLead[i].ref_blnSelected)
                            continue;

                        m_smVisionInfo.g_arrLead[i].ref_intExtraBlobID = Count;

                        m_smVisionInfo.g_arrLead[i].ref_blnViewLeadResultDrawing = true;

                        // Identify Lead definition for displaying fail message
                        string strPosition = GetLeadDefinition(i);

                        m_smVisionInfo.g_arrLead[i].ref_fUnitAverageCenterX = fTotalX / intCount;
                        m_smVisionInfo.g_arrLead[i].ref_fUnitAverageCenterY = fTotalY / intCount;
                        int intFailType = 0;
                        if (!IsLeadOK(i, ref intFailType))
                        {
                            if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                            {
                                m_bLeadBaseCenterPointDone = true;
                                m_bLeadBaseCenterPointResult = false;

                                WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_MarkTest 1");
                                if (!m_bSubTh_MarkTest_Result)
                                {
                                    return false;
                                }

                                WaitEventDone(ref m_bSubTh_PackageTest_MarkLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_MarkLightView 1");
                                if (!m_bSubTh_PackageTest_MarkLightView_Result)
                                {
                                    return false;
                                }

                                WaitEventDone(ref m_bSubTh_PackageTest_SideLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_SideLightView 1");
                                if (!m_bSubTh_PackageTest_SideLightView_Result)
                                {
                                    return false;
                                }

                                WaitEventDone(ref m_bSubTh_PackageTest_TopLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_TopLightView 1");
                                if (!m_bSubTh_PackageTest_TopLightView_Result)
                                {
                                    return false;
                                }
                            }

                            bWholeTestFail = true;
                            if (blnAuto)
                            {
                                if ((intFailType & 0x01) > 0)
                                    SaveRejectImage_AddToBuffer("Lead", m_smVisionInfo.g_arrLead[i].GetLeadFailTestDisplayResult(strPosition));
                                else if (m_smVisionInfo.g_arrLead[i].ref_blnWantInspectBaseLead)
                                    SaveRejectImage_AddToBuffer("Lead", m_smVisionInfo.g_arrLead[i].GetLeadFailTestDisplayResult_BaseLead(strPosition));
                            }
                            if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                            {
                                m_smVisionInfo.g_intLeadFailureTotal++;
                                m_blnFailCounterAdded = true;
                                m_blnTotalCounterAdded = false;
                                //SaveRejectImage_AddToBuffer("Lead", m_smVisionInfo.g_arrLead[i].GetLeadFailTestDisplayResult(strPosition));
                            }

                            m_smVisionInfo.g_strErrorMessage += m_smVisionInfo.g_arrLead[i].GetLeadFailTestDisplayResult(strPosition);
                            if (m_smVisionInfo.g_arrLead[0].ref_blnWantInspectBaseLead)
                            {
                                m_smVisionInfo.g_strErrorMessage += m_smVisionInfo.g_arrLead[i].GetLeadFailTestDisplayResult_BaseLead(strPosition);
                            }
                            if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                                break;
                        }
                        Count = m_smVisionInfo.g_arrLead[i].ref_intExtraBlobID;
                    }
                }
            }
            
            m_bLeadBaseCenterPointResult = !bWholeTestFail;
            m_bLeadBaseCenterPointDone = true;

            // Check Length Variance
            if (!bWholeTestFail || m_smVisionInfo.AT_VM_OfflineTestAllLead)
            {
                if ((m_smVisionInfo.g_arrLead[0].ref_intFailOptionMask & 0x800) > 0)
                {
                    //Check Span only if 2 opposite lead is use
                    if (!IsUnitLengthVarianceOk())
                    {
                        if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                        {
                            WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_MarkTest 1");
                            if (!m_bSubTh_MarkTest_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_MarkLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_MarkLightView 1");
                            if (!m_bSubTh_PackageTest_MarkLightView_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_SideLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_SideLightView 1");
                            if (!m_bSubTh_PackageTest_SideLightView_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_TopLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_TopLightView 1");
                            if (!m_bSubTh_PackageTest_TopLightView_Result)
                            {
                                return false;
                            }
                        }

                        bWholeTestFail = true;

                        if (blnAuto)
                        {
                            SaveRejectImage_AddToBuffer("Lead", m_smVisionInfo.g_arrLead[0].GetUnitLengthVarianceFailTestDisplayResult());
                        }

                        if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                        {
                            m_smVisionInfo.g_intLeadFailureTotal++;
                            m_blnFailCounterAdded = true;
                            m_blnTotalCounterAdded = false;
                        }

                        m_smVisionInfo.g_strErrorMessage += m_smVisionInfo.g_arrLead[0].GetUnitLengthVarianceFailTestDisplayResult();
                    }
                }
            }

            //Check Lead Span here
            if (!bWholeTestFail || m_smVisionInfo.AT_VM_OfflineTestAllLead)
            {
                if ((m_smVisionInfo.g_arrLead[0].ref_intFailOptionMask & 0x1000) > 0)
                {
                    //Check Span only if 2 opposite lead is use
                    if (!IsUnitSpanOk())
                    {
                        if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                        {
                            WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_MarkTest 1");
                            if (!m_bSubTh_MarkTest_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_MarkLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_MarkLightView 1");
                            if (!m_bSubTh_PackageTest_MarkLightView_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_SideLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_SideLightView 1");
                            if (!m_bSubTh_PackageTest_SideLightView_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_TopLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_TopLightView 1");
                            if (!m_bSubTh_PackageTest_TopLightView_Result)
                            {
                                return false;
                            }
                        }

                        bWholeTestFail = true;
                        if (blnAuto)
                        {
                            SaveRejectImage_AddToBuffer("LeadSpan", m_smVisionInfo.g_arrLead[0].GetLeadSpanFailTestDisplayResult());
                        }
                        if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                        {
                            m_smVisionInfo.g_intLeadFailureTotal++;
                            m_blnFailCounterAdded = true;
                            m_blnTotalCounterAdded = false;
                            //SaveRejectImage_AddToBuffer("LeadSpan", m_smVisionInfo.g_arrLead[0].GetLeadSpanFailTestDisplayResult());
                        }

                        m_smVisionInfo.g_strErrorMessage += m_smVisionInfo.g_arrLead[0].GetLeadSpanFailTestDisplayResult("Unit ");
                    }
                }
            }


            if (m_smVisionInfo.g_intViewInspectionSetting == 0)
            {
                m_smVisionInfo.g_blnViewLeadInspection = true;
                //m_smVisionInfo.VM_AT_UpdateErrorMessage = true;   // 2020 10 23 - CCENG: Set this event after all inspection done, Do not set here bcos error msg will be displayed weird.
            }
            else
                m_smVisionInfo.g_strErrorMessage = "";

            m_smVisionInfo.g_blnLeadInspected = true;

            if (bWholeTestFail)
            {
                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        m_intTCPIPResultID = (int)TCPIPResulID.Fail;

                return false;
            }
            else
                return true;
        }
        private bool StartPackageColorTest_MultiThreading(bool blnAuto, int intUnitNo)
        {
            bool blnResult = true;
            bool blnWantDebug = false;

            if (!GetWantInspectPackageColor(intUnitNo))
                return true;

            // Check is templates learnt
            if (m_smVisionInfo.g_arrPackageROIs[intUnitNo].Count == 0)
            {
                // Wait mark inspection done.
                WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartPackageColorTest_MultiThreading > m_bSubTh_MarkTest 1");    // need to wait for mark inspection done. Because package inspection need to use mark char area to set dont care area on package roi.
                if (!m_bSubTh_MarkTest_Result)
                {
                    return false;   // Skip package inspection if mark test fail.
                }
                // Wait package test done under mark light view 
                WaitEventDone(ref m_bSubTh_PackageTest_MarkLightView, false, 10000, "StartPackageColorTest_MultiThreading > m_bSubTh_PackageTest_MarkLightView 2");
                if (!m_bSubTh_PackageTest_MarkLightView_Result)
                {
                    return false;
                }
                // Wait SideLightView Package done because using same database (array)
                WaitEventDone(ref m_bSubTh_PackageTest_SideLightView, false, 10000, "StartPackageColorTest_MultiThreading > m_bSubTh_PackageTest_SideLightView 3");
                if (!m_bSubTh_PackageTest_SideLightView_Result)
                {
                    return false;
                }
                // Wait TopLightView Package done because using same database (array)
                WaitEventDone(ref m_bSubTh_PackageTest_TopLightView, false, 10000, "StartPackageColorTest_MultiThreading > m_bSubTh_PackageTest_TopLightView 4");
                if (!m_bSubTh_PackageTest_TopLightView_Result)
                {
                    return false;
                }

                m_smVisionInfo.g_strErrorMessage += "*Package : No Template Found";
                if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                {
                    m_smVisionInfo.g_intNoTemplateFailureTotal++;
                    m_blnFailCounterAdded = true;
                    m_blnTotalCounterAdded = false;

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 8a PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                }
                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        SetPackageResultID(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailResultMask);

                return false;
            }

            // Make sure template unit size not set to zero
            if ((m_smVisionInfo.g_arrPackage[intUnitNo].ref_fUnitWidthMin == 0 || m_smVisionInfo.g_arrPackage[intUnitNo].ref_fUnitHeightMin == 0) ||
                (m_smVisionInfo.g_arrPackage[intUnitNo].ref_fUnitWidthMax == 0 || m_smVisionInfo.g_arrPackage[intUnitNo].ref_fUnitHeightMax == 0))
            {
                // Wait mark inspection done.
                WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartPackageColorTest_MultiThreading > m_bSubTh_MarkTest 1");    // need to wait for mark inspection done. Because package inspection need to use mark char area to set dont care area on package roi.
                if (!m_bSubTh_MarkTest_Result)
                {
                    return false;   // Skip package inspection if mark test fail.
                }
                // Wait package test done under mark light view 
                WaitEventDone(ref m_bSubTh_PackageTest_MarkLightView, false, 10000, "StartPackageColorTest_MultiThreading > m_bSubTh_PackageTest_MarkLightView 2");
                if (!m_bSubTh_PackageTest_MarkLightView_Result)
                {
                    return false;
                }
                // Wait SideLightView Package done because using same database (array)
                WaitEventDone(ref m_bSubTh_PackageTest_SideLightView, false, 10000, "StartPackageColorTest_MultiThreading > m_bSubTh_PackageTest_SideLightView 3");
                if (!m_bSubTh_PackageTest_SideLightView_Result)
                {
                    return false;
                }
                // Wait TopLightView Package done because using same database (array)
                WaitEventDone(ref m_bSubTh_PackageTest_TopLightView, false, 10000, "StartPackageColorTest_MultiThreading > m_bSubTh_PackageTest_TopLightView 4");
                if (!m_bSubTh_PackageTest_TopLightView_Result)
                {
                    return false;
                }

                m_smVisionInfo.g_strErrorMessage += "*Package : Template Unit Size Min Max Setting cannot be zero.";
                if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnFailCounterAdded)//2020-11-11 ZJYEOH : Removed && !m_blnPassCounterAdded
                {
                    m_smVisionInfo.g_intPackageFailureTotal++;
                    m_blnFailCounterAdded = true;
                    m_blnTotalCounterAdded = false;

                    if (m_smVisionInfo.g_blnTrackPocketCounter) STTrackLog.WriteLine("Fail 9a PackageFailureTotal=" + m_smVisionInfo.g_intPackageFailureTotal.ToString() + ", RetestEnd=" + m_smVisionInfo.g_blnInPocketRetestEnd.ToString() + ", FailCounterAdded=" + m_blnFailCounterAdded.ToString());
                }
                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        m_intTCPIPResultID = (int)TCPIPResulID.Fail;//FailPackageDimension;

                return false;
            }

            // Wait mark inspection done.
            WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartPackageColorTest_MultiThreading > m_bSubTh_MarkTest 1");    // need to wait for mark inspection done. Because package inspection need to use mark char area to set dont care area on package roi.
            if (!m_bSubTh_MarkTest_Result)
            {
                return false;   // Skip package inspection if mark test fail.
            }
            // Wait package test done under mark light view 
            WaitEventDone(ref m_bSubTh_PackageTest_MarkLightView, false, 10000, "StartPackageColorTest_MultiThreading > m_bSubTh_PackageTest_MarkLightView 2");
            if (!m_bSubTh_PackageTest_MarkLightView_Result)
            {
                return false;
            }
            // Wait SideLightView Package done because using same database (array)
            WaitEventDone(ref m_bSubTh_PackageTest_SideLightView, false, 10000, "StartPackageColorTest_MultiThreading > m_bSubTh_PackageTest_SideLightView 3");
            if (!m_bSubTh_PackageTest_SideLightView_Result)
            {
                return false;
            }
            // Wait TopLightView Package done because using same database (array)
            WaitEventDone(ref m_bSubTh_PackageTest_TopLightView, false, 10000, "StartPackageColorTest_MultiThreading > m_bSubTh_PackageTest_TopLightView 4");
            if (!m_bSubTh_PackageTest_TopLightView_Result)
            {
                return false;
            }

            bool blnWantMark = false;
            int intCharDilateHalfWidth = 2;
            if (m_smVisionInfo.g_arrMarks != null && m_smVisionInfo.g_arrMarks.Count > intUnitNo)
            {
                // 2020 04 15 - JBTAN: will continue to check mark even option uncheck check mark option
                // 2020 07 08 - Roll back to previous method, wont check mark if Mark Checking is not selected.
                blnWantMark = m_smVisionInfo.g_arrMarks[intUnitNo].ref_blnCheckMark;
                //blnWantMark = true;
                intCharDilateHalfWidth = m_smVisionInfo.g_arrMarks[intUnitNo].ref_intCharDilateHalfWidth; // thick iteration
            }

            List<int> arrStartX = new List<int>();
            List<int> arrStartY = new List<int>();
            List<int> arrEndX = new List<int>();
            List<int> arrEndY = new List<int>();
            if (blnWantMark)
            {
                // ---------- Fill Mark Image's mark area with black color -------------------
                int intNumChars = m_smVisionInfo.g_arrMarks[intUnitNo].GetNumChars();
                int intStartX = 0, intStartY = 0, intEndX = 0, intEndY = 0;

                int intOffsetX;
                int intOffsetY;

                if (m_smVisionInfo.g_blnWantGauge)  // Mean during mark inspection, orient gauge is used to measure unit position for m_objMarkTrainROI
                {
                    intOffsetX = m_objMarkTrainROI.ref_ROITotalX;
                    intOffsetY = m_objMarkTrainROI.ref_ROITotalY;
                }
                else if (m_smVisionInfo.g_arrMarkROIs[0].Count > 3)    // Mean during mark inspection, Unit PR is used to find unit surface position for m_objMarkTrainROI
                {
                    intOffsetX = m_objMarkTrainROI.ref_ROITotalX;
                    intOffsetY = m_objMarkTrainROI.ref_ROITotalY;
                }
                else // Mean during mark inspection, m_objMarkSearchROI is used.
                {
                    intOffsetX = m_objMarkTrainROI.ref_ROITotalX;
                    intOffsetY = m_objMarkTrainROI.ref_ROITotalY;
                }

                for (int i = 0; i < intNumChars; i++)
                {
                    bool blnIsBarPin1 = m_smVisionInfo.g_arrMarks[intUnitNo].GetCharIsBarPin1(m_smVisionInfo.g_arrMarks[intUnitNo].ref_intGroupIndex, m_smVisionInfo.g_arrMarks[intUnitNo].ref_intTemplateIndex, i);
                    int intBarPin1Type = m_smVisionInfo.g_arrMarks[intUnitNo].GetCharBarPin1Type(m_smVisionInfo.g_arrMarks[intUnitNo].ref_intGroupIndex, m_smVisionInfo.g_arrMarks[intUnitNo].ref_intTemplateIndex, i);

                    int intRectStartX, intRectStartY, intRectEndX, intRectEndY;
                    intRectStartX = intRectStartY = intRectEndX = intRectEndY = 0;
                    m_smVisionInfo.g_arrMarks[intUnitNo].GetCharStartXY(i, ref intStartX, ref intStartY);
                    m_smVisionInfo.g_arrMarks[intUnitNo].GetCharEndXY(i, ref intEndX, ref intEndY);

                    if (m_smVisionInfo.g_arrMarks[intUnitNo].ref_blnWantDontCareIgnoredMarkWholeArea && !m_smVisionInfo.g_arrMarks[intUnitNo].GetEnableMarkSetting(i))
                    {
                        //2021-01-18 ZJYEOH : Should use sample position
                        Point pStartTemplate = new Point(intStartX, intStartY);//m_smVisionInfo.g_arrMarks[0].GetTemplateCharROIStartPoint(i);
                        Point pEndTemplate = new Point(intEndX, intEndY);//m_smVisionInfo.g_arrMarks[0].GetTemplateCharROIEndPoint(i);

                        if ((intOffsetX + pStartTemplate.X - m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftX(i)) >= 0)
                            intRectStartX = intOffsetX + pStartTemplate.X - m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftX(i);
                        else
                            intRectStartX = intOffsetX;

                        if ((intOffsetY + pStartTemplate.Y - m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftY(i)) >= 0)
                            intRectStartY = intOffsetY + pStartTemplate.Y - m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftY(i);
                        else
                            intRectStartY = intOffsetY;

                        if ((intOffsetX + pEndTemplate.X + m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftX(i)) < m_smVisionInfo.g_intCameraResolutionWidth)
                            intRectEndX = intOffsetX + pEndTemplate.X + m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftX(i);
                        else
                            continue;
                        if ((intOffsetY + pEndTemplate.Y + m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftY(i)) < m_smVisionInfo.g_intCameraResolutionHeight)
                            intRectEndY = intOffsetY + pEndTemplate.Y + m_smVisionInfo.g_arrMarks[intUnitNo].GetTemplateCharShiftY(i);
                        else
                            continue;
                    }
                    else
                    {
                        // 2019 10 11 - CCENG   : add intOffsetXY checking because rectangle will be filled on m_objPkgViewImage (Full image)
                        //                      : without the intOffsetXY, intRectStartX will set to intOffsetX and fill position may be shifted                       
                        if ((intOffsetX + intStartX - intCharDilateHalfWidth) >= 0)  //if ((intStartX - intCharDilateHalfWidth) >= 0)   
                            intRectStartX = intOffsetX + intStartX - intCharDilateHalfWidth;
                        else
                            intRectStartX = intOffsetX;

                        // 2019 10 11 - CCENG   : add intOffsetXY checking because rectangle will be filled on m_objPkgViewImage (Full image)
                        //                      : without the intOffsetXY, intRectStartX will set to intOffsetX and fill position may be shifted
                        if ((intOffsetY + intStartY - intCharDilateHalfWidth) >= 0)    //if ((intStartY - intCharDilateHalfWidth) >= 0) 
                            intRectStartY = intOffsetY + intStartY - intCharDilateHalfWidth;
                        else
                            intRectStartY = intOffsetY;

                        if ((intEndX + intCharDilateHalfWidth) < m_smVisionInfo.g_intCameraResolutionWidth)
                            intRectEndX = intOffsetX + intEndX + intCharDilateHalfWidth;
                        else
                            intRectEndX = intOffsetX + intEndX;

                        if ((intEndY + intCharDilateHalfWidth) < m_smVisionInfo.g_intCameraResolutionHeight)
                            intRectEndY = intOffsetY + intEndY + intCharDilateHalfWidth;
                        else
                            intRectEndY = intOffsetY + intEndY;
                    }

                    //2020-05-28 ZJYEOH : extend the dont care area to fit the m_objMarkTrainROI size
                    if (blnIsBarPin1 && !m_smVisionInfo.g_blnWantCheckBarPin1)
                    {
                        if (intBarPin1Type == 0) // Virtical bar
                        {
                            intRectStartY = intOffsetY;
                            intRectEndY = intOffsetY + m_objMarkTrainROI.ref_ROIHeight;
                        }
                        else if (intBarPin1Type == 1) // Horizontal bar
                        {
                            intRectStartX = intOffsetX;
                            intRectEndX = intOffsetX + m_objMarkTrainROI.ref_ROIWidth;
                        }
                    }

                    arrStartX.Add(intRectStartX);
                    arrStartY.Add(intRectStartY);
                    arrEndX.Add(intRectEndX);
                    arrEndY.Add(intRectEndY);
                    //if (blnWantDebug)
                    //{
                    //    m_arrColorImage_ForInspection[0].SaveImage("D:\\TS\\1.m_arrColorImage_ForInspection" + i.ToString() + ".bmp");
                    //}

                    //Shape.FillRectangle(m_arrColorImage_ForInspection[0], intRectStartX, intRectStartY, intRectEndX, intRectEndY, 0);

                    //if (blnWantDebug)
                    //{
                    //    m_arrColorImage_ForInspection[0].SaveImage("D:\\TS\\2.m_arrColorImage_ForInspection" + i.ToString() + ".bmp");
                    //}

                    if (m_smVisionInfo.g_blnWantNonRotateInspection)
                    {
                        float newSX = 0, newSY = 0, newEX = 0, newEY = 0;
                        Math2.GetNewXYAfterRotate_360deg((intRectEndX + intRectStartX) / 2, (intRectEndY + intRectStartY) / 2, intRectStartX, intRectStartY, -(m_smVisionInfo.g_arrOrients[m_smVisionInfo.g_intSelectedUnit][m_smVisionInfo.g_intSelectedOcv[0]].ref_fDegAngleResult), ref newSX, ref newSY);

                        Math2.GetNewXYAfterRotate_360deg((intRectEndX + intRectStartX) / 2, (intRectEndY + intRectStartY) / 2, intRectEndX, intRectEndY, -(m_smVisionInfo.g_arrOrients[m_smVisionInfo.g_intSelectedUnit][m_smVisionInfo.g_intSelectedOcv[0]].ref_fDegAngleResult), ref newEX, ref newEY);
                        
                        float fCenterX = m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X;
                        float fCenterY = m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y;

                        float fX_Rotated = (float)((fCenterX) + ((newSX - fCenterX) * Math.Cos(-m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle * Math.PI / 180)) - ((newSY - fCenterY) * Math.Sin(-m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle * Math.PI / 180)));

                        float fY_Rotated = (float)((fCenterY) + ((newSX - fCenterX) * Math.Sin(-m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle * Math.PI / 180)) + ((newSY - fCenterY) * Math.Cos(-m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle * Math.PI / 180)));

                        arrStartX[i] = (int)Math.Ceiling(fX_Rotated);
                        arrStartY[i] = (int)Math.Ceiling(fY_Rotated);

                        fX_Rotated = (float)((fCenterX) + ((newEX - fCenterX) * Math.Cos(-m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle * Math.PI / 180)) - ((newEY - fCenterY) * Math.Sin(-m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle * Math.PI / 180)));

                        fY_Rotated = (float)((fCenterY) + ((newEX - fCenterX) * Math.Sin(-m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle * Math.PI / 180)) + ((newEY - fCenterY) * Math.Cos(-m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle * Math.PI / 180)));

                        arrEndX[i] = (int)Math.Floor(fX_Rotated);
                        arrEndY[i] = (int)Math.Floor(fY_Rotated);
                    }
                }
            }
            
            // ----------- Define the actual location for unit and place the package roi on that location. ------------------------
            CROI objPkgViewROI = null; // Image 2 - Package ROI

            objPkgViewROI = new CROI();
            objPkgViewROI.AttachImage(m_arrColorImage_ForInspection[0]);
            objPkgViewROI.LoadROISetting((int)Math.Round((m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X -
                                         m_smVisionInfo.g_objGauge_PkgSize.ref_fRectWidth / 2), 0, MidpointRounding.AwayFromZero),
                                         (int)Math.Round((m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y -
                                         m_smVisionInfo.g_objGauge_PkgSize.ref_fRectHeight / 2), 0, MidpointRounding.AwayFromZero),
                                         (int)Math.Round(m_smVisionInfo.g_objGauge_PkgSize.ref_fRectWidth, 0, MidpointRounding.AwayFromZero),
                                         (int)Math.Round(m_smVisionInfo.g_objGauge_PkgSize.ref_fRectHeight, 0, MidpointRounding.AwayFromZero));

            if (m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intColorDefectLinkMethod == 1)
            {
                if (!m_smVisionInfo.g_arrPackage[intUnitNo].CheckColorDefect_CombineSameName_LinkNearest(objPkgViewROI, m_arrColorImage_ForInspection, m_smVisionInfo.g_objWhiteImage, m_smVisionInfo.g_objBlackImage, arrStartX, arrStartY, arrEndX, arrEndY))
                {
                    m_smVisionInfo.g_strErrorMessage += m_smVisionInfo.g_arrPackage[intUnitNo].ref_strErrorMessage;
                    if (blnAuto)
                    {
                        SaveRejectImage_AddToBuffer("PackageColorDefect", m_smVisionInfo.g_arrPackage[intUnitNo].ref_strErrorMessage);
                    }
                    if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                    {
                        if (!m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        {
                            m_objVisionIO.PackageFail.SetOn("V4 PackageFail 2");
                        }
                        //SaveRejectImage_AddToBuffer("PackageDefect", m_smVisionInfo.g_arrPackage[intUnitNo].ref_strErrorMessage);

                        m_smVisionInfo.g_intPkgColorDefectFailureTotal++;
                        //m_smVisionInfo.g_intTestedTotal++;
                        //m_smVisionInfo.g_intLowYieldUnitCount++;
                        m_blnFailCounterAdded = true;
                        m_blnTotalCounterAdded = false;
                    }
                    if (blnAuto)
                    {
                        if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        {
                            m_blnPackageFail_Out = true;
                            if (m_intTCPIPResultID == -1)
                                SetPackageResultID(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailResultMask);
                        }
                    }
                    blnResult = false;
                }
            }
            else
            {
                if (!m_smVisionInfo.g_arrPackage[intUnitNo].CheckColorDefect_CombineSameName(objPkgViewROI, m_arrColorImage_ForInspection, m_smVisionInfo.g_objWhiteImage, m_smVisionInfo.g_objBlackImage, arrStartX, arrStartY, arrEndX, arrEndY))
                {
                    m_smVisionInfo.g_strErrorMessage += m_smVisionInfo.g_arrPackage[intUnitNo].ref_strErrorMessage;
                    if (blnAuto)
                    {
                        SaveRejectImage_AddToBuffer("PackageColorDefect", m_smVisionInfo.g_arrPackage[intUnitNo].ref_strErrorMessage);
                    }
                    if (blnAuto && m_smVisionInfo.g_blnInPocketRetestEnd && !m_blnPassCounterAdded && !m_blnFailCounterAdded)
                    {
                        if (!m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        {
                            m_objVisionIO.PackageFail.SetOn("V4 PackageFail 2");
                        }
                        //SaveRejectImage_AddToBuffer("PackageDefect", m_smVisionInfo.g_arrPackage[intUnitNo].ref_strErrorMessage);

                        m_smVisionInfo.g_intPkgColorDefectFailureTotal++;
                        //m_smVisionInfo.g_intTestedTotal++;
                        //m_smVisionInfo.g_intLowYieldUnitCount++;
                        m_blnFailCounterAdded = true;
                        m_blnTotalCounterAdded = false;
                    }
                    if (blnAuto)
                    {
                        if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        {
                            m_blnPackageFail_Out = true;
                            if (m_intTCPIPResultID == -1)
                                SetPackageResultID(m_smVisionInfo.g_arrPackage[intUnitNo].ref_intFailResultMask);
                        }
                    }
                    blnResult = false;
                }
            }

            objPkgViewROI.Dispose();

            m_smVisionInfo.g_blnDrawPkgResult = true;
            m_smVisionInfo.g_blnPackageInspected = true;

            return blnResult;
        }
        private bool WaitEventDone(int[] arrImageIndex, string strTrackName)
        {
            for (int i = 0; i < arrImageIndex.Length; i++)
            {
                if (arrImageIndex[i] == 0)
                    return WaitEventDone(ref m_bGrabImage1Done, true, ref m_bGrabImage1Result, strTrackName + "- 1");
                else if (arrImageIndex[i] == 1)
                    return WaitEventDone(ref m_bGrabImage2Done, true, ref m_bGrabImage2Result, strTrackName + "- 2");
                else if (arrImageIndex[i] == 2)
                    return WaitEventDone(ref m_bGrabImage3Done, true, ref m_bGrabImage3Result, strTrackName + "- 3");
                else if (arrImageIndex[i] == 3)
                    return WaitEventDone(ref m_bGrabImage4Done, true, ref m_bGrabImage4Result, strTrackName + "- 4");
                else if (arrImageIndex[i] == 4)
                    return WaitEventDone(ref m_bGrabImage5Done, true, ref m_bGrabImage5Result, strTrackName + "- 5");
                else if (arrImageIndex[i] == 5)
                    return WaitEventDone(ref m_bGrabImage6Done, true, ref m_bGrabImage6Result, strTrackName + "- 6");
                else if (arrImageIndex[i] == 6)
                    return WaitEventDone(ref m_bGrabImage7Done, true, ref m_bGrabImage7Result, strTrackName + "- 7");
            }

            return false;
        }
       
        private void UpdateSubProgress_AfterInspect()
        {
            while (!m_blnStopping)
            {
                try
                {
                    if (m_bSubTh_StartAfterInspect)
                    {

                        //2020-04-30 ZJYEOH : Record Result Log
                        if (m_blnAuto && m_smVisionInfo.g_blnWantRecordResult && (m_smVisionInfo.g_intTestedTotal <= m_smVisionInfo.g_intResultLogMaxCount))
                            RecordResultLog();

                        m_bSubTh_StartAfterInspect = false;
                    }
                }
                catch (Exception ex)
                {
                    SRMMessageBox.Show("Vision1Process->UpdateSubProgress_SideBR() :" + ex.ToString());
                }
                Thread.Sleep(1);
            }

            m_thSubThread_AfterInspect = null;
            m_blnStopped_AfterInspect = true;
        }
        private void RecordResultLog()
        {
            string strLotSaveResultLogPath;
            string strVisionResultLogFileName;
            string strPath;
            if (m_smVisionInfo.g_intVisionResetCount == 0)
            {
                strLotSaveResultLogPath = m_smProductionInfo.g_strHistoryDataLocation + "ResultLog\\" + m_smProductionInfo.g_strLotID + "_" + m_smProductionInfo.g_strLotStartTime;
                strVisionResultLogFileName = m_smVisionInfo.g_strVisionFolderName + "(" + m_smVisionInfo.g_strVisionDisplayName + " " + m_smVisionInfo.g_strVisionNameRemark + ")" + "_" + m_smProductionInfo.g_strLotStartTime;

                if (!Directory.Exists(strLotSaveResultLogPath))
                    Directory.CreateDirectory(strLotSaveResultLogPath);

                strPath = strLotSaveResultLogPath + "\\" + strVisionResultLogFileName + ".txt";
            }
            else
            {
                strLotSaveResultLogPath = m_smProductionInfo.g_strHistoryDataLocation + "ResultLog\\" + m_smProductionInfo.g_strLotID + "_" + m_smProductionInfo.g_strLotStartTime;
                strVisionResultLogFileName = m_smVisionInfo.g_strVisionFolderName + "(" + m_smVisionInfo.g_strVisionDisplayName + " " + m_smVisionInfo.g_strVisionNameRemark + ")" + "_" + m_smVisionInfo.g_strVisionResetCountTime;

                if (!Directory.Exists(strLotSaveResultLogPath))
                    Directory.CreateDirectory(strLotSaveResultLogPath);

                strPath = strLotSaveResultLogPath + "\\" + strVisionResultLogFileName + ".txt";
            }

            string ResultData = "";

            for (int a = 0; a < m_smVisionInfo.g_arrLead.Length; a++)
            {
                if (!m_smVisionInfo.g_arrLead[a].ref_blnSelected)
                    continue;

                int intBlobsCount = m_smVisionInfo.g_arrLead[a].GetBlobsFeaturesNumber();

                if (intBlobsCount > 0)
                    ResultData += "Date Time=" + DateTime.Now.ToString() + ",";

                string strLeadDirection = "";
                switch (a)
                {
                    case 0:
                        strLeadDirection = "Center ";
                        break;
                    case 1:
                        strLeadDirection = "Top ";
                        break;
                    case 2:
                        strLeadDirection = "Right ";
                        break;
                    case 3:
                        strLeadDirection = "Bottom ";
                        break;
                    case 4:
                        strLeadDirection = "Left ";
                        break;
                }

                for (int i = 0; i < intBlobsCount; i++)
                {
                    List<string> arrResultList = new List<string>();

                    arrResultList = m_smVisionInfo.g_arrLead[a].GetBlobFeaturesResult_WithPassFailIndicator(i);

                    int intFailMask = Convert.ToInt32(arrResultList[arrResultList.Count - 1]);
                    int intFailOptionMask = m_smVisionInfo.g_arrLead[a].ref_intFailOptionMask;
                    bool blnWantCheckWidthLength = false, blnWantCheckPitchGap = false,
                        blnWantCheckBaseLeadArea = false;

                    if ((intFailOptionMask & 0xC0) > 0)
                        blnWantCheckWidthLength = true;
                    if ((intFailOptionMask & 0x600) > 0)
                        blnWantCheckPitchGap = true;
                    if ((intFailOptionMask & 0x20000) > 0)
                        blnWantCheckBaseLeadArea = true;

                    if (blnWantCheckWidthLength)
                    {
                        ResultData += strLeadDirection + "Lead " + (i + 1).ToString() + " Tip Width=" + arrResultList[2].ToString() + ",";

                        ResultData += strLeadDirection + "Lead " + (i + 1).ToString() + " Tip Length=" + arrResultList[3].ToString() + ",";
                    }

                    if (blnWantCheckPitchGap && a == 0)
                    {
                        ResultData += strLeadDirection + "Lead " + (i + 1).ToString() + " Pitch=" + arrResultList[4].ToString() + ",";

                        ResultData += strLeadDirection + "Lead " + (i + 1).ToString() + " Gap=" + arrResultList[5].ToString() + ",";
                    }

                    if (blnWantCheckBaseLeadArea && a == 0)
                    {
                        ResultData += strLeadDirection + "Lead " + (i + 1).ToString() + " Base Lead Area=" + arrResultList[6].ToString() + ",";
                    }

                }

            }

            if (ResultData != "")
            {
                ResultData = ResultData.Substring(0, ResultData.Length - 1); // Remove comma
                STTrackLog.WriteLine_ForResultLog(strLotSaveResultLogPath, strVisionResultLogFileName, ResultData);
            }
        }
        private string GetUnitName(int intUnitNo)
        {

            if (m_smVisionInfo.g_intUnitsOnImage == 2)
            {
                if (intUnitNo == 0)
                    return "*Unit " + Convert.ToString(intUnitNo + 1) + "(Test) :*"; //return " * Test :*";
                else
                    return "*Unit " + Convert.ToString(intUnitNo + 1) + "(Retest) :*";//" * Retest :*";
            }
            else
                return "";
        }
        private void SetPackageResultID(int intFailResultMask)
        {
            if ((intFailResultMask & 0x01) > 0) //Crack
                m_intTCPIPResultID = (int)TCPIPResulID.Fail;//FailCrack;
            else if (((intFailResultMask & 0x02) > 0) || ((intFailResultMask & 0x04) > 0)) //Chipped Off, Scratches
                m_intTCPIPResultID = (int)TCPIPResulID.Fail;//FailChippedOffOrScractches;
            else if ((intFailResultMask & 0x10) > 0) //Contamination
                m_intTCPIPResultID = (int)TCPIPResulID.Fail;//FailForeignMaterial;
            else
                m_intTCPIPResultID = (int)TCPIPResulID.Fail;//FailPackage;
        }
        private bool ContainColorSelectedImage(int intImageIndex, int intUnitIndex)
        {
            List<int> arrDefectImage = new List<int>();

            for (int i = 0; i < m_smVisionInfo.g_arrPackage[intUnitIndex].ref_arrDefectImageNo.Count; i++)
            {
                if (!arrDefectImage.Contains(CImageDrawing.GetArrayImageIndex(m_smVisionInfo.g_arrPackage[intUnitIndex].ref_arrDefectImageNo[i], m_smVisionInfo.g_intVisionIndex)))
                    arrDefectImage.Add(CImageDrawing.GetArrayImageIndex(m_smVisionInfo.g_arrPackage[intUnitIndex].ref_arrDefectImageNo[i], m_smVisionInfo.g_intVisionIndex));
            }

            if (arrDefectImage.Contains(intImageIndex))
                return true;

            return false;
        }
        private bool GetWantInspectPackageColor(int intUnitIndex)
        {
            if (m_blnCustomWantColor &&
                m_smVisionInfo.g_blnCheckPackageColor &&
                (m_smVisionInfo.g_arrPackage.Count > intUnitIndex) &&
                (m_smVisionInfo.g_arrPackage[intUnitIndex].ref_arrDefectColor.Count > 0) &&
                (m_smVisionInfo.g_arrPackage[intUnitIndex].ref_intFailColorOptionMask > 0)
                )
            {
                return true;
            }
            return false;
        }

        private bool GetColorImageRotated(int intImageIndex)
        {
            switch (intImageIndex)
            {
                case 0:
                    return m_blnRotateColorImage1Updated;
                    break;
                case 1:
                    return m_blnRotateColorImage2Updated;
                    break;
                case 2:
                    return m_blnRotateColorImage3Updated;
                    break;
                case 3:
                    return m_blnRotateColorImage4Updated;
                    break;
                case 4:
                    return m_blnRotateColorImage5Updated;
                    break;
                case 5:
                    return m_blnRotateColorImage6Updated;
                    break;
                case 6:
                    return m_blnRotateColorImage7Updated;
                    break;
            }
            return true;
        }
        private void SetColorImageRotated(int intImageIndex)
        {
            switch (intImageIndex)
            {
                case 0:
                    m_blnRotateColorImage1Updated = true;
                    break;
                case 1:
                    m_blnRotateColorImage2Updated = true;
                    break;
                case 2:
                    m_blnRotateColorImage3Updated = true;
                    break;
                case 3:
                    m_blnRotateColorImage4Updated = true;
                    break;
                case 4:
                    m_blnRotateColorImage5Updated = true;
                    break;
                case 5:
                    m_blnRotateColorImage6Updated = true;
                    break;
                case 6:
                    m_blnRotateColorImage7Updated = true;
                    break;
            }
        }
    }
}
