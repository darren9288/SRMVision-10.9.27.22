using System;
using System.Collections;
using System.Collections.Generic;
using System.Drawing;
using System.IO;
using System.Text;
using System.Threading;
using Common;
using ImageAcquisition;
using SharedMemory;
using VisionProcessing;
using System.Windows.Forms;
using System.Runtime.InteropServices;
using IOMode;   
using Lighting;
using Microsoft.Win32;
using System.Linq;

namespace VisionModule
{
    public class Vision1Process
    {
        #region DllImport

#if (RTXDebug || RTXRelease)

        [DllImport("SRMRtx.dll", CharSet = CharSet.Auto)]
        public static extern bool SRMSingleLock([MarshalAs(UnmanagedType.LPStr)] string valueName);

        [DllImport("SRMRtx.dll", CharSet = CharSet.Auto)]
        public static extern void SRMSetEvent([MarshalAs(UnmanagedType.LPStr)] string eventName);

        [DllImport("SRMRtx.dll", CharSet = CharSet.Auto)]
        public static extern void SRMResetEvent([MarshalAs(UnmanagedType.LPStr)] string eventName);

#endif

        #endregion

        #region constant variables

        //private const int BUFFERSIZE = 20;

        #endregion

        #region enum
        public enum ResulType { Pass, FailPackageSize, FailPackageDefect, Timesout, NotReady };
        public enum TCPIPResulID { Fail = 0, FailMark = 1, FailPackage = 0/*2*/, FailPosition = 0/*3*///, FailNotSeatProper = 4, FailCrack = 11, FailForeignMaterial = 12,
                                   //FailPackageDimension = 13, FailVoid = 14, FailChippedOffOrScractches = 15, FailCopper = 16, FailDiscolouration = 17, FailEmpty = 18,
                                   //FailNoMark = 19, Fail2DCodeNoFound = 20, Fail2DCodeVerification = 21
                                 };
        #endregion

        #region Member Variables 
        private bool m_blnRecipeVerificationTestMode = false;
        private bool m_blnTestHandMade_Mark = false;
        private Point m_pOrientRotateStartPoint = new Point(0, 0);
        private Size m_pOrientRotateSize = new Size(1, 1);
        private float m_fOrientTotalRotateAngle = 0;
        List<IntPtr> m_arrBufferPointer = new List<IntPtr>();
        private bool m_blnCustomWantColor = false;
        private int m_intCounter = 0;
        private float m_fLeadPatternAngle = 0;
        private float m_fLeadPatternScore = 0;
        private float m_fCenterX, m_fCenterY;
        // Thread handle
        private readonly object m_objStopLock = new object();
        private bool m_blnAuto = false;
        private bool m_blnStopping = false;
        private bool m_blnPause = false;
        private bool m_blnWantOrientTest = false;
        private bool m_blnWantMarkTest = false;
        private bool m_blnWantPackageTest = false;
        private bool m_blnWantPositioning = false;
        private bool m_blnWantLeadTest = false;
        private bool m_blnOrientDataUpdated = false;
        private bool m_blnRotateImage1Updated = false;
        private bool m_blnRotateImage2Updated = false;
        private bool m_blnRotateImage3Updated = false;
        private bool m_blnRotateImage4Updated = false;
        private bool m_blnRotateImage5Updated = false;
        private bool m_blnRotateImage6Updated = false;
        private bool m_blnRotateImage7Updated = false;
        private bool m_blnRotateColorImage1Updated = false;
        private bool m_blnRotateColorImage2Updated = false;
        private bool m_blnRotateColorImage3Updated = false;
        private bool m_blnRotateColorImage4Updated = false;
        private bool m_blnRotateColorImage5Updated = false;
        private bool m_blnRotateColorImage6Updated = false;
        private bool m_blnRotateColorImage7Updated = false;
        private bool m_blnForceStopProduction = false;
        private bool m_blnLoadRejectImageListPath = false;
        private int m_intPassStartNode = 0;
        private int m_intFailStartNode = 0;
        private int m_intPassEndNode = 0;
        private int m_intFailEndNode = 0;
        private int m_intFileIndex = 0;

        private float m_fOrientFinalAngleForLead = 0;

        //package 
        private int m_intGrabRequire = 0;
        private int m_intCurrentGrabRequire = 1;
        private double m_dRedRatioPrev = 2.309997559;
        private double m_dBlueRatioPrev = 2.539978027;
        private uint m_intCameraGainPrev = 1;
        private float m_fCameraShuttlePrev = 1f;
        private int m_intCameraOutState = 1;
        private int[] m_arrCameraIntensityPrev = { -1, -1, -1, -1 }; // index == light source number. Maximum for each camera link to light source is only four
        private float m_fOrientGauge = 0.0f;
        List<bool> m_arrFinalPreciseAnglePass = new List<bool>();
        private List<CImageDrawing> m_arrColorImage_ForInspection = new List<CImageDrawing>();
        private ImageDrawing m_objPkgViewImage = new ImageDrawing(true);
        private ImageDrawing m_objPkgViewImage_DarkField2 = new ImageDrawing(true);
        private ImageDrawing m_objPkgViewImage_DarkField3 = new ImageDrawing(true);
        private ImageDrawing m_objPkgViewImage_DarkField4 = new ImageDrawing(true);
        private ImageDrawing m_objPkgMoldFlashViewImage = new ImageDrawing(true);
        private ImageDrawing m_objPkgViewImage2 = new ImageDrawing(true);
        private ImageDrawing m_objVoidViewImage = new ImageDrawing(true);
        private ImageDrawing m_objMarkViewImage = new ImageDrawing(true);
        private ImageDrawing m_objCrackViewImage = new ImageDrawing(true);
        private ImageDrawing m_objOrientGainImage = new ImageDrawing(true);
        private ImageDrawing m_objPkgSizeGainImage = new ImageDrawing(true);
        private ImageDrawing m_objLeadImage = new ImageDrawing(true);
        private ImageDrawing m_objMarkTestImage = new ImageDrawing(true); //use for mark 2D and dont care to prevent main image modified
        private ImageDrawing m_objGrayValueImage_SideLight = new ImageDrawing(true);
        private ImageDrawing m_objGrayValueImage_TopLight = new ImageDrawing(true);
        private ImageDrawing[] m_arrPassImage1Buffer = null;
        private ImageDrawing[] m_arrPassImage2Buffer = null;
        private ImageDrawing[] m_arrPassImage3Buffer = null;
        private ImageDrawing[] m_arrPassImage4Buffer = null;
        private ImageDrawing[] m_arrPassImage5Buffer = null;
        private ImageDrawing[] m_arrPassImage6Buffer = null;
        private ImageDrawing[] m_arrPassImage7Buffer = null;
        private ImageDrawing[] m_arrFailImage1Buffer = null;
        private ImageDrawing[] m_arrFailImage2Buffer = null;
        private ImageDrawing[] m_arrFailImage3Buffer = null;
        private ImageDrawing[] m_arrFailImage4Buffer = null;
        private ImageDrawing[] m_arrFailImage5Buffer = null;
        private ImageDrawing[] m_arrFailImage6Buffer = null;
        private ImageDrawing[] m_arrFailImage7Buffer = null;
        private CImageDrawing[] m_arrPassCImage1Buffer = null;
        private CImageDrawing[] m_arrPassCImage2Buffer = null;
        private CImageDrawing[] m_arrPassCImage3Buffer = null;
        private CImageDrawing[] m_arrPassCImage4Buffer = null;
        private CImageDrawing[] m_arrPassCImage5Buffer = null;
        private CImageDrawing[] m_arrPassCImage6Buffer = null;
        private CImageDrawing[] m_arrPassCImage7Buffer = null;
        private CImageDrawing[] m_arrFailCImage1Buffer = null;
        private CImageDrawing[] m_arrFailCImage2Buffer = null;
        private CImageDrawing[] m_arrFailCImage3Buffer = null;
        private CImageDrawing[] m_arrFailCImage4Buffer = null;
        private CImageDrawing[] m_arrFailCImage5Buffer = null;
        private CImageDrawing[] m_arrFailCImage6Buffer = null;
        private CImageDrawing[] m_arrFailCImage7Buffer = null;
        private RectGaugeM4L m_objGauge_PkgMarkView;
        private RectGaugeM4L m_objGauge_PkgSideView;
        private RectGaugeM4L m_objGauge_PkgTopView;
        private Object m_objLockSaveRejectImage = new Object();
        private int[] m_arrPassNoBuffer = null;
        private int[] m_arrFailNoBuffer = null;
        private int[] m_arrOrientationBuffer = null;
        private string[] m_arrRejectNameBuffer = null;
        private string[] m_arrRejectMessageBuffer = null;
        private List<string> m_arrRejectImageListPath = new List<string>();
        private List<string> m_arrRejectImageErrorMessageListPath = new List<string>();
        private object m_objLock = new object();

        private ROI m_objMarkSearchROI = new ROI();
        private ROI m_objMarkTrainROI = new ROI();
        private ROI m_objMarkOcvSearchROI = new ROI();
        private ROI m_objMarkOCRSearchROI = new ROI();
        private ROI m_objMark2DCodeROI = new ROI();

        // ------color package -------------
        CROI objColorUnitROI = new CROI();
        CROI objColorTrainROI = new CROI();
        ROI objMonoUnitROI = new ROI();
        ROI objMonoTrainROI = new ROI();
        ROI objUnitROIForImage0 = new ROI();

        private UInt32[] m_intCameraGain = new UInt32[2];
        private int[] m_intLightChannel = new int[2];
        private int[] m_intStrobeIntensity = new int[2];

        private bool m_blnStopped = false, m_blnStopped_GrabImage = false, m_blnStopped_TransferImage = false, m_blnStopped_WaitFrame = false, m_blnStopped_AfterInspect, m_blnStopped_SaveImage = false;
        private bool m_blnStopped_MarkTest = false, m_blnStopped_PackageTest_MarkLightView = false, m_blnStopped_PackageTest_SideLightView = false, m_blnStopped_PackageTest_TopLightView = false, m_blnStopped_LeadTest = false, m_blnStopped_PackageColorTest = false;
        private Thread m_thThread, m_thSubThread_GrabImage, m_thSubThread_TransferImage, m_thSubThread_WaitFrame, m_thSubThread_AfterInspect, m_thSubThread_SaveImage;
        private Thread m_thSubThread_MarkTest, m_thSubThread_PackageTest_MarkLightView, m_thSubThread_PackageTest_SideLightView, m_thSubThread_PackageTest_TopLightView, m_thSubThread_LeadTest, m_thSubThread_PackageColorTest;
        private VisionIO m_objVisionIO;
        private CustomOption m_smCustomizeInfo;
        private ProductionInfo m_smProductionInfo;
        private VisionInfo m_smVisionInfo;
        private AVTVimba m_objAVTFireGrab;
        private TeliCamera m_objTeliCamera;
        private VisionComThread m_smComThread;
        private TCPIPIO m_smTCPIPIO;
        private RS232 m_thCOMMPort;

        // ---------------- Multitreading --------------------------------------

        private bool m_bSubTh1_GrabImage = false;
        private bool m_bSubTh1_TransferImage = false;
        private bool m_bSubTh1_WaitFrame = false;
        private bool m_bSubTh_MarkTest = false;
        private bool m_bSubTh_PackageTest_MarkLightView = false;
        private bool m_bSubTh_PackageTest_SideLightView = false;
        private bool m_bSubTh_PackageTest_TopLightView = false;
        private bool m_bSubTh_LeadTest = false;
        private bool m_bSubTh_PackageColorTest = false;
        private bool m_bSubTh_StartAfterInspect = false;
        private bool m_bSubTh_MarkTest_Result = false;
        private bool m_bSubTh_PackageTest_PackageSize_Result = false;
        private bool m_bSubTh_PackageTest_MarkLightView_Result = false;
        private bool m_bSubTh_PackageTest_SideLightView_Result = false;
        private bool m_bSubTh_PackageTest_TopLightView_Result = false;
        private bool m_bSubTh_LeadTest_Result = false;
        private bool m_bSubTh_PackageColorTest_Result = false;
        private bool m_bGrabImage1Done = false;
        private bool m_bGrabImage2Done = false;
        private bool m_bGrabImage3Done = false;
        private bool m_bGrabImage4Done = false;
        private bool m_bGrabImage5Done = false;
        private bool m_bGrabImage6Done = false;
        private bool m_bGrabImage7Done = false;
        private bool m_bGrabImage1Result = false;
        private bool m_bGrabImage2Result = false;
        private bool m_bGrabImage3Result = false;
        private bool m_bGrabImage4Result = false;
        private bool m_bGrabImage5Result = false;
        private bool m_bGrabImage6Result = false;
        private bool m_bGrabImage7Result = false;
        private bool m_bGrabImage1LoadDone = false;
        private bool m_bGrabImage2LoadDone = false;
        private bool m_bGrabImage3LoadDone = false;
        private bool m_bGrabImage4LoadDone = false;
        private bool m_bGrabImage5LoadDone = false;
        private bool m_bGrabImage6LoadDone = false;
        private bool m_bGrabImage7LoadDone = false;
        private bool m_bGrabImage1LoadResult = false;
        private bool m_bGrabImage2LoadResult = false;
        private bool m_bGrabImage3LoadResult = false;
        private bool m_bGrabImage4LoadResult = false;
        private bool m_bGrabImage5LoadResult = false;
        private bool m_bGrabImage6LoadResult = false;
        private bool m_bGrabImage7LoadResult = false;
        private bool m_bGrabImage1TriggerDone = false;
        private bool m_bGrabImage2TriggerDone = false;
        private bool m_bGrabImage3TriggerDone = false;
        private bool m_bGrabImage4TriggerDone = false;
        private bool m_bGrabImage5TriggerDone = false;
        private bool m_bGrabImage6TriggerDone = false;
        private bool m_bGrabImage7TriggerDone = false;
        private bool m_bGrabImage1TriggerResult = false;
        private bool m_bGrabImage2TriggerResult = false;
        private bool m_bGrabImage3TriggerResult = false;
        private bool m_bGrabImage4TriggerResult = false;
        private bool m_bGrabImage5TriggerResult = false;
        private bool m_bGrabImage6TriggerResult = false;
        private bool m_bGrabImage7TriggerResult = false;
        private bool m_bGrabImageFinalResult = false;
        private bool m_bPackageSizeTestDone = false;
        private bool m_bPackageSizePreTestDone = false;
        private bool m_bPackageSizePreTestResult = false;
        private bool m_bLeadBaseCenterPointDone = false;
        private bool m_bLeadBaseCenterPointResult = false;
        private ResulType m_eInspectionResult_MarkTest = ResulType.Pass;
        private ResulType m_eInspectionResult_PackageTest_Size = ResulType.Pass;
        private ResulType m_eInspectionResult_PackageTest_MarkLightView = ResulType.Pass;
        private ResulType m_eInspectionResult_PackageTest_SideLightView = ResulType.Pass;
        private ResulType m_eInspectionResult_PackageTest_TopLightView = ResulType.Pass;
        private ResulType m_eInspectionResult_LeadTest = ResulType.Pass;
        private ResulType m_eInspectionResult_PackageColorTest = ResulType.Pass;

        private ROI m_objSubTh1_RotateROI = new ROI();
        private ROI m_objSubTh2_RotateROI = new ROI();
        private ROI m_objSubTh3_RotateROI = new ROI();

        private int m_intOrientAngle = 0;

        private float m_fSubTh1_TotalRotateAngle = 0;
        private float m_fSubTh2_TotalRotateAngle = 0;
        private float m_fSubTh3_TotalRotateAngle = 0;

        //TCPIPIO
        private int m_intTCPIPResultID = -1;
        private float m_fOffsetX = 0;
        private float m_fOffsetY = 0;
        private float m_fOffsetAngle = 0;
        private bool m_blnStartVision_In = false;
        private bool m_blnEndVision_Out = true;
        private bool m_blnGrabbing_Out = false;
        private bool m_blnCheckOffset_In = false;
        private bool m_blnInPocketCheckUnit1_In = false;
        private bool m_blnInPocketReTest_In = false;
        private bool m_blnInPocketReCheckUnit2_In = false;
        private bool m_blnInPocketEndOfReTest_In = false;
        private bool m_blnInPocketRollbackRetest_In = false;
        private bool m_blnInPocketCheckEmpty_In = false;
        private bool m_blnRotatorSignal1_In = false;
        private bool m_blnRotatorSignal2_In = false;
        private bool m_blnPass1_Out = true;
        private bool m_blnPass2_Out = true;
        private bool m_blnOrientResult2_Out = false;
        private bool m_blnOrientResult1_Out = false;
        private bool m_blnUnitPresent_Out = true;
        private bool m_blnPackageFail_Out = false;        // Fail criteria: Package
        private bool m_blnEmptyUnit_Out = false;          // Fail criteria: Empty Unit           
        private bool m_blnWrongOrientation_Out = false;   // Fail criteria: Wrong Orientation
        private bool m_blnPositionReject_Out = false;     // Fail criteria: Position Reject
        private bool m_blnMarkFail_Out = false;           // Fail criteria: Mark
        private bool m_blnFailLead_Out = false;           // Fail criteria in Mark Orient : Trigger this IO when fail criteria is not mark
        private bool m_blnFailNoMark_Out = false;         // Fail criteria: no Mark
        private bool m_blnMarkData0_In = false;
        private bool m_blnMarkData1_In = false;
        private bool m_blnMarkData2_In = false;
        private bool m_blnMarkData3_In = false;
        private bool m_blnMarkData4_In = false;
        private bool m_blnMarkData5_In = false;
        #endregion

        //HiPerfTimer m_T1 = new HiPerfTimer();
        //string m_strTrack = "";
        //float m_fTimingPrev = 0;
        //float m_fTiming = 0;
        //string m_strResultTrack = "";
        bool blnReScanSOTAfterInspectionDone = false;
        int debugCount = 0;
        string strTrackHeadName = "V1";
        // Tracking Error
        private bool m_blnTrackingON_SaveImageBuffer = false;
        private string m_strTrackingData_SaveImageBuffer = "";
        private bool ShowLiterationOnly = false;
        private List<float> m_arrDontCareLeadAreaStartX = new List<float>();
        private List<float> m_arrDontCareLeadAreaStartY = new List<float>();
        private List<float> m_arrDontCareLeadAreaEndX = new List<float>();
        private List<float> m_arrDontCareLeadAreaEndY = new List<float>();
        private List<int> m_arrDontCareLeadDirection = new List<int>();

        public Vision1Process(CustomOption objCustomOption, ProductionInfo smProductionInfo, VisionInfo objVisionInfo,
            AVTVimba objAVTFireGrab, VisionComThread smComThread, RS232 thCOMMPort, TCPIPIO smTCPIPIO)
        {
            m_smCustomizeInfo = objCustomOption;
            m_smProductionInfo = smProductionInfo;
            m_smVisionInfo = objVisionInfo;
            m_objAVTFireGrab = objAVTFireGrab;
            m_smComThread = smComThread;
            m_smTCPIPIO = smTCPIPIO;
            m_thCOMMPort = thCOMMPort;

            // 2019 09 12 - CCENG: Change to init this buffer during Init Camera.
            //if (m_smVisionInfo.g_blnViewColorImage)
            //{
            //    m_arrPassCImage1Buffer = new CImageDrawing[BUFFERSIZE];
            //    m_arrPassCImage2Buffer = new CImageDrawing[BUFFERSIZE];
            //    m_arrPassCImage3Buffer = new CImageDrawing[BUFFERSIZE];
            //    m_arrPassCImage4Buffer = new CImageDrawing[BUFFERSIZE];
            //    m_arrPassCImage5Buffer = new CImageDrawing[BUFFERSIZE];
            //    m_arrFailCImage1Buffer = new CImageDrawing[BUFFERSIZE];
            //    m_arrFailCImage2Buffer = new CImageDrawing[BUFFERSIZE];
            //    m_arrFailCImage3Buffer = new CImageDrawing[BUFFERSIZE];
            //    m_arrFailCImage4Buffer = new CImageDrawing[BUFFERSIZE];
            //    m_arrFailCImage5Buffer = new CImageDrawing[BUFFERSIZE];

            //    for (int i = 0; i < BUFFERSIZE; i++)
            //    {
            //        m_arrPassCImage1Buffer[i] = new CImageDrawing(true);
            //        m_arrPassCImage2Buffer[i] = new CImageDrawing(true);
            //        m_arrPassCImage3Buffer[i] = new CImageDrawing(true);
            //        m_arrPassCImage4Buffer[i] = new CImageDrawing(true);
            //        m_arrPassCImage5Buffer[i] = new CImageDrawing(true);
            //        m_arrFailCImage1Buffer[i] = new CImageDrawing(true);
            //        m_arrFailCImage2Buffer[i] = new CImageDrawing(true);
            //        m_arrFailCImage3Buffer[i] = new CImageDrawing(true);
            //        m_arrFailCImage4Buffer[i] = new CImageDrawing(true);
            //        m_arrFailCImage5Buffer[i] = new CImageDrawing(true);
            //    }
            //}
            //else
            //{
            //    m_arrPassImage1Buffer = new ImageDrawing[BUFFERSIZE];
            //    m_arrPassImage2Buffer = new ImageDrawing[BUFFERSIZE];
            //    m_arrPassImage3Buffer = new ImageDrawing[BUFFERSIZE];
            //    m_arrPassImage4Buffer = new ImageDrawing[BUFFERSIZE];
            //    m_arrPassImage5Buffer = new ImageDrawing[BUFFERSIZE];
            //    m_arrFailImage1Buffer = new ImageDrawing[BUFFERSIZE];
            //    m_arrFailImage2Buffer = new ImageDrawing[BUFFERSIZE];
            //    m_arrFailImage3Buffer = new ImageDrawing[BUFFERSIZE];
            //    m_arrFailImage4Buffer = new ImageDrawing[BUFFERSIZE];
            //    m_arrFailImage5Buffer = new ImageDrawing[BUFFERSIZE];

            //    for (int i = 0; i < BUFFERSIZE; i++)
            //    {
            //        m_arrPassImage1Buffer[i] = new ImageDrawing(true);
            //        m_arrPassImage2Buffer[i] = new ImageDrawing(true);
            //        m_arrPassImage3Buffer[i] = new ImageDrawing(true);
            //        m_arrPassImage4Buffer[i] = new ImageDrawing(true);
            //        m_arrPassImage5Buffer[i] = new ImageDrawing(true);
            //        m_arrFailImage1Buffer[i] = new ImageDrawing(true);
            //        m_arrFailImage2Buffer[i] = new ImageDrawing(true);
            //        m_arrFailImage3Buffer[i] = new ImageDrawing(true);
            //        m_arrFailImage4Buffer[i] = new ImageDrawing(true);
            //        m_arrFailImage5Buffer[i] = new ImageDrawing(true);
            //    }
            //}
            //m_arrPassNoBuffer = new int[BUFFERSIZE];
            //m_arrFailNoBuffer = new int[BUFFERSIZE];
            //m_arrOrientationBuffer = new int[BUFFERSIZE];
            //m_arrRejectNameBuffer = new string[BUFFERSIZE];

            if ((m_smCustomizeInfo.g_intUseColorCamera & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
            {
                m_blnCustomWantColor = true;
            }

            if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                m_smTCPIPIO.ReceiveCommandEvent += new TCPIPIO.ReceiveCommandHandle(TakeAction_TCPIPIO);
            else
                m_smComThread.ReceiveCommandEvent += new VisionComThread.ReceiveCommandHandle(TakeAction);

            
            //create vision io object
            m_objVisionIO = new VisionIO(m_smVisionInfo.g_strVisionName, m_smVisionInfo.g_strVisionDisplayName,
                                         m_smVisionInfo.g_intVisionIndex, m_smVisionInfo.g_intVisionSameCount,
                                         m_smVisionInfo.g_strVisionNameRemark, 0);

            //List<string> arrThreadNameBF = new List<string>();
            //List<string> arrThreadNameAF = new List<string>();
            //arrThreadNameBF = ProcessTh.GetThreadsName("SRMVision");

            m_thThread = new Thread(new ThreadStart(UpdateProgress));
            m_thThread.IsBackground = true;
            m_thThread.Priority = ThreadPriority.Highest;
            m_thThread.Start();

            m_thSubThread_GrabImage = new Thread(new ThreadStart(UpdateSubProgress_GrabImage));
            m_thSubThread_GrabImage.IsBackground = true;
            m_thSubThread_GrabImage.Priority = ThreadPriority.Highest;
            m_thSubThread_GrabImage.Start();

            if (m_blnCustomWantColor || m_smVisionInfo.g_intGrabMode == 2)
            {
                m_thSubThread_TransferImage = new Thread(new ThreadStart(UpdateSubProgress_TransferImage));
                m_thSubThread_TransferImage.IsBackground = true;
                m_thSubThread_TransferImage.Priority = ThreadPriority.Highest;
                m_thSubThread_TransferImage.Start();

                m_thSubThread_WaitFrame = new Thread(new ThreadStart(UpdateSubProgress_WaitFrame));
                m_thSubThread_WaitFrame.IsBackground = true;
                m_thSubThread_WaitFrame.Priority = ThreadPriority.Highest;
                m_thSubThread_WaitFrame.Start();
            }
            else
            {
                m_blnStopped_TransferImage = true;
                m_blnStopped_WaitFrame = true;
            }

            m_thSubThread_SaveImage = new Thread(new ThreadStart(UpdateSubProgress_SaveImage));
            m_thSubThread_SaveImage.IsBackground = true;
            m_thSubThread_SaveImage.Priority = ThreadPriority.Lowest;
            m_thSubThread_SaveImage.Start();

            if (((m_smCustomizeInfo.g_intWantMark & (1 << m_smVisionInfo.g_intVisionPos)) > 0) || ((m_smCustomizeInfo.g_intWantOrient & (1 << m_smVisionInfo.g_intVisionPos)) > 0))
            {
                m_thSubThread_MarkTest = new Thread(new ThreadStart(UpdateSubProgress_MarkTest));
                m_thSubThread_MarkTest.IsBackground = true;
                m_thSubThread_MarkTest.Priority = ThreadPriority.Highest;
                m_thSubThread_MarkTest.Start();
            }

            if ((m_smCustomizeInfo.g_intWantPackage & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
            {
                m_thSubThread_PackageTest_MarkLightView = new Thread(new ThreadStart(UpdateSubProgress_PackageTest_MarkLightView));
                m_thSubThread_PackageTest_MarkLightView.IsBackground = true;
                m_thSubThread_PackageTest_MarkLightView.Priority = ThreadPriority.Highest;
                m_thSubThread_PackageTest_MarkLightView.Start();

                m_thSubThread_PackageTest_SideLightView = new Thread(new ThreadStart(UpdateSubProgress_PackageTest_SideLightView));
                m_thSubThread_PackageTest_SideLightView.IsBackground = true;
                m_thSubThread_PackageTest_SideLightView.Priority = ThreadPriority.Highest;
                m_thSubThread_PackageTest_SideLightView.Start();

                m_thSubThread_PackageTest_TopLightView = new Thread(new ThreadStart(UpdateSubProgress_PackageTest_TopLightView));
                m_thSubThread_PackageTest_TopLightView.IsBackground = true;
                m_thSubThread_PackageTest_TopLightView.Priority = ThreadPriority.Highest;
                m_thSubThread_PackageTest_TopLightView.Start();
            }
            else
            {
                m_blnStopped_PackageTest_MarkLightView = true;
                m_blnStopped_PackageTest_SideLightView = true;
                m_blnStopped_PackageTest_TopLightView = true;
            }

            if ((m_smCustomizeInfo.g_intWantLead & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
            {
                m_thSubThread_LeadTest = new Thread(new ThreadStart(UpdateSubProgress_LeadTest));
                m_thSubThread_LeadTest.IsBackground = true;
                m_thSubThread_LeadTest.Priority = ThreadPriority.Highest;
                m_thSubThread_LeadTest.Start();
            }
            else
            {
                m_blnStopped_LeadTest = true;
            }

            if (m_blnCustomWantColor)
            {
                m_thSubThread_PackageColorTest = new Thread(new ThreadStart(UpdateSubProgress_PackageColorTest));
                m_thSubThread_PackageColorTest.IsBackground = true;
                m_thSubThread_PackageColorTest.Priority = ThreadPriority.Highest;
                m_thSubThread_PackageColorTest.Start();
            }
            else
            {
                m_blnStopped_PackageColorTest = true;
            }

            if (((m_smCustomizeInfo.g_intWantPackage & (1 << m_smVisionInfo.g_intVisionPos)) > 0) || ((m_smCustomizeInfo.g_intWantLead & (1 << m_smVisionInfo.g_intVisionPos)) > 0))
            {
                m_thSubThread_AfterInspect = new Thread(new ThreadStart(UpdateSubProgress_AfterInspect));
                m_thSubThread_AfterInspect.IsBackground = true;
                m_thSubThread_AfterInspect.Priority = ThreadPriority.Normal;
                m_thSubThread_AfterInspect.Start();
            }

            //Thread.Sleep(500);
            //arrThreadNameAF = ProcessTh.GetThreadsName("SRMVision");
            //ProcessTh.GetDifferentThreadsName(arrThreadNameAF, arrThreadNameBF, "V1a", 0x04);

            if (m_smVisionInfo.g_strVisionName == "BottomOrient")
                strTrackHeadName = "VO";
            else
                strTrackHeadName = "VM";
        }

        public Vision1Process(CustomOption objCustomOption, ProductionInfo smProductionInfo, VisionInfo objVisionInfo,
            TeliCamera objTeliCamera, VisionComThread smComThread, RS232 thCOMMPort, TCPIPIO smTCPIPIO)
        {
            m_smCustomizeInfo = objCustomOption;
            m_smProductionInfo = smProductionInfo;
            m_smVisionInfo = objVisionInfo;
            m_objTeliCamera = objTeliCamera;
            m_smComThread = smComThread;
            m_smTCPIPIO = smTCPIPIO;
            m_thCOMMPort = thCOMMPort;

            // 2019 09 12 - CCENG: Change to init this buffer during Init Camera.
            //if (m_smVisionInfo.g_blnViewColorImage)
            //{
            //    m_arrPassCImage1Buffer = new CImageDrawing[BUFFERSIZE];
            //    m_arrPassCImage2Buffer = new CImageDrawing[BUFFERSIZE];
            //    m_arrPassCImage3Buffer = new CImageDrawing[BUFFERSIZE];
            //    m_arrPassCImage4Buffer = new CImageDrawing[BUFFERSIZE];
            //    m_arrPassCImage5Buffer = new CImageDrawing[BUFFERSIZE];
            //    m_arrFailCImage1Buffer = new CImageDrawing[BUFFERSIZE];
            //    m_arrFailCImage2Buffer = new CImageDrawing[BUFFERSIZE];
            //    m_arrFailCImage3Buffer = new CImageDrawing[BUFFERSIZE];
            //    m_arrFailCImage4Buffer = new CImageDrawing[BUFFERSIZE];
            //    m_arrFailCImage5Buffer = new CImageDrawing[BUFFERSIZE];

            //    for (int i = 0; i < BUFFERSIZE; i++)
            //    {
            //        m_arrPassCImage1Buffer[i] = new CImageDrawing(true);
            //        m_arrPassCImage2Buffer[i] = new CImageDrawing(true);
            //        m_arrPassCImage3Buffer[i] = new CImageDrawing(true);
            //        m_arrPassCImage4Buffer[i] = new CImageDrawing(true);
            //        m_arrPassCImage5Buffer[i] = new CImageDrawing(true);
            //        m_arrFailCImage1Buffer[i] = new CImageDrawing(true);
            //        m_arrFailCImage2Buffer[i] = new CImageDrawing(true);
            //        m_arrFailCImage3Buffer[i] = new CImageDrawing(true);
            //        m_arrFailCImage4Buffer[i] = new CImageDrawing(true);
            //        m_arrFailCImage5Buffer[i] = new CImageDrawing(true);
            //    }
            //}
            //else
            //{
            //    m_arrPassImage1Buffer = new ImageDrawing[BUFFERSIZE];
            //    m_arrPassImage2Buffer = new ImageDrawing[BUFFERSIZE];
            //    m_arrPassImage3Buffer = new ImageDrawing[BUFFERSIZE];
            //    m_arrPassImage4Buffer = new ImageDrawing[BUFFERSIZE];
            //    m_arrPassImage5Buffer = new ImageDrawing[BUFFERSIZE];
            //    m_arrFailImage1Buffer = new ImageDrawing[BUFFERSIZE];
            //    m_arrFailImage2Buffer = new ImageDrawing[BUFFERSIZE];
            //    m_arrFailImage3Buffer = new ImageDrawing[BUFFERSIZE];
            //    m_arrFailImage4Buffer = new ImageDrawing[BUFFERSIZE];
            //    m_arrFailImage5Buffer = new ImageDrawing[BUFFERSIZE];

            //    for (int i = 0; i < BUFFERSIZE; i++)
            //    {
            //        m_arrPassImage1Buffer[i] = new ImageDrawing(true);
            //        m_arrPassImage2Buffer[i] = new ImageDrawing(true);
            //        m_arrPassImage3Buffer[i] = new ImageDrawing(true);
            //        m_arrPassImage4Buffer[i] = new ImageDrawing(true);
            //        m_arrPassImage5Buffer[i] = new ImageDrawing(true);
            //        m_arrFailImage1Buffer[i] = new ImageDrawing(true);
            //        m_arrFailImage2Buffer[i] = new ImageDrawing(true);
            //        m_arrFailImage3Buffer[i] = new ImageDrawing(true);
            //        m_arrFailImage4Buffer[i] = new ImageDrawing(true);
            //        m_arrFailImage5Buffer[i] = new ImageDrawing(true);
            //    }
            //}
            //m_arrPassNoBuffer = new int[BUFFERSIZE];
            //m_arrFailNoBuffer = new int[BUFFERSIZE];
            //m_arrOrientationBuffer = new int[BUFFERSIZE];
            //m_arrRejectNameBuffer = new string[BUFFERSIZE];

            if ((m_smCustomizeInfo.g_intUseColorCamera & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
            {
                m_blnCustomWantColor = true;
            }

            if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                m_smTCPIPIO.ReceiveCommandEvent += new TCPIPIO.ReceiveCommandHandle(TakeAction_TCPIPIO);
            else
                m_smComThread.ReceiveCommandEvent += new VisionComThread.ReceiveCommandHandle(TakeAction);
            
            //create vision io object
            m_objVisionIO = new VisionIO(m_smVisionInfo.g_strVisionName, m_smVisionInfo.g_strVisionDisplayName,
                                         m_smVisionInfo.g_intVisionIndex, m_smVisionInfo.g_intVisionSameCount,
                                         m_smVisionInfo.g_strVisionNameRemark, 0);

            //List<string> arrThreadNameBF = new List<string>();
            //List<string> arrThreadNameAF = new List<string>();
            //arrThreadNameBF = ProcessTh.GetThreadsName("SRMVision");

            m_thThread = new Thread(new ThreadStart(UpdateProgress));
            m_thThread.IsBackground = true;
            m_thThread.Priority = ThreadPriority.Highest;
            m_thThread.Start();

            m_thSubThread_GrabImage = new Thread(new ThreadStart(UpdateSubProgress_GrabImage));
            m_thSubThread_GrabImage.IsBackground = true;
            m_thSubThread_GrabImage.Priority = ThreadPriority.Highest;
            m_thSubThread_GrabImage.Start();

            if (m_blnCustomWantColor || m_smVisionInfo.g_intGrabMode == 2)
            {
                m_thSubThread_TransferImage = new Thread(new ThreadStart(UpdateSubProgress_TransferImage));
                m_thSubThread_TransferImage.IsBackground = true;
                m_thSubThread_TransferImage.Priority = ThreadPriority.Highest;
                m_thSubThread_TransferImage.Start();

                m_thSubThread_WaitFrame = new Thread(new ThreadStart(UpdateSubProgress_WaitFrame));
                m_thSubThread_WaitFrame.IsBackground = true;
                m_thSubThread_WaitFrame.Priority = ThreadPriority.Highest;
                m_thSubThread_WaitFrame.Start();
            }
            else
            {
                m_blnStopped_TransferImage = true;
                m_blnStopped_WaitFrame = true;
            }

            m_thSubThread_SaveImage = new Thread(new ThreadStart(UpdateSubProgress_SaveImage));
            m_thSubThread_SaveImage.IsBackground = true;
            m_thSubThread_SaveImage.Priority = ThreadPriority.Lowest;
            m_thSubThread_SaveImage.Start();

            if (((m_smCustomizeInfo.g_intWantMark & (1 << m_smVisionInfo.g_intVisionPos)) > 0) || ((m_smCustomizeInfo.g_intWantOrient & (1 << m_smVisionInfo.g_intVisionPos)) > 0))
            {
                m_thSubThread_MarkTest = new Thread(new ThreadStart(UpdateSubProgress_MarkTest));
                m_thSubThread_MarkTest.IsBackground = true;
                m_thSubThread_MarkTest.Priority = ThreadPriority.Highest;
                m_thSubThread_MarkTest.Start();
            }

            if ((m_smCustomizeInfo.g_intWantPackage & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
            {
                m_thSubThread_PackageTest_MarkLightView = new Thread(new ThreadStart(UpdateSubProgress_PackageTest_MarkLightView));
                m_thSubThread_PackageTest_MarkLightView.IsBackground = true;
                m_thSubThread_PackageTest_MarkLightView.Priority = ThreadPriority.Highest;
                m_thSubThread_PackageTest_MarkLightView.Start();

                m_thSubThread_PackageTest_SideLightView = new Thread(new ThreadStart(UpdateSubProgress_PackageTest_SideLightView));
                m_thSubThread_PackageTest_SideLightView.IsBackground = true;
                m_thSubThread_PackageTest_SideLightView.Priority = ThreadPriority.Highest;
                m_thSubThread_PackageTest_SideLightView.Start();

                m_thSubThread_PackageTest_TopLightView = new Thread(new ThreadStart(UpdateSubProgress_PackageTest_TopLightView));
                m_thSubThread_PackageTest_TopLightView.IsBackground = true;
                m_thSubThread_PackageTest_TopLightView.Priority = ThreadPriority.Highest;
                m_thSubThread_PackageTest_TopLightView.Start();
            }
            else
            {
                m_blnStopped_PackageTest_MarkLightView = true;
                m_blnStopped_PackageTest_SideLightView = true;
                m_blnStopped_PackageTest_TopLightView = true;
            }

            if ((m_smCustomizeInfo.g_intWantLead & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
            {
                m_thSubThread_LeadTest = new Thread(new ThreadStart(UpdateSubProgress_LeadTest));
                m_thSubThread_LeadTest.IsBackground = true;
                m_thSubThread_LeadTest.Priority = ThreadPriority.Highest;
                m_thSubThread_LeadTest.Start();
            }
            else
            {
                m_blnStopped_LeadTest = true;
            }

            if (m_blnCustomWantColor)
            {
                m_thSubThread_PackageColorTest = new Thread(new ThreadStart(UpdateSubProgress_PackageColorTest));
                m_thSubThread_PackageColorTest.IsBackground = true;
                m_thSubThread_PackageColorTest.Priority = ThreadPriority.Highest;
                m_thSubThread_PackageColorTest.Start();
            }
            else
            {
                m_blnStopped_PackageColorTest = true;
            }

            if (((m_smCustomizeInfo.g_intWantPackage & (1 << m_smVisionInfo.g_intVisionPos)) > 0) || ((m_smCustomizeInfo.g_intWantLead & (1 << m_smVisionInfo.g_intVisionPos)) > 0))
            {
                m_thSubThread_AfterInspect = new Thread(new ThreadStart(UpdateSubProgress_AfterInspect));
                m_thSubThread_AfterInspect.IsBackground = true;
                m_thSubThread_AfterInspect.Priority = ThreadPriority.Normal;
                m_thSubThread_AfterInspect.Start();
            }

            //Thread.Sleep(500);
            //arrThreadNameAF = ProcessTh.GetThreadsName("SRMVision");
            //ProcessTh.GetDifferentThreadsName(arrThreadNameAF, arrThreadNameBF, "V1b", 0x04);

            if (m_smVisionInfo.g_strVisionName == "BottomOrient")
                strTrackHeadName = "V1";
            else
                strTrackHeadName = "V2";
        }

        /// <summary>
        /// Grab image
        /// </summary>      
        /// <returns>true = successfully grab image, false = fail to grab image</returns>
        public bool GrabImageWithSetIntensity()
        {
            m_smVisionInfo.g_objGrabTime.Start();
            bool blnSuccess = true;
            HiPerfTimer timer_GrabTime = new HiPerfTimer();

            int intExposureTime = (int)Math.Ceiling(m_smVisionInfo.g_fCameraShuttle * 0.02f);   // 0.02 == 20 nano second.

            m_objAVTFireGrab.DiscardFrame();
            for (int i = 0; i < m_intGrabRequire; i++)
            {
                #region if more than 1 image need to be captured
                // Set light source channel ON/OFF
                if (m_intGrabRequire > 0)
                {
                    // change light source intensity for different image's effects
                    for (int j = 0; j < m_smVisionInfo.g_arrLightSource.Count; j++)
                    {
                        int intValueNo = 0;

                        // Due to some light source only ON for second image so its intensity value is at array no. 0.
                        // So we need to loop to find which array no. is for that image
                        for (int k = 1; k < m_smVisionInfo.g_arrLightSource[j].ref_arrValue.Count; k++)
                        {
                            // if this image no is in array k
                            if (m_smVisionInfo.g_arrLightSource[j].ref_arrImageNo != null)
                            {
                                if (m_smVisionInfo.g_arrLightSource[j].ref_arrImageNo[k] == i)
                                {
                                    intValueNo = k;
                                    break;
                                }
                            }
                        }

                        // Set camera gain
                        if (m_intCameraGainPrev != m_smVisionInfo.g_arrCameraGain[i])
                        {
                            m_objAVTFireGrab.SetCameraParameter(2, m_smVisionInfo.g_arrCameraGain[i]);
                            m_intCameraGainPrev = m_smVisionInfo.g_arrCameraGain[i];
                        }

                        switch (m_smCustomizeInfo.g_blnLEDiControl)
                        {
                            case true:
                                if ((m_smVisionInfo.g_arrLightSource[j].ref_intSeqNo & (0x01 << i)) > 0)
                                {
                                    if (m_arrCameraIntensityPrev[j] != m_smVisionInfo.g_arrLightSource[j].ref_arrValue[intValueNo])
                                    {
                                        LEDi_Control.SetIntensity(m_smVisionInfo.g_arrLightSource[j].ref_intPortNo,
                                           m_smVisionInfo.g_arrLightSource[j].ref_intChannel,
                                           Convert.ToByte(m_smVisionInfo.g_arrLightSource[j].ref_arrValue[intValueNo]));

                                        m_arrCameraIntensityPrev[j] = m_smVisionInfo.g_arrLightSource[j].ref_arrValue[intValueNo];
                                        Thread.Sleep(5);
                                    }
                                }
                                else
                                {
                                    if (m_arrCameraIntensityPrev[j] != 0)
                                    {
                                        LEDi_Control.SetIntensity(m_smVisionInfo.g_arrLightSource[j].ref_intPortNo,
                                            m_smVisionInfo.g_arrLightSource[j].ref_intChannel, Convert.ToByte(0));

                                        m_arrCameraIntensityPrev[j] = 0;
                                        Thread.Sleep(5);
                                    }
                                }
                                break;
                            case false:
                                if ((m_smVisionInfo.g_arrLightSource[j].ref_intSeqNo & (0x01 << i)) > 0)
                                {
                                    if (m_arrCameraIntensityPrev[j] != m_smVisionInfo.g_arrLightSource[j].ref_arrValue[intValueNo])
                                    {
                                        TCOSIO_Control.SetIntensity(m_smVisionInfo.g_arrLightSource[j].ref_intPortNo,
                                            m_smVisionInfo.g_arrLightSource[j].ref_intChannel,
                                            m_smVisionInfo.g_arrLightSource[j].ref_arrValue[intValueNo]);

                                        m_arrCameraIntensityPrev[j] = m_smVisionInfo.g_arrLightSource[j].ref_arrValue[intValueNo];
                                        Thread.Sleep(2);
                                    }
                                }
                                else
                                {
                                    if (m_arrCameraIntensityPrev[j] != 0)
                                    {
                                        TCOSIO_Control.SetIntensity(m_smVisionInfo.g_arrLightSource[j].ref_intPortNo,
                                            m_smVisionInfo.g_arrLightSource[j].ref_intChannel, 0);

                                        m_arrCameraIntensityPrev[j] = 0;
                                        Thread.Sleep(2);
                                    }
                                }
                                break;
                        }
                    }
                }
                #endregion

                if (i > 0) // for second image and third image
                {
                    timer_GrabTime.Stop();
                    if ((m_objAVTFireGrab.ref_intNextGrabDelay - timer_GrabTime.Duration) > 0)
                        Thread.Sleep((int)(m_objAVTFireGrab.ref_intNextGrabDelay - timer_GrabTime.Duration));
                }

                if (!m_objAVTFireGrab.Grab())
                {
                    blnSuccess = false;
                    m_blnForceStopProduction = true;
                }

                if (i < m_intGrabRequire - 1)
                {
                    timer_GrabTime.Start();
                    Thread.Sleep(intExposureTime);
                }
                else
                {
                    Thread.Sleep(Math.Max(intExposureTime, 4));
                }
            }

            if (blnSuccess)
            {
                SetGrabDone(false);
                m_smVisionInfo.g_objTransferTime.Start();

                for (int i = 0; i < m_intGrabRequire; i++)
                {
                    if (m_objAVTFireGrab.GetFrame(i))
                    {
                        if (m_objAVTFireGrab.ConvertFrame(i))
                        {
                            if (m_smVisionInfo.g_blnViewColorImage)
                            {
                                m_smVisionInfo.g_objMemoryColorImage.LoadImageFromMemory(m_objAVTFireGrab.ref_ptrImagePointer);
                                m_smVisionInfo.g_objMemoryColorImage.CopyTo(ref m_smVisionInfo.g_arrColorImages, i);
                            }
                            else
                            {
                                m_smVisionInfo.g_objMemoryImage.LoadImageFromMemory(m_objAVTFireGrab.ref_ptrImagePointer);
                                m_smVisionInfo.g_objMemoryImage.CopyTo(ref m_smVisionInfo.g_arrImages, i);
                                m_smVisionInfo.g_arrImages[i].AddGain(m_smVisionInfo.g_arrImageGain[i]);
                            }
                        }
                    }
                }
            }
            else
                SetGrabDone(false);

            for (int i = 0; i < m_intGrabRequire; i++)
            {
                m_objAVTFireGrab.ReleaseImage(i);
            }

            if (m_objAVTFireGrab.ref_strErrorText != "")
            {
                m_smVisionInfo.g_strErrorMessage = m_objAVTFireGrab.ref_strErrorText;
                m_smVisionInfo.g_objTransferTime.Stop();
                return false;
            }
            else
            {
                //AttachImageToROI();
                m_smVisionInfo.g_blnLoadFile = false;
                m_smVisionInfo.g_objTransferTime.Stop();
                return true;
            }
        }
        private bool IsCameraInitDone()
        {
            switch (m_smVisionInfo.g_strCameraModel)
            {
                case "AVT":
                    return m_objAVTFireGrab.ref_blnCameraInitDone;
                    break;
                case "Teli":
                default:
                    return m_objTeliCamera.IsCameraInitDone();
                    break;
            }
        }
        public bool GrabImage(bool blnForInspection)
        {
            //m_smVisionInfo.g_objGrabTime.Reset();
            //m_smVisionInfo.g_objTransferTime.Reset();

            // 2021 06 27 - Blank image before new grab.
            if (m_smProductionInfo.g_blnBlankImageBeforeGrab)
            {
                if (!m_smProductionInfo.g_blnAllRunGrabWithoutUseImage && IsCameraInitDone())
                {
                    for (int i = 0; i < m_smVisionInfo.g_arrImages.Count; i++)
                    {
                        m_smVisionInfo.g_arrImages[i].SetImageToBlack();
                    }
                }
            }

            if (m_smVisionInfo.g_intLightControllerType == 2)
            {
                if (m_smVisionInfo.g_strCameraModel == "AVT")
                    return GrabImage_Sequence_GetFrameBeforeNextGrab_NoSetIntensity_AVT(blnForInspection);
                else if (m_smVisionInfo.g_strCameraModel == "Teli")
                {
                    if (m_blnCustomWantColor)
                        return GrabImage_Sequence_NoSetIntensity_Teli_HighSpeedOrColor(blnForInspection);
                    else
                    {
                        if (m_smVisionInfo.g_intGrabMode == 0)
                            return GrabImage_Sequence_NoSetIntensity_Teli(blnForInspection);
                        else if (m_smVisionInfo.g_intGrabMode == 1)
                            return GrabImage_Sequence_NoSetIntensity_Teli_GrabAllFirst(blnForInspection);
                        else
                            return GrabImage_Sequence_NoSetIntensity_Teli_HighSpeedOrColor(blnForInspection);
                    }
                }
            }

            if (m_smVisionInfo.g_strCameraModel == "Teli")
            {
                return GrabImage_Teli(blnForInspection);
            }
            else
            {
                return GrabImage_Normal_GetFrameBeforeNextGrab_NoSetIntensity_AVTVimba(blnForInspection);
            }
        }

        public bool GrabImage_Teli(bool blnForInspection)
        {
            if (!m_objTeliCamera.IsCameraInitDone())
            {
                m_bGrabImage1Result = m_bGrabImage2Result = m_bGrabImage3Result = m_bGrabImage4Result = m_bGrabImage5Result = m_bGrabImage6Result = m_bGrabImage7Result = true;
                m_bGrabImage1Done = m_bGrabImage2Done = m_bGrabImage3Done = m_bGrabImage4Done = m_bGrabImage5Done = m_bGrabImage6Done = m_bGrabImage7Done = true;
                m_smVisionInfo.g_strErrorMessage = "Camera No Connected";
                return true;
            }
            // Using Teli Camera
            m_smVisionInfo.g_objGrabTime.Start();

            Thread.Sleep(m_smVisionInfo.g_intCameraGrabDelay);

            bool blnSuccess = true;
            bool blnSeparateGrab = m_smVisionInfo.g_blnSeparateGrab;
            int intSelectedImage = m_smVisionInfo.g_intSelectedImage;

            TrackLog objTL = new TrackLog();
            float fTotalGrabTime = 0f;
            HiPerfTimer timer_TotalTime = new HiPerfTimer();
            HiPerfTimer timer_TotalGrabTime = new HiPerfTimer();
            timer_TotalTime.Start();

            int intExposureTime = (int)Math.Ceiling(m_smVisionInfo.g_arrCameraShuttle[0] * 0.001f);  // For Teli, Shuttle 1 == 1 microsecond

            m_objTeliCamera.DiscardFrame();

            for (int i = 0; i < m_intGrabRequire; i++)
            {
                if (blnSeparateGrab)
                {
                    if (i != intSelectedImage)
                        continue;
                }

                if (i > 0) // for second image and third image
                {
                    if (m_objTeliCamera.WaitFrameReady())
                    {
                        if (m_smVisionInfo.g_blnViewColorImage)
                        {
                            m_smVisionInfo.g_objMemoryColorImage.SetImageSize(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight);
                            m_smVisionInfo.g_objMemoryColorImage.LoadImageFromMemory(m_objTeliCamera.GetImagePointer());
                            m_smVisionInfo.g_objMemoryColorImage.CopyTo(ref m_smVisionInfo.g_arrColorImages, i - 1);
                        }
                        else
                        {
                            m_smVisionInfo.g_objMemoryImage.SetImageSize(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight);
                            m_smVisionInfo.g_objMemoryImage.LoadImageFromMemory(m_objTeliCamera.GetImagePointer());
                            m_smVisionInfo.g_objMemoryImage.CopyTo(ref m_smVisionInfo.g_arrImages, i - 1);
                            m_smVisionInfo.g_arrImages[i - 1].AddGain(m_smVisionInfo.g_arrImageGain[i - 1]);
                        }

                        // 2020 12 30 - CCENG: Do image processing to increase image contrast. (to solve mark no enough contrast case)
                        if (i == 1)
                        {
                            if (m_smVisionInfo.g_blnEnhanceImage_Enable)
                            {
                                if (m_smVisionInfo.g_intEnhanceImage_Close > 0)
                                    m_smVisionInfo.g_arrImages[i - 1].AddCloseMorphology(m_smVisionInfo.g_intEnhanceImage_Close);
                                if (m_smVisionInfo.g_intEnhanceImage_Open > 0)
                                    m_smVisionInfo.g_arrImages[i - 1].AddOpenMorphology(m_smVisionInfo.g_intEnhanceImage_Open);
                                if (m_smVisionInfo.g_intEnhanceImage_Dilate > 0)
                                    m_smVisionInfo.g_arrImages[i - 1].AddDilate(m_smVisionInfo.g_intEnhanceImage_Dilate);
                                if (m_smVisionInfo.g_intEnhanceImage_Offset != 0)
                                    m_smVisionInfo.g_arrImages[i - 1].AddOffset(m_smVisionInfo.g_intEnhanceImage_Offset);
                                if (m_smVisionInfo.g_fEnhanceImage_Gain != 1f)
                                    m_smVisionInfo.g_arrImages[i - 1].AddGain(m_smVisionInfo.g_fEnhanceImage_Gain);
                            }
                        }

                        timer_TotalGrabTime.Stop();
                        fTotalGrabTime = fTotalGrabTime + timer_TotalGrabTime.Duration;

                    }
                    else
                    {
                        blnSuccess = false;
                        m_blnForceStopProduction = true;
                    }

                }

                #region if more than 1 image need to be captured
                // Set light source channel ON/OFF
                if (m_intGrabRequire > 1)
                {
                    // Set camera gain
                    if (m_intCameraGainPrev != m_smVisionInfo.g_arrCameraGain[i])
                    {
                        m_objTeliCamera.SetCameraParameter(2, m_smVisionInfo.g_arrCameraGain[i]);
                        m_intCameraGainPrev = m_smVisionInfo.g_arrCameraGain[i];
                        //if (m_objTeliCamera.ref_intSetGainDelay != 0)
                        //    Thread.Sleep(m_objTeliCamera.ref_intSetGainDelay);
                    }

                    // Set camera shuttle
                    if (m_fCameraShuttlePrev != m_smVisionInfo.g_arrCameraShuttle[i])
                    {
                        m_objTeliCamera.SetCameraParameter(1, m_smVisionInfo.g_arrCameraShuttle[i]);
                        m_fCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[i];
                        //if (m_objTeliCamera.ref_intSetGainDelay != 0)
                        //    Thread.Sleep(m_objTeliCamera.ref_intSetGainDelay);

                        intExposureTime = (int)Math.Ceiling(m_smVisionInfo.g_arrCameraShuttle[i] * 0.0001f);
                    }
                }
                #endregion

                timer_TotalGrabTime.Start();

                if (blnSuccess)//2021-10-21 ZJYEOH : No need to grab anymore if not success, as this will reset the camera error message
                {
                    if (!m_objTeliCamera.Grab())
                    {
                        blnSuccess = false;
                        m_blnForceStopProduction = true;
                    }
                }

                if (i < m_intGrabRequire - 1)
                {
                    Thread.Sleep(intExposureTime);
                }
                else
                {
                    Thread.Sleep(Math.Max(intExposureTime, 10));
                }
            }

            if (!m_objTeliCamera.WaitFrameReady())
            {
                blnSuccess = false;
                m_blnForceStopProduction = true;
            }

            if (blnSuccess)
            {
                SetGrabDone(blnForInspection);
                m_smVisionInfo.g_objTransferTime.Start();

                if (m_objTeliCamera.GetFrame(m_intGrabRequire - 1))
                {
                    if (m_objTeliCamera.ConvertFrame(m_intGrabRequire - 1))
                    {
                        if (m_smVisionInfo.g_blnViewColorImage)
                        {
                            m_smVisionInfo.g_objMemoryColorImage.SetImageSize(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight);
                            m_smVisionInfo.g_objMemoryColorImage.LoadImageFromMemory(m_objTeliCamera.GetImagePointer());
                            m_smVisionInfo.g_objMemoryColorImage.CopyTo(ref m_smVisionInfo.g_arrColorImages, m_intGrabRequire - 1);
                        }
                        else
                        {
                            m_smVisionInfo.g_objMemoryImage.SetImageSize(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight);
                            m_smVisionInfo.g_objMemoryImage.LoadImageFromMemory(m_objTeliCamera.GetImagePointer());
                            m_smVisionInfo.g_objMemoryImage.CopyTo(ref m_smVisionInfo.g_arrImages, m_intGrabRequire - 1);
                            m_smVisionInfo.g_arrImages[m_intGrabRequire - 1].AddGain(m_smVisionInfo.g_arrImageGain[m_intGrabRequire - 1]);
                        }
                    }
                }

                timer_TotalGrabTime.Stop();
                fTotalGrabTime = fTotalGrabTime + timer_TotalGrabTime.Duration;
            }
            else
                SetGrabDone(blnForInspection);

            m_bGrabImage1Done = m_bGrabImage2Done = m_bGrabImage3Done = m_bGrabImage4Done = m_bGrabImage5Done = m_bGrabImage6Done = m_bGrabImage7Done = true;
            m_bGrabImage1Result = m_bGrabImage2Result = m_bGrabImage3Result = m_bGrabImage4Result = m_bGrabImage5Result = m_bGrabImage6Result = m_bGrabImage7Result = true;

            //2021-10-21 ZJYEOH : Set Image to Black if camera fail
            if (!blnSuccess)
            {
                for (int i = 0; i < m_smVisionInfo.g_arrImages.Count; i++)
                {
                    if (m_smVisionInfo.g_blnViewColorImage)
                    {
                        m_smVisionInfo.g_arrColorImages[i].SetImageToBlack();
                        m_smVisionInfo.g_arrColorRotatedImages[i].SetImageToBlack();
                    }
                    m_smVisionInfo.g_arrImages[i].SetImageToBlack();
                    m_smVisionInfo.g_arrRotatedImages[i].SetImageToBlack();
                }
            }

            if (m_objTeliCamera.GetErrorMessage() != "")
            {
                m_smVisionInfo.g_strErrorMessage = m_objTeliCamera.GetErrorMessage();
                m_smVisionInfo.ALL_VM_UpdatePictureBox = true;
                m_smVisionInfo.g_objTransferTime.Stop();

                timer_TotalTime.Stop();
                //objTL.WriteLine("Total grab time = " + fTotalGrabTime.ToString());
                //objTL.WriteLine("Total time = " + timer_TotalTime.Duration.ToString());
                return false;
            }
            else
            {
                // Set camera gain
                if (m_intCameraGainPrev != m_smVisionInfo.g_arrCameraGain[0])
                {
                    m_objTeliCamera.SetCameraParameter(2, m_smVisionInfo.g_arrCameraGain[0]);
                    m_intCameraGainPrev = m_smVisionInfo.g_arrCameraGain[0];
                }

                // Set camera shuttle
                if (m_fCameraShuttlePrev != m_smVisionInfo.g_arrCameraShuttle[0])
                {
                    m_objTeliCamera.SetCameraParameter(1, m_smVisionInfo.g_arrCameraShuttle[0]);
                    m_fCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[0];
                }

                //AttachImageToROI();
                m_smVisionInfo.g_blnLoadFile = false;
                m_smVisionInfo.ALL_VM_UpdatePictureBox = true;
                m_smVisionInfo.g_objTransferTime.Stop();

                timer_TotalTime.Stop();
                //objTL.WriteLine("Total grab time = " + fTotalGrabTime.ToString());
                //objTL.WriteLine("Total time = " + timer_TotalTime.Duration.ToString());
                return true;
            }
        }

        public bool GrabImage_AVT(bool blnForInspection)
        {
#if (DEBUG || Debug_2_12 || RTXDebug)
            return true;
#endif
            string strTime = "";
            float fCurrentTime;
            float fLastTime = 0f;

            m_smVisionInfo.g_objGrabTime.Start();
            bool blnSuccess = true;
            bool blnSeparateGrab = m_smVisionInfo.g_blnSeparateGrab;
            int intSelectedImage = m_smVisionInfo.g_intSelectedImage;
            HiPerfTimer timer_GrabTime = new HiPerfTimer();

            int intExposureTime = (int)Math.Ceiling(m_smVisionInfo.g_fCameraShuttle * 0.02f);

            // Define grab images require
            if (blnForInspection)
            {
                if ((m_smCustomizeInfo.g_intWantPackage & (1 << m_smVisionInfo.g_intVisionPos)) > 0 &&
                            m_smVisionInfo.g_blnCheckPackage)
                {
                    if (m_intCurrentGrabRequire != m_intGrabRequire)
                        m_intCurrentGrabRequire = m_intGrabRequire;
                }
                else
                {
                    if (m_intCurrentGrabRequire != 1)
                        m_intCurrentGrabRequire = 1;
                }
            }
            else
            {
                // Set to maximum requirement grab image if camera live or grab.
                if (m_intCurrentGrabRequire != m_intGrabRequire)
                    m_intCurrentGrabRequire = m_intGrabRequire;
            }

            m_objAVTFireGrab.DiscardFrame();
            for (int i = 0; i < m_intCurrentGrabRequire; i++)
            {
                if (blnSeparateGrab)
                {
                    if (i != intSelectedImage)
                        continue;
                }

                if (i > 0) // for second image and third image
                {
                    timer_GrabTime.Stop();
                    if ((m_objAVTFireGrab.ref_intNextGrabDelay - timer_GrabTime.Duration) > 0)
                        Thread.Sleep((int)(m_objAVTFireGrab.ref_intNextGrabDelay - timer_GrabTime.Duration));
                }

                #region if more than 1 image need to be captured
                // Set light source channel ON/OFF
                if (m_intGrabRequire > 1)
                {
                    // Set camera gain
                    if (m_intCameraGainPrev != m_smVisionInfo.g_arrCameraGain[i])
                    {
                        m_objAVTFireGrab.SetCameraParameter(2, m_smVisionInfo.g_arrCameraGain[i]);
                        m_intCameraGainPrev = m_smVisionInfo.g_arrCameraGain[i];
                        if (m_objAVTFireGrab.ref_intSetGainDelay != 0)
                            Thread.Sleep(m_objAVTFireGrab.ref_intSetGainDelay);
                    }

                    // Set camera shuttle
                    if (m_fCameraShuttlePrev != m_smVisionInfo.g_arrCameraShuttle[i])
                    {
                        m_objAVTFireGrab.SetCameraParameter(1, (uint)m_smVisionInfo.g_arrCameraShuttle[i]);
                        m_fCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[i];
                        if (m_objAVTFireGrab.ref_intSetGainDelay != 0)
                            Thread.Sleep(m_objAVTFireGrab.ref_intSetGainDelay);
                    }

                    switch (i)
                    {
                        case 0:
                            if ((m_intCameraOutState & (0x01)) == 0)
                            {
                                m_objAVTFireGrab.OutPort(0, m_smVisionInfo.g_intTriggerMode);
                                m_intCameraOutState |= 0x01;
                            }
                            if ((m_intCameraOutState & (0x02)) > 0)
                            {
                                m_objAVTFireGrab.OutPort(1, 0);
                                m_intCameraOutState &= ~0x02;
                            }
                            if ((m_intCameraOutState & (0x04)) > 0)
                            {
                                m_objAVTFireGrab.OutPort(2, 0);
                                m_intCameraOutState &= ~0x04;
                            }
                            break;
                        case 1:
                            if ((m_intCameraOutState & (0x01)) > 0)
                            {
                                m_objAVTFireGrab.OutPort(0, 0);
                                m_intCameraOutState &= ~0x01;
                            }
                            if ((m_intCameraOutState & (0x02)) == 0)
                            {
                                m_objAVTFireGrab.OutPort(1, m_smVisionInfo.g_intTriggerMode);
                                m_intCameraOutState |= 0x02;
                            }
                            if ((m_intCameraOutState & (0x04)) > 0)
                            {
                                m_objAVTFireGrab.OutPort(2, 0);
                                m_intCameraOutState &= ~0x04;
                            }
                            break;
                        case 2:
                            if ((m_intCameraOutState & (0x01)) > 0)
                            {
                                m_objAVTFireGrab.OutPort(0, 0);
                                m_intCameraOutState &= ~0x01;
                            }
                            if ((m_intCameraOutState & (0x02)) > 0)
                            {
                                m_objAVTFireGrab.OutPort(1, 0);
                                m_intCameraOutState &= ~0x02;
                            }
                            if ((m_intCameraOutState & (0x04)) == 0)
                            {
                                m_objAVTFireGrab.OutPort(2, m_smVisionInfo.g_intTriggerMode);
                                m_intCameraOutState |= 0x04;
                            }
                            break;
                    }
                }
                #endregion

                if (!m_objAVTFireGrab.Grab())
                {
                    blnSuccess = false;
                    m_blnForceStopProduction = true;
                }

                if (i < m_intCurrentGrabRequire - 1)
                {
                    timer_GrabTime.Start();
                    Thread.Sleep(intExposureTime);
                }
                else
                {
                    Thread.Sleep(Math.Max(intExposureTime, 4));
                }
            }

            fCurrentTime = m_smVisionInfo.g_objGrabTime.Timing;
            strTime += "G=" + (fCurrentTime - fLastTime).ToString("F3") + ", ";
            fLastTime = fCurrentTime;

            if (blnSuccess)
            {
                SetGrabDone(blnForInspection);
                m_smVisionInfo.g_objTransferTime.Start();

                for (int i = 0; i < m_intCurrentGrabRequire; i++)
                {
                    if (blnSeparateGrab)
                    {
                        if (i != intSelectedImage)
                            continue;
                    }

                    if (m_objAVTFireGrab.GetFrame(i))
                    {
                        if (m_objAVTFireGrab.ConvertFrame(i))
                        {
                            if (m_smVisionInfo.g_blnViewColorImage)
                            {
                                m_smVisionInfo.g_objMemoryColorImage.LoadImageFromMemory(m_objAVTFireGrab.ref_ptrImagePointer);
                                m_smVisionInfo.g_objMemoryColorImage.CopyTo(ref m_smVisionInfo.g_arrColorImages, i);
                            }
                            else
                            {
                                m_smVisionInfo.g_objMemoryImage.LoadImageFromMemory(m_objAVTFireGrab.ref_ptrImagePointer);
                                m_smVisionInfo.g_objMemoryImage.CopyTo(ref m_smVisionInfo.g_arrImages, i);
                                m_smVisionInfo.g_arrImages[i].AddGain(m_smVisionInfo.g_arrImageGain[i]);
                            }
                        }
                    }
                }

                for (int i = 0; i < m_intCurrentGrabRequire; i++)
                {
                    if (blnSeparateGrab)
                    {
                        if (i != intSelectedImage)
                            continue;
                    }

                    m_objAVTFireGrab.ReleaseImage(i);
                }
            }
            else
                SetGrabDone(blnForInspection);

            //-------------------------------------------
            m_smVisionInfo.g_objTransferTime.Stop();
            strTime += "L" + "=" + (m_smVisionInfo.g_objGrabTime.Duration + m_smVisionInfo.g_objTransferTime.Duration).ToString("F3");
            //-------------------------------------------

            if (m_objAVTFireGrab.ref_strErrorText != "")
            {
                m_smVisionInfo.g_strErrorMessage = m_objAVTFireGrab.ref_strErrorText;
                m_smVisionInfo.g_objTransferTime.Stop();
                return false;
            }
            else
            {
                // Set camera gain
                if (m_intCameraGainPrev != m_smVisionInfo.g_arrCameraGain[0])
                {
                    m_objAVTFireGrab.SetCameraParameter(2, m_smVisionInfo.g_arrCameraGain[0]);
                    m_intCameraGainPrev = m_smVisionInfo.g_arrCameraGain[0];
                }

                // Set camera shuttle
                if (m_fCameraShuttlePrev != m_smVisionInfo.g_arrCameraShuttle[0])
                {
                    m_objAVTFireGrab.SetCameraParameter(1, (uint)m_smVisionInfo.g_arrCameraShuttle[0]);
                    m_fCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[0];
                }



                //AttachImageToROI();
                m_smVisionInfo.g_blnLoadFile = false;
                m_smVisionInfo.g_objTransferTime.Stop();
                return true;
            }
        }

        public bool GrabImage_Sequence_GetFrameBeforeNextGrab_NoSetIntensity_AVT(bool blnForInspection)
        {

            /*
             * Use Vitrox Sequence controller
             * Grab each image, get frame, convert frame, assign to imagedrawing by sequence.
             * No grab all first, then only get all frame after.
             * Use this function unless you need to trigger GrabDone signal to software as early as possible.
             */

            if (!m_objAVTFireGrab.ref_blnCameraInitDone)
            {
                m_bGrabImage1Result = m_bGrabImage2Result = m_bGrabImage3Result = m_bGrabImage4Result = m_bGrabImage5Result = m_bGrabImage6Result = m_bGrabImage7Result = true;
                m_bGrabImage1Done = m_bGrabImage2Done = m_bGrabImage3Done = m_bGrabImage4Done = m_bGrabImage5Done = m_bGrabImage6Done = m_bGrabImage7Done = true;
                m_smVisionInfo.g_strErrorMessage = "Camera No Connected";
                return true;
            }

            // Default Using AVT Camera
            m_smVisionInfo.g_objGrabTime.Start();


            Thread.Sleep(m_smVisionInfo.g_intCameraGrabDelay);


            bool blnSuccess = true;
            bool blnSeparateGrab = m_smVisionInfo.g_blnSeparateGrab;
            int intSelectedImage = m_smVisionInfo.g_intSelectedImage;
            HiPerfTimer timer_GrabTime = new HiPerfTimer();

            m_objAVTFireGrab.DiscardFrame();

            for (int i = 0; i < m_intGrabRequire; i++)
            {

                if (blnSeparateGrab)
                {
                    if (i != intSelectedImage)
                        continue;
                }

                #region if more than 1 image need to be captured
                // Set light source channel ON/OFF
                if (m_intGrabRequire > 1)
                {
                    // Set camera gain
                    if (m_intCameraGainPrev != m_smVisionInfo.g_arrCameraGain[i])
                    {
                        m_objAVTFireGrab.SetCameraParameter(2, m_smVisionInfo.g_arrCameraGain[i]);
                        m_intCameraGainPrev = m_smVisionInfo.g_arrCameraGain[i];
                        if (m_objAVTFireGrab.ref_intSetGainDelay != 0)
                            Thread.Sleep(m_objAVTFireGrab.ref_intSetGainDelay);
                    }

                    // Set camera shuttle
                    if (m_fCameraShuttlePrev != m_smVisionInfo.g_arrCameraShuttle[i])
                    {
                        m_objAVTFireGrab.SetCameraParameter(1, (uint)m_smVisionInfo.g_arrCameraShuttle[i]);
                        m_fCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[i];
                        if (m_objAVTFireGrab.ref_intSetGainDelay != 0)
                            Thread.Sleep(m_objAVTFireGrab.ref_intSetGainDelay);
                    }
                }
                #endregion
                if (i == 0)
                {
                    m_objAVTFireGrab.OutPort(1, 4);     // Set high to controller's Reset Trigger 
                    m_objAVTFireGrab.OutPort(0, m_smVisionInfo.g_intTriggerMode);
                    Thread.Sleep(1);
                }
                else if (i == (m_intGrabRequire - 1))
                {
                    m_objAVTFireGrab.OutPort(0, 0);
                }

                if (!m_objAVTFireGrab.Grab())
                {
                    blnSuccess = false;
                    m_blnForceStopProduction = true;
                }

                if (i == (m_intGrabRequire - 1))
                {
                    SetGrabDone(blnForInspection);
                    m_smVisionInfo.g_objTransferTime.Start();
                }

                if (m_objAVTFireGrab.GetFrame(i))
                {

                    if (m_objAVTFireGrab.ConvertFrame(i))
                    {

                        if (m_smVisionInfo.g_blnViewColorImage)
                        {
                            m_smVisionInfo.g_objMemoryColorImage.SetImageSize(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight);
                            m_smVisionInfo.g_objMemoryColorImage.LoadImageFromMemory(m_objAVTFireGrab.ref_ptrImagePointer);
                            m_smVisionInfo.g_objMemoryColorImage.CopyTo(ref m_smVisionInfo.g_arrColorImages, i);
                        }
                        else
                        {
                            m_smVisionInfo.g_objMemoryImage.SetImageSize(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight);
                            m_smVisionInfo.g_objMemoryImage.LoadImageFromMemory(m_objAVTFireGrab.ref_ptrImagePointer);
                            m_smVisionInfo.g_objMemoryImage.CopyTo(ref m_smVisionInfo.g_arrImages, i);
                            m_smVisionInfo.g_arrImages[i].AddGain(m_smVisionInfo.g_arrImageGain[i]);
                        }
                    }
                }



                m_objAVTFireGrab.ReleaseImage(i);
            }

            if (!blnSuccess)
            {
                SetGrabDone(blnForInspection);

            }

            // 11/2/2019 ZJYEOH , Moved to above's for loop , because pointer not pointed to the current image
            //for (int i = 0; i < m_intGrabRequire; i++)
            //{
            //    if (blnSeparateGrab)
            //    {
            //        if (i != intSelectedImage)
            //            continue;
            //    }

            //    m_objAVTFireGrab.ReleaseImage(i);

            //    t.WriteLine("After ReleaseImage " +i.ToString());
            //}

            //Reset outport
            m_objAVTFireGrab.OutPort(1, 5);     // Set Low to controller's Reset Trigger 

            if (m_objAVTFireGrab.ref_strErrorText != "")
            {
                m_smVisionInfo.g_strErrorMessage = m_objAVTFireGrab.ref_strErrorText;
                m_smVisionInfo.ALL_VM_UpdatePictureBox = true;
                m_smVisionInfo.g_objTransferTime.Stop();

                return false;
            }
            else
            {
                // Set camera gain
                if (m_intCameraGainPrev != m_smVisionInfo.g_arrCameraGain[0])
                {
                    m_objAVTFireGrab.SetCameraParameter(2, m_smVisionInfo.g_arrCameraGain[0]);
                    m_intCameraGainPrev = m_smVisionInfo.g_arrCameraGain[0];
                }

                // Set camera shuttle
                if (m_fCameraShuttlePrev != m_smVisionInfo.g_arrCameraShuttle[0])
                {
                    m_objAVTFireGrab.SetCameraParameter(1, (uint)m_smVisionInfo.g_arrCameraShuttle[0]);
                    m_fCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[0];
                }

                //AttachImageToROI();
                m_smVisionInfo.g_blnLoadFile = false;
                m_smVisionInfo.ALL_VM_UpdatePictureBox = true;
                m_smVisionInfo.g_objTransferTime.Stop();

                return true;
            }
        }

        public bool GrabImage_Normal_GetFrameBeforeNextGrab_NoSetIntensity_AVTVimba(bool blnForInspection)
        {

            /*
             * Use LEDi standard controller
             * Grab each image, get frame, convert frame, assign to imagedrawing by sequence.
             * No grab all first, then only get all frame after.
             * Use this function unless you need to trigger GrabDone signal to software as early as possible.
             */

            //m_T1.Start();
            //m_strTrack = "";
            //m_fTimingPrev = 0;
            //m_fTiming = 0;

            if (!m_objAVTFireGrab.ref_blnCameraInitDone)
            {
                m_bGrabImage1Result = m_bGrabImage2Result = m_bGrabImage3Result = m_bGrabImage4Result = m_bGrabImage5Result = m_bGrabImage6Result = m_bGrabImage7Result = true;
                m_bGrabImage1Done = m_bGrabImage2Done = m_bGrabImage3Done = m_bGrabImage4Done = m_bGrabImage5Done = m_bGrabImage6Done = m_bGrabImage7Done = true;
                m_smVisionInfo.g_strErrorMessage = "Camera No Connected";
                return true;
            }

            // Default Using AVT Camera
            m_smVisionInfo.g_objGrabTime.Start();

            Thread.Sleep(m_smVisionInfo.g_intCameraGrabDelay);

            bool blnSuccess = true;
            bool blnSeparateGrab = m_smVisionInfo.g_blnSeparateGrab;
            int intSelectedImage = m_smVisionInfo.g_intSelectedImage;


            m_objAVTFireGrab.DiscardFrame();

            for (int i = 0; i < m_intGrabRequire; i++)
            {
                if (blnSeparateGrab)
                {
                    if (i != intSelectedImage)
                        continue;
                }

                #region if more than 1 image need to be captured
                // Set light source channel ON/OFF
                if (m_intGrabRequire > 1)
                {
                    // Set camera gain
                    if (m_intCameraGainPrev != m_smVisionInfo.g_arrCameraGain[i])
                    {
                        m_objAVTFireGrab.SetCameraParameter_Quick(2, m_smVisionInfo.g_arrCameraGain[i]);
                        m_intCameraGainPrev = m_smVisionInfo.g_arrCameraGain[i];
                    }

                    // Set camera    shuttle
                    if (m_fCameraShuttlePrev != m_smVisionInfo.g_arrCameraShuttle[i])
                    {
                        m_objAVTFireGrab.SetCameraParameter_Quick(1, m_smVisionInfo.g_arrCameraShuttle[i]);
                        m_fCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[i];
                    }
                }
                #endregion

                switch (i)
                {
                    case 0:
                        if ((m_intCameraOutState & (0x01)) == 0)
                        {
                            m_objAVTFireGrab.QuickOutPort(0, m_smVisionInfo.g_intTriggerMode);

                            m_intCameraOutState |= 0x01;
                        }
                        if ((m_intCameraOutState & (0x02)) > 0)
                        {
                            m_objAVTFireGrab.QuickOutPort(1, 0);

                            m_intCameraOutState &= ~0x02;
                        }
                        if ((m_intCameraOutState & (0x04)) > 0)
                        {
                            m_objAVTFireGrab.QuickOutPort(2, 0);

                            m_intCameraOutState &= ~0x04;
                        }
                        break;
                    case 1:
                        if ((m_intCameraOutState & (0x01)) > 0)
                        {
                            m_objAVTFireGrab.QuickOutPort(0, 0);
                            m_intCameraOutState &= ~0x01;
                        }
                        if ((m_intCameraOutState & (0x02)) == 0)
                        {
                            m_objAVTFireGrab.QuickOutPort(1, m_smVisionInfo.g_intTriggerMode);
                            m_intCameraOutState |= 0x02;
                        }
                        if ((m_intCameraOutState & (0x04)) > 0)
                        {
                            m_objAVTFireGrab.QuickOutPort(2, 0);
                            m_intCameraOutState &= ~0x04;
                        }
                        break;
                    case 2:
                        if ((m_intCameraOutState & (0x01)) > 0)
                        {
                            m_objAVTFireGrab.QuickOutPort(0, 0);
                            m_intCameraOutState &= ~0x01;
                        }
                        if ((m_intCameraOutState & (0x02)) > 0)
                        {
                            m_objAVTFireGrab.QuickOutPort(1, 0);
                            m_intCameraOutState &= ~0x02;
                        }
                        if ((m_intCameraOutState & (0x04)) == 0)
                        {
                            m_objAVTFireGrab.QuickOutPort(2, m_smVisionInfo.g_intTriggerMode);
                            m_intCameraOutState |= 0x04;
                        }
                        break;
                }

                if (!m_objAVTFireGrab.Grab())
                {
                    blnSuccess = false;
                    m_blnForceStopProduction = true;
                }

                if (i == (m_intGrabRequire - 1))
                {
                    SetGrabDone(blnForInspection);
                    m_smVisionInfo.g_objTransferTime.Start();
                }

                if (m_objAVTFireGrab.GetFrame(i))
                {
                    if (m_objAVTFireGrab.ConvertFrame(i))
                    {
                        if (m_smVisionInfo.g_blnViewColorImage)
                        {
                            m_smVisionInfo.g_objMemoryColorImage.SetImageSize(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight);
                            m_smVisionInfo.g_objMemoryColorImage.LoadImageFromMemory(m_objAVTFireGrab.ref_ptrImagePointer);
                            m_smVisionInfo.g_objMemoryColorImage.CopyTo(ref m_smVisionInfo.g_arrColorImages, i);
                        }
                        else
                        {
                            m_smVisionInfo.g_objMemoryImage.SetImageSize(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight);
                            m_smVisionInfo.g_objMemoryImage.LoadImageFromMemory(m_objAVTFireGrab.ref_ptrImagePointer);
                            m_smVisionInfo.g_objMemoryImage.CopyTo(ref m_smVisionInfo.g_arrImages, i);
                            m_smVisionInfo.g_arrImages[i].AddGain(m_smVisionInfo.g_arrImageGain[i]);
                        }
                        if (i == 0)
                        {
                            if (blnSuccess) m_bGrabImage1Result = true;
                            m_bGrabImage1Done = true;
                        }
                        else if (i == 1)
                        {
                            if (blnSuccess) m_bGrabImage2Result = true;
                            m_bGrabImage2Done = true;
                        }
                        else if (i == 2)
                        {
                            if (blnSuccess) m_bGrabImage3Result = true;
                            m_bGrabImage3Done = true;
                        }
                        else if (i == 3)
                        {
                            if (blnSuccess) m_bGrabImage4Result = true;
                            m_bGrabImage4Done = true;
                        }
                        else if (i == 4)
                        {
                            if (blnSuccess) m_bGrabImage5Result = true;
                            m_bGrabImage5Done = true;
                        }
                        else if (i == 5)
                        {
                            if (blnSuccess) m_bGrabImage6Result = true;
                            m_bGrabImage6Done = true;
                        }
                        else if (i == 6)
                        {
                            if (blnSuccess) m_bGrabImage7Result = true;
                            m_bGrabImage7Done = true;
                        }
                    }
                }



                m_objAVTFireGrab.ReleaseImage(i);

            }

            if (!blnSuccess)
            {
                SetGrabDone(blnForInspection);

            }

            if (m_objAVTFireGrab.ref_strErrorText != "")
            {
                m_smVisionInfo.g_strErrorMessage = m_objAVTFireGrab.ref_strErrorText;
                m_smVisionInfo.ALL_VM_UpdatePictureBox = true;
                m_smVisionInfo.g_objTransferTime.Stop();

                return false;
            }
            else
            {
                // Set camera gain
                if (m_intCameraGainPrev != m_smVisionInfo.g_arrCameraGain[0])
                {
                    m_objAVTFireGrab.SetCameraParameter_Quick(2, m_smVisionInfo.g_arrCameraGain[0]);
                    m_intCameraGainPrev = m_smVisionInfo.g_arrCameraGain[0];
                }

                // Set camera shuttle
                if (m_fCameraShuttlePrev != m_smVisionInfo.g_arrCameraShuttle[0])
                {
                    m_objAVTFireGrab.SetCameraParameter_Quick(1, (uint)m_smVisionInfo.g_arrCameraShuttle[0]);
                    m_fCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[0];
                }

                if ((m_intCameraOutState & (0x01)) == 0)
                {
                    m_objAVTFireGrab.QuickOutPort(0, m_smVisionInfo.g_intTriggerMode);

                    m_intCameraOutState |= 0x01;
                }
                if ((m_intCameraOutState & (0x02)) > 0)
                {
                    m_objAVTFireGrab.QuickOutPort(1, 0);

                    m_intCameraOutState &= ~0x02;
                }
                if ((m_intCameraOutState & (0x04)) > 0)
                {
                    m_objAVTFireGrab.QuickOutPort(2, 0);

                    m_intCameraOutState &= ~0x04;
                }

                //AttachImageToROI();
                m_smVisionInfo.g_blnLoadFile = false;
                m_smVisionInfo.ALL_VM_UpdatePictureBox = true;
                m_smVisionInfo.g_objTransferTime.Stop();

                //STTrackLog.WriteLine(m_strTrack);
                return true;
            }
        }

        public bool GrabImage_Sequence_GrabAllBeforeGetFrame_NoSetIntensity_AVT4()
        {
            /*
            * Grab all first, then only get all frame after.
            * Use this function when need to trigger GrabDone signal to software as early as possible.
            * Issue: When shuttle set to 33% or higher, need more delay time before allow to grab next time. If delay no enough, it will affecting next image lighting.
            */
#if (DEBUG || Debug_2_12 || RTXDebug)
            return true;
#endif
            // Default Using AVT Camera
            m_smVisionInfo.g_objGrabTime.Start();
            bool blnSuccess = true;
            bool blnSeparateGrab = m_smVisionInfo.g_blnSeparateGrab;
            int intSelectedImage = m_smVisionInfo.g_intSelectedImage;
            HiPerfTimer timer_GrabTime = new HiPerfTimer();

            //m_fTimingPrev = 0;
            //m_strTrack = "";
            //m_T1.Start();

            int intExposureTime = (int)Math.Ceiling(m_smVisionInfo.g_arrCameraShuttle[0] * 0.02f);

            m_objAVTFireGrab.DiscardFrame();

            for (int i = 0; i < m_intGrabRequire; i++)
            {
                if (blnSeparateGrab)
                {
                    if (i != intSelectedImage)
                        continue;
                }



                if (i > 0) // for second image and third image
                {
                    timer_GrabTime.Stop();
                    if ((m_objAVTFireGrab.ref_intNextGrabDelay - timer_GrabTime.Duration) > 0)
                        Thread.Sleep((int)(m_objAVTFireGrab.ref_intNextGrabDelay - timer_GrabTime.Duration));
                }

                #region if more than 1 image need to be captured
                // Set light source channel ON/OFF
                if (m_intGrabRequire > 1)
                {
                    // Set camera gain
                    if (m_intCameraGainPrev != m_smVisionInfo.g_arrCameraGain[i])
                    {
                        m_objAVTFireGrab.SetCameraParameter(2, m_smVisionInfo.g_arrCameraGain[i]);
                        m_intCameraGainPrev = m_smVisionInfo.g_arrCameraGain[i];
                        if (m_objAVTFireGrab.ref_intSetGainDelay != 0)
                            Thread.Sleep(m_objAVTFireGrab.ref_intSetGainDelay);
                    }

                    // Set camera shuttle
                    if (m_fCameraShuttlePrev != m_smVisionInfo.g_arrCameraShuttle[i])
                    {
                        m_objAVTFireGrab.SetCameraParameter(1, (uint)m_smVisionInfo.g_arrCameraShuttle[i]);
                        m_fCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[i];
                        if (m_objAVTFireGrab.ref_intSetGainDelay != 0)
                            Thread.Sleep(m_objAVTFireGrab.ref_intSetGainDelay);

                        intExposureTime = (int)Math.Ceiling(m_smVisionInfo.g_arrCameraShuttle[i] * 0.02f);
                    }
                }
                #endregion

                if (i == 0)
                {
                    m_objAVTFireGrab.OutPort(1, 4);
                }

                if (!m_objAVTFireGrab.Grab())
                {
                    blnSuccess = false;
                    m_blnForceStopProduction = true;
                }

                if (i < m_intGrabRequire - 1)
                {
                    timer_GrabTime.Start();

                    Thread.Sleep(intExposureTime);
                }
                else
                {
                    Thread.Sleep(Math.Max(intExposureTime, m_objAVTFireGrab.ref_intNextGrabDelay));
                }

            }

            if (blnSuccess)
            {
                SetGrabDone(false);

                m_smVisionInfo.g_objTransferTime.Start();

                for (int i = 0; i < m_intGrabRequire; i++)
                {
                    if (blnSeparateGrab)
                    {
                        if (i != intSelectedImage)
                            continue;
                    }

                    if (m_objAVTFireGrab.GetFrame(i))
                    {
                        if (m_objAVTFireGrab.ConvertFrame(i))
                        {
                            if (m_smVisionInfo.g_blnViewColorImage)
                            {
                                m_smVisionInfo.g_objMemoryColorImage.SetImageSize(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight);
                                m_smVisionInfo.g_objMemoryColorImage.LoadImageFromMemory(m_objAVTFireGrab.ref_ptrImagePointer);
                                m_smVisionInfo.g_objMemoryColorImage.CopyTo(ref m_smVisionInfo.g_arrColorImages, i);
                            }
                            else
                            {
                                m_smVisionInfo.g_objMemoryImage.SetImageSize(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight);
                                m_smVisionInfo.g_objMemoryImage.LoadImageFromMemory(m_objAVTFireGrab.ref_ptrImagePointer);
                                m_smVisionInfo.g_objMemoryImage.CopyTo(ref m_smVisionInfo.g_arrImages, i);
                                m_smVisionInfo.g_arrImages[i].AddGain(m_smVisionInfo.g_arrImageGain[i]);
                            }
                        }
                    }
                }
            }
            else
            {
                SetGrabDone(false);
            }

            for (int i = 0; i < m_intGrabRequire; i++)
            {
                if (blnSeparateGrab)
                {
                    if (i != intSelectedImage)
                        continue;
                }

                m_objAVTFireGrab.ReleaseImage(i);
            }

            //Reset outport
            m_objAVTFireGrab.OutPort(1, 5);

            if (m_objAVTFireGrab.ref_strErrorText != "")
            {
                m_smVisionInfo.g_strErrorMessage = m_objAVTFireGrab.ref_strErrorText;
                m_smVisionInfo.ALL_VM_UpdatePictureBox = true;
                m_smVisionInfo.g_objTransferTime.Stop();

                return false;
            }
            else
            {
                // Set camera gain
                if (m_intCameraGainPrev != m_smVisionInfo.g_arrCameraGain[0])
                {
                    m_objAVTFireGrab.SetCameraParameter(2, m_smVisionInfo.g_arrCameraGain[0]);
                    m_intCameraGainPrev = m_smVisionInfo.g_arrCameraGain[0];
                }

                // Set camera shuttle
                if (m_fCameraShuttlePrev != m_smVisionInfo.g_arrCameraShuttle[0])
                {
                    m_objAVTFireGrab.SetCameraParameter(1, (uint)m_smVisionInfo.g_arrCameraShuttle[0]);
                    m_fCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[0];
                }

                //AttachImageToROI();
                m_smVisionInfo.g_blnLoadFile = false;
                m_smVisionInfo.ALL_VM_UpdatePictureBox = true;
                m_smVisionInfo.g_objTransferTime.Stop();

                return true;
            }
        }

        public bool GrabImage_Sequence_NoSetIntensity_Teli(bool blnForInspection)
        {
            if (!m_objTeliCamera.IsCameraInitDone())
            {
                m_bGrabImage1Result = m_bGrabImage2Result = m_bGrabImage3Result = m_bGrabImage4Result = m_bGrabImage5Result = m_bGrabImage6Result = m_bGrabImage7Result = true;
                m_bGrabImage1Done = m_bGrabImage2Done = m_bGrabImage3Done = m_bGrabImage4Done = m_bGrabImage5Done = m_bGrabImage6Done = m_bGrabImage7Done = true;
                m_smVisionInfo.g_strErrorMessage = "Camera No Connected";
                return true;
            }

            // Using Teli Camera
            m_smVisionInfo.g_objGrabTime.Start();

            Thread.Sleep(m_smVisionInfo.g_intCameraGrabDelay);

            bool blnSuccess = true;
            bool blnSeparateGrab = m_smVisionInfo.g_blnSeparateGrab;
            int intSelectedImage = m_smVisionInfo.g_intSelectedImage;

            TrackLog objTL = new TrackLog();
            float fTotalGrabTime = 0f;
            HiPerfTimer timer_TotalTime = new HiPerfTimer();
            HiPerfTimer timer_TotalGrabTime = new HiPerfTimer();
            timer_TotalTime.Start();

            for (int i = 0; i < m_intGrabRequire; i++)
            {
                if (blnSeparateGrab)
                {
                    if (i != intSelectedImage)
                        continue;
                }

                if (i > 0) // for second image and third image
                {
                    if (m_objTeliCamera.WaitFrameReady())
                    {
                        if (m_smVisionInfo.g_blnViewColorImage)
                        {
                            m_smVisionInfo.g_objMemoryColorImage.SetImageSize(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight);
                            m_smVisionInfo.g_objMemoryColorImage.LoadImageFromMemory(m_objTeliCamera.GetImagePointer());
                            m_smVisionInfo.g_objMemoryColorImage.CopyTo(ref m_smVisionInfo.g_arrColorImages, i - 1);
                            ConvertColorToMono(i - 1);
                            m_smVisionInfo.g_arrImages[i - 1].AddGain(m_smVisionInfo.g_arrImageGain[i - 1]);
                        }
                        else
                        {
                            m_smVisionInfo.g_objMemoryImage.SetImageSize(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight);
                            m_smVisionInfo.g_objMemoryImage.LoadImageFromMemory(m_objTeliCamera.GetImagePointer());

                            if (m_smVisionInfo.g_intRotateFlip == 1)
                            {
                                m_smVisionInfo.g_objMemoryImage.Rotate180Image(ref m_smVisionInfo.g_ojRotateImage, false);
                            }
                            else if (m_smVisionInfo.g_intRotateFlip == 2)
                            {
                                m_smVisionInfo.g_objMemoryImage.Rotate90Image(ref m_smVisionInfo.g_ojRotateImage, false);
                            }
                            else if (m_smVisionInfo.g_intRotateFlip == 3)
                            {
                                m_smVisionInfo.g_objMemoryImage.RotateMinus90Image(ref m_smVisionInfo.g_ojRotateImage, false);
                            }
                            else if (m_smVisionInfo.g_intRotateFlip == 4)
                            {
                                m_smVisionInfo.g_objMemoryImage.FlipHorizontalImage(ref m_smVisionInfo.g_ojRotateImage, false);
                            }
                            else if (m_smVisionInfo.g_intRotateFlip == 5)
                            {
                                m_smVisionInfo.g_objMemoryImage.FlipVerticalImage(ref m_smVisionInfo.g_ojRotateImage, false);
                            }
                            else
                            {
                                m_smVisionInfo.g_objMemoryImage.CopyTo(ref m_smVisionInfo.g_ojRotateImage);
                            }

                            if (m_smProductionInfo.g_blnAllRunGrabWithoutUseImage)
                            {
                                if (m_smVisionInfo.g_arrDebugImages.Count != m_smVisionInfo.g_arrImages.Count)
                                {
                                    for (int d = 0; d < m_smVisionInfo.g_arrImages.Count; d++)
                                    {
                                        m_smVisionInfo.g_arrDebugImages.Add(new ImageDrawing(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight));
                                    }
                                }

                                m_smVisionInfo.g_ojRotateImage.CopyTo(ref m_smVisionInfo.g_arrDebugImages, i - 1);
                                m_smVisionInfo.g_arrDebugImages[i - 1].AddGain(m_smVisionInfo.g_arrImageGain[i - 1]);
                            }
                            else
                            {
                                m_smVisionInfo.g_ojRotateImage.CopyTo(ref m_smVisionInfo.g_arrImages, i - 1);
                                m_smVisionInfo.g_arrImages[i - 1].AddGain(m_smVisionInfo.g_arrImageGain[i - 1]);
                            }

                            // 2020 12 30 - CCENG: Do image processing to increase image contrast. (to solve mark no enough contrast case)
                            if (i == 1)
                            {
                                if (m_smVisionInfo.g_blnEnhanceImage_Enable)
                                {
                                    if (m_smVisionInfo.g_intEnhanceImage_Close > 0)
                                        m_smVisionInfo.g_arrImages[i - 1].AddCloseMorphology(m_smVisionInfo.g_intEnhanceImage_Close);
                                    if (m_smVisionInfo.g_intEnhanceImage_Open > 0)
                                        m_smVisionInfo.g_arrImages[i - 1].AddOpenMorphology(m_smVisionInfo.g_intEnhanceImage_Open);
                                    if (m_smVisionInfo.g_intEnhanceImage_Dilate > 0)
                                        m_smVisionInfo.g_arrImages[i - 1].AddDilate(m_smVisionInfo.g_intEnhanceImage_Dilate);
                                    if (m_smVisionInfo.g_intEnhanceImage_Offset != 0)
                                        m_smVisionInfo.g_arrImages[i - 1].AddOffset(m_smVisionInfo.g_intEnhanceImage_Offset);
                                    if (m_smVisionInfo.g_fEnhanceImage_Gain != 1f)
                                        m_smVisionInfo.g_arrImages[i - 1].AddGain(m_smVisionInfo.g_fEnhanceImage_Gain);
                                }
                            }
                        }

                        timer_TotalGrabTime.Stop();
                        fTotalGrabTime = fTotalGrabTime + timer_TotalGrabTime.Duration;
                        //objTL.WriteLine("grab time " + i.ToString() + " = " + fTotalGrabTime.ToString());
                    }
                    else
                    {
                        blnSuccess = false;
                        m_blnForceStopProduction = true;
                    }

                    // STTrackLog.WriteLine("Grab i = " + i.ToString());
                    if (i == 1)
                    {
                        if (m_smVisionInfo.g_blnSaveImageAfterGrab && blnForInspection) m_smVisionInfo.g_arrImages[i - 1].SaveImage("D:\\TSMark\\" + m_intCounter + ".bmp");
                        //      STTrackLog.WriteLine("Grab 1 done.");
                        if (blnSuccess) m_bGrabImage1Result = true;
                        m_bGrabImage1Done = true;
                    }
                    else if (i == 2)
                    {
                        if (m_smVisionInfo.g_blnSaveImageAfterGrab && blnForInspection) m_smVisionInfo.g_arrImages[i - 1].SaveImage("D:\\TSMark\\" + m_intCounter + "_Image" + (i - 1) + ".bmp");
                        if (blnSuccess) m_bGrabImage2Result = true;
                        m_bGrabImage2Done = true;
                    }
                    else if (i == 3)
                    {
                        if (m_smVisionInfo.g_blnSaveImageAfterGrab && blnForInspection) m_smVisionInfo.g_arrImages[i - 1].SaveImage("D:\\TSMark\\" + m_intCounter + "_Image" + (i - 1) + ".bmp");
                        if (blnSuccess) m_bGrabImage3Result = true;
                        m_bGrabImage3Done = true;
                    }
                    else if (i == 4)
                    {
                        if (m_smVisionInfo.g_blnSaveImageAfterGrab && blnForInspection) m_smVisionInfo.g_arrImages[i - 1].SaveImage("D:\\TSMark\\" + m_intCounter + "_Image" + (i - 1) + ".bmp");
                        if (blnSuccess) m_bGrabImage4Result = true;
                        m_bGrabImage4Done = true;
                    }
                    else if (i == 5)
                    {
                        if (m_smVisionInfo.g_blnSaveImageAfterGrab && blnForInspection) m_smVisionInfo.g_arrImages[i - 1].SaveImage("D:\\TSMark\\" + m_intCounter + "_Image" + (i - 1) + ".bmp");
                        if (blnSuccess) m_bGrabImage5Result = true;
                        m_bGrabImage5Done = true;
                    }
                    else if (i == 6)
                    {
                        if (m_smVisionInfo.g_blnSaveImageAfterGrab && blnForInspection) m_smVisionInfo.g_arrImages[i - 1].SaveImage("D:\\TSMark\\" + m_intCounter + "_Image" + (i - 1) + ".bmp");
                        if (blnSuccess) m_bGrabImage6Result = true;
                        m_bGrabImage6Done = true;
                    }
                    else if (i == 7)
                    {
                        if (m_smVisionInfo.g_blnSaveImageAfterGrab && blnForInspection) m_smVisionInfo.g_arrImages[i - 1].SaveImage("D:\\TSMark\\" + m_intCounter + "_Image" + (i - 1) + ".bmp");
                        if (blnSuccess) m_bGrabImage7Result = true;
                        m_bGrabImage7Done = true;
                    }
                }

                #region if more than 1 image need to be captured
                // Set light source channel ON/OFF
                if (m_intGrabRequire > 1)
                {
                    // Set camera gain
                    if (m_intCameraGainPrev != m_smVisionInfo.g_arrCameraGain[i])
                    {
                        m_objTeliCamera.SetCameraParameter(2, m_smVisionInfo.g_arrCameraGain[i]);
                        m_intCameraGainPrev = m_smVisionInfo.g_arrCameraGain[i];
                        //if (m_objTeliCamera.ref_intSetGainDelay != 0)
                        //    Thread.Sleep(m_objTeliCamera.ref_intSetGainDelay);
                    }

                    // Set camera shuttle
                    if (m_fCameraShuttlePrev != m_smVisionInfo.g_arrCameraShuttle[i])
                    {
                        m_objTeliCamera.SetCameraParameter(1, m_smVisionInfo.g_arrCameraShuttle[i]);
                        m_fCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[i];
                        //if (m_objTeliCamera.ref_intSetGainDelay != 0)
                        //    Thread.Sleep(m_objTeliCamera.ref_intSetGainDelay);
                    }
                }
                #endregion

                timer_TotalGrabTime.Start();
                if (i == 0)
                {
                    if (m_smCustomizeInfo.g_blnVTControl)
                    {
                        m_objTeliCamera.OutPort(1, 3);
                    }
                }

                if (blnSuccess)//2021-10-21 ZJYEOH : No need to grab anymore if not success, as this will reset the camera error message
                {
                    if (!m_objTeliCamera.Grab())
                    {
                        blnSuccess = false;
                        m_blnForceStopProduction = true;
                    }
                }
                //objTL.WriteLine("grab time at last line "+i.ToString()+" = " + fTotalGrabTime.ToString());
            }

            if (!m_objTeliCamera.WaitFrameReady())
            {
                blnSuccess = false;
                m_blnForceStopProduction = true;
            }

            if (blnSuccess)
            {
                SetGrabDone(blnForInspection);
                m_smVisionInfo.g_objTransferTime.Start();

                if (m_objTeliCamera.GetFrame(m_intGrabRequire - 1))
                {
                    if (m_objTeliCamera.ConvertFrame(m_intGrabRequire - 1))
                    {
                        if (m_smVisionInfo.g_blnViewColorImage)
                        {
                            m_smVisionInfo.g_objMemoryColorImage.SetImageSize(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight);
                            m_smVisionInfo.g_objMemoryColorImage.LoadImageFromMemory(m_objTeliCamera.GetImagePointer());
                            m_smVisionInfo.g_objMemoryColorImage.CopyTo(ref m_smVisionInfo.g_arrColorImages, m_intGrabRequire - 1);
                            ConvertColorToMono(m_intGrabRequire - 1);
                            m_smVisionInfo.g_arrImages[m_intGrabRequire - 1].AddGain(m_smVisionInfo.g_arrImageGain[m_intGrabRequire - 1]);
                        }
                        else
                        {
                            m_smVisionInfo.g_objMemoryImage.SetImageSize(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight);
                            m_smVisionInfo.g_objMemoryImage.LoadImageFromMemory(m_objTeliCamera.GetImagePointer());

                            if (m_smVisionInfo.g_intRotateFlip == 1)
                            {
                                m_smVisionInfo.g_objMemoryImage.Rotate180Image(ref m_smVisionInfo.g_ojRotateImage, false);
                            }
                            else if (m_smVisionInfo.g_intRotateFlip == 2)
                            {
                                m_smVisionInfo.g_objMemoryImage.Rotate90Image(ref m_smVisionInfo.g_ojRotateImage, false);
                            }
                            else if (m_smVisionInfo.g_intRotateFlip == 3)
                            {
                                m_smVisionInfo.g_objMemoryImage.RotateMinus90Image(ref m_smVisionInfo.g_ojRotateImage, false);
                            }
                            else if (m_smVisionInfo.g_intRotateFlip == 4)
                            {
                                m_smVisionInfo.g_objMemoryImage.FlipHorizontalImage(ref m_smVisionInfo.g_ojRotateImage, false);
                            }
                            else if (m_smVisionInfo.g_intRotateFlip == 5)
                            {
                                m_smVisionInfo.g_objMemoryImage.FlipVerticalImage(ref m_smVisionInfo.g_ojRotateImage, false);
                            }
                            else
                            {
                                m_smVisionInfo.g_objMemoryImage.CopyTo(ref m_smVisionInfo.g_ojRotateImage);
                            }

                            if (m_smProductionInfo.g_blnAllRunGrabWithoutUseImage)
                            {
                                if (m_smVisionInfo.g_arrDebugImages.Count != m_smVisionInfo.g_arrImages.Count)
                                {
                                    for (int d = 0; d < m_smVisionInfo.g_arrImages.Count; d++)
                                    {
                                        m_smVisionInfo.g_arrDebugImages.Add(new ImageDrawing(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight));
                                    }
                                }

                                m_smVisionInfo.g_ojRotateImage.CopyTo(ref m_smVisionInfo.g_arrDebugImages, m_intGrabRequire - 1);
                                m_smVisionInfo.g_arrDebugImages[m_intGrabRequire - 1].AddGain(m_smVisionInfo.g_arrImageGain[m_intGrabRequire - 1]);
                            }
                            else
                            {
                                m_smVisionInfo.g_ojRotateImage.CopyTo(ref m_smVisionInfo.g_arrImages, m_intGrabRequire - 1);
                                m_smVisionInfo.g_arrImages[m_intGrabRequire - 1].AddGain(m_smVisionInfo.g_arrImageGain[m_intGrabRequire - 1]);
                            }
                        }

                        if (m_intGrabRequire == 1)
                        {
                            if (m_smVisionInfo.g_blnSaveImageAfterGrab && blnForInspection) m_smVisionInfo.g_arrImages[m_intGrabRequire - 1].SaveImage("D:\\TSMark\\" + m_intCounter + "_Image" + (m_intGrabRequire - 1) + ".bmp");
                            if (blnSuccess) m_bGrabImage1Result = true;
                            m_bGrabImage1Done = true;
                        }
                        else if (m_intGrabRequire == 2)
                        {
                            if (m_smVisionInfo.g_blnSaveImageAfterGrab && blnForInspection) m_smVisionInfo.g_arrImages[m_intGrabRequire - 1].SaveImage("D:\\TSMark\\" + m_intCounter + "_Image" + (m_intGrabRequire - 1) + ".bmp");
                            if (blnSuccess) m_bGrabImage2Result = true;
                            m_bGrabImage2Done = true;
                        }
                        else if (m_intGrabRequire == 3)
                        {
                            if (m_smVisionInfo.g_blnSaveImageAfterGrab && blnForInspection) m_smVisionInfo.g_arrImages[m_intGrabRequire - 1].SaveImage("D:\\TSMark\\" + m_intCounter + "_Image" + (m_intGrabRequire - 1) + ".bmp");
                            if (blnSuccess) m_bGrabImage3Result = true;
                            m_bGrabImage3Done = true;
                        }
                        else if (m_intGrabRequire == 4)
                        {
                            if (m_smVisionInfo.g_blnSaveImageAfterGrab && blnForInspection) m_smVisionInfo.g_arrImages[m_intGrabRequire - 1].SaveImage("D:\\TSMark\\" + m_intCounter + "_Image" + (m_intGrabRequire - 1) + ".bmp");
                            if (blnSuccess) m_bGrabImage4Result = true;
                            m_bGrabImage4Done = true;
                        }
                        else if (m_intGrabRequire == 5)
                        {
                            if (m_smVisionInfo.g_blnSaveImageAfterGrab && blnForInspection) m_smVisionInfo.g_arrImages[m_intGrabRequire - 1].SaveImage("D:\\TSMark\\" + m_intCounter + "_Image" + (m_intGrabRequire - 1) + ".bmp");
                            if (blnSuccess) m_bGrabImage5Result = true;
                            m_bGrabImage5Done = true;
                        }
                        else if (m_intGrabRequire == 6)
                        {
                            if (m_smVisionInfo.g_blnSaveImageAfterGrab && blnForInspection) m_smVisionInfo.g_arrImages[m_intGrabRequire - 1].SaveImage("D:\\TSMark\\" + m_intCounter + "_Image" + (m_intGrabRequire - 1) + ".bmp");
                            if (blnSuccess) m_bGrabImage6Result = true;
                            m_bGrabImage6Done = true;
                        }
                        else if (m_intGrabRequire == 7)
                        {
                            if (m_smVisionInfo.g_blnSaveImageAfterGrab && blnForInspection) m_smVisionInfo.g_arrImages[m_intGrabRequire - 1].SaveImage("D:\\TSMark\\" + m_intCounter + "_Image" + (m_intGrabRequire - 1) + ".bmp");
                            if (blnSuccess) m_bGrabImage7Result = true;
                            m_bGrabImage7Done = true;
                        }
                    }
                }
                timer_TotalGrabTime.Stop();
                fTotalGrabTime = fTotalGrabTime + timer_TotalGrabTime.Duration;
                //objTL.WriteLine("Total grab time after Grab loop = " + fTotalGrabTime.ToString());
            }
            else
                SetGrabDone(blnForInspection);

            m_intCounter++;
            if (m_intCounter >= 5)  // Maximum keep last 5 set of images only. 
            {
                m_intCounter = 0;
            }

            m_bGrabImage1Done = m_bGrabImage2Done = m_bGrabImage3Done = m_bGrabImage4Done = m_bGrabImage5Done = m_bGrabImage6Done = m_bGrabImage7Done = true;

            //Reset outport
            if (m_smCustomizeInfo.g_blnLEDiControl)
            {
                m_objTeliCamera.OutPort(1, 3);
                Thread.Sleep(3);
                m_objTeliCamera.OutPort(1, 0);
            }
            else if (m_smCustomizeInfo.g_blnVTControl)
            {
                m_objTeliCamera.OutPort(1, 0);
            }

            //2021-10-21 ZJYEOH : Set Image to Black if camera fail
            if (!blnSuccess)
            {
                for (int i = 0; i < m_smVisionInfo.g_arrImages.Count; i++)
                {
                    if (m_smVisionInfo.g_blnViewColorImage)
                    {
                        m_smVisionInfo.g_arrColorImages[i].SetImageToBlack();
                        m_smVisionInfo.g_arrColorRotatedImages[i].SetImageToBlack();
                    }
                    m_smVisionInfo.g_arrImages[i].SetImageToBlack();
                    m_smVisionInfo.g_arrRotatedImages[i].SetImageToBlack();
                }
            }

            if (m_objTeliCamera.GetErrorMessage() != "")
            {
                m_smVisionInfo.g_strErrorMessage = m_objTeliCamera.GetErrorMessage();
                m_smVisionInfo.ALL_VM_UpdatePictureBox = true;
                m_smVisionInfo.g_objTransferTime.Stop();

                timer_TotalTime.Stop();
                //objTL.WriteLine("Total grab time = " + fTotalGrabTime.ToString());
                //objTL.WriteLine("Total time = " + timer_TotalTime.Duration.ToString());
                return false;
            }
            else
            {
                // Set camera gain
                if (m_intCameraGainPrev != m_smVisionInfo.g_arrCameraGain[0])
                {
                    m_objTeliCamera.SetCameraParameter(2, m_smVisionInfo.g_arrCameraGain[0]);
                    m_intCameraGainPrev = m_smVisionInfo.g_arrCameraGain[0];
                }

                // Set camera shuttle
                if (m_fCameraShuttlePrev != m_smVisionInfo.g_arrCameraShuttle[0])
                {
                    m_objTeliCamera.SetCameraParameter(1, m_smVisionInfo.g_arrCameraShuttle[0]);
                    m_fCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[0];
                }

                if (m_smVisionInfo.g_bImageStatisticAnalysisON)
                {
                    m_smVisionInfo.g_bImageStatisticAnalysisUpdateInfo = true;

                    while (true)
                    {
                        if (!m_smVisionInfo.g_bImageStatisticAnalysisUpdateInfo)
                            break;

                        Thread.Sleep(1);
                    }
                }

                //AttachImageToROI();
                m_smVisionInfo.g_blnLoadFile = false;
                m_smVisionInfo.ALL_VM_UpdatePictureBox = true;
                m_smVisionInfo.g_objTransferTime.Stop();

                timer_TotalTime.Stop();
                //objTL.WriteLine("Total grab time = " + fTotalGrabTime.ToString());
                //objTL.WriteLine("Total time = " + timer_TotalTime.Duration.ToString());

                return true;
            }
        }
        public bool GrabImage_Sequence_NoSetIntensity_Teli_GrabAllFirst(bool blnForInspection)
        {
            if (!m_objTeliCamera.IsCameraInitDone())
            {
                m_bGrabImage1Result = m_bGrabImage2Result = m_bGrabImage3Result = m_bGrabImage4Result = m_bGrabImage5Result = m_bGrabImage6Result = m_bGrabImage7Result = true;
                m_bGrabImage1Done = m_bGrabImage2Done = m_bGrabImage3Done = m_bGrabImage4Done = m_bGrabImage5Done = m_bGrabImage6Done = m_bGrabImage7Done = true;
                m_smVisionInfo.g_strErrorMessage = "Camera No Connected";
                return true;
            }

            // Using Teli Camera
            m_smVisionInfo.g_objGrabTime.Start();

            // Set camera gain
            if (m_intCameraGainPrev != m_smVisionInfo.g_arrCameraGain[0])
            {
                m_objTeliCamera.SetCameraParameter(2, m_smVisionInfo.g_arrCameraGain[0]);
                m_intCameraGainPrev = m_smVisionInfo.g_arrCameraGain[0];
                //if (m_objTeliCamera.ref_intSetGainDelay != 0)
                //    Thread.Sleep(m_objTeliCamera.ref_intSetGainDelay);
            }

            // Set camera shuttle
            if (m_fCameraShuttlePrev != m_smVisionInfo.g_arrCameraShuttle[0])
            {
                m_objTeliCamera.SetCameraParameter(1, m_smVisionInfo.g_arrCameraShuttle[0]);
                m_fCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[0];
                //if (m_objTeliCamera.ref_intSetGainDelay != 0)
                //    Thread.Sleep(m_objTeliCamera.ref_intSetGainDelay);
            }

            Thread.Sleep(m_smVisionInfo.g_intCameraGrabDelay);

            bool blnSuccess = true;
            bool blnSeparateGrab = m_smVisionInfo.g_blnSeparateGrab;
            int intSelectedImage = m_smVisionInfo.g_intSelectedImage;

            TrackLog objTL = new TrackLog();
            float fTotalGrabTime = 0f;
            HiPerfTimer timer_TotalTime = new HiPerfTimer();
            HiPerfTimer timer_TotalGrabTime = new HiPerfTimer();
            timer_TotalTime.Start();
            m_arrBufferPointer = new List<IntPtr>();

            for (int i = 0; i < m_intGrabRequire; i++)
            {

                if (i > 0)
                {
                    if (m_objTeliCamera.WaitTriggerWaitDone())
                    {
                        // Set camera gain
                        if (m_intCameraGainPrev != m_smVisionInfo.g_arrCameraGain[i])
                        {
                            m_objTeliCamera.SetCameraParameter(2, m_smVisionInfo.g_arrCameraGain[i]);
                            m_intCameraGainPrev = m_smVisionInfo.g_arrCameraGain[i];
                        }

                        if (/*!blnStartGrab &&*/ !m_objTeliCamera.Grab(i))
                        {
                            blnSuccess = false;
                            m_blnForceStopProduction = true;
                        }
                    }
                    else
                    {
                        blnSuccess = false;
                        m_blnForceStopProduction = true;
                    }
                }
                else
                {
                    if (/*!blnStartGrab &&*/ !m_objTeliCamera.Grab(i))
                    {
                        blnSuccess = false;
                        m_blnForceStopProduction = true;
                    }
                }

                //Set light source channel ON / OFF
                if (m_intGrabRequire > 1 && ((i + 1) < m_smVisionInfo.g_arrCameraShuttle.Count))
                {

                    // Set camera shuttle
                    if (m_fCameraShuttlePrev != m_smVisionInfo.g_arrCameraShuttle[i + 1])
                    {
                        m_objTeliCamera.SetCameraParameter(1, m_smVisionInfo.g_arrCameraShuttle[i + 1]);
                        m_fCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[i + 1];
                        //if (m_objTeliCamera.ref_intSetGainDelay != 0)
                        //    Thread.Sleep(m_objTeliCamera.ref_intSetGainDelay);
                    }

                }

                if (!m_objTeliCamera.WaitFrameAcquiredReady(i))
                {
                    blnSuccess = false;
                    m_blnForceStopProduction = true;
                }

            }

            if (blnSuccess)
            {
                //m_objTeliCamera.TriggerImageBufferRead();
                SetGrabDone(blnForInspection);
                m_smVisionInfo.g_objTransferTime.Start();

            }
            else
                SetGrabDone(blnForInspection);

            if (!m_objTeliCamera.WaitTriggerWaitDone())
            {
                blnSuccess = false;
                m_blnForceStopProduction = true;
            }

            for (int i = 0; i < m_intGrabRequire; i++)
            {
                if (m_smProductionInfo.g_blnAllRunGrabWithoutUseImage)
                {
                    if (m_smVisionInfo.g_blnViewColorImage)
                    {
                        if (m_smVisionInfo.g_arrDebugColorImages.Count != m_smVisionInfo.g_arrColorImages.Count)
                        {
                            for (int d = 0; d < m_smVisionInfo.g_arrColorImages.Count; d++)
                            {
                                m_smVisionInfo.g_arrDebugColorImages.Add(new CImageDrawing(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight));
                            }
                        }
                        m_objTeliCamera.ConvertImage(i);
                        m_smVisionInfo.g_arrMemoryColorImage[i].LoadImageFromMemory(m_objTeliCamera.GetImagePointer());

                        if (m_smVisionInfo.g_intRotateFlip == 1)
                        {
                            m_smVisionInfo.g_arrMemoryColorImage[i].Rotate180Image(ref m_smVisionInfo.g_arrCRotateImage, i);
                        }
                        else if (m_smVisionInfo.g_intRotateFlip == 2)
                        {
                            m_smVisionInfo.g_arrMemoryColorImage[i].Rotate90Image(ref m_smVisionInfo.g_arrCRotateImage, i);
                        }
                        else if (m_smVisionInfo.g_intRotateFlip == 3)
                        {
                            m_smVisionInfo.g_arrMemoryColorImage[i].RotateMinus90Image(ref m_smVisionInfo.g_arrCRotateImage, i);
                        }
                        else if (m_smVisionInfo.g_intRotateFlip == 4)
                        {
                            m_smVisionInfo.g_arrMemoryColorImage[i].FlipHorizontalImage(ref m_smVisionInfo.g_arrCRotateImage, i);
                        }
                        else if (m_smVisionInfo.g_intRotateFlip == 5)
                        {
                            m_smVisionInfo.g_arrMemoryColorImage[i].FlipVerticalImage(ref m_smVisionInfo.g_arrCRotateImage, i);
                        }
                        else
                        {
                            m_smVisionInfo.g_arrMemoryColorImage[i].CopyTo(ref m_smVisionInfo.g_arrCRotateImage, i);
                        }

                        m_smVisionInfo.g_arrCRotateImage[i].CopyTo(ref m_smVisionInfo.g_arrDebugColorImages, i);

                        if (m_smVisionInfo.g_arrImageGain[i] != 1f)
                        {
                            m_smVisionInfo.g_arrDebugColorImages[i].AddGain(m_smVisionInfo.g_arrImageGain[i], m_smVisionInfo.g_intColorFormat);
                        }

                        if (i == 0)
                        {
                            if (m_smVisionInfo.g_blnEnhanceImage_Enable)
                            {
                                if (m_smVisionInfo.g_intEnhanceImage_Close > 0)
                                    m_smVisionInfo.g_arrDebugColorImages[i].AddCloseMorphology(m_smVisionInfo.g_intEnhanceImage_Close);
                                if (m_smVisionInfo.g_intEnhanceImage_Open > 0)
                                    m_smVisionInfo.g_arrDebugColorImages[i].AddOpenMorphology(m_smVisionInfo.g_intEnhanceImage_Open);
                                if (m_smVisionInfo.g_intEnhanceImage_Dilate > 0)
                                    m_smVisionInfo.g_arrDebugColorImages[i].AddDilate(m_smVisionInfo.g_intEnhanceImage_Dilate);
                                if (m_smVisionInfo.g_intEnhanceImage_Offset != 0)
                                    m_smVisionInfo.g_arrDebugColorImages[i].AddOffset(m_smVisionInfo.g_intEnhanceImage_Offset, m_smVisionInfo.g_intColorFormat);
                                if (m_smVisionInfo.g_fEnhanceImage_Gain != 1f)
                                    m_smVisionInfo.g_arrDebugColorImages[i].AddGain(m_smVisionInfo.g_fEnhanceImage_Gain, m_smVisionInfo.g_intColorFormat);
                            }
                        }

                        m_smVisionInfo.g_arrDebugColorImages[i].ConvertColorToMono(ref m_smVisionInfo.g_arrDebugImages, i);
                    }
                }
                else
                {
                    if (m_smVisionInfo.g_blnViewColorImage)
                    {
                        //m_objTeliCamera.ConvertImage(i);
                        //m_objTeliCamera.ConvertImage(/*m_arrBitmapData[i],*/ m_arrBufferPointer[i]);
                        m_objTeliCamera.ConvertImage(i);
                        m_smVisionInfo.g_arrMemoryColorImage[i].LoadImageFromMemory(m_objTeliCamera.GetImagePointer());

                        if (m_smVisionInfo.g_intRotateFlip == 1)
                        {
                            m_smVisionInfo.g_arrMemoryColorImage[i].Rotate180Image(ref m_smVisionInfo.g_arrCRotateImage, i);
                        }
                        else if (m_smVisionInfo.g_intRotateFlip == 2)
                        {
                            m_smVisionInfo.g_arrMemoryColorImage[i].Rotate90Image(ref m_smVisionInfo.g_arrCRotateImage, i);
                        }
                        else if (m_smVisionInfo.g_intRotateFlip == 3)
                        {
                            m_smVisionInfo.g_arrMemoryColorImage[i].RotateMinus90Image(ref m_smVisionInfo.g_arrCRotateImage, i);
                        }
                        else if (m_smVisionInfo.g_intRotateFlip == 4)
                        {
                            m_smVisionInfo.g_arrMemoryColorImage[i].FlipHorizontalImage(ref m_smVisionInfo.g_arrCRotateImage, i);
                        }
                        else if (m_smVisionInfo.g_intRotateFlip == 5)
                        {
                            m_smVisionInfo.g_arrMemoryColorImage[i].FlipVerticalImage(ref m_smVisionInfo.g_arrCRotateImage, i);
                        }
                        else
                        {
                            m_smVisionInfo.g_arrMemoryColorImage[i].CopyTo(ref m_smVisionInfo.g_arrCRotateImage, i);
                        }

                        m_smVisionInfo.g_arrCRotateImage[i].CopyTo(ref m_smVisionInfo.g_arrColorImages, i);

                        if (m_smVisionInfo.g_arrImageGain[i] != 1f)
                        {
                            m_smVisionInfo.g_arrColorImages[i].AddGain(m_smVisionInfo.g_arrImageGain[i], m_smVisionInfo.g_intColorFormat);
                        }

                        if (i == 0)
                        {
                            if (m_smVisionInfo.g_blnEnhanceImage_Enable)
                            {
                                if (m_smVisionInfo.g_intEnhanceImage_Close > 0)
                                    m_smVisionInfo.g_arrColorImages[i].AddCloseMorphology(m_smVisionInfo.g_intEnhanceImage_Close);
                                if (m_smVisionInfo.g_intEnhanceImage_Open > 0)
                                    m_smVisionInfo.g_arrColorImages[i].AddOpenMorphology(m_smVisionInfo.g_intEnhanceImage_Open);
                                if (m_smVisionInfo.g_intEnhanceImage_Dilate > 0)
                                    m_smVisionInfo.g_arrColorImages[i].AddDilate(m_smVisionInfo.g_intEnhanceImage_Dilate);
                                if (m_smVisionInfo.g_intEnhanceImage_Offset != 0)
                                    m_smVisionInfo.g_arrColorImages[i].AddOffset(m_smVisionInfo.g_intEnhanceImage_Offset, m_smVisionInfo.g_intColorFormat);
                                if (m_smVisionInfo.g_fEnhanceImage_Gain != 1f)
                                    m_smVisionInfo.g_arrColorImages[i].AddGain(m_smVisionInfo.g_fEnhanceImage_Gain, m_smVisionInfo.g_intColorFormat);
                            }
                        }

                        m_smVisionInfo.g_arrColorImages[i].ConvertColorToMono(ref m_smVisionInfo.g_arrImages, i);

                    }
                }

                if (m_smProductionInfo.g_blnAllRunGrabWithoutUseImage)
                {
                    if (m_smVisionInfo.g_arrDebugImages.Count != m_smVisionInfo.g_arrImages.Count)
                    {
                        for (int d = 0; d < m_smVisionInfo.g_arrImages.Count; d++)
                        {
                            m_smVisionInfo.g_arrDebugImages.Add(new ImageDrawing(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight));
                        }
                    }
                    if (!m_smVisionInfo.g_blnViewColorImage)
                    {
                        m_smVisionInfo.g_arrMemoryImage[i].LoadImageFromMemory(m_objTeliCamera.GetImageBufferPointer(i));//(m_objTeliCamera.GetImagePointer());

                        if (m_smVisionInfo.g_intRotateFlip == 1)
                        {
                            m_smVisionInfo.g_arrMemoryImage[i].Rotate180Image(ref m_smVisionInfo.g_arrRotateImage, i);
                        }
                        else if (m_smVisionInfo.g_intRotateFlip == 2)
                        {
                            m_smVisionInfo.g_arrMemoryImage[i].Rotate90Image(ref m_smVisionInfo.g_arrRotateImage, i);
                        }
                        else if (m_smVisionInfo.g_intRotateFlip == 3)
                        {
                            m_smVisionInfo.g_arrMemoryImage[i].RotateMinus90Image(ref m_smVisionInfo.g_arrRotateImage, i);
                        }
                        else if (m_smVisionInfo.g_intRotateFlip == 4)
                        {
                            m_smVisionInfo.g_arrMemoryImage[i].FlipHorizontalImage(ref m_smVisionInfo.g_arrRotateImage, i);
                        }
                        else if (m_smVisionInfo.g_intRotateFlip == 5)
                        {
                            m_smVisionInfo.g_arrMemoryImage[i].FlipVerticalImage(ref m_smVisionInfo.g_arrRotateImage, i);
                        }
                        else
                        {
                            m_smVisionInfo.g_arrMemoryImage[i].CopyTo(ref m_smVisionInfo.g_arrRotateImage, i);
                        }
                        m_smVisionInfo.g_arrRotateImage[i].CopyTo(ref m_smVisionInfo.g_arrDebugImages, i);
                        m_smVisionInfo.g_arrDebugImages[i].AddGain(m_smVisionInfo.g_arrImageGain[i]);

                        // 2020 12 30 - CCENG: Do image processing to increase image contrast. (to solve mark no enough contrast case)
                        if (i == 0)
                        {
                            if (m_smVisionInfo.g_blnEnhanceImage_Enable)
                            {
                                if (m_smVisionInfo.g_intEnhanceImage_Close > 0)
                                    m_smVisionInfo.g_arrDebugImages[i].AddCloseMorphology(m_smVisionInfo.g_intEnhanceImage_Close);
                                if (m_smVisionInfo.g_intEnhanceImage_Open > 0)
                                    m_smVisionInfo.g_arrDebugImages[i].AddOpenMorphology(m_smVisionInfo.g_intEnhanceImage_Open);
                                if (m_smVisionInfo.g_intEnhanceImage_Dilate > 0)
                                    m_smVisionInfo.g_arrDebugImages[i].AddDilate(m_smVisionInfo.g_intEnhanceImage_Dilate);
                                if (m_smVisionInfo.g_intEnhanceImage_Offset != 0)
                                    m_smVisionInfo.g_arrDebugImages[i].AddOffset(m_smVisionInfo.g_intEnhanceImage_Offset);
                                if (m_smVisionInfo.g_fEnhanceImage_Gain != 1f)
                                    m_smVisionInfo.g_arrDebugImages[i].AddGain(m_smVisionInfo.g_fEnhanceImage_Gain);
                            }
                        }
                    }

                }
                else
                {
                    if (!m_smVisionInfo.g_blnViewColorImage)
                    {
                        m_smVisionInfo.g_arrMemoryImage[i].LoadImageFromMemory(m_objTeliCamera.GetImageBufferPointer(i));//(m_objTeliCamera.GetImagePointer());

                        if (m_smVisionInfo.g_intRotateFlip == 1)
                        {
                            m_smVisionInfo.g_arrMemoryImage[i].Rotate180Image(ref m_smVisionInfo.g_arrRotateImage, i);
                        }
                        else if (m_smVisionInfo.g_intRotateFlip == 2)
                        {
                            m_smVisionInfo.g_arrMemoryImage[i].Rotate90Image(ref m_smVisionInfo.g_arrRotateImage, i);
                        }
                        else if (m_smVisionInfo.g_intRotateFlip == 3)
                        {
                            m_smVisionInfo.g_arrMemoryImage[i].RotateMinus90Image(ref m_smVisionInfo.g_arrRotateImage, i);
                        }
                        else if (m_smVisionInfo.g_intRotateFlip == 4)
                        {
                            m_smVisionInfo.g_arrMemoryImage[i].FlipHorizontalImage(ref m_smVisionInfo.g_arrRotateImage, i);
                        }
                        else if (m_smVisionInfo.g_intRotateFlip == 5)
                        {
                            m_smVisionInfo.g_arrMemoryImage[i].FlipVerticalImage(ref m_smVisionInfo.g_arrRotateImage, i);
                        }
                        else
                        {
                            m_smVisionInfo.g_arrMemoryImage[i].CopyTo(ref m_smVisionInfo.g_arrRotateImage, i);
                        }
                        m_smVisionInfo.g_arrRotateImage[i].CopyTo(ref m_smVisionInfo.g_arrImages, i);
                        m_smVisionInfo.g_arrImages[i].AddGain(m_smVisionInfo.g_arrImageGain[i]);

                        // 2020 12 30 - CCENG: Do image processing to increase image contrast. (to solve mark no enough contrast case)
                        if (i == 0)
                        {
                            if (m_smVisionInfo.g_blnEnhanceImage_Enable)
                            {
                                if (m_smVisionInfo.g_intEnhanceImage_Close > 0)
                                    m_smVisionInfo.g_arrImages[i].AddCloseMorphology(m_smVisionInfo.g_intEnhanceImage_Close);
                                if (m_smVisionInfo.g_intEnhanceImage_Open > 0)
                                    m_smVisionInfo.g_arrImages[i].AddOpenMorphology(m_smVisionInfo.g_intEnhanceImage_Open);
                                if (m_smVisionInfo.g_intEnhanceImage_Dilate > 0)
                                    m_smVisionInfo.g_arrImages[i].AddDilate(m_smVisionInfo.g_intEnhanceImage_Dilate);
                                if (m_smVisionInfo.g_intEnhanceImage_Offset != 0)
                                    m_smVisionInfo.g_arrImages[i].AddOffset(m_smVisionInfo.g_intEnhanceImage_Offset);
                                if (m_smVisionInfo.g_fEnhanceImage_Gain != 1f)
                                    m_smVisionInfo.g_arrImages[i].AddGain(m_smVisionInfo.g_fEnhanceImage_Gain);
                            }
                        }
                    }

                }

                // STTrackLog.WriteLine("Grab i = " + i.ToString());
                if (i == 0)
                {
                    if (m_smVisionInfo.g_blnSaveImageAfterGrab) m_smVisionInfo.g_arrImages[i].SaveImage("D:\\TSMark\\" + m_intCounter + ".bmp");
                    //      STTrackLog.WriteLine("Grab 1 done.");
                    if (blnSuccess) m_bGrabImage1Result = true;
                    m_bGrabImage1Done = true;
                }
                else if (i == 1)
                {
                    if (m_smVisionInfo.g_blnSaveImageAfterGrab) m_smVisionInfo.g_arrImages[i].SaveImage("D:\\TSMark\\" + m_intCounter + "_Image" + (i) + ".bmp");
                    if (blnSuccess) m_bGrabImage2Result = true;
                    m_bGrabImage2Done = true;
                }
                else if (i == 2)
                {
                    if (m_smVisionInfo.g_blnSaveImageAfterGrab) m_smVisionInfo.g_arrImages[i].SaveImage("D:\\TSMark\\" + m_intCounter + "_Image" + (i) + ".bmp");
                    if (blnSuccess) m_bGrabImage3Result = true;
                    m_bGrabImage3Done = true;
                }
                else if (i == 3)
                {
                    if (m_smVisionInfo.g_blnSaveImageAfterGrab) m_smVisionInfo.g_arrImages[i].SaveImage("D:\\TSMark\\" + m_intCounter + "_Image" + (i) + ".bmp");
                    if (blnSuccess) m_bGrabImage4Result = true;
                    m_bGrabImage4Done = true;
                }
                else if (i == 4)
                {
                    if (m_smVisionInfo.g_blnSaveImageAfterGrab) m_smVisionInfo.g_arrImages[i].SaveImage("D:\\TSMark\\" + m_intCounter + "_Image" + (i) + ".bmp");
                    if (blnSuccess) m_bGrabImage5Result = true;
                    m_bGrabImage5Done = true;
                }
                else if (i == 5)
                {
                    if (m_smVisionInfo.g_blnSaveImageAfterGrab) m_smVisionInfo.g_arrImages[i].SaveImage("D:\\TSMark\\" + m_intCounter + "_Image" + (i) + ".bmp");
                    if (blnSuccess) m_bGrabImage6Result = true;
                    m_bGrabImage6Done = true;
                }
                else if (i == 6)
                {
                    if (m_smVisionInfo.g_blnSaveImageAfterGrab) m_smVisionInfo.g_arrImages[i].SaveImage("D:\\TSMark\\" + m_intCounter + "_Image" + (i) + ".bmp");
                    if (blnSuccess) m_bGrabImage7Result = true;
                    m_bGrabImage7Done = true;
                }

            }

            //m_intCounter++;
            m_bGrabImage1Done = m_bGrabImage2Done = m_bGrabImage3Done = m_bGrabImage4Done = m_bGrabImage5Done = m_bGrabImage6Done = m_bGrabImage7Done = true;

            //Reset outport
            if (m_smCustomizeInfo.g_blnLEDiControl)
            {
                m_objTeliCamera.OutPort(1, 3);
                Thread.Sleep(3);
                m_objTeliCamera.OutPort(1, 0);
            }
            else if (m_smCustomizeInfo.g_blnVTControl)
            {
                m_objTeliCamera.OutPort(1, 0);
            }

            //2021-10-21 ZJYEOH : Set Image to Black if camera fail
            if (!blnSuccess)
            {
                for (int i = 0; i < m_smVisionInfo.g_arrImages.Count; i++)
                {
                    if (m_smVisionInfo.g_blnViewColorImage)
                    {
                        m_smVisionInfo.g_arrColorImages[i].SetImageToBlack();
                        m_smVisionInfo.g_arrColorRotatedImages[i].SetImageToBlack();
                    }
                    m_smVisionInfo.g_arrImages[i].SetImageToBlack();
                    m_smVisionInfo.g_arrRotatedImages[i].SetImageToBlack();
                }
            }

            if (m_objTeliCamera.GetErrorMessage() != "")
            {
                m_smVisionInfo.g_strErrorMessage = m_objTeliCamera.GetErrorMessage();
                m_smVisionInfo.ALL_VM_UpdatePictureBox = true;
                m_smVisionInfo.g_objTransferTime.Stop();

                timer_TotalTime.Stop();
                //objTL.WriteLine("Total grab time = " + fTotalGrabTime.ToString());
                //objTL.WriteLine("Total time = " + timer_TotalTime.Duration.ToString());
                return false;
            }
            else
            {
                // Set camera gain
                if (m_intCameraGainPrev != m_smVisionInfo.g_arrCameraGain[0])
                {
                    m_objTeliCamera.SetCameraParameter(2, m_smVisionInfo.g_arrCameraGain[0]);
                    m_intCameraGainPrev = m_smVisionInfo.g_arrCameraGain[0];
                }

                // Set camera shuttle
                if (m_fCameraShuttlePrev != m_smVisionInfo.g_arrCameraShuttle[0])
                {
                    m_objTeliCamera.SetCameraParameter(1, m_smVisionInfo.g_arrCameraShuttle[0]);
                    m_fCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[0];
                }

                if (m_smVisionInfo.g_bImageStatisticAnalysisON)
                {
                    m_smVisionInfo.g_bImageStatisticAnalysisUpdateInfo = true;

                    while (true)
                    {
                        if (!m_smVisionInfo.g_bImageStatisticAnalysisUpdateInfo)
                            break;

                        Thread.Sleep(1);
                    }
                }

                //AttachImageToROI();
                m_smVisionInfo.g_blnLoadFile = false;
                m_smVisionInfo.ALL_VM_UpdatePictureBox = true;
                m_smVisionInfo.g_objTransferTime.Stop();

                timer_TotalTime.Stop();
                //objTL.WriteLine("Total grab time = " + fTotalGrabTime.ToString());
                //objTL.WriteLine("Total time = " + timer_TotalTime.Duration.ToString());

                return true;
            }
        }
        public bool GrabImage_Sequence_NoSetIntensity_Teli_HighSpeedOrColor(bool blnForInspection)
        {
            if (!m_objTeliCamera.IsCameraInitDone())
            {
                m_bGrabImage1Result = m_bGrabImage2Result = m_bGrabImage3Result = m_bGrabImage4Result = m_bGrabImage5Result = m_bGrabImage6Result = m_bGrabImage7Result = true; // 2020 07 17 - CCENG: Set Result before Set Done.
                m_bGrabImage1Done = m_bGrabImage2Done = m_bGrabImage3Done = m_bGrabImage4Done = m_bGrabImage5Done = m_bGrabImage6Done = m_bGrabImage7Done = true;
                //m_bGrabImage1Result = m_bGrabImage2Result = m_bGrabImage3Result = m_bGrabImage4Result = m_bGrabImage5Result = true;
                m_bGrabImage1LoadDone = m_bGrabImage2LoadDone = m_bGrabImage3LoadDone = m_bGrabImage4LoadDone = m_bGrabImage5LoadDone = m_bGrabImage6LoadDone = m_bGrabImage7LoadDone = true;
                m_bGrabImage1LoadResult = m_bGrabImage2LoadResult = m_bGrabImage3LoadResult = m_bGrabImage4LoadResult = m_bGrabImage5LoadResult = m_bGrabImage6LoadResult = m_bGrabImage7LoadResult = true;
                m_bGrabImage1TriggerDone = m_bGrabImage2TriggerDone = m_bGrabImage3TriggerDone = m_bGrabImage4TriggerDone = m_bGrabImage5TriggerDone = m_bGrabImage6TriggerDone = m_bGrabImage7TriggerDone = true;
                m_bGrabImage1TriggerResult = m_bGrabImage2TriggerResult = m_bGrabImage3TriggerResult = m_bGrabImage4TriggerResult = m_bGrabImage5TriggerResult = m_bGrabImage6TriggerResult = m_bGrabImage7TriggerResult = true;
                m_smVisionInfo.g_strErrorMessage = "Camera No Connected";
                return true;
            }

            m_smVisionInfo.g_objGrabTime.Start();

            //10-07-2019 ZJYEOH : Check the shuttle and gain again because PH got other setting
            // Set camera gain
            if (m_intCameraGainPrev != m_smVisionInfo.g_arrCameraGain[0])
            {
                m_objTeliCamera.SetCameraParameter(2, m_smVisionInfo.g_arrCameraGain[0]);
                m_intCameraGainPrev = m_smVisionInfo.g_arrCameraGain[0];
            }

            // Set camera shuttle
            if (m_fCameraShuttlePrev != m_smVisionInfo.g_arrCameraShuttle[0])
            {
                m_objTeliCamera.SetCameraParameter(1, m_smVisionInfo.g_arrCameraShuttle[0]);
                m_fCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[0];
            }

            if (m_dRedRatioPrev != m_smVisionInfo.g_dRedRatio)
            {
                m_objTeliCamera.SetWhiteBalance_ForRed(m_smVisionInfo.g_dRedRatio);
                m_dRedRatioPrev = m_smVisionInfo.g_dRedRatio;
            }

            if (m_dBlueRatioPrev != m_smVisionInfo.g_dBlueRatio)
            {
                m_objTeliCamera.SetWhiteBalance_ForBlue(m_smVisionInfo.g_dBlueRatio);
                m_dBlueRatioPrev = m_smVisionInfo.g_dBlueRatio;
            }

            Thread.Sleep(m_smVisionInfo.g_intCameraGrabDelay);

            if (m_smVisionInfo.g_blnWhiteBalanceAuto)
            {
                m_objTeliCamera.SetWhiteBalanceAuto();
            }

            bool blnSuccess = true;
            bool blnSeparateGrab = m_smVisionInfo.g_blnSeparateGrab;
            int intSelectedImage = m_smVisionInfo.g_intSelectedImage;
            m_bGrabImage1Result = m_bGrabImage2Result = m_bGrabImage3Result = m_bGrabImage4Result = m_bGrabImage5Result = m_bGrabImage6Result = m_bGrabImage7Result = false;
            m_bGrabImage1LoadDone = m_bGrabImage2LoadDone = m_bGrabImage3LoadDone = m_bGrabImage4LoadDone = m_bGrabImage5LoadDone = m_bGrabImage6LoadDone = m_bGrabImage7LoadDone = false;
            m_bGrabImage1LoadResult = m_bGrabImage2LoadResult = m_bGrabImage3LoadResult = m_bGrabImage4LoadResult = m_bGrabImage5LoadResult = m_bGrabImage6LoadResult = m_bGrabImage7LoadResult = false;
            m_bGrabImage1TriggerDone = m_bGrabImage2TriggerDone = m_bGrabImage3TriggerDone = m_bGrabImage4TriggerDone = m_bGrabImage5TriggerDone = m_bGrabImage6TriggerDone = m_bGrabImage7TriggerDone = false;
            m_bGrabImage1TriggerResult = m_bGrabImage2TriggerResult = m_bGrabImage3TriggerResult = m_bGrabImage4TriggerResult = m_bGrabImage5TriggerResult = m_bGrabImage6TriggerResult = m_bGrabImage7TriggerResult = false;

            m_arrBufferPointer = new List<IntPtr>();
            m_bSubTh1_TransferImage = true;
            m_bSubTh1_WaitFrame = true;

            for (int i = 0; i < m_intGrabRequire; i++)
            {
                if (blnSeparateGrab)
                {
                    if (i != intSelectedImage)
                        continue;
                }

                if (i > 0)
                {
                    bool blnStartTransfer2 = false;
                    switch (i - 1)
                    {
                        case 0:
                            blnStartTransfer2 = WaitEventDone(ref m_bGrabImage1LoadDone, true, ref m_bGrabImage1LoadResult, "WaitGrab1");
                            break;
                        case 1:
                            blnStartTransfer2 = WaitEventDone(ref m_bGrabImage2LoadDone, true, ref m_bGrabImage2LoadResult, "WaitGrab2");
                            break;
                        case 2:
                            blnStartTransfer2 = WaitEventDone(ref m_bGrabImage3LoadDone, true, ref m_bGrabImage3LoadResult, "WaitGrab3");
                            break;
                        case 3:
                            blnStartTransfer2 = WaitEventDone(ref m_bGrabImage4LoadDone, true, ref m_bGrabImage4LoadResult, "WaitGrab4");
                            break;
                        case 4:
                            blnStartTransfer2 = WaitEventDone(ref m_bGrabImage5LoadDone, true, ref m_bGrabImage5LoadResult, "WaitGrab5");
                            break;
                        case 5:
                            blnStartTransfer2 = WaitEventDone(ref m_bGrabImage6LoadDone, true, ref m_bGrabImage6LoadResult, "WaitGrab6");
                            break;
                        case 6:
                            blnStartTransfer2 = WaitEventDone(ref m_bGrabImage7LoadDone, true, ref m_bGrabImage7LoadResult, "WaitGrab7");
                            break;
                        default:
                            blnStartTransfer2 = false;
                            break;
                    }
                    if (blnStartTransfer2)  //if (m_objTeliCamera.WaitTriggerWaitDone())
                    {
                        // Set camera gain
                        if (m_intCameraGainPrev != m_smVisionInfo.g_arrCameraGain[i])
                        {
                            m_objTeliCamera.SetCameraParameter(2, m_smVisionInfo.g_arrCameraGain[i]);
                            m_intCameraGainPrev = m_smVisionInfo.g_arrCameraGain[i];
                        }

                        if (/*!blnStartGrab &&*/ !m_objTeliCamera.Grab(i))
                        {
                            blnSuccess = false;
                            m_blnForceStopProduction = true;
                        }
                    }
                    else
                    {
                        STTrackLog.WriteLine("GrabImage_Sequence_NoSetIntensity_Teli_HighSpeedOrColor > blnStartTransfer2 " + (i - 1).ToString() + " fail");
                        blnSuccess = false;
                        m_blnForceStopProduction = true;
                    }
                }
                else
                {
                    if (/*!blnStartGrab &&*/ !m_objTeliCamera.Grab(i))
                    {
                        blnSuccess = false;
                        m_blnForceStopProduction = true;
                    }
                }

                if (m_intGrabRequire > 1 && ((i + 1) < m_smVisionInfo.g_arrCameraShuttle.Count))
                {
                    // Set camera shuttle
                    if (m_fCameraShuttlePrev != m_smVisionInfo.g_arrCameraShuttle[i + 1])
                    {
                        m_objTeliCamera.SetCameraParameter(1, m_smVisionInfo.g_arrCameraShuttle[i + 1]);
                        m_fCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[i + 1];
                    }
                }

                if (i == 0)//1
                {
                    m_bGrabImage1TriggerResult = blnSuccess;
                    m_bGrabImage1TriggerDone = true;
                }
                else if (i == 1)//2
                {
                    m_bGrabImage2TriggerResult = blnSuccess;
                    m_bGrabImage2TriggerDone = true;
                }
                else if (i == 2)//3
                {
                    m_bGrabImage3TriggerResult = blnSuccess;
                    m_bGrabImage3TriggerDone = true;
                }
                else if (i == 3)//4
                {
                    m_bGrabImage4TriggerResult = blnSuccess;
                    m_bGrabImage4TriggerDone = true;
                }
                else if (i == 4)//5
                {
                    m_bGrabImage5TriggerResult = blnSuccess;
                    m_bGrabImage5TriggerDone = true;
                }
                else if (i == 5)//6
                {
                    m_bGrabImage6TriggerResult = blnSuccess;
                    m_bGrabImage6TriggerDone = true;
                }
                else if (i == 6)//7
                {
                    m_bGrabImage7TriggerResult = blnSuccess;
                    m_bGrabImage7TriggerDone = true;
                }
            }

            // --- After last grab ---------------------------------------------------------------------------------------------------------------------------
            m_bGrabImage1TriggerDone = m_bGrabImage2TriggerDone = m_bGrabImage3TriggerDone = m_bGrabImage4TriggerDone = m_bGrabImage5TriggerDone = m_bGrabImage6TriggerDone = m_bGrabImage7TriggerDone = true;

            bool blnStartTransfer = false;
            switch (m_intGrabRequire - 1)
            {
                case 0:
                    blnStartTransfer = WaitEventDone(ref m_bGrabImage1LoadDone, true, ref m_bGrabImage1LoadResult, "WaitGrab1");
                    break;
                case 1:
                    blnStartTransfer = WaitEventDone(ref m_bGrabImage2LoadDone, true, ref m_bGrabImage2LoadResult, "WaitGrab2");
                    break;
                case 2:
                    blnStartTransfer = WaitEventDone(ref m_bGrabImage3LoadDone, true, ref m_bGrabImage3LoadResult, "WaitGrab3");
                    break;
                case 3:
                    blnStartTransfer = WaitEventDone(ref m_bGrabImage4LoadDone, true, ref m_bGrabImage4LoadResult, "WaitGrab4");
                    break;
                case 4:
                    blnStartTransfer = WaitEventDone(ref m_bGrabImage5LoadDone, true, ref m_bGrabImage5LoadResult, "WaitGrab5");
                    break;
                case 5:
                    blnStartTransfer = WaitEventDone(ref m_bGrabImage6LoadDone, true, ref m_bGrabImage6LoadResult, "WaitGrab6");
                    break;
                case 6:
                    blnStartTransfer = WaitEventDone(ref m_bGrabImage7LoadDone, true, ref m_bGrabImage7LoadResult, "WaitGrab7");
                    break;
                default:
                    blnStartTransfer = false;
                    break;
            }
            if (!blnStartTransfer)
            {
                STTrackLog.WriteLine("GrabImage_Sequence_NoSetIntensity_Teli_HighSpeedOrColor > blnStartTransfer last " + m_intGrabRequire.ToString() + " fail");
                blnSuccess = false;
                m_blnForceStopProduction = true;
            }

            if (blnSuccess)
            {
                SetGrabDone(blnForInspection);
                m_smVisionInfo.g_objTransferTime.Start();
            }
            else
                SetGrabDone(blnForInspection);

            //Reset outport
            if (m_smCustomizeInfo.g_blnLEDiControl)
            {
                m_objTeliCamera.OutPort(1, 3);
                //Thread.Sleep(3);
                m_objTeliCamera.OutPort(1, 0);
            }
            else if (m_smCustomizeInfo.g_blnVTControl)
            {
                m_objTeliCamera.OutPort(1, 0);
            }

            // Set camera gain
            if (m_intCameraGainPrev != m_smVisionInfo.g_arrCameraGain[0])
            {
                m_objTeliCamera.SetCameraParameter(2, m_smVisionInfo.g_arrCameraGain[0]);
                m_intCameraGainPrev = m_smVisionInfo.g_arrCameraGain[0];
            }

            // Set camera shuttle
            if (m_fCameraShuttlePrev != m_smVisionInfo.g_arrCameraShuttle[0])
            {
                m_objTeliCamera.SetCameraParameter(1, m_smVisionInfo.g_arrCameraShuttle[0]);
                m_fCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[0];
            }

            if (m_smVisionInfo.g_blnWhiteBalanceAuto)
            {
                double dRedRatio = 0, dBlueRatio = 0;
                m_objTeliCamera.GetWhiteBalance(ref dRedRatio, ref dBlueRatio);

                m_smVisionInfo.g_dRedRatio = dRedRatio;
                m_smVisionInfo.g_dBlueRatio = dBlueRatio;

                m_smVisionInfo.g_blnWhiteBalanceAuto = false;
            }

            WaitEventDone(ref m_bSubTh1_TransferImage, false, 10000, "WaitTransferDone");

            //2021-10-21 ZJYEOH : Set Image to Black if camera fail
            if (!blnSuccess)
            {
                for (int i = 0; i < m_smVisionInfo.g_arrImages.Count; i++)
                {
                    if (m_smVisionInfo.g_blnViewColorImage)
                    {
                        m_smVisionInfo.g_arrColorImages[i].SetImageToBlack();
                        m_smVisionInfo.g_arrColorRotatedImages[i].SetImageToBlack();
                    }
                    m_smVisionInfo.g_arrImages[i].SetImageToBlack();
                    m_smVisionInfo.g_arrRotatedImages[i].SetImageToBlack();
                }
            }

            if (m_objTeliCamera.GetErrorMessage() != "")
            {
                m_smVisionInfo.g_strErrorMessage = m_objTeliCamera.GetErrorMessage();
                m_smVisionInfo.ALL_VM_UpdatePictureBox = true;
                m_smVisionInfo.g_objTransferTime.Stop();

                return false;
            }
            else
            {
                if (m_smVisionInfo.g_bImageStatisticAnalysisON)
                {
                    m_smVisionInfo.g_bImageStatisticAnalysisUpdateInfo = true;

                    HiPerfTimer timesout = new HiPerfTimer();
                    timesout.Start();

                    while (true)
                    {
                        if (!m_smVisionInfo.g_bImageStatisticAnalysisUpdateInfo)
                            break;

                        if (timesout.Timing > 3000)
                        {
                            STTrackLog.WriteLine(">>>>>>>>>>>>> time out 1");
                            break;
                        }

                        Thread.Sleep(1);
                    }
                }

                //AttachImageToROI();
                m_smVisionInfo.g_blnLoadFile = false;
                m_smVisionInfo.ALL_VM_UpdatePictureBox = true;
                m_smVisionInfo.g_objTransferTime.Stop();

                return true;
            }
        }
        public bool InitCamera(int intPort, String SerialNo, int intResolutionX, int intResolutionY, bool blnFirstTime)
        {
            bool blnInitSuccess = true;

            if (blnFirstTime)
            {
                if (m_smVisionInfo.g_strCameraModel == "AVT")
                {
                    if (!m_objAVTFireGrab.InitializeCamera(intPort, false))
                    {
                        blnInitSuccess = false;
                        SRMMessageBox.Show("Serial No. " + intPort + " - " + m_smVisionInfo.g_strVisionDisplayName + " " + m_objAVTFireGrab.ref_strErrorText);
                    }
                }
                else if (m_smVisionInfo.g_strCameraModel == "Teli")
                {
                    if (!m_objTeliCamera.InitializeCamera(SerialNo, intResolutionX, intResolutionY))
                    {
                        blnInitSuccess = false;
                        SRMMessageBox.Show("Serial No. " + SerialNo + " - " + m_smVisionInfo.g_strVisionDisplayName + " " + m_objTeliCamera.GetErrorMessage());
                    }
                }
            }
            RegistryKey Key = Registry.LocalMachine.OpenSubKey("Software", true);
            RegistryKey subKey = Key.OpenSubKey("SVG\\LightControl", true);
            string[] strLightControlMaskList = subKey.GetValueNames();

            string strCameraFilePath = m_smProductionInfo.g_strRecipePath + m_smProductionInfo.g_arrSingleRecipeID[m_smVisionInfo.g_intVisionIndex] + "\\Camera.xml";
            if (m_smVisionInfo.g_blnGlobalSharingCameraData)
                strCameraFilePath = AppDomain.CurrentDomain.BaseDirectory + "DeviceNo\\GlobalCamera.xml";

            XmlParser fileHandle = new XmlParser(m_smProductionInfo.g_strRecipePath + "Camera.xml");
            XmlParser objFileHandle = new XmlParser(strCameraFilePath);
            fileHandle.GetFirstSection(m_smVisionInfo.g_strVisionName);
            objFileHandle.GetFirstSection(m_smVisionInfo.g_strVisionFolderName);

            m_smVisionInfo.g_fCameraShuttle = objFileHandle.GetValueAsFloat("Shutter", 200f);
            if (m_smVisionInfo.g_strCameraModel == "AVT")
            {
                m_objAVTFireGrab.SetCameraParameter(1, Convert.ToUInt32(m_smVisionInfo.g_fCameraShuttle));
                m_objAVTFireGrab.SetCameraParameter(4, objFileHandle.GetValueAsUInt("Gamma", 0));
                if (m_smVisionInfo.g_blnViewColorImage)
                {
                    m_objAVTFireGrab.SetCameraParameter(5, objFileHandle.GetValueAsUInt("UBValue", 0));
                    m_objAVTFireGrab.SetCameraParameter(6, objFileHandle.GetValueAsUInt("VRValue", 0));
                }
            }
            else if (m_smVisionInfo.g_strCameraModel == "Teli")
            {

            }
            m_smVisionInfo.g_intCameraGrabDelay = objFileHandle.GetValueAsInt("GrabDelay", 5);

            m_smVisionInfo.g_arrLightSource.Clear();

            string[] arrName = subKey.GetSubKeyNames();          // Get Related CommPort List
            for (int x = 0; x < arrName.Length; x++)
            {
                RegistryKey child = subKey.OpenSubKey(arrName[x], true);
                RegistryKey grandChild = child.CreateSubKey(m_smVisionInfo.g_strVisionFolderName);

                string[] arrType = grandChild.GetValueNames();
                for (int i = 0; i < arrType.Length; i++)
                {
                    LightSource objLightSource = new LightSource();
                    objLightSource.ref_strCommPort = arrName[x];
                    objLightSource.ref_strType = arrType[i];
                    objLightSource.ref_intChannel = Convert.ToInt32(grandChild.GetValue(arrType[i], 1));

                    string strSearch = arrType[i].Replace(" ", string.Empty);

                    bool blnLightMaskingFound = false;
                    for (int y = 0; y < strLightControlMaskList.Length; y++)
                    {
                        if (strLightControlMaskList[y].Contains(m_smVisionInfo.g_strVisionName + " - " + arrType[i]))
                            blnLightMaskingFound = true;
                    }
                    if (blnLightMaskingFound)
                        objLightSource.ref_intSeqNo = Convert.ToInt32(subKey.GetValue(m_smVisionInfo.g_strVisionName + " - " + arrType[i], 1));
                    else
                    {
                        objLightSource.ref_intSeqNo = fileHandle.GetValueAsInt(strSearch, 1);
                        subKey.SetValue(m_smVisionInfo.g_strVisionName + " - " + arrType[i], objLightSource.ref_intSeqNo);
                    }

                    objLightSource.ref_intValue = objFileHandle.GetValueAsInt(arrType[i], 31);
                    objLightSource.ref_intPortNo = x;
                    int intCameraOutNo = Convert.ToInt32(objLightSource.ref_strType.Substring(objLightSource.ref_strType.Length - 1));

                    if (m_smVisionInfo.g_strCameraModel == "AVT")
                    {
                        if (intCameraOutNo == 0)
                            m_objAVTFireGrab.OutPort(intCameraOutNo, m_smVisionInfo.g_intTriggerMode);
                        else
                            m_objAVTFireGrab.OutPort(intCameraOutNo, 0);


                    }
                    else if (m_smVisionInfo.g_strCameraModel == "Teli")
                    {
                        if (intCameraOutNo == 0)
                            m_objTeliCamera.OutPort(intCameraOutNo, m_smVisionInfo.g_intTriggerMode);
                        else
                            m_objTeliCamera.OutPort(intCameraOutNo, 0);
                    }

                    objLightSource.ref_arrValue = new List<int>();
                    objLightSource.ref_arrImageNo = new List<int>();
                    // Maximum grab 7 times
                    for (int j = 0; j < 7; j++)
                    {
                        if ((objLightSource.ref_intSeqNo & (0x01 << j)) > 0)
                        {
                            if (m_intGrabRequire < (j + 1))
                            {
                                m_intGrabRequire = j + 1; // Get highest grab number
                                for (int k = m_smVisionInfo.g_arrImages.Count; k < m_intGrabRequire; k++)
                                {
                                    if (m_smVisionInfo.g_blnViewColorImage)
                                    {
                                        m_smVisionInfo.g_arrColorImages.Add(new CImageDrawing());
                                        m_smVisionInfo.g_arrColorRotatedImages.Add(new CImageDrawing());
                                    }

                                    m_smVisionInfo.g_arrImages.Add(new ImageDrawing());
                                    m_smVisionInfo.g_arrRotatedImages.Add(new ImageDrawing());

                                    m_smVisionInfo.g_arrCameraShuttle.Add(new float());
                                    m_smVisionInfo.g_arrCameraGain.Add(new int());
                                    m_smVisionInfo.g_arrImageGain.Add(new float());
                                }
                            }
                            int intCount = objLightSource.ref_arrValue.Count;

                            objLightSource.ref_arrValue.Add(new int());
                            objLightSource.ref_arrImageNo.Add(new int());
                            objFileHandle.GetSecondSection(objLightSource.ref_strType);
                            objLightSource.ref_arrValue[intCount] = objFileHandle.GetValueAsInt("Seq" + intCount.ToString(), 31, 2);
                            objLightSource.ref_arrImageNo[intCount] = j;
                        }
                    }

                    m_smVisionInfo.g_arrLightSource.Add(objLightSource);

                    if (m_smCustomizeInfo.g_blnLEDiControl)
                    {
                        // 2018 07 18 - JBTAN: some light source is used for grab 1 and grab 2, only set intensity for image grab 1
                        LEDi_Control.SetIntensity(x, objLightSource.ref_intChannel, Convert.ToByte(objLightSource.ref_arrValue[0]));
                    }
                    else if (m_smCustomizeInfo.g_blnVTControl)
                    {
                        VT_Control.SetConfigMode(objLightSource.ref_intPortNo);
                        VT_Control.SetIntensity(x, objLightSource.ref_intChannel, objLightSource.ref_arrValue[0]);
                        VT_Control.SetRunMode(objLightSource.ref_intPortNo);
                    }
                    else
                    {
                        TCOSIO_Control.SetIntensity(x, objLightSource.ref_intChannel, objLightSource.ref_arrValue[0]);
                        TCOSIO_Control.SendMessage(x, "@ST" + objLightSource.ref_intChannel + "1*");    // Set Strobe ON
                        TCOSIO_Control.SendMessage(x, "@SI" + objLightSource.ref_intChannel + "00*");   // Set Constant Intensity to 0
                    }

                    Thread.Sleep(5); // Delay after set intensity to light source controller

                    // Keep light source intensity previous setting
                    m_arrCameraIntensityPrev[i] = objLightSource.ref_intValue;
                }
            }

            if (blnFirstTime)
            {
                InitSaveImageBuffer(m_intGrabRequire);
            }

            // Sorting light source
            LightSource[] arrLightSource = new LightSource[m_smVisionInfo.g_arrLightSource.Count];
            for (int i = 0; i < m_smVisionInfo.g_arrLightSource.Count; i++)
            {
                int intStartIndex = m_smVisionInfo.g_arrLightSource[i].ref_strType.Length - 1;
                int intLightSourceIndex = Convert.ToInt32(m_smVisionInfo.g_arrLightSource[i].ref_strType.Substring(intStartIndex, 1));

                arrLightSource[intLightSourceIndex] = m_smVisionInfo.g_arrLightSource[i];
            }

            m_smVisionInfo.g_arrLightSource.Clear();
            for (int i = 0; i < arrLightSource.Length; i++)
            {
                m_smVisionInfo.g_arrLightSource.Add(arrLightSource[i]);
            }

            if (m_smCustomizeInfo.g_blnVTControl)
            {
                //channel grouping
                int intChannelNum = 0;
                uint uintGroupNum = 0;
                for (int k = 0; k < m_smVisionInfo.g_arrLightSource.Count; k++)
                {
                    intChannelNum = m_smVisionInfo.g_arrLightSource[k].ref_intChannel;
                    //intChannelNum -= 1;
                    uintGroupNum += Convert.ToUInt32(Math.Pow(2, intChannelNum));
                }
                VT_Control.SetConfigMode(m_smVisionInfo.g_arrLightSource[0].ref_intPortNo);
                VT_Control.SetGroupsAvailable(m_smVisionInfo.g_arrLightSource[0].ref_intPortNo, uintGroupNum);
                //Setting active flag
                for (int m = 0; m < m_intGrabRequire; m++)
                {
                    VT_Control.SetActiveOutFlag(m_smVisionInfo.g_arrLightSource[0].ref_intPortNo, uintGroupNum, m, 1);
                }
                VT_Control.SetRunMode(m_smVisionInfo.g_arrLightSource[0].ref_intPortNo);
            }

            for (int i = 0; i < m_smVisionInfo.g_arrCameraShuttle.Count; i++)
            {
                m_smVisionInfo.g_arrCameraShuttle[i] = objFileHandle.GetValueAsFloat("Shutter" + i.ToString(), 0f);

                if (m_smVisionInfo.g_arrCameraShuttle[i] == 0)
                {
                    m_smVisionInfo.g_arrCameraShuttle[i] = Convert.ToUInt32(m_smVisionInfo.g_fCameraShuttle);
                }

                if (i == 0)
                {
                    if (m_smVisionInfo.g_strCameraModel == "AVT")
                        m_objAVTFireGrab.SetCameraParameter(1, (uint)m_smVisionInfo.g_arrCameraShuttle[i]);
                    else if (m_smVisionInfo.g_strCameraModel == "Teli")
                        m_objTeliCamera.SetCameraParameter(1, m_smVisionInfo.g_arrCameraShuttle[i]);

                    m_fCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[i];
                }
            }

            for (int i = 0; i < m_smVisionInfo.g_arrCameraGain.Count; i++)
            {
                m_smVisionInfo.g_arrCameraGain[i] = (uint)objFileHandle.GetValueAsInt("Gain" + i.ToString(), 1);

                if (i == 0)
                {
                    if (m_smVisionInfo.g_strCameraModel == "AVT")
                        m_objAVTFireGrab.SetCameraParameter(2, m_smVisionInfo.g_arrCameraGain[i]);
                    else if (m_smVisionInfo.g_strCameraModel == "Teli")
                        m_objTeliCamera.SetCameraParameter(2, m_smVisionInfo.g_arrCameraGain[i]);

                    m_intCameraGainPrev = m_smVisionInfo.g_arrCameraGain[i];
                }
            }

            for (int i = 0; i < m_smVisionInfo.g_arrImageGain.Count; i++)
            {
                m_smVisionInfo.g_arrImageGain[i] = objFileHandle.GetValueAsFloat("ImageGain" + i.ToString(), 1);
            }

            // Define Image View Count
            m_smVisionInfo.g_intImageViewCount = m_intGrabRequire;
            ImageDrawing.SetImageCount(m_intGrabRequire, m_smVisionInfo.g_intVisionIndex);
            ImageDrawing.SetImageMergeType(m_smVisionInfo.g_intImageMergeType, m_smVisionInfo.g_intVisionIndex);

            if (m_smVisionInfo.g_intSelectedImage >= m_smVisionInfo.g_arrImages.Count)
            {
                m_smVisionInfo.g_intSelectedImage = 0;
            }

            return blnInitSuccess;
        }

        public bool InitCameraSequence(int intPort, String SerialNo, int intResolutionX, int intResolutionY, bool blnFirstTime)
        {
            bool blnInitSuccess = true;

            if (blnFirstTime)
            {
                if (m_smVisionInfo.g_strCameraModel == "AVT")
                {
                    if (!m_objAVTFireGrab.InitializeCamera(intPort, false))
                        blnInitSuccess = false;
                }
                else if (m_smVisionInfo.g_strCameraModel == "Teli")
                {
                    if (m_blnCustomWantColor)
                    {
                        if (!m_objTeliCamera.InitializeCamera_LowLevelAPI(SerialNo, intResolutionX, intResolutionY, true))
                        {
                            blnInitSuccess = false;
                            SRMMessageBox.Show("Serial No. " + SerialNo + " - " + m_smVisionInfo.g_strVisionDisplayName + " " + m_objTeliCamera.GetErrorMessage());

                            if (blnInitSuccess)
                            {
                                double dRedRatio = 0, dBlueRatio = 0;
                                m_objTeliCamera.GetWhiteBalance(ref dRedRatio, ref dBlueRatio);

                                m_dRedRatioPrev = m_smVisionInfo.g_dRedRatio = dRedRatio;
                                m_dBlueRatioPrev = m_smVisionInfo.g_dBlueRatio = dBlueRatio;
                            }
                        }
                    }
                    else
                    {
                        if (m_smVisionInfo.g_intGrabMode == 0)
                        {
                            if (!m_objTeliCamera.InitializeCamera(SerialNo, intResolutionX, intResolutionY))
                            {
                                blnInitSuccess = false;
                                SRMMessageBox.Show("Serial No. " + SerialNo + " - " + m_smVisionInfo.g_strVisionDisplayName + " " + m_objTeliCamera.GetErrorMessage());
                            }
                        }
                        else
                        {
                            if (!m_objTeliCamera.InitializeCamera_LowLevelAPI(SerialNo, intResolutionX, intResolutionY, false))
                            {
                                blnInitSuccess = false;
                                SRMMessageBox.Show("Serial No. " + SerialNo + " - " + m_smVisionInfo.g_strVisionDisplayName + " " + m_objTeliCamera.GetErrorMessage());

                                if (blnInitSuccess)
                                {
                                    double dRedRatio = 0, dBlueRatio = 0;
                                    m_objTeliCamera.GetWhiteBalance(ref dRedRatio, ref dBlueRatio);

                                    m_dRedRatioPrev = m_smVisionInfo.g_dRedRatio = dRedRatio;
                                    m_dBlueRatioPrev = m_smVisionInfo.g_dBlueRatio = dBlueRatio;
                                }
                            }
                        }
                    }
                }
            }
            RegistryKey Key = Registry.LocalMachine.OpenSubKey("Software", true);
            RegistryKey subKey = Key.OpenSubKey("SVG\\LightControl", true);
            string[] strLightControlMaskList = subKey.GetValueNames();

            string strCameraFilePath = m_smProductionInfo.g_strRecipePath + m_smProductionInfo.g_arrSingleRecipeID[m_smVisionInfo.g_intVisionIndex] + "\\Camera.xml";
            if (m_smVisionInfo.g_blnGlobalSharingCameraData)
                strCameraFilePath = AppDomain.CurrentDomain.BaseDirectory + "DeviceNo\\GlobalCamera.xml";

            XmlParser fileHandle = new XmlParser(m_smProductionInfo.g_strRecipePath + "Camera.xml");
            XmlParser objFileHandle = new XmlParser(strCameraFilePath);
            fileHandle.GetFirstSection(m_smVisionInfo.g_strVisionName);
            objFileHandle.GetFirstSection(m_smVisionInfo.g_strVisionFolderName);

            m_smVisionInfo.g_fCameraShuttle = objFileHandle.GetValueAsFloat("Shutter", 200f);
            if (m_smVisionInfo.g_strCameraModel == "AVT")
            {
                m_objAVTFireGrab.SetCameraParameter(1, Convert.ToUInt32(m_smVisionInfo.g_fCameraShuttle));
                m_objAVTFireGrab.SetCameraParameter(4, objFileHandle.GetValueAsUInt("Gamma", 0));
                if (m_smVisionInfo.g_blnViewColorImage)
                {
                    m_objAVTFireGrab.SetCameraParameter(5, objFileHandle.GetValueAsUInt("UBValue", 0));
                    m_objAVTFireGrab.SetCameraParameter(6, objFileHandle.GetValueAsUInt("VRValue", 0));
                }
            }
            else if (m_smVisionInfo.g_strCameraModel == "Teli")
            {
                if (m_smVisionInfo.g_blnViewColorImage)
                {
                    m_smVisionInfo.g_dRedRatio = objFileHandle.GetValueAsDouble("RedRatio", 2.309997559);
                    m_smVisionInfo.g_dBlueRatio = objFileHandle.GetValueAsDouble("BlueRatio", 2.539978027);
                    m_objTeliCamera.SetWhiteBalance_ForRed(m_smVisionInfo.g_dRedRatio);
                    m_objTeliCamera.SetWhiteBalance_ForBlue(m_smVisionInfo.g_dBlueRatio);
                }
            }

            m_smVisionInfo.g_intCameraGrabDelay = objFileHandle.GetValueAsInt("GrabDelay", 5);

            m_smVisionInfo.g_arrLightSource.Clear();

            string[] arrName = subKey.GetSubKeyNames();          // Get Related CommPort List

            //arrName means comport number
            for (int x = 0; x < arrName.Length; x++)
            {
                RegistryKey child = subKey.OpenSubKey(arrName[x], true);
                RegistryKey grandChild = child.CreateSubKey(m_smVisionInfo.g_strVisionFolderName);

                string[] arrType = grandChild.GetValueNames();

                //arrType means light source type
                for (int i = 0; i < arrType.Length; i++)
                {
                    LightSource objLightSource = new LightSource();
                    objLightSource.ref_strCommPort = arrName[x];
                    objLightSource.ref_strType = arrType[i];

                    objLightSource.ref_intChannel = Convert.ToInt32(grandChild.GetValue(arrType[i], 1));

                    string strSearch = arrType[i].Replace(" ", string.Empty);
                    bool blnLightMaskingFound = false;
                    for (int y = 0; y < strLightControlMaskList.Length; y++)
                    {
                        if (strLightControlMaskList[y].Contains(m_smVisionInfo.g_strVisionName + " - " + arrType[i]))
                            blnLightMaskingFound = true;
                    }
                    if (blnLightMaskingFound)
                        objLightSource.ref_intSeqNo = Convert.ToInt32(subKey.GetValue(m_smVisionInfo.g_strVisionName + " - " + arrType[i], 1));
                    else
                    {
                        objLightSource.ref_intSeqNo = fileHandle.GetValueAsInt(strSearch, 1);
                        subKey.SetValue(m_smVisionInfo.g_strVisionName + " - " + arrType[i], objLightSource.ref_intSeqNo);
                    }
                    objLightSource.ref_intValue = 31;// objFileHandle.GetValueAsInt(arrType[i], 31); 2019-09-12 ZJYEOH : do not read this value from XML file because it combine all intensity value in the light source sequence which will exceed 32 bit integer value when have 5 grab 
                    objLightSource.ref_intPortNo = x;

                    if (m_smVisionInfo.g_strCameraModel == "AVT")
                    {
                        //Need to change
                        m_objAVTFireGrab.OutPort(0, m_smVisionInfo.g_intTriggerMode);
                        Thread.Sleep(10);
                        m_objAVTFireGrab.OutPort(1, 5);
                    }
                    else if (m_smVisionInfo.g_strCameraModel == "Teli")
                    {
                        m_objTeliCamera.OutPort(0, m_smVisionInfo.g_intTriggerMode);
                        Thread.Sleep(10);
                        m_objTeliCamera.OutPort(1, 0);
                    }

                    objLightSource.ref_arrValue = new List<int>();
                    objLightSource.ref_arrImageNo = new List<int>();
                    // Maximum grab 7 times
                    for (int j = 0; j < 7; j++)
                    {
                        if ((objLightSource.ref_intSeqNo & (0x01 << j)) > 0)
                        {
                            if (m_intGrabRequire < (j + 1))
                            {
                                m_intGrabRequire = j + 1; // Get highest grab number
                                for (int k = m_smVisionInfo.g_arrImages.Count; k < m_intGrabRequire; k++)
                                {
                                    if (blnFirstTime)
                                    {
                                        if (m_smVisionInfo.g_blnViewColorImage)
                                        {
                                            m_smVisionInfo.g_arrColorImages.Add(new CImageDrawing());
                                            m_smVisionInfo.g_arrColorRotatedImages.Add(new CImageDrawing());
                                            m_smVisionInfo.g_arrMemoryColorImage.Add(new CImageDrawing(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight));
                                            m_smVisionInfo.g_arrCRotateImage.Add(new CImageDrawing(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight));
                                            m_arrColorImage_ForInspection.Add(new CImageDrawing(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight));
                                        }

                                        m_smVisionInfo.g_arrRotateImage.Add(new ImageDrawing(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight));
                                        m_smVisionInfo.g_arrMemoryImage.Add(new ImageDrawing(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight));
                                        m_smVisionInfo.g_arrImages.Add(new ImageDrawing(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight));
                                        m_smVisionInfo.g_arrRotatedImages.Add(new ImageDrawing(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight));

                                        m_smVisionInfo.g_arrCameraShuttle.Add(new float());
                                        m_smVisionInfo.g_arrCameraGain.Add(new int());
                                        m_smVisionInfo.g_arrImageGain.Add(new float());


                                    }
                                }
                            }
                            int intCount = objLightSource.ref_arrValue.Count;

                            objLightSource.ref_arrValue.Add(new int());
                            objLightSource.ref_arrImageNo.Add(new int());
                            objFileHandle.GetSecondSection(objLightSource.ref_strType);
                            objLightSource.ref_arrValue[intCount] = objFileHandle.GetValueAsInt("Seq" + intCount.ToString(), 31, 2);
                            objLightSource.ref_arrImageNo[intCount] = j;
                        }
                    }

                    m_smVisionInfo.g_arrLightSource.Add(objLightSource);

                    // Keep light source intensity previous setting
                    m_arrCameraIntensityPrev[i] = objLightSource.ref_intValue;
                }
            }

            if (blnFirstTime)
            {
                InitSaveImageBuffer(m_intGrabRequire);
            }

            // Sorting light source
            LightSource[] arrLightSource = new LightSource[m_smVisionInfo.g_arrLightSource.Count];
            for (int i = 0; i < m_smVisionInfo.g_arrLightSource.Count; i++)
            {
                int intStartIndex = m_smVisionInfo.g_arrLightSource[i].ref_strType.Length - 1;
                int intLightSourceIndex = Convert.ToInt32(m_smVisionInfo.g_arrLightSource[i].ref_strType.Substring(intStartIndex, 1));

                arrLightSource[intLightSourceIndex] = m_smVisionInfo.g_arrLightSource[i];
            }

            m_smVisionInfo.g_arrLightSource.Clear();
            for (int i = 0; i < arrLightSource.Length; i++)
            {
                m_smVisionInfo.g_arrLightSource.Add(arrLightSource[i]);
            }

            if (m_smCustomizeInfo.g_blnLEDiControl)
            {
                //Set to stop mode
                LEDi_Control.RunStop(m_smVisionInfo.g_arrLightSource[0].ref_intPortNo, 0, false);
                Thread.Sleep(10);
                for (int i = 0; i < m_intGrabRequire; i++)
                {
                    int intValue1 = 0;
                    int intValue2 = 0;
                    int intValue3 = 0;
                    int intValue4 = 0;

                    if (m_intGrabRequire > 0)
                    {
                        for (int j = 0; j < m_smVisionInfo.g_arrLightSource.Count; j++)
                        {
                            int intValueNo = 0;

                            // Due to some light source only ON for second image so its intensity value is at array no. 0.
                            // So we need to loop to find which array no. is for that image
                            for (int k = 0; k < m_smVisionInfo.g_arrLightSource[j].ref_arrValue.Count; k++)
                            {
                                // if this image no is in array k
                                if (m_smVisionInfo.g_arrLightSource[j].ref_arrImageNo != null)
                                {
                                    if (m_smVisionInfo.g_arrLightSource[j].ref_arrImageNo[k] == i)
                                    {
                                        intValueNo = k;

                                        switch (j)
                                        {
                                            case 0:
                                                if ((m_smVisionInfo.g_arrLightSource[j].ref_intSeqNo & (0x01 << i)) > 0)
                                                {
                                                    intValue1 = m_smVisionInfo.g_arrLightSource[j].ref_arrValue[intValueNo];
                                                }
                                                break;
                                            case 1:
                                                if ((m_smVisionInfo.g_arrLightSource[j].ref_intSeqNo & (0x01 << i)) > 0)
                                                {
                                                    intValue2 = m_smVisionInfo.g_arrLightSource[j].ref_arrValue[intValueNo];
                                                }
                                                break;
                                            case 2:
                                                if ((m_smVisionInfo.g_arrLightSource[j].ref_intSeqNo & (0x01 << i)) > 0)
                                                {
                                                    intValue3 = m_smVisionInfo.g_arrLightSource[j].ref_arrValue[intValueNo];
                                                }
                                                break;
                                            case 3:
                                                if ((m_smVisionInfo.g_arrLightSource[j].ref_intSeqNo & (0x01 << i)) > 0)
                                                {
                                                    intValue4 = m_smVisionInfo.g_arrLightSource[j].ref_arrValue[intValueNo];
                                                }
                                                break;
                                        }

                                        break;
                                    }
                                }
                            }
                        }
                        //Set all light source for sequence light controller for each grab
                        LEDi_Control.SetSeqIntensity(m_smVisionInfo.g_arrLightSource[0].ref_intPortNo, 0, i, intValue1, intValue2, intValue3, intValue4);
                        Thread.Sleep(10);
                        TrackLog objTL = new TrackLog();
                        objTL.WriteLine("Vision 1");
                        objTL.WriteLine("Sequence number: " + i.ToString());
                        objTL.WriteLine("Com: " + m_smVisionInfo.g_arrLightSource[0].ref_intPortNo.ToString());
                        objTL.WriteLine("Intensity 1: " + intValue1.ToString());
                        objTL.WriteLine("Intensity 2: " + intValue2.ToString());
                        objTL.WriteLine("Intensity 3: " + intValue3.ToString());
                    }
                }
                LEDi_Control.SaveIntensity(m_smVisionInfo.g_arrLightSource[0].ref_intPortNo, 0);
                Thread.Sleep(100);
                //Set to run mode
                LEDi_Control.RunStop(m_smVisionInfo.g_arrLightSource[0].ref_intPortNo, 0, true);

                Thread.Sleep(10);
            }
            else if (m_smCustomizeInfo.g_blnVTControl)
            {
                //channel grouping
                int intChannelNum = 0;
                uint uintGroupNum = 0;
                for (int k = 0; k < m_smVisionInfo.g_arrLightSource.Count; k++)
                {
                    intChannelNum = m_smVisionInfo.g_arrLightSource[k].ref_intChannel;
                    //intChannelNum -= 1;
                    uintGroupNum += Convert.ToUInt32(Math.Pow(2, intChannelNum));
                }

                TrackLog objTL = new TrackLog();
                objTL.WriteLine("m_smVisionInfo.g_arrLightSource[0].ref_intPortNo=" + m_smVisionInfo.g_arrLightSource[0].ref_intPortNo.ToString());
                objTL.WriteLine("uintGroupNum=" + uintGroupNum.ToString());
                VT_Control.SetConfigMode(m_smVisionInfo.g_arrLightSource[0].ref_intPortNo);
                VT_Control.SetGroupsAvailable(m_smVisionInfo.g_arrLightSource[0].ref_intPortNo, uintGroupNum);

                //Setting active flag
                for (int m = 0; m < m_intGrabRequire; m++)
                {
                    objTL.WriteLine("SetActiveOutFlag m=" + m.ToString());
                    VT_Control.SetActiveOutFlag(m_smVisionInfo.g_arrLightSource[0].ref_intPortNo, uintGroupNum, m, 1);
                }

                for (int j = 0; j < m_smVisionInfo.g_arrLightSource.Count; j++)
                {
                    int intCount = 0;
                    for (int i = 0; i < m_intGrabRequire; i++)
                    {
                        if (m_intGrabRequire > 0)
                        {
                            // if this image no is in array intCount
                            if (m_smVisionInfo.g_arrLightSource[j].ref_arrImageNo != null)
                            {
                                if (m_smVisionInfo.g_arrLightSource[j].ref_arrImageNo.Count != intCount)
                                {
                                    if (m_smVisionInfo.g_arrLightSource[j].ref_arrImageNo[intCount] == i)
                                    {
                                        objTL.WriteLine("Set Seq Intensity A Port=" + m_smVisionInfo.g_arrLightSource[j].ref_intPortNo.ToString() +
                                                        ", i=" + i.ToString() +
                                                        ", channel=" + m_smVisionInfo.g_arrLightSource[j].ref_intChannel.ToString() +
                                                        ", value=" + m_smVisionInfo.g_arrLightSource[j].ref_arrValue[intCount].ToString());
                                        VT_Control.SetSeqIntensity(m_smVisionInfo.g_arrLightSource[j].ref_intPortNo, i, m_smVisionInfo.g_arrLightSource[j].ref_intChannel, m_smVisionInfo.g_arrLightSource[j].ref_arrValue[intCount]);
                                        intCount++;
                                    }
                                    else
                                    {
                                        objTL.WriteLine("Set Seq Intensity B Port=" + m_smVisionInfo.g_arrLightSource[j].ref_intPortNo.ToString() +
                                                        ", i=" + i.ToString() +
                                                        ", channel=" + m_smVisionInfo.g_arrLightSource[j].ref_intChannel.ToString() +
                                                        ", value=0");

                                        VT_Control.SetSeqIntensity(m_smVisionInfo.g_arrLightSource[j].ref_intPortNo, i, m_smVisionInfo.g_arrLightSource[j].ref_intChannel, 0);
                                    }
                                }
                                else
                                {
                                    objTL.WriteLine("Set Seq Intensity C Port=" + m_smVisionInfo.g_arrLightSource[j].ref_intPortNo.ToString() +
                                                    ", i=" + i.ToString() +
                                                    ", channel=" + m_smVisionInfo.g_arrLightSource[j].ref_intChannel.ToString() +
                                                    ", value=0");

                                    VT_Control.SetSeqIntensity(m_smVisionInfo.g_arrLightSource[j].ref_intPortNo, i, m_smVisionInfo.g_arrLightSource[j].ref_intChannel, 0);
                                }
                            }
                        }
                    }
                    //VT_Control.SaveIntensity(m_smVisionInfo.g_arrLightSource[j].ref_intPortNo, m_smVisionInfo.g_arrLightSource[j].ref_intChannel);
                }

                objTL.WriteLine("SetRunMode=" + m_smVisionInfo.g_arrLightSource[0].ref_intPortNo.ToString());
                VT_Control.SetRunMode(m_smVisionInfo.g_arrLightSource[0].ref_intPortNo);
            }
            for (int i = 0; i < m_smVisionInfo.g_arrCameraShuttle.Count; i++)
            {
                m_smVisionInfo.g_arrCameraShuttle[i] = objFileHandle.GetValueAsFloat("Shutter" + i.ToString(), 0f);

                if (m_smVisionInfo.g_arrCameraShuttle[i] == 0)
                {
                    m_smVisionInfo.g_arrCameraShuttle[i] = Convert.ToUInt32(m_smVisionInfo.g_fCameraShuttle);
                }

                if (i == 0)
                {
                    if (m_smVisionInfo.g_strCameraModel == "AVT")
                        m_objAVTFireGrab.SetCameraParameter(1, (uint)m_smVisionInfo.g_arrCameraShuttle[i]);
                    else if (m_smVisionInfo.g_strCameraModel == "Teli")
                        m_objTeliCamera.SetCameraParameter(1, m_smVisionInfo.g_arrCameraShuttle[i]);
                    m_fCameraShuttlePrev = m_smVisionInfo.g_arrCameraShuttle[i];
                }
            }

            for (int i = 0; i < m_smVisionInfo.g_arrCameraGain.Count; i++)
            {
                m_smVisionInfo.g_arrCameraGain[i] = (uint)objFileHandle.GetValueAsInt("Gain" + i.ToString(), 1);

                if (i == 0)
                {
                    if (m_smVisionInfo.g_strCameraModel == "AVT")
                        m_objAVTFireGrab.SetCameraParameter(2, m_smVisionInfo.g_arrCameraGain[i]);
                    else if (m_smVisionInfo.g_strCameraModel == "Teli")
                        m_objTeliCamera.SetCameraParameter(2, m_smVisionInfo.g_arrCameraGain[i]);

                    m_intCameraGainPrev = m_smVisionInfo.g_arrCameraGain[i];
                }
            }

            for (int i = 0; i < m_smVisionInfo.g_arrImageGain.Count; i++)
            {
                m_smVisionInfo.g_arrImageGain[i] = objFileHandle.GetValueAsFloat("ImageGain" + i.ToString(), 1);
            }

            objFileHandle.GetSecondSection("EnhanceImage");
            m_smVisionInfo.g_intEnhanceImage_Close = objFileHandle.GetValueAsInt("EnhanceImage_Close", 0, 2);
            m_smVisionInfo.g_blnEnhanceImage_Enable = objFileHandle.GetValueAsBoolean("EnhanceImage_Enable", false, 2);
            m_smVisionInfo.g_intEnhanceImage_Open = objFileHandle.GetValueAsInt("EnhanceImage_Open", 1, 2);
            m_smVisionInfo.g_intEnhanceImage_Dilate = objFileHandle.GetValueAsInt("EnhanceImage_Dilate", 1, 2);
            m_smVisionInfo.g_intEnhanceImage_Offset = objFileHandle.GetValueAsInt("EnhanceImage_Offset", -50, 2);
            m_smVisionInfo.g_fEnhanceImage_Gain = objFileHandle.GetValueAsFloat("EnhanceImage_Gain", 2, 2);

            // Define Image View Count
            m_smVisionInfo.g_intImageViewCount = m_intGrabRequire;
            ImageDrawing.SetImageCount(m_intGrabRequire, m_smVisionInfo.g_intVisionIndex);
            ImageDrawing.SetImageMergeType(m_smVisionInfo.g_intImageMergeType, m_smVisionInfo.g_intVisionIndex);
            if (m_smVisionInfo.g_blnViewColorImage)
            {
                CImageDrawing.SetImageCount(m_intGrabRequire, m_smVisionInfo.g_intVisionIndex);
                CImageDrawing.SetImageMergeType(m_smVisionInfo.g_intImageMergeType, m_smVisionInfo.g_intVisionIndex);
            }

            if (m_smVisionInfo.g_blnViewColorImage)
            {
                if (m_smVisionInfo.g_intSelectedImage >= m_smVisionInfo.g_arrColorImages.Count)
                {
                    m_smVisionInfo.g_intSelectedImage = 0;
                }
            }
            else
            {
                if (m_smVisionInfo.g_intSelectedImage >= m_smVisionInfo.g_arrImages.Count)
                {
                    m_smVisionInfo.g_intSelectedImage = 0;
                }
            }

            return blnInitSuccess;
        }


        /// <summary>
        /// Returns whether the worker thread has stopped.
        /// </summary>
        public bool IsThreadStopped
        {
            get
            {
                //lock (m_objStopLock)
                {
                    return m_blnStopped;
                }
            }
        }


        /// <summary>
        /// Tells the thread to stop, typically after completing its 
        /// current work item.
        /// </summary>
        public void StopThread()
        {
            //lock (m_objStopLock)
            {
                m_blnStopping = true;
            }

            WaitAllThreadStopped();
        }

        public void PauseThread()
        {
            m_blnPause = true;
        }

        public void StartThread()
        {
            m_blnPause = false;
        }

        private void AttachImageToROI()
        {
            //// ENG?
            //for (int i = 0; i < m_smVisionInfo.g_arrImages.Count; i++)
            //{
            //    if (m_smVisionInfo.g_blnViewColorImage)
            //    {
            //        m_smVisionInfo.g_arrColorImages[i].CopyTo(m_smVisionInfo.g_arrColorRotatedImages[i]);
            //        m_smVisionInfo.g_arrColorImages[i].ConvertColorToMono(m_smVisionInfo.g_arrImages[i]);
            //    }

            //    m_smVisionInfo.g_arrImages[i].CopyTo(m_smVisionInfo.g_arrRotatedImages[i]);
            //}

            if (m_smVisionInfo.g_arrImages.Count > 0)
            {
                m_smVisionInfo.g_objCameraROI.AttachImage(m_smVisionInfo.g_arrImages[0]);
                m_smVisionInfo.g_objCalibrateROI.AttachImage(m_smVisionInfo.g_arrImages[0]);

                if ((m_smCustomizeInfo.g_intWantOrient & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
                    AttachToROI(m_smVisionInfo.g_arrOrientROIs, m_smVisionInfo.g_arrImages[0]);

                if ((m_smCustomizeInfo.g_intWantMark & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
                    AttachToROI(m_smVisionInfo.g_arrMarkROIs, m_smVisionInfo.g_arrImages[0]);

                if ((m_smCustomizeInfo.g_intWantPackage & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
                {
                    AttachToROI(m_smVisionInfo.g_arrPackageROIs, m_smVisionInfo.g_arrImages[0]);

                    if (m_smVisionInfo.g_blnViewColorImage)
                        AttachToROI(m_smVisionInfo.g_arrColorPackageROIs, m_smVisionInfo.g_arrColorImages[0]);
                }
                //if ((m_smCustomizeInfo.g_intWantLead & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
                //    AttachToROI(m_smVisionInfo.g_arrLeadROIs, m_smVisionInfo.g_arrImages, m_smVisionInfo.g_arrLead[0].ref_intImageViewNo);
            }

            m_smVisionInfo.VS_VM_UpdateSmallPictureBox = true;
        }

        // 2019 03 07 - JBTAN: convert color to mono for selected image
        private void ConvertColorToMono(int intIndex)
        {
            m_smVisionInfo.g_arrColorImages[intIndex].ConvertColorToMono(m_smVisionInfo.g_arrImages[intIndex]);
        }

        private void AttachToROI(List<List<ROI>> arrROI, ImageDrawing objImage)
        {
            ROI objROI;

            for (int i = 0; i < arrROI.Count; i++)
            {
                for (int j = 0; j < arrROI[i].Count; j++)
                {
                    objROI = arrROI[i][j];

                    switch (objROI.ref_intType)
                    {
                        case 1:
                            objROI.AttachImage(objImage);   // Search ROI attach to image
                            break;
                        case 2:
                            objROI.AttachImage(arrROI[i][0]);  // Train ROI attach to search roi
                            break;
                        case 4:
                            objROI.AttachImage(arrROI[i][1]);   // Sub ROI attach to Train ROI
                            break;
                    }
                    arrROI[i][j] = objROI;
                }
            }

            objROI = null;
        }

        private void AttachToROI(List<List<CROI>> arrROI, CImageDrawing objImage)
        {
            CROI objROI;

            for (int i = 0; i < arrROI.Count; i++)
            {
                for (int j = 0; j < arrROI[i].Count; j++)
                {
                    objROI = (CROI)arrROI[i][j];

                    switch (objROI.ref_intType)
                    {
                        case 1:
                            objROI.AttachImage(objImage);
                            break;
                        case 2:
                            objROI.AttachImage((CROI)arrROI[i][0]);
                            break;
                    }
                    arrROI[i][j] = objROI;
                }
            }

            objROI = null;
        }

        /// <summary>
        /// Attach ROI to its parent ROI or parent image
        /// </summary>
        /// <param name="arrROI">ROI</param>
        /// <param name="objImage">parent image</param>
        private void AttachToROI(List<List<ROI>> arrROI, List<ImageDrawing> arrImage, int intLeadImageIndex)
        {
            ROI objROI;

            for (int i = 0; i < arrROI.Count; i++)
            {
                for (int j = 0; j < arrROI[i].Count; j++)
                {
                    objROI = (ROI)arrROI[i][j];

                    switch (objROI.ref_intType)
                    {
                        case 1:
                            if (arrImage.Count > 3)
                                objROI.AttachImage(arrImage[3]); //attach ROI to image 4 if image 4 is available
                            else if (arrImage.Count > 1)
                                objROI.AttachImage(arrImage[intLeadImageIndex]); //attach ROI to image intLeadImageIndex if image 4 is not available
                            else
                                objROI.AttachImage(arrImage[0]);
                            break;
                    }
                    arrROI[i][j] = objROI;
                }
            }

            objROI = null;
        }

        private void CheckLowYield()
        {
            if (!m_smVisionInfo.g_blnStopLowYield)//m_smCustomizeInfo.g_blnStopLowYield)
                return;

            if (m_smVisionInfo.g_intTestedTotal != 0)
            {
                float fYield = m_smVisionInfo.g_intPassTotal / (float)m_smVisionInfo.g_intTestedTotal * 100;
                if ((fYield <= m_smVisionInfo.g_fLowYield) && (m_smVisionInfo.g_intLowYieldUnitCount >= m_smVisionInfo.g_intMinUnitCheck)) //m_smCustomizeInfo.g_fLowYield , m_smCustomizeInfo.g_intMinUnitCheck
                {
                    m_smProductionInfo.PR_AT_StopProduction = true;
                    m_smVisionInfo.g_intMachineStatus = 1;
                    m_smVisionInfo.g_intLowYieldUnitCount = 0;
                    m_smVisionInfo.g_strErrorMessage += "Low Yield Fail!";
                }
            }
        }
        private void CheckContinuousPass()
        {
            if (!m_smVisionInfo.g_blnStopContinuousPass)
                return;

            if (m_smVisionInfo.g_intTestedTotal != 0)
            {
                if (m_smVisionInfo.g_intContinuousPassUnitCount >= m_smVisionInfo.g_intMinPassUnit)
                {
                    m_smProductionInfo.PR_AT_StopProduction = true;
                    m_smVisionInfo.g_intMachineStatus = 1;
                    m_smVisionInfo.g_intContinuousPassUnitCount = 0;
                    m_smVisionInfo.g_strErrorMessage += "*Continuous Pass " + m_smVisionInfo.g_intMinPassUnit.ToString() + " Unit(s)!";
                }
            }
        }

        private void CheckContinuousFail()
        {
            if (!m_smVisionInfo.g_blnStopContinuousFail)
                return;

            if (m_smVisionInfo.g_intTestedTotal != 0)
            {
                if (m_smVisionInfo.g_intContinuousFailUnitCount >= m_smVisionInfo.g_intMinFailUnit)
                {
                    m_smProductionInfo.PR_AT_StopProduction = true;
                    m_smVisionInfo.g_intMachineStatus = 1;
                    m_smVisionInfo.g_intContinuousFailUnitCount = 0;
                    m_smVisionInfo.g_strErrorMessage += "*Continuous Fail " + m_smVisionInfo.g_intMinFailUnit.ToString() + " Unit(s)!";
                }
            }
        }

        private bool DeleteTemplate()
        {
            try
            {
                //// Delete OCV array object
                //for (int u = 0; u < m_smVisionInfo.g_intUnitsOnImage; u++)
                //{
                //    int intTemplateCount = m_smVisionInfo.g_arrOCVs[u].Count;
                //    for (int i = intTemplateCount - 1; i >= 0; i--)
                //    {
                //        m_smVisionInfo.g_arrOCVs[u].RemoveAt(i);
                //    }
                //}
                //m_smVisionInfo.g_intTemplateMask = 0;
                //m_smVisionInfo.g_intTemplatePriority = 0;
                //m_smVisionInfo.g_intTotalGroup = 0;
                //m_smVisionInfo.g_intTotalTemplates = 0;

                string strFolderPath = m_smProductionInfo.g_strRecipePath + m_smProductionInfo.g_arrSingleRecipeID[m_smVisionInfo.g_intVisionIndex] + "\\" + m_smVisionInfo.g_strVisionFolderName + "\\";

                // 2019 07 31 - JBTAN: Delete all mark template
                for (int u = 0; u < m_smVisionInfo.g_intUnitsOnImage; u++)
                {
                    m_smVisionInfo.g_arrMarks[u].DeleteAllPreviousTemplate(strFolderPath + "Mark\\");
                    m_smVisionInfo.g_arrMarks[u].SaveSingleTemplate(strFolderPath + "Mark\\Template\\", false, false); // 2020-05-11 ZJYEOH: Save first template setting 
                    m_smVisionInfo.g_arrMarks[u].ClearTemplateSetting();
                    m_smVisionInfo.g_blnUnitInspected[u] = false;
                }

                // Reset variables
                m_smVisionInfo.g_intTotalGroup = 1; //Group count is always 1
                m_smVisionInfo.g_intTotalTemplates = 0;
                m_smVisionInfo.g_intTemplateMask = 0;
                m_smVisionInfo.g_intTemplatePriority = 0;

                XmlParser objFile = new XmlParser(strFolderPath + "General.xml");
                objFile.WriteSectionElement("TemplateCounting");
                objFile.WriteElement1Value("TotalGroups", m_smVisionInfo.g_intTotalGroup);
                objFile.WriteElement1Value("TotalTemplates", m_smVisionInfo.g_intTotalTemplates);
                objFile.WriteElement1Value("TemplateMask", m_smVisionInfo.g_intTemplateMask);
                objFile.WriteElement1Value("TemplatePriority", m_smVisionInfo.g_intTemplatePriority);

                objFile.WriteEndElement();

                m_smVisionInfo.PG_VM_LoadTemplate = true;
                m_smVisionInfo.VM_AT_TemplateNotLearn = true;

                return true;
            }
            catch
            {
                return false;
            }
        }

        private string DisplayMarkTestResult(int intMarkFailMask)
        {
            int intCount = m_smVisionInfo.g_arrOCVs[0][m_smVisionInfo.g_intSelectedGroup].Count;
            int intCharSetValue;
            float fScoreValue;
            string strErrorMessage = "";
            int intStartLearnNo = 0;
            if (!m_smVisionInfo.g_blnInspectAllTemplate)
                intStartLearnNo = m_smVisionInfo.g_intSelectedTemplate;

            float fGradientScore;
            float fBinarizedScore;
            for (int ln = intStartLearnNo; ln < intCount; ln++)
            {
                OCV objOCV = (OCV)m_smVisionInfo.g_arrOCVs[0][m_smVisionInfo.g_intSelectedGroup][ln];
                for (int i = 0; i < objOCV.ref_intCharsCount; i++)
                {
                    intCharSetValue = objOCV.GetCharSetting(i);
                    fGradientScore = objOCV.GetOcvScore(i);
                    fBinarizedScore = objOCV.GetBinarizedOcvScore(i);
                    if ((fGradientScore >= fBinarizedScore) || ((fGradientScore < 101) && (fBinarizedScore == 101)))
                        fScoreValue = fGradientScore;
                    else
                        fScoreValue = fBinarizedScore;
                    if ((intCharSetValue > fGradientScore) &&
                        (intCharSetValue > fBinarizedScore))
                    {
                        strErrorMessage += "*Fail Mark - Template " + (ln + 1)
                                        + ", Mark " + i + " : Set="
                                        + intCharSetValue.ToString() + "% Score= "
                                        + fScoreValue.ToString("F2") + "%";
                    }
                }
                if (!m_smVisionInfo.g_blnInspectAllTemplate)
                    break;
            }

            if ((intMarkFailMask & 0x01) > 0)
                strErrorMessage += "*Text Not Found!";
            if ((intMarkFailMask & 0x02) > 0)
                strErrorMessage += "*Text Mismatch! ";
            if ((intMarkFailMask & 0x04) > 0)
                strErrorMessage += "*Text Overprint! ";
            if ((intMarkFailMask & 0x08) > 0)
                strErrorMessage += "*Text Underprint! ";
            if ((intMarkFailMask & 0x100) > 0)
                strErrorMessage += "*Extra Mark! ";
            if ((intMarkFailMask & 0x200) > 0)
                strErrorMessage += "*Broken Mark! ";    // 2019 10 05 - original from missing mark
            if ((intMarkFailMask & 0x400) > 0)
                strErrorMessage += "*Excess Mark! ";
            if ((intMarkFailMask & 0x800) > 0)
                strErrorMessage += "*Broken Mark! ";
            if ((intMarkFailMask & 0x1000) > 0)
                strErrorMessage += "*Joint Mark! ";
            if ((intMarkFailMask & 0x2000) > 0)
                strErrorMessage += "*Text Shfited! ";
            if ((intMarkFailMask & 0x4000) > 0)
                strErrorMessage += "*Total Extra Mark! ";

            return strErrorMessage;
        }

        private void SaveRejectImage_AddToBuffer(string strRejectName, string strRejectMessage)
        {
            lock (m_objLockSaveRejectImage)
            {
                if (m_smCustomizeInfo.g_blnSaveFailImage)
                {
                    if (m_smCustomizeInfo.g_intSaveImageMode == 0)
                    {
                        if (m_smVisionInfo.g_intFailImageCount >= m_smCustomizeInfo.g_intFailImagePics)
                            return;
                    }

                    WaitImageBufferClear(ref m_intFailStartNode, ref m_intFailEndNode);

                    //To handle case when test fail before all image grab complete
                    WaitAllImageGrabDone();

                    if (m_smVisionInfo.g_blnViewColorImage)
                        m_smVisionInfo.g_arrColorImages[0].CopyTo(ref m_arrFailCImage1Buffer[m_intFailEndNode]);
                    else
                        m_smVisionInfo.g_arrImages[0].CopyTo(ref m_arrFailImage1Buffer[m_intFailEndNode]);

                    if (m_smVisionInfo.g_arrImages.Count > 1)
                    {
                        if (m_smVisionInfo.g_blnViewColorImage)
                            m_smVisionInfo.g_arrColorImages[1].CopyTo(ref m_arrFailCImage2Buffer[m_intFailEndNode]);
                        else
                            m_smVisionInfo.g_arrImages[1].CopyTo(ref m_arrFailImage2Buffer[m_intFailEndNode]);
                    }

                    if (m_smVisionInfo.g_arrImages.Count > 2)
                    {
                        if (m_smVisionInfo.g_blnViewColorImage)
                            m_smVisionInfo.g_arrColorImages[2].CopyTo(ref m_arrFailCImage3Buffer[m_intFailEndNode]);
                        else
                            m_smVisionInfo.g_arrImages[2].CopyTo(ref m_arrFailImage3Buffer[m_intFailEndNode]);
                    }

                    if (m_smVisionInfo.g_arrImages.Count > 3)
                    {
                        if (m_smVisionInfo.g_blnViewColorImage)
                            m_smVisionInfo.g_arrColorImages[3].CopyTo(ref m_arrFailCImage4Buffer[m_intFailEndNode]);
                        else
                            m_smVisionInfo.g_arrImages[3].CopyTo(ref m_arrFailImage4Buffer[m_intFailEndNode]);
                    }

                    if (m_smVisionInfo.g_arrImages.Count > 4)
                    {
                        if (m_smVisionInfo.g_blnViewColorImage)
                            m_smVisionInfo.g_arrColorImages[4].CopyTo(ref m_arrFailCImage5Buffer[m_intFailEndNode]);
                        else
                            m_smVisionInfo.g_arrImages[4].CopyTo(ref m_arrFailImage5Buffer[m_intFailEndNode]);
                    }

                    if (m_smVisionInfo.g_arrImages.Count > 5)
                    {
                        if (m_smVisionInfo.g_blnViewColorImage)
                            m_smVisionInfo.g_arrColorImages[5].CopyTo(ref m_arrFailCImage6Buffer[m_intFailEndNode]);
                        else
                            m_smVisionInfo.g_arrImages[5].CopyTo(ref m_arrFailImage6Buffer[m_intFailEndNode]);
                    }

                    if (m_smVisionInfo.g_arrImages.Count > 6)
                    {
                        if (m_smVisionInfo.g_blnViewColorImage)
                            m_smVisionInfo.g_arrColorImages[6].CopyTo(ref m_arrFailCImage7Buffer[m_intFailEndNode]);
                        else
                            m_smVisionInfo.g_arrImages[6].CopyTo(ref m_arrFailImage7Buffer[m_intFailEndNode]);
                    }

                    m_arrRejectNameBuffer[m_intFailEndNode] = strRejectName;
                    m_arrRejectMessageBuffer[m_intFailEndNode] = strRejectMessage;
                    //m_arrFailNoBuffer[m_intFailEndNode] = m_smVisionInfo.g_intFailImageCount;
                    m_arrFailNoBuffer[m_intFailEndNode] = m_smVisionInfo.g_intTotalImageCount;  // 2019 09 18 - CCENG: Use total image count instead of Fail Image count so that pass fail image will display in sequence.

                    if (m_smVisionInfo.g_blnTrackSaveImageFile) STTrackLog.WriteLine("Save Fail Image - PassNo=" + m_arrFailNoBuffer[m_intFailEndNode].ToString() + ", m_arrRejectNameBuffer=" + m_arrRejectNameBuffer[m_intFailEndNode].ToString());
                    m_smVisionInfo.g_intTotalImageCount++;
                    m_smVisionInfo.g_intFailImageCount++;

                    //m_intFailEndNode++;
                    //if (m_smVisionInfo.g_blnViewColorImage)
                    //{
                    //    if (m_intFailEndNode == BUFFERSIZE)
                    //        m_intFailEndNode = 0;
                    //}
                    //else
                    //{
                    //    if (m_intFailEndNode == BUFFERSIZE)
                    //        m_intFailEndNode = 0;
                    //}

                    if (m_smVisionInfo.g_blnViewColorImage)
                    {
                        if ((m_intFailEndNode + 1) == m_smVisionInfo.g_intSaveImageBufferSize)
                            m_intFailEndNode = 0;
                        else
                            m_intFailEndNode++;
                    }
                    else
                    {
                        if ((m_intFailEndNode + 1) == m_smVisionInfo.g_intSaveImageBufferSize)
                            m_intFailEndNode = 0;
                        else
                            m_intFailEndNode++;
                    }
                }
            }
        }

        private void SavePassImage_AddToBuffer()
        {
            if (m_smCustomizeInfo.g_blnSavePassImage)
            {
                if (m_smVisionInfo.g_intPassImageCount < m_smCustomizeInfo.g_intPassImagePics)
                {
                    WaitImageBufferClear(ref m_intPassStartNode, ref m_intPassEndNode);

                    if (m_smVisionInfo.g_blnViewColorImage)
                        m_smVisionInfo.g_arrColorImages[0].CopyTo(ref m_arrPassCImage1Buffer[m_intPassEndNode]);
                    else
                        m_smVisionInfo.g_arrImages[0].CopyTo(ref m_arrPassImage1Buffer[m_intPassEndNode]);

                    if (m_smVisionInfo.g_arrImages.Count > 1)
                    {
                        if (m_smVisionInfo.g_blnViewColorImage)
                            m_smVisionInfo.g_arrColorImages[1].CopyTo(ref m_arrPassCImage2Buffer[m_intPassEndNode]);
                        else
                            m_smVisionInfo.g_arrImages[1].CopyTo(ref m_arrPassImage2Buffer[m_intPassEndNode]);
                    }

                    if (m_smVisionInfo.g_arrImages.Count > 2)
                    {
                        if (m_smVisionInfo.g_blnViewColorImage)
                            m_smVisionInfo.g_arrColorImages[2].CopyTo(ref m_arrPassCImage3Buffer[m_intPassEndNode]);
                        else
                            m_smVisionInfo.g_arrImages[2].CopyTo(ref m_arrPassImage3Buffer[m_intPassEndNode]);
                    }

                    if (m_smVisionInfo.g_arrImages.Count > 3)
                    {
                        if (m_smVisionInfo.g_blnViewColorImage)
                            m_smVisionInfo.g_arrColorImages[3].CopyTo(ref m_arrPassCImage4Buffer[m_intPassEndNode]);
                        else
                            m_smVisionInfo.g_arrImages[3].CopyTo(ref m_arrPassImage4Buffer[m_intPassEndNode]);
                    }

                    if (m_smVisionInfo.g_arrImages.Count > 4)
                    {
                        if (m_smVisionInfo.g_blnViewColorImage)
                            m_smVisionInfo.g_arrColorImages[4].CopyTo(ref m_arrPassCImage5Buffer[m_intPassEndNode]);
                        else
                            m_smVisionInfo.g_arrImages[4].CopyTo(ref m_arrPassImage5Buffer[m_intPassEndNode]);
                    }

                    if (m_smVisionInfo.g_arrImages.Count > 5)
                    {
                        if (m_smVisionInfo.g_blnViewColorImage)
                            m_smVisionInfo.g_arrColorImages[5].CopyTo(ref m_arrPassCImage6Buffer[m_intPassEndNode]);
                        else
                            m_smVisionInfo.g_arrImages[5].CopyTo(ref m_arrPassImage6Buffer[m_intPassEndNode]);
                    }

                    if (m_smVisionInfo.g_arrImages.Count > 6)
                    {
                        if (m_smVisionInfo.g_blnViewColorImage)
                            m_smVisionInfo.g_arrColorImages[6].CopyTo(ref m_arrPassCImage7Buffer[m_intPassEndNode]);
                        else
                            m_smVisionInfo.g_arrImages[6].CopyTo(ref m_arrPassImage7Buffer[m_intPassEndNode]);
                    }

                    m_arrOrientationBuffer[m_intPassEndNode] = m_smVisionInfo.g_intOrientResult[0];
                    //m_arrPassNoBuffer[m_intPassEndNode] = m_smVisionInfo.g_intPassImageCount;
                    m_arrPassNoBuffer[m_intPassEndNode] = m_smVisionInfo.g_intTotalImageCount;  // 2019 09 18 - CCENG: Use total image count instead of Pass Image count so that pass fail image will display in sequence.

                    if (m_smVisionInfo.g_blnTrackSaveImageFile) STTrackLog.WriteLine("Save Pass Image - PassNo=" + m_arrPassNoBuffer[m_intPassEndNode].ToString() + ", m_arrOrientationBuffer=" + m_arrOrientationBuffer[m_intPassEndNode].ToString());
                    m_smVisionInfo.g_intTotalImageCount++;
                    m_smVisionInfo.g_intPassImageCount++;

                    m_intPassEndNode++;
                    if (m_intPassEndNode == m_smVisionInfo.g_intSaveImageBufferSize)
                        m_intPassEndNode = 0;
                }
            }
        }

        private void SetGrabDone(bool blnForInspection)
        {
            float fGrabDelay = 5 - m_smVisionInfo.g_objGrabTime.Timing;
            if (fGrabDelay >= 1)
                Thread.Sleep((int)fGrabDelay);

            if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
            {
                if (blnForInspection) //2021-11-16 ZJYEOH : Change m_smVisionInfo.g_intMachineStatus == 2 to blnForInspection
                    m_smTCPIPIO.Send(m_smVisionInfo.g_intVisionIndex, "GRBRP", true, -1);
                //m_blnGrabbing_Out = false;
            }
            else
                m_objVisionIO.IOGrabbing.SetOff(strTrackHeadName + " IOGrabbing 1"); if (m_smVisionInfo.g_blnTrackIO) STTrackLog.WriteLine("IO-IOGrabbing-Set OFF 10");
            m_blnGrabbing_Out = false;
            m_smVisionInfo.g_objGrabTime.Stop();

            m_smVisionInfo.g_objGrabDoneTime.Start();
        }

        private bool StartColorPackageTest(bool blnAuto)
        {
            if ((m_smCustomizeInfo.g_intWantPackage & (1 << m_smVisionInfo.g_intVisionPos)) == 0)
                return true;

            m_objVisionIO.WrongOrientation.SetOff(strTrackHeadName + " "); if (m_smVisionInfo.g_blnTrackIO) STTrackLog.WriteLine("IO-WrongOrientation-Set OFF 11");

            if (m_smVisionInfo.g_arrPackageROIs.Count == 0 || m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit].Count == 0)          // Check whether template is learnt
            {
                m_smVisionInfo.g_strErrorMessage += "*Package : No Template Found";
                if (blnAuto)
                    m_smVisionInfo.g_intNoTemplateFailureTotal++;
                return false;
            }

            #region OrientResult - Rotate 2 image into correct angle
            if ((m_smCustomizeInfo.g_intWantOrient & (0x01 << m_smVisionInfo.g_intVisionPos)) > 0)
            {
                float fVisionAngle = m_fOrientGauge;
                switch (m_smVisionInfo.g_intOrientResult[0])
                {
                    case 1:
                        fVisionAngle += 90;
                        break;
                    case 2:
                        fVisionAngle += 180;
                        break;
                    case 3:
                        fVisionAngle += 270;
                        break;
                }

                for (int i = 0; i < m_smVisionInfo.g_arrImages.Count; i++)
                {
                    CROI.Rotate0Degree(m_smVisionInfo.g_arrColorImages[i], m_smVisionInfo.g_arrColorPackageROIs[0][0],
                         fVisionAngle, 0, ref m_smVisionInfo.g_arrColorRotatedImages, i);

                    ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[i], m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][0], fVisionAngle, ref m_smVisionInfo.g_arrRotatedImages, i);
                }
                m_smVisionInfo.g_arrColorPackageROIs[0][0].AttachImage(m_smVisionInfo.g_arrColorRotatedImages[0]);
                m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][0].AttachImage(m_smVisionInfo.g_arrRotatedImages[0]);
            }
            #endregion

            // use second image which has a better gauge view to measure gauge
            float fAngle = m_smVisionInfo.g_arrPackageGauge[0].Measure(m_smVisionInfo.g_arrImages[1]);

            if (!m_smVisionInfo.g_arrPackageGauge[0].VerifyGaugeValid(10))
            {
                m_smVisionInfo.g_strErrorMessage += "No Sample Found";
                if (blnAuto)
                {
                    m_smVisionInfo.g_intCheckPresenceFailureTotal++;
                    SaveRejectImage_AddToBuffer("Empty", m_smVisionInfo.g_strErrorMessage);
                }
                return false;
            }

            // Unit ROI that recover whole sample area
            int intPositionX = (int)Math.Round((m_smVisionInfo.g_arrPackageGauge[0].ref_ObjectCenterX - (m_smVisionInfo.g_arrPackageGauge[0].ref_ObjectWidth / 2)), 0, MidpointRounding.AwayFromZero);
            int intPositionY = (int)Math.Round((m_smVisionInfo.g_arrPackageGauge[0].ref_ObjectCenterY - (m_smVisionInfo.g_arrPackageGauge[0].ref_ObjectHeight / 2)), 0, MidpointRounding.AwayFromZero);
            int intWidth = (int)m_smVisionInfo.g_arrPackageGauge[0].ref_ObjectWidth;
            int intHeight = (int)m_smVisionInfo.g_arrPackageGauge[0].ref_ObjectHeight;
            objColorUnitROI = new CROI();
            objColorUnitROI.LoadROISetting(intPositionX, intPositionY, intWidth, intHeight);
            objMonoUnitROI = new ROI();
            objMonoUnitROI.LoadROISetting(intPositionX, intPositionY, intWidth, intHeight);

            // Package ROI area that used to inspect exposed copper and deep scratches
            int intDisX = (int)Math.Round((m_smVisionInfo.g_arrPackageGauge[0].ref_ObjectCenterX - ((float)m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][1].ref_ROIWidth / 2)), 0, MidpointRounding.AwayFromZero);
            int intDisY = (int)Math.Round((m_smVisionInfo.g_arrPackageGauge[0].ref_ObjectCenterY - ((float)m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][1].ref_ROIHeight / 2)), 0, MidpointRounding.AwayFromZero);
            objColorTrainROI = new CROI();
            objColorTrainROI.LoadROISetting(intDisX, intDisY, m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][1].ref_ROIWidth, m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][1].ref_ROIHeight);
            objMonoTrainROI = new ROI();
            objMonoTrainROI.LoadROISetting(intDisX, intDisY, m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][1].ref_ROIWidth, m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][1].ref_ROIHeight);

            if (!blnAuto)
            {
                m_smVisionInfo.g_arrColorPackageROIs[0][1].ref_ROIPositionX = m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][1].ref_ROIPositionX = intDisX - m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][0].ref_ROIPositionX;
                m_smVisionInfo.g_arrColorPackageROIs[0][1].ref_ROIPositionY = m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][1].ref_ROIPositionY = intDisY - m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][0].ref_ROIPositionY;
            }

            // Rotate unit to 0 deg
            if (fAngle != 0)
            {
                int intRotateROIDisX = (int)Math.Round((m_smVisionInfo.g_arrPackageGauge[0].ref_ObjectCenterX - ((float)m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][0].ref_ROIWidth / 2)), 0, MidpointRounding.AwayFromZero);
                int intRotateROIDisY = (int)Math.Round((m_smVisionInfo.g_arrPackageGauge[0].ref_ObjectCenterY - ((float)m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][0].ref_ROIHeight / 2)), 0, MidpointRounding.AwayFromZero);
                CROI objRotateUnitCROI = new CROI();
                objRotateUnitCROI.AttachImage(m_smVisionInfo.g_arrColorImages[0]);
                objRotateUnitCROI.LoadROISetting(intRotateROIDisX, intRotateROIDisY, m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][0].ref_ROIWidth, m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][0].ref_ROIHeight);
                CROI.Rotate0Degree(m_smVisionInfo.g_arrColorImages[0], objRotateUnitCROI,
                         fAngle, 4, ref m_smVisionInfo.g_arrColorRotatedImages, 0);
                if (m_smVisionInfo.g_intSelectedImage == 1)
                {
                    objRotateUnitCROI.AttachImage(m_smVisionInfo.g_arrColorImages[1]);
                    CROI.Rotate0Degree(m_smVisionInfo.g_arrColorImages[1], objRotateUnitCROI,
                          fAngle, 4, ref m_smVisionInfo.g_arrColorRotatedImages, 1);
                }
                ROI objRotateUnitROI = new ROI();
                objRotateUnitROI.AttachImage(m_smVisionInfo.g_arrRotatedImages[0]);
                objRotateUnitROI.LoadROISetting(intRotateROIDisX, intRotateROIDisY, m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][0].ref_ROIWidth, m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][0].ref_ROIHeight);
                ROI.Rotate0Degree(objRotateUnitROI, fAngle, 4, ref m_smVisionInfo.g_arrRotatedImages, 0);
                ROI.Rotate0Degree(objRotateUnitROI, fAngle, 4, ref m_smVisionInfo.g_arrRotatedImages, 1);

                //CROI.Rotate0Degree(m_smVisionInfo.g_arrColorRotatedImages[0], m_smVisionInfo.g_arrColorPackageROIs[0][0],
                //        fAngle, m_smVisionInfo.g_arrColorRotatedImages[0], 0);
                //CROI.Rotate0Degree(m_smVisionInfo.g_arrColorRotatedImages[1], m_smVisionInfo.g_arrColorPackageROIs[0][0],
                //      fAngle, m_smVisionInfo.g_arrColorRotatedImages[1], 0);
                //ROI.Rotate0Degree(m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][0], fAngle, ref m_smVisionInfo.g_arrRotatedImages, 0);
                //ROI.Rotate0Degree(m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][0], fAngle, ref m_smVisionInfo.g_arrRotatedImages, 1);
            }
            else
            {
                m_smVisionInfo.g_arrColorImages[0].CopyTo(m_smVisionInfo.g_arrColorRotatedImages[0]);
                //m_smVisionInfo.g_arrImages[i].CopyTo(m_smVisionInfo.g_arrRotatedImages[i]);
            }

            //m_smVisionInfo.g_arrPackageGauge[0].Measure(m_smVisionInfo.g_arrRotatedImages[1]);
            intDisX = (int)Math.Round((m_smVisionInfo.g_arrPackageGauge[0].ref_ObjectCenterX - (m_smVisionInfo.g_arrPackageGauge[0].ref_ObjectWidth / 2)), 0, MidpointRounding.AwayFromZero) - 1;
            intDisY = (int)Math.Round((m_smVisionInfo.g_arrPackageGauge[0].ref_ObjectCenterY - (m_smVisionInfo.g_arrPackageGauge[0].ref_ObjectHeight / 2)), 0, MidpointRounding.AwayFromZero) - 1;
            objUnitROIForImage0 = new ROI();
            objUnitROIForImage0.LoadROISetting(intDisX, intDisY, Convert.ToInt32(m_smVisionInfo.g_arrPackageGauge[0].ref_ObjectWidth) + 3, Convert.ToInt32(m_smVisionInfo.g_arrPackageGauge[0].ref_ObjectHeight) + 3);
            objUnitROIForImage0.AttachImage(m_smVisionInfo.g_arrRotatedImages[0]);

            // Package ROI area that used to inspect
            if (!m_smVisionInfo.g_arrColorPackage[0].DoInspection(m_smVisionInfo.g_arrColorRotatedImages, m_smVisionInfo.g_arrRotatedImages,
                objColorUnitROI, objColorTrainROI, objMonoUnitROI, objMonoTrainROI, objUnitROIForImage0))
            {
                m_smVisionInfo.g_strErrorMessage += m_smVisionInfo.g_arrColorPackage[0].ref_strErrorMessage;
                if (blnAuto)
                {
                    switch (m_smVisionInfo.g_arrColorPackage[0].ref_intFailMask)
                    {
                        case 1:
                            m_objVisionIO.WrongOrientation.SetOn(strTrackHeadName + " WrongOrientation 14"); if (m_smVisionInfo.g_blnTrackIO) STTrackLog.WriteLine("IO-WrongOrientation-Set ON 12");
                            m_smVisionInfo.g_intOrientFailureTotal++;
                            SaveRejectImage_AddToBuffer("Orientation", m_smVisionInfo.g_arrColorPackage[0].ref_strErrorMessage);
                            break;
                        case 3:
                            m_smVisionInfo.g_intPkgDefectFailureTotal++;
                            SaveRejectImage_AddToBuffer("Burr", m_smVisionInfo.g_arrColorPackage[0].ref_strErrorMessage);
                            break;
                        case 5:
                            m_smVisionInfo.g_intPkgDefectFailureTotal++;
                            SaveRejectImage_AddToBuffer("Copper", m_smVisionInfo.g_arrColorPackage[0].ref_strErrorMessage);
                            break;
                        case 6:
                            m_smVisionInfo.g_intPkgDefectFailureTotal++;
                            SaveRejectImage_AddToBuffer("Chip", m_smVisionInfo.g_arrColorPackage[0].ref_strErrorMessage);
                            break;
                        default:
                            SaveRejectImage_AddToBuffer("Package", m_smVisionInfo.g_arrColorPackage[0].ref_strErrorMessage);
                            m_smVisionInfo.g_intPackageFailureTotal++;
                            break;
                    }
                }
                return false;
            }

            return true;
        }
        private bool StartMarkOCR2Test(bool blnAuto)
        {
            // Make sure Database already learnt
            if (m_smVisionInfo.g_arrMarks[0].GetDatabseNum() == 0)
            {
                if (m_smVisionInfo.g_arrMarks[0].ref_blnCheckMark)
                {
                    m_smVisionInfo.g_strErrorMessage += "*OCR2 : No Character Database Found";
                    if (blnAuto)
                        m_smVisionInfo.g_intNoTemplateFailureTotal++;
                }
                return false;
            }
            else
            {
                m_objMarkSearchROI = m_smVisionInfo.g_arrMarkROIs[0][0];
                if (m_objMarkTrainROI == null)
                    m_objMarkTrainROI = new ROI();
                m_objMarkTrainROI.AttachImage(m_objMarkSearchROI);
                m_objMarkTrainROI.LoadROISetting(m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROIPositionX, m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROIPositionY,
                                           m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROIWidth, m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROIHeight);

                if (m_objMarkOCRSearchROI == null)
                    m_objMarkOCRSearchROI = new ROI();
                m_objMarkOCRSearchROI.AttachImage(m_smVisionInfo.g_objMarkImage);
                m_objMarkOCRSearchROI.LoadROISetting(m_objMarkSearchROI.ref_ROIPositionX, m_objMarkSearchROI.ref_ROIPositionY,
                                                         m_objMarkSearchROI.ref_ROIWidth, m_objMarkSearchROI.ref_ROIHeight);

                m_objMarkSearchROI.AttachImage(m_smVisionInfo.g_arrRotatedImages[0]);

                m_smVisionInfo.g_pMarkROIDrawing[0] = new Point(m_objMarkTrainROI.ref_ROITotalX, m_objMarkTrainROI.ref_ROITotalY);
                m_smVisionInfo.g_pMarkROIDrawing[1] = new Point(m_objMarkTrainROI.ref_ROITotalX + m_objMarkTrainROI.ref_ROIWidth, m_objMarkTrainROI.ref_ROITotalY);
                m_smVisionInfo.g_pMarkROIDrawing[2] = new Point(m_objMarkTrainROI.ref_ROITotalX, m_objMarkTrainROI.ref_ROITotalY + m_objMarkTrainROI.ref_ROIHeight);
                m_smVisionInfo.g_pMarkROIDrawing[3] = new Point(m_objMarkTrainROI.ref_ROITotalX + m_objMarkTrainROI.ref_ROIWidth, m_objMarkTrainROI.ref_ROITotalY + m_objMarkTrainROI.ref_ROIHeight);

                if (!m_smVisionInfo.g_arrMarks[m_smVisionInfo.g_intSelectedUnit].OCRInspect(m_objMarkOCRSearchROI, m_objMarkTrainROI, false, 0))
                {
                    m_smVisionInfo.g_blnHasDetected = false;
                    m_smVisionInfo.g_blnHasRecognise = false;
                }
                else
                {
                    m_smVisionInfo.g_blnHasDetected = true;
                    m_smVisionInfo.g_blnHasRecognise = true;
                }

                m_smVisionInfo.g_blnMarkInspected = true;
                m_smVisionInfo.g_blnDrawMarkResult = true;

                if (m_smVisionInfo.g_arrMarks[0].ref_intFailResultMask > 0)
                {
                    m_smVisionInfo.g_strErrorMessage = m_smVisionInfo.g_arrMarks[0].GetOCRInspectionMessage(-1, false, 0);

                    if (blnAuto)
                    {
                        m_smVisionInfo.g_intMarkFailureTotal++;
                        SaveRejectImage_AddToBuffer("Mark", m_smVisionInfo.g_arrMarks[0].GetOCRInspectionMessage(-1, false, 0));
                    }
                    return false;
                }
                return true;
            }
        }
        private bool StartMarkOCRTest(bool blnAuto)
        {
            // Make sure template exist
            if (m_smVisionInfo.g_arrMarks[0].GetNumPatterns() == 0)
            {
                // 2020 04 15 - JBTAN: check mark option enable only will set result fail
                if (m_smVisionInfo.g_arrMarks[0].ref_blnCheckMark)
                {
                    m_smVisionInfo.g_strErrorMessage += "*Mark : No Template Found";
                    if (blnAuto)
                        m_smVisionInfo.g_intNoTemplateFailureTotal++;
                }
                return false;
            }

            m_objMarkSearchROI = m_smVisionInfo.g_arrMarkROIs[0][0];
            if (m_objMarkTrainROI == null)
                m_objMarkTrainROI = new ROI();
            m_objMarkTrainROI.AttachImage(m_objMarkSearchROI);
            m_objMarkTrainROI.LoadROISetting(m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROIPositionX, m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROIPositionY,
                                       m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROIWidth, m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROIHeight);

            //no orient check
            if (((m_smCustomizeInfo.g_intWantOrient & (1 << m_smVisionInfo.g_intVisionPos)) == 0))
            {
                //got gauge check
                if (m_smVisionInfo.g_blnWantGauge)
                {
                    m_objMarkSearchROI.AttachImage(m_smVisionInfo.g_arrImages[0]);
                    // Rotate unit to exact 0 degree
                    float fGaugeAngle = ((RectGauge)m_smVisionInfo.g_arrMarkGauge[0]).Measure(m_objMarkSearchROI, 10);

                    ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[0], m_objMarkSearchROI, fGaugeAngle, m_smVisionInfo.g_intRotationInterpolation_Mark, ref m_smVisionInfo.g_arrRotatedImages, 0);
                    m_objMarkSearchROI.AttachImage(m_smVisionInfo.g_arrRotatedImages[0]);
                }
            }
            else
            {
                m_objMarkSearchROI.AttachImage(m_smVisionInfo.g_arrRotatedImages[0]);
            }

            if (m_smVisionInfo.g_blnWantGauge)
            {
                // Measure search roi to get unit center point
                ((RectGauge)m_smVisionInfo.g_arrMarkGauge[0]).Measure(m_objMarkSearchROI, 10);

                // Get object width and height measured by gauge
                int intGaugeWidth = (int)(((RectGauge)m_smVisionInfo.g_arrMarkGauge[0]).ref_ObjectWidth);
                int intGaugeHeight = (int)(((RectGauge)m_smVisionInfo.g_arrMarkGauge[0]).ref_ObjectHeight);

                int intROIWidth = m_objMarkTrainROI.ref_ROIWidth;
                int intROIHeight = m_objMarkTrainROI.ref_ROIHeight;

                if (intROIWidth >= intGaugeWidth)
                    intROIWidth -= (intROIWidth - intGaugeWidth) / 2;
                if (intROIHeight >= intGaugeHeight)
                    intROIHeight -= (intROIHeight - intGaugeHeight) / 2;

                int intROIOriX = (int)(((RectGauge)m_smVisionInfo.g_arrMarkGauge[0]).ref_ObjectCenterX - intROIWidth / 2) - m_objMarkSearchROI.ref_ROIPositionX;
                int intROIOriY = (int)(((RectGauge)m_smVisionInfo.g_arrMarkGauge[0]).ref_ObjectCenterY - intROIHeight / 2) - m_objMarkSearchROI.ref_ROIPositionY;


                // Set train roi start point
                if ((intROIOriX > 0) &&
                    (intROIOriX < m_objMarkTrainROI.ref_ROIWidth) &&
                    (intROIOriY > 0) &&
                    (intROIOriY < m_objMarkTrainROI.ref_ROIHeight))
                {
                    m_objMarkTrainROI.ref_ROIPositionX = intROIOriX;
                    m_objMarkTrainROI.ref_ROIPositionY = intROIOriY;
                }
                else
                {
                    // if start point out of range, then set train roi position same as position during learning
                    m_objMarkTrainROI.ref_ROIPositionX = m_objMarkTrainROI.ref_ROIOriPositionX;
                    m_objMarkTrainROI.ref_ROIPositionY = m_objMarkTrainROI.ref_ROIOriPositionY;
                }
            }
            else
            {
                // Attach search roi to main image
                m_objMarkSearchROI.AttachImage(m_smVisionInfo.g_arrImages[0]);
            }

            m_smVisionInfo.g_arrMarks[0].InspectOCRMark(m_smVisionInfo.g_arrRotatedImages[0], m_objMarkTrainROI, m_smVisionInfo.g_blnWantRecogPosition);

            m_smVisionInfo.g_blnMarkInspected = true;
            m_smVisionInfo.g_blnDrawMarkResult = true;

            if (m_smVisionInfo.g_arrMarks[0].ref_intFailResultMask > 0)
            {
                m_smVisionInfo.g_strErrorMessage = m_smVisionInfo.g_arrMarks[0].GetInspectionMessage(-1, false, 0);

                if (blnAuto)
                {
                    m_smVisionInfo.g_intMarkFailureTotal++;
                    SaveRejectImage_AddToBuffer("Mark", m_smVisionInfo.g_arrMarks[0].GetInspectionMessage(-1, false, 0));
                }
            }

            return true;

        }

        private bool StartMarkTest_using4LGauge_OcvAngleAndPackageAngle(bool blnAuto)
        {
            try
            {
                if ((m_smCustomizeInfo.g_intWantMark & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
                {
                    if (m_smVisionInfo.g_arrMarks[0].GetNumTemplates() == 0)
                    {
                        // 2020 04 15 - JBTAN: check mark option enable only will set result fail
                        if (m_smVisionInfo.g_arrMarks[0].ref_blnCheckMark)
                        {
                            m_smVisionInfo.g_strErrorMessage += "*Mark : No Template Found";
                            if (blnAuto)
                            {
                                m_smVisionInfo.g_intNoTemplateFailureTotal++;
                            }

                            if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                                if (m_intTCPIPResultID == -1)
                                    m_intTCPIPResultID = (int)TCPIPResulID.FailMark;
                        }
                        else
                        {
                            // 2020-06-30 ZJYEOH : Just to fix no parameter in package inspection
                            if (m_smVisionInfo.g_arrMarkROIs.Count > 0)
                            {
                                if (m_smVisionInfo.g_arrMarkROIs[0].Count > 0)
                                {
                                    m_objMarkSearchROI = m_smVisionInfo.g_arrMarkROIs[0][0];
                                }

                                if (m_objMarkTrainROI == null)
                                    m_objMarkTrainROI = new ROI();
                                m_objMarkTrainROI.AttachImage(m_objMarkSearchROI);
                                if (m_smVisionInfo.g_arrMarkROIs[0].Count > 1)
                                {
                                    m_objMarkTrainROI.LoadROISetting(m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROIPositionX, m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROIPositionY,
                                                           m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROIWidth, m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROIHeight);
                                }
                            }
                        }

                        return false;
                    }

                    m_arrDontCareLeadAreaStartX.Clear();
                    m_arrDontCareLeadAreaStartY.Clear();
                    m_arrDontCareLeadAreaEndX.Clear();
                    m_arrDontCareLeadAreaEndY.Clear();
                    m_arrDontCareLeadDirection.Clear();

                    m_objMarkSearchROI = m_smVisionInfo.g_arrMarkROIs[0][0];
                    if (m_objMarkTrainROI == null)
                        m_objMarkTrainROI = new ROI();
                    m_objMarkTrainROI.AttachImage(m_objMarkSearchROI);
                    m_objMarkTrainROI.LoadROISetting(m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROIPositionX, m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROIPositionY,
                                               m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROIWidth, m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROIHeight);
                    //m_objMarkTrainROI.SaveImage("D:\\TS\\m_objMarkTrainROI3.bmp");

                    if (m_objMarkOcvSearchROI == null)
                        m_objMarkOcvSearchROI = new ROI();
                    m_objMarkOcvSearchROI.AttachImage(m_smVisionInfo.g_objMarkImage);
                    m_objMarkOcvSearchROI.LoadROISetting(m_objMarkSearchROI.ref_ROIPositionX, m_objMarkSearchROI.ref_ROIPositionY,
                                                             m_objMarkSearchROI.ref_ROIWidth, m_objMarkSearchROI.ref_ROIHeight);

                    if (m_smVisionInfo.g_arrOrients[0][0].ref_intCorrectAngleMethod == 0)
                    {
                        //no orient check
                        if (((m_smCustomizeInfo.g_intWantOrient & (1 << m_smVisionInfo.g_intVisionPos)) == 0))
                        {
                            //got gauge check
                            if (m_smVisionInfo.g_blnWantGauge)
                            {
                                m_objMarkSearchROI.AttachImage(m_smVisionInfo.g_arrImages[0]);
                                m_smVisionInfo.g_arrMarkGaugeM4L[0].Measure_WithDontCareArea(m_smVisionInfo.g_arrImages, m_smVisionInfo.g_objWhiteImage);
                                // Rotate unit to exact 0 degree
                                float fGaugeAngle = m_smVisionInfo.g_arrMarkGaugeM4L[0].ref_fRectAngle;

                                ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[0], m_objMarkSearchROI, fGaugeAngle, m_smVisionInfo.g_intRotationInterpolation_Mark, ref m_smVisionInfo.g_arrRotatedImages, 0);
                                m_objMarkSearchROI.AttachImage(m_smVisionInfo.g_arrRotatedImages[0]);

                                if (m_blnCustomWantColor && !GetColorImageRotated(0) && !ContainColorSelectedImage(0, m_smVisionInfo.g_intSelectedUnit))
                                {
                                    CROI objColorRotatedROI = new CROI();
                                    objColorRotatedROI.AttachImage(m_smVisionInfo.g_arrColorImages[0]);

                                    // Get RotateROI center point where the ROI center point == Package Unit Center Point
                                    objColorRotatedROI.LoadROISetting(m_objMarkSearchROI.ref_ROIPositionX,
                                                                 m_objMarkSearchROI.ref_ROIPositionY,
                                                                 m_objMarkSearchROI.ref_ROIWidth,
                                                                 m_objMarkSearchROI.ref_ROIHeight);

                                    CROI.Rotate0Degree(m_smVisionInfo.g_arrColorImages[0], objColorRotatedROI, fGaugeAngle, 4, ref m_smVisionInfo.g_arrColorRotatedImages, 0);

                                    SetColorImageRotated(0);
                                    objColorRotatedROI.Dispose();
                                }

                            }
                        }
                        else
                        {
                            m_objMarkSearchROI.AttachImage(m_smVisionInfo.g_arrRotatedImages[0]);
                            if (m_smVisionInfo.g_blnWantGauge)
                            {
                                m_objMarkSearchROI.LoadROISetting(
                                                    (int)Math.Round(m_smVisionInfo.g_arrOrientGaugeM4L[0].ref_pRectCenterPoint.X -
                                                    m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIWidth / 2, 0, MidpointRounding.AwayFromZero),
                                                    (int)Math.Round(m_smVisionInfo.g_arrOrientGaugeM4L[0].ref_pRectCenterPoint.Y -
                                                    m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIHeight / 2, 0, MidpointRounding.AwayFromZero),
                                                    m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIWidth,
                                                    m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIHeight);
                            }
                        }

                        if (m_smVisionInfo.g_blnWantGauge)
                        {
                            RectGaugeM4L objGauge;
                            if (m_blnWantOrientTest)
                            {
                                objGauge = m_smVisionInfo.g_arrOrientGaugeM4L[0];

                            }
                            else
                            {
                                objGauge = m_smVisionInfo.g_arrMarkGaugeM4L[0];

                                if (m_blnWantPositioning)
                                {
                                    objGauge.SetGaugePlace_BasedOnEdgeROI();

                                    m_objMarkSearchROI.LoadROISetting(
                                        (int)Math.Round(m_smVisionInfo.g_objPositioning.ref_fObjectCenterX -
                                         m_objMarkSearchROI.ref_ROIWidth / 2, 0, MidpointRounding.AwayFromZero),
                                         (int)Math.Round(m_smVisionInfo.g_objPositioning.ref_fObjectCenterY -
                                        m_objMarkSearchROI.ref_ROIHeight / 2, 0, MidpointRounding.AwayFromZero),
                                        m_objMarkSearchROI.ref_ROIWidth,
                                        m_objMarkSearchROI.ref_ROIHeight);
                                }

                                // Measure search roi to get unit center point
                                objGauge.Measure_WithDontCareArea(m_smVisionInfo.g_arrRotatedImages, m_objMarkSearchROI, m_smVisionInfo.g_objWhiteImage);
                            }

                            // Get mark gauge measure size
                            int intGaugeWidth = (int)(objGauge.ref_fRectWidth);
                            int intGaugeHeight = (int)(objGauge.ref_fRectHeight);

                            int intGaugeCenterX = (int)(objGauge.ref_pRectCenterPoint.X);
                            int intGaugeCenterY = (int)(objGauge.ref_pRectCenterPoint.Y);

                            //         float Angle = m_intOrientAngle + objGauge.ref_fRectAngle;
                            //         float CenterX = (float)(m_objMarkSearchROI.ref_ROITotalCenterX);
                            //         float CenterY = (float)(m_objMarkSearchROI.ref_ROITotalCenterY);
                            //         float fXAfterRotated = (float)((CenterX) + ((intGaugeCenterX - CenterX) * Math.Cos(Angle * Math.PI / 180)) -
                            //((intGaugeCenterY - CenterY) * Math.Sin(Angle * Math.PI / 180)));
                            //         float fYAfterRotated = (float)((CenterY) + ((intGaugeCenterX - CenterX) * Math.Sin(Angle * Math.PI / 180)) +
                            //          ((intGaugeCenterY - CenterY) * Math.Cos(Angle * Math.PI / 180)));

                            // Get Mark ROI size
                            int intROIWidth = m_objMarkTrainROI.ref_ROIWidth;
                            int intROIHeight = m_objMarkTrainROI.ref_ROIHeight;

                            if (intROIWidth >= intGaugeWidth)
                                intROIWidth -= (intROIWidth - intGaugeWidth) / 2;
                            if (intROIHeight >= intGaugeHeight)
                                intROIHeight -= (intROIHeight - intGaugeHeight) / 2;

                            //int intROIOriX = (int)(fXAfterRotated - intROIWidth / 2) - m_objMarkSearchROI.ref_ROIPositionX;
                            //int intROIOriY = (int)(fYAfterRotated - intROIHeight / 2) - m_objMarkSearchROI.ref_ROIPositionY;

                            int intROIOriX = (int)(objGauge.ref_pRectCenterPoint.X - intROIWidth / 2) - m_objMarkSearchROI.ref_ROIPositionX;
                            int intROIOriY = (int)(objGauge.ref_pRectCenterPoint.Y - intROIHeight / 2) - m_objMarkSearchROI.ref_ROIPositionY;


                            // Set train roi start point
                            if ((intROIOriX > 0) &&
                              ((intROIOriX + m_objMarkTrainROI.ref_ROIWidth) <= m_objMarkSearchROI.ref_ROIWidth) &&
                              (intROIOriY > 0) &&
                              ((intROIOriY + m_objMarkTrainROI.ref_ROIHeight) <= m_objMarkSearchROI.ref_ROIHeight))
                            {
                                m_objMarkTrainROI.ref_ROIPositionX = intROIOriX;
                                m_objMarkTrainROI.ref_ROIPositionY = intROIOriY;
                            }
                            else
                            {
                                m_objMarkTrainROI.ref_ROIPositionX = m_objMarkTrainROI.ref_ROIOriPositionX;
                                m_objMarkTrainROI.ref_ROIPositionY = m_objMarkTrainROI.ref_ROIOriPositionY;
                            }
                        }
                        //else if (m_smVisionInfo.g_arrMarkROIs[0].Count > 3)    // Mean Unit Surface ROI exist
                        //{
                        //    // Only positioning and lead will use unit surface ROI
                        //    if (((m_smCustomizeInfo.g_intWantPositioningIndex & (1 << m_smVisionInfo.g_intVisionPos)) > 0) ||
                        //        ((m_smCustomizeInfo.g_intWantLead & (1 << m_smVisionInfo.g_intVisionPos)) > 0))
                        //    {
                        //        // Get offset value between Unit Surface ROI and Mark ROI center points
                        //        int intMarkROIOffsetX = m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROICenterX - m_smVisionInfo.g_arrMarkROIs[0][3].ref_ROICenterX;
                        //        int intMarkROIOffsetY = m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROICenterY - m_smVisionInfo.g_arrMarkROIs[0][3].ref_ROICenterY;

                        //        // Find unit ROI (Train ROI)
                        //        m_objMarkTrainROI.ref_ROIPositionX = (int)Math.Round(m_smVisionInfo.g_fUnitCenterX[0] - (float)m_objMarkTrainROI.ref_ROIWidth / 2 + intMarkROIOffsetX, 0, MidpointRounding.AwayFromZero);   // 2018 10 09 - CCENG: change g_fOrientCenterXY to g_fUnitCenterXY because g_fOrientCenter is used to keep Orient matcher result center point, not orient gauge unit center point.
                        //        m_objMarkTrainROI.ref_ROIPositionY = (int)Math.Round(m_smVisionInfo.g_fUnitCenterY[0] - (float)m_objMarkTrainROI.ref_ROIHeight / 2 + intMarkROIOffsetY, 0, MidpointRounding.AwayFromZero);

                        //    }
                        //}
                        else //No gauge
                        {
                            /* 2019 07 12 - CCENG: 
                             * No gauge mean dun know where is the unit.
                             * Mark ROI will be relocated according to orient PR result + offset between orient ROI and mark ROI
                             */


                            //m_objMarkTrainROI.LoadROISetting((int)m_smVisionInfo.g_fOrientCenterX[0] +                  // Orient Result Object Center X
                            //                                   m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROICenterX -      // Mark ROI Center X
                            //                                   m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROICenterX -    // Orient ROI Center X
                            //                                   m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROIWidth / 2,     // Half of Mark ROI Size X
                            //                                   (int)m_smVisionInfo.g_fOrientCenterY[0] +
                            //                                   m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROICenterY -
                            //                                   m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROICenterY -
                            //                                   m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROIHeight / 2,
                            //                                   m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROIWidth, m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROIHeight);

                            bool blnUsePackageCenterPoint = false;

                            // 2019-12-17 JBTAN: will not run this sequence if disable package size test
                            if (m_blnWantPackageTest && ((m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailMask & 0x1000) > 0 || m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetWantInspectPackage() || GetWantInspectPackageColor(m_smVisionInfo.g_intSelectedUnit)))
                            {
                                WaitEventDone(ref m_bPackageSizePreTestDone, true, 10000, "StartMarkTest > m_bPackageSizePreTestDone 1");

                                if (m_bPackageSizePreTestResult)
                                {
                                    blnUsePackageCenterPoint = true;
                                }
                                else
                                {
                                    // 2019-11-08 ZJYEOH : Reset the inspection data so that offline page result does not store previous unit result
                                    m_smVisionInfo.g_arrMarks[0].ResetInspectionData(true);
                                    // 2019-11-08 ZJYEOH : if package fail, no need to check mark anymore
                                    return true;
                                }
                            }

                            bool blnUseLeadBaseCenterPoint = false;
                            if (!blnUsePackageCenterPoint)  // if no use package center point, then try use lead base center point
                            {
                                // 2020 12 18 - CCENG: No need check also if ByPassUnit is true.
                                if ((m_smCustomizeInfo.g_intWantLead & (1 << m_smVisionInfo.g_intVisionPos)) > 0 && m_smVisionInfo.g_arrLead[0].GetWantInspectLead() && !m_smVisionInfo.VM_PR_ByPassUnit)
                                {
                                    WaitEventDone(ref m_bLeadBaseCenterPointDone, true, 10000, "AAA46");

                                    if (m_bLeadBaseCenterPointResult)
                                    {
                                        blnUseLeadBaseCenterPoint = true;

                                        m_arrDontCareLeadAreaStartX.Clear();
                                        m_arrDontCareLeadAreaStartY.Clear();
                                        m_arrDontCareLeadAreaEndX.Clear();
                                        m_arrDontCareLeadAreaEndY.Clear();
                                        m_arrDontCareLeadDirection.Clear();

                                        for (int j = 0; j < m_smVisionInfo.g_arrLead.Length; j++)
                                        {
                                            if (m_smVisionInfo.g_arrLead[j].ref_blnSelected)
                                            {
                                                for (int k = 0; k < m_smVisionInfo.g_arrLead[j].ref_intNumberOfLead; k++)
                                                {
                                                    float fStartX = 0, fStartY = 0, fEndX = 0, fEndY = 0;
                                                    int intLeadDirection = 0;
                                                    m_smVisionInfo.g_arrLead[j].GetSampleLeadArea(k,
                                                                                                  m_smVisionInfo.g_arrInspectLeadROI[j].ref_ROITotalX,
                                                                                                  m_smVisionInfo.g_arrInspectLeadROI[j].ref_ROITotalY,
                                                                                                  m_smVisionInfo.g_arrLead[0].ref_fRotateCenterX_ForDrawing,
                                                                                                  m_smVisionInfo.g_arrLead[0].ref_fRotateCenterY_ForDrawing,
                                                                                                   m_fOrientFinalAngleForLead - m_fLeadPatternAngle,
                                                                                                  ref fStartX, ref fStartY, ref fEndX, ref fEndY, ref intLeadDirection);

                                                    m_arrDontCareLeadAreaStartX.Add(fStartX);
                                                    m_arrDontCareLeadAreaStartY.Add(fStartY);
                                                    m_arrDontCareLeadAreaEndX.Add(fEndX);
                                                    m_arrDontCareLeadAreaEndY.Add(fEndY);
                                                    m_arrDontCareLeadDirection.Add(intLeadDirection);
                                                }
                                            }
                                        }

                                    }
                                    else
                                        return true;//2021-09-09 ZJYEOH : Should return true instead of false, so that can fail lead or package 
                                }
                            }

                            if (blnUsePackageCenterPoint)
                            {
                                // Get RotateROI center point where the ROI center point == Unit Center Point
                                //m_objMarkTrainROI.LoadROISetting(
                                //            (int)Math.Round(m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X -
                                //            m_smVisionInfo.g_arrMarkROIs[0][0].ref_ROIPositionX -
                                //            m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROIWidth / 2, 0, MidpointRounding.AwayFromZero),
                                //            (int)Math.Round(m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y -
                                //            m_smVisionInfo.g_arrMarkROIs[0][0].ref_ROIPositionY -
                                //            m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROIHeight / 2, 0, MidpointRounding.AwayFromZero),
                                //            m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROIWidth, m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROIHeight);

                                if (m_smVisionInfo.g_fOrientCenterX[0] != -1 && m_smVisionInfo.g_fOrientCenterY[0] != -1)    // Orient test able to get position
                                {
                                    // 2019 10 15 - CCENG: Use m_smVisionInfo.g_objGauge_PkgSize measurement center point as rotation center point reference to get mark train roi "0 orient direction and 0 deg" center points.
                                    float CenterX = (float)(m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X - m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIPositionX);
                                    float CenterY = (float)(m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y - m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIPositionY);

                                    float Angle = m_smVisionInfo.g_fOrientAngle[0] + (m_intOrientAngle); // this formula is based on clockwise rotation so the angle need to be inverted, 
                                    Angle = -Angle;
                                    float fXAfterRotated = (float)((CenterX) + ((m_smVisionInfo.g_fOrientCenterX[0] - CenterX) * Math.Cos(Angle * Math.PI / 180)) - ((m_smVisionInfo.g_fOrientCenterY[0] - CenterY) * Math.Sin(Angle * Math.PI / 180)));

                                    float fYAfterRotated = (float)((CenterY) + ((m_smVisionInfo.g_fOrientCenterX[0] - CenterX) * Math.Sin(Angle * Math.PI / 180)) + ((m_smVisionInfo.g_fOrientCenterY[0] - CenterY) * Math.Cos(Angle * Math.PI / 180)));

                                    m_fCenterX = //m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalX + m_smVisionInfo.g_fOrientCenterX[0] + m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROICenterX - m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROICenterX;
                                    m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalX + fXAfterRotated + m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROICenterX - m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROICenterX;
                                    m_fCenterY = //m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalY + m_smVisionInfo.g_fOrientCenterY[0] + m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROICenterY - m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROICenterY;
                                    m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalY + fYAfterRotated + m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROICenterY - m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROICenterY;

                                    m_objMarkTrainROI.LoadROISetting((int)fXAfterRotated +                  // Orient Result Object Center X
                                                                    m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROICenterX -      // Mark ROI Center X
                                                                    m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROICenterX -    // Orient ROI Center X
                                                                    m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROIWidth / 2,     // Half of Mark ROI Size X
                                                                    (int)fYAfterRotated +
                                                                    m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROICenterY -
                                                                    m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROICenterY -
                                                                    m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROIHeight / 2,
                                                                    m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROIWidth, m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROIHeight);
                                }
                                else
                                {
                                    m_objMarkTrainROI.LoadROISetting(m_objMarkSearchROI.ref_ROIWidth / 2 -    // Orient ROI Center X
                                                                    m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROIWidth / 2,     // Half of Mark ROI Size X
                                                                    m_objMarkSearchROI.ref_ROIHeight / 2 -
                                                                    m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROIHeight / 2,
                                                                    m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROIWidth, m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROIHeight);
                                }

                                //m_objMarkTrainROI.SaveImage("D:\\TS\\objMarkTrainROI.bmp");
                                // 2019-11-08 ZJYEOH : Limit Mark inspection ROI within package size area, so that extra mark wont happen outside the package size area

                                //if (m_objMarkTrainROI.ref_ROITotalX < (m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X - m_smVisionInfo.g_objGauge_PkgSize.ref_fRectWidth / 2))
                                //{
                                //    m_objMarkTrainROI.LoadROISetting(m_objMarkTrainROI.ref_ROIPositionX + (int)(m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X - m_smVisionInfo.g_objGauge_PkgSize.ref_fRectWidth / 2) - m_objMarkTrainROI.ref_ROITotalX,
                                //m_objMarkTrainROI.ref_ROIPositionY,
                                //m_objMarkTrainROI.ref_ROIWidth - ((int)(m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X - m_smVisionInfo.g_objGauge_PkgSize.ref_fRectWidth / 2) - m_objMarkTrainROI.ref_ROITotalX), m_objMarkTrainROI.ref_ROIHeight);
                                //}

                                //if (m_objMarkTrainROI.ref_ROITotalY < (m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y - m_smVisionInfo.g_objGauge_PkgSize.ref_fRectHeight / 2))
                                //{
                                //    m_objMarkTrainROI.LoadROISetting(m_objMarkTrainROI.ref_ROIPositionX,
                                //                   m_objMarkTrainROI.ref_ROIPositionY + (int)(m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y - m_smVisionInfo.g_objGauge_PkgSize.ref_fRectHeight / 2) - m_objMarkTrainROI.ref_ROITotalY,
                                //                    m_objMarkTrainROI.ref_ROIWidth, m_objMarkTrainROI.ref_ROIHeight - ((int)(m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y - m_smVisionInfo.g_objGauge_PkgSize.ref_fRectHeight / 2) - m_objMarkTrainROI.ref_ROITotalY));
                                //}

                                //if (m_objMarkTrainROI.ref_ROITotalY + m_objMarkTrainROI.ref_ROIHeight > (m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y + m_smVisionInfo.g_objGauge_PkgSize.ref_fRectHeight / 2))
                                //{
                                //    m_objMarkTrainROI.LoadROISetting(m_objMarkTrainROI.ref_ROIPositionX, m_objMarkTrainROI.ref_ROIPositionY,
                                //m_objMarkTrainROI.ref_ROIWidth, m_objMarkTrainROI.ref_ROIHeight - (int)(m_objMarkTrainROI.ref_ROITotalY + m_objMarkTrainROI.ref_ROIHeight - (m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y + m_smVisionInfo.g_objGauge_PkgSize.ref_fRectHeight / 2)));
                                //}

                                //if (m_objMarkTrainROI.ref_ROITotalX + m_objMarkTrainROI.ref_ROIWidth > (m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X + m_smVisionInfo.g_objGauge_PkgSize.ref_fRectWidth / 2))
                                //{
                                //    m_objMarkTrainROI.LoadROISetting(m_objMarkTrainROI.ref_ROIPositionX, m_objMarkTrainROI.ref_ROIPositionY,
                                //m_objMarkTrainROI.ref_ROIWidth - (int)(m_objMarkTrainROI.ref_ROITotalX + m_objMarkTrainROI.ref_ROIWidth - (m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X + m_smVisionInfo.g_objGauge_PkgSize.ref_fRectWidth / 2)), m_objMarkTrainROI.ref_ROIHeight);
                                //}

                                int intROITolerance_Top = 0, intROITolerance_Right = 0, intROITolerance_Bottom = 0, intROITolerance_Left = 0;
                                if (m_smVisionInfo.g_blnWhiteOnBlack || !m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_blnSeperateBrightDarkROITolerance)
                                {
                                    intROITolerance_Top = m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromEdge;
                                    intROITolerance_Right = m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromRight;
                                    intROITolerance_Bottom = m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromBottom;
                                    intROITolerance_Left = m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromLeft;
                                }
                                else
                                {
                                    intROITolerance_Top = m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromEdge_Dark;
                                    intROITolerance_Right = m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromRight_Dark;
                                    intROITolerance_Bottom = m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromBottom_Dark;
                                    intROITolerance_Left = m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromLeft_Dark;
                                }

                                float fEdgeLimit = m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X - m_smVisionInfo.g_objGauge_PkgSize.ref_fRectWidth / 2 + intROITolerance_Left;
                                if (m_objMarkTrainROI.ref_ROITotalX < fEdgeLimit)
                                {
                                    m_objMarkTrainROI.LoadROISetting(m_objMarkTrainROI.ref_ROIPositionX + (int)Math.Round(fEdgeLimit - m_objMarkTrainROI.ref_ROITotalX, 0, MidpointRounding.AwayFromZero),
                                                                     m_objMarkTrainROI.ref_ROIPositionY,
                                                                     m_objMarkTrainROI.ref_ROIWidth - (int)Math.Round(fEdgeLimit - m_objMarkTrainROI.ref_ROITotalX, 0, MidpointRounding.AwayFromZero),
                                                                     m_objMarkTrainROI.ref_ROIHeight);
                                }

                                fEdgeLimit = m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y - m_smVisionInfo.g_objGauge_PkgSize.ref_fRectHeight / 2 + intROITolerance_Top;
                                if (m_objMarkTrainROI.ref_ROITotalY < fEdgeLimit)
                                {
                                    m_objMarkTrainROI.LoadROISetting(m_objMarkTrainROI.ref_ROIPositionX,
                                                                     m_objMarkTrainROI.ref_ROIPositionY + (int)Math.Round(fEdgeLimit - m_objMarkTrainROI.ref_ROITotalY, 0, MidpointRounding.AwayFromZero),
                                                                     m_objMarkTrainROI.ref_ROIWidth,
                                                                     m_objMarkTrainROI.ref_ROIHeight - ((int)fEdgeLimit - m_objMarkTrainROI.ref_ROITotalY));
                                }

                                fEdgeLimit = m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y + m_smVisionInfo.g_objGauge_PkgSize.ref_fRectHeight / 2 - intROITolerance_Bottom;
                                if (m_objMarkTrainROI.ref_ROITotalY + m_objMarkTrainROI.ref_ROIHeight > fEdgeLimit)
                                {
                                    m_objMarkTrainROI.LoadROISetting(m_objMarkTrainROI.ref_ROIPositionX, m_objMarkTrainROI.ref_ROIPositionY,
                                                                     m_objMarkTrainROI.ref_ROIWidth,
                                                                     m_objMarkTrainROI.ref_ROIHeight - (int)Math.Round(m_objMarkTrainROI.ref_ROITotalY + m_objMarkTrainROI.ref_ROIHeight - fEdgeLimit, 0, MidpointRounding.AwayFromZero));
                                }

                                fEdgeLimit = m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X + m_smVisionInfo.g_objGauge_PkgSize.ref_fRectWidth / 2 - intROITolerance_Right;
                                if (m_objMarkTrainROI.ref_ROITotalX + m_objMarkTrainROI.ref_ROIWidth > fEdgeLimit)
                                {
                                    m_objMarkTrainROI.LoadROISetting(m_objMarkTrainROI.ref_ROIPositionX,
                                                                     m_objMarkTrainROI.ref_ROIPositionY,
                                                                     m_objMarkTrainROI.ref_ROIWidth - (int)Math.Round(m_objMarkTrainROI.ref_ROITotalX + m_objMarkTrainROI.ref_ROIWidth - fEdgeLimit, 0, MidpointRounding.AwayFromZero),
                                                                     m_objMarkTrainROI.ref_ROIHeight);
                                }

                            }
                            #region  2021-08-25 : Hide this because no more using Lead base point to offset mark ROI
                            //else if (blnUseLeadBaseCenterPoint && m_blnWantLeadTest && (!m_blnWantPackageTest || (m_blnWantPackageTest && ((m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailMask & 0x1000) == 0 && !m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetWantInspectPackage() && !GetWantInspectPackageColor(m_smVisionInfo.g_intSelectedUnit)))) && m_smVisionInfo.g_blnWantUseLeadPointOffsetMarkROI)
                            //{
                            //    m_smVisionInfo.g_arrRotatedImages[0].CopyTo(ref m_objMarkTestImage);
                            //    m_objMarkSearchROI.AttachImage(m_objMarkTestImage);

                            //    PointF pLeadRefBasePoint = new PointF();
                            //    if (m_smVisionInfo.g_arrLead[1].ref_blnSelected && m_smVisionInfo.g_arrLead[3].ref_blnSelected)
                            //    {
                            //        pLeadRefBasePoint = m_smVisionInfo.g_arrLead[1].GetSampleLeadBaseCenterPoint(false);

                            //        pLeadRefBasePoint = new PointF(m_smVisionInfo.g_arrInspectLeadROI[1].ref_ROITotalX + pLeadRefBasePoint.X,
                            //                                       m_smVisionInfo.g_arrInspectLeadROI[1].ref_ROITotalY + pLeadRefBasePoint.Y);
                            //    }
                            //    else if (m_smVisionInfo.g_arrLead[2].ref_blnSelected && m_smVisionInfo.g_arrLead[4].ref_blnSelected)
                            //    {
                            //        pLeadRefBasePoint = m_smVisionInfo.g_arrLead[4].GetSampleLeadBaseCenterPoint(true);
                            //        pLeadRefBasePoint = new PointF(m_smVisionInfo.g_arrInspectLeadROI[4].ref_ROITotalX + pLeadRefBasePoint.X,
                            //                                       m_smVisionInfo.g_arrInspectLeadROI[4].ref_ROITotalY + pLeadRefBasePoint.Y);
                            //    }

                            //    //float fOffsetX1 = -60;
                            //    //float fOffsetY1 = 30;
                            //    //float fOffsetX2 = 300;
                            //    //float fOffsetY2 = 180;
                            //    float fOffsetX1 = m_smVisionInfo.g_arrMarks[0].ref_intMarkROIOffsetLeft;
                            //    float fOffsetY1 = m_smVisionInfo.g_arrMarks[0].ref_intMarkROIOffsetTop;
                            //    float fOffsetX2 = m_smVisionInfo.g_arrMarks[0].ref_intMarkROIOffsetRight;
                            //    float fOffsetY2 = m_smVisionInfo.g_arrMarks[0].ref_intMarkROIOffsetBottom;
                            //    PointF pStart = new PointF(pLeadRefBasePoint.X + fOffsetX1, pLeadRefBasePoint.Y + fOffsetY1);
                            //    PointF pEnd = new PointF(pLeadRefBasePoint.X + fOffsetX2, pLeadRefBasePoint.Y + fOffsetY2);
                            //    List<PointF> arrPoints = new List<PointF>(); // 0:Top Left, 1: Top Right, 2:Bottom Left, 3:Bottom Right
                            //    arrPoints.Add(new PointF(pStart.X, pStart.Y));
                            //    arrPoints.Add(new PointF(pEnd.X, pStart.Y));
                            //    arrPoints.Add(new PointF(pStart.X, pEnd.Y));
                            //    arrPoints.Add(new PointF(pEnd.X, pEnd.Y));

                            //    m_objMarkTrainROI.LoadROISetting((int)Math.Round(arrPoints[0].X - m_objMarkSearchROI.ref_ROIPositionX), (int)Math.Round(arrPoints[0].Y - m_objMarkSearchROI.ref_ROIPositionY),
                            //        (int)Math.Round(arrPoints[3].X - arrPoints[0].X), (int)Math.Round(arrPoints[2].Y - arrPoints[0].Y));
                            //    //m_objMarkTrainROI.SaveImage("D:\\m_objMarkTrainROI1.bmp");

                            //    PointF pTemp = new PointF();
                            //    //2021-04-07 ZJYEOH : Get Mark inspect ROI points for drawing during display lead image
                            //    Math2.GetNewXYAfterRotate_360deg(m_objMarkTrainROI.ref_ROITotalCenterX,
                            //                                m_objMarkTrainROI.ref_ROITotalCenterY,
                            //                                arrPoints[0],
                            //                                (m_fOrientFinalAngleForLead),
                            //                                ref pTemp);
                            //    m_smVisionInfo.g_pMarkROIDrawing_Lead[0] = pTemp;

                            //    Math2.GetNewXYAfterRotate_360deg(m_objMarkTrainROI.ref_ROITotalCenterX,
                            //                                     m_objMarkTrainROI.ref_ROITotalCenterY,
                            //                                     arrPoints[1],
                            //                                     (m_fOrientFinalAngleForLead),
                            //                                     ref pTemp);
                            //    m_smVisionInfo.g_pMarkROIDrawing_Lead[1] = pTemp;

                            //    Math2.GetNewXYAfterRotate_360deg(m_objMarkTrainROI.ref_ROITotalCenterX,
                            //                                     m_objMarkTrainROI.ref_ROITotalCenterY,
                            //                                     arrPoints[2],
                            //                                     (m_fOrientFinalAngleForLead),
                            //                                     ref pTemp);
                            //    m_smVisionInfo.g_pMarkROIDrawing_Lead[2] = pTemp;

                            //    Math2.GetNewXYAfterRotate_360deg(m_objMarkTrainROI.ref_ROITotalCenterX,
                            //                                     m_objMarkTrainROI.ref_ROITotalCenterY,
                            //                                     arrPoints[3],
                            //                                     (m_fOrientFinalAngleForLead),
                            //                                     ref pTemp);
                            //    m_smVisionInfo.g_pMarkROIDrawing_Lead[3] = pTemp;

                            //    //PointF pTemp = new PointF();
                            //    Math2.GetNewXYAfterRotate_360deg(m_smVisionInfo.g_arrLead[0].ref_fRotateCenterX_ForDrawing,
                            //                                     m_smVisionInfo.g_arrLead[0].ref_fRotateCenterY_ForDrawing,
                            //                                     arrPoints[0],
                            //                                     -(m_fOrientFinalAngleForLead - m_fLeadPatternAngle),
                            //                                     ref pTemp);
                            //    arrPoints[0] = pTemp;

                            //    Math2.GetNewXYAfterRotate_360deg(m_smVisionInfo.g_arrLead[0].ref_fRotateCenterX_ForDrawing,
                            //                                     m_smVisionInfo.g_arrLead[0].ref_fRotateCenterY_ForDrawing,
                            //                                     arrPoints[1],
                            //                                     -(m_fOrientFinalAngleForLead - m_fLeadPatternAngle),
                            //                                     ref pTemp);
                            //    arrPoints[1] = pTemp;

                            //    Math2.GetNewXYAfterRotate_360deg(m_smVisionInfo.g_arrLead[0].ref_fRotateCenterX_ForDrawing,
                            //                                     m_smVisionInfo.g_arrLead[0].ref_fRotateCenterY_ForDrawing,
                            //                                     arrPoints[2],
                            //                                     -(m_fOrientFinalAngleForLead - m_fLeadPatternAngle),
                            //                                     ref pTemp);
                            //    arrPoints[2] = pTemp;

                            //    Math2.GetNewXYAfterRotate_360deg(m_smVisionInfo.g_arrLead[0].ref_fRotateCenterX_ForDrawing,
                            //                                     m_smVisionInfo.g_arrLead[0].ref_fRotateCenterY_ForDrawing,
                            //                                     arrPoints[3],
                            //                                     -(m_fOrientFinalAngleForLead - m_fLeadPatternAngle),
                            //                                     ref pTemp);
                            //    arrPoints[3] = pTemp;

                            //    //2021-04-07 ZJYEOH : Get Mark inspect ROI points for drawing during display lead image
                            //    //m_smVisionInfo.g_pMarkROIDrawing_Lead[0] = arrPoints[0];
                            //    //m_smVisionInfo.g_pMarkROIDrawing_Lead[1] = arrPoints[1];
                            //    //m_smVisionInfo.g_pMarkROIDrawing_Lead[2] = arrPoints[2];
                            //    //m_smVisionInfo.g_pMarkROIDrawing_Lead[3] = arrPoints[3];

                            //    if (m_smVisionInfo.g_blnWhiteOnBlack)
                            //    {
                            //        DontCareWithoutRotateImage.ProduceImage(arrPoints, m_objMarkSearchROI, m_objMarkTrainROI, m_objMarkTestImage
                            //            , m_smVisionInfo.g_objBlackWhiteTopImage, m_smVisionInfo.g_objBlackWhiteRightImage, m_smVisionInfo.g_objBlackWhiteBottomImage, m_smVisionInfo.g_objBlackWhiteLeftImage, false);
                            //    }
                            //    else
                            //    {
                            //        DontCareWithoutRotateImage.ProduceImage(arrPoints, m_objMarkSearchROI, m_objMarkTrainROI, m_objMarkTestImage
                            //            , m_smVisionInfo.g_objBlackWhiteTopImage, m_smVisionInfo.g_objBlackWhiteRightImage, m_smVisionInfo.g_objBlackWhiteBottomImage, m_smVisionInfo.g_objBlackWhiteLeftImage, true);
                            //    }

                            //}
                            #endregion
                            else
                            {
                                if ((m_smCustomizeInfo.g_intWantLead & (1 << m_smVisionInfo.g_intVisionPos)) > 0 && m_smVisionInfo.g_arrLead[0].GetWantInspectLead())
                                    m_smVisionInfo.g_arrRotatedImages[0].CopyTo(ref m_objMarkTestImage);

                                if (m_smVisionInfo.g_fOrientCenterX[0] != -1 && m_smVisionInfo.g_fOrientCenterY[0] != -1)    // Orient test able to get position
                                {

                                    // 2019 08 16 ZJYEOH : To load the Mark ROI without gauge, the center point cannot use directly from m_smVisionInfo.g_fOrientCenterX[0] as this point is before rotated
                                    float CenterX = (float)(m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROICenterX - m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIPositionX);
                                    float CenterY = (float)(m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROICenterY - m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIPositionY);

                                    float Angle = m_smVisionInfo.g_fOrientAngle[0] + (m_intOrientAngle); // this formula is based on clockwise rotation so the angle need to be inverted, 
                                    Angle = -Angle;
                                    float fXAfterRotated = (float)((CenterX) + ((m_smVisionInfo.g_fOrientCenterX[0] - CenterX) * Math.Cos(Angle * Math.PI / 180)) - ((m_smVisionInfo.g_fOrientCenterY[0] - CenterY) * Math.Sin(Angle * Math.PI / 180)));

                                    float fYAfterRotated = (float)((CenterY) + ((m_smVisionInfo.g_fOrientCenterX[0] - CenterX) * Math.Sin(Angle * Math.PI / 180)) + ((m_smVisionInfo.g_fOrientCenterY[0] - CenterY) * Math.Cos(Angle * Math.PI / 180)));

                                    m_fCenterX = //m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalX + m_smVisionInfo.g_fOrientCenterX[0] + m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROICenterX - m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROICenterX;
                                    m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalX + fXAfterRotated + m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROICenterX - m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROICenterX;
                                    m_fCenterY = //m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalY + m_smVisionInfo.g_fOrientCenterY[0] + m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROICenterY - m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROICenterY;
                                    m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalY + fYAfterRotated + m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROICenterY - m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROICenterY;

                                    m_objMarkTrainROI.LoadROISetting((int)fXAfterRotated +                  // Orient Result Object Center X
                                                                    m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROICenterX -      // Mark ROI Center X
                                                                    m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROICenterX -    // Orient ROI Center X
                                                                    m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROIWidth / 2,     // Half of Mark ROI Size X
                                                                    (int)fYAfterRotated +
                                                                    m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROICenterY -
                                                                    m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROICenterY -
                                                                    m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROIHeight / 2,
                                                                    m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROIWidth, m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROIHeight);
                                }
                                else
                                {
                                    m_objMarkTrainROI.LoadROISetting(m_objMarkSearchROI.ref_ROIWidth / 2 -    // Orient ROI Center X
                                                                    m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROIWidth / 2,     // Half of Mark ROI Size X
                                                                    m_objMarkSearchROI.ref_ROIHeight / 2 -
                                                                    m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROIHeight / 2,
                                                                    m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROIWidth, m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROIHeight);
                                }
                            }
                        }
                    }
                    else
                    {
                        m_objMarkSearchROI.AttachImage(m_smVisionInfo.g_arrRotatedImages[0]);

                        if (m_blnWantOrientTest && m_blnWantPackageTest)
                        {
                            // Find unit ROI (Train ROI)
                            m_objMarkTrainROI.ref_ROIPositionX = (int)Math.Round(m_smVisionInfo.g_fUnitCenterX[0] - (float)m_objMarkTrainROI.ref_ROIWidth / 2, 0, MidpointRounding.AwayFromZero);   // 2018 10 09 - CCENG: change g_fOrientCenterXY to g_fUnitCenterXY because g_fOrientCenter is used to keep Orient matcher result center point, not orient gauge unit center point.
                            m_objMarkTrainROI.ref_ROIPositionY = (int)Math.Round(m_smVisionInfo.g_fUnitCenterY[0] - (float)m_objMarkTrainROI.ref_ROIHeight / 2, 0, MidpointRounding.AwayFromZero);
                        }
                    }

                    if ((m_smCustomizeInfo.g_intWant2DCode & (1 << m_smVisionInfo.g_intVisionPos)) > 0 && m_smVisionInfo.g_blnWantMark2DCode)
                    {
                        // ---------- Fill 2D code area with black color -------------------
                        int intStartX = 0, intStartY = 0, intEndX = 0, intEndY = 0;

                        int intOffsetX;
                        int intOffsetY;

                        if (m_smVisionInfo.g_blnWantGauge)  // Mean during mark inspection, orient gauge is used to measure unit position for m_objMark2DCodeROI
                        {
                            intOffsetX = m_objMark2DCodeROI.ref_ROITotalX;
                            intOffsetY = m_objMark2DCodeROI.ref_ROITotalY;
                        }
                        else if (m_smVisionInfo.g_arrMarkROIs[0].Count > 3)    // Mean during mark inspection, Unit PR is used to find unit surface position for m_objMark2DCodeROI
                        {
                            intOffsetX = m_objMark2DCodeROI.ref_ROITotalX;
                            intOffsetY = m_objMark2DCodeROI.ref_ROITotalY;
                        }
                        else // Mean during mark inspection, m_objMarkSearchROI is used.
                        {
                            intOffsetX = m_objMark2DCodeROI.ref_ROITotalX;
                            intOffsetY = m_objMark2DCodeROI.ref_ROITotalY;
                        }

                        int intRectStartX, intRectStartY, intRectEndX, intRectEndY;
                        intRectStartX = intRectStartY = intRectEndX = intRectEndY = 0;

                        m_smVisionInfo.g_arrMarks[0].Get2DCodeStartEndXY(ref intStartX, ref intStartY, ref intEndX, ref intEndY);

                        intRectStartX = intOffsetX + intStartX;
                        intRectStartY = intOffsetY + intStartY;
                        intRectEndX = intOffsetX + intEndX;
                        intRectEndY = intOffsetY + intEndY;

                        m_smVisionInfo.g_arrRotatedImages[0].CopyTo(ref m_objMarkTestImage);
                        m_objMarkSearchROI.AttachImage(m_objMarkTestImage);
                        Shape.FillRectangle(m_objMarkTestImage, intRectStartX, intRectStartY, intRectEndX, intRectEndY, 0);

                        if (m_smVisionInfo.g_blnWantGauge)
                            m_smVisionInfo.g_arrMarks[0].InspectOCVMark_NewMethodForMultiExcessMark(blnAuto, m_objMarkTestImage, m_objMarkSearchROI, m_objMarkTrainROI, !m_smVisionInfo.g_blnWantGauge, m_smVisionInfo.g_objWhiteImage, m_smVisionInfo.g_objBlackImage, m_smVisionInfo.g_blnWantCheckNoMark, m_smVisionInfo.g_blnWantCheckContourOnMark, m_smVisionInfo.g_blnWantCheckMarkBroken, false, 0);
                        else if (m_smVisionInfo.g_arrMarkROIs[0].Count > 3 && (((m_smCustomizeInfo.g_intWantPositioningIndex & (1 << m_smVisionInfo.g_intVisionPos)) > 0) ||
                                    ((m_smCustomizeInfo.g_intWantLead & (1 << m_smVisionInfo.g_intVisionPos)) > 0)))    // Mean Unit Surface ROI exist
                            m_smVisionInfo.g_arrMarks[0].InspectOCVMark_NewMethodForMultiExcessMark(blnAuto, m_objMarkTestImage, m_objMarkSearchROI, m_objMarkTrainROI, !m_smVisionInfo.g_blnWantGauge, m_smVisionInfo.g_objWhiteImage, m_smVisionInfo.g_objBlackImage, m_smVisionInfo.g_blnWantCheckNoMark, m_smVisionInfo.g_blnWantCheckContourOnMark, m_smVisionInfo.g_blnWantCheckMarkBroken, false, 0);
                        else
                            m_smVisionInfo.g_arrMarks[0].InspectOCVMark_NewMethodForMultiExcessMark(blnAuto, m_objMarkTestImage, m_objMarkSearchROI, m_objMarkTrainROI, !m_smVisionInfo.g_blnWantGauge, m_smVisionInfo.g_objWhiteImage, m_smVisionInfo.g_objBlackImage, m_smVisionInfo.g_blnWantCheckNoMark, m_smVisionInfo.g_blnWantCheckContourOnMark, m_smVisionInfo.g_blnWantCheckMarkBroken, false, 0); // m_objMarkSearchROI

                        // 2020 04 15 - JBTAN: check mark option enable only will set result fail
                        if (m_smVisionInfo.g_arrMarks[0].ref_blnCheckMark)
                        {
                            m_smVisionInfo.g_blnMarkInspected = true;
                            m_smVisionInfo.g_blnDrawMarkResult = true;

                            if (m_smVisionInfo.g_arrMarks[0].ref_intFailResultMask > 0)
                            {

                                m_smVisionInfo.g_strErrorMessage = m_smVisionInfo.g_arrMarks[0].GetInspectionMessage(-1, false, 0);

                                if (blnAuto)
                                {
                                    SaveRejectImage_AddToBuffer("Mark", m_smVisionInfo.g_arrMarks[0].GetInspectionMessage(-1, false, 0));

                                    m_smVisionInfo.g_intMarkFailureTotal++;
                                }
                                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                                    if (m_intTCPIPResultID == -1)
                                        m_intTCPIPResultID = (int)TCPIPResulID.FailMark;
                                return false;
                            }
                        }
                    }
                    else
                    {
                        //2020-11-04 ZJYEOH : Get Mark inspect ROI points for drawing
                        m_smVisionInfo.g_pMarkROIDrawing[0] = new Point(m_objMarkTrainROI.ref_ROITotalX, m_objMarkTrainROI.ref_ROITotalY);
                        m_smVisionInfo.g_pMarkROIDrawing[1] = new Point(m_objMarkTrainROI.ref_ROITotalX + m_objMarkTrainROI.ref_ROIWidth, m_objMarkTrainROI.ref_ROITotalY);
                        m_smVisionInfo.g_pMarkROIDrawing[2] = new Point(m_objMarkTrainROI.ref_ROITotalX, m_objMarkTrainROI.ref_ROITotalY + m_objMarkTrainROI.ref_ROIHeight);
                        m_smVisionInfo.g_pMarkROIDrawing[3] = new Point(m_objMarkTrainROI.ref_ROITotalX + m_objMarkTrainROI.ref_ROIWidth, m_objMarkTrainROI.ref_ROITotalY + m_objMarkTrainROI.ref_ROIHeight);

                        PointF pPackageCenterPoint = new PointF(-1, -1);
                        SizeF SPackageSize = new SizeF(-1, -1);
                        float fPackageAngle = 0;
                        if (m_blnWantPackageTest && ((m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailMask & 0x1000) > 0 || m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetWantInspectPackage() || GetWantInspectPackageColor(m_smVisionInfo.g_intSelectedUnit))) // 2020-06-23 ZJYEOH : If inspection option got tick Check package size just can use pkg gauge
                        {
                            pPackageCenterPoint = m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint;
                            fPackageAngle = m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle;
                            SPackageSize = new SizeF(m_smVisionInfo.g_objGauge_PkgSize.ref_fRectWidth, m_smVisionInfo.g_objGauge_PkgSize.ref_fRectHeight);
                        }

                        string strPreTestImagePath = "D:\\PreTest Image\\Recipe\\" + m_smProductionInfo.g_arrSingleRecipeID[m_smVisionInfo.g_intVisionIndex] + "\\" + m_smVisionInfo.g_strVisionFolderName + "\\";

                        // 2021-08-25 : Hide this because no more using Lead base point to offset mark ROI
                        //if (m_blnWantLeadTest && (!m_blnWantPackageTest || (m_blnWantPackageTest && ((m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailMask & 0x1000) == 0 && !m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetWantInspectPackage() && !GetWantInspectPackageColor(m_smVisionInfo.g_intSelectedUnit)))) && m_smVisionInfo.g_blnWantUseLeadPointOffsetMarkROI)
                        //{
                        //    ImageDrawing objRotatedPackageImage = m_objMarkTestImage;//m_smVisionInfo.g_arrRotatedImages[0]; //2020-11-03 ZJYEOH : if no package and got lead, then rotatedpackageimage will follow mark Angle
                        //    m_smVisionInfo.g_arrMarks[0].InspectOCVMark_NewMethodForMultiExcessMark_OcvAngleAndPackageAngle_Lead(blnAuto,
                        //        ref objRotatedPackageImage,
                        //        m_smVisionInfo.g_objMarkImage,
                        //        m_objMarkOcvSearchROI,
                        //        m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROIWidth,
                        //        m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROIHeight,
                        //        m_objMarkSearchROI,
                        //        m_objMarkTrainROI,
                        //        !m_smVisionInfo.g_blnWantGauge, m_smVisionInfo.g_objWhiteImage, m_smVisionInfo.g_objBlackImage,
                        //        m_smVisionInfo.g_blnWantCheckNoMark, m_smVisionInfo.g_blnWantCheckContourOnMark, m_smVisionInfo.g_blnWantCheckMarkBroken,//m_smVisionInfo.g_blnWantCheckCharBrokenMark,
                        //        pPackageCenterPoint,
                        //        SPackageSize,
                        //        fPackageAngle,
                        //        m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_fDegAngleResult,
                        //        m_smVisionInfo.g_intMarkDefectInspectionMethod,
                        //        m_smVisionInfo.g_intMarkInspectionAreaGrayValueSensitivity,
                        //        m_smVisionInfo.g_intMarkBrightSensitivity,
                        //        m_smVisionInfo.VM_PR_ByPassUnit, m_smVisionInfo.g_intMinMarkScore, m_smVisionInfo.g_arrMarkDontCareROIs
                        //        , m_smVisionInfo.g_objBlackWhiteTopImage, m_smVisionInfo.g_objBlackWhiteRightImage, m_smVisionInfo.g_objBlackWhiteBottomImage, m_smVisionInfo.g_objBlackWhiteLeftImage);
                        //}
                        //else
                        {
                            ImageDrawing objRotatedPackageImage = m_smVisionInfo.g_arrRotatedImages[0];
                            m_smVisionInfo.g_arrMarks[0].InspectOCVMark_NewMethodForMultiExcessMark_OcvAngleAndPackageAngle(blnAuto,
                                ref objRotatedPackageImage,
                                m_smVisionInfo.g_objMarkImage,
                                m_objMarkOcvSearchROI,
                                 m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROIWidth,
                                m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROIHeight,
                                m_objMarkSearchROI,
                                m_objMarkTrainROI,
                                !m_smVisionInfo.g_blnWantGauge, m_smVisionInfo.g_objWhiteImage, m_smVisionInfo.g_objBlackImage,
                                false,// m_smVisionInfo.g_blnWantCheckNoMark,
                                m_smVisionInfo.g_blnWantCheckContourOnMark, m_smVisionInfo.g_blnWantCheckMarkBroken,//m_smVisionInfo.g_blnWantCheckCharBrokenMark,
                                pPackageCenterPoint,
                                SPackageSize,
                                fPackageAngle,
                                m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_fDegAngleResult,
                                m_smVisionInfo.g_intMarkDefectInspectionMethod,
                                m_smVisionInfo.g_intMarkInspectionAreaGrayValueSensitivity,
                                m_smVisionInfo.g_intMarkBrightSensitivity,
                                false, 0, m_arrDontCareLeadAreaStartX, m_arrDontCareLeadAreaStartY, m_arrDontCareLeadAreaEndX, m_arrDontCareLeadAreaEndY, m_arrDontCareLeadDirection, m_smVisionInfo.g_arrMarkDontCareROIs
                                , m_smVisionInfo.g_objBlackWhiteTopImage, m_smVisionInfo.g_objBlackWhiteRightImage, m_smVisionInfo.g_objBlackWhiteBottomImage, m_smVisionInfo.g_objBlackWhiteLeftImage,
                                m_blnTestHandMade_Mark, strPreTestImagePath, ShowLiterationOnly);
                        }

                        if (m_smVisionInfo.g_arrMarks[0].ref_blnCheckMark)
                        {
                            m_smVisionInfo.g_blnMarkInspected = true;
                            m_smVisionInfo.g_blnDrawMarkResult = !m_blnRecipeVerificationTestMode;//true

                            if (m_smVisionInfo.g_arrMarks[0].ref_intFailResultMask > 0)
                            {
                                //WaitEventDone(ref m_bPackageSizeTestDone, true, 10000, "StartMarkTest > m_bPackageSizeTestDone 2");//2021-03-09 ZJYEOH : No need to wait package result as mark will fail priority, waiting here cause software fall into infinite loop as package also waiting mark done inspection
                                //if (m_bSubTh_PackageTest_PackageSize_Result)
                                //if (m_bSubTh_PackageTest_PackageSize_Result)
                                {
                                    m_smVisionInfo.g_strErrorMessage += m_smVisionInfo.g_arrMarks[0].GetInspectionMessage(-1, false, 0);
                                    
                                    if (m_smVisionInfo.g_arrMarks[0].ref_blnExtraSaveImageAndRecipeDueToException)
                                    {
                                        m_smVisionInfo.g_arrMarks[0].ref_blnExtraSaveImageAndRecipeDueToException = false;

                                        // Save image
                                        string strFileName = DateTime.Now.ToString("yyyy-MM-dd_HH-mm");

                                        for (int i = 0; i < m_smVisionInfo.g_arrImages.Count; i++)
                                        {
                                            if (i == 0)
                                                m_smVisionInfo.g_arrImages[i].SaveImage("D:\\TS\\" + strFileName + "\\ExceptionImage.bmp");
                                            else
                                                m_smVisionInfo.g_arrImages[i].SaveImage("D:\\TS\\" + strFileName + "\\ExceptionImage_Image" + i.ToString() + ".bmp");
                                        }

                                        string strRecipePath = m_smProductionInfo.g_strRecipePath + m_smProductionInfo.g_strRecipeID + "\\";
                                        string strDestinationPath = "D:\\TS\\" + strFileName + "\\";
                                        // Save recipe
                                        if (Directory.Exists(strDestinationPath))
                                        {
                                            CopyAllFiles(strRecipePath + "Vision" + (m_smVisionInfo.g_intVisionIndex + 1).ToString() + "\\",
                                                         strDestinationPath + "Vision" + (m_smVisionInfo.g_intVisionIndex + 1).ToString() + "\\");

                                            if (Directory.Exists(strDestinationPath))
                                            {
                                                DirectoryInfo dir = new DirectoryInfo(m_smProductionInfo.g_strRecipePath);
                                                FileInfo[] files = dir.GetFiles();
                                                foreach (FileInfo file in files)
                                                {
                                                    if (file.Name == "Vision" + (m_smVisionInfo.g_intVisionIndex + 1).ToString() + "Calibration.xml")
                                                    {
                                                        string temppath = Path.Combine(strDestinationPath, file.Name);
                                                        file.CopyTo(temppath, true);
                                                    }
                                                }
                                            }
                                        }

                                        // 2019 09 04 - CCENG: Add save date and software version for easier tracking.
                                        File.WriteAllText(strDestinationPath + @"\ReadMe.txt", "Save Date : " + DateTime.Now.ToString());
                                        File.AppendAllText(strDestinationPath + @"\ReadMe.txt", "\n");
                                        File.AppendAllText(strDestinationPath + @"\ReadMe.txt", "Vision Software Version : " + Application.ProductVersion);
                                    }

                                    if (blnAuto)
                                    {
                                        SaveRejectImage_AddToBuffer("Mark", m_smVisionInfo.g_arrMarks[0].GetInspectionMessage(-1, false, 0));

                                        m_smVisionInfo.g_intMarkFailureTotal++;
                                    }
                                }
                                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                                    if (m_intTCPIPResultID == -1)
                                        m_intTCPIPResultID = (int)TCPIPResulID.FailMark;

                                return false;

                            }
                        }

                    }
                }

                // -------- Check Mark Text Shifted ----------------------------
                // 2019 07 21 - When no gauge during mark test, it is not possible to check Mark Texted Shifted.
                //            - So need to rely on Package Size result to check Mark Text Shifted.
                if (!m_smVisionInfo.g_blnWantGauge && !m_blnTestHandMade_Mark)
                {
                    bool blnWantCheckMarkTextShifted = false;
                    if (m_smVisionInfo.g_arrMarks != null && m_smVisionInfo.g_arrMarks.Count > 0)
                    {
                        blnWantCheckMarkTextShifted = m_smVisionInfo.g_arrMarks[0].ref_blnCheckMark && m_smVisionInfo.g_arrMarks[0].WantCheckMarkTextShifted();
                    }

                    if (blnWantCheckMarkTextShifted)
                    {
                        if (m_bPackageSizePreTestResult) // Only need to check text shifted if mark result pass, and package size inspection pass
                        {
                            if (!m_smVisionInfo.g_arrMarks[0].CheckTextShifted2(
                                (int)Math.Round(m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_fPackageResultCenterX - m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_fPackageResultWidth_px / 2, 0, MidpointRounding.AwayFromZero),
                                (int)Math.Round(m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_fPackageResultCenterY - m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_fPackageResultHeight_px / 2, 0, MidpointRounding.AwayFromZero),
                                (int)Math.Round(m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_fPackageResultCenterX + m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_fPackageResultWidth_px / 2, 0, MidpointRounding.AwayFromZero),
                                (int)Math.Round(m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_fPackageResultCenterY + m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_fPackageResultHeight_px / 2, 0, MidpointRounding.AwayFromZero)))
                            {
                                //WaitEventDone(ref m_bPackageSizeTestDone, true, 10000, "StartMarkTest > m_bPackageSizeTestDone 3");//2021-03-09 ZJYEOH : No need to wait package result as mark will fail priority, waiting here cause software fall into infinite loop as package also waiting mark done inspection
                                //if (m_bSubTh_PackageTest_PackageSize_Result)
                                {
                                    m_smVisionInfo.g_strErrorMessage += "*Mark Shifted";
                                    if (blnAuto)
                                    {
                                        SaveRejectImage_AddToBuffer("Mark", m_smVisionInfo.g_strErrorMessage);

                                        m_smVisionInfo.g_intMarkFailureTotal++;
                                    }
                                }
                                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                                    if (m_intTCPIPResultID == -1)
                                        m_intTCPIPResultID = (int)TCPIPResulID.FailMark;
                                return false;
                            }
                        }
                    }
                }
                // --------------- End Check Mark Text Shifted ---------------------------------------------


                return true;

            }
            catch (Exception ex)
            {
                STTrackLog.WriteLine("Vision1Process StartMarkTest ex: " + ex.ToString());
                return false;
            }
        }

        private bool StartMark2DCodeTest_using4LGauge(bool blnAuto)
        {
            try
            {
                m_objMarkSearchROI = m_smVisionInfo.g_arrMarkROIs[0][0];
                if (m_objMark2DCodeROI == null)
                    m_objMark2DCodeROI = new ROI();
                m_objMark2DCodeROI.AttachImage(m_objMarkSearchROI);
                m_objMark2DCodeROI.LoadROISetting(m_smVisionInfo.g_arrMarkROIs[0][2].ref_ROIPositionX, m_smVisionInfo.g_arrMarkROIs[0][2].ref_ROIPositionY,
                                           m_smVisionInfo.g_arrMarkROIs[0][2].ref_ROIWidth, m_smVisionInfo.g_arrMarkROIs[0][2].ref_ROIHeight);

                if (m_smVisionInfo.g_arrOrients[0][0].ref_intCorrectAngleMethod == 0)
                {
                    //no orient check
                    if (((m_smCustomizeInfo.g_intWantOrient & (1 << m_smVisionInfo.g_intVisionPos)) == 0))
                    {
                        //got gauge check
                        if (m_smVisionInfo.g_blnWantGauge)
                        {
                            m_objMarkSearchROI.AttachImage(m_smVisionInfo.g_arrImages[0]);
                            m_smVisionInfo.g_arrMarkGaugeM4L[0].Measure_WithDontCareArea(m_smVisionInfo.g_arrImages, m_smVisionInfo.g_objWhiteImage);
                            // Rotate unit to exact 0 degree
                            float fGaugeAngle = m_smVisionInfo.g_arrMarkGaugeM4L[0].ref_fRectAngle;

                            ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[0], m_objMarkSearchROI, fGaugeAngle, ref m_smVisionInfo.g_arrRotatedImages, 0);
                            m_objMarkSearchROI.AttachImage(m_smVisionInfo.g_arrRotatedImages[0]);
                        }
                    }
                    else
                    {
                        m_objMarkSearchROI.AttachImage(m_smVisionInfo.g_arrRotatedImages[0]);

                        if (m_smVisionInfo.g_blnWantGauge)
                        {
                            m_objMarkSearchROI.LoadROISetting(
                                                (int)Math.Round(m_smVisionInfo.g_arrOrientGaugeM4L[0].ref_pRectCenterPoint.X -
                                                m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIWidth / 2, 0, MidpointRounding.AwayFromZero),
                                                (int)Math.Round(m_smVisionInfo.g_arrOrientGaugeM4L[0].ref_pRectCenterPoint.Y -
                                                m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIHeight / 2, 0, MidpointRounding.AwayFromZero),
                                                m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIWidth,
                                                m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIHeight);
                        }
                    }
                    if (m_smVisionInfo.g_blnWantGauge)
                    {
                        RectGaugeM4L objGauge;
                        if (m_blnWantOrientTest)
                        {
                            objGauge = m_smVisionInfo.g_arrOrientGaugeM4L[0];

                        }
                        else
                        {
                            objGauge = m_smVisionInfo.g_arrMarkGaugeM4L[0];

                            if (m_blnWantPositioning)
                            {
                                objGauge.SetGaugePlace_BasedOnEdgeROI();

                                m_objMarkSearchROI.LoadROISetting(
                                    (int)Math.Round(m_smVisionInfo.g_objPositioning.ref_fObjectCenterX -
                                     m_objMarkSearchROI.ref_ROIWidth / 2, 0, MidpointRounding.AwayFromZero),
                                     (int)Math.Round(m_smVisionInfo.g_objPositioning.ref_fObjectCenterY -
                                    m_objMarkSearchROI.ref_ROIHeight / 2, 0, MidpointRounding.AwayFromZero),
                                    m_objMarkSearchROI.ref_ROIWidth,
                                    m_objMarkSearchROI.ref_ROIHeight);
                            }

                            // Measure search roi to get unit center point
                            objGauge.Measure_WithDontCareArea(m_smVisionInfo.g_arrRotatedImages, m_objMarkSearchROI, m_smVisionInfo.g_objWhiteImage);
                        }

                        int intGaugeCenterX = (int)(objGauge.ref_pRectCenterPoint.X);
                        int intGaugeCenterY = (int)(objGauge.ref_pRectCenterPoint.Y);

                        int intOffsetX = intGaugeCenterX - (m_objMarkSearchROI.ref_ROIPositionX + m_objMarkSearchROI.ref_ROIWidth / 2);
                        int intOffsetY = intGaugeCenterY - (m_objMarkSearchROI.ref_ROIPositionY + m_objMarkSearchROI.ref_ROIHeight / 2);

                        m_objMark2DCodeROI.ref_ROIPositionX = m_objMark2DCodeROI.ref_ROIPositionX + intOffsetX;
                        m_objMark2DCodeROI.ref_ROIPositionY = m_objMark2DCodeROI.ref_ROIPositionY + intOffsetY;
                    }
                    else //No gauge
                    {
                        /* 2019 07 12 - CCENG: 
                         * No gauge mean dun know where is the unit.
                         * Mark ROI will be relocated according to orient PR result + offset between orient ROI and mark ROI
                         */


                        if (m_smVisionInfo.g_fOrientCenterX[0] != -1 && m_smVisionInfo.g_fOrientCenterY[0] != -1)    // Orient test able to get position
                        {

                            // 2019 08 16 ZJYEOH : To load the Mark ROI without gauge, the center point cannot use directly from m_smVisionInfo.g_fOrientCenterX[0] as this point is before rotated
                            float CenterX = (float)(m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROICenterX - m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIPositionX);
                            float CenterY = (float)(m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROICenterY - m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIPositionY);

                            float Angle = m_smVisionInfo.g_fOrientAngle[0] + (m_intOrientAngle); // this formula is based on clockwise rotation so the angle need to be inverted, 
                            Angle = -Angle;
                            float fXAfterRotated = (float)((CenterX) + ((m_smVisionInfo.g_fOrientCenterX[0] - CenterX) * Math.Cos(Angle * Math.PI / 180)) - ((m_smVisionInfo.g_fOrientCenterY[0] - CenterY) * Math.Sin(Angle * Math.PI / 180)));

                            float fYAfterRotated = (float)((CenterY) + ((m_smVisionInfo.g_fOrientCenterX[0] - CenterX) * Math.Sin(Angle * Math.PI / 180)) + ((m_smVisionInfo.g_fOrientCenterY[0] - CenterY) * Math.Cos(Angle * Math.PI / 180)));

                            m_fCenterX = //m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalX + m_smVisionInfo.g_fOrientCenterX[0] + m_smVisionInfo.g_arrMarkROIs[0][2].ref_ROICenterX - m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROICenterX;
                            m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalX + fXAfterRotated + m_smVisionInfo.g_arrMarkROIs[0][2].ref_ROICenterX - m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROICenterX;
                            m_fCenterY = //m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalY + m_smVisionInfo.g_fOrientCenterY[0] + m_smVisionInfo.g_arrMarkROIs[0][2].ref_ROICenterY - m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROICenterY;
                            m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalY + fYAfterRotated + m_smVisionInfo.g_arrMarkROIs[0][2].ref_ROICenterY - m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROICenterY;

                            m_objMark2DCodeROI.LoadROISetting((int)fXAfterRotated +                  // Orient Result Object Center X
                                                            m_smVisionInfo.g_arrMarkROIs[0][2].ref_ROICenterX -      // Mark ROI Center X
                                                            m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROICenterX -    // Orient ROI Center X
                                                            m_smVisionInfo.g_arrMarkROIs[0][2].ref_ROIWidth / 2,     // Half of Mark ROI Size X
                                                            (int)fYAfterRotated +
                                                            m_smVisionInfo.g_arrMarkROIs[0][2].ref_ROICenterY -
                                                            m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROICenterY -
                                                            m_smVisionInfo.g_arrMarkROIs[0][2].ref_ROIHeight / 2,
                                                            m_smVisionInfo.g_arrMarkROIs[0][2].ref_ROIWidth, m_smVisionInfo.g_arrMarkROIs[0][2].ref_ROIHeight);
                        }
                        else
                        {
                            m_objMark2DCodeROI.LoadROISetting(m_objMarkSearchROI.ref_ROIWidth / 2 -    // Orient ROI Center X
                                                            m_smVisionInfo.g_arrMarkROIs[0][2].ref_ROIWidth / 2,     // Half of Mark ROI Size X
                                                            m_objMarkSearchROI.ref_ROIHeight / 2 -
                                                            m_smVisionInfo.g_arrMarkROIs[0][2].ref_ROIHeight / 2,
                                                            m_smVisionInfo.g_arrMarkROIs[0][2].ref_ROIWidth, m_smVisionInfo.g_arrMarkROIs[0][2].ref_ROIHeight);
                        }

                        // 
                        // Attach search roi to main image
                        //m_objMarkSearchROI.AttachImage(m_smVisionInfo.g_arrImages[0]);
                    }
                }
                else
                {
                    m_objMarkSearchROI.AttachImage(m_smVisionInfo.g_arrRotatedImages[0]);

                    if (m_blnWantOrientTest && m_blnWantPackageTest)
                    {
                        // Find unit ROI (Train ROI)
                        m_objMark2DCodeROI.ref_ROIPositionX = (int)Math.Round(m_smVisionInfo.g_fUnitCenterX[0] - (float)m_objMark2DCodeROI.ref_ROIWidth / 2, 0, MidpointRounding.AwayFromZero);   // 2018 10 09 - CCENG: change g_fOrientCenterXY to g_fUnitCenterXY because g_fOrientCenter is used to keep Orient matcher result center point, not orient gauge unit center point.
                        m_objMark2DCodeROI.ref_ROIPositionY = (int)Math.Round(m_smVisionInfo.g_fUnitCenterY[0] - (float)m_objMark2DCodeROI.ref_ROIHeight / 2, 0, MidpointRounding.AwayFromZero);
                    }
                }
                //m_smVisionInfo.g_arrImages[0].SaveImage("D:\\TS\\oriImage.bmp");
                //m_smVisionInfo.g_arrRotatedImages[0].SaveImage("D:\\TS\\rotatedimagemarktest.bmp");
                //m_objMark2DCodeROI.SaveImage("D:\\TS\\m_objMark2DCodeROI.bmp");
                //m_objMarkSearchROI.SaveImage("D:\\TS\\m_objMarkSearchROI.bmp");

                if (!m_smVisionInfo.g_arrMarks[0].Read2DCodeObjects(m_objMark2DCodeROI, m_smVisionInfo.g_int2DCodeType))
                {
                    m_smVisionInfo.g_strErrorMessage = m_smVisionInfo.g_arrMarks[0].Get2DCodeErrorMessage();

                    if (blnAuto)
                    {
                        SaveRejectImage_AddToBuffer("2DCode", m_smVisionInfo.g_arrMarks[0].Get2DCodeErrorMessage());

                        m_smVisionInfo.g_intMarkFailureTotal++;
                    }

                    m_smVisionInfo.g_blnDrawMark2DCodeResult = true;
                    m_smProductionInfo.AT_CO_DataMatrixCode = "";
                    m_smProductionInfo.g_bln2DCodePass = false;
                    m_smProductionInfo.AT_CO_Send2DCode = true;

                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        if (m_intTCPIPResultID == -1)
                        {
                            if (!m_smVisionInfo.g_arrMarks[0].Get2DCodeFound())
                                m_intTCPIPResultID = (int)TCPIPResulID.FailMark;//Fail2DCodeNoFound;
                            else
                                m_intTCPIPResultID = (int)TCPIPResulID.FailMark;//Fail2DCodeVerification;
                        }

                    return false;
                }
                m_smVisionInfo.g_blnDrawMark2DCodeResult = true;
                m_smProductionInfo.AT_CO_DataMatrixCode = m_smVisionInfo.g_arrMarks[0].Get2DCodeResult();
                m_smProductionInfo.g_bln2DCodePass = true;
                m_smProductionInfo.AT_CO_Send2DCode = true;
                return true;

            }
            catch (Exception ex)
            {
                //objTL1.WriteLine("Vision1Process StartMarkTest ex: " + ex.ToString());
                return false;
            }
        }

        private bool StartOrientTest_using4LGauge_OcvAngleAndPackageAngle(bool blnAuto, bool blnWantOrient)
        {
            if ((m_smCustomizeInfo.g_intWantOrient & (1 << m_smVisionInfo.g_intVisionPos)) == 0)
                return true;

            // Reset orientation IO
            if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
            {
                m_blnOrientResult1_Out = false;
                m_blnOrientResult2_Out = false;
            }
            else
            {
                if (m_objVisionIO.OrientResult1 != null)
                    m_objVisionIO.OrientResult1.SetOff(strTrackHeadName + " OrientResult1 1"); if (m_smVisionInfo.g_blnTrackIO) STTrackLog.WriteLine("IO-OrientResult1-Set OFF 13");
                if (m_objVisionIO.OrientResult2 != null)
                    m_objVisionIO.OrientResult2.SetOff(strTrackHeadName + " OrientResult2 2"); if (m_smVisionInfo.g_blnTrackIO) STTrackLog.WriteLine("IO-OrientResult2-Set OFF 14");
            }

            // make sure template learn
            if (m_smVisionInfo.g_arrOrients[0].Count == 0)
            {
                m_smVisionInfo.g_strErrorMessage += "*Orient : No Template Found";
                if (blnAuto)
                    m_smVisionInfo.g_intNoTemplateFailureTotal++;

                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        m_intTCPIPResultID = (int)TCPIPResulID.Fail;

                return false;
            }

            if (blnAuto && m_smVisionInfo.g_blnWantSetTemplateBasedOnBinInfo)
            {
                //Get template IO data
                m_smVisionInfo.g_intSelectedTemplate = 0;
                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                {
                    if (m_blnMarkData0_In)
                        m_smVisionInfo.g_intSelectedTemplate += 1;
                    if (m_blnMarkData1_In)
                        m_smVisionInfo.g_intSelectedTemplate += 2;
                    if (m_blnMarkData2_In)
                        m_smVisionInfo.g_intSelectedTemplate += 4;
                    if (m_blnMarkData3_In)
                        m_smVisionInfo.g_intSelectedTemplate += 8;
                    if (m_blnMarkData4_In)
                        m_smVisionInfo.g_intSelectedTemplate += 16;
                    if (m_blnMarkData5_In)
                        m_smVisionInfo.g_intSelectedTemplate += 32;
                }
                else
                {
                    if (m_objVisionIO.Data1.IsOn())
                        m_smVisionInfo.g_intSelectedTemplate += 1;
                    if (m_objVisionIO.Data2.IsOn())
                        m_smVisionInfo.g_intSelectedTemplate += 2;
                    if (m_objVisionIO.Data4.IsOn())
                        m_smVisionInfo.g_intSelectedTemplate += 4;
                }

                // make sure template learn
                if (m_smVisionInfo.g_arrOrients[0].Count <= m_smVisionInfo.g_intSelectedTemplate)
                {
                    m_smVisionInfo.g_strErrorMessage += "*Orient : Selected Template " + (m_smVisionInfo.g_intSelectedTemplate + 1).ToString() + " not Learnt";
                    m_smVisionInfo.g_intNoTemplateFailureTotal++;

                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        if (m_intTCPIPResultID == -1)
                            m_intTCPIPResultID = (int)TCPIPResulID.Fail;

                    return false;
                }

                m_smVisionInfo.g_arrMarks[0].ref_intTemplateIndex = m_smVisionInfo.g_intSelectedTemplate;
            }

            // reset all inspection data
            for (int i = 0; i < m_smVisionInfo.g_arrOrients[0].Count; i++)
            {
                ((Orient)m_smVisionInfo.g_arrOrients[0][i]).ResetInspectionData();
            }

            float fUnitSurfaceOffsetX = 0;
            float fUnitSurfaceOffsetY = 0;
            float fUnitPRResultCenterX = 0;
            float fUnitPRResultCenterY = 0;
            float fUnitPRResultAngle = 0;

            // Use Gauge to find unit angle and rotate it to 0 deg
            if (m_smVisionInfo.g_blnWantGauge && ((m_smCustomizeInfo.g_intWantBottom & (1 << m_smVisionInfo.g_intVisionPos)) == 0))
            {
                if (!blnAuto)
                    m_smVisionInfo.g_arrOrientROIs[0][0].AttachImage(m_smVisionInfo.g_arrImages[0]);

                // Add gain value to image and attached all position ROI to gain image.
                float fGaugeAngle;
                bool blnGaugeResult = false;
                //if (m_smVisionInfo.g_arrOrientGaugeM4L[0].ref_fGainValue != 1000)  // 2019 05 29 - CCENG: Enable this gain feature because hard to get unit edge sometime. Dun know why this feature disabled previously
                //{
                //    m_smVisionInfo.g_arrImages[0].AddGain(ref m_objOrientGainImage, m_smVisionInfo.g_arrOrientGaugeM4L[0].ref_fGainValue / 1000);
                //    m_smVisionInfo.g_arrOrientGaugeM4L[0].SetGaugePlace_BasedOnEdgeROI();
                //    blnGaugeResult = m_smVisionInfo.g_arrOrientGaugeM4L[0].Measure_WithDontCareArea(m_objOrientGainImage, m_smVisionInfo.g_objWhiteImage);
                //    fGaugeAngle = m_fOrientGauge = m_smVisionInfo.g_arrOrientGaugeM4L[0].ref_fRectAngle;
                //}
                //else
                {
                    m_smVisionInfo.g_arrOrientGaugeM4L[0].SetGaugePlace_BasedOnEdgeROI();
                    blnGaugeResult = m_smVisionInfo.g_arrOrientGaugeM4L[0].Measure_WithDontCareArea(m_smVisionInfo.g_arrImages, m_smVisionInfo.g_objWhiteImage);
                    fGaugeAngle = m_fOrientGauge = m_smVisionInfo.g_arrOrientGaugeM4L[0].ref_fRectAngle;
                }
                if (!blnGaugeResult)
                {
                    m_smVisionInfo.g_strErrorMessage += "*Orient : " + m_smVisionInfo.g_arrOrientGaugeM4L[0].ref_strErrorMessage;
                    if (blnAuto)
                    {
                        m_smVisionInfo.g_intEdgeNotFoundFailureTotal++;
                        SaveRejectImage_AddToBuffer("EdgeNotFound", m_smVisionInfo.g_arrOrientGaugeM4L[0].ref_strErrorMessage);
                    }

                    m_smVisionInfo.g_blnViewGaugeNotFound = true;
                    m_smVisionInfo.g_blnViewOrientObject = true;

                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        if (m_intTCPIPResultID == -1)
                            m_intTCPIPResultID = (int)TCPIPResulID.Fail;

                    return false;
                }
                // RotateROI has same center point with gauge measure center point.
                ROI objRotateROI = new ROI();
                objRotateROI.AttachImage(m_smVisionInfo.g_arrImages[0]);
                objRotateROI.LoadROISetting(
                    (int)Math.Round(m_smVisionInfo.g_arrOrientGaugeM4L[0].ref_pRectCenterPoint.X -
                    m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIWidth / 2, 0, MidpointRounding.AwayFromZero),
                    (int)Math.Round(m_smVisionInfo.g_arrOrientGaugeM4L[0].ref_pRectCenterPoint.Y -
                    m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIHeight / 2, 0, MidpointRounding.AwayFromZero),
                    m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIWidth,
                    m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIHeight);

                // Rotate unit to exact 0 degree (m_fOrientGauge used in Package)
                ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[0], objRotateROI, fGaugeAngle, 0, ref m_smVisionInfo.g_arrRotatedImages, 0); // Clear image is not so important in Orient Matching. Use interpolation 0 to save rotation time.

                if (m_blnCustomWantColor && !GetColorImageRotated(0) && !ContainColorSelectedImage(0, m_smVisionInfo.g_intSelectedUnit))
                {
                    CROI objColorRotatedROI = new CROI();
                    objColorRotatedROI.AttachImage(m_smVisionInfo.g_arrColorImages[0]);

                    // Get RotateROI center point where the ROI center point == Package Unit Center Point
                    objColorRotatedROI.LoadROISetting(objRotateROI.ref_ROIPositionX,
                                                 objRotateROI.ref_ROIPositionY,
                                                 objRotateROI.ref_ROIWidth,
                                                 objRotateROI.ref_ROIHeight);

                    CROI.Rotate0Degree(m_smVisionInfo.g_arrColorImages[0], objColorRotatedROI, fGaugeAngle, 4, ref m_smVisionInfo.g_arrColorRotatedImages, 0);

                    SetColorImageRotated(0);
                    objColorRotatedROI.Dispose();
                }

                objRotateROI.Dispose();
            }
            else // No rect gauge
            {
                //2021-08-20 ZJYEOH : No need purpose rotate
                //// If Lead Unit, use unit lead pattern to find unit surface ROI
                //if (((m_smCustomizeInfo.g_intWantLead & (1 << m_smVisionInfo.g_intVisionPos)) > 0) && m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedTemplate].ref_blnUnitPRMatcherExist)
                //{
                //    m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedTemplate].MatchWithTemplateUnitPR(m_smVisionInfo.g_arrOrientROIs[0][0]);
                //    fUnitPRResultCenterX = m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedTemplate].GetUnitPRResultCenterX();
                //    fUnitPRResultCenterY = m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedTemplate].GetUnitPRResultCenterY();
                //    fUnitPRResultAngle = m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedTemplate].GetUnitPRResultAngle();
                //    fUnitSurfaceOffsetX = m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedTemplate].ref_intUnitSurfaceOffsetX;
                //    fUnitSurfaceOffsetY = m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedTemplate].ref_intUnitSurfaceOffsetY;

                //    if (!Math2.GetNewXYAfterRotate(m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalX + fUnitPRResultCenterX,
                //                                  m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalY + fUnitPRResultCenterY,
                //                                  fUnitSurfaceOffsetX,
                //                                  fUnitSurfaceOffsetY,
                //                                  fUnitPRResultAngle,
                //                                  ref fUnitSurfaceOffsetX,
                //                                  ref fUnitSurfaceOffsetY))
                //    { }

                //    ROI objRotateROI = new ROI();
                //    objRotateROI.AttachImage(m_smVisionInfo.g_arrImages[0]);
                //    objRotateROI.LoadROISetting(
                //        (int)Math.Round(m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalX +
                //        fUnitPRResultCenterX -
                //        m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIWidth / 2 +
                //        fUnitSurfaceOffsetX, 0, MidpointRounding.AwayFromZero),
                //        (int)Math.Round(m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalY +
                //        fUnitPRResultCenterY -
                //        m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIHeight / 2 +
                //        fUnitSurfaceOffsetY, 0, MidpointRounding.AwayFromZero),
                //        m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIWidth,
                //        m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIHeight);


                //    // Rotate unit to exact 0 degree (m_fOrientGauge used in Package)
                //    ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[0], objRotateROI, fUnitPRResultAngle, 0, ref m_smVisionInfo.g_arrRotatedImages, 0); // Clear image is not so important in Orient Matching. Use interpolation 0 to save rotation time.

                //    if (m_blnCustomWantColor && !GetColorImageRotated(0) && !ContainColorSelectedImage(0, m_smVisionInfo.g_intSelectedUnit))
                //    {
                //        CROI objColorRotatedROI = new CROI();
                //        objColorRotatedROI.AttachImage(m_smVisionInfo.g_arrColorImages[0]);

                //        // Get RotateROI center point where the ROI center point == Package Unit Center Point
                //        objColorRotatedROI.LoadROISetting(objRotateROI.ref_ROIPositionX,
                //                                     objRotateROI.ref_ROIPositionY,
                //                                     objRotateROI.ref_ROIWidth,
                //                                     objRotateROI.ref_ROIHeight);

                //        CROI.Rotate0Degree(m_smVisionInfo.g_arrColorImages[0], objColorRotatedROI, fUnitPRResultAngle, 4, ref m_smVisionInfo.g_arrColorRotatedImages, 0);

                //        SetColorImageRotated(0);
                //        objColorRotatedROI.Dispose();
                //    }

                //    objRotateROI.Dispose();
                //}
                //else if ((m_smCustomizeInfo.g_intWantBottom & (1 << m_smVisionInfo.g_intVisionPos)) > 0)    // Bottom Orient
                //{
                //    m_smVisionInfo.g_arrImages[0].CopyTo(m_smVisionInfo.g_arrRotatedImages[0]);
                //}
                //else // if not lead unit, mean it is QFN. There is no way to find unit surface ROI without gauge tool.
                {
                    m_smVisionInfo.g_arrImages[0].CopyTo(m_smVisionInfo.g_arrRotatedImages[0]);
                }
            }

            int intMatchCount = 0;
            m_smVisionInfo.g_intOrientResult[0] = -1;  // 0:0deg, 1:90deg, 2:180deg, 3:-90, 4:Fail
            m_arrFinalPreciseAnglePass.Clear();
            // 2019 10 08 - CCENG: m_smVisionInfo.g_blnInspectAllTemplate no longer set to false.
            // 2019 10 08 - CCENG: When g_blnWantSetTemplateBasedOnBinInfo is true, DoOrientationInspection instead of using MatchWithTemplate.
            // Single template test
            //if (!blnAuto && !m_smVisionInfo.g_blnInspectAllTemplate)
            //if ((!blnAuto && !m_smVisionInfo.g_blnInspectAllTemplate) || m_smVisionInfo.g_blnWantSetTemplateBasedOnBinInfo)
            //if ((!blnAuto && !m_smVisionInfo.g_blnInspectAllTemplate))
            //{
            //    m_smVisionInfo.g_arrMarks[0].ref_blnInspectAllTemplate = false;
            //    m_smVisionInfo.g_intOrientResult[0] = m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedTemplate].MatchWithTemplate(
            //        m_smVisionInfo.g_arrOrientROIs[0][0], m_smVisionInfo.g_arrRotatedImages[0], true);
            //    m_smVisionInfo.g_intSelectedOcv[0] = m_smVisionInfo.g_intSelectedTemplate;
            //    m_smVisionInfo.g_fOrientScore[0] = m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedTemplate].GetMinScore();
            //}
            //else // Whole active templates test
            if (m_smVisionInfo.g_blnWantSetTemplateBasedOnBinInfo)
            {
                float fHighestScore = -1;
                m_smVisionInfo.g_arrMarks[0].ref_blnInspectAllTemplate = true;
                int intTemplateIndex = m_smVisionInfo.g_intSelectedTemplate;
                if (intTemplateIndex >= 0)
                {
                    int intAngle;
                    if (m_smVisionInfo.g_intTemplateMask == 0 || (m_smVisionInfo.g_intTemplateMask & (1 << intTemplateIndex)) > 0)
                    {
                        m_smVisionInfo.g_arrOrientROIs[0][0].AttachImage(m_smVisionInfo.g_arrRotatedImages[0]);

                        intAngle = m_smVisionInfo.g_arrOrients[0][intTemplateIndex].DoOrientationInspection(
                                m_smVisionInfo.g_arrOrientROIs[0][0], 2, !m_smVisionInfo.g_blnWantGauge);  // Use FinalReduction=2 because match center point is not very important in MarkOrient Test.


                        if (m_smVisionInfo.g_arrOrients[0][intTemplateIndex].GetMinScore() > fHighestScore)
                        {
                            fHighestScore = m_smVisionInfo.g_fOrientScore[0] = m_smVisionInfo.g_arrOrients[0][intTemplateIndex].GetMinScore();
                            m_smVisionInfo.g_intSelectedOcv[0] = intTemplateIndex;
                            m_smVisionInfo.g_intOrientResult[0] = intAngle;

                        }
                    }
                }
            }
            else
            {

                float fHighestScore = -1;
                m_smVisionInfo.g_arrMarks[0].ref_blnInspectAllTemplate = true;
                do
                {
                    int intTemplateIndex = (int)((m_smVisionInfo.g_intTemplatePriority >> (0x04 * intMatchCount)) & 0x0F) - 1;
                    if (intTemplateIndex >= 0)
                    {
                        int intAngle;
                        m_arrFinalPreciseAnglePass.Add(true);
                        bool blnPreciseAngleResult = true;
                        if (m_smVisionInfo.g_intTemplateMask == 0 || (m_smVisionInfo.g_intTemplateMask & (1 << intTemplateIndex)) > 0)
                        {
                            if (((m_smCustomizeInfo.g_intWantMark & (1 << m_smVisionInfo.g_intVisionPos)) > 0) || ((m_smCustomizeInfo.g_intWantOCR & (1 << m_smVisionInfo.g_intVisionPos)) > 0) || ((m_smCustomizeInfo.g_intWantOCR2 & (1 << m_smVisionInfo.g_intVisionPos)) > 0) ||
                                (m_smCustomizeInfo.g_intWantPackage & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
                            {
                                m_smVisionInfo.g_arrOrientROIs[0][0].AttachImage(m_smVisionInfo.g_arrRotatedImages[0]);

                                intAngle = m_smVisionInfo.g_arrOrients[0][intTemplateIndex].DoOrientationInspection(
                                m_smVisionInfo.g_arrOrientROIs[0][0], m_smVisionInfo.g_intFinalReduction_Direction, m_smVisionInfo.g_intFinalReduction_MarkDeg, blnWantOrient, !m_smVisionInfo.g_blnWantGauge,
                                m_smVisionInfo.g_arrMarks[0].GetMarkAngleTolerance(0, intTemplateIndex), 
                                ref blnPreciseAngleResult, ((m_smCustomizeInfo.g_intWantLead & (1 << m_smVisionInfo.g_intVisionPos)) > 0),
                                !m_smVisionInfo.g_blnWhiteOnBlack);  // Use FinalReduction=2 because match center point is not very important in MarkOrient Test.

                                if (!blnPreciseAngleResult)
                                    m_arrFinalPreciseAnglePass[intTemplateIndex] = false;

                                //intAngle = m_smVisionInfo.g_arrOrients[0][intTemplateIndex].DoOrientationInspection(
                                //    m_smVisionInfo.g_arrOrientROIs[0][0], 2, !m_smVisionInfo.g_blnWantGauge);  // Use FinalReduction=2 because match center point is not very important in MarkOrient Test.
                            }
                            else
                            {
                                m_smVisionInfo.g_arrOrientROIs[0][0].AttachImage(m_smVisionInfo.g_arrRotatedImages[0]);

                                intAngle = m_smVisionInfo.g_arrOrients[0][intTemplateIndex].DoOrientationInspection_WithSubMatcher4(m_smVisionInfo.g_arrRotatedImages[0],
                                            m_smVisionInfo.g_arrOrientROIs[0][0], m_smVisionInfo.g_arrOrientROIs[0][1], m_smVisionInfo.g_arrOrientROIs[0][2], 2);  // Use FinalReduction=2 because match center point is not very important in MarkOrient Test.

                                //intAngle = m_smVisionInfo.g_arrOrients[0][intTemplateIndex].DoOrientationInspection_WithSubMatcher(
                                //    m_smVisionInfo.g_arrOrientROIs[0][0], 2, true, m_smVisionInfo.g_blnWantSubROI && (m_smVisionInfo.g_arrOrientROIs[0].Count > 2));  // Use FinalReduction=2 because match center point is not very important in MarkOrient Test.

                                //intAngle = m_smVisionInfo.g_arrOrients[0][intTemplateIndex].MatchWithTemplate(
                                //    m_smVisionInfo.g_arrOrientROIs[0][0], m_smVisionInfo.g_arrRotatedImages[0], true, fHighestScore, true, // false
                                //    m_smVisionInfo.g_blnWantSubROI && (m_smVisionInfo.g_arrOrientROIs[0].Count > 2));
                            }

                            if (m_smVisionInfo.g_arrOrients[0][intTemplateIndex].GetMinScore() > fHighestScore)
                            {
                                fHighestScore = m_smVisionInfo.g_fOrientScore[0] = m_smVisionInfo.g_arrOrients[0][intTemplateIndex].GetMinScore();
                                m_smVisionInfo.g_intSelectedOcv[0] = intTemplateIndex;
                                m_smVisionInfo.g_intOrientResult[0] = intAngle;

                            }
                        }
                    }
                    intMatchCount++;
              //} while (((fHighestScore < 0.8) && (intMatchCount < m_smVisionInfo.g_arrOrients[0].Count)) || !blnAngleResult); 
                } while (intMatchCount < m_smVisionInfo.g_arrOrients[0].Count);
            }

            Orient objOrient = m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]];

            m_smVisionInfo.g_fOrientCenterX[0] = objOrient.ref_fObjectX;
            m_smVisionInfo.g_fOrientCenterY[0] = objOrient.ref_fObjectY;
            m_smVisionInfo.g_fSubOrientCenterX[0] = objOrient.ref_fSubObjectX;
            m_smVisionInfo.g_fSubOrientCenterY[0] = objOrient.ref_fSubObjectY;
            m_smVisionInfo.g_fOrientScore[0] = objOrient.GetMinScore();
            m_smVisionInfo.g_fOrientAngle[0] = objOrient.ref_fDegAngleResult;
            m_smVisionInfo.g_blnViewOrientObject = true;

            if (m_blnWantMarkTest || m_blnWantLeadTest)
            {
                if (m_smVisionInfo.g_intOrientResult[0] < 4)
                {
                    // This corner position orientation checking will only do if Orientation is ON.
                    if (blnWantOrient && objOrient.ref_blnWantUsePositionCheckOrientation)
                    {
                        // 2020 11 20 - CCENG: Method 2 orientation
                        float fOrientationSeparatorX = (float)m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIWidth / 2;
                        float fOrientationSeparatorY = (float)m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIHeight / 2;

                        for (int m = 0; m < objOrient.ref_arrMatchScoreList.Count; m++)
                        {
                            if (m == m_smVisionInfo.g_intOrientResult[0])
                                continue;

                            if (objOrient.ref_arrMatchScoreList[m] >= objOrient.ref_fMinScore)
                            {
                                if (Math.Abs(objOrient.GetMinScore() - objOrient.ref_arrMatchScoreList[m]) < objOrient.ref_fCheckPositionOrientationWhenBelowDifferentScore)
                                {
                                    if (objOrient.ref_intDirections == 2)
                                    {
                                        bool blnSampleIsTop = objOrient.ref_fObjectY - fOrientationSeparatorY < 0;
                                        bool blnDirectionisTop = objOrient.ref_blnTemplateOrientationIsTop != blnSampleIsTop;

                                        if (blnDirectionisTop)            // rotate 180  from template point
                                        {
                                            m_smVisionInfo.g_intOrientResult[0] = 2;
                                        }
                                        else
                                        {
                                            m_smVisionInfo.g_intOrientResult[0] = 0;            // no rotate
                                        }
                                    }
                                    else
                                    {
                                        bool blnSampleIsLeft = objOrient.ref_fObjectX - fOrientationSeparatorX < 0;
                                        bool blnSampleIsTop = objOrient.ref_fObjectY - fOrientationSeparatorY < 0;

                                        bool blnDirectionIsLeft = objOrient.ref_blnTemplateOrientationIsLeft != blnSampleIsLeft;
                                        bool blnDirectionisTop = objOrient.ref_blnTemplateOrientationIsTop != blnSampleIsTop;

                                        if (blnDirectionIsLeft && blnDirectionisTop)            // rotate 180  from template point
                                        {
                                            m_smVisionInfo.g_intOrientResult[0] = 2;
                                        }
                                        else if (blnDirectionIsLeft && !blnDirectionisTop)      // rotate 90 ccw from template point
                                        {
                                            m_smVisionInfo.g_intOrientResult[0] = 1;            // show result angle 90 when rotate ccw from template point
                                        }
                                        else if (!blnDirectionIsLeft && blnDirectionisTop)      // rotate 90 cw from template point
                                        {
                                            m_smVisionInfo.g_intOrientResult[0] = 3;            // show result angle -90 when rotate cw from template point
                                        }
                                        else
                                        {
                                            m_smVisionInfo.g_intOrientResult[0] = 0;            // no rotate
                                        }
                                    }

                                    break;
                                }
                            }
                        }
                    }
                    // 2020 11 20 - CCENG: Method 1 orientation - Hide first because have Method 2 function to check orientatation
                    //if (objOrient.ref_fObjectOriX != -1 && objOrient.ref_fObjectOriY != -1 &&
                    //    (((m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROITotalCenterX + m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROIWidth / 2) < (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalCenterX)) &&
                    //    ((m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROITotalCenterY + m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROIHeight / 2) < (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalCenterY))) ||
                    //    (((m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROITotalCenterX - m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROIWidth / 2) > (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalCenterX)) &&
                    //    ((m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROITotalCenterY + m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROIHeight / 2) < (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalCenterY))) ||
                    //    (((m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROITotalCenterX + m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROIWidth / 2) < (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalCenterX)) &&
                    //    ((m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROITotalCenterY - m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROIHeight / 2) > (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalCenterY))) ||
                    //    (((m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROITotalCenterX - m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROIWidth / 2) > (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalCenterX)) &&
                    //    ((m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROITotalCenterY - m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROIHeight / 2) > (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalCenterY))))
                    //{
                    //    if ((m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROITotalCenterX < (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalCenterX)) && (m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROITotalCenterY > (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalCenterY)))
                    //    {
                    //        if ((m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalX + objOrient.ref_fObjectOriX < (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalCenterX)) && (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalY + objOrient.ref_fObjectOriY > (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalCenterY)))
                    //        {
                    //            m_smVisionInfo.g_intOrientResult[0] = 0;
                    //        }
                    //        else if ((m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalX + objOrient.ref_fObjectOriX < (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalCenterX)) && (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalY + objOrient.ref_fObjectOriY < (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalCenterY)))
                    //        {
                    //            m_smVisionInfo.g_intOrientResult[0] = 1;
                    //        }
                    //        else if ((m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalX + objOrient.ref_fObjectOriX > (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalCenterX)) && (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalY + objOrient.ref_fObjectOriY < (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalCenterY)))
                    //        {
                    //            m_smVisionInfo.g_intOrientResult[0] = 2;
                    //        }
                    //        else if ((m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalX + objOrient.ref_fObjectOriX > (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalCenterX)) && (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalY + objOrient.ref_fObjectOriY > (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalCenterY)))
                    //        {
                    //            m_smVisionInfo.g_intOrientResult[0] = 3;
                    //        }
                    //    }
                    //    else if ((m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROITotalCenterX < (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalCenterX)) && (m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROITotalCenterY < (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalCenterY)))
                    //    {
                    //        if ((m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalX + objOrient.ref_fObjectOriX < (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalCenterX)) && (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalY + objOrient.ref_fObjectOriY < (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalCenterY)))
                    //        {
                    //            m_smVisionInfo.g_intOrientResult[0] = 0;
                    //        }
                    //        else if ((m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalX + objOrient.ref_fObjectOriX > (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalCenterX)) && (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalY + objOrient.ref_fObjectOriY < (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalCenterY)))
                    //        {
                    //            m_smVisionInfo.g_intOrientResult[0] = 1;
                    //        }
                    //        else if ((m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalX + objOrient.ref_fObjectOriX > (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalCenterX)) && (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalY + objOrient.ref_fObjectOriY > (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalCenterY)))
                    //        {
                    //            m_smVisionInfo.g_intOrientResult[0] = 2;
                    //        }
                    //        else if ((m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalX + objOrient.ref_fObjectOriX < (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalCenterX)) && (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalY + objOrient.ref_fObjectOriY > (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalCenterY)))
                    //        {
                    //            m_smVisionInfo.g_intOrientResult[0] = 3;
                    //        }
                    //    }
                    //    else if ((m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROITotalCenterX > (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalCenterX)) && (m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROITotalCenterY < (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalCenterY)))
                    //    {
                    //        if ((m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalX + objOrient.ref_fObjectOriX > (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalCenterX)) && (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalY + objOrient.ref_fObjectOriY < (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalCenterY)))
                    //        {
                    //            m_smVisionInfo.g_intOrientResult[0] = 0;
                    //        }
                    //        else if ((m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalX + objOrient.ref_fObjectOriX > (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalCenterX)) && (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalY + objOrient.ref_fObjectOriY > (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalCenterY)))
                    //        {
                    //            m_smVisionInfo.g_intOrientResult[0] = 1;
                    //        }
                    //        else if ((m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalX + objOrient.ref_fObjectOriX < (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalCenterX)) && (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalY + objOrient.ref_fObjectOriY > (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalCenterY)))
                    //        {
                    //            m_smVisionInfo.g_intOrientResult[0] = 2;
                    //        }
                    //        else if ((m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalX + objOrient.ref_fObjectOriX < (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalCenterX)) && (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalY + objOrient.ref_fObjectOriY < (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalCenterY)))
                    //        {
                    //            m_smVisionInfo.g_intOrientResult[0] = 3;
                    //        }
                    //    }
                    //    else if ((m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROITotalCenterX > (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalCenterX)) && (m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROITotalCenterY > (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalCenterY)))
                    //    {
                    //        if ((m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalX + objOrient.ref_fObjectOriX > (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalCenterX)) && (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalY + objOrient.ref_fObjectOriY > (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalCenterY)))
                    //        {
                    //            m_smVisionInfo.g_intOrientResult[0] = 0;
                    //        }
                    //        else if ((m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalX + objOrient.ref_fObjectOriX < (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalCenterX)) && (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalY + objOrient.ref_fObjectOriY > (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalCenterY)))
                    //        {
                    //            m_smVisionInfo.g_intOrientResult[0] = 1;
                    //        }
                    //        else if ((m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalX + objOrient.ref_fObjectOriX < (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalCenterX)) && (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalY + objOrient.ref_fObjectOriY < (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalCenterY)))
                    //        {
                    //            m_smVisionInfo.g_intOrientResult[0] = 2;
                    //        }
                    //        else if ((m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalX + objOrient.ref_fObjectOriX > (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalCenterX)) && (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalY + objOrient.ref_fObjectOriY < (m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalCenterY)))
                    //        {
                    //            m_smVisionInfo.g_intOrientResult[0] = 3;
                    //        }
                    //    }
                    //}

                    // 2019 07 20 - CCENG: Not need to rotate image if want Orient 0 deg only
                    //if ((m_smCustomizeInfo.g_intWantOrient0Deg & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
                    if (((m_smCustomizeInfo.g_intWantOrient0Deg & (1 << m_smVisionInfo.g_intVisionPos)) > 0) ||
                        (!m_smVisionInfo.g_arrOrients[0][0].ref_blnWantCheckOrientation))
                    {
                        m_intOrientAngle = 0;
                    }
                    else
                    {
                        switch (m_smVisionInfo.g_intOrientResult[0])
                        {
                            default:
                            case 0:
                                m_intOrientAngle = 0;
                                break;
                            case 1:
                                m_intOrientAngle = 90;
                                break;
                            case 2:
                                m_intOrientAngle = 180;
                                break;
                            case 3:
                                m_intOrientAngle = -90;
                                break;
                        }
                    }

                    m_blnOrientDataUpdated = true;
                    ROI objRotatedROI = new ROI();
                    CROI objRotatedColorROI = new CROI();
                    float fTotalRotateAngle = 0;
                    if (m_smVisionInfo.g_blnWantGauge)
                    {
                        RectGaugeM4L objGauge = m_smVisionInfo.g_arrOrientGaugeM4L[0];

                        // Get Orient Center Point (Final result for next MarkTest and PackageTest)
                        m_smVisionInfo.g_fUnitCenterX[0] = objGauge.ref_pRectCenterPoint.X - m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalX;
                        m_smVisionInfo.g_fUnitCenterY[0] = objGauge.ref_pRectCenterPoint.Y - m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalY;

                        // Calculate total angle 
                        fTotalRotateAngle = m_intOrientAngle + objGauge.ref_fRectAngle;

                        // Get RotateROI where the ROI center point == Unit Center Point
                        objRotatedROI.AttachImage(m_smVisionInfo.g_arrImages[0]);

                        float fSizeX, fSizeY;
                        if ((objGauge.ref_fRectWidth + m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIWidth) > m_smVisionInfo.g_arrImages[0].ref_intImageWidth ||
                            (objGauge.ref_fRectHeight + m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIHeight) > m_smVisionInfo.g_arrImages[0].ref_intImageHeight)
                        {
                            fSizeX = m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIWidth - m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIWidth % 2; // why %2? To get "even" number
                            fSizeY = m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIHeight - m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIHeight % 2;
                        }
                        else
                        {
                            fSizeX = objGauge.ref_fRectWidth + m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIWidth - m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIWidth % 2; // why %2? To get "even" number
                            fSizeY = objGauge.ref_fRectHeight + m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIHeight - m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIHeight % 2;
                        }

                        objRotatedROI.LoadROISetting((int)Math.Round(objGauge.ref_pRectCenterPoint.X - fSizeX / 2, 0, MidpointRounding.AwayFromZero),
                                                     (int)Math.Round(objGauge.ref_pRectCenterPoint.Y - fSizeY / 2, 0, MidpointRounding.AwayFromZero),
                                                     (int)Math.Round(fSizeX, 0, MidpointRounding.AwayFromZero),
                                                     (int)Math.Round(fSizeY, 0, MidpointRounding.AwayFromZero));

                    }
                    else
                    {
                        // For Lead Unit Case
                        if (m_smVisionInfo.g_arrOrientROIs[0].Count > 3 &&
                           (((m_smCustomizeInfo.g_intWantPositioningIndex & (1 << m_smVisionInfo.g_intVisionPos)) > 0) ||
                           (((m_smCustomizeInfo.g_intWantLead & (1 << m_smVisionInfo.g_intVisionPos)) > 0) && m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedTemplate].ref_blnUnitPRMatcherExist)))    // Mean Unit Surface ROI exist
                        {
                            // Get Unit Surface Center Point (Final result for next MarkTest and PackageTest)
                            m_smVisionInfo.g_fUnitCenterX[0] = fUnitPRResultCenterX + fUnitSurfaceOffsetX;
                            m_smVisionInfo.g_fUnitCenterY[0] = fUnitPRResultCenterY + fUnitSurfaceOffsetY;

                            // Calculate total angle 
                            fTotalRotateAngle = m_intOrientAngle + fUnitPRResultAngle;

                            // Get RotateROI where the ROI center point == Unit Center Point
                            objRotatedROI.AttachImage(m_smVisionInfo.g_arrImages[0]);

                            float fSizeX, fSizeY;
                            fSizeX = m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIWidth - m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIWidth % 2; // why %2? To get "even" number
                            fSizeY = m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIHeight - m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIHeight % 2;

                            objRotatedROI.LoadROISetting(m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalX +
                                                            (int)Math.Round(m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedTemplate].GetUnitPRResultCenterX() -
                                                            fSizeX / 2 +
                                                            m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedTemplate].ref_intUnitSurfaceOffsetX, 0, MidpointRounding.AwayFromZero),
                                                         m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalY +
                                                            (int)Math.Round(m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedTemplate].GetUnitPRResultCenterY() -
                                                            fSizeY / 2 +
                                                            m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedTemplate].ref_intUnitSurfaceOffsetY, 0, MidpointRounding.AwayFromZero),
                                                         (int)Math.Round(fSizeX, 0, MidpointRounding.AwayFromZero),
                                                         (int)Math.Round(fSizeY, 0, MidpointRounding.AwayFromZero));
                        }
                        else // For No Lead Case
                        {
                            // Calculate total angle 
                            fTotalRotateAngle = m_intOrientAngle + m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_fDegAngleResult;

                            // Get RotateROI where the ROI center point == Unit Center Point
                            objRotatedROI.AttachImage(m_smVisionInfo.g_arrImages[0]);

                            float fSizeX, fSizeY;
                            fSizeX = m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIWidth - m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIWidth % 2; // why %2? To get "even" number
                            fSizeY = m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIHeight - m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIHeight % 2;

                            if (m_blnWantPackageTest && ((m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailMask & 0x1000) > 0 || m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetWantInspectPackage() || GetWantInspectPackageColor(m_smVisionInfo.g_intSelectedUnit))) // 2020-06-23 ZJYEOH : If inspection option got tick Check package size just can use pkg gauge
                            {
                                WaitEventDone(ref m_bPackageSizePreTestDone, true, 10000, "StartOrientTest > m_bPackageSizePreTestDone");

                                if (m_bPackageSizePreTestResult)
                                {
                                    // Get RotateROI center point where the ROI center point == Package Unit Center Point
                                    objRotatedROI.LoadROISetting((int)Math.Round(m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X - fSizeX / 2, 0, MidpointRounding.AwayFromZero),
                                                                 (int)Math.Round(m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y - fSizeY / 2, 0, MidpointRounding.AwayFromZero),
                                                                 (int)Math.Round(fSizeX, 0, MidpointRounding.AwayFromZero),
                                                                 (int)Math.Round(fSizeY, 0, MidpointRounding.AwayFromZero));

                                    // 2020 03 03 - CCENG: Enable this command to use package angle instead of mark angle. 
                                    // 2020 05 02 - No longer need this feature because mark and package angle are separated to different images.
                                    //if (m_smVisionInfo.g_blnWantRotateMarkImageUsingPkgAngle)
                                    //    fTotalRotateAngle = m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle; // 2020 04 19 - Should add m_intOrientAngle? 
                                }
                                else
                                {
                                    objRotatedROI.LoadROISetting((int)Math.Round(m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalCenterX - fSizeX / 2, 0, MidpointRounding.AwayFromZero),
                                                                (int)Math.Round(m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalCenterY - fSizeY / 2, 0, MidpointRounding.AwayFromZero),
                                                                (int)Math.Round(fSizeX, 0, MidpointRounding.AwayFromZero),
                                                                (int)Math.Round(fSizeY, 0, MidpointRounding.AwayFromZero));
                                }
                            }
                            else
                            {
                                // 2019 09 06 - CCENG: If no package size center point, then use Orient Search ROI Center Point
                                objRotatedROI.LoadROISetting((int)Math.Round(m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalCenterX - fSizeX / 2, 0, MidpointRounding.AwayFromZero),
                                                             (int)Math.Round(m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalCenterY - fSizeY / 2, 0, MidpointRounding.AwayFromZero),
                                                             (int)Math.Round(fSizeX, 0, MidpointRounding.AwayFromZero),
                                                             (int)Math.Round(fSizeY, 0, MidpointRounding.AwayFromZero));

                            }
                        }
                    }

                    // Start Rotate image 1 to zero orientation and zero angle degree.
                    // 2020 05 02 - Rotate image to package 0 deg

                    if (m_blnWantPackageTest && ((m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailMask & 0x1000) > 0 || m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetWantInspectPackage() || GetWantInspectPackageColor(m_smVisionInfo.g_intSelectedUnit))) // 2020-06-23 ZJYEOH : If inspection option got tick Check package size just can use pkg gauge
                    {
                        //2020-11-07 ZJYEOH : Need to wait package gauge measure finish just can take the angle 
                        WaitEventDone(ref m_bPackageSizePreTestDone, true, 10000, "StartOrientTest > m_bPackageSizePreTestDone2");

                        if (m_bPackageSizePreTestResult)
                        {
                            // 2020-06-25 ZJYEOH : Need to include Orient angle and package gauge angle for MOPkg, MarkPkg will not affected as Orient angle will always be 0
                            ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[0], objRotatedROI, m_intOrientAngle + m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle, m_smVisionInfo.g_intRotationInterpolation_Mark, ref m_smVisionInfo.g_arrRotatedImages, 0);

                            if (m_blnCustomWantColor && !GetColorImageRotated(0) && !ContainColorSelectedImage(0, m_smVisionInfo.g_intSelectedUnit))
                            {
                                CROI objColorRotatedROI = new CROI();
                                objColorRotatedROI.AttachImage(m_smVisionInfo.g_arrColorImages[0]);

                                // Get RotateROI center point where the ROI center point == Package Unit Center Point
                                objColorRotatedROI.LoadROISetting(objRotatedROI.ref_ROIPositionX,
                                                             objRotatedROI.ref_ROIPositionY,
                                                             objRotatedROI.ref_ROIWidth,
                                                             objRotatedROI.ref_ROIHeight);

                                CROI.Rotate0Degree(m_smVisionInfo.g_arrColorImages[0], objColorRotatedROI, m_intOrientAngle + m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle, 4, ref m_smVisionInfo.g_arrColorRotatedImages, 0);

                                SetColorImageRotated(0);
                                objColorRotatedROI.Dispose();
                            }

                        }
                        else
                        {
                            ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[0], objRotatedROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_Mark, ref m_smVisionInfo.g_arrRotatedImages, 0);

                            if (m_blnCustomWantColor && !GetColorImageRotated(0) && !ContainColorSelectedImage(0, m_smVisionInfo.g_intSelectedUnit))
                            {
                                CROI objColorRotatedROI = new CROI();
                                objColorRotatedROI.AttachImage(m_smVisionInfo.g_arrColorImages[0]);

                                // Get RotateROI center point where the ROI center point == Package Unit Center Point
                                objColorRotatedROI.LoadROISetting(objRotatedROI.ref_ROIPositionX,
                                                             objRotatedROI.ref_ROIPositionY,
                                                             objRotatedROI.ref_ROIWidth,
                                                             objRotatedROI.ref_ROIHeight);

                                CROI.Rotate0Degree(m_smVisionInfo.g_arrColorImages[0], objColorRotatedROI, fTotalRotateAngle, 4, ref m_smVisionInfo.g_arrColorRotatedImages, 0);

                                SetColorImageRotated(0);
                                objColorRotatedROI.Dispose();
                            }
                        }
                    }
                    else
                    {
                        ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[0], objRotatedROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_Mark, ref m_smVisionInfo.g_arrRotatedImages, 0);

                        if (m_blnCustomWantColor && !GetColorImageRotated(0) && !ContainColorSelectedImage(0, m_smVisionInfo.g_intSelectedUnit))
                        {
                            CROI objColorRotatedROI = new CROI();
                            objColorRotatedROI.AttachImage(m_smVisionInfo.g_arrColorImages[0]);

                            // Get RotateROI center point where the ROI center point == Package Unit Center Point
                            objColorRotatedROI.LoadROISetting(objRotatedROI.ref_ROIPositionX,
                                                         objRotatedROI.ref_ROIPositionY,
                                                         objRotatedROI.ref_ROIWidth,
                                                         objRotatedROI.ref_ROIHeight);

                            CROI.Rotate0Degree(m_smVisionInfo.g_arrColorImages[0], objColorRotatedROI, fTotalRotateAngle, 4, ref m_smVisionInfo.g_arrColorRotatedImages, 0);

                            SetColorImageRotated(0);
                            objColorRotatedROI.Dispose();
                        }
                    }
                    m_blnRotateImage1Updated = true;

                    //if (m_blnWantPackageTest && ((m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailMask & 0x1000) > 0)) // 2020-06-23 ZJYEOH : If inspection option got tick Check package size just can use pkg gauge
                    //{
                    //    //2020-11-07 ZJYEOH : Need to wait package gauge measure finish just can take the angle 
                    //    WaitEventDone(ref m_bPackageSizePreTestDone, true, 10000, "StartOrientTest > m_bPackageSizePreTestDone2");

                    //    if (m_bPackageSizePreTestResult)
                    //    {
                    //        for (int i = 0; i < m_smVisionInfo.g_arrRotatedImages.Count; i++)
                    //        {
                    //            // 2020-06-25 ZJYEOH : Need to include Orient angle and package gauge angle for MOPkg, MarkPkg will not affected as Orient angle will always be 0
                    //            ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[i], objRotatedROI, m_intOrientAngle + m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle, m_smVisionInfo.g_intRotationInterpolation_Mark, ref m_smVisionInfo.g_arrRotatedImages, i);
                    //        }
                    //    }
                    //    else
                    //    {
                    //        for (int i = 0; i < m_smVisionInfo.g_arrRotatedImages.Count; i++)
                    //        {
                    //            ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[i], objRotatedROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_Mark, ref m_smVisionInfo.g_arrRotatedImages, i);
                    //        }
                    //    }
                    //}
                    //else
                    //{
                    //    for (int i = 0; i < m_smVisionInfo.g_arrRotatedImages.Count; i++)
                    //    {
                    //        ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[i], objRotatedROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_Mark, ref m_smVisionInfo.g_arrRotatedImages, i);
                    //    }
                    //}

                    //m_blnRotateImage1Updated = true;
                    //m_blnRotateImage2Updated = true;
                    //m_blnRotateImage3Updated = true;

                    // 2020 04 19 - cceng: Rotate image to mark 0 deg
                    ROI.Rotate0Degree_Better(m_smVisionInfo.g_arrImages[0], objRotatedROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_Mark, ref m_smVisionInfo.g_objMarkImage);

                    m_fOrientTotalRotateAngle = fTotalRotateAngle;
                    m_pOrientRotateStartPoint = new Point(objRotatedROI.ref_ROIPositionX, objRotatedROI.ref_ROIPositionY);
                    m_pOrientRotateSize = new Size(objRotatedROI.ref_ROIWidth, objRotatedROI.ref_ROIHeight);

                    //if (m_blnWantLeadTest)
                    //{
                    //    if (m_smVisionInfo.g_arrImages.Count > m_smVisionInfo.g_arrLead[0].ref_intImageViewNo)
                    //    {
                    //        ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo], objRotatedROI, fTotalRotateAngle, ref m_smVisionInfo.g_arrRotatedImages, m_smVisionInfo.g_arrLead[0].ref_intImageViewNo);
                    //        if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 0)
                    //            m_blnRotateImage1Updated = true;
                    //        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 1)
                    //            m_blnRotateImage2Updated = true;
                    //        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 2)
                    //            m_blnRotateImage3Updated = true;
                    //        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 3)
                    //            m_blnRotateImage4Updated = true;
                    //        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 4)
                    //            m_blnRotateImage5Updated = true;
                    //    }
                    //}

                    m_fOrientFinalAngleForLead = fTotalRotateAngle - m_intOrientAngle; //2020-07-23 ZJYEOH: For later use in Lead function
                    objRotatedROI.Dispose();
                    objRotatedColorROI.Dispose();
                }
                else
                {
                    m_smVisionInfo.g_arrImages[0].CopyTo(m_smVisionInfo.g_objMarkImage);
                }
            }
            else
            {
                m_smVisionInfo.g_fOrientCenterX[0] = m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_fObjectX;
                m_smVisionInfo.g_fOrientCenterY[0] = m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_fObjectY;
            }

            bool blnFailAngle = false;
            bool blnFailPosition = false;
            if ((m_smCustomizeInfo.g_intWantBottom & (1 << m_smVisionInfo.g_intVisionPos)) > 0 && m_smVisionInfo.g_intOrientResult[0] != 4)
            {
                float fAngleResult = Math.Abs(m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_fDegAngleResult); //GetResultAngle()
                float CenterX = 0;
                float CenterY = 0;
                float fXAfterRotated = 0;
                float fYAfterRotated = 0;
                float fCenterXDiff = 0;
                float fCenterYDiff = 0;

                //     if (m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_intRotatedAngle == 90 )
                //     {
                //         CenterX = (float)(m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIWidth) / 2;
                //         CenterY = (float)(m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIHeight) / 2;
                //         fXAfterRotated = (float)((CenterX) - ((m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_fTemplateX - CenterX) * Math.Cos(m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_intRotatedAngle * Math.PI / 180)) +
                //((m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_fTemplateY - CenterY) * Math.Sin(m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_intRotatedAngle * Math.PI / 180)));
                //         fYAfterRotated = (float)((CenterY) - ((m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_fTemplateX - CenterX) * Math.Sin(m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_intRotatedAngle * Math.PI / 180)) -
                //          ((m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_fTemplateY - CenterY) * Math.Cos(m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_intRotatedAngle * Math.PI / 180)));
                //         fCenterXDiff = Math.Abs(fXAfterRotated - m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_fObjectX);// m_smVisionInfo.g_fOrientCenterX[0];
                //         fCenterYDiff = Math.Abs(fYAfterRotated - m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_fObjectY);// m_smVisionInfo.g_fOrientCenterY[0];
                //     }
                //     else if (m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_intRotatedAngle == 270)
                //     {
                //         CenterX = (float)(m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIWidth) / 2;
                //         CenterY = (float)(m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIHeight) / 2;
                //         fXAfterRotated = (float)((CenterX) + ((m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_fTemplateX - CenterX) * Math.Cos(m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_intRotatedAngle * Math.PI / 180)) -
                //((m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_fTemplateY - CenterY) * Math.Sin(m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_intRotatedAngle * Math.PI / 180)));
                //         fYAfterRotated = (float)((CenterY) + ((m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_fTemplateX - CenterX) * Math.Sin(m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_intRotatedAngle * Math.PI / 180)) +
                //          ((m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_fTemplateY - CenterY) * Math.Cos(m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_intRotatedAngle * Math.PI / 180)));
                //         fCenterXDiff = Math.Abs(fXAfterRotated - m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_fObjectX);// m_smVisionInfo.g_fOrientCenterX[0];
                //         fCenterYDiff = Math.Abs(fYAfterRotated - m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_fObjectY);// m_smVisionInfo.g_fOrientCenterY[0];
                //     }
                //     else
                //     {
                //         CenterX = m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalX + (float)(m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIWidth) / 2; //(float)(m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIWidth) / 2;
                //         CenterY = m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalY + (float)(m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIHeight) / 2;// (float)(m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIHeight) / 2;
                //                                                                                                                                        //2020-09-24 ZJYEOH : Should use current angle to rotate template center point because when get center point different, the object center point is based on current angle
                //         fXAfterRotated = (float)((CenterX) + ((m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_fTemplateX - CenterX) * Math.Cos(m_intOrientAngle * Math.PI / 180)) - //m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_intRotatedAngle
                //((m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_fTemplateY - CenterY) * Math.Sin(m_intOrientAngle * Math.PI / 180)));
                //         fYAfterRotated = (float)((CenterY) + ((m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_fTemplateX - CenterX) * Math.Sin(m_intOrientAngle * Math.PI / 180)) +
                //          ((m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_fTemplateY - CenterY) * Math.Cos(m_intOrientAngle * Math.PI / 180)));
                fXAfterRotated = m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_fTemplateX;
                fYAfterRotated = m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_fTemplateY;

                fCenterXDiff = m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].GetCenterXDiff(fXAfterRotated, m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalX);// m_smVisionInfo.g_fOrientCenterX[0];
                fCenterYDiff = m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].GetCenterYDiff(fYAfterRotated, m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalY);// m_smVisionInfo.g_fOrientCenterY[0];
                                                                                                                                                                                     // }

                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                {
                    m_fOffsetX = fCenterXDiff;
                    m_fOffsetY = fCenterYDiff;
                    m_fOffsetAngle = fAngleResult;
                }

                if (m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_blnWantCheckOrientAngleTolerance)
                {
                    if (m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_fAngleTolerance <= fAngleResult)
                    {
                        m_smVisionInfo.g_intOrientResult[0] = 4;
                        m_smVisionInfo.g_strErrorMessage += "*Fail Orient Angle Tolerance : Set = " + m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_fAngleTolerance.ToString("f4") +
                            " , Result = " + fAngleResult.ToString("f4");
                        blnFailAngle = true;
                    }
                }
                if (m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_blnWantCheckOrientXTolerance)
                {
                    if (Math.Abs(fCenterXDiff) >= m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_fXTolerance)
                    {
                        m_smVisionInfo.g_intOrientResult[0] = 4;
                        m_smVisionInfo.g_strErrorMessage += "*Fail Orient X Tolerance : Set = " + m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_fXTolerance.ToString("f4") +
                            " , Result = " + fCenterXDiff.ToString("f4");
                        blnFailPosition = true;
                    }
                }
                if (m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_blnWantCheckOrientYTolerance)
                {
                    if (Math.Abs(fCenterYDiff) >= m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_fYTolerance)
                    {
                        m_smVisionInfo.g_intOrientResult[0] = 4;
                        m_smVisionInfo.g_strErrorMessage += "*Fail Orient Y Tolerance : Set = " + m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_fYTolerance.ToString("f4") +
                            " , Result = " + fCenterYDiff.ToString("f4");
                        blnFailPosition = true;
                    }
                }
            }

            if (m_smVisionInfo.g_blnWantCheckMarkAngle)
            {
                int intFailMask = m_smVisionInfo.g_arrMarks[0].GetFailOptionMask(0, m_smVisionInfo.g_intSelectedOcv[0]);
                if ((intFailMask & 0x2000) > 0)   // 0x2000=Mark Angle
                {
                    if (m_smVisionInfo.g_intOrientResult[0] < 4)    // Will only check Mark Angle if Orientation Pass
                    {
                        if (m_blnWantPackageTest && ((m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailMask & 0x1000) > 0 || m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetWantInspectPackage() || GetWantInspectPackageColor(m_smVisionInfo.g_intSelectedUnit))) // 2020-06-23 ZJYEOH : If inspection option got tick Check package size just can use pkg gauge
                        {
                            WaitEventDone(ref m_bPackageSizePreTestDone, true, 10000, "StartOrientTest > m_bPackageSizePreTestDone3");

                            if (m_bPackageSizePreTestResult)
                                m_smVisionInfo.g_fOrientAngle[0] = m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle - m_smVisionInfo.g_fOrientAngle[0];

                            if (Math.Abs(m_smVisionInfo.g_fOrientAngle[0]) > m_smVisionInfo.g_arrMarks[0].GetMarkAngleTolerance(0, m_smVisionInfo.g_intSelectedOcv[0]))
                            {
                                m_smVisionInfo.g_strErrorMessage += "*Fail Mark Angle : Set = " +
                                                                m_smVisionInfo.g_arrMarks[0].GetMarkAngleTolerance(0, m_smVisionInfo.g_intSelectedOcv[0]).ToString("f4") +
                                                                " , Result = " + m_smVisionInfo.g_fOrientAngle[0].ToString("f4");
                                m_smVisionInfo.g_arrMarks[0].ref_intTemplateIndex = m_smVisionInfo.g_intSelectedOcv[0];

                                m_smVisionInfo.g_blnMarkInspected = true;
                                //2021-01-04 ZJYEOH : increase angle fail counter and save fail angle image if in production mode
                                if (blnAuto)
                                {
                                    m_smVisionInfo.g_intAngleFailureTotal++;
                                    SaveRejectImage_AddToBuffer("Angle", m_smVisionInfo.g_strErrorMessage);
                                }

                                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                                    if (m_intTCPIPResultID == -1)
                                        m_intTCPIPResultID = (int)TCPIPResulID.FailMark;

                                return false;
                            }
                        }
                        else
                        {
                            if (!m_arrFinalPreciseAnglePass[m_smVisionInfo.g_intSelectedOcv[0]])  // Check selected Orient have precise angle pass or not
                            {
                                m_smVisionInfo.g_strErrorMessage += "*Fail Mark Angle : Set = " +
                                                                m_smVisionInfo.g_arrMarks[0].GetMarkAngleTolerance(0, m_smVisionInfo.g_intSelectedOcv[0]).ToString("f4") +
                                                                " , Result = " + m_smVisionInfo.g_fOrientAngle[0].ToString("f4");
                                m_smVisionInfo.g_arrMarks[0].ref_intTemplateIndex = m_smVisionInfo.g_intSelectedOcv[0];

                                m_smVisionInfo.g_blnMarkInspected = true;
                                //2021-01-04 ZJYEOH : increase angle fail counter and save fail angle image if in production mode
                                if (blnAuto)
                                {
                                    m_smVisionInfo.g_intAngleFailureTotal++;
                                    SaveRejectImage_AddToBuffer("Angle", m_smVisionInfo.g_strErrorMessage);
                                }

                                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                                    if (m_intTCPIPResultID == -1)
                                        m_intTCPIPResultID = (int)TCPIPResulID.FailMark;

                                return false;
                            }
                        }
                    }
                }
            }

            //if (m_objVisionIO.OrientResult1 == null && m_smVisionInfo.g_intOrientResult[0] != 0)    // 2019 04 10 - CCENG: For Mark without Orient (e.g SRM-Mark, SRM-MarkPkg). Fail if g_intOrientResult not 0.
            //if (((m_smCustomizeInfo.g_intWantOrient0Deg & (1 << m_smVisionInfo.g_intVisionPos)) > 0) && m_smVisionInfo.g_intOrientResult[0] != 0)
            if ((((m_smCustomizeInfo.g_intWantOrient0Deg & (1 << m_smVisionInfo.g_intVisionPos)) > 0) || 
                (!m_smVisionInfo.g_arrOrients[0][0].ref_blnWantCheckOrientation)) && 
                m_smVisionInfo.g_intOrientResult[0] != 0)
            {
                //if (!blnFailAngle)
                //{
                //    m_smVisionInfo.g_intOrientResult[0] = 4;
                //    m_smVisionInfo.g_strErrorMessage += "*Fail Orient Angle Tolerance : Set = " + m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_fAngleTolerance.ToString("f4") +
                //        " , Result = " + 0.ToString("f4");
                //    blnFailAngle = true;
                //}
                return true;
                //if (blnAuto)
                //{
                //    m_smVisionInfo.g_intMarkFailureTotal++;
                //    SaveRejectImage_AddToBuffer("Mark");
                //}

                //if (m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_strErrorMessage == "" )
                //{
                //    m_smVisionInfo.g_strErrorMessage += "*Fail Mark!";
                //}
                //else
                //{
                //    m_smVisionInfo.g_strErrorMessage = m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_strErrorMessage;
                //}
                //return false;
            }
            else if (((!m_smCustomizeInfo.g_blnWantUseTCPIPIO && m_objVisionIO.OrientResult1 != null) || m_smCustomizeInfo.g_blnWantUseTCPIPIO) && m_smVisionInfo.g_intOrientResult[0] == 4)
            {
                if ((m_smCustomizeInfo.g_intWantBottom & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
                {
                    if (blnAuto)
                    {
                        if (m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_strErrorMessage == "" && m_smVisionInfo.g_strErrorMessage == "")
                        {
                            m_smVisionInfo.g_strErrorMessage = "*Recipe is corrupted. Please relearn.";
                        }
                        else
                        {
                            m_smVisionInfo.g_strErrorMessage += "*" + m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_strErrorMessage;
                        }

                        if (blnFailAngle)
                        {
                            m_smVisionInfo.g_intAngleFailureTotal++;
                            SaveRejectImage_AddToBuffer("Angle", m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_strErrorMessage);
                        }
                        else if (blnFailPosition)
                        {
                            m_smVisionInfo.g_intPositionFailureTotal++;
                            SaveRejectImage_AddToBuffer("Position", m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_strErrorMessage);
                        }
                        else
                        {
                            m_smVisionInfo.g_intOrientFailureTotal++;
                            SaveRejectImage_AddToBuffer("Orient", m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_strErrorMessage);
                        }
                    }
                }
                else
                {
                    if (m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_strErrorMessage == "" && m_smVisionInfo.g_strErrorMessage == "")
                    {
                        m_smVisionInfo.g_strErrorMessage = "*Recipe is corrupted. Please relearn.";
                    }
                    else
                    {
                        m_smVisionInfo.g_strErrorMessage += "*" + m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_strErrorMessage;   // 2021 03 11 - Add * to make sure message go to next line.
                    }

                    if (blnAuto)
                    {
                        m_smVisionInfo.g_intOrientFailureTotal++;
                        SaveRejectImage_AddToBuffer("Orient", m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_strErrorMessage);
                    }
                }

                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        m_intTCPIPResultID = (int)TCPIPResulID.Fail;

                return false;
            }
            else if (m_smVisionInfo.g_intOrientResult[0] > 0 && ((!m_smCustomizeInfo.g_blnWantUseTCPIPIO && m_objVisionIO.OrientResult1 != null && m_objVisionIO.OrientResult2 != null)) || m_smCustomizeInfo.g_blnWantUseTCPIPIO)
            {
                switch (m_smVisionInfo.g_intOrientResult[0])
                {
                    case 1:
                        if (m_smCustomizeInfo.g_intOrientIO == 0)
                        {
                            if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                            {
                                m_blnOrientResult1_Out = false;
                                m_blnOrientResult2_Out = true;
                            }
                            else
                            {
                                m_objVisionIO.OrientResult1.SetOff(strTrackHeadName + " OrientResult1 3"); if (m_smVisionInfo.g_blnTrackIO) STTrackLog.WriteLine("IO-OrientResult1-Set OFF 15");
                                m_objVisionIO.OrientResult2.SetOn(strTrackHeadName + " OrientResult1 4"); if (m_smVisionInfo.g_blnTrackIO) STTrackLog.WriteLine("IO-OrientResult2-Set ON 16");
                            }
                        }
                        else
                        {
                            if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                            {
                                m_blnOrientResult1_Out = true;
                                m_blnOrientResult2_Out = false;
                            }
                            else
                            {
                                m_objVisionIO.OrientResult1.SetOn(strTrackHeadName + " OrientResult1 3"); if (m_smVisionInfo.g_blnTrackIO) STTrackLog.WriteLine("IO-OrientResult1-Set ON 17");
                                m_objVisionIO.OrientResult2.SetOff(strTrackHeadName + " OrientResult1 4"); if (m_smVisionInfo.g_blnTrackIO) STTrackLog.WriteLine("IO-OrientResult2-Set OFF 18");
                            }
                        }
                        break;
                    case 2:
                        if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        {
                            m_blnOrientResult1_Out = true;
                            m_blnOrientResult2_Out = true;
                        }
                        else
                        {
                            m_objVisionIO.OrientResult1.SetOn(strTrackHeadName + " OrientResult1 5"); if (m_smVisionInfo.g_blnTrackIO) STTrackLog.WriteLine("IO-OrientResult1-Set ON 19");
                            m_objVisionIO.OrientResult2.SetOn(strTrackHeadName + " OrientResult2 6"); if (m_smVisionInfo.g_blnTrackIO) STTrackLog.WriteLine("IO-OrientResult2-Set ON 20");
                        }
                        break;
                    case 3:
                        if (m_smCustomizeInfo.g_intOrientIO == 0)
                        {
                            if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                            {
                                m_blnOrientResult1_Out = true;
                                m_blnOrientResult2_Out = false;
                            }
                            else
                            {
                                m_objVisionIO.OrientResult1.SetOn(strTrackHeadName + " OrientResult1 7"); if (m_smVisionInfo.g_blnTrackIO) STTrackLog.WriteLine("IO-OrientResult1-Set ON 21");
                                m_objVisionIO.OrientResult2.SetOff(strTrackHeadName + " OrientResult2 8"); if (m_smVisionInfo.g_blnTrackIO) STTrackLog.WriteLine("IO-OrientResult2-Set OFF 22");
                            }
                        }
                        else
                        {
                            if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                            {
                                m_blnOrientResult1_Out = false;
                                m_blnOrientResult2_Out = true;
                            }
                            else
                            {
                                m_objVisionIO.OrientResult1.SetOff(strTrackHeadName + " OrientResult1 7"); if (m_smVisionInfo.g_blnTrackIO) STTrackLog.WriteLine("IO-OrientResult1-Set OFF 23");
                                m_objVisionIO.OrientResult2.SetOn(strTrackHeadName + " OrientResult2 8"); if (m_smVisionInfo.g_blnTrackIO) STTrackLog.WriteLine("IO-OrientResult2-Set ON 24");
                            }
                        }
                        break;
                }
            }
            return true;
        }

        private bool StartBottomOrientTest(bool blnAuto)
        {
            if ((m_smCustomizeInfo.g_intWantOrient & (1 << m_smVisionInfo.g_intVisionPos)) == 0)
                return true;

            // Reset orientation IO
            if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
            {
                m_blnOrientResult1_Out = false;
                m_blnOrientResult2_Out = false;
            }
            else
            {
                if (m_objVisionIO.OrientResult1 != null)
                    m_objVisionIO.OrientResult1.SetOff(strTrackHeadName + " OrientResult1 1"); if (m_smVisionInfo.g_blnTrackIO) STTrackLog.WriteLine("IO-OrientResult1-Set OFF 25");
                if (m_objVisionIO.OrientResult2 != null)
                    m_objVisionIO.OrientResult2.SetOff(strTrackHeadName + " OrientResult2 2"); if (m_smVisionInfo.g_blnTrackIO) STTrackLog.WriteLine("IO-OrientResult2-Set OFF 26");
            }
            // make sure template learn
            if (m_smVisionInfo.g_arrOrients[0].Count == 0)
            {
                m_smVisionInfo.g_strErrorMessage += "*Orient : No Template Found";
                if (blnAuto)
                    m_smVisionInfo.g_intNoTemplateFailureTotal++;

                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        m_intTCPIPResultID = (int)TCPIPResulID.Fail;

                return false;
            }

            // reset all inspection data
            for (int i = 0; i < m_smVisionInfo.g_arrOrients[0].Count; i++)
            {
                ((Orient)m_smVisionInfo.g_arrOrients[0][i]).ResetInspectionData();
            }
            m_smVisionInfo.g_arrImages[0].CopyTo(m_smVisionInfo.g_arrRotatedImages[0]);
            m_smVisionInfo.g_intOrientResult[0] = -1;  // 0:0deg, 1:90deg, 2:180deg, 3:-90, 4:Fail
            m_smVisionInfo.g_arrOrientROIs[0][0].AttachImage(m_smVisionInfo.g_arrRotatedImages[0]);

            int intAngle = m_smVisionInfo.g_arrOrients[0][0].DoOrientationInspection_WithSubMatcher4(m_smVisionInfo.g_arrRotatedImages[0],
                        //m_smVisionInfo.g_arrOrientROIs[0][0], m_smVisionInfo.g_arrOrientROIs[0][1], m_smVisionInfo.g_arrOrientROIs[0][2], 2);  // Use FinalReduction=2 because match center point is not very important in MarkOrient Test.
                        m_smVisionInfo.g_arrOrientROIs[0][0], m_smVisionInfo.g_arrOrientROIs[0][1], m_smVisionInfo.g_arrOrientROIs[0][2], 1);  // 2020 01 08 - CCENG: Change from 2 to 1 bcos for unit 0603 pattern, angle not enough precise if FinalReduction is 2.

            if (m_smVisionInfo.g_strVisionName.Contains("BottomPosition")) //limit to unit ROI surround area, use search ROI to match always fail 
            {
                ROI temp = new ROI();
                temp.LoadROISetting(m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIPositionX + m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROIPositionX - 30, m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIPositionY + m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROIPositionY - 10, m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROIWidth + 60, m_smVisionInfo.g_arrOrientROIs[0][1].ref_ROIHeight + 20);
                intAngle = m_smVisionInfo.g_arrOrients[0][0].DoOrientationInspection_WithSubMatcher4(m_smVisionInfo.g_arrRotatedImages[0],
                           temp, m_smVisionInfo.g_arrOrientROIs[0][1], m_smVisionInfo.g_arrOrientROIs[0][2], 1);
            }

            m_smVisionInfo.g_fOrientScore[0] = m_smVisionInfo.g_arrOrients[0][0].GetMinScore();
            m_smVisionInfo.g_intSelectedOcv[0] = 0;
            m_smVisionInfo.g_intOrientResult[0] = intAngle;
            m_smVisionInfo.g_intOrientResult[1] = intAngle; //2020-09-24 ZJYEOH : Temporary store inside second index fot later use because 1st index will set to 4 when fail angle or position

            int intOrientAngle = 0;
            if (m_smVisionInfo.g_intOrientResult[0] < 4)
            {
                switch (m_smVisionInfo.g_intOrientResult[0])
                {
                    default:
                    case 0:
                        intOrientAngle = 0;
                        break;
                    case 1:
                        intOrientAngle = 90;
                        break;
                    case 2:
                        intOrientAngle = 180;
                        break;
                    case 3:
                        intOrientAngle = -90;
                        break;
                }

            }
            Orient objOrient = m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]];

            m_smVisionInfo.g_fOrientCenterX[0] = objOrient.ref_fObjectX;
            m_smVisionInfo.g_fOrientCenterY[0] = objOrient.ref_fObjectY;
            m_smVisionInfo.g_fSubOrientCenterX[0] = objOrient.ref_fSubObjectX;
            m_smVisionInfo.g_fSubOrientCenterY[0] = objOrient.ref_fSubObjectY;
            m_smVisionInfo.g_fOrientScore[0] = objOrient.GetMinScore();
            m_smVisionInfo.g_fOrientAngle[0] = objOrient.ref_fDegAngleResult;
            m_smVisionInfo.g_blnViewOrientObject = true;

            m_smVisionInfo.g_fOrientCenterX[0] = m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_fObjectX;
            m_smVisionInfo.g_fOrientCenterY[0] = m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_fObjectY;

            bool blnFailAngle = false;
            bool blnFailPosition = false;
            if (m_smVisionInfo.g_intOrientResult[0] != 4 &&
                m_smVisionInfo.g_fOrientScore[0] >= 0)
            {
                float fAngleResult = Math.Abs(m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_fDegAngleResult); //GetResultAngle()
                float CenterX = 0;
                float CenterY = 0;
                float fXAfterRotated = m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_fTemplateX;
                float fYAfterRotated = m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_fTemplateY;
                float fCenterXDiff = 0;
                float fCenterYDiff = 0;

                //CenterX = m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalX + (float)(m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIWidth) / 2;// (float)(m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIWidth) / 2;
                //CenterY = m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalY + (float)(m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIHeight) / 2; //(float)(m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIHeight) / 2;

                //fXAfterRotated = (float)((CenterX) + ((m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_fTemplateX - CenterX) * Math.Cos(intOrientAngle * Math.PI / 180)) -//m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_intRotatedAngle
                //                   ((m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_fTemplateY - CenterY) * Math.Sin(intOrientAngle * Math.PI / 180)));
                //fYAfterRotated = (float)((CenterY) + ((m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_fTemplateX - CenterX) * Math.Sin(intOrientAngle * Math.PI / 180)) +
                //                    ((m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_fTemplateY - CenterY) * Math.Cos(intOrientAngle * Math.PI / 180)));
                fCenterXDiff = m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].GetCenterXDiff(fXAfterRotated, m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalX);// m_smVisionInfo.g_fOrientCenterX[0];
                fCenterYDiff = m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].GetCenterYDiff(fYAfterRotated, m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalY);// m_smVisionInfo.g_fOrientCenterY[0];
                                                                                                                                                                                     // }


                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                {
                    m_fOffsetX = fCenterXDiff;
                    m_fOffsetY = fCenterYDiff;
                    m_fOffsetAngle = fAngleResult;
                }

                if (m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_blnWantCheckOrientAngleTolerance)
                {
                    if (m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_fAngleTolerance <= fAngleResult)
                    {
                        m_smVisionInfo.g_intOrientResult[0] = 4;
                        m_smVisionInfo.g_strErrorMessage += "*Fail Orient Angle Tolerance : Set = " + m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_fAngleTolerance.ToString("f4") +
                            " , Result = " + fAngleResult.ToString("f4");
                        blnFailAngle = true;
                    }
                }
                if (m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_blnWantCheckOrientXTolerance)
                {
                    if (Math.Abs(fCenterXDiff) >= m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_fXTolerance)
                    {
                        m_smVisionInfo.g_intOrientResult[0] = 4;
                        m_smVisionInfo.g_strErrorMessage += "*Fail Orient X Tolerance : Set = " + m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_fXTolerance.ToString("f4") +
                            " , Result = " + fCenterXDiff.ToString("f4");
                        blnFailPosition = true;
                    }
                }
                if (m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_blnWantCheckOrientYTolerance)
                {
                    if (Math.Abs(fCenterYDiff) >= m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_fYTolerance)
                    {
                        m_smVisionInfo.g_intOrientResult[0] = 4;
                        m_smVisionInfo.g_strErrorMessage += "*Fail Orient Y Tolerance : Set = " + m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_fYTolerance.ToString("f4") +
                            " , Result = " + fCenterYDiff.ToString("f4");
                        blnFailPosition = true;
                    }
                }
            }

            if (((!m_smCustomizeInfo.g_blnWantUseTCPIPIO && m_objVisionIO.OrientResult1 != null) || m_smCustomizeInfo.g_blnWantUseTCPIPIO) && m_smVisionInfo.g_intOrientResult[0] == 4)
            {
                if ((m_smCustomizeInfo.g_intWantBottom & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
                {
                    if (m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_strErrorMessage == "" && m_smVisionInfo.g_strErrorMessage == "")
                    {
                        m_smVisionInfo.g_strErrorMessage = "*Recipe is corrupted. Please relearn.";
                    }
                    else
                    {
                        m_smVisionInfo.g_strErrorMessage += "*" + m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_strErrorMessage;

                        if (m_smVisionInfo.g_strVisionName.Contains("BottomPosition"))
                            m_smVisionInfo.g_strErrorMessage = m_smVisionInfo.g_strErrorMessage.Replace("Orient", "Unit");
                    }

                    if (blnAuto)
                    {
                        if (blnFailAngle)
                        {
                            m_smVisionInfo.g_intAngleFailureTotal++;
                            SaveRejectImage_AddToBuffer("Angle", m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_strErrorMessage);
                        }
                        else if (blnFailPosition)
                        {
                            m_smVisionInfo.g_intPositionFailureTotal++;
                            SaveRejectImage_AddToBuffer("Position", m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_strErrorMessage);
                        }
                        else
                        {
                            if (m_smVisionInfo.g_strVisionName.Contains("BottomPosition"))
                            {
                                m_smVisionInfo.g_intOrientFailureTotal++;
                                SaveRejectImage_AddToBuffer("Unit", m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_strErrorMessage);
                            }
                            else
                            {
                                m_smVisionInfo.g_intOrientFailureTotal++;
                                SaveRejectImage_AddToBuffer("Orient", m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_strErrorMessage);
                            }
                        }
                    }
                }
                else
                {
                    if (m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_strErrorMessage == "" && m_smVisionInfo.g_strErrorMessage == "")
                    {
                        m_smVisionInfo.g_strErrorMessage = "*Recipe is corrupted. Please relearn.";
                    }
                    else
                    {
                        m_smVisionInfo.g_strErrorMessage += "*" + m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_strErrorMessage;

                        if (m_smVisionInfo.g_strVisionName.Contains("BottomPosition"))
                            m_smVisionInfo.g_strErrorMessage = m_smVisionInfo.g_strErrorMessage.Replace("Orient", "Unit");
                    }

                    if (blnAuto)
                    {
                        if (m_smVisionInfo.g_strVisionName.Contains("BottomPosition"))
                        {
                            m_smVisionInfo.g_intOrientFailureTotal++;
                            SaveRejectImage_AddToBuffer("Unit", m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_strErrorMessage);
                        }
                        else
                        {
                            m_smVisionInfo.g_intOrientFailureTotal++;
                            SaveRejectImage_AddToBuffer("Orient", m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_strErrorMessage);
                        }
                    }
                }

                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        m_intTCPIPResultID = (int)TCPIPResulID.Fail;

                return false;
            }
            else if (m_smVisionInfo.g_intOrientResult[0] > 0 && ((!m_smCustomizeInfo.g_blnWantUseTCPIPIO && m_objVisionIO.OrientResult1 != null && m_objVisionIO.OrientResult2 != null) && !((m_smVisionInfo.g_strVisionName.Contains("BottomPosition") && (m_smCustomizeInfo.g_intWantOrient & (1 << m_smVisionInfo.g_intVisionPos)) > 0))
                || m_smCustomizeInfo.g_blnWantUseTCPIPIO) && !((m_smVisionInfo.g_strVisionName.Contains("BottomPosition") && (m_smCustomizeInfo.g_intWantOrient & (1 << m_smVisionInfo.g_intVisionPos)) > 0)))
            {
                switch (m_smVisionInfo.g_intOrientResult[0])
                {
                    case 1:
                        if (m_smCustomizeInfo.g_intOrientIO == 0)
                        {
                            if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                            {
                                m_blnOrientResult1_Out = false;
                                m_blnOrientResult2_Out = true;
                            }
                            else
                            {
                                m_objVisionIO.OrientResult1.SetOff(strTrackHeadName + " OrientResult1 3"); if (m_smVisionInfo.g_blnTrackIO) STTrackLog.WriteLine("IO-OrientResult1-Set OFF 27");
                                m_objVisionIO.OrientResult2.SetOn(strTrackHeadName + " OrientResult1 4"); if (m_smVisionInfo.g_blnTrackIO) STTrackLog.WriteLine("IO-OrientResult2-Set ON 28");
                            }
                        }
                        else
                        {
                            if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                            {
                                m_blnOrientResult1_Out = true;
                                m_blnOrientResult2_Out = false;
                            }
                            else
                            {
                                m_objVisionIO.OrientResult1.SetOn(strTrackHeadName + " OrientResult1 3"); if (m_smVisionInfo.g_blnTrackIO) STTrackLog.WriteLine("IO-OrientResult1-Set ON 29");
                                m_objVisionIO.OrientResult2.SetOff(strTrackHeadName + " OrientResult1 4"); if (m_smVisionInfo.g_blnTrackIO) STTrackLog.WriteLine("IO-OrientResult2-Set OFF 30");
                            }
                        }
                        break;
                    case 2:
                        if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        {
                            m_blnOrientResult1_Out = true;
                            m_blnOrientResult2_Out = true;
                        }
                        else
                        {
                            m_objVisionIO.OrientResult1.SetOn(strTrackHeadName + " OrientResult1 5"); if (m_smVisionInfo.g_blnTrackIO) STTrackLog.WriteLine("IO-OrientResult1-Set ON 31");
                            m_objVisionIO.OrientResult2.SetOn(strTrackHeadName + " OrientResult2 6"); if (m_smVisionInfo.g_blnTrackIO) STTrackLog.WriteLine("IO-OrientResult2-Set ON 32");
                        }
                        break;
                    case 3:
                        if (m_smCustomizeInfo.g_intOrientIO == 0)
                        {
                            if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                            {
                                m_blnOrientResult1_Out = true;
                                m_blnOrientResult2_Out = false;
                            }
                            else
                            {
                                m_objVisionIO.OrientResult1.SetOn(strTrackHeadName + " OrientResult1 7"); if (m_smVisionInfo.g_blnTrackIO) STTrackLog.WriteLine("IO-OrientResult1-Set ON 33");
                                m_objVisionIO.OrientResult2.SetOff(strTrackHeadName + " OrientResult2 8"); if (m_smVisionInfo.g_blnTrackIO) STTrackLog.WriteLine("IO-OrientResult2-Set OFF 34");
                            }
                        }
                        else
                        {
                            if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                            {
                                m_blnOrientResult1_Out = false;
                                m_blnOrientResult2_Out = true;
                            }
                            else
                            {
                                m_objVisionIO.OrientResult1.SetOff(strTrackHeadName + " OrientResult1 7"); if (m_smVisionInfo.g_blnTrackIO) STTrackLog.WriteLine("IO-OrientResult1-Set OFF 35");
                                m_objVisionIO.OrientResult2.SetOn(strTrackHeadName + " OrientResult2 8"); if (m_smVisionInfo.g_blnTrackIO) STTrackLog.WriteLine("IO-OrientResult2-Set ON 36");
                            }
                        }
                        break;
                }
            }
            return true;
        }
        
        private bool StartPin1Test(bool blnAuto)
        {
            // make sure template learn
            if (m_smVisionInfo.g_arrPin1[0].ref_arrTemplateSetting.Count == 0)
            {
                m_smVisionInfo.g_strErrorMessage += "*Pin1 : No Template Found";
                if (blnAuto)
                    m_smVisionInfo.g_intNoTemplateFailureTotal++;

                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        m_intTCPIPResultID = (int)TCPIPResulID.Fail;

                return false;
            }
            m_smVisionInfo.g_arrPin1[0].ResetInspectionData();

            bool blnImageRotated = false;
            if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 0)
                blnImageRotated = m_blnRotateImage1Updated;
            else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 1)
                blnImageRotated = m_blnRotateImage2Updated;
            else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 2)
                blnImageRotated = m_blnRotateImage3Updated;
            else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 3)
                blnImageRotated = m_blnRotateImage4Updated;
            else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 4)
                blnImageRotated = m_blnRotateImage5Updated;
            else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 5)
                blnImageRotated = m_blnRotateImage6Updated;
            else
                blnImageRotated = m_blnRotateImage6Updated;

            // 2021 06 02 - CCEN: During dummy test (no mark and orient mark test), image is not rotated during pin test.
            if (blnImageRotated)
                m_smVisionInfo.g_arrOrientROIs[0][0].AttachImage(m_smVisionInfo.g_arrRotatedImages[m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo]);
            else
                m_smVisionInfo.g_arrOrientROIs[0][0].AttachImage(m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo]);

            int intMatchCount = 0;
            bool blnResult;
            string strErrorMessage = "";
            int intTemplateIndex;
            // Single template test
            if (!blnAuto && !m_smVisionInfo.g_blnInspectAllTemplate)
            {
                intTemplateIndex = m_smVisionInfo.g_intSelectedTemplate;
                if (m_smVisionInfo.g_arrPin1[0].ref_objTestROI == null)
                    m_smVisionInfo.g_arrPin1[0].ref_objTestROI = new ROI();

                m_smVisionInfo.g_arrPin1[0].ref_objTestROI.AttachImage(m_smVisionInfo.g_arrOrientROIs[0][0]);
                m_smVisionInfo.g_arrPin1[0].ref_objTestROI.LoadROISetting(
                    (int)(m_smVisionInfo.g_fOrientCenterX[0] -
                    m_smVisionInfo.g_arrPin1[0].GetPin1PatternWidth(intTemplateIndex) - m_smVisionInfo.g_arrPin1[0].GetRefOffsetX(intTemplateIndex)),
                    (int)(m_smVisionInfo.g_fOrientCenterY[0] -
                    m_smVisionInfo.g_arrPin1[0].GetPin1PatternHeight(intTemplateIndex) - m_smVisionInfo.g_arrPin1[0].GetRefOffsetY(intTemplateIndex)),
                    (int)m_smVisionInfo.g_arrPin1[0].GetPin1PatternWidth(intTemplateIndex) * 2,
                    (int)m_smVisionInfo.g_arrPin1[0].GetPin1PatternHeight(intTemplateIndex) * 2);

                m_smVisionInfo.g_arrPin1[0].ref_blnFinalResultPassFail = m_smVisionInfo.g_arrPin1[0].MatchWithTemplate(m_smVisionInfo.g_arrPin1[0].ref_objTestROI, m_smVisionInfo.g_intSelectedTemplate);
                m_smVisionInfo.g_arrPin1[0].ref_intFinalResultSelectedTemplate = intTemplateIndex;
                strErrorMessage = m_smVisionInfo.g_arrPin1[0].ref_strErrorMessage;
            }
            else // Whole active templates test
            {
                float fHighestScore = 0;
                do
                {
                    //float fHighestScore = 0; // 2020-04-15 ZJYEOH : move outside the loop so that highest score will not reset
                    intTemplateIndex = (int)((m_smVisionInfo.g_intTemplatePriority >> (0x04 * intMatchCount)) & 0x0F) - 1;
                    if (intTemplateIndex >= 0)
                    {
                        if (m_smVisionInfo.g_intTemplateMask == 0 || (m_smVisionInfo.g_intTemplateMask & (1 << intTemplateIndex)) > 0)
                        {
                            if (m_smVisionInfo.g_arrPin1[0].ref_objTestROI == null)
                                m_smVisionInfo.g_arrPin1[0].ref_objTestROI = new ROI();

                            m_smVisionInfo.g_arrPin1[0].ref_objTestROI.AttachImage(m_smVisionInfo.g_arrOrientROIs[0][0]);
                            float RotatedOrientCenterX = m_smVisionInfo.g_fOrientCenterX[0];
                            float RotatedOrientCenterY = m_smVisionInfo.g_fOrientCenterY[0];
                            float CenterX, CenterY;
                            if (m_smVisionInfo.g_blnWantGauge)
                            {
                                CenterX = m_smVisionInfo.g_arrOrientGaugeM4L[0].ref_pRectCenterPoint.X - m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIPositionX;
                                CenterY = m_smVisionInfo.g_arrOrientGaugeM4L[0].ref_pRectCenterPoint.Y - m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIPositionY;

                            }
                            else
                            {

                                CenterX = (float)(m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIWidth) / 2;
                                CenterY = (float)(m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIHeight) / 2;
                            }

                            float RotationAngle = m_intOrientAngle;
                            if (RotationAngle == -90)
                                RotationAngle = 90;
                            else if (RotationAngle == 90)
                                RotationAngle = -90;

                            RotatedOrientCenterX = (float)((CenterX) + ((m_smVisionInfo.g_fOrientCenterX[0] - CenterX) * Math.Cos(RotationAngle * Math.PI / 180)) -
                   ((m_smVisionInfo.g_fOrientCenterY[0] - CenterY) * Math.Sin(RotationAngle * Math.PI / 180)));
                            RotatedOrientCenterY = (float)((CenterY) + ((m_smVisionInfo.g_fOrientCenterX[0] - CenterX) * Math.Sin(RotationAngle * Math.PI / 180)) +
                             ((m_smVisionInfo.g_fOrientCenterY[0] - CenterY) * Math.Cos(RotationAngle * Math.PI / 180)));

                            m_smVisionInfo.g_arrPin1[0].ref_objTestROI.LoadROISetting(
                                (int)(Math.Abs(RotatedOrientCenterX) -
                                m_smVisionInfo.g_arrPin1[0].GetPin1PatternWidth(intTemplateIndex) - m_smVisionInfo.g_arrPin1[0].GetRefOffsetX(intTemplateIndex)),
                                (int)(Math.Abs(RotatedOrientCenterY) -
                                m_smVisionInfo.g_arrPin1[0].GetPin1PatternHeight(intTemplateIndex) - m_smVisionInfo.g_arrPin1[0].GetRefOffsetY(intTemplateIndex)),
                                (int)m_smVisionInfo.g_arrPin1[0].GetPin1PatternWidth(intTemplateIndex) * 2,
                                (int)m_smVisionInfo.g_arrPin1[0].GetPin1PatternHeight(intTemplateIndex) * 2);

                            //m_smVisionInfo.g_arrPin1[0].ref_objTestROI.SaveImage("D:\\TestROI.bmp");

                            blnResult = m_smVisionInfo.g_arrPin1[0].MatchWithTemplate(m_smVisionInfo.g_arrPin1[0].ref_objTestROI, intTemplateIndex);

                            if (m_smVisionInfo.g_arrPin1[0].GetResultScore(intTemplateIndex) > 0 &&
                                m_smVisionInfo.g_arrPin1[0].GetResultScore(intTemplateIndex) > fHighestScore)
                            {
                                fHighestScore = m_smVisionInfo.g_arrPin1[0].GetResultScore(intTemplateIndex);
                                m_smVisionInfo.g_arrPin1[0].ref_blnFinalResultPassFail = blnResult;
                                m_smVisionInfo.g_arrPin1[0].ref_intFinalResultSelectedTemplate = intTemplateIndex;
                                strErrorMessage = m_smVisionInfo.g_arrPin1[0].ref_strErrorMessage;
                            }
                        }
                    }
                    intMatchCount++;
                } while (intMatchCount < m_smVisionInfo.g_arrPin1[0].ref_arrTemplateSetting.Count);
            }

            m_smVisionInfo.g_blnDrawPin1Result = true;

            if (m_smVisionInfo.g_arrPin1[0].ref_blnFinalResultPassFail)
            {
                return true;
            }
            else
            {
                m_smVisionInfo.g_strErrorMessage = strErrorMessage;
                if (blnAuto)
                    m_smVisionInfo.g_intPin1FailureTotal++;

                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        m_intTCPIPResultID = (int)TCPIPResulID.Fail;

                return false;
            }
        }
        private bool StartPin1Test_WithOrientation(bool blnAuto)
        {
            // make sure template learn
            if (m_smVisionInfo.g_arrPin1[0].ref_arrTemplateSetting.Count == 0)
            {
                m_smVisionInfo.g_strErrorMessage += "*Pin1 : No Template Found";
                if (blnAuto)
                    m_smVisionInfo.g_intNoTemplateFailureTotal++;

                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        m_intTCPIPResultID = (int)TCPIPResulID.Fail;

                return false;
            }

            // Reset orientation IO
            if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
            {
                m_blnOrientResult1_Out = false;
                m_blnOrientResult2_Out = false;
            }
            else
            {
                if (m_objVisionIO.OrientResult1 != null)
                    m_objVisionIO.OrientResult1.SetOff(strTrackHeadName + " OrientResult1 1");
                if (m_objVisionIO.OrientResult2 != null)
                    m_objVisionIO.OrientResult2.SetOff(strTrackHeadName + " OrientResult2 2");
            }

            m_smVisionInfo.g_arrPin1[0].ResetInspectionData();
            m_smVisionInfo.g_arrOrientROIs[0][0].AttachImage(m_smVisionInfo.g_arrRotatedImages[m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo]);
            float ResultX = 0;
            float ResultY = 0;
            int intMatchCount = 0;
            bool blnResult;
            string strErrorMessage = "";
            int intTemplateIndex;
            // Single template test
            if (!blnAuto && !m_smVisionInfo.g_blnInspectAllTemplate)
            {
                intTemplateIndex = m_smVisionInfo.g_intSelectedTemplate;
                if (m_smVisionInfo.g_arrPin1[0].ref_objTestROI == null)
                    m_smVisionInfo.g_arrPin1[0].ref_objTestROI = new ROI();

                m_smVisionInfo.g_arrPin1[0].ref_objTestROI.AttachImage(m_smVisionInfo.g_arrOrientROIs[0][0]);
                m_smVisionInfo.g_arrPin1[0].ref_objTestROI.LoadROISetting(
                    (int)(m_smVisionInfo.g_fOrientCenterX[0] -
                    m_smVisionInfo.g_arrPin1[0].GetPin1PatternWidth(intTemplateIndex) - m_smVisionInfo.g_arrPin1[0].GetRefOffsetX(intTemplateIndex)),
                    (int)(m_smVisionInfo.g_fOrientCenterY[0] -
                    m_smVisionInfo.g_arrPin1[0].GetPin1PatternHeight(intTemplateIndex) - m_smVisionInfo.g_arrPin1[0].GetRefOffsetY(intTemplateIndex)),
                    (int)m_smVisionInfo.g_arrPin1[0].GetPin1PatternWidth(intTemplateIndex) * 2,
                    (int)m_smVisionInfo.g_arrPin1[0].GetPin1PatternHeight(intTemplateIndex) * 2);

                m_smVisionInfo.g_arrPin1[0].ref_blnFinalResultPassFail = m_smVisionInfo.g_arrPin1[0].MatchWithTemplate(m_smVisionInfo.g_arrPin1[0].ref_objTestROI, m_smVisionInfo.g_intSelectedTemplate);
                m_smVisionInfo.g_arrPin1[0].ref_intFinalResultSelectedTemplate = intTemplateIndex;
                strErrorMessage = m_smVisionInfo.g_arrPin1[0].ref_strErrorMessage;
            }
            else // Whole active templates test
            {
                float fHighestScore = 0;
                do
                {
                    //float fHighestScore = 0; // 2020-04-15 ZJYEOH : move outside the loop so that highest score will not reset
                    intTemplateIndex = (int)((m_smVisionInfo.g_intTemplatePriority >> (0x04 * intMatchCount)) & 0x0F) - 1;
                    if (intTemplateIndex >= 0)
                    {
                        if (m_smVisionInfo.g_intTemplateMask == 0 || (m_smVisionInfo.g_intTemplateMask & (1 << intTemplateIndex)) > 0)
                        {
                            for (int i = 0; i < m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_intDirections; i++)
                            {
                                if (m_smVisionInfo.g_arrPin1[0].ref_objTestROI == null)
                                    m_smVisionInfo.g_arrPin1[0].ref_objTestROI = new ROI();

                                m_smVisionInfo.g_arrPin1[0].ref_objTestROI.AttachImage(m_smVisionInfo.g_arrOrientROIs[0][0]);
                                float RotatedOrientCenterX = m_smVisionInfo.g_fOrientCenterX[0];
                                float RotatedOrientCenterY = m_smVisionInfo.g_fOrientCenterY[0];
                                float CenterX, CenterY;
                                float fSizeX, fSizeY;
                               
                                if (m_smVisionInfo.g_blnWantGauge)
                                {
                                    CenterX = m_smVisionInfo.g_arrOrientGaugeM4L[0].ref_pRectCenterPoint.X - m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIPositionX;
                                    CenterY = m_smVisionInfo.g_arrOrientGaugeM4L[0].ref_pRectCenterPoint.Y - m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIPositionY;
                                    if ((m_smVisionInfo.g_arrOrientGaugeM4L[0].ref_fRectWidth + m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIWidth) > m_smVisionInfo.g_arrImages[0].ref_intImageWidth ||
                                   (m_smVisionInfo.g_arrOrientGaugeM4L[0].ref_fRectHeight + m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIHeight) > m_smVisionInfo.g_arrImages[0].ref_intImageHeight)
                                    {
                                        fSizeX = m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIWidth - m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIWidth % 2; // why %2? To get "even" number
                                        fSizeY = m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIHeight - m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIHeight % 2;
                                    }
                                    else
                                    {
                                        fSizeX = m_smVisionInfo.g_arrOrientGaugeM4L[0].ref_fRectWidth + m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIWidth - m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIWidth % 2; // why %2? To get "even" number
                                        fSizeY = m_smVisionInfo.g_arrOrientGaugeM4L[0].ref_fRectHeight + m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIHeight - m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIHeight % 2;
                                    }
                                    fSizeX /= 2;
                                    fSizeY /= 2;
                                }
                                else
                                {

                                    CenterX = (float)(m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIWidth) / 2;
                                    CenterY = (float)(m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIHeight) / 2;
                                    fSizeX = m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIWidth / 2;
                                    fSizeY = m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIHeight / 2;
                                }

                                //         float RotationAngle = m_intOrientAngle;
                                //         if (RotationAngle == -90)
                                //             RotationAngle = 90;
                                //         else if (RotationAngle == 90)
                                //             RotationAngle = -90;

                                //         RotatedOrientCenterX = (float)((CenterX) + ((m_smVisionInfo.g_fOrientCenterX[0] - CenterX) * Math.Cos(RotationAngle * Math.PI / 180)) -
                                //((m_smVisionInfo.g_fOrientCenterY[0] - CenterY) * Math.Sin(RotationAngle * Math.PI / 180)));
                                //         RotatedOrientCenterY = (float)((CenterY) + ((m_smVisionInfo.g_fOrientCenterX[0] - CenterX) * Math.Sin(RotationAngle * Math.PI / 180)) +
                                //          ((m_smVisionInfo.g_fOrientCenterY[0] - CenterY) * Math.Cos(RotationAngle * Math.PI / 180)));

                                //m_smVisionInfo.g_arrPin1[0].ref_objTestROI.LoadROISetting(
                                //    (int)(Math.Abs(RotatedOrientCenterX) -
                                //    m_smVisionInfo.g_arrPin1[0].GetPin1PatternWidth(intTemplateIndex) - m_smVisionInfo.g_arrPin1[0].GetRefOffsetX(intTemplateIndex)),
                                //    (int)(Math.Abs(RotatedOrientCenterY) -
                                //    m_smVisionInfo.g_arrPin1[0].GetPin1PatternHeight(intTemplateIndex) - m_smVisionInfo.g_arrPin1[0].GetRefOffsetY(intTemplateIndex)),
                                //    (int)m_smVisionInfo.g_arrPin1[0].GetPin1PatternWidth(intTemplateIndex) * 2,
                                //    (int)m_smVisionInfo.g_arrPin1[0].GetPin1PatternHeight(intTemplateIndex) * 2);
                                int intStartX = 0;
                                int intStartY = 0;

                                // 2021 06 02 - CCENG: Pin1 matcher need to set angle also  bcos sometime pin 1 have pattern, not a dot only)
                                int intMinAngle = 0;
                                int intMaxAngle = 0;
                                int intAngleTolerance = 0; // Default put 0 deg first. 

                                if (i == 0) // 0
                                {
                                    //if (m_smVisionInfo.g_arrPin1[0].ref_arrTemplateSetting[intTemplateIndex].blnTemplateOrientationIsLeft)
                                    //    intStartX = (int)(CenterX - fSizeX);
                                    //else
                                    //    intStartX = (int)(CenterX);

                                    //if (m_smVisionInfo.g_arrPin1[0].ref_arrTemplateSetting[intTemplateIndex].blnTemplateOrientationIsTop)
                                    //    intStartY = (int)(CenterY - fSizeY);
                                    //else
                                    //    intStartY = (int)(CenterY);

                                    //if (m_smVisionInfo.g_arrPin1[0].ref_arrTemplateSetting[intTemplateIndex].blnTemplateOrientationIsLeft)
                                        intStartX = (int)(CenterX - m_smVisionInfo.g_arrPin1[0].ref_arrTemplateSetting[intTemplateIndex].intOffsetFromSearchROIX);
                                    //else
                                    //    intStartX = (int)(CenterX);

                                    //if (m_smVisionInfo.g_arrPin1[0].ref_arrTemplateSetting[intTemplateIndex].blnTemplateOrientationIsTop)
                                        intStartY = (int)(CenterY - m_smVisionInfo.g_arrPin1[0].ref_arrTemplateSetting[intTemplateIndex].intOffsetFromSearchROIY);
                                    //else
                                    //    intStartY = (int)(CenterY);

                                    m_smVisionInfo.g_arrPin1[0].ref_objTestROI.LoadROISetting(
                                      intStartX - (int)m_smVisionInfo.g_arrPin1[0].GetPin1PatternWidth(intTemplateIndex),
                                      intStartY  - (int)m_smVisionInfo.g_arrPin1[0].GetPin1PatternHeight(intTemplateIndex),
                                          (int)m_smVisionInfo.g_arrPin1[0].GetPin1PatternWidth(intTemplateIndex) * 2,
                                          (int)m_smVisionInfo.g_arrPin1[0].GetPin1PatternHeight(intTemplateIndex) * 2);
                                    //(int)fSizeX,
                                    //(int)fSizeY);

                                    intMinAngle = -intAngleTolerance;
                                    intMaxAngle = intAngleTolerance;
                                }
                                else if (i == 1) // 180
                                {
                                    //if (!m_smVisionInfo.g_arrPin1[0].ref_arrTemplateSetting[intTemplateIndex].blnTemplateOrientationIsLeft)
                                    //    intStartX = (int)(CenterX - fSizeX);
                                    //else
                                    //    intStartX = (int)(CenterX);

                                    //if (!m_smVisionInfo.g_arrPin1[0].ref_arrTemplateSetting[intTemplateIndex].blnTemplateOrientationIsTop)
                                    //    intStartY = (int)(CenterY - fSizeY);
                                    //else
                                    //    intStartY = (int)(CenterY);

                                    //m_smVisionInfo.g_arrPin1[0].ref_objTestROI.LoadROISetting(
                                    //  intStartX,
                                    //  intStartX,
                                    //  (int)fSizeX,
                                    //  (int)fSizeY);

                                    //if (m_smVisionInfo.g_arrPin1[0].ref_arrTemplateSetting[intTemplateIndex].blnTemplateOrientationIsLeft)
                                        intStartX = (int)(CenterX + m_smVisionInfo.g_arrPin1[0].ref_arrTemplateSetting[intTemplateIndex].intOffsetFromSearchROIX);
                                    //else
                                    //    intStartX = (int)(CenterX);

                                    //if (m_smVisionInfo.g_arrPin1[0].ref_arrTemplateSetting[intTemplateIndex].blnTemplateOrientationIsTop)
                                        intStartY = (int)(CenterY + m_smVisionInfo.g_arrPin1[0].ref_arrTemplateSetting[intTemplateIndex].intOffsetFromSearchROIY);
                                    //else
                                    //    intStartY = (int)(CenterY);

                                    m_smVisionInfo.g_arrPin1[0].ref_objTestROI.LoadROISetting(
                                      intStartX - (int)m_smVisionInfo.g_arrPin1[0].GetPin1PatternWidth(intTemplateIndex),
                                      intStartY - (int)m_smVisionInfo.g_arrPin1[0].GetPin1PatternHeight(intTemplateIndex),
                                          (int)m_smVisionInfo.g_arrPin1[0].GetPin1PatternWidth(intTemplateIndex) * 2,
                                          (int)m_smVisionInfo.g_arrPin1[0].GetPin1PatternHeight(intTemplateIndex) * 2);
                                    //(int)fSizeX,
                                    //(int)fSizeY);

                                    intMinAngle = 180 -intAngleTolerance;
                                    intMaxAngle = 180 +intAngleTolerance;

                                }
                                else if (i == 2) //90
                                {
                                    //if (!m_smVisionInfo.g_arrPin1[0].ref_arrTemplateSetting[intTemplateIndex].blnTemplateOrientationIsLeft)
                                    //    intStartX = (int)(CenterX - fSizeX);
                                    //else
                                    //    intStartX = (int)(CenterX);

                                    //if (m_smVisionInfo.g_arrPin1[0].ref_arrTemplateSetting[intTemplateIndex].blnTemplateOrientationIsTop)
                                    //    intStartY = (int)(CenterY - fSizeY);
                                    //else
                                    //    intStartY = (int)(CenterY);

                                    //m_smVisionInfo.g_arrPin1[0].ref_objTestROI.LoadROISetting(
                                    //  intStartX,
                                    //  intStartX,
                                    //  (int)fSizeX,
                                    //  (int)fSizeY);

                                    //if (m_smVisionInfo.g_arrPin1[0].ref_arrTemplateSetting[intTemplateIndex].blnTemplateOrientationIsLeft)
                                    intStartX = (int)(CenterX - m_smVisionInfo.g_arrPin1[0].ref_arrTemplateSetting[intTemplateIndex].intOffsetFromSearchROIX);
                                    //else
                                    //    intStartX = (int)(CenterX);

                                    //if (m_smVisionInfo.g_arrPin1[0].ref_arrTemplateSetting[intTemplateIndex].blnTemplateOrientationIsTop)
                                    intStartY = (int)(CenterY + m_smVisionInfo.g_arrPin1[0].ref_arrTemplateSetting[intTemplateIndex].intOffsetFromSearchROIY);
                                    //else
                                    //    intStartY = (int)(CenterY);

                                    m_smVisionInfo.g_arrPin1[0].ref_objTestROI.LoadROISetting(
                                      intStartX - (int)m_smVisionInfo.g_arrPin1[0].GetPin1PatternWidth(intTemplateIndex),
                                      intStartY - (int)m_smVisionInfo.g_arrPin1[0].GetPin1PatternHeight(intTemplateIndex),
                                          (int)m_smVisionInfo.g_arrPin1[0].GetPin1PatternWidth(intTemplateIndex) * 2,
                                          (int)m_smVisionInfo.g_arrPin1[0].GetPin1PatternHeight(intTemplateIndex) * 2);

                                    intMinAngle = 90 - intAngleTolerance;
                                    intMaxAngle = 90 + intAngleTolerance;

                                }
                                else if (i == 3) //-90
                                {
                                    //if (m_smVisionInfo.g_arrPin1[0].ref_arrTemplateSetting[intTemplateIndex].blnTemplateOrientationIsLeft)
                                    //    intStartX = (int)(CenterX - fSizeX);
                                    //else
                                    //    intStartX = (int)(CenterX);

                                    //if (!m_smVisionInfo.g_arrPin1[0].ref_arrTemplateSetting[intTemplateIndex].blnTemplateOrientationIsTop)
                                    //    intStartY = (int)(CenterY - fSizeY);
                                    //else
                                    //    intStartY = (int)(CenterY);

                                    //m_smVisionInfo.g_arrPin1[0].ref_objTestROI.LoadROISetting(
                                    //  intStartX,
                                    //  intStartX,
                                    //  (int)fSizeX,
                                    //  (int)fSizeY);

                                    //if (m_smVisionInfo.g_arrPin1[0].ref_arrTemplateSetting[intTemplateIndex].blnTemplateOrientationIsLeft)
                                    intStartX = (int)(CenterX + m_smVisionInfo.g_arrPin1[0].ref_arrTemplateSetting[intTemplateIndex].intOffsetFromSearchROIX);
                                    //else
                                    //    intStartX = (int)(CenterX);

                                    //if (m_smVisionInfo.g_arrPin1[0].ref_arrTemplateSetting[intTemplateIndex].blnTemplateOrientationIsTop)
                                    intStartY = (int)(CenterY - m_smVisionInfo.g_arrPin1[0].ref_arrTemplateSetting[intTemplateIndex].intOffsetFromSearchROIY);
                                    //else
                                    //    intStartY = (int)(CenterY);

                                    m_smVisionInfo.g_arrPin1[0].ref_objTestROI.LoadROISetting(
                                      intStartX - (int)m_smVisionInfo.g_arrPin1[0].GetPin1PatternWidth(intTemplateIndex),
                                      intStartY - (int)m_smVisionInfo.g_arrPin1[0].GetPin1PatternHeight(intTemplateIndex),
                                          (int)m_smVisionInfo.g_arrPin1[0].GetPin1PatternWidth(intTemplateIndex) * 2,
                                          (int)m_smVisionInfo.g_arrPin1[0].GetPin1PatternHeight(intTemplateIndex) * 2);

                                    intMinAngle = -90 -intAngleTolerance;
                                    intMaxAngle = -90 + intAngleTolerance;

                                }

                                //m_smVisionInfo.g_arrPin1[0].ref_objTestROI.SaveImage("D:\\TestROI.bmp");

                                blnResult = m_smVisionInfo.g_arrPin1[0].MatchWithTemplate(m_smVisionInfo.g_arrPin1[0].ref_objTestROI, intTemplateIndex, fHighestScore, intMinAngle, intMaxAngle);

                                if (m_smVisionInfo.g_arrPin1[0].GetResultScore(intTemplateIndex) > 0 && 
                                    m_smVisionInfo.g_arrPin1[0].GetResultScore(intTemplateIndex) > fHighestScore)
                                {
                                    ResultX = m_smVisionInfo.g_arrPin1[0].ref_objTestROI.ref_ROIPositionX + m_smVisionInfo.g_arrPin1[0].GetResultPosX(m_smVisionInfo.g_intSelectedTemplate);
                                    ResultY = m_smVisionInfo.g_arrPin1[0].ref_objTestROI.ref_ROIPositionY + m_smVisionInfo.g_arrPin1[0].GetResultPosY(m_smVisionInfo.g_intSelectedTemplate);
                                    fHighestScore = m_smVisionInfo.g_arrPin1[0].GetResultScore(intTemplateIndex);
                                    m_smVisionInfo.g_arrPin1[0].ref_blnFinalResultPassFail = blnResult;
                                    m_smVisionInfo.g_arrPin1[0].ref_intFinalResultSelectedTemplate = intTemplateIndex;
                                    strErrorMessage = m_smVisionInfo.g_arrPin1[0].ref_strErrorMessage;
                                }
                            }
                        }
                    }
                    intMatchCount++;
                } while (intMatchCount < m_smVisionInfo.g_arrPin1[0].ref_arrTemplateSetting.Count);
            }

            m_smVisionInfo.g_blnDrawPin1Result = true;
            
                // 2020 11 20 - CCENG: Method 2 orientation
                float fOrientationSeparatorX = (float)m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIWidth / 2;
                float fOrientationSeparatorY = (float)m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIHeight / 2;

            if (m_smVisionInfo.g_arrPin1[0].ref_blnFinalResultPassFail && m_smVisionInfo.g_arrPin1[0].ref_intFinalResultSelectedTemplate >= 0)
            {
                Orient objOrient = m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]];
                if (objOrient.ref_intDirections == 2)
                {
                    bool blnSampleIsTop = ResultY - fOrientationSeparatorY < 0;
                    bool blnDirectionisTop = m_smVisionInfo.g_arrPin1[0].ref_arrTemplateSetting[m_smVisionInfo.g_arrPin1[0].ref_intFinalResultSelectedTemplate].blnTemplateOrientationIsTop != blnSampleIsTop;

                    if (blnDirectionisTop)            // rotate 180  from template point
                    {
                        m_smVisionInfo.g_intOrientResult[0] = 2;
                    }
                    else
                    {
                        m_smVisionInfo.g_intOrientResult[0] = 0;            // no rotate
                    }
                }
                else
                {
                    bool blnSampleIsLeft = ResultX - fOrientationSeparatorX < 0;
                    bool blnSampleIsTop = ResultY - fOrientationSeparatorY < 0;

                    bool blnDirectionIsLeft = m_smVisionInfo.g_arrPin1[0].ref_arrTemplateSetting[m_smVisionInfo.g_arrPin1[0].ref_intFinalResultSelectedTemplate].blnTemplateOrientationIsLeft != blnSampleIsLeft;
                    bool blnDirectionisTop = m_smVisionInfo.g_arrPin1[0].ref_arrTemplateSetting[m_smVisionInfo.g_arrPin1[0].ref_intFinalResultSelectedTemplate].blnTemplateOrientationIsTop != blnSampleIsTop;

                    if (blnDirectionIsLeft && blnDirectionisTop)            // rotate 180  from template point
                    {
                        m_smVisionInfo.g_intOrientResult[0] = 2;
                    }
                    else if (blnDirectionIsLeft && !blnDirectionisTop)      // rotate 90 ccw from template point
                    {
                        m_smVisionInfo.g_intOrientResult[0] = 1;            // show result angle 90 when rotate ccw from template point
                    }
                    else if (!blnDirectionIsLeft && blnDirectionisTop)      // rotate 90 cw from template point
                    {
                        m_smVisionInfo.g_intOrientResult[0] = 3;            // show result angle -90 when rotate cw from template point
                    }
                    else
                    {
                        m_smVisionInfo.g_intOrientResult[0] = 0;            // no rotate
                    }
                }
            }
            else
            {
                m_smVisionInfo.g_intOrientResult[0] = 0;    // 2021 06 02 - Give Orient 0 deg if pin 1 result fail.
            }

            switch (m_smVisionInfo.g_intOrientResult[0])
            {
                default:
                case 0:
                    m_intOrientAngle = 0;
                    break;
                case 1:
                    m_intOrientAngle = 90;
                    break;
                case 2:
                    m_intOrientAngle = 180;
                    break;
                case 3:
                    m_intOrientAngle = -90;
                    break;
            }
            if (((!m_smCustomizeInfo.g_blnWantUseTCPIPIO && m_objVisionIO.OrientResult1 != null) || m_smCustomizeInfo.g_blnWantUseTCPIPIO) && m_smVisionInfo.g_intOrientResult[0] == 4)
            {
                //STTrackLog.WriteLine("Orient Fail");
                if ((m_smCustomizeInfo.g_intWantBottom & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
                {
                    if (blnAuto)
                    {
                        if (m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_strErrorMessage == "" && m_smVisionInfo.g_strErrorMessage == "")
                        {
                            m_smVisionInfo.g_strErrorMessage = "*Recipe is corrupted. Please relearn.";
                        }
                        else
                        {
                            m_smVisionInfo.g_strErrorMessage += "*" + m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_strErrorMessage;
                        }

                        //if (blnFailAngle)
                        //{
                        //    m_smVisionInfo.g_intAngleFailureTotal++;
                        //    SaveRejectImage_AddToBuffer("Angle", m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_strErrorMessage);
                        //}
                        //else if (blnFailPosition)
                        //{
                        //    m_smVisionInfo.g_intPositionFailureTotal++;
                        //    SaveRejectImage_AddToBuffer("Position", m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_strErrorMessage);
                        //}
                        //else
                        //{
                        //    m_smVisionInfo.g_intOrientFailureTotal++;
                        //    SaveRejectImage_AddToBuffer("Orient", m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_strErrorMessage);
                        //}
                    }
                }
                else
                {
                    if (m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_strErrorMessage == "" && m_smVisionInfo.g_strErrorMessage == "")
                    {
                        m_smVisionInfo.g_strErrorMessage = "*Recipe is corrupted. Please relearn.";
                    }
                    else
                    {
                        m_smVisionInfo.g_strErrorMessage += "*" + m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_strErrorMessage;   // 2021 03 11 - Add * to make sure message go to next line.
                    }

                    if (blnAuto)
                    {
                        m_smVisionInfo.g_intOrientFailureTotal++;
                        SaveRejectImage_AddToBuffer("Orient", m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_strErrorMessage);
                    }
                }

                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        m_intTCPIPResultID = (int)TCPIPResulID.Fail;

                //return false;
            }
            else if (m_smVisionInfo.g_intOrientResult[0] > 0 && ((!m_smCustomizeInfo.g_blnWantUseTCPIPIO && m_objVisionIO.OrientResult1 != null && m_objVisionIO.OrientResult2 != null)) || m_smCustomizeInfo.g_blnWantUseTCPIPIO)
            {
                //STTrackLog.WriteLine("Orient Pass with result "+ m_smVisionInfo.g_intOrientResult[0].ToString());
                switch (m_smVisionInfo.g_intOrientResult[0])
                {
                    case 1:
                        if (m_smCustomizeInfo.g_intOrientIO == 0)
                        {
                            if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                            {
                                m_blnOrientResult1_Out = false;
                                m_blnOrientResult2_Out = true;
                            }
                            else
                            {
                                //STTrackLog.WriteLine("OrientResult1 Off");
                                //STTrackLog.WriteLine("OrientResult2 On");
                                m_objVisionIO.OrientResult1.SetOff(strTrackHeadName + " OrientResult1 3");
                                m_objVisionIO.OrientResult2.SetOn(strTrackHeadName + " OrientResult1 4");
                            }
                        }
                        else
                        {
                            if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                            {
                                m_blnOrientResult1_Out = true;
                                m_blnOrientResult2_Out = false;
                            }
                            else
                            {
                                //STTrackLog.WriteLine("OrientResult1 On");
                                //STTrackLog.WriteLine("OrientResult2 Off");
                                m_objVisionIO.OrientResult1.SetOn(strTrackHeadName + " OrientResult1 3");
                                m_objVisionIO.OrientResult2.SetOff(strTrackHeadName + " OrientResult1 4");
                            }
                        }
                        break;
                    case 2:
                        if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        {
                            m_blnOrientResult1_Out = true;
                            m_blnOrientResult2_Out = true;
                        }
                        else
                        {
                            //STTrackLog.WriteLine("OrientResult1 On");
                            //STTrackLog.WriteLine("OrientResult2 On");
                            m_objVisionIO.OrientResult1.SetOn(strTrackHeadName + " OrientResult1 5");
                            m_objVisionIO.OrientResult2.SetOn(strTrackHeadName + " OrientResult2 6");
                        }
                        break;
                    case 3:
                        if (m_smCustomizeInfo.g_intOrientIO == 0)
                        {
                            if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                            {
                                m_blnOrientResult1_Out = true;
                                m_blnOrientResult2_Out = false;
                            }
                            else
                            {
                                //STTrackLog.WriteLine("OrientResult1 On");
                                //STTrackLog.WriteLine("OrientResult2 Off");
                                m_objVisionIO.OrientResult1.SetOn(strTrackHeadName + " OrientResult1 7");
                                m_objVisionIO.OrientResult2.SetOff(strTrackHeadName + " OrientResult2 8");
                            }
                        }
                        else
                        {
                            if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                            {
                                m_blnOrientResult1_Out = false;
                                m_blnOrientResult2_Out = true;
                            }
                            else
                            {
                                //STTrackLog.WriteLine("OrientResult1 Off");
                                //STTrackLog.WriteLine("OrientResult2 On");
                                m_objVisionIO.OrientResult1.SetOff(strTrackHeadName + " OrientResult1 7");
                                m_objVisionIO.OrientResult2.SetOn(strTrackHeadName + " OrientResult2 8");
                            }
                        }
                        break;
                }
            }
            if (m_smVisionInfo.g_arrPin1[0].ref_blnFinalResultPassFail)
            {
                return true;
            }
            else
            {
                m_smVisionInfo.g_strErrorMessage = strErrorMessage;
                if (blnAuto)
                    m_smVisionInfo.g_intPin1FailureTotal++;

                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        m_intTCPIPResultID = (int)TCPIPResulID.Fail;

                return false;
            }
        }
        private void GaugeMeasureUnit(RectGauge objGauge, ImageDrawing objMeasuredImage)
        {
            if (m_blnWantPositioning)
            {
                objGauge.SetRectGaugePlacement(
                    m_smVisionInfo.g_objPositioning.ref_fObjectCenterX,
                    m_smVisionInfo.g_objPositioning.ref_fObjectCenterY);

                m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][0].LoadROISetting(
                   (int)Math.Round(m_smVisionInfo.g_objPositioning.ref_fObjectCenterX -
                    m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][0].ref_ROIWidth / 2, 0, MidpointRounding.AwayFromZero),
                    (int)Math.Round(m_smVisionInfo.g_objPositioning.ref_fObjectCenterY -
                   m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][0].ref_ROIHeight / 2, 0, MidpointRounding.AwayFromZero),
                   m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][0].ref_ROIWidth,
                   m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][0].ref_ROIHeight);
            }

            if (objGauge.ref_fGainValue != 1000)
            {
                lock (m_objLock)
                {
                    objMeasuredImage.AddGain(ref m_objPkgSizeGainImage, objGauge.ref_fGainValue / 1000);
                    objGauge.Measure_2(m_objPkgSizeGainImage);
                }
            }
            else
                objGauge.Measure(objMeasuredImage);
        }

        private bool GaugeMeasureUnit(RectGaugeM4L objGauge, List<ImageDrawing> arrMeasuredImage)
        {
            bool blnResult = true;
            //if (objGauge.ref_fGainValue != 1000)
            //{
            //    lock (m_objLock)
            //    {
            //        objMeasuredImage.AddGain(ref m_objPkgSizeGainImage, objGauge.ref_fGainValue / 1000);
            //        blnResult = objGauge.Measure_WithDontCareArea(m_objPkgSizeGainImage, m_smVisionInfo.g_objWhiteImage);
            //    }
            //}
            //else
            blnResult = objGauge.Measure_WithDontCareArea(arrMeasuredImage, m_smVisionInfo.g_objWhiteImage,
                       true,
                       m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_fTemplateUnitSizeX,
                       m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_fTemplateUnitSizeY);

            return blnResult;
        }
        private int GetLargestGaugeImageNo(RectGaugeM4L objGauge)
        {
            int[] arrPackageSizeImageIndex = { };

            arrPackageSizeImageIndex = objGauge.GetGaugeImageNoList();

            int intMinImageIndex = 0;
            for (int j = 0; j < 4; j++)
            {
                if (arrPackageSizeImageIndex[j] > intMinImageIndex)
                    intMinImageIndex = arrPackageSizeImageIndex[j];
            }

            return intMinImageIndex;
        }
        private bool StartPackageSizeTest(bool blnAuto)
        {
            // 2019 07 15 - CCENG: Need to measure package size even though no check package size because need the unit edge for inspect package defect.
            if ((m_smCustomizeInfo.g_intWantPackage & (1 << m_smVisionInfo.g_intVisionPos)) == 0 ||
                ((m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailMask & 0x1000) == 0 && !m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetWantInspectPackage() && !GetWantInspectPackageColor(m_smVisionInfo.g_intSelectedUnit)) ||
                (m_smVisionInfo.g_strVisionName.Contains("BottomOrient") || m_smVisionInfo.g_strVisionName.Contains("BottomPosition")) &&
                !m_smVisionInfo.g_blnOrientWantPackage ||
                ((m_smVisionInfo.g_strVisionName.Contains("BottomOrient") || m_smVisionInfo.g_strVisionName.Contains("BottomPosition")) && (m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailMask & 0x1000) == 0))
            //if ((m_smCustomizeInfo.g_intWantPackage & (1 << m_smVisionInfo.g_intVisionPos)) == 0 || (m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailMask & 0x1000) == 0)
            {
                m_bPackageSizePreTestResult = false;
                m_bPackageSizePreTestDone = true;
                return true;
            }

            // Check is templates learnt
            if (m_smVisionInfo.g_arrPackageROIs.Count <= m_smVisionInfo.g_intSelectedUnit || m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit].Count == 0)
            {
                m_bPackageSizePreTestResult = false;
                m_bPackageSizePreTestDone = true;

                //2021-03-10 ZJYEOH : open back wait mark done to tally with vision4process, mark fail priority
                // 2019-11-08 ZJYEOH: No need wait mark done anymore, if package size fail no need to check mark
                WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartPackageSizeTest > m_bSubTh_MarkTest 5861");    // need to wait for mark inspection done. Because package size fail should not display error msg if mark fail.
                if (!m_bSubTh_MarkTest_Result)
                {
                    return false;   // Skip package counter if mark fail because counter will add to mark
                }



                m_smVisionInfo.g_strErrorMessage += "*Package : No Template Found";
                if (blnAuto)
                {
                    m_smVisionInfo.g_intNoTemplateFailureTotal++;
                }

                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        SetPackageResultID(m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailResultMask);

                return false;
            }

            // Make sure template unit size not set to zero
            if ((m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_fUnitWidthMin == 0 || m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_fUnitHeightMin == 0) ||
                (m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_fUnitWidthMax == 0 || m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_fUnitHeightMax == 0))
            {
                m_bPackageSizePreTestResult = false;
                m_bPackageSizePreTestDone = true;

                //2021-03-10 ZJYEOH : open back wait mark done to tally with vision4process, mark fail priority
                // 2019-11-08 ZJYEOH: No need wait mark done anymore, if package size fail no need to check mark
                WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartPackageSizeTest > m_bSubTh_MarkTest 5884");    // need to wait for mark inspection done. Because package size fail should not display error msg if mark fail.
                if (!m_bSubTh_MarkTest_Result)
                {
                    return false;   // Skip package counter if mark fail because counter will add to mark
                }

                m_smVisionInfo.g_strErrorMessage += "*Package : Template Unit Size Min Max Setting cannot be zero.";
                if (blnAuto)
                {

                    m_smVisionInfo.g_intPackageFailureTotal++;
                }

                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        m_intTCPIPResultID = (int)TCPIPResulID.FailPackage;//FailPackageDimension;

                return false;
            }

            // --------- Get image index for : unit edge / Mark / package / crack -----------------
            int intUnitEdgeImageIndex = GetLargestGaugeImageNo(m_smVisionInfo.g_arrPackageGaugeM4L[m_smVisionInfo.g_intSelectedUnit]); // 2020-09-10 ZJYEOH : Need to wait the lagest image no //m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetGrabImageIndex(0);

            if (intUnitEdgeImageIndex == 0)
                WaitEventDone(ref m_bGrabImage1Done, true, 10000, "StartPackageSizeTest > m_bGrabImage1Done a");
            else if (intUnitEdgeImageIndex == 1)
                WaitEventDone(ref m_bGrabImage2Done, true, 10000, "StartPackageSizeTest > m_bGrabImage2Done a");
            else if (intUnitEdgeImageIndex == 2)
                WaitEventDone(ref m_bGrabImage3Done, true, 10000, "StartPackageSizeTest > m_bGrabImage3Done a");
            else if (intUnitEdgeImageIndex == 3)
                WaitEventDone(ref m_bGrabImage4Done, true, 10000, "StartPackageSizeTest > m_bGrabImage4Done a");
            else if (intUnitEdgeImageIndex == 4)
                WaitEventDone(ref m_bGrabImage5Done, true, 10000, "StartPackageSizeTest > m_bGrabImage5Done a");
            else if (intUnitEdgeImageIndex == 5)
                WaitEventDone(ref m_bGrabImage6Done, true, 10000, "StartPackageSizeTest > m_bGrabImage6Done a");
            else if (intUnitEdgeImageIndex == 6)
                WaitEventDone(ref m_bGrabImage7Done, true, 10000, "StartPackageSizeTest > m_bGrabImage7Done a");
            else
            {
                m_bPackageSizePreTestResult = false;
                m_bPackageSizePreTestDone = true;

                //2021-03-10 ZJYEOH : open back wait mark done to tally with vision4process, mark fail priority
                // 2019-11-08 ZJYEOH: No need wait mark done anymore, if package size fail no need to check mark
                WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartPackageSizeTest > m_bSubTh_MarkTest 5920");    // need to wait for mark inspection done. Because package size fail should not display error msg if mark fail.
                if (!m_bSubTh_MarkTest_Result)
                {
                    return false;   // Skip package counter if mark fail because counter will add to mark
                }

                m_smVisionInfo.g_strErrorMessage += "*Package : Wrong setting for package size image number. intUnitEdgeImageIndex = " + intUnitEdgeImageIndex.ToString();
                if (blnAuto)
                {
                    m_smVisionInfo.g_intPackageFailureTotal++;
                }

                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        SetPackageResultID(m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailResultMask);

                return false;
            }

            if (m_smVisionInfo.g_arrPackageGaugeM4L[m_smVisionInfo.g_intSelectedUnit].GetGaugeMeasureMode(0) == 4)
                m_smVisionInfo.g_arrPackageGaugeM4L[m_smVisionInfo.g_intSelectedUnit].SetGaugeAngle(-1);  //reset back to default angle

            if (m_smVisionInfo.g_objGauge_PkgSize == null)
            {
                m_smVisionInfo.g_objGauge_PkgSize = new RectGaugeM4L(m_smVisionInfo.g_WorldShape, 0, m_smVisionInfo.g_intVisionIndex);
            }
            m_smVisionInfo.g_arrPackageGaugeM4L[m_smVisionInfo.g_intSelectedUnit].CopyTo(ref m_smVisionInfo.g_objGauge_PkgSize);

            int[] arrUserSelectImageViewIndex = m_smVisionInfo.g_objGauge_PkgSize.GetGaugeImageNoList();

            if (!WaitEventDone(arrUserSelectImageViewIndex, "arrUserSelectImageViewIndex 5920"))
            {
                m_bPackageSizePreTestResult = false;
                m_bPackageSizePreTestDone = true;

                //m_smVisionInfo.g_strErrorMessage += "*Package : Wrong setting for package size image number.";
                m_smVisionInfo.g_strErrorMessage += "*Package : Grab image Event fail. Please check camera.";
                if (blnAuto)
                {
                    m_smVisionInfo.g_intPackageFailureTotal++;
                }

                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        SetPackageResultID(m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailResultMask);

                return false;
            }

            // Always use PackageGauge[0] to measure unit edge for image 1, 2, or 3 depends on Package Advance Setting.
            if (!GaugeMeasureUnit(m_smVisionInfo.g_objGauge_PkgSize, m_smVisionInfo.g_arrImages))
            {
                if (m_smVisionInfo.g_arrPackageGaugeM4L[m_smVisionInfo.g_intSelectedUnit].GetGaugeMeasureMode(0) != 4)
                {
                    m_bPackageSizePreTestResult = false;
                    m_bPackageSizePreTestDone = true;

                    m_smVisionInfo.g_arrPackageGaugeM4L[m_smVisionInfo.g_intSelectedUnit] = m_smVisionInfo.g_objGauge_PkgSize; // 2020-02-06 ZJYEOH : Pass back to g_arrPackageGaugeM4L so that drawing will based on latest measured result
                    m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_blnDrawPkgGaugeResult = true;

                    //2021-03-10 ZJYEOH : open back wait mark done to tally with vision4process, mark fail priority
                    // 2019-11-08 ZJYEOH: No need wait mark done anymore, if package size fail no need to check mark
                    WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartPackageSizeTest > m_bSubTh_MarkTest 5963");    // need to wait for mark inspection done. Because package size fail should not display error msg if mark fail.
                    if (!m_bSubTh_MarkTest_Result)
                    {
                        return false;   // Skip package counter if mark fail because counter will add to mark
                    }

                    m_smVisionInfo.g_strErrorMessage += "*Package : " + m_smVisionInfo.g_objGauge_PkgSize.ref_strErrorMessage;
                    if (blnAuto)
                    {
                        SaveRejectImage_AddToBuffer("Package", m_smVisionInfo.g_objGauge_PkgSize.ref_strErrorMessage);
                        m_smVisionInfo.g_intPackageFailureTotal++;
                    }

                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        if (m_intTCPIPResultID == -1)
                            SetPackageResultID(m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailResultMask);

                    return false;
                }
                else
                {
                    float fcenterX = -1, fcenterY = -1, angle = 0;
                    int intUnitPRWidth = 0;
                    int intUnitPRHeight = 0;

                    if (m_smVisionInfo.g_arrOrientROIs.Count != 0 && m_smVisionInfo.g_arrOrients.Count != 0)
                    {
                        fcenterX = m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalX + m_smVisionInfo.g_arrOrients[0][0].ref_fObjectX;
                        fcenterY = m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalY + m_smVisionInfo.g_arrOrients[0][0].ref_fObjectY;
                        angle = m_smVisionInfo.g_arrOrients[0][0].ref_fDegAngleResult;
                        intUnitPRWidth = (int)m_smVisionInfo.g_arrPackageGaugeM4L[m_smVisionInfo.g_intSelectedUnit].ref_f4LGaugeUnitWidth;
                        intUnitPRHeight = (int)m_smVisionInfo.g_arrPackageGaugeM4L[m_smVisionInfo.g_intSelectedUnit].ref_f4LGaugeUnitHeight;
                    }

                    m_smVisionInfo.g_arrPackageGaugeM4L[m_smVisionInfo.g_intSelectedUnit].SetEdgeROIPlacementLimit2(m_smVisionInfo.g_arrOrientROIs[0][0], (int)fcenterX, (int)fcenterY, intUnitPRWidth, intUnitPRHeight);
                    m_smVisionInfo.g_arrPackageGaugeM4L[m_smVisionInfo.g_intSelectedUnit].SetGaugePlace_BasedOnEdgeROI();
                    m_smVisionInfo.g_arrPackageGaugeM4L[m_smVisionInfo.g_intSelectedUnit].SetGaugeAngle(angle);  //set angle
                    m_smVisionInfo.g_arrPackageGaugeM4L[m_smVisionInfo.g_intSelectedUnit].CopyTo(ref m_smVisionInfo.g_objGauge_PkgSize);

                    if (!m_smVisionInfo.g_objGauge_PkgSize.Measure_WithDontCareArea(m_smVisionInfo.g_arrImages, m_smVisionInfo.g_objWhiteImage,  //measure 2nd time because 1st time measurement orient test not yet carried out
                           true,
                           m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_fTemplateUnitSizeX,
                           m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_fTemplateUnitSizeY))
                    {

                        m_bPackageSizePreTestResult = false;
                        m_bPackageSizePreTestDone = true;

                        m_smVisionInfo.g_arrPackageGaugeM4L[m_smVisionInfo.g_intSelectedUnit] = m_smVisionInfo.g_objGauge_PkgSize; // 2020-02-06 ZJYEOH : Pass back to g_arrPackageGaugeM4L so that drawing will based on latest measured result
                        m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_blnDrawPkgGaugeResult = true;

                        //2021-03-10 ZJYEOH : open back wait mark done to tally with vision4process, mark fail priority
                        // 2019-11-08 ZJYEOH: No need wait mark done anymore, if package size fail no need to check mark
                        WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartPackageSizeTest > m_bSubTh_MarkTest 5963");    // need to wait for mark inspection done. Because package size fail should not display error msg if mark fail.
                        if (!m_bSubTh_MarkTest_Result)
                        {
                            return false;   // Skip package counter if mark fail because counter will add to mark
                        }

                        m_smVisionInfo.g_strErrorMessage += "*Package : " + m_smVisionInfo.g_objGauge_PkgSize.ref_strErrorMessage;
                        if (blnAuto)
                        {
                            SaveRejectImage_AddToBuffer("Package", m_smVisionInfo.g_objGauge_PkgSize.ref_strErrorMessage);
                            m_smVisionInfo.g_intPackageFailureTotal++;
                        }

                        if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                            if (m_intTCPIPResultID == -1)
                                SetPackageResultID(m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailResultMask);

                        return false;
                    }
                }
            }
            else
            {
                if (m_blnWantLeadTest)
                {
                    for (int j = 0; j < m_smVisionInfo.g_arrLead.Length; j++)
                    {
                        if (m_smVisionInfo.g_arrLead[j].ref_blnSelected)
                        {
                            if (m_smVisionInfo.g_arrLead[0].ref_blnWantUsePkgToBaseTolerance)
                                m_smVisionInfo.g_arrLead[j].AssignLineGaugeDataFromPackageGaugeM4L(m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X, m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y, m_smVisionInfo.g_objGauge_PkgSize.ref_fRectWidth, m_smVisionInfo.g_objGauge_PkgSize.ref_fRectHeight, m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle);
                        }
                    }
                }
                m_bPackageSizePreTestResult = true;
                m_bPackageSizePreTestDone = true;
            }

            if (!m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].DoInspection_PackageSizeOnly(m_smVisionInfo.g_objGauge_PkgSize, m_smVisionInfo.g_blnWantCheckPackageAngle) && !m_blnTestHandMade_Mark)
            {
                // 2019-10-16 ZJYEOH : change packagesize pretest state above during measure gauge, here is compare package size with tolerance
                //m_bPackageSizePreTestResult = false;
                //m_bPackageSizePreTestDone = true;

                //2021-03-10 ZJYEOH : open back wait mark done to tally with vision4process, mark fail priority
                // 2019-11-08 ZJYEOH: No need wait mark done anymore, if package size fail no need to check mark
                WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartPackageSizeTest > m_bSubTh_MarkTest 6002");    // need to wait for mark inspection done. Because package size fail should not display error msg if mark fail.
                if (!m_bSubTh_MarkTest_Result)
                {
                    return false;   // Skip package counter if mark fail because counter will add to mark
                }

                m_smVisionInfo.g_strErrorMessage += m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_strErrorMessage;
                if (blnAuto)
                {
                    m_objVisionIO.PackageFail.SetOn(strTrackHeadName + " PackageFail");
                    SaveRejectImage_AddToBuffer("Package", m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_strErrorMessage);
                    m_smVisionInfo.g_intPackageFailureTotal++;
                }

                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        m_intTCPIPResultID = (int)TCPIPResulID.FailPackage;//FailPackageDimension;

                return false;
            }
            //else
            //{
            //    m_bPackageSizePreTestResult = true;
            //    m_bPackageSizePreTestDone = true;
            //}

            return true;
        }

        private bool StartPackageTest_MarkLightView(bool blnAuto)
        {
            bool blnResult = true;

            if ((m_smCustomizeInfo.g_intWantPackage & (1 << m_smVisionInfo.g_intVisionPos)) == 0 || !m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetWantInspectPackage())
                return true;

            if (m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetGrabImageIndex(2) == 0 || !m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_blnUseDetailDefectCriteria)     // Side light View // 13-08-2019 ZJYEOH : No need to test mark light view during simple mode
            {
                // 2019 06 08 - CCENG: Not need to check defect under mark light view because it will test under side light view
                return true;
            }

            // Check is templates learnt
            if (m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit].Count == 0)
            {
                m_smVisionInfo.g_strErrorMessage += "*Package : No Template Found";
                if (blnAuto)
                {
                    m_smVisionInfo.g_intNoTemplateFailureTotal++;
                }

                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        SetPackageResultID(m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailResultMask);

                return false;
            }

            // Make sure template unit size not set to zero
            if ((m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_fUnitWidthMin == 0 || m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_fUnitHeightMin == 0) ||
                (m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_fUnitWidthMax == 0 || m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_fUnitHeightMax == 0))
            {
                m_smVisionInfo.g_strErrorMessage += "*Package : Template Unit Size Min Max Setting cannot be zero.";
                if (blnAuto)
                {
                    m_smVisionInfo.g_intPackageFailureTotal++;
                }

                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        m_intTCPIPResultID = (int)TCPIPResulID.FailPackage;//FailPackageDimension;

                return false;
            }

            // --------- Get image index for : Mark -----------------
            int intMarkImageIndex = m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetGrabImageIndex(1);

            // 2019 03 07 - ZJYeoh: Wait m_intOrientAngle value from StartOrientTest First
            //if (intSideLightViewImageIndex > 0)   
            WaitEventDone(ref m_blnOrientDataUpdated, true, 10000, "StartPackagetest > m_blnOrientDataUpdated 1");


            // ---------  Rotate image 2 and 3 to oriented 0 deg -------------
            if (m_objGauge_PkgMarkView == null)
            {
                m_objGauge_PkgMarkView = new RectGaugeM4L(m_smVisionInfo.g_WorldShape, 0, m_smVisionInfo.g_intVisionIndex);
            }

            float fGaugeCenterX = 0, fGaugeCenterY = 0, fGaugeWidth = 0, fGaugeHeight = 0, fGaugeAngle = 0;

            if (m_smVisionInfo.g_blnWantGauge)
            {
                // 2019 07 15 - CCENG: if want gauge ON, mean g_arrOrientGauge is used to measure unit edge for image 1. So not need to remeasure again here. Direct get measure result from g_arrOrientGauge.
                m_objGauge_PkgMarkView = m_smVisionInfo.g_arrOrientGaugeM4L[0];

                fGaugeCenterX = m_objGauge_PkgMarkView.ref_pRectCenterPoint.X;
                fGaugeCenterY = m_objGauge_PkgMarkView.ref_pRectCenterPoint.Y;
                fGaugeWidth = m_objGauge_PkgMarkView.ref_fRectWidth;
                fGaugeHeight = m_objGauge_PkgMarkView.ref_fRectHeight;
                fGaugeAngle = m_objGauge_PkgMarkView.ref_fRectAngle;

                // 2019 07 15 - CCENG: If want gauge ON, mean image 1 has been rotated. So not need to re-rotate image 1 here again.
            }
            else
            {
                WaitEventDone(ref m_bPackageSizeTestDone, true, 10000, "StartPackageTest > m_bPackageSizeTestDone 2");
                fGaugeCenterX = m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X;
                fGaugeCenterY = m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y;
                fGaugeWidth = m_smVisionInfo.g_objGauge_PkgSize.ref_fRectWidth;
                fGaugeHeight = m_smVisionInfo.g_objGauge_PkgSize.ref_fRectHeight;
                fGaugeAngle = m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle;


                float fTotalRotateAngle = m_intOrientAngle + fGaugeAngle;

                // Get RotateROI center point where the ROI center point == Unit Center Point
                m_objSubTh1_RotateROI.LoadROISetting(
                            (int)Math.Round(fGaugeCenterX -
                            m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][0].ref_ROIWidth / 2, 0, MidpointRounding.AwayFromZero),
                            (int)Math.Round(fGaugeCenterY -
                            m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][0].ref_ROIHeight / 2, 0, MidpointRounding.AwayFromZero),
                            m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][0].ref_ROIWidth,
                            m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][0].ref_ROIHeight);

                // 2019 07 15 - Since want gauge is OFF, mean image 1 is not rotated according to unit angle, but accoring to orient again only. So need to re-rotate here again.
                // Rotate imgae 1 
                m_objSubTh1_RotateROI.AttachImage(m_smVisionInfo.g_arrImages[0]);
                ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[0], m_objSubTh1_RotateROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_PkgBright, ref m_smVisionInfo.g_arrRotatedImages, 0);
            }

            m_blnRotateImage1Updated = true;

            // ========================================================================================================================

            m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_blnViewUnitPosition = true;

            m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ClearDontCareAreaArray();

            // ------- Copy image to temporary inspection image.
            if (m_smVisionInfo.g_arrImages.Count > 2) // when mark image present
                m_smVisionInfo.g_arrRotatedImages[intMarkImageIndex].CopyTo(ref m_objMarkViewImage);
            //m_smVisionInfo.g_arrRotatedImages[intMarkImageIndex].SaveImage("D:\\TS\\rotatedimagemarklightview.bmp");
            bool blnWantMark = false;
            int intCharDilateHalfWidth = 2;
            if (m_smVisionInfo.g_arrMarks != null && m_smVisionInfo.g_arrMarks.Count > 0)
            {
                // 2020 04 15 - JBTAN: will continue to check mark even option uncheck check mark option
                // 2020 07 08 - Roll back to previous method, wont check mark if Mark Checking is not selected.
                blnWantMark = m_smVisionInfo.g_arrMarks[0].ref_blnCheckMark;
                //blnWantMark = true;
                intCharDilateHalfWidth = m_smVisionInfo.g_arrMarks[0].ref_intCharDilateHalfWidth; // thick iteration
            }

            if (blnWantMark)
            {
                // ---------- Fill Mark Image's mark area with black color -------------------
                int intNumChars = m_smVisionInfo.g_arrMarks[0].GetNumChars();
                int intStartX = 0, intStartY = 0, intEndX = 0, intEndY = 0;
                int CenterPointOffsetX = 0;
                int CenterPointOffsetY = 0;

                if (!m_smVisionInfo.g_blnWantGauge)
                {
                    //   float CenterX = m_objSubTh1_RotateROI.ref_ROITotalCenterX;// (float)(m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][0].ref_ROICenterX);
                    //   float CenterY = m_objSubTh1_RotateROI.ref_ROITotalCenterY;// (float)(m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][0].ref_ROICenterY);

                    //   float Angle = fGaugeAngle + (m_intOrientAngle);
                    //   Angle = -Angle;
                    //   float fXAfterRotated = (float)((CenterX) + ((fGaugeCenterX - CenterX) * Math.Cos(Angle * Math.PI / 180)) -
                    //((fGaugeCenterY - CenterY) * Math.Sin(Angle * Math.PI / 180)));

                    //   float fYAfterRotated = (float)((CenterY) + ((fGaugeCenterX - CenterX) * Math.Sin(Angle * Math.PI / 180)) +
                    //    ((fGaugeCenterY - CenterY) * Math.Cos(Angle * Math.PI / 180)));

                    //   CenterPointOffsetX = //-(int)(m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalCenterX - m_objSubTh1_RotateROI.ref_ROITotalCenterX);
                    //   -(int)(m_fCenterX - (fXAfterRotated));
                    //   CenterPointOffsetY = //-(int)(m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROITotalCenterY - m_objSubTh1_RotateROI.ref_ROITotalCenterY);
                    //   -(int)(m_fCenterY - (fYAfterRotated));

                }
                int intOffsetX;
                int intOffsetY;

                if (m_smVisionInfo.g_blnWantGauge)  // Mean during mark inspection, orient gauge is used to measure unit position for m_objMarkTrainROI
                {
                    intOffsetX = m_objMarkTrainROI.ref_ROITotalX;
                    intOffsetY = m_objMarkTrainROI.ref_ROITotalY;
                }
                else if (m_smVisionInfo.g_arrMarkROIs[0].Count > 3)    // Mean during mark inspection, Unit PR is used to find unit surface position for m_objMarkTrainROI
                {
                    intOffsetX = m_objMarkTrainROI.ref_ROITotalX;
                    intOffsetY = m_objMarkTrainROI.ref_ROITotalY;
                }
                else // Mean during mark inspection, m_objMarkSearchROI is used.
                {
                    intOffsetX = m_objMarkTrainROI.ref_ROITotalX;
                    intOffsetY = m_objMarkTrainROI.ref_ROITotalY;
                }
                for (int i = 0; i < intNumChars; i++)
                {
                    int intRectStartX, intRectStartY, intRectEndX, intRectEndY;
                    intRectStartX = intRectStartY = intRectEndX = intRectEndY = 0;
                    m_smVisionInfo.g_arrMarks[0].GetCharStartXY(i, ref intStartX, ref intStartY);
                    m_smVisionInfo.g_arrMarks[0].GetCharEndXY(i, ref intEndX, ref intEndY);

                    if (m_smVisionInfo.g_arrMarks[0].ref_blnWantDontCareIgnoredMarkWholeArea && !m_smVisionInfo.g_arrMarks[0].GetEnableMarkSetting(i))
                    {
                        //2021-01-18 ZJYEOH : Should use sample position
                        Point pStartTemplate = new Point(intStartX, intStartY);//m_smVisionInfo.g_arrMarks[0].GetTemplateCharROIStartPoint(i);
                        Point pEndTemplate = new Point(intEndX, intEndY);//m_smVisionInfo.g_arrMarks[0].GetTemplateCharROIEndPoint(i);

                        if ((intOffsetX + pStartTemplate.X - m_smVisionInfo.g_arrMarks[0].GetTemplateCharShiftX(i)) >= 0)
                            intRectStartX = intOffsetX + pStartTemplate.X - m_smVisionInfo.g_arrMarks[0].GetTemplateCharShiftX(i);
                        else
                            intRectStartX = intOffsetX;

                        if ((intOffsetY + pStartTemplate.Y - m_smVisionInfo.g_arrMarks[0].GetTemplateCharShiftY(i)) >= 0)
                            intRectStartY = intOffsetY + pStartTemplate.Y - m_smVisionInfo.g_arrMarks[0].GetTemplateCharShiftY(i);
                        else
                            intRectStartY = intOffsetY;

                        if ((intOffsetX + pEndTemplate.X + m_smVisionInfo.g_arrMarks[0].GetTemplateCharShiftX(i)) < m_smVisionInfo.g_intCameraResolutionWidth)
                            intRectEndX = intOffsetX + pEndTemplate.X + m_smVisionInfo.g_arrMarks[0].GetTemplateCharShiftX(i);
                        else
                            continue;
                        if ((intOffsetY + pEndTemplate.Y + m_smVisionInfo.g_arrMarks[0].GetTemplateCharShiftY(i)) < m_smVisionInfo.g_intCameraResolutionHeight)
                            intRectEndY = intOffsetY + pEndTemplate.Y + m_smVisionInfo.g_arrMarks[0].GetTemplateCharShiftY(i);
                        else
                            continue;
                    }
                    else
                    {
                        // 2019 10 11 - CCENG   : add intOffsetXY checking because rectangle will be filled on m_objPkgViewImage (Full image)
                        //                      : without the intOffsetXY, intRectStartX will set to intOffsetX and fill position may be shifted
                        if ((intOffsetX + intStartX - intCharDilateHalfWidth) >= 0)  //if ((intStartX - intCharDilateHalfWidth) >= 0)
                            intRectStartX = intOffsetX + intStartX - intCharDilateHalfWidth + CenterPointOffsetX;
                        else
                            intRectStartX = intOffsetX + CenterPointOffsetX;

                        // 2019 10 11 - CCENG   : add intOffsetXY checking because rectangle will be filled on m_objPkgViewImage (Full image)
                        //                      : without the intOffsetXY, intRectStartX will set to intOffsetX and fill position may be shifted
                        if ((intOffsetY + intStartY - intCharDilateHalfWidth) >= 0)    //if ((intStartY - intCharDilateHalfWidth) >= 0)
                            intRectStartY = intOffsetY + intStartY - intCharDilateHalfWidth + CenterPointOffsetY;
                        else
                            intRectStartY = intOffsetY + CenterPointOffsetY;

                        if ((intEndX + intCharDilateHalfWidth) < m_smVisionInfo.g_intCameraResolutionWidth)
                            intRectEndX = intOffsetX + intEndX + intCharDilateHalfWidth + CenterPointOffsetX;
                        else
                            intRectEndX = intOffsetX + intEndX + CenterPointOffsetX;

                        if ((intEndY + intCharDilateHalfWidth) < m_smVisionInfo.g_intCameraResolutionHeight)
                            intRectEndY = intOffsetY + intEndY + intCharDilateHalfWidth + CenterPointOffsetY;
                        else
                            intRectEndY = intOffsetY + intEndY + CenterPointOffsetY;
                    }

                    if (m_smVisionInfo.g_arrImages.Count > 2) // when mark image present
                        Shape.FillRectangle(m_objMarkViewImage, intRectStartX, intRectStartY, intRectEndX, intRectEndY, 0);

                    m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].SetDontCareArea(intRectStartX, intRectStartY, intRectEndX, intRectEndY);
                }
            }

            if ((m_smCustomizeInfo.g_intWant2DCode & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
            {
                if (m_smVisionInfo.g_blnWantMark2DCode)
                {
                    // ---------- Fill 2D code area with black color -------------------
                    int intStartX = 0, intStartY = 0, intEndX = 0, intEndY = 0;

                    int intOffsetX;
                    int intOffsetY;

                    if (m_smVisionInfo.g_blnWantGauge)  // Mean during mark inspection, orient gauge is used to measure unit position for m_objMark2DCodeROI
                    {
                        intOffsetX = m_objMark2DCodeROI.ref_ROITotalX;
                        intOffsetY = m_objMark2DCodeROI.ref_ROITotalY;
                    }
                    else if (m_smVisionInfo.g_arrMarkROIs[0].Count > 3)    // Mean during mark inspection, Unit PR is used to find unit surface position for m_objMark2DCodeROI
                    {
                        intOffsetX = m_objMark2DCodeROI.ref_ROITotalX;
                        intOffsetY = m_objMark2DCodeROI.ref_ROITotalY;
                    }
                    else // Mean during mark inspection, m_objMarkSearchROI is used.
                    {
                        intOffsetX = m_objMark2DCodeROI.ref_ROITotalX;
                        intOffsetY = m_objMark2DCodeROI.ref_ROITotalY;
                    }

                    int intRectStartX, intRectStartY, intRectEndX, intRectEndY;
                    intRectStartX = intRectStartY = intRectEndX = intRectEndY = 0;

                    m_smVisionInfo.g_arrMarks[0].Get2DCodeStartEndXY(ref intStartX, ref intStartY, ref intEndX, ref intEndY);

                    intRectStartX = intOffsetX + intStartX;
                    intRectStartY = intOffsetY + intStartY;
                    intRectEndX = intOffsetX + intEndX;
                    intRectEndY = intOffsetY + intEndY;

                    if (m_smVisionInfo.g_arrImages.Count > 2) // when mark image present
                        Shape.FillRectangle(m_objMarkViewImage, intRectStartX, intRectStartY, intRectEndX, intRectEndY, 0);

                    m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].SetDontCareArea(intRectStartX, intRectStartY, intRectEndX, intRectEndY);
                }
            }

            // ----------- Define the actual location for unit and place the package roi on that location. ------------------------
            ROI objMarkViewROI = null;
            if (m_smVisionInfo.g_arrImages.Count > 2) // when mark image present
            {
                objMarkViewROI = new ROI();
                objMarkViewROI.LoadROISetting((int)Math.Round((fGaugeCenterX -
                                             fGaugeWidth / 2 +
                                             m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromLeft), 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round((fGaugeCenterY -
                                             fGaugeHeight / 2 +
                                             m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromEdge), 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round(fGaugeWidth - m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromRight - m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromLeft, 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round(fGaugeHeight - m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromEdge - m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromBottom, 0, MidpointRounding.AwayFromZero));
                objMarkViewROI.AttachImage(m_objMarkViewImage);
            }

            if (m_smVisionInfo.g_blnWantDontCareArea_Package)
            {
                if (m_smVisionInfo.g_arrImages.Count > 2)
                {
                    ////Draw don't care ROI edge to make sure Don't Care Area is not inspected
                    //for (int k = 3; k < m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit].Count; k++)
                    //{
                    //    m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][k].AttachImage(objMarkViewROI);
                    //    ROI objROI = new ROI();
                    //    objROI.LoadROISetting((int)Math.Round((fGaugeCenterX - fGaugeWidth / 2 + m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][k].ref_ROIPositionX), 0, MidpointRounding.AwayFromZero),
                    //                          (int)Math.Round((fGaugeCenterY - fGaugeHeight / 2 + m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][k].ref_ROIPositionY), 0, MidpointRounding.AwayFromZero),
                    //                           m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][k].ref_ROIWidth, m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][k].ref_ROIHeight);
                    //    objROI.AttachImage(m_smVisionInfo.g_objWhiteImage);
                    //    ROI.SubtractROI(m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][k], objROI);
                    //    //objPkgViewROI.SaveImage("D:\\aaa.bmp");
                    //    objROI.Dispose();
                    //}

                    ROI objDontCareROI = new ROI();
                    //objDontCareROI.LoadROISetting(0, 0, objMarkViewROI.ref_ROIWidth, objMarkViewROI.ref_ROIHeight);
                    // 2020 06 27 - CCENG: objDontCareROI have to start from Package Tolerance bcos g_objDontCareImage_Package_Bright template is start from Package Size Template.
                    objDontCareROI.LoadROISetting(m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromLeft,
                             m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromEdge,
                             objMarkViewROI.ref_ROIWidth, objMarkViewROI.ref_ROIHeight);
                    objDontCareROI.AttachImage(m_smVisionInfo.g_objDontCareImage_Package_Bright);
                    ROI.SubtractROI(objMarkViewROI, objDontCareROI);
                    objDontCareROI.Dispose();
                }
            }

            //objMarkViewROI.SaveImage("D:\\TS\\objMarkViewROI.bmp");
            //m_objMarkViewImage.SaveImage("D:\\TS\\m_objMarkViewImage.bmp");

            if (!m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].DoInspection_MarkLightView(objMarkViewROI,      // Package Test on first image
                                                                           m_objMarkViewImage)) // First package image

            {
                m_smVisionInfo.g_strErrorMessage += m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_strErrorMessage;
                if (blnAuto)
                {
                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    {
                        m_blnPackageFail_Out = true;
                        if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                            if (m_intTCPIPResultID == -1)
                                SetPackageResultID(m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailResultMask);
                    }
                    else
                    {
                        m_objVisionIO.PackageFail.SetOn(strTrackHeadName + " PackageFail 15"); if (m_smVisionInfo.g_blnTrackIO) STTrackLog.WriteLine("IO-PackageFail-Set ON 37");
                    }

                    SaveRejectImage_AddToBuffer("Package", m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_strErrorMessage);

                    m_smVisionInfo.g_intPkgDefectFailureTotal++;
                }
                blnResult = false;
            }
            
            objMarkViewROI.Dispose();

            return blnResult;
        }

        private bool StartPackageTest_SideLightView(bool blnAuto)
        {
            bool blnResult = true;
            bool blnWantDebug = false;

            if ((m_smCustomizeInfo.g_intWantPackage & (1 << m_smVisionInfo.g_intVisionPos)) == 0 || !m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetWantInspectPackage())
                return true;

            // Check is templates learnt
            if (m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit].Count == 0)
            {
                m_smVisionInfo.g_strErrorMessage += "*Package : No Template Found";
                if (blnAuto)
                {
                    m_smVisionInfo.g_intNoTemplateFailureTotal++;
                }
                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        SetPackageResultID(m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailResultMask);

                return false;
            }

            // Make sure template unit size not set to zero
            if ((m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_fUnitWidthMin == 0 || m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_fUnitHeightMin == 0) ||
                (m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_fUnitWidthMax == 0 || m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_fUnitHeightMax == 0))
            {
                m_smVisionInfo.g_strErrorMessage += "*Package : Template Unit Size Min Max Setting cannot be zero.";
                if (blnAuto)
                {
                    m_smVisionInfo.g_intPackageFailureTotal++;
                }
                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        m_intTCPIPResultID = (int)TCPIPResulID.FailPackage;//FailPackageDimension;

                return false;
            }



            // ------------- Make sure grab image done ------------------------
            int intSideLightViewImageIndex = m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetGrabImageIndex(2);     // Side light View
            if (intSideLightViewImageIndex == 0)
                WaitEventDone(ref m_bGrabImage1Done, true, 10000, "StartPackageSizeTest>m_bGrabImage1Done b");
            else if (intSideLightViewImageIndex == 1)
                WaitEventDone(ref m_bGrabImage2Done, true, 10000, "StartPackageSizeTest>m_bGrabImage2Done b");
            else if (intSideLightViewImageIndex == 2)
                WaitEventDone(ref m_bGrabImage3Done, true, 10000, "StartPackageSizeTest>m_bGrabImage3Done b");
            else if (intSideLightViewImageIndex == 3)
                WaitEventDone(ref m_bGrabImage4Done, true, 10000, "StartPackageSizeTest>m_bGrabImage4Done b");
            else if (intSideLightViewImageIndex == 4)
                WaitEventDone(ref m_bGrabImage5Done, true, 10000, "StartPackageSizeTest>m_bGrabImage5Done b");
            else if (intSideLightViewImageIndex == 5)
                WaitEventDone(ref m_bGrabImage6Done, true, 10000, "StartPackageSizeTest>m_bGrabImage6Done b");
            else if (intSideLightViewImageIndex == 6)
                WaitEventDone(ref m_bGrabImage7Done, true, 10000, "StartPackageSizeTest>m_bGrabImage7Done b");
            else
            {
                m_smVisionInfo.g_strErrorMessage += "*Package : Wrong setting for package (Side Light View) image number. intSideLightViewImageIndex = " + intSideLightViewImageIndex.ToString();
                if (blnAuto)
                {
                    m_smVisionInfo.g_intPackageFailureTotal++;
                }
                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        SetPackageResultID(m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailResultMask);

                return false;
            }

            //2020-06-18 ZJYEOH : wait image used for dark field 2 grab done
            int intSideLightViewImageIndex_DarkField2 = m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetGrabImageIndex(4);
            int intSideLightViewImageIndex_DarkField3 = m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetGrabImageIndex(6);
            int intSideLightViewImageIndex_DarkField4 = m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetGrabImageIndex(7);

            if (intSideLightViewImageIndex_DarkField2 == 0)
                WaitEventDone(ref m_bGrabImage1Done, true, 10000, "StartPackageSizeTest>m_bGrabImage1Done e");
            else if (intSideLightViewImageIndex_DarkField2 == 1)
                WaitEventDone(ref m_bGrabImage2Done, true, 10000, "StartPackageSizeTest>m_bGrabImage2Done e");
            else if (intSideLightViewImageIndex_DarkField2 == 2)
                WaitEventDone(ref m_bGrabImage3Done, true, 10000, "StartPackageSizeTest>m_bGrabImage3Done e");
            else if (intSideLightViewImageIndex_DarkField2 == 3)
                WaitEventDone(ref m_bGrabImage4Done, true, 10000, "StartPackageSizeTest>m_bGrabImage4Done e");
            else if (intSideLightViewImageIndex_DarkField2 == 4)
                WaitEventDone(ref m_bGrabImage5Done, true, 10000, "StartPackageSizeTest>m_bGrabImage5Done e");
            else if (intSideLightViewImageIndex_DarkField2 == 5)
                WaitEventDone(ref m_bGrabImage6Done, true, 10000, "StartPackageSizeTest>m_bGrabImage6Done e");
            else if (intSideLightViewImageIndex_DarkField2 == 6)
                WaitEventDone(ref m_bGrabImage7Done, true, 10000, "StartPackageSizeTest>m_bGrabImage7Done e");
            else
            {
                m_smVisionInfo.g_strErrorMessage += "*Package : Wrong setting for package (Side Light View - Dark Field 2) image number. intSideLightViewDarkField2ImageIndex = " + intSideLightViewImageIndex_DarkField2.ToString();
                if (blnAuto)
                {
                    m_smVisionInfo.g_intPackageFailureTotal++;
                }
                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        SetPackageResultID(m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailResultMask);

                return false;
            }

            if (intSideLightViewImageIndex_DarkField3 == 0)
                WaitEventDone(ref m_bGrabImage1Done, true, 10000, "StartPackageSizeTest>m_bGrabImage1Done e");
            else if (intSideLightViewImageIndex_DarkField3 == 1)
                WaitEventDone(ref m_bGrabImage2Done, true, 10000, "StartPackageSizeTest>m_bGrabImage2Done e");
            else if (intSideLightViewImageIndex_DarkField3 == 2)
                WaitEventDone(ref m_bGrabImage3Done, true, 10000, "StartPackageSizeTest>m_bGrabImage3Done e");
            else if (intSideLightViewImageIndex_DarkField3 == 3)
                WaitEventDone(ref m_bGrabImage4Done, true, 10000, "StartPackageSizeTest>m_bGrabImage4Done e");
            else if (intSideLightViewImageIndex_DarkField3 == 4)
                WaitEventDone(ref m_bGrabImage5Done, true, 10000, "StartPackageSizeTest>m_bGrabImage5Done e");
            else if (intSideLightViewImageIndex_DarkField3 == 5)
                WaitEventDone(ref m_bGrabImage6Done, true, 10000, "StartPackageSizeTest>m_bGrabImage6Done e");
            else if (intSideLightViewImageIndex_DarkField3 == 6)
                WaitEventDone(ref m_bGrabImage7Done, true, 10000, "StartPackageSizeTest>m_bGrabImage7Done e");
            else
            {
                m_smVisionInfo.g_strErrorMessage += "*Package : Wrong setting for package (Side Light View - Dark Field 3) image number. intSideLightViewDarkField3ImageIndex = " + intSideLightViewImageIndex_DarkField3.ToString();
                if (blnAuto)
                {
                    m_smVisionInfo.g_intPackageFailureTotal++;
                }
                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        SetPackageResultID(m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailResultMask);

                return false;
            }

            if (intSideLightViewImageIndex_DarkField4 == 0)
                WaitEventDone(ref m_bGrabImage1Done, true, 10000, "StartPackageSizeTest>m_bGrabImage1Done e");
            else if (intSideLightViewImageIndex_DarkField4 == 1)
                WaitEventDone(ref m_bGrabImage2Done, true, 10000, "StartPackageSizeTest>m_bGrabImage2Done e");
            else if (intSideLightViewImageIndex_DarkField4 == 2)
                WaitEventDone(ref m_bGrabImage3Done, true, 10000, "StartPackageSizeTest>m_bGrabImage3Done e");
            else if (intSideLightViewImageIndex_DarkField4 == 3)
                WaitEventDone(ref m_bGrabImage4Done, true, 10000, "StartPackageSizeTest>m_bGrabImage4Done e");
            else if (intSideLightViewImageIndex_DarkField4 == 4)
                WaitEventDone(ref m_bGrabImage5Done, true, 10000, "StartPackageSizeTest>m_bGrabImage5Done e");
            else if (intSideLightViewImageIndex_DarkField4 == 5)
                WaitEventDone(ref m_bGrabImage6Done, true, 10000, "StartPackageSizeTest>m_bGrabImage6Done e");
            else if (intSideLightViewImageIndex_DarkField4 == 6)
                WaitEventDone(ref m_bGrabImage7Done, true, 10000, "StartPackageSizeTest>m_bGrabImage7Done e");
            else
            {
                m_smVisionInfo.g_strErrorMessage += "*Package : Wrong setting for package (Side Light View - Dark Field 4) image number. intSideLightViewDarkField4ImageIndex = " + intSideLightViewImageIndex_DarkField4.ToString();
                if (blnAuto)
                {
                    m_smVisionInfo.g_intPackageFailureTotal++;
                }
                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        SetPackageResultID(m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailResultMask);

                return false;
            }

            //2020-12-18 ZJYEOH : wait image used for MoldFlash grab done
            int intMoldFlashViewImageIndex = m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetGrabImageIndex(5);
            if (intMoldFlashViewImageIndex == 0)
                WaitEventDone(ref m_bGrabImage1Done, true, 10000, "StartPackageSizeTest>m_bGrabImage1Done c");
            else if (intMoldFlashViewImageIndex == 1)
                WaitEventDone(ref m_bGrabImage2Done, true, 10000, "StartPackageSizeTest>m_bGrabImage2Done c");
            else if (intMoldFlashViewImageIndex == 2)
                WaitEventDone(ref m_bGrabImage3Done, true, 10000, "StartPackageSizeTest>m_bGrabImage3Done c");
            else if (intMoldFlashViewImageIndex == 3)
                WaitEventDone(ref m_bGrabImage4Done, true, 10000, "StartPackageSizeTest>m_bGrabImage4Done c");
            else if (intMoldFlashViewImageIndex == 4)
                WaitEventDone(ref m_bGrabImage5Done, true, 10000, "StartPackageSizeTest>m_bGrabImage5Done c");
            else if (intMoldFlashViewImageIndex == 5)
                WaitEventDone(ref m_bGrabImage6Done, true, 10000, "StartPackageSizeTest>m_bGrabImage6Done c");
            else if (intMoldFlashViewImageIndex == 6)
                WaitEventDone(ref m_bGrabImage7Done, true, 10000, "StartPackageSizeTest>m_bGrabImage7Done c");
            else
            {
                m_smVisionInfo.g_strErrorMessage += "*Package : Wrong setting for package (Side Light View - Dark Field 2) image number. intMoldFlashViewImageIndex = " + intMoldFlashViewImageIndex.ToString();
                if (blnAuto)
                {
                    m_smVisionInfo.g_intPackageFailureTotal++;
                }
                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        SetPackageResultID(m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailResultMask);

                return false;
            }

            // 2019 03 07 - ZJYeoh: Wait m_intOrientAngle value from StartOrientTest First
            //if (intSideLightViewImageIndex > 0)   
            WaitEventDone(ref m_blnOrientDataUpdated, true, 10000, "StartPackageTest > m_blnOrientDataUpdated 10");


            // ---------  Rotate image 2 and 3 to oriented 0 deg -------------
            if (m_objGauge_PkgSideView == null)
            {
                m_objGauge_PkgSideView = new RectGaugeM4L(m_smVisionInfo.g_WorldShape, 0, m_smVisionInfo.g_intVisionIndex);
            }

            float fGaugeCenterX = 0, fGaugeCenterY = 0, fGaugeWidth = 0, fGaugeHeight = 0, fGaugeAngle = 0;

            if (m_smVisionInfo.g_blnWantGauge && (intSideLightViewImageIndex == 0 || (intSideLightViewImageIndex_DarkField2 == 0 && m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_blnSeperateDarkField2DefectSetting) ||
                (intSideLightViewImageIndex_DarkField3 == 0 && m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_blnSeperateDarkField3DefectSetting) ||
                (intSideLightViewImageIndex_DarkField4 == 0 && m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_blnSeperateDarkField4DefectSetting) ||
                (intMoldFlashViewImageIndex == 0 && m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_blnSeperateMoldFlashDefectSetting)))
            {
                if (m_blnWantOrientTest)
                    m_smVisionInfo.g_arrOrientGaugeM4L[0].CopyTo(ref m_objGauge_PkgSideView);
                else
                    m_smVisionInfo.g_arrMarkGaugeM4L[0].CopyTo(ref m_objGauge_PkgSideView); // 2019-09-18 ZJYEOH : Changed g_arrPackageGaugeM4L to g_arrMarkGaugeM4L, if got use mark gauge and intSideLightViewImageIndex == 0

                int[] arrUserSelectImageViewIndex = m_objGauge_PkgSideView.GetGaugeImageNoList();

                if (!WaitEventDone(arrUserSelectImageViewIndex, "arrUserSelectImageViewIndex 6475"))
                {
                    m_smVisionInfo.g_strErrorMessage += "*Package : Wrong setting for package size image number.";
                    if (blnAuto)
                    {
                        m_smVisionInfo.g_intPackageFailureTotal++;
                    }
                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        if (m_intTCPIPResultID == -1)
                            SetPackageResultID(m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailResultMask);

                    return false;
                }

                if (!GaugeMeasureUnit(m_objGauge_PkgSideView, m_smVisionInfo.g_arrImages))
                {
                    m_smVisionInfo.g_strErrorMessage += "*Package : " + m_objGauge_PkgSideView.ref_strErrorMessage;
                    if (blnAuto)
                    {
                        m_smVisionInfo.g_intPackageFailureTotal++;
                    }
                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        if (m_intTCPIPResultID == -1)
                            SetPackageResultID(m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailResultMask);

                    return false;
                }
                fGaugeCenterX = m_objGauge_PkgSideView.ref_pRectCenterPoint.X;
                fGaugeCenterY = m_objGauge_PkgSideView.ref_pRectCenterPoint.Y;
                fGaugeWidth = m_objGauge_PkgSideView.ref_fRectWidth;
                fGaugeHeight = m_objGauge_PkgSideView.ref_fRectHeight;
                fGaugeAngle = m_objGauge_PkgSideView.ref_fRectAngle;
            }
            else
            {
                WaitEventDone(ref m_bPackageSizeTestDone, true, 10000, "StartPackageSizeTest > m_bPackageSizeTestDone c");
                fGaugeCenterX = m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X;
                fGaugeCenterY = m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y;
                fGaugeWidth = m_smVisionInfo.g_objGauge_PkgSize.ref_fRectWidth;
                fGaugeHeight = m_smVisionInfo.g_objGauge_PkgSize.ref_fRectHeight;
                fGaugeAngle = m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle;
            }


            float fTotalRotateAngle = m_intOrientAngle + fGaugeAngle;
            float fTotalRotateMarkAngle;
            if (m_smVisionInfo.g_arrMarks[0].ref_blnCheckMark)
            {
                fTotalRotateMarkAngle = m_intOrientAngle + m_smVisionInfo.g_arrOrients[0][m_smVisionInfo.g_intSelectedOcv[0]].ref_fDegAngleResult;
            }
            else
            {
                fTotalRotateMarkAngle = fTotalRotateAngle;
            }

            // Get RotateROI center point where the ROI center point == Unit Center Point
            m_objSubTh2_RotateROI.LoadROISetting(
                        (int)Math.Round(fGaugeCenterX -
                        m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][0].ref_ROIWidth / 2, 0, MidpointRounding.AwayFromZero),
                        (int)Math.Round(fGaugeCenterY -
                        m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][0].ref_ROIHeight / 2, 0, MidpointRounding.AwayFromZero),
                        m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][0].ref_ROIWidth,
                        m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][0].ref_ROIHeight);

            // Rotate image
            if (intSideLightViewImageIndex == 0)
            {
                /* 2019 07 14 - CCENG: 
                 * if g_blnWantGauge is false, mean Image 1 is rotated according to Orient Matching Angle, which is not 100% correct,
                 * because the Orient Matching Angle and Unit Angle may be different.
                 * So when come to Image 1 package size test, Image 1 need to be re-rotated  according to Package size result angle.
                 */
                if (m_smVisionInfo.g_blnWantGauge)
                {
                    // Wait StartOrientTest rotate image 1 done or mark test done. (sometime rotate image 1 done will not set to true if Orient fail).
                    WaitEventDone(ref m_blnRotateImage1Updated, ref m_bSubTh_MarkTest, true, false, "StartPackageTest_SideLightView > m_blnRotateImage1Updated 6542");
                }
                else
                {
                    // Since Mark Test Image index and side light package view image index are same, then need to Wait for Marktest done because Rotated image need to be tested by mark inspection function. After mark inspection, then only allow to re-rotate again using packge angle.
                    WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartPackageTest > m_bSubTh_MarkTest 6547");

                    if (!m_bSubTh_MarkTest_Result)
                    {
                        return false;   // Skip package inspection if mark test fail.
                    }

                    m_objSubTh2_RotateROI.AttachImage(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex]);
                    ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex], m_objSubTh2_RotateROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_PkgBright, ref m_smVisionInfo.g_arrRotatedImages, intSideLightViewImageIndex);

                    if (m_blnCustomWantColor && !GetColorImageRotated(intSideLightViewImageIndex) && !ContainColorSelectedImage(intSideLightViewImageIndex, m_smVisionInfo.g_intSelectedUnit))
                    {
                        CROI objColorRotatedROI = new CROI();
                        objColorRotatedROI.AttachImage(m_smVisionInfo.g_arrColorImages[intSideLightViewImageIndex]);

                        // Get RotateROI center point where the ROI center point == Package Unit Center Point
                        objColorRotatedROI.LoadROISetting(m_objSubTh2_RotateROI.ref_ROIPositionX,
                                                     m_objSubTh2_RotateROI.ref_ROIPositionY,
                                                     m_objSubTh2_RotateROI.ref_ROIWidth,
                                                     m_objSubTh2_RotateROI.ref_ROIHeight);

                        CROI.Rotate0Degree(m_smVisionInfo.g_arrColorImages[intSideLightViewImageIndex], objColorRotatedROI, fTotalRotateAngle, 4, ref m_smVisionInfo.g_arrColorRotatedImages, intSideLightViewImageIndex);

                        SetColorImageRotated(intSideLightViewImageIndex);
                        objColorRotatedROI.Dispose();
                    }
                }

            }
            else
            {
                // Rotate imgae 2
                m_objSubTh2_RotateROI.AttachImage(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex]);
                ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex], m_objSubTh2_RotateROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_PkgBright, ref m_smVisionInfo.g_arrRotatedImages, intSideLightViewImageIndex);

                if (m_blnCustomWantColor && !GetColorImageRotated(intSideLightViewImageIndex) && !ContainColorSelectedImage(intSideLightViewImageIndex, m_smVisionInfo.g_intSelectedUnit))
                {
                    CROI objColorRotatedROI = new CROI();
                    objColorRotatedROI.AttachImage(m_smVisionInfo.g_arrColorImages[intSideLightViewImageIndex]);

                    // Get RotateROI center point where the ROI center point == Package Unit Center Point
                    objColorRotatedROI.LoadROISetting(m_objSubTh2_RotateROI.ref_ROIPositionX,
                                                 m_objSubTh2_RotateROI.ref_ROIPositionY,
                                                 m_objSubTh2_RotateROI.ref_ROIWidth,
                                                 m_objSubTh2_RotateROI.ref_ROIHeight);

                    CROI.Rotate0Degree(m_smVisionInfo.g_arrColorImages[intSideLightViewImageIndex], objColorRotatedROI, fTotalRotateAngle, 4, ref m_smVisionInfo.g_arrColorRotatedImages, intSideLightViewImageIndex);

                    SetColorImageRotated(intSideLightViewImageIndex);
                    objColorRotatedROI.Dispose();
                }
            }

            if (intSideLightViewImageIndex == 0)
                m_blnRotateImage1Updated = true;
            else if (intSideLightViewImageIndex == 1)
                m_blnRotateImage2Updated = true;
            else if (intSideLightViewImageIndex == 2)
                m_blnRotateImage3Updated = true;
            else if (intSideLightViewImageIndex == 3)
                m_blnRotateImage4Updated = true;
            else if (intSideLightViewImageIndex == 4)
                m_blnRotateImage5Updated = true;
            else if (intSideLightViewImageIndex == 5)
                m_blnRotateImage6Updated = true;
            else
                m_blnRotateImage7Updated = true;

            // 2020-06-18 ZJYEOH : If not same image selected, need rotate another image
            if (intSideLightViewImageIndex != intSideLightViewImageIndex_DarkField2 && m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_blnSeperateDarkField2DefectSetting
                || intSideLightViewImageIndex != intSideLightViewImageIndex_DarkField3 && m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_blnSeperateDarkField3DefectSetting
                || intSideLightViewImageIndex != intSideLightViewImageIndex_DarkField4 && m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_blnSeperateDarkField4DefectSetting)
            {
                if (intSideLightViewImageIndex_DarkField2 == 0 || intSideLightViewImageIndex_DarkField3 == 0 || intSideLightViewImageIndex_DarkField4 == 0)
                {
                    /* 2019 07 14 - CCENG: 
                     * if g_blnWantGauge is false, mean Image 1 is rotated according to Orient Matching Angle, which is not 100% correct,
                     * because the Orient Matching Angle and Unit Angle may be different.
                     * So when come to Image 1 package size test, Image 1 need to be re-rotated  according to Package size result angle.
                     */
                    if (m_smVisionInfo.g_blnWantGauge)
                    {
                        // Wait StartOrientTest rotate image 1 done or mark test done. (sometime rotate image 1 done will not set to true if Orient fail).
                        WaitEventDone(ref m_blnRotateImage1Updated, ref m_bSubTh_MarkTest, true, false, "StartPackageTest_SideLightView > m_blnRotateImage1Updated 6594");
                    }
                    else
                    {
                        // Since Mark Test Image index and side light package view image index are same, then need to Wait for Marktest done because Rotated image need to be tested by mark inspection function. After mark inspection, then only allow to re-rotate again using packge angle.
                        WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartPackageTest > m_bSubTh_MarkTest 6599");

                        if (!m_bSubTh_MarkTest_Result)
                        {
                            return false;   // Skip package inspection if mark test fail.
                        }

                        if (m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_blnSeperateDarkField2DefectSetting)
                        {
                            m_objSubTh2_RotateROI.AttachImage(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex_DarkField2]);
                            ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex_DarkField2], m_objSubTh2_RotateROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_PkgBright, ref m_smVisionInfo.g_arrRotatedImages, intSideLightViewImageIndex_DarkField2);
                        }

                        if (m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_blnSeperateDarkField3DefectSetting)
                        {
                            m_objSubTh2_RotateROI.AttachImage(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex_DarkField3]);
                            ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex_DarkField3], m_objSubTh2_RotateROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_PkgBright, ref m_smVisionInfo.g_arrRotatedImages, intSideLightViewImageIndex_DarkField3);
                        }

                        if (m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_blnSeperateDarkField4DefectSetting)
                        {
                            m_objSubTh2_RotateROI.AttachImage(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex_DarkField4]);
                            ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex_DarkField4], m_objSubTh2_RotateROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_PkgBright, ref m_smVisionInfo.g_arrRotatedImages, intSideLightViewImageIndex_DarkField4);
                        }

                        if (m_blnCustomWantColor && !GetColorImageRotated(intSideLightViewImageIndex_DarkField2) && !ContainColorSelectedImage(intSideLightViewImageIndex_DarkField2, m_smVisionInfo.g_intSelectedUnit)
                            || m_blnCustomWantColor && !GetColorImageRotated(intSideLightViewImageIndex_DarkField3) && !ContainColorSelectedImage(intSideLightViewImageIndex_DarkField3, m_smVisionInfo.g_intSelectedUnit)
                            || m_blnCustomWantColor && !GetColorImageRotated(intSideLightViewImageIndex_DarkField4) && !ContainColorSelectedImage(intSideLightViewImageIndex_DarkField4, m_smVisionInfo.g_intSelectedUnit))

                        {
                            CROI objColorRotatedROI = new CROI();

                            if (m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_blnSeperateDarkField2DefectSetting)
                            {
                                objColorRotatedROI.AttachImage(m_smVisionInfo.g_arrColorImages[intSideLightViewImageIndex_DarkField2]);
                                // Get RotateROI center point where the ROI center point == Package Unit Center Point
                                objColorRotatedROI.LoadROISetting(m_objSubTh2_RotateROI.ref_ROIPositionX,
                                m_objSubTh2_RotateROI.ref_ROIPositionY,
                                m_objSubTh2_RotateROI.ref_ROIWidth,
                                m_objSubTh2_RotateROI.ref_ROIHeight);
                                CROI.Rotate0Degree(m_smVisionInfo.g_arrColorImages[intSideLightViewImageIndex_DarkField2], objColorRotatedROI, fTotalRotateAngle, 4, ref m_smVisionInfo.g_arrColorRotatedImages, intSideLightViewImageIndex_DarkField2);
                                SetColorImageRotated(intSideLightViewImageIndex_DarkField2);
                            }

                            if (m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_blnSeperateDarkField3DefectSetting)
                            {
                                objColorRotatedROI.AttachImage(m_smVisionInfo.g_arrColorImages[intSideLightViewImageIndex_DarkField3]);
                                objColorRotatedROI.LoadROISetting(m_objSubTh2_RotateROI.ref_ROIPositionX,
                                m_objSubTh2_RotateROI.ref_ROIPositionY,
                                m_objSubTh2_RotateROI.ref_ROIWidth,
                                m_objSubTh2_RotateROI.ref_ROIHeight);
                                CROI.Rotate0Degree(m_smVisionInfo.g_arrColorImages[intSideLightViewImageIndex_DarkField3], objColorRotatedROI, fTotalRotateAngle, 4, ref m_smVisionInfo.g_arrColorRotatedImages, intSideLightViewImageIndex_DarkField3);
                                SetColorImageRotated(intSideLightViewImageIndex_DarkField3);
                            }

                            if (m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_blnSeperateDarkField4DefectSetting)
                            {
                                objColorRotatedROI.AttachImage(m_smVisionInfo.g_arrColorImages[intSideLightViewImageIndex_DarkField4]);
                                objColorRotatedROI.LoadROISetting(m_objSubTh2_RotateROI.ref_ROIPositionX,
                                m_objSubTh2_RotateROI.ref_ROIPositionY,
                                m_objSubTh2_RotateROI.ref_ROIWidth,
                                m_objSubTh2_RotateROI.ref_ROIHeight);
                                CROI.Rotate0Degree(m_smVisionInfo.g_arrColorImages[intSideLightViewImageIndex_DarkField4], objColorRotatedROI, fTotalRotateAngle, 4, ref m_smVisionInfo.g_arrColorRotatedImages, intSideLightViewImageIndex_DarkField4);
                                SetColorImageRotated(intSideLightViewImageIndex_DarkField4);
                            }
                            objColorRotatedROI.Dispose();
                        }
                    }

                }
                else
                {
                    // Rotate imgae 2
                    if (m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_blnSeperateDarkField2DefectSetting)
                    {
                        m_objSubTh2_RotateROI.AttachImage(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex_DarkField2]);
                        ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex_DarkField2], m_objSubTh2_RotateROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_PkgBright, ref m_smVisionInfo.g_arrRotatedImages, intSideLightViewImageIndex_DarkField2);
                    }

                    if (m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_blnSeperateDarkField3DefectSetting)
                    {
                        m_objSubTh2_RotateROI.AttachImage(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex_DarkField3]);
                        ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex_DarkField3], m_objSubTh2_RotateROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_PkgBright, ref m_smVisionInfo.g_arrRotatedImages, intSideLightViewImageIndex_DarkField3);
                    }

                    if (m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_blnSeperateDarkField4DefectSetting)
                    {
                        m_objSubTh2_RotateROI.AttachImage(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex_DarkField4]);
                        ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex_DarkField4], m_objSubTh2_RotateROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_PkgBright, ref m_smVisionInfo.g_arrRotatedImages, intSideLightViewImageIndex_DarkField4);
                    }

                    if (m_blnCustomWantColor && !GetColorImageRotated(intSideLightViewImageIndex_DarkField2) && !ContainColorSelectedImage(intSideLightViewImageIndex_DarkField2, m_smVisionInfo.g_intSelectedUnit)
                        || m_blnCustomWantColor && !GetColorImageRotated(intSideLightViewImageIndex_DarkField3) && !ContainColorSelectedImage(intSideLightViewImageIndex_DarkField3, m_smVisionInfo.g_intSelectedUnit)
                        || m_blnCustomWantColor && !GetColorImageRotated(intSideLightViewImageIndex_DarkField4) && !ContainColorSelectedImage(intSideLightViewImageIndex_DarkField4, m_smVisionInfo.g_intSelectedUnit))
                    {
                        CROI objColorRotatedROI = new CROI();

                        if (m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_blnSeperateDarkField2DefectSetting)
                        {
                            objColorRotatedROI.AttachImage(m_smVisionInfo.g_arrColorImages[intSideLightViewImageIndex_DarkField2]);
                            // Get RotateROI center point where the ROI center point == Package Unit Center Point
                            objColorRotatedROI.LoadROISetting(m_objSubTh2_RotateROI.ref_ROIPositionX,
                                                         m_objSubTh2_RotateROI.ref_ROIPositionY,
                                                         m_objSubTh2_RotateROI.ref_ROIWidth,
                                                         m_objSubTh2_RotateROI.ref_ROIHeight);

                            CROI.Rotate0Degree(m_smVisionInfo.g_arrColorImages[intSideLightViewImageIndex_DarkField2], objColorRotatedROI, fTotalRotateAngle, 4, ref m_smVisionInfo.g_arrColorRotatedImages, intSideLightViewImageIndex_DarkField2);
                            SetColorImageRotated(intSideLightViewImageIndex_DarkField2);
                        }

                        if (m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_blnSeperateDarkField3DefectSetting)
                        {
                            objColorRotatedROI.AttachImage(m_smVisionInfo.g_arrColorImages[intSideLightViewImageIndex_DarkField3]);
                            objColorRotatedROI.LoadROISetting(m_objSubTh2_RotateROI.ref_ROIPositionX,
                                                         m_objSubTh2_RotateROI.ref_ROIPositionY,
                                                         m_objSubTh2_RotateROI.ref_ROIWidth,
                                                         m_objSubTh2_RotateROI.ref_ROIHeight);

                            CROI.Rotate0Degree(m_smVisionInfo.g_arrColorImages[intSideLightViewImageIndex_DarkField3], objColorRotatedROI, fTotalRotateAngle, 4, ref m_smVisionInfo.g_arrColorRotatedImages, intSideLightViewImageIndex_DarkField3);
                            SetColorImageRotated(intSideLightViewImageIndex_DarkField3);
                        }

                        if (m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_blnSeperateDarkField4DefectSetting)
                        {
                            objColorRotatedROI.AttachImage(m_smVisionInfo.g_arrColorImages[intSideLightViewImageIndex_DarkField4]);
                            objColorRotatedROI.LoadROISetting(m_objSubTh2_RotateROI.ref_ROIPositionX,
                                                         m_objSubTh2_RotateROI.ref_ROIPositionY,
                                                         m_objSubTh2_RotateROI.ref_ROIWidth,
                                                         m_objSubTh2_RotateROI.ref_ROIHeight);

                            CROI.Rotate0Degree(m_smVisionInfo.g_arrColorImages[intSideLightViewImageIndex_DarkField4], objColorRotatedROI, fTotalRotateAngle, 4, ref m_smVisionInfo.g_arrColorRotatedImages, intSideLightViewImageIndex_DarkField4);
                            SetColorImageRotated(intSideLightViewImageIndex_DarkField4);
                        }
                        objColorRotatedROI.Dispose();
                    }
                }

                if (m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_blnSeperateDarkField2DefectSetting)
                {
                    if (intSideLightViewImageIndex_DarkField2 == 0)
                        m_blnRotateImage1Updated = true;
                    else if (intSideLightViewImageIndex_DarkField2 == 1)
                        m_blnRotateImage2Updated = true;
                    else if (intSideLightViewImageIndex_DarkField2 == 2)
                        m_blnRotateImage3Updated = true;
                    else if (intSideLightViewImageIndex_DarkField2 == 3)
                        m_blnRotateImage4Updated = true;
                    else if (intSideLightViewImageIndex_DarkField2 == 4)
                        m_blnRotateImage5Updated = true;
                    else if (intSideLightViewImageIndex_DarkField2 == 5)
                        m_blnRotateImage6Updated = true;
                    else
                        m_blnRotateImage7Updated = true;
                }

                if (m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_blnSeperateDarkField3DefectSetting)
                {
                    if (intSideLightViewImageIndex_DarkField3 == 0)
                        m_blnRotateImage1Updated = true;
                    else if (intSideLightViewImageIndex_DarkField3 == 1)
                        m_blnRotateImage2Updated = true;
                    else if (intSideLightViewImageIndex_DarkField3 == 2)
                        m_blnRotateImage3Updated = true;
                    else if (intSideLightViewImageIndex_DarkField3 == 3)
                        m_blnRotateImage4Updated = true;
                    else if (intSideLightViewImageIndex_DarkField3 == 4)
                        m_blnRotateImage5Updated = true;
                    else if (intSideLightViewImageIndex_DarkField3 == 5)
                        m_blnRotateImage6Updated = true;
                    else
                        m_blnRotateImage7Updated = true;
                }

                if (m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_blnSeperateDarkField4DefectSetting)
                {
                    if (intSideLightViewImageIndex_DarkField4 == 0)
                        m_blnRotateImage1Updated = true;
                    else if (intSideLightViewImageIndex_DarkField4 == 1)
                        m_blnRotateImage2Updated = true;
                    else if (intSideLightViewImageIndex_DarkField4 == 2)
                        m_blnRotateImage3Updated = true;
                    else if (intSideLightViewImageIndex_DarkField4 == 3)
                        m_blnRotateImage4Updated = true;
                    else if (intSideLightViewImageIndex_DarkField4 == 4)
                        m_blnRotateImage5Updated = true;
                    else if (intSideLightViewImageIndex_DarkField4 == 5)
                        m_blnRotateImage6Updated = true;
                    else
                        m_blnRotateImage7Updated = true;
                }
            }

            // 2020-12-18 ZJYEOH : If not same image selected, need rotate another image
            if ((intSideLightViewImageIndex != intMoldFlashViewImageIndex && m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_blnSeperateMoldFlashDefectSetting) &&
                (intSideLightViewImageIndex_DarkField2 != intMoldFlashViewImageIndex && m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_blnSeperateMoldFlashDefectSetting)
                && (intSideLightViewImageIndex_DarkField3 != intMoldFlashViewImageIndex && m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_blnSeperateMoldFlashDefectSetting)
                && (intSideLightViewImageIndex_DarkField4 != intMoldFlashViewImageIndex && m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_blnSeperateMoldFlashDefectSetting))
            {
                if (intMoldFlashViewImageIndex == 0)
                {
                    /* 2019 07 14 - CCENG: 
                     * if g_blnWantGauge is false, mean Image 1 is rotated according to Orient Matching Angle, which is not 100% correct,
                     * because the Orient Matching Angle and Unit Angle may be different.
                     * So when come to Image 1 package size test, Image 1 need to be re-rotated  according to Package size result angle.
                     */
                    if (m_smVisionInfo.g_blnWantGauge)
                    {
                        // Wait StartOrientTest rotate image 1 done or mark test done. (sometime rotate image 1 done will not set to true if Orient fail).
                        WaitEventDone(ref m_blnRotateImage1Updated, ref m_bSubTh_MarkTest, true, false, "StartPackageTest_SideLightView > m_blnRotateImage1Updated 6648");
                    }
                    else
                    {
                        // Since Mark Test Image index and side light package view image index are same, then need to Wait for Marktest done because Rotated image need to be tested by mark inspection function. After mark inspection, then only allow to re-rotate again using packge angle.
                        WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartPackageTest > m_bSubTh_MarkTest 6653");

                        if (!m_bSubTh_MarkTest_Result)
                        {
                            return false;   // Skip package inspection if mark test fail.
                        }

                        m_objSubTh2_RotateROI.AttachImage(m_smVisionInfo.g_arrImages[intMoldFlashViewImageIndex]);
                        ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[intMoldFlashViewImageIndex], m_objSubTh2_RotateROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_PkgBright, ref m_smVisionInfo.g_arrRotatedImages, intMoldFlashViewImageIndex);

                        if (m_blnCustomWantColor && !GetColorImageRotated(intMoldFlashViewImageIndex) && !ContainColorSelectedImage(intMoldFlashViewImageIndex, m_smVisionInfo.g_intSelectedUnit))
                        {
                            CROI objColorRotatedROI = new CROI();
                            objColorRotatedROI.AttachImage(m_smVisionInfo.g_arrColorImages[intMoldFlashViewImageIndex]);

                            // Get RotateROI center point where the ROI center point == Package Unit Center Point
                            objColorRotatedROI.LoadROISetting(m_objSubTh2_RotateROI.ref_ROIPositionX,
                                                         m_objSubTh2_RotateROI.ref_ROIPositionY,
                                                         m_objSubTh2_RotateROI.ref_ROIWidth,
                                                         m_objSubTh2_RotateROI.ref_ROIHeight);

                            CROI.Rotate0Degree(m_smVisionInfo.g_arrColorImages[intMoldFlashViewImageIndex], objColorRotatedROI, fTotalRotateAngle, 4, ref m_smVisionInfo.g_arrColorRotatedImages, intMoldFlashViewImageIndex);

                            SetColorImageRotated(intMoldFlashViewImageIndex);
                            objColorRotatedROI.Dispose();
                        }
                    }

                }
                else
                {
                    // Rotate imgae 2
                    m_objSubTh2_RotateROI.AttachImage(m_smVisionInfo.g_arrImages[intMoldFlashViewImageIndex]);
                    ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[intMoldFlashViewImageIndex], m_objSubTh2_RotateROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_PkgBright, ref m_smVisionInfo.g_arrRotatedImages, intMoldFlashViewImageIndex);

                    if (m_blnCustomWantColor && !GetColorImageRotated(intMoldFlashViewImageIndex) && !ContainColorSelectedImage(intMoldFlashViewImageIndex, m_smVisionInfo.g_intSelectedUnit))
                    {
                        CROI objColorRotatedROI = new CROI();
                        objColorRotatedROI.AttachImage(m_smVisionInfo.g_arrColorImages[intMoldFlashViewImageIndex]);

                        // Get RotateROI center point where the ROI center point == Package Unit Center Point
                        objColorRotatedROI.LoadROISetting(m_objSubTh2_RotateROI.ref_ROIPositionX,
                                                     m_objSubTh2_RotateROI.ref_ROIPositionY,
                                                     m_objSubTh2_RotateROI.ref_ROIWidth,
                                                     m_objSubTh2_RotateROI.ref_ROIHeight);

                        CROI.Rotate0Degree(m_smVisionInfo.g_arrColorImages[intMoldFlashViewImageIndex], objColorRotatedROI, fTotalRotateAngle, 4, ref m_smVisionInfo.g_arrColorRotatedImages, intMoldFlashViewImageIndex);

                        SetColorImageRotated(intMoldFlashViewImageIndex);
                        objColorRotatedROI.Dispose();
                    }
                }

                if (intMoldFlashViewImageIndex == 0)
                    m_blnRotateImage1Updated = true;
                else if (intMoldFlashViewImageIndex == 1)
                    m_blnRotateImage2Updated = true;
                else if (intMoldFlashViewImageIndex == 2)
                    m_blnRotateImage3Updated = true;
                else if (intMoldFlashViewImageIndex == 3)
                    m_blnRotateImage4Updated = true;
                else if (intMoldFlashViewImageIndex == 4)
                    m_blnRotateImage5Updated = true;
                else if (intMoldFlashViewImageIndex == 5)
                    m_blnRotateImage6Updated = true;
                else
                    m_blnRotateImage7Updated = true;
            }

            // Wait mark inspection done.
            WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartPackageTest > m_bSubTh_MarkTest 6689");    // need to wait for mark inspection done. Because package inspection need to use mark char area to set dont care area on package roi.
            if (!m_bSubTh_MarkTest_Result)
            {
                return false;   // Skip package inspection if mark test fail.
            }
            // Wait package test done under mark light view 
            WaitEventDone(ref m_bSubTh_PackageTest_MarkLightView, false, 10000, "StartPackageTest > m_bSubTh_PackageTest_MarkLightView 6695");
            if (!m_bSubTh_PackageTest_MarkLightView_Result)
            {
                return false;
            }

            // --------- Get image index for : package -----------------
            m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_blnViewUnitPosition = true;

            //m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ClearDontCareAreaArray();//2020-12-28 ZJYEOH : Only StartPackageTest_MarkLightView will use this dont care

            // ------- Copy image to temporary inspection image
            if (intSideLightViewImageIndex >= 0)
            {
                if (m_objPkgViewImage == null)
                    m_objPkgViewImage = new ImageDrawing(true);

                if (blnWantDebug)
                {
                    m_smVisionInfo.g_arrRotatedImages[intSideLightViewImageIndex].SaveImage("D:\\TS\\3.RotateImage.bmp");
                }

                // 2020 07 11 - CCENG: need to rotate to mark 0 deg first in order to mask dont care the marking area before proceed for package inspection.
                //            - Why cannot mask dont care mark without mark 0 deg. 
                //              > because currently ocv do inspection when mark is in 0 deg.
                //              > also our mark template is in 0 deg also. If want to mask dont care without mark 0 deg, 
                //                then dont mark template need to rotate to sample mark angle before masking dont care. 
                //m_smVisionInfo.g_arrRotatedImages[intSideLightViewImageIndex].CopyTo(ref m_objPkgViewImage);
                ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex], m_objSubTh2_RotateROI, fTotalRotateMarkAngle, m_smVisionInfo.g_intRotationInterpolation_PkgBright, ref m_objPkgViewImage);

                if (m_blnCustomWantColor && !GetColorImageRotated(intSideLightViewImageIndex) && !ContainColorSelectedImage(intSideLightViewImageIndex, m_smVisionInfo.g_intSelectedUnit))
                {
                    CROI objColorRotatedROI = new CROI();
                    objColorRotatedROI.AttachImage(m_smVisionInfo.g_arrColorImages[intSideLightViewImageIndex]);

                    // Get RotateROI center point where the ROI center point == Package Unit Center Point
                    objColorRotatedROI.LoadROISetting(m_objSubTh2_RotateROI.ref_ROIPositionX,
                                                 m_objSubTh2_RotateROI.ref_ROIPositionY,
                                                 m_objSubTh2_RotateROI.ref_ROIWidth,
                                                 m_objSubTh2_RotateROI.ref_ROIHeight);

                    CROI.Rotate0Degree(m_smVisionInfo.g_arrColorImages[intSideLightViewImageIndex], objColorRotatedROI, fTotalRotateMarkAngle, 4, ref m_smVisionInfo.g_arrColorRotatedImages, intSideLightViewImageIndex);

                    SetColorImageRotated(intSideLightViewImageIndex);
                    objColorRotatedROI.Dispose();
                }
                if (blnWantDebug)
                {
                    m_objPkgViewImage.SaveImage("D:\\TS\\0.m_objPkgViewImage.bmp");
                }
            }
            else if (m_objPkgViewImage != null)
                m_objPkgViewImage = null;


            if (intSideLightViewImageIndex_DarkField2 >= 0)
            {
                if (m_objPkgViewImage_DarkField2 == null)
                    m_objPkgViewImage_DarkField2 = new ImageDrawing(true);
                m_smVisionInfo.g_arrRotatedImages[intSideLightViewImageIndex_DarkField2].CopyTo(ref m_objPkgViewImage_DarkField2);
            }
            else if (m_objPkgViewImage_DarkField2 != null)
                m_objPkgViewImage_DarkField2 = null;

            if (intSideLightViewImageIndex_DarkField3 >= 0)
            {
                if (m_objPkgViewImage_DarkField3 == null)
                    m_objPkgViewImage_DarkField3 = new ImageDrawing(true);
                m_smVisionInfo.g_arrRotatedImages[intSideLightViewImageIndex_DarkField3].CopyTo(ref m_objPkgViewImage_DarkField3);
            }
            else if (m_objPkgViewImage_DarkField3 != null)
                m_objPkgViewImage_DarkField3 = null;

            if (intSideLightViewImageIndex_DarkField4 >= 0)
            {
                if (m_objPkgViewImage_DarkField4 == null)
                    m_objPkgViewImage_DarkField4 = new ImageDrawing(true);
                m_smVisionInfo.g_arrRotatedImages[intSideLightViewImageIndex_DarkField4].CopyTo(ref m_objPkgViewImage_DarkField4);
            }
            else if (m_objPkgViewImage_DarkField4 != null)
                m_objPkgViewImage_DarkField4 = null;

            if (intMoldFlashViewImageIndex >= 0)
            {
                if (m_objPkgMoldFlashViewImage == null)
                    m_objPkgMoldFlashViewImage = new ImageDrawing(true);
                m_smVisionInfo.g_arrRotatedImages[intMoldFlashViewImageIndex].CopyTo(ref m_objPkgMoldFlashViewImage);
            }
            else if (m_objPkgMoldFlashViewImage != null)
                m_objPkgMoldFlashViewImage = null;

            bool blnWantMark = false;
            int intCharDilateHalfWidth = 2;
            if (m_smVisionInfo.g_arrMarks != null && m_smVisionInfo.g_arrMarks.Count > 0)
            {
                // 2020 04 15 - JBTAN: will continue to check mark even option uncheck check mark option
                // 2020 07 08 - Roll back to previous method, wont check mark if Mark Checking is not selected.
                blnWantMark = m_smVisionInfo.g_arrMarks[0].ref_blnCheckMark;
                //blnWantMark = true;
                intCharDilateHalfWidth = m_smVisionInfo.g_arrMarks[0].ref_intCharDilateHalfWidth; // thick iteration
            }

            //2020-05-18 ZJYEOH : Get another Image without subtract mark area
            if (m_smVisionInfo.g_intPackageDefectInspectionMethod != 0)
            {
                m_objPkgViewImage.CopyTo(ref m_objGrayValueImage_SideLight);
            }

            if (blnWantMark)
            {
                // ---------- Fill Mark Image's mark area with black color -------------------
                int intNumChars = m_smVisionInfo.g_arrMarks[0].GetNumChars();
                int intStartX = 0, intStartY = 0, intEndX = 0, intEndY = 0;

                int intOffsetX;
                int intOffsetY;

                if (m_smVisionInfo.g_blnWantGauge)  // Mean during mark inspection, orient gauge is used to measure unit position for m_objMarkTrainROI
                {
                    intOffsetX = m_objMarkTrainROI.ref_ROITotalX;
                    intOffsetY = m_objMarkTrainROI.ref_ROITotalY;
                }
                else if (m_smVisionInfo.g_arrMarkROIs[0].Count > 3)    // Mean during mark inspection, Unit PR is used to find unit surface position for m_objMarkTrainROI
                {
                    intOffsetX = m_objMarkTrainROI.ref_ROITotalX;
                    intOffsetY = m_objMarkTrainROI.ref_ROITotalY;
                }
                else // Mean during mark inspection, m_objMarkSearchROI is used.
                {
                    intOffsetX = m_objMarkTrainROI.ref_ROITotalX;
                    intOffsetY = m_objMarkTrainROI.ref_ROITotalY;
                }

                for (int i = 0; i < intNumChars; i++)
                {
                    bool blnIsBarPin1 = m_smVisionInfo.g_arrMarks[0].GetCharIsBarPin1(m_smVisionInfo.g_arrMarks[0].ref_intGroupIndex, m_smVisionInfo.g_arrMarks[0].ref_intTemplateIndex, i);
                    int intBarPin1Type = m_smVisionInfo.g_arrMarks[0].GetCharBarPin1Type(m_smVisionInfo.g_arrMarks[0].ref_intGroupIndex, m_smVisionInfo.g_arrMarks[0].ref_intTemplateIndex, i);

                    int intRectStartX, intRectStartY, intRectEndX, intRectEndY;
                    intRectStartX = intRectStartY = intRectEndX = intRectEndY = 0;
                    m_smVisionInfo.g_arrMarks[0].GetCharStartXY(i, ref intStartX, ref intStartY);
                    m_smVisionInfo.g_arrMarks[0].GetCharEndXY(i, ref intEndX, ref intEndY);

                    if (m_smVisionInfo.g_arrMarks[0].ref_blnWantDontCareIgnoredMarkWholeArea && !m_smVisionInfo.g_arrMarks[0].GetEnableMarkSetting(i))
                    {
                        //2021-01-18 ZJYEOH : Should use sample position
                        Point pStartTemplate = new Point(intStartX, intStartY);//m_smVisionInfo.g_arrMarks[0].GetTemplateCharROIStartPoint(i);
                        Point pEndTemplate = new Point(intEndX, intEndY);//m_smVisionInfo.g_arrMarks[0].GetTemplateCharROIEndPoint(i);

                        if ((intOffsetX + pStartTemplate.X - m_smVisionInfo.g_arrMarks[0].GetTemplateCharShiftX(i)) >= 0)
                            intRectStartX = intOffsetX + pStartTemplate.X - m_smVisionInfo.g_arrMarks[0].GetTemplateCharShiftX(i);
                        else
                            intRectStartX = intOffsetX;

                        if ((intOffsetY + pStartTemplate.Y - m_smVisionInfo.g_arrMarks[0].GetTemplateCharShiftY(i)) >= 0)
                            intRectStartY = intOffsetY + pStartTemplate.Y - m_smVisionInfo.g_arrMarks[0].GetTemplateCharShiftY(i);
                        else
                            intRectStartY = intOffsetY;

                        if ((intOffsetX + pEndTemplate.X + m_smVisionInfo.g_arrMarks[0].GetTemplateCharShiftX(i)) < m_smVisionInfo.g_intCameraResolutionWidth)
                            intRectEndX = intOffsetX + pEndTemplate.X + m_smVisionInfo.g_arrMarks[0].GetTemplateCharShiftX(i);
                        else
                            continue;
                        if ((intOffsetY + pEndTemplate.Y + m_smVisionInfo.g_arrMarks[0].GetTemplateCharShiftY(i)) < m_smVisionInfo.g_intCameraResolutionHeight)
                            intRectEndY = intOffsetY + pEndTemplate.Y + m_smVisionInfo.g_arrMarks[0].GetTemplateCharShiftY(i);
                        else
                            continue;
                    }
                    else
                    {
                        // 2019 10 11 - CCENG   : add intOffsetXY checking because rectangle will be filled on m_objPkgViewImage (Full image)
                        //                      : without the intOffsetXY, intRectStartX will set to intOffsetX and fill position may be shifted                       
                        if ((intOffsetX + intStartX - intCharDilateHalfWidth) >= 0)  //if ((intStartX - intCharDilateHalfWidth) >= 0)   
                            intRectStartX = intOffsetX + intStartX - intCharDilateHalfWidth;
                        else
                            intRectStartX = intOffsetX;

                        // 2019 10 11 - CCENG   : add intOffsetXY checking because rectangle will be filled on m_objPkgViewImage (Full image)
                        //                      : without the intOffsetXY, intRectStartX will set to intOffsetX and fill position may be shifted
                        if ((intOffsetY + intStartY - intCharDilateHalfWidth) >= 0)    //if ((intStartY - intCharDilateHalfWidth) >= 0) 
                            intRectStartY = intOffsetY + intStartY - intCharDilateHalfWidth;
                        else
                            intRectStartY = intOffsetY;

                        if ((intEndX + intCharDilateHalfWidth) < m_smVisionInfo.g_intCameraResolutionWidth)
                            intRectEndX = intOffsetX + intEndX + intCharDilateHalfWidth;
                        else
                            intRectEndX = intOffsetX + intEndX;

                        if ((intEndY + intCharDilateHalfWidth) < m_smVisionInfo.g_intCameraResolutionHeight)
                            intRectEndY = intOffsetY + intEndY + intCharDilateHalfWidth;
                        else
                            intRectEndY = intOffsetY + intEndY;
                    }

                    //2020-05-28 ZJYEOH : extend the dont care area to fit the m_objMarkTrainROI size
                    if (blnIsBarPin1 && !m_smVisionInfo.g_blnWantCheckBarPin1)
                    {
                        if (intBarPin1Type == 0) // Virtical bar
                        {
                            intRectStartY = intOffsetY;
                            intRectEndY = intOffsetY + m_objMarkTrainROI.ref_ROIHeight;
                        }
                        else if (intBarPin1Type == 1) // Horizontal bar
                        {
                            intRectStartX = intOffsetX;
                            intRectEndX = intOffsetX + m_objMarkTrainROI.ref_ROIWidth;
                        }
                    }

                    if (blnWantDebug)
                    {
                        m_objPkgViewImage.SaveImage("D:\\TS\\1.m_objPkgViewImage" + i.ToString() + ".bmp");
                    }

                    if (intSideLightViewImageIndex >= 0)
                        Shape.FillRectangle(m_objPkgViewImage, intRectStartX, intRectStartY, intRectEndX, intRectEndY, 0);

                    if (blnWantDebug)
                    {
                        m_objPkgViewImage.SaveImage("D:\\TS\\2.m_objPkgViewImage" + i.ToString() + ".bmp");
                    }

                    // 2020-06-18 ZJYEOH : Fill white pixel on DarkField2 image
                    if (intSideLightViewImageIndex_DarkField2 >= 0 && m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_blnSeperateDarkField2DefectSetting && !m_smVisionInfo.g_blnWantCheckVoidOnMarkArea_SideLight[0])
                    {
                        Shape.FillRectangle(m_objPkgViewImage_DarkField2, intRectStartX, intRectStartY, intRectEndX, intRectEndY, 255);
                    }

                    if (intSideLightViewImageIndex_DarkField3 >= 0 && m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_blnSeperateDarkField3DefectSetting && !m_smVisionInfo.g_blnWantCheckVoidOnMarkArea_SideLight[1])
                    {
                        Shape.FillRectangle(m_objPkgViewImage_DarkField3, intRectStartX, intRectStartY, intRectEndX, intRectEndY, 255);
                    }

                    if (intSideLightViewImageIndex_DarkField4 >= 0 && m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_blnSeperateDarkField4DefectSetting && !m_smVisionInfo.g_blnWantCheckVoidOnMarkArea_SideLight[2])
                    {
                        Shape.FillRectangle(m_objPkgViewImage_DarkField4, intRectStartX, intRectStartY, intRectEndX, intRectEndY, 255);
                    }

                    // 2020-12-18 ZJYEOH : Fill Dark pixel on Mold Flash image
                    if (intMoldFlashViewImageIndex >= 0 && m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_blnSeperateMoldFlashDefectSetting)
                    {
                        Shape.FillRectangle(m_objPkgMoldFlashViewImage, intRectStartX, intRectStartY, intRectEndX, intRectEndY, 0);
                    }

                    //m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].SetDontCareArea(intRectStartX, intRectStartY, intRectEndX, intRectEndY);//2020-12-28 ZJYEOH : Only StartPackageTest_MarkLightView will use this dont care
                }
            }

            if ((m_smCustomizeInfo.g_intWant2DCode & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
            {
                if (m_smVisionInfo.g_blnWantMark2DCode)
                {
                    // ---------- Fill 2D code area with black color -------------------
                    int intStartX = 0, intStartY = 0, intEndX = 0, intEndY = 0;

                    int intOffsetX;
                    int intOffsetY;

                    if (m_smVisionInfo.g_blnWantGauge)  // Mean during mark inspection, orient gauge is used to measure unit position for m_objMark2DCodeROI
                    {
                        intOffsetX = m_objMark2DCodeROI.ref_ROITotalX;
                        intOffsetY = m_objMark2DCodeROI.ref_ROITotalY;
                    }
                    else if (m_smVisionInfo.g_arrMarkROIs[0].Count > 3)    // Mean during mark inspection, Unit PR is used to find unit surface position for m_objMark2DCodeROI
                    {
                        intOffsetX = m_objMark2DCodeROI.ref_ROITotalX;
                        intOffsetY = m_objMark2DCodeROI.ref_ROITotalY;
                    }
                    else // Mean during mark inspection, m_objMarkSearchROI is used.
                    {
                        intOffsetX = m_objMark2DCodeROI.ref_ROITotalX;
                        intOffsetY = m_objMark2DCodeROI.ref_ROITotalY;
                    }

                    int intRectStartX, intRectStartY, intRectEndX, intRectEndY;
                    intRectStartX = intRectStartY = intRectEndX = intRectEndY = 0;

                    m_smVisionInfo.g_arrMarks[0].Get2DCodeStartEndXY(ref intStartX, ref intStartY, ref intEndX, ref intEndY);

                    intRectStartX = intOffsetX + intStartX;
                    intRectStartY = intOffsetY + intStartY;
                    intRectEndX = intOffsetX + intEndX;
                    intRectEndY = intOffsetY + intEndY;

                    if (intSideLightViewImageIndex >= 0)
                        Shape.FillRectangle(m_objPkgViewImage, intRectStartX, intRectStartY, intRectEndX, intRectEndY, 0);

                    //m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].SetDontCareArea(intRectStartX, intRectStartY, intRectEndX, intRectEndY);//2020-12-28 ZJYEOH : Only StartPackageTest_MarkLightView will use this dont care
                }
            }

            if (blnWantDebug)
            {
                m_objPkgViewImage.SaveImage("D:\\TS\\3.m_objPkgViewImage.bmp");
            }


            if (fTotalRotateMarkAngle != fTotalRotateAngle)
            {
                // Rotate unit to package zero deg
                m_objSubTh2_RotateROI.AttachImage(m_smVisionInfo.g_arrImages[intSideLightViewImageIndex]);
                ROI.Rotate0Degree(m_objSubTh2_RotateROI, fTotalRotateAngle - fTotalRotateMarkAngle, m_smVisionInfo.g_intRotationInterpolation_PkgBright, ref m_objPkgViewImage);

                if (m_blnCustomWantColor && !GetColorImageRotated(intSideLightViewImageIndex) && !ContainColorSelectedImage(intSideLightViewImageIndex, m_smVisionInfo.g_intSelectedUnit))
                {
                    CROI objColorRotatedROI = new CROI();
                    objColorRotatedROI.AttachImage(m_smVisionInfo.g_arrColorImages[intSideLightViewImageIndex]);

                    // Get RotateROI center point where the ROI center point == Package Unit Center Point
                    objColorRotatedROI.LoadROISetting(m_objSubTh2_RotateROI.ref_ROIPositionX,
                                                 m_objSubTh2_RotateROI.ref_ROIPositionY,
                                                 m_objSubTh2_RotateROI.ref_ROIWidth,
                                                 m_objSubTh2_RotateROI.ref_ROIHeight);

                    CROI.Rotate0Degree(m_smVisionInfo.g_arrColorImages[intSideLightViewImageIndex], objColorRotatedROI, fTotalRotateAngle - fTotalRotateMarkAngle, 4, ref m_smVisionInfo.g_arrColorRotatedImages, intSideLightViewImageIndex);

                    SetColorImageRotated(intSideLightViewImageIndex);
                    objColorRotatedROI.Dispose();
                }
            }

            if (blnWantDebug)
            {
                m_objPkgViewImage.SaveImage("D:\\TS\\4.m_objPkgViewImage.bmp");
            }

            // ----------- Define the actual location for unit and place the package roi on that location. ------------------------
            ROI objPkgViewROI = null; // Image 2 - Package ROI
            if (intSideLightViewImageIndex >= 0)
            {
                objPkgViewROI = new ROI();
                objPkgViewROI.AttachImage(m_objPkgViewImage);
                objPkgViewROI.LoadROISetting((int)Math.Round((fGaugeCenterX -
                                             fGaugeWidth / 2 +
                                             m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromLeft), 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round((fGaugeCenterY -
                                             fGaugeHeight / 2 +
                                             m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromEdge), 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round(fGaugeWidth - m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromRight - m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromLeft, 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round(fGaugeHeight - m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromEdge - m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromBottom, 0, MidpointRounding.AwayFromZero));
            }

            ROI objPkgViewROI_DarkField2 = null; // Dark Field 2 ROI
            ROI objPkgViewROI_DarkField3 = null; // Dark Field 3 ROI
            ROI objPkgViewROI_DarkField4 = null; // Dark Field 4 ROI

            if (intSideLightViewImageIndex_DarkField2 >= 0)
            {
                objPkgViewROI_DarkField2 = new ROI();
                objPkgViewROI_DarkField2.AttachImage(m_objPkgViewImage_DarkField2);
                objPkgViewROI_DarkField2.LoadROISetting((int)Math.Round((fGaugeCenterX -
                                             fGaugeWidth / 2 +
                                             m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromLeft_DarkField2), 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round((fGaugeCenterY -
                                             fGaugeHeight / 2 +
                                             m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromEdge_DarkField2), 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round(fGaugeWidth - m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromRight_DarkField2 - m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromLeft_DarkField2, 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round(fGaugeHeight - m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromEdge_DarkField2 - m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromBottom_DarkField2, 0, MidpointRounding.AwayFromZero));
            }

            if (intSideLightViewImageIndex_DarkField3 >= 0)
            {
                objPkgViewROI_DarkField3 = new ROI();
                objPkgViewROI_DarkField3.AttachImage(m_objPkgViewImage_DarkField3);
                objPkgViewROI_DarkField3.LoadROISetting((int)Math.Round((fGaugeCenterX -
                                             fGaugeWidth / 2 +
                                             m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromLeft_DarkField3), 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round((fGaugeCenterY -
                                             fGaugeHeight / 2 +
                                             m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromEdge_DarkField3), 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round(fGaugeWidth - m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromRight_DarkField3 - m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromLeft_DarkField3, 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round(fGaugeHeight - m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromEdge_DarkField3 - m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromBottom_DarkField3, 0, MidpointRounding.AwayFromZero));
            }

            if (intSideLightViewImageIndex_DarkField4 >= 0)
            {
                objPkgViewROI_DarkField4 = new ROI();
                objPkgViewROI_DarkField4.AttachImage(m_objPkgViewImage_DarkField4);
                objPkgViewROI_DarkField4.LoadROISetting((int)Math.Round((fGaugeCenterX -
                                             fGaugeWidth / 2 +
                                             m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromLeft_DarkField4), 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round((fGaugeCenterY -
                                             fGaugeHeight / 2 +
                                             m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromEdge_DarkField4), 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round(fGaugeWidth - m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromRight_DarkField4 - m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromLeft_DarkField4, 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round(fGaugeHeight - m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromEdge_DarkField4 - m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromBottom_DarkField4, 0, MidpointRounding.AwayFromZero));
            }


            ROI objChipUnitROI = null; // Image 2 - Chip ROI
            if (intSideLightViewImageIndex >= 0)
            {
                objChipUnitROI = new ROI();
                // Use pkg image for chip test as priority
                objChipUnitROI.AttachImage(m_objPkgViewImage);
                //objChipUnitROI.LoadROISetting((int)Math.Round((fGaugeCenterX - fGaugeWidth / 2), 0, MidpointRounding.AwayFromZero),
                //                              (int)Math.Round((fGaugeCenterY - fGaugeHeight / 2), 0, MidpointRounding.AwayFromZero),
                //                              (int)Math.Round(fGaugeWidth, 0, MidpointRounding.AwayFromZero),
                //                              (int)Math.Round(fGaugeHeight, 0, MidpointRounding.AwayFromZero));
                objChipUnitROI.LoadROISetting((int)Math.Round((fGaugeCenterX - fGaugeWidth / 2) + m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelExtendFromLeft_Chip, 0, MidpointRounding.AwayFromZero),
                                           (int)Math.Round((fGaugeCenterY - fGaugeHeight / 2) + m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelExtendFromEdge_Chip, 0, MidpointRounding.AwayFromZero),
                                           (int)Math.Round(fGaugeWidth - m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelExtendFromLeft_Chip - m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelExtendFromRight_Chip, 0, MidpointRounding.AwayFromZero),
                                           (int)Math.Round(fGaugeHeight - m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelExtendFromEdge_Chip - m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelExtendFromBottom_Chip, 0, MidpointRounding.AwayFromZero));

            }

            ROI objMoldFlashROI = null; // Image 2 - MoldFlash ROI
            if (intMoldFlashViewImageIndex >= 0)
            {
                objMoldFlashROI = new ROI();
                objMoldFlashROI.LoadROISetting((int)Math.Round((fGaugeCenterX -
                                             fGaugeWidth / 2 -
                                             m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromLeft_Mold), 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round((fGaugeCenterY -
                                             fGaugeHeight / 2 -
                                             m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromEdge_Mold), 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round(fGaugeWidth + m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromRight_Mold + m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromLeft_Mold, 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round(fGaugeHeight + m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromEdge_Mold + m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromBottom_Mold, 0, MidpointRounding.AwayFromZero));
                objMoldFlashROI.AttachImage(m_objPkgMoldFlashViewImage);
            }

            if (m_smVisionInfo.g_blnWantDontCareArea_Package)
            {
                if (intSideLightViewImageIndex >= 0)
                {
                    ////Draw don't care ROI edge to make sure Don't Care Area is not inspected
                    //for (int k = 3; k < m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit].Count; k++)
                    //{
                    //    m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][k].AttachImage(objPkgViewROI);
                    //    ROI objROI = new ROI();
                    //    objROI.LoadROISetting((int)Math.Round((fGaugeCenterX - fGaugeWidth / 2 + m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][k].ref_ROIPositionX), 0, MidpointRounding.AwayFromZero),
                    //                          (int)Math.Round((fGaugeCenterY - fGaugeHeight / 2 + m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][k].ref_ROIPositionY), 0, MidpointRounding.AwayFromZero),
                    //                           m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][k].ref_ROIWidth, m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][k].ref_ROIHeight);
                    //    objROI.AttachImage(m_smVisionInfo.g_objWhiteImage);
                    //    ROI.SubtractROI(m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][k], objROI);
                    //    //objPkgViewROI.SaveImage("D:\\aaa.bmp");
                    //    objROI.Dispose();
                    //}

                    ROI objDontCareROI = new ROI();
                    //objDontCareROI.LoadROISetting(0, 0, objPkgViewROI.ref_ROIWidth, objPkgViewROI.ref_ROIHeight);
                    // 2020 06 27 - CCENG: objDontCareROI have to start from Package Tolerance bcos g_objDontCareImage_Package_Bright template is start from Package Size Template.
                    objDontCareROI.LoadROISetting(m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromLeft,
                             m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromEdge,
                             objPkgViewROI.ref_ROIWidth, objPkgViewROI.ref_ROIHeight);
                    objDontCareROI.AttachImage(m_smVisionInfo.g_objDontCareImage_Package_Bright);
                    ROI.SubtractROI(objPkgViewROI, objDontCareROI);
                    objDontCareROI.Dispose();
                }

                if (intSideLightViewImageIndex_DarkField2 >= 0 && m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_blnSeperateDarkField2DefectSetting)
                {
                    ROI objDontCareROI = new ROI();
                    objDontCareROI.LoadROISetting(m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromLeft,
                                                  m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromEdge,
                                                  objPkgViewROI.ref_ROIWidth, objPkgViewROI.ref_ROIHeight);
                    objDontCareROI.AttachImage(m_smVisionInfo.g_objDontCareImage_Package_Bright);
                    ROI.LogicOperationAddROI(objPkgViewROI_DarkField2, objDontCareROI);
                    objDontCareROI.Dispose();
                }

                if (intSideLightViewImageIndex_DarkField3 >= 0 && m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_blnSeperateDarkField3DefectSetting)
                {
                    ROI objDontCareROI = new ROI();
                    objDontCareROI.LoadROISetting(m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromLeft,
                                                  m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromEdge,
                                                  objPkgViewROI.ref_ROIWidth, objPkgViewROI.ref_ROIHeight);
                    objDontCareROI.AttachImage(m_smVisionInfo.g_objDontCareImage_Package_Bright);
                    ROI.LogicOperationAddROI(objPkgViewROI_DarkField3, objDontCareROI);
                    objDontCareROI.Dispose();
                }

                if (intSideLightViewImageIndex_DarkField4 >= 0 && m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_blnSeperateDarkField4DefectSetting)
                {
                    ROI objDontCareROI = new ROI();
                    objDontCareROI.LoadROISetting(m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromLeft,
                                                  m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromEdge,
                                                  objPkgViewROI.ref_ROIWidth, objPkgViewROI.ref_ROIHeight);
                    objDontCareROI.AttachImage(m_smVisionInfo.g_objDontCareImage_Package_Bright);
                    ROI.LogicOperationAddROI(objPkgViewROI_DarkField4, objDontCareROI);
                    objDontCareROI.Dispose();
                }

                if (intMoldFlashViewImageIndex >= 0 && m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_blnSeperateMoldFlashDefectSetting)
                {
                    ROI objDontCareROI = new ROI();
                    ROI objOriROI = new ROI();
                    float fCenterX = m_smVisionInfo.g_arrPackageGaugeM4L[m_smVisionInfo.g_intSelectedUnit].ref_pRectCenterPoint.X;
                    float fCenterY = m_smVisionInfo.g_arrPackageGaugeM4L[m_smVisionInfo.g_intSelectedUnit].ref_pRectCenterPoint.Y;

                    for (int i = 0; i < m_smVisionInfo.g_arrPackageMoldFlashDontCareROIs.Count; i++)
                    {
                        objOriROI.AttachImage(m_objPkgMoldFlashViewImage);

                        objDontCareROI.AttachImage(m_smVisionInfo.g_objWhiteImage);

                        objOriROI.LoadROISetting((int)Math.Round(fCenterX - m_smVisionInfo.g_arrPackageMoldFlashDontCareROIs[i].ref_intStartOffsetX),
                                                      (int)Math.Round(fCenterY - m_smVisionInfo.g_arrPackageMoldFlashDontCareROIs[i].ref_intStartOffsetY),
                                                      m_smVisionInfo.g_arrPackageMoldFlashDontCareROIs[i].ref_ROIWidth, m_smVisionInfo.g_arrPackageMoldFlashDontCareROIs[i].ref_ROIHeight);

                        objDontCareROI.LoadROISetting((int)Math.Round(fCenterX - m_smVisionInfo.g_arrPackageMoldFlashDontCareROIs[i].ref_intStartOffsetX),
                                                      (int)Math.Round(fCenterY - m_smVisionInfo.g_arrPackageMoldFlashDontCareROIs[i].ref_intStartOffsetY),
                                                      m_smVisionInfo.g_arrPackageMoldFlashDontCareROIs[i].ref_ROIWidth, m_smVisionInfo.g_arrPackageMoldFlashDontCareROIs[i].ref_ROIHeight);

                        ROI.SubtractROI(objOriROI, objDontCareROI);
                        //m_objPkgMoldFlashViewImage.SaveImage("D:\\m_objPkgMoldFlashViewImage.bmp");
                        //objMoldFlashROI.SaveImage("D:\\objMoldFlashROI" + i.ToString() + ".bmp");
                    }
                    objDontCareROI.Dispose();
                    objOriROI.Dispose();
                }
            }
            if (m_smVisionInfo.g_intPackageDefectInspectionMethod == 0)
            {
                if (!m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].DoInspection_SideLightView(//m_smVisionInfo.g_arrPackageGaugeM4L[m_smVisionInfo.g_intSelectedUnit],   // use to measure unit edge
                                                    fGaugeCenterX, fGaugeCenterY,
                                                    fGaugeWidth, fGaugeHeight,
                                                    objPkgViewROI,              // Package Test on second image
                                                    objChipUnitROI,             // Chipped off test on image 2
                                                    m_objPkgViewImage,          // Second package image (option)
                                                    objMoldFlashROI,
                                                    objPkgViewROI_DarkField2,
                                                    objPkgViewROI_DarkField3,
                                                    objPkgViewROI_DarkField4, // Dark field 2 ROI
                                                    m_smVisionInfo.g_objWhiteImage, m_smVisionInfo.g_objBlackImage))
                {
                    m_smVisionInfo.g_strErrorMessage += m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_strErrorMessage;
                    if (blnAuto)
                    {
                        if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        {
                            m_blnPackageFail_Out = true;
                            if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                                if (m_intTCPIPResultID == -1)
                                    SetPackageResultID(m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailResultMask);
                        }
                        else
                        {
                            m_objVisionIO.PackageFail.SetOn(strTrackHeadName + " PackageFail 16"); if (m_smVisionInfo.g_blnTrackIO) STTrackLog.WriteLine("IO-PackageFail-Set ON 38");
                        }

                        SaveRejectImage_AddToBuffer("Package", m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_strErrorMessage);

                        m_smVisionInfo.g_intPkgDefectFailureTotal++;
                    }
                    blnResult = false;
                }
            }
            else
            {
                if (!m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].DoInspection_SideLightView_GrayValueThresholdMethod(//m_smVisionInfo.g_arrPackageGaugeM4L[m_smVisionInfo.g_intSelectedUnit],   // use to measure unit edge
                                                    fGaugeCenterX, fGaugeCenterY,
                                                    fGaugeWidth, fGaugeHeight, 
                                                    objPkgViewROI,              // Package Test on second image
                                                    objChipUnitROI,             // Chipped off test on image 2
                                                    m_objPkgViewImage,          // Second package image (option)
                                                    m_objGrayValueImage_SideLight,
                                                    objMoldFlashROI,
                                                    m_smVisionInfo.g_intPackageInspectionAreaGrayValueSensitivity,
                                                    m_smVisionInfo.g_intPackageMergeSensitivity,
                                                    m_smVisionInfo.g_intPackageBrightSensitivity,
                                                    m_smVisionInfo.g_objWhiteImage, m_smVisionInfo.g_objBlackImage))
                {
                    m_smVisionInfo.g_strErrorMessage += m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_strErrorMessage;
                    if (blnAuto)
                    {
                        if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        {
                            m_blnPackageFail_Out = true;
                            if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                                if (m_intTCPIPResultID == -1)
                                    SetPackageResultID(m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailResultMask);
                        }
                        else
                        {
                            m_objVisionIO.PackageFail.SetOn(strTrackHeadName + " PackageFail 16"); if (m_smVisionInfo.g_blnTrackIO) STTrackLog.WriteLine("IO-PackageFail-Set ON 39");
                        }

                        SaveRejectImage_AddToBuffer("Package", m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_strErrorMessage);

                        m_smVisionInfo.g_intPkgDefectFailureTotal++;
                    }
                    blnResult = false;
                }
            }
            objPkgViewROI.Dispose();
            objPkgViewROI_DarkField2.Dispose();
            objPkgViewROI_DarkField3.Dispose();
            objPkgViewROI_DarkField4.Dispose();
            objChipUnitROI.Dispose();
            m_smVisionInfo.g_blnDrawPkgResult = true;
            m_smVisionInfo.g_blnPackageInspected = true;

            return blnResult;
        }

        private bool StartPackageTest_TopLightView(bool blnAuto)
        {
            bool blnResult = true;

            if ((m_smCustomizeInfo.g_intWantPackage & (1 << m_smVisionInfo.g_intVisionPos)) == 0 || !m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetWantInspectPackage())
                return true;

            // Check is templates learnt
            if (m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit].Count == 0)
            {
                m_smVisionInfo.g_strErrorMessage += "*Package : No Template Found";
                if (blnAuto)
                {
                    m_smVisionInfo.g_intNoTemplateFailureTotal++;
                }
                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        SetPackageResultID(m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailResultMask);

                return false;
            }

            // Make sure template unit size not set to zero
            if ((m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_fUnitWidthMin == 0 || m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_fUnitHeightMin == 0) ||
                (m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_fUnitWidthMax == 0 || m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_fUnitHeightMax == 0))
            {
                m_smVisionInfo.g_strErrorMessage += "*Package : Template Unit Size Min Max Setting cannot be zero.";
                if (blnAuto)
                {
                    m_smVisionInfo.g_intPackageFailureTotal++;
                }
                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        m_intTCPIPResultID = (int)TCPIPResulID.FailPackage;//FailPackageDimension;

                return false;
            }

            // ------------- Make sure grab image done ------------------------
            int intTopLightViewImageIndex = m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetGrabImageIndex(3);    // Top Light 
            if (intTopLightViewImageIndex == 0)
                WaitEventDone(ref m_bGrabImage1Done, true, 10000, "StartPackageTest > m_bGrabImage1Done d");
            else if (intTopLightViewImageIndex == 1)
                WaitEventDone(ref m_bGrabImage2Done, true, 10000, "StartPackageTest > m_bGrabImage2Done d");
            else if (intTopLightViewImageIndex == 2)
                WaitEventDone(ref m_bGrabImage3Done, true, 10000, "StartPackageTest > m_bGrabImage3Done d");
            else if (intTopLightViewImageIndex == 3)
                WaitEventDone(ref m_bGrabImage4Done, true, 10000, "StartPackageTest > m_bGrabImage4Done d");
            else if (intTopLightViewImageIndex == 4)
                WaitEventDone(ref m_bGrabImage5Done, true, 10000, "StartPackageTest > m_bGrabImage5Done d");
            else if (intTopLightViewImageIndex == 5)
                WaitEventDone(ref m_bGrabImage6Done, true, 10000, "StartPackageTest > m_bGrabImage6Done d");
            else if (intTopLightViewImageIndex == 6)
                WaitEventDone(ref m_bGrabImage7Done, true, 10000, "StartPackageTest > m_bGrabImage7Done d");
            else
            {
                m_smVisionInfo.g_strErrorMessage += "*Package : Wrong setting for package (Top Light View) image number. intTopLightViewImageIndex = " + intTopLightViewImageIndex.ToString();
                if (blnAuto)
                {
                    m_smVisionInfo.g_intPackageFailureTotal++;
                }
                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        SetPackageResultID(m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailResultMask);

                return false;
            }

            // 2022 02 16 - Hide this intTopLightViewImageIndex > 0. If silver unit, User will select image 0 for top light package also.
            //            - During orient test, system will copy ori image to rotated image object. 
            //            - rotated image will overlap with orient rotated image if no wait for orient data updated.
            // 2019 03 07 - ZJYeoh: Wait m_intOrientAngle value from StartOrientTest First
            //if (intTopLightViewImageIndex > 0)
            WaitEventDone(ref m_blnOrientDataUpdated, true, 10000, "StartPackageTest > m_blnOrientDataUpdated 7206");

            float fGaugeCenterX = 0, fGaugeCenterY = 0, fGaugeWidth = 0, fGaugeHeight = 0, fGaugeAngle = 0;

            // ---------  Rotate image 2 and 3 to oriented 0 deg -------------
            // 2019 04 30 - JBTAN: Top light view use m_smVisionInfo.g_arrPackageGauge2[0]
            if (m_objGauge_PkgTopView == null)
            {
                m_objGauge_PkgTopView = new RectGaugeM4L(m_smVisionInfo.g_WorldShape, 0, m_smVisionInfo.g_intVisionIndex);
            }

            if (!m_smVisionInfo.g_blnWantUseSideLightGauge)
            {
                //if (m_smVisionInfo.g_arrPackageGauge2[0] != null)
                //{
                //    m_smVisionInfo.g_arrPackageGauge2[0].CopyTo(ref m_objGauge_PkgTopView);
                //    GaugeMeasureUnit(m_objGauge_PkgTopView, m_smVisionInfo.g_arrImages[intTopLightViewImageIndex]);
                //}
                //else
                {
                    m_smVisionInfo.g_arrPackageGauge2M4L[m_smVisionInfo.g_intSelectedUnit].CopyTo(ref m_objGauge_PkgTopView);

                    int[] arrUserSelectImageViewIndex = m_objGauge_PkgTopView.GetGaugeImageNoList();

                    if (!WaitEventDone(arrUserSelectImageViewIndex, "arrUserSelectImageViewIndex 7230"))
                    {
                        m_smVisionInfo.g_strErrorMessage += "*Package : Wrong setting for package size image number.";
                        if (blnAuto)
                        {
                            m_smVisionInfo.g_intPackageFailureTotal++;
                        }
                        if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                            if (m_intTCPIPResultID == -1)
                                SetPackageResultID(m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailResultMask);

                        return false;
                    }

                    if (!GaugeMeasureUnit(m_objGauge_PkgTopView, m_smVisionInfo.g_arrImages))
                    {
                        m_smVisionInfo.g_strErrorMessage += "*Package : " + m_objGauge_PkgTopView.ref_strErrorMessage;
                        if (blnAuto)
                        {
                            m_smVisionInfo.g_intPackageFailureTotal++;
                        }
                        if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                            if (m_intTCPIPResultID == -1)
                                SetPackageResultID(m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailResultMask);

                        return false;
                    }
                }

                fGaugeCenterX = m_objGauge_PkgTopView.ref_pRectCenterPoint.X;
                fGaugeCenterY = m_objGauge_PkgTopView.ref_pRectCenterPoint.Y;
                fGaugeWidth = m_objGauge_PkgTopView.ref_fRectWidth;
                fGaugeHeight = m_objGauge_PkgTopView.ref_fRectHeight;
                fGaugeAngle = m_objGauge_PkgTopView.ref_fRectAngle;

            }
            else
            {
                WaitEventDone(ref m_bPackageSizeTestDone, true, 10000, "StartPackageTest > m_bPackageSizeTestDone 7260");
                fGaugeCenterX = m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X;
                fGaugeCenterY = m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y;
                fGaugeWidth = m_smVisionInfo.g_objGauge_PkgSize.ref_fRectWidth;
                fGaugeHeight = m_smVisionInfo.g_objGauge_PkgSize.ref_fRectHeight;
                fGaugeAngle = m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle;
            }
            float fTotalRotateAngle = m_intOrientAngle + fGaugeAngle;

            // Get RotateROI center point where the ROI center point == Unit Center Point
            m_objSubTh3_RotateROI.LoadROISetting(
                        (int)Math.Round(fGaugeCenterX -
                        m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][0].ref_ROIWidth / 2, 0, MidpointRounding.AwayFromZero),
                        (int)Math.Round(fGaugeCenterY -
                        m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][0].ref_ROIHeight / 2, 0, MidpointRounding.AwayFromZero),
                        m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][0].ref_ROIWidth,
                        m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][0].ref_ROIHeight);

            if (intTopLightViewImageIndex == 0)
            {
                /* 2019 07 14 - CCENG: 
                 * if g_blnWantGauge is false, mean Image 1 is rotated according to Orient Matching Angle, which is not 100% correct,
                 * because the Orient Matching Angle and Unit Angle may be different.
                 * So when come to Image 1 package size test, Image 1 need to be re-rotated  according to Package size result angle.
                 */
                if (m_smVisionInfo.g_blnWantGauge)
                {
                    // Wait StartOrientTest rotate image 1 done or mark test done. (sometime rotate image 1 done will not set to true if Orient fail).
                    WaitEventDone(ref m_blnRotateImage1Updated, ref m_bSubTh_MarkTest, true, false, "StartPackageTest_SideLightView > m_blnRotateImage1Updated 6542");
                }
                else
                {
                    // Since Mark Test Image index and top light package view image index are same, then need to Wait for Marktest done because Rotated image need to be tested by mark inspection function. After mark inspection, then only allow to re-rotate again using packge angle.
                    WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartPackageTest > m_bSubTh_MarkTest 6547");

                    if (!m_bSubTh_MarkTest_Result)
                    {
                        return false;   // Skip package inspection if mark test fail.
                    }

                    // Rotate image 3
                    m_objSubTh3_RotateROI.AttachImage(m_smVisionInfo.g_arrImages[intTopLightViewImageIndex]);
                    ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[intTopLightViewImageIndex], m_objSubTh3_RotateROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_PkgDark, ref m_smVisionInfo.g_arrRotatedImages, intTopLightViewImageIndex);

                    if (m_blnCustomWantColor && !GetColorImageRotated(intTopLightViewImageIndex) && !ContainColorSelectedImage(intTopLightViewImageIndex, m_smVisionInfo.g_intSelectedUnit))
                    {
                        CROI objColorRotatedROI = new CROI();
                        objColorRotatedROI.AttachImage(m_smVisionInfo.g_arrColorImages[intTopLightViewImageIndex]);

                        // Get RotateROI center point where the ROI center point == Package Unit Center Point
                        objColorRotatedROI.LoadROISetting(m_objSubTh3_RotateROI.ref_ROIPositionX,
                                                     m_objSubTh3_RotateROI.ref_ROIPositionY,
                                                     m_objSubTh3_RotateROI.ref_ROIWidth,
                                                     m_objSubTh3_RotateROI.ref_ROIHeight);

                        CROI.Rotate0Degree(m_smVisionInfo.g_arrColorImages[intTopLightViewImageIndex], objColorRotatedROI, fTotalRotateAngle, 4, ref m_smVisionInfo.g_arrColorRotatedImages, intTopLightViewImageIndex);

                        SetColorImageRotated(intTopLightViewImageIndex);
                        objColorRotatedROI.Dispose();
                    }
                }
            }
            else
            {
                // Rotate image 3
                m_objSubTh3_RotateROI.AttachImage(m_smVisionInfo.g_arrImages[intTopLightViewImageIndex]);
                ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[intTopLightViewImageIndex], m_objSubTh3_RotateROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_PkgDark, ref m_smVisionInfo.g_arrRotatedImages, intTopLightViewImageIndex);

                if (m_blnCustomWantColor && !GetColorImageRotated(intTopLightViewImageIndex) && !ContainColorSelectedImage(intTopLightViewImageIndex, m_smVisionInfo.g_intSelectedUnit))
                {
                    CROI objColorRotatedROI = new CROI();
                    objColorRotatedROI.AttachImage(m_smVisionInfo.g_arrColorImages[intTopLightViewImageIndex]);

                    // Get RotateROI center point where the ROI center point == Package Unit Center Point
                    objColorRotatedROI.LoadROISetting(m_objSubTh3_RotateROI.ref_ROIPositionX,
                                                 m_objSubTh3_RotateROI.ref_ROIPositionY,
                                                 m_objSubTh3_RotateROI.ref_ROIWidth,
                                                 m_objSubTh3_RotateROI.ref_ROIHeight);

                    CROI.Rotate0Degree(m_smVisionInfo.g_arrColorImages[intTopLightViewImageIndex], objColorRotatedROI, fTotalRotateAngle, 4, ref m_smVisionInfo.g_arrColorRotatedImages, intTopLightViewImageIndex);

                    SetColorImageRotated(intTopLightViewImageIndex);
                    objColorRotatedROI.Dispose();
                }
            }

            if (intTopLightViewImageIndex == 0)
                m_blnRotateImage1Updated = true;
            else if (intTopLightViewImageIndex == 1)
                m_blnRotateImage2Updated = true;
            else if (intTopLightViewImageIndex == 2)
                m_blnRotateImage3Updated = true;
            else if (intTopLightViewImageIndex == 3)
                m_blnRotateImage4Updated = true;
            else if (intTopLightViewImageIndex == 4)
                m_blnRotateImage5Updated = true;
            else if (intTopLightViewImageIndex == 5)
                m_blnRotateImage6Updated = true;
            else
                m_blnRotateImage7Updated = true;

            // Wait mark inspection done.
            WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartPackageTest > m_bSubTh_MarkTest 7297");    // need to wait for mark inspection done. Because package inspection need to use mark char area to set dont care area on package roi.
            if (!m_bSubTh_MarkTest_Result)
            {
                return false;   // Skip package inspection if mark test fail.
            }
            // Wait package test done under mark light view 
            WaitEventDone(ref m_bSubTh_PackageTest_MarkLightView, false, 10000, "StartPackageTest > m_bSubTh_PackageTest_MarkLightView 7302");
            if (!m_bSubTh_PackageTest_MarkLightView_Result)
            {
                return false;
            }
            // Wait SideLightView Package done because using same database (array)
            WaitEventDone(ref m_bSubTh_PackageTest_SideLightView, false, 10000, "StartPackageTest > m_bSubTh_PackageTest_SideLightView 7309");
            if (!m_bSubTh_PackageTest_SideLightView_Result)
            {
                return false;
            }

            m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_blnViewUnitPosition = true;
            //m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ClearDontCareAreaArray(); //2020-12-28 ZJYEOH : Only StartPackageTest_MarkLightView will use this dont care

            // ------- Copy image to temporary inspection image.
            if (intTopLightViewImageIndex >= 0)
            {
                if (m_objPkgViewImage2 == null)
                    m_objPkgViewImage2 = new ImageDrawing(true);
                m_smVisionInfo.g_arrRotatedImages[intTopLightViewImageIndex].CopyTo(ref m_objPkgViewImage2);
            }
            else if (m_objPkgViewImage2 != null)
                m_objPkgViewImage2 = null;

            if (intTopLightViewImageIndex >= 0)
            {
                if (m_objVoidViewImage == null)
                    m_objVoidViewImage = new ImageDrawing(true);
                m_smVisionInfo.g_arrRotatedImages[intTopLightViewImageIndex].CopyTo(ref m_objVoidViewImage);
            }
            else if (m_objVoidViewImage != null)
                m_objVoidViewImage = null;

            if (intTopLightViewImageIndex >= 0)
            {
                if (m_objCrackViewImage == null)
                    m_objCrackViewImage = new ImageDrawing(true);
                m_smVisionInfo.g_arrRotatedImages[intTopLightViewImageIndex].CopyTo(ref m_objCrackViewImage);
            }
            else if (m_objCrackViewImage != null)
                m_objCrackViewImage = null;

            bool blnWantMark = false;
            int intCharDilateHalfWidth = 2;
            if (m_smVisionInfo.g_arrMarks != null && m_smVisionInfo.g_arrMarks.Count > 0)
            {
                // 2020 04 15 - JBTAN: will continue to check mark even option uncheck check mark option
                // 2020 07 08 - Roll back to previous method, wont check mark if Mark Checking is not selected.
                blnWantMark = m_smVisionInfo.g_arrMarks[0].ref_blnCheckMark;
                //blnWantMark = true;
                intCharDilateHalfWidth = m_smVisionInfo.g_arrMarks[0].ref_intCharDilateHalfWidth; // thick iteration
            }

            if (m_smVisionInfo.g_intPackageDefectInspectionMethod != 0)
            {
                //2020-05-18 ZJYEOH : Get another Image without subtract mark area
                m_objCrackViewImage.CopyTo(ref m_objGrayValueImage_TopLight);
            }

            if (blnWantMark)
            {
                // ---------- Fill Mark Image's mark area with black color -------------------
                int intNumChars = m_smVisionInfo.g_arrMarks[0].GetNumChars();
                int intStartX = 0, intStartY = 0, intEndX = 0, intEndY = 0;

                int intOffsetX;
                int intOffsetY;

                if (m_smVisionInfo.g_blnWantGauge)  // Mean during mark inspection, orient gauge is used to measure unit position for m_objMarkTrainROI
                {
                    intOffsetX = m_objMarkTrainROI.ref_ROITotalX;
                    intOffsetY = m_objMarkTrainROI.ref_ROITotalY;
                }
                else if (m_smVisionInfo.g_arrMarkROIs[0].Count > 3)    // Mean during mark inspection, Unit PR is used to find unit surface position for m_objMarkTrainROI
                {
                    intOffsetX = m_objMarkTrainROI.ref_ROITotalX;
                    intOffsetY = m_objMarkTrainROI.ref_ROITotalY;
                }
                else // Mean during mark inspection, m_objMarkSearchROI is used.
                {
                    intOffsetX = m_objMarkTrainROI.ref_ROITotalX;
                    intOffsetY = m_objMarkTrainROI.ref_ROITotalY;
                }

                for (int i = 0; i < intNumChars; i++)
                {
                    int intRectStartX, intRectStartY, intRectEndX, intRectEndY;
                    intRectStartX = intRectStartY = intRectEndX = intRectEndY = 0;

                    bool blnIsBarPin1 = m_smVisionInfo.g_arrMarks[0].GetCharIsBarPin1(m_smVisionInfo.g_arrMarks[0].ref_intGroupIndex, m_smVisionInfo.g_arrMarks[0].ref_intTemplateIndex, i);
                    int intBarPin1Type = m_smVisionInfo.g_arrMarks[0].GetCharBarPin1Type(m_smVisionInfo.g_arrMarks[0].ref_intGroupIndex, m_smVisionInfo.g_arrMarks[0].ref_intTemplateIndex, i);
                    m_smVisionInfo.g_arrMarks[0].GetCharStartXY(i, ref intStartX, ref intStartY);
                    m_smVisionInfo.g_arrMarks[0].GetCharEndXY(i, ref intEndX, ref intEndY);

                    if (m_smVisionInfo.g_arrMarks[0].ref_blnWantDontCareIgnoredMarkWholeArea && !m_smVisionInfo.g_arrMarks[0].GetEnableMarkSetting(i))
                    {
                        //2021-01-18 ZJYEOH : Should use sample position
                        Point pStartTemplate = new Point(intStartX, intStartY);//m_smVisionInfo.g_arrMarks[0].GetTemplateCharROIStartPoint(i);
                        Point pEndTemplate = new Point(intEndX, intEndY);//m_smVisionInfo.g_arrMarks[0].GetTemplateCharROIEndPoint(i);

                        if ((intOffsetX + pStartTemplate.X - m_smVisionInfo.g_arrMarks[0].GetTemplateCharShiftX(i)) >= 0)
                            intRectStartX = intOffsetX + pStartTemplate.X - m_smVisionInfo.g_arrMarks[0].GetTemplateCharShiftX(i);
                        else
                            intRectStartX = intOffsetX;

                        if ((intOffsetY + pStartTemplate.Y - m_smVisionInfo.g_arrMarks[0].GetTemplateCharShiftY(i)) >= 0)
                            intRectStartY = intOffsetY + pStartTemplate.Y - m_smVisionInfo.g_arrMarks[0].GetTemplateCharShiftY(i);
                        else
                            intRectStartY = intOffsetY;

                        if ((intOffsetX + pEndTemplate.X + m_smVisionInfo.g_arrMarks[0].GetTemplateCharShiftX(i)) < m_smVisionInfo.g_intCameraResolutionWidth)
                            intRectEndX = intOffsetX + pEndTemplate.X + m_smVisionInfo.g_arrMarks[0].GetTemplateCharShiftX(i);
                        else
                            continue;
                        if ((intOffsetY + pEndTemplate.Y + m_smVisionInfo.g_arrMarks[0].GetTemplateCharShiftY(i)) < m_smVisionInfo.g_intCameraResolutionHeight)
                            intRectEndY = intOffsetY + pEndTemplate.Y + m_smVisionInfo.g_arrMarks[0].GetTemplateCharShiftY(i);
                        else
                            continue;
                    }
                    else
                    {
                        // 2019 10 11 - CCENG   : add intOffsetXY checking because rectangle will be filled on m_objPkgViewImage (Full image)
                        //                      : without the intOffsetXY, intRectStartX will set to intOffsetX and fill position may be shifted
                        if ((intOffsetX + intStartX - intCharDilateHalfWidth) >= 0)  //if ((intStartX - intCharDilateHalfWidth) >= 0) 
                            intRectStartX = intOffsetX + intStartX - intCharDilateHalfWidth;
                        else
                            intRectStartX = intOffsetX;

                        // 2019 10 11 - CCENG   : add intOffsetXY checking because rectangle will be filled on m_objPkgViewImage (Full image)
                        //                      : without the intOffsetXY, intRectStartX will set to intOffsetX and fill position may be shifted
                        if ((intOffsetY + intStartY - intCharDilateHalfWidth) >= 0)    //if ((intStartY - intCharDilateHalfWidth) >= 0)
                            intRectStartY = intOffsetY + intStartY - intCharDilateHalfWidth;
                        else
                            intRectStartY = intOffsetY;

                        if ((intEndX + intCharDilateHalfWidth) < m_smVisionInfo.g_intCameraResolutionWidth)
                            intRectEndX = intOffsetX + intEndX + intCharDilateHalfWidth;
                        else
                            intRectEndX = intOffsetX + intEndX;

                        if ((intEndY + intCharDilateHalfWidth) < m_smVisionInfo.g_intCameraResolutionHeight)
                            intRectEndY = intOffsetY + intEndY + intCharDilateHalfWidth;
                        else
                            intRectEndY = intOffsetY + intEndY;
                    }

                    //2020-05-28 ZJYEOH : extend the dont care area to fit the m_objMarkTrainROI size
                    if (blnIsBarPin1 && !m_smVisionInfo.g_blnWantCheckBarPin1)
                    {
                        if (intBarPin1Type == 0) // Virtical bar
                        {
                            intRectStartY = intOffsetY;
                            intRectEndY = intOffsetY + m_objMarkTrainROI.ref_ROIHeight;
                        }
                        else if (intBarPin1Type == 1) // Horizontal bar
                        {
                            intRectStartX = intOffsetX;
                            intRectEndX = intOffsetX + m_objMarkTrainROI.ref_ROIWidth;
                        }
                    }

                    if (intTopLightViewImageIndex >= 0 && !m_smVisionInfo.g_blnWantCheckVoidOnMarkArea)
                        Shape.FillRectangle(m_objPkgViewImage2, intRectStartX, intRectStartY, intRectEndX, intRectEndY, 255);
                    if (intTopLightViewImageIndex >= 0 && !m_smVisionInfo.g_blnWantCheckVoidOnMarkArea)
                        Shape.FillRectangle(m_objCrackViewImage, intRectStartX, intRectStartY, intRectEndX, intRectEndY, 255);
                    if (intTopLightViewImageIndex >= 0 && !m_smVisionInfo.g_blnWantCheckVoidOnMarkArea)
                        Shape.FillRectangle(m_objVoidViewImage, intRectStartX, intRectStartY, intRectEndX, intRectEndY, 255);

                    //m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].SetDontCareArea(intRectStartX, intRectStartY, intRectEndX, intRectEndY);//2020-12-28 ZJYEOH : Only StartPackageTest_MarkLightView will use this dont care
                }
            }

            if ((m_smCustomizeInfo.g_intWant2DCode & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
            {
                if (m_smVisionInfo.g_blnWantMark2DCode)
                {
                    // ---------- Fill 2D code area with black color -------------------
                    int intStartX = 0, intStartY = 0, intEndX = 0, intEndY = 0;

                    int intOffsetX;
                    int intOffsetY;

                    if (m_smVisionInfo.g_blnWantGauge)  // Mean during mark inspection, orient gauge is used to measure unit position for m_objMark2DCodeROI
                    {
                        intOffsetX = m_objMark2DCodeROI.ref_ROITotalX;
                        intOffsetY = m_objMark2DCodeROI.ref_ROITotalY;
                    }
                    else if (m_smVisionInfo.g_arrMarkROIs[0].Count > 3)    // Mean during mark inspection, Unit PR is used to find unit surface position for m_objMark2DCodeROI
                    {
                        intOffsetX = m_objMark2DCodeROI.ref_ROITotalX;
                        intOffsetY = m_objMark2DCodeROI.ref_ROITotalY;
                    }
                    else // Mean during mark inspection, m_objMarkSearchROI is used.
                    {
                        intOffsetX = m_objMark2DCodeROI.ref_ROITotalX;
                        intOffsetY = m_objMark2DCodeROI.ref_ROITotalY;
                    }

                    int intRectStartX, intRectStartY, intRectEndX, intRectEndY;
                    intRectStartX = intRectStartY = intRectEndX = intRectEndY = 0;

                    m_smVisionInfo.g_arrMarks[0].Get2DCodeStartEndXY(ref intStartX, ref intStartY, ref intEndX, ref intEndY);

                    intRectStartX = intOffsetX + intStartX;
                    intRectStartY = intOffsetY + intStartY;
                    intRectEndX = intOffsetX + intEndX;
                    intRectEndY = intOffsetY + intEndY;

                    if (intTopLightViewImageIndex >= 0 && !m_smVisionInfo.g_blnWantCheckVoidOnMarkArea)
                        Shape.FillRectangle(m_objPkgViewImage2, intRectStartX, intRectStartY, intRectEndX, intRectEndY, 255);
                    if (intTopLightViewImageIndex >= 0 && !m_smVisionInfo.g_blnWantCheckVoidOnMarkArea)
                        Shape.FillRectangle(m_objCrackViewImage, intRectStartX, intRectStartY, intRectEndX, intRectEndY, 255);
                    if (intTopLightViewImageIndex >= 0 && !m_smVisionInfo.g_blnWantCheckVoidOnMarkArea)
                        Shape.FillRectangle(m_objVoidViewImage, intRectStartX, intRectStartY, intRectEndX, intRectEndY, 255);

                    //m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].SetDontCareArea(intRectStartX, intRectStartY, intRectEndX, intRectEndY);//2020-12-28 ZJYEOH : Only StartPackageTest_MarkLightView will use this dont care
                }
            }

            // ----------- Define the actual location for unit and place the package roi on that location. ------------------------
            ROI objChipUnitROI2 = null; // Image 3 - Chip ROI
            if (intTopLightViewImageIndex >= 0)
            {
                objChipUnitROI2 = new ROI();
                //objChipUnitROI2.LoadROISetting((int)Math.Round((fGaugeCenterX - fGaugeWidth / 2), 0, MidpointRounding.AwayFromZero),
                //                               (int)Math.Round((fGaugeCenterY - fGaugeHeight / 2), 0, MidpointRounding.AwayFromZero),
                //                               (int)Math.Round(fGaugeWidth, 0, MidpointRounding.AwayFromZero),
                //                               (int)Math.Round(fGaugeHeight, 0, MidpointRounding.AwayFromZero));
                objChipUnitROI2.LoadROISetting((int)Math.Round((fGaugeCenterX - fGaugeWidth / 2) + m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelExtendFromLeft_Chip_Dark, 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round((fGaugeCenterY - fGaugeHeight / 2) + m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelExtendFromEdge_Chip_Dark, 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round(fGaugeWidth - m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelExtendFromLeft_Chip_Dark - m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelExtendFromRight_Chip_Dark, 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round(fGaugeHeight - m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelExtendFromEdge_Chip_Dark - m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelExtendFromBottom_Chip_Dark, 0, MidpointRounding.AwayFromZero));

                // Use pkg image for chip test as priority
                objChipUnitROI2.AttachImage(m_objPkgViewImage2);
            }

            ROI objVoidUnitROI = null; // Image 3 - Void ROI
            if (intTopLightViewImageIndex >= 0)
            {
                objVoidUnitROI = new ROI();
                if (m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_blnSeperateBrightDarkROITolerance)
                {
                    objVoidUnitROI.LoadROISetting((int)Math.Round((fGaugeCenterX -
                                    fGaugeWidth / 2 +
                                    m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromLeft_Dark), 0, MidpointRounding.AwayFromZero),
                                    (int)Math.Round((fGaugeCenterY -
                                    fGaugeHeight / 2 +
                                    m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromEdge_Dark), 0, MidpointRounding.AwayFromZero),
                                    (int)Math.Round(fGaugeWidth - m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromRight_Dark - m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromLeft_Dark, 0, MidpointRounding.AwayFromZero),
                                    (int)Math.Round(fGaugeHeight - m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromEdge_Dark - m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromBottom_Dark, 0, MidpointRounding.AwayFromZero));
                }
                else
                {
                    objVoidUnitROI.LoadROISetting((int)Math.Round((fGaugeCenterX -
                                    fGaugeWidth / 2 +
                                    m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromLeft), 0, MidpointRounding.AwayFromZero),
                                    (int)Math.Round((fGaugeCenterY -
                                    fGaugeHeight / 2 +
                                    m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromEdge), 0, MidpointRounding.AwayFromZero),
                                    (int)Math.Round(fGaugeWidth - m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromRight - m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromLeft, 0, MidpointRounding.AwayFromZero),
                                    (int)Math.Round(fGaugeHeight - m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromEdge - m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromBottom, 0, MidpointRounding.AwayFromZero));
                }

                objVoidUnitROI.AttachImage(m_objVoidViewImage);
            }
            ROI objCrackViewROI = null; // Image 3 - Crack ROI
            if (intTopLightViewImageIndex >= 0)
            {
                //RectGauge objGauge2 = m_smVisionInfo.g_arrPackageGauge[0];

                objCrackViewROI = new ROI();
                if (m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_blnSeperateBrightDarkROITolerance)
                {
                    objCrackViewROI.LoadROISetting((int)Math.Round((fGaugeCenterX -
                                fGaugeWidth / 2 +
                                m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromLeft_Dark), 0, MidpointRounding.AwayFromZero),
                                (int)Math.Round((fGaugeCenterY -
                                fGaugeHeight / 2 +
                                m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromEdge_Dark), 0, MidpointRounding.AwayFromZero),
                                (int)Math.Round(fGaugeWidth - m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromRight_Dark - m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromLeft_Dark, 0, MidpointRounding.AwayFromZero),
                                (int)Math.Round(fGaugeHeight - m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromEdge_Dark - m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromBottom_Dark, 0, MidpointRounding.AwayFromZero));
                }
                else
                {
                    objCrackViewROI.LoadROISetting((int)Math.Round((fGaugeCenterX -
                                fGaugeWidth / 2 +
                                m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromLeft), 0, MidpointRounding.AwayFromZero),
                                (int)Math.Round((fGaugeCenterY -
                                fGaugeHeight / 2 +
                                m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromEdge), 0, MidpointRounding.AwayFromZero),
                                (int)Math.Round(fGaugeWidth - m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromRight - m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromLeft, 0, MidpointRounding.AwayFromZero),
                                (int)Math.Round(fGaugeHeight - m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromEdge - m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromBottom, 0, MidpointRounding.AwayFromZero));
                }
                objCrackViewROI.AttachImage(m_objCrackViewImage);
            }

            if (m_smVisionInfo.g_blnWantDontCareArea_Package)
            {
                if (intTopLightViewImageIndex >= 0)
                {
                    ////Draw don't care ROI edge to make sure Don't Care Area is not inspected
                    //for (int k = 3; k < m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit].Count; k++)
                    //{
                    //    m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][k].AttachImage(objCrackViewROI);
                    //    ROI objROI = new ROI();
                    //    objROI.LoadROISetting((int)Math.Round((fGaugeCenterX - fGaugeWidth / 2 + m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][k].ref_ROIPositionX), 0, MidpointRounding.AwayFromZero),
                    //                          (int)Math.Round((fGaugeCenterY - fGaugeHeight / 2 + m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][k].ref_ROIPositionY), 0, MidpointRounding.AwayFromZero),
                    //                           m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][k].ref_ROIWidth, m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][k].ref_ROIHeight);
                    //    objROI.AttachImage(m_smVisionInfo.g_objWhiteImage);
                    //    ROI.LogicOperationAddROI(m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit][k], objROI);
                    //    //objCrackViewROI.SaveImage("D:\\aaa.bmp");
                    //    objROI.Dispose();
                    //}

                    ROI objDontCareROI = new ROI();
                    //objDontCareROI.LoadROISetting(0, 0, objCrackViewROI.ref_ROIWidth, objCrackViewROI.ref_ROIHeight);
                    // 2020 06 27 - CCENG: objDontCareROI have to start from Package Tolerance bcos g_objDontCareImage_Package_Dark template is start from Package Size Template.
                    if (m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_blnSeperateBrightDarkROITolerance)
                    {
                        objDontCareROI.LoadROISetting(m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromLeft_Dark,
                              m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromEdge_Dark,
                              objCrackViewROI.ref_ROIWidth, objCrackViewROI.ref_ROIHeight);
                    }
                    else
                    {
                        objDontCareROI.LoadROISetting(m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromLeft,
                              m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromEdge,
                              objCrackViewROI.ref_ROIWidth, objCrackViewROI.ref_ROIHeight);
                    }
                    objDontCareROI.AttachImage(m_smVisionInfo.g_objDontCareImage_Package_Dark);
                    ROI.LogicOperationAddROI(objCrackViewROI, objDontCareROI);
                    objDontCareROI.Dispose();
                }
            }

            if (m_smVisionInfo.g_intPackageDefectInspectionMethod == 0)
            {
                if (!m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].DoInspection_TopLightView(//m_objGauge_PkgTopView,   // use to measure unit edge
                                                    fGaugeCenterX, fGaugeCenterY,
                                                    fGaugeWidth, fGaugeHeight,
                                                    objCrackViewROI,            // Crack test
                                                    objChipUnitROI2,            // Chipped off test on image 3
                                                    objVoidUnitROI, // Void Test using Image 3
                                                    m_smVisionInfo.g_arrRotatedImages[intTopLightViewImageIndex],       // Image from Top light source
                                                    m_smVisionInfo.g_objWhiteImage, m_smVisionInfo.g_objBlackImage))
                {
                    m_smVisionInfo.g_strErrorMessage += m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_strErrorMessage;
                    if (blnAuto)
                    {
                        if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        {
                            m_blnPackageFail_Out = true;
                            if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                                if (m_intTCPIPResultID == -1)
                                {
                                    SetPackageResultID(m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailResultMask);
                                }
                        }
                        else
                        {
                            m_objVisionIO.PackageFail.SetOn(strTrackHeadName + " PackageFail 17"); if (m_smVisionInfo.g_blnTrackIO) STTrackLog.WriteLine("IO-PackageFail-Set ON 40");
                        }

                        SaveRejectImage_AddToBuffer("Package", m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_strErrorMessage);

                        m_smVisionInfo.g_intPkgDefectFailureTotal++;
                    }
                    blnResult = false;
                }
            }
            else
            {
                if (!m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].DoInspection_TopLightView_GrayValueThresholdMethod(//m_objGauge_PkgTopView,   // use to measure unit edge
                                                   fGaugeCenterX, fGaugeCenterY,
                                                   fGaugeWidth, fGaugeHeight,
                                                   objCrackViewROI,            // Crack test
                                                   objChipUnitROI2,            // Chipped off test on image 3
                                                   objVoidUnitROI, // Void Test using Image 3
                                                   m_smVisionInfo.g_arrRotatedImages[intTopLightViewImageIndex],       // Image from Top light source
                                                   m_objGrayValueImage_TopLight,
                                                   m_smVisionInfo.g_intPackageInspectionAreaGrayValueSensitivity,
                                                   m_smVisionInfo.g_intPackageMergeSensitivity,
                                                  m_smVisionInfo.g_intPackageDarkSensitivity,
                                                  m_smVisionInfo.g_objWhiteImage, m_smVisionInfo.g_objBlackImage))
                {
                    m_smVisionInfo.g_strErrorMessage += m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_strErrorMessage;
                    if (blnAuto)
                    {
                        if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        {
                            m_blnPackageFail_Out = true;
                            if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                                if (m_intTCPIPResultID == -1)
                                    SetPackageResultID(m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailResultMask);
                        }
                        else
                        {
                            m_objVisionIO.PackageFail.SetOn(strTrackHeadName + " PackageFail 17"); if (m_smVisionInfo.g_blnTrackIO) STTrackLog.WriteLine("IO-PackageFail-Set ON 41");
                        }

                        SaveRejectImage_AddToBuffer("Package", m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_strErrorMessage);

                        m_smVisionInfo.g_intPkgDefectFailureTotal++;
                    }
                    blnResult = false;
                }
            }
            objVoidUnitROI.Dispose();
            objChipUnitROI2.Dispose();
            objCrackViewROI.Dispose();
            m_smVisionInfo.g_blnDrawPkgResult = true;
            m_smVisionInfo.g_blnPackageInspected = true;

            return blnResult;
        }
        private void WaitEventDone(ref bool bTriggerEvent, bool bBreakResult, int intTimeout, string strTrackName)
        {
            HiPerfTimer timeout = new HiPerfTimer();
            timeout.Start();

            while (true)
            {
                if (bTriggerEvent == bBreakResult)
                {
                    //STTrackLog.WriteLine("Time = " + timeout.Timing.ToString());
                    return;
                }

#if (RELEASE || RTXRelease || Release_2_12)
                if (timeout.Timing > intTimeout)
                {
                    STTrackLog.WriteLine(">>>>>>>>>>>>> Vision 1 time out 9 - " + strTrackName);
                    bTriggerEvent = bBreakResult;
                    break;
                }
#endif
                Thread.Sleep(1);    // 2018 10 01 - CCENG: Dun use Sleep(0) as it may cause other internal thread hang especially during waiting for grab image done. (Grab frame timeout happen)
            }

            timeout.Stop();
        }
        private void StartTest_MultiThreading(bool blnAuto)
        {
            if (m_smVisionInfo.g_blnTrackBasic) STTrackLog.WriteLine("V1-Basic-4");

            m_smVisionInfo.g_objProcessTime.Start();

            //m_T1.Start();
            //m_strTrack = "";
            //m_fTimingPrev = 0;
            //m_fTiming = 0;
            //m_strResultTrack = "";

            WaitEventDone(ref m_bSubTh_StartAfterInspect, false, 10000, "StartTest_MultiThreading > m_bSubTh_StartAfterInspect A22");

            if (m_smVisionInfo.g_blnTrackBasic) STTrackLog.WriteLine("V1-Basic-5");
            //m_fTiming = m_T1.Timing;
            //m_strTrack += ", 1=" + (m_fTiming - m_fTimingPrev).ToString();
            //m_fTimingPrev = m_fTiming;

            m_blnAuto = blnAuto;
            bool blnResultOK = true;
            m_fOrientFinalAngleForLead = 0;
            m_blnOrientDataUpdated = false;
            m_blnRotateImage1Updated = false;
            m_blnRotateImage2Updated = false;
            m_blnRotateImage3Updated = false;
            m_blnRotateImage4Updated = false;
            m_blnRotateImage5Updated = false;
            m_blnRotateImage6Updated = false;
            m_blnRotateImage7Updated = false;
            m_blnRotateColorImage1Updated = false;
            m_blnRotateColorImage2Updated = false;
            m_blnRotateColorImage3Updated = false;
            m_blnRotateColorImage4Updated = false;
            m_blnRotateColorImage5Updated = false;
            m_blnRotateColorImage6Updated = false;
            m_blnRotateColorImage7Updated = false;
            m_smVisionInfo.g_blnLeadInspected = false;
            m_smVisionInfo.g_blnMarkInspected = false;
            m_smVisionInfo.g_blnPackageInspected = false;
            m_smVisionInfo.g_blnDrawPin1Result = false;
            m_smVisionInfo.g_blnDrawMarkResult = false;
            m_smVisionInfo.g_blnDrawMark2DCodeResult = false;
            m_smVisionInfo.g_blnDrawPkgResult = false;
            m_smVisionInfo.g_blnViewOrientObject = false;
            m_smVisionInfo.g_blnViewGaugeNotFound = false;
            m_fOrientTotalRotateAngle = 0;
            m_pOrientRotateStartPoint = new Point(0, 0);
            m_pOrientRotateSize = new Size(1, 1);
            m_bLeadBaseCenterPointDone = false;
            m_bLeadBaseCenterPointResult = false;

            m_smVisionInfo.g_pMarkROIDrawing[0] = new Point(0, 0);
            m_smVisionInfo.g_pMarkROIDrawing[1] = new Point(0, 0);
            m_smVisionInfo.g_pMarkROIDrawing[2] = new Point(0, 0);
            m_smVisionInfo.g_pMarkROIDrawing[3] = new Point(0, 0);

            m_smVisionInfo.g_pMarkROIDrawing_Lead[0] = new Point(0, 0);
            m_smVisionInfo.g_pMarkROIDrawing_Lead[1] = new Point(0, 0);
            m_smVisionInfo.g_pMarkROIDrawing_Lead[2] = new Point(0, 0);
            m_smVisionInfo.g_pMarkROIDrawing_Lead[3] = new Point(0, 0);

            m_smVisionInfo.g_pLeadDontCareRotateCenter = new Point(-1, -1);

            m_bPackageSizeTestDone = false;
            m_bPackageSizePreTestDone = false;
            m_bPackageSizePreTestResult = false;
            m_smVisionInfo.g_blnGrabbing = true;
            m_bGrabImageFinalResult = m_bGrabImage1Result = m_bGrabImage2Result = m_bGrabImage3Result = m_bGrabImage4Result = m_bGrabImage5Result = m_bGrabImage6Result = m_bGrabImage7Result = false;
            m_bGrabImage1Done = m_bGrabImage2Done = m_bGrabImage3Done = m_bGrabImage4Done = m_bGrabImage5Done = m_bGrabImage6Done = m_bGrabImage7Done = false;
            m_smVisionInfo.g_blnNoGrabTime = false;
            ShowLiterationOnly = m_smVisionInfo.g_blnWantShowLiterationOnly;

            if (m_smVisionInfo.g_blnTrackBasic) STTrackLog.WriteLine("V1-Basic-6");

            if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
            {
                m_blnPackageFail_Out = false;
            }
            else
            {
                if (m_objVisionIO.PackageFail != null)
                    if (m_objVisionIO.PackageFail.IsOn())
                        m_objVisionIO.PackageFail.SetOff("V4 PackageFail 100"); if (m_smVisionInfo.g_blnTrackIO) STTrackLog.WriteLine("IO-PackageFail -Set Off 42");
            }

            if (blnAuto)
            {
                //Thread.Sleep(m_smVisionInfo.g_intCameraGrabDelay); //29-05-2019 ZJYEOH : Moved it to After Grabtime Start counting 

                if (!m_smProductionInfo.g_blnAllRunWithoutGrabImage)
                {
                    m_bSubTh1_GrabImage = true;  // Trigger Sub Thread 1 to grab images
                }
                else
                {
                    m_smVisionInfo.g_objGrabTime.Reset();
                    m_smVisionInfo.g_objTransferTime.Reset();
                    m_smVisionInfo.g_blnGrabbing = false;
                    m_bGrabImage1Result = m_bGrabImage2Result = m_bGrabImage3Result = m_bGrabImage4Result = m_bGrabImage5Result = m_bGrabImage6Result = m_bGrabImage7Result = true;
                    m_bGrabImage1Done = m_bGrabImage2Done = m_bGrabImage3Done = m_bGrabImage4Done = m_bGrabImage5Done = m_bGrabImage6Done = m_bGrabImage7Done = true;
                    m_smVisionInfo.g_blnNoGrabTime = true;
                    m_blnGrabbing_Out = false;
                }
            }
            else if (m_smVisionInfo.MN_PR_GrabImage)
            {
                m_smVisionInfo.MN_PR_GrabImage = false;

                m_bSubTh1_GrabImage = true;  // Trigger Sub Thread 1 to grab images
            }
            else
            {
                m_smVisionInfo.g_objGrabTime.Reset();
                m_smVisionInfo.g_objTransferTime.Reset();
                m_smVisionInfo.g_blnGrabbing = false;
                m_bGrabImage1Result = m_bGrabImage2Result = m_bGrabImage3Result = m_bGrabImage4Result = m_bGrabImage5Result = m_bGrabImage6Result = m_bGrabImage7Result = true;
                m_bGrabImage1Done = m_bGrabImage2Done = m_bGrabImage3Done = m_bGrabImage4Done = m_bGrabImage5Done = m_bGrabImage6Done = m_bGrabImage7Done = true;
                m_smVisionInfo.g_blnNoGrabTime = true;
            }

            // ----------- Define what test going to do --------------------------------------------

            if (m_smVisionInfo.g_blnTrackBasic) STTrackLog.WriteLine("V1-Basic-7");

            if ((m_smCustomizeInfo.g_intWantPackage & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
            {
                if (!m_blnWantPackageTest)
                    m_blnWantPackageTest = true;
            }
            else
            {
                if (m_blnWantPackageTest)
                    m_blnWantPackageTest = false;
            }

            if ((m_smCustomizeInfo.g_intWantOrient & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
            {
                if (!m_blnWantOrientTest)
                    m_blnWantOrientTest = true;
            }
            else
            {
                if (m_blnWantOrientTest)
                    m_blnWantOrientTest = false;
            }

            if ((m_smCustomizeInfo.g_intWantMark & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
            {
                if (!m_blnWantMarkTest)
                    m_blnWantMarkTest = true;
            }
            else
            {
                if (m_blnWantMarkTest)
                    m_blnWantMarkTest = false;
            }

            if ((m_smCustomizeInfo.g_intWantLead & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
            {
                if (!m_blnWantLeadTest)
                    m_blnWantLeadTest = true;
            }
            else
            {
                if (m_blnWantLeadTest)
                    m_blnWantLeadTest = false;
            }

            // ------------------ Reset Inspection data ----------------------------------------------
            if (m_blnWantPackageTest)
            {
                //if (!m_smVisionInfo.g_blnViewColorImage)
                {
                    if (m_smVisionInfo.g_arrPackage != null && m_smVisionInfo.g_arrPackage.Count > 0)
                        m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ResetPackageInspectionData();
                }
            }

            if (m_smVisionInfo.g_blnWantPin1)
            {
                for (int i = 0; i < m_smVisionInfo.g_arrPin1.Count; i++)
                {
                    m_smVisionInfo.g_arrPin1[i].ResetInspectionData();
                }
            }

            if (m_blnWantLeadTest)
            {
                for (int i = 0; i < m_smVisionInfo.g_arrLead.Length; i++)
                {
                    if (i == 0)
                        m_smVisionInfo.g_arrLead[i].ResetInspectionData();

                    if (!m_smVisionInfo.g_arrLead[i].ref_blnSelected)
                    {
                        // 2021 08 23 - CCENG: Make sure inspection data are cleared also when user change lead inspection direction from left right <> top bottom
                        //                     If no clear it, user will see the number display on image at point gauge profile form.
                        m_smVisionInfo.g_arrLead[i].ResetNoInspectionData();
                        continue;
                    }

                    m_smVisionInfo.g_arrLead[i].ref_blnLock = true;

                    // Reset previous inspection data
                    m_smVisionInfo.g_arrLead[i].ResetInspectionData();
                }
            }

            if (m_smVisionInfo.g_blnTrackBasic) STTrackLog.WriteLine("V1-Basic-8");

            // ----------------- Trigger Sub Thread test now -----------------------------------------
#if (DEBUG || Debug_2_12 || RTXDebug)
            m_bSubTh_PackageTest_PackageSize_Result = false;
            m_bSubTh_PackageTest_MarkLightView_Result = false;
            m_bSubTh_PackageTest_SideLightView_Result = false;
            m_bSubTh_PackageTest_TopLightView_Result = false;

            if (m_blnWantMarkTest || m_blnWantOrientTest)
            {
                m_bSubTh_MarkTest = true;
            }
            else
            {
                m_bSubTh_MarkTest_Result = true;
            }

            if (m_blnWantPackageTest)
            {
                m_bSubTh_PackageTest_MarkLightView = true;
                m_bSubTh_PackageTest_SideLightView = true;
                m_bSubTh_PackageTest_TopLightView = true;
            }
            else
            {
                m_bSubTh_PackageTest_MarkLightView_Result = true;
                m_bSubTh_PackageTest_SideLightView_Result = true;
                m_bSubTh_PackageTest_TopLightView_Result = true;
            }

            if (m_blnWantLeadTest)
            {
                m_bSubTh_LeadTest = true;
            }
            else
            {
                m_bSubTh_LeadTest_Result = true;
            }

            if (m_blnCustomWantColor)
            {
                m_bSubTh_PackageColorTest = true;
            }
            else
            {
                m_bSubTh_PackageColorTest_Result = true;
            }

#else
            m_bSubTh_PackageTest_PackageSize_Result = false;
            m_bSubTh_PackageTest_MarkLightView_Result = false;
            m_bSubTh_PackageTest_SideLightView_Result = false;
            m_bSubTh_PackageTest_TopLightView_Result = false;


            if (m_blnWantMarkTest || m_blnWantOrientTest)
            {
                m_bSubTh_MarkTest = true;
            }
            else
            {
                m_bSubTh_MarkTest_Result = true;
            }

            if (m_blnWantPackageTest)
            {
                m_bSubTh_PackageTest_MarkLightView = true;
                m_bSubTh_PackageTest_SideLightView = true;
                m_bSubTh_PackageTest_TopLightView = true;
            }
            else
            {
                m_bSubTh_PackageTest_MarkLightView_Result = true;
                m_bSubTh_PackageTest_SideLightView_Result = true;
                m_bSubTh_PackageTest_TopLightView_Result = true;
            }

            if (m_blnWantLeadTest)
            {
                m_bSubTh_LeadTest = true;
            }
            else
            {
                m_bSubTh_LeadTest_Result = true;
            }
            
            if (m_blnCustomWantColor)
            {
                m_bSubTh_PackageColorTest = true;
            }
            else
            {
                m_bSubTh_PackageColorTest_Result = true;
            }

#endif

            if (m_smVisionInfo.g_blnTrackBasic) STTrackLog.WriteLine("V1-Basic-9");
            // ------------------ Wait Sub Thread Test done --------------------------------------------------
            bool blnInspectionDone = false;
            HiPerfTimer timeout = new HiPerfTimer();
            timeout.Start();
            while (true)
            {
                if (!m_bSubTh_MarkTest &&
                    !m_bSubTh_PackageTest_MarkLightView &&
                    !m_bSubTh_PackageTest_SideLightView &&
                    !m_bSubTh_PackageTest_TopLightView &&
                    !m_bSubTh_LeadTest &&
                    !m_bSubTh_PackageColorTest)
                {
                    blnInspectionDone = true;
                    break;
                }

#if (RELEASE || RTXRelease || Release_2_12)

                if (timeout.Timing > 10000) // 2020 02 18 - CCENG: Change to 10ms to prevent inspection time out due to debug run too fast.
                {
                    string strFileName = DateTime.Now.ToString("yyyy-MM-dd_HH-mm");
                    for (int m = 0; m < m_smVisionInfo.g_arrImages.Count; m++)
                    {
                        m_smVisionInfo.g_arrImages[m].SaveImage("D:\\ErrorImage\\V1_image_" + strFileName + "_" + m.ToString() + ".bmp");
                    }
                    STTrackLog.WriteLine(">>>>>>>>>>>>> Vision 1 - time out 7.");
                    STTrackLog.WriteLine(">>>>>>>>>>>>> Vision 1 - m_bSubTh_MarkTest=" + m_bSubTh_MarkTest.ToString());
                    STTrackLog.WriteLine(">>>>>>>>>>>>> Vision 1 - m_bSubTh_PackageTest_MarkLightView=" + m_bSubTh_PackageTest_MarkLightView.ToString());
                    STTrackLog.WriteLine(">>>>>>>>>>>>> Vision 1 - m_bSubTh_PackageTest_SideLightView=" + m_bSubTh_PackageTest_SideLightView.ToString());
                    STTrackLog.WriteLine(">>>>>>>>>>>>> Vision 1 - m_bSubTh_PackageTest_TopLightView=" + m_bSubTh_PackageTest_TopLightView.ToString());
                    STTrackLog.WriteLine(">>>>>>>>>>>>> Vision 1 - m_bSubTh_LeadTest=" + m_bSubTh_LeadTest.ToString());
                    STTrackLog.WriteLine(">>>>>>>>>>>>> Vision 1 - m_bSubTh_PackageColorTest=" + m_bSubTh_PackageColorTest.ToString());

                    break;
                }

#endif
                Thread.Sleep(1);
            }
            
            if (m_smVisionInfo.g_blnTrackBasic) STTrackLog.WriteLine("V1-Basic-10");
            // ---------------------- Action after Sub Thread Test Done -----------------------------------------------------------
            if (m_smVisionInfo.g_blnUnitInspected.Length > 0)
                m_smVisionInfo.g_blnUnitInspected[0] = true;

            // ------------------ Set IO to handler (set before save image for faster UPH) ----------------------------------------
            // Define Final result is pass or fail.
            if (blnInspectionDone &&
                m_bSubTh_MarkTest_Result &&
                m_bSubTh_PackageTest_MarkLightView_Result &&
                m_bSubTh_PackageTest_SideLightView_Result &&
                m_bSubTh_PackageTest_TopLightView_Result &&
                m_bSubTh_LeadTest_Result &&
                m_bSubTh_PackageColorTest_Result)
            {
                if (m_smVisionInfo.g_blnTrackBasic) STTrackLog.WriteLine("V1-Basic-11");
                if (blnAuto)
                {
                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    {
                        WaitEventDone(ref m_blnGrabbing_Out, false, 10000, "m_blnGrabbing_Out");//2021-03-24 ZJYEOH : Wait grab done send to handler first
                        m_blnPass1_Out = true;

                        //2021-03-24 ZJYEOH : Wait at least 5ms before send result
                        float fDelay = 5 - Math.Max(0, m_smVisionInfo.g_objTotalTime.Timing - m_smVisionInfo.g_objGrabTime.Duration);
                        if (fDelay >= 1)
                            Thread.Sleep((int)fDelay);

                        if (m_blnCheckOffset_In)
                            m_smTCPIPIO.Send_ResultForCheckOffset(m_smVisionInfo.g_intVisionIndex, true, m_blnOrientResult1_Out, m_blnOrientResult2_Out, m_fOffsetX, m_fOffsetY, m_fOffsetAngle, true);
                        else
                            m_smTCPIPIO.Send_Result(m_smVisionInfo.g_intVisionIndex, true, m_blnOrientResult1_Out, m_blnOrientResult2_Out, m_intTCPIPResultID);
                    }
                    else
                    {
                        WaitEventDone(ref m_blnGrabbing_Out, false, 10000, "m_blnGrabbing_Out");
                        float fGrabDelay = 5 - m_smVisionInfo.g_objGrabDoneTime.Timing;
                        if (fGrabDelay >= 1)
                            Thread.Sleep((int)fGrabDelay);

                        m_objVisionIO.IOPass1.SetOn(strTrackHeadName + " IOPass1 19"); if (m_smVisionInfo.g_blnTrackIO) STTrackLog.WriteLine("IO-IOPass1-Set ON 43");
                        m_smVisionInfo.g_objGrabDoneTime.Stop();
                    }
                }

                blnResultOK = true;
            }
            else
            {
                if (m_smVisionInfo.g_blnTrackBasic) STTrackLog.WriteLine("V1-Basic-12");
                blnResultOK = false;

                //want no mark feature
                if (m_smVisionInfo.g_blnWantCheckNoMark)
                {
                    if ((m_smVisionInfo.g_arrMarks[0].ref_intFailResultMask & 0x1000) > 0)
                    {
                        if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        {
                            m_blnMarkFail_Out = true;
                            if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                                if (m_intTCPIPResultID == -1)
                                    m_intTCPIPResultID = (int)TCPIPResulID.FailMark;//FailNoMark;
                        }
                        else
                        {
                            m_objVisionIO.FailNoMark.SetOn(strTrackHeadName + " FailNoMark 20"); if (m_smVisionInfo.g_blnTrackIO) STTrackLog.WriteLine("IO-FailNoMark-Set ON 44");
                        }
                    }
                }

                if (blnAuto && m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                {
                    WaitEventDone(ref m_blnGrabbing_Out, false, 10000, "m_blnGrabbing_Out");//2021-03-24 ZJYEOH : Wait grab done send to handler first

                    //2021-03-24 ZJYEOH : Wait at least 5ms before send result
                    float fDelay = 5 - Math.Max(0, m_smVisionInfo.g_objTotalTime.Timing - m_smVisionInfo.g_objGrabTime.Duration);
                    if (fDelay >= 1)
                        Thread.Sleep((int)fDelay);

                    if (m_blnCheckOffset_In)
                        m_smTCPIPIO.Send_ResultForCheckOffset(m_smVisionInfo.g_intVisionIndex, false, m_blnOrientResult1_Out, m_blnOrientResult2_Out, m_fOffsetX, m_fOffsetY, m_fOffsetAngle, false);
                    else
                        m_smTCPIPIO.Send_Result(m_smVisionInfo.g_intVisionIndex, false, m_blnOrientResult1_Out, m_blnOrientResult2_Out, m_intTCPIPResultID);
                }
            }

            //m_objVisionIO.FailNoMark.SetOn(strTrackHeadName + " FailNoMark 20");
            // 2019 04 10 CCENG: Move this Single Orient Test to Sub tread already.
            // 2019 04 04 ZJYEOH: Test Orient Only 
            //if ((m_smCustomizeInfo.g_intWantOrient & (1 << m_smVisionInfo.g_intVisionPos)) > 0 && (m_smCustomizeInfo.g_intWantMark & (1 << m_smVisionInfo.g_intVisionPos)) == 0)
            //{
            //    if (!StartOrientTest(blnAuto))
            //        blnResultOK = false;
            //}

            if (m_smVisionInfo.g_blnTrackBasic) STTrackLog.WriteLine("V1-Basic-13");

            if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
            {
                m_blnEndVision_Out = true;
            }
            else
            {
                m_objVisionIO.IOEndVision.SetOn(strTrackHeadName + " IOEndVision 21"); if (m_smVisionInfo.g_blnTrackIO) STTrackLog.WriteLine("IO-IOEndVision-Set ON 45");
            }

            if (m_smVisionInfo.g_blnTrackBasic) STTrackLog.WriteLine("V1-Basic-14");
            // Wait all images grab done to make sure latest images are saved.
            WaitAllImageGrabDone();
            m_smVisionInfo.g_blnGrabbing = false;

            if (blnResultOK)
            {
                m_smVisionInfo.g_strResult = "Pass";

                if (blnAuto)
                {
                    m_smVisionInfo.g_intPassTotal++;
                    m_smVisionInfo.g_intContinuousPassUnitCount++;
                    SavePassImage_AddToBuffer();
                }
                else
                {
                    m_smVisionInfo.g_cErrorMessageColor = Color.Black;
                    m_smVisionInfo.g_strErrorMessage = "Offline Test Pass!";
                }
            }
            else
            {
                m_smVisionInfo.g_strResult = "Fail";

                if (blnAuto)
                {
                    m_smVisionInfo.g_intContinuousFailUnitCount++;
                }
                else
                {
                    m_smVisionInfo.g_strErrorMessage = "Offline Test Fail! " + "*" + m_smVisionInfo.g_strErrorMessage;
                }
            }

            if (m_smVisionInfo.g_blnTrackBasic) STTrackLog.WriteLine("V1-Basic-15");
            if (blnAuto)
            {
                m_smVisionInfo.g_intTestedTotal++;
                m_smVisionInfo.g_intLowYieldUnitCount++;
                CheckLowYield();
                CheckContinuousPass();
                CheckContinuousFail();
            }

            if (m_smVisionInfo.g_blnTrackBasic) STTrackLog.WriteLine("V1-Basic-16");
            // 2019 05 30 - JBTAN: Temporary solution for multi view test rotated images no update and show black image
            //// 2019 01 28 - CCENG: Not need purposely rotate image for user view.
            if (!m_blnRotateImage1Updated)
            {
                if (m_smVisionInfo.g_arrImages.Count > 0)
                    m_smVisionInfo.g_arrImages[0].CopyTo(ref m_smVisionInfo.g_arrRotatedImages, 0);
            }

            if (!m_blnRotateImage2Updated)
            {
                if (m_smVisionInfo.g_arrImages.Count > 1)
                    m_smVisionInfo.g_arrImages[1].CopyTo(ref m_smVisionInfo.g_arrRotatedImages, 1);
            }

            if (!m_blnRotateImage3Updated)
            {
                if (m_smVisionInfo.g_arrImages.Count > 2)
                    m_smVisionInfo.g_arrImages[2].CopyTo(ref m_smVisionInfo.g_arrRotatedImages, 2);
            }

            if (!m_blnRotateImage4Updated)
            {
                if (m_smVisionInfo.g_arrImages.Count > 3)
                    m_smVisionInfo.g_arrImages[3].CopyTo(ref m_smVisionInfo.g_arrRotatedImages, 3);
            }

            if (!m_blnRotateImage5Updated)
            {
                if (m_smVisionInfo.g_arrImages.Count > 4)
                    m_smVisionInfo.g_arrImages[4].CopyTo(ref m_smVisionInfo.g_arrRotatedImages, 4);
            }

            if (!m_blnRotateImage6Updated)
            {
                if (m_smVisionInfo.g_arrImages.Count > 5)
                    m_smVisionInfo.g_arrImages[5].CopyTo(ref m_smVisionInfo.g_arrRotatedImages, 5);
            }

            if (!m_blnRotateImage7Updated)
            {
                if (m_smVisionInfo.g_arrImages.Count > 6)
                    m_smVisionInfo.g_arrImages[6].CopyTo(ref m_smVisionInfo.g_arrRotatedImages, 6);
            }

            if (m_smVisionInfo.g_blnTrackBasic) STTrackLog.WriteLine("V1-Basic-17");
            if (((m_smCustomizeInfo.g_intWantPackage & (1 << m_smVisionInfo.g_intVisionPos)) > 0) || ((m_smCustomizeInfo.g_intWantLead & (1 << m_smVisionInfo.g_intVisionPos)) > 0))
                m_bSubTh_StartAfterInspect = true;

            m_smVisionInfo.g_objProcessTime.Stop();

            m_smVisionInfo.VS_AT_UpdateQuantity = true;
            m_smVisionInfo.PR_VM_UpdateQuantity = true;
            if (m_blnWantPackageTest)
            {
                m_smVisionInfo.g_blnDrawPkgResult = true;
                m_smVisionInfo.g_blnPackageInspected = true;
            }

            if (m_smVisionInfo.g_blnViewColorImage)
            {
                m_smVisionInfo.g_arrblnImageRotated[0] = m_blnRotateColorImage1Updated && m_blnCustomWantColor;
                m_smVisionInfo.g_arrblnImageRotated[1] = m_blnRotateColorImage2Updated && m_blnCustomWantColor;
                m_smVisionInfo.g_arrblnImageRotated[2] = m_blnRotateColorImage3Updated && m_blnCustomWantColor;
                m_smVisionInfo.g_arrblnImageRotated[3] = m_blnRotateColorImage4Updated && m_blnCustomWantColor;
                m_smVisionInfo.g_arrblnImageRotated[4] = m_blnRotateColorImage5Updated && m_blnCustomWantColor;
                m_smVisionInfo.g_arrblnImageRotated[5] = m_blnRotateColorImage6Updated && m_blnCustomWantColor;
                m_smVisionInfo.g_arrblnImageRotated[6] = m_blnRotateColorImage7Updated && m_blnCustomWantColor;
            }
            else
            {
                m_smVisionInfo.g_arrblnImageRotated[0] = m_blnRotateImage1Updated;
                m_smVisionInfo.g_arrblnImageRotated[1] = m_blnRotateImage2Updated;
                m_smVisionInfo.g_arrblnImageRotated[2] = m_blnRotateImage3Updated;
                m_smVisionInfo.g_arrblnImageRotated[3] = m_blnRotateImage4Updated;
                m_smVisionInfo.g_arrblnImageRotated[4] = m_blnRotateImage5Updated;
                m_smVisionInfo.g_arrblnImageRotated[5] = m_blnRotateImage6Updated;
                m_smVisionInfo.g_arrblnImageRotated[6] = m_blnRotateImage7Updated;
            }

            // 2020 12 18 - CCENG: No need check also if ByPassUnit is true.
            if ((m_smCustomizeInfo.g_intWantLead & (1 << m_smVisionInfo.g_intVisionPos)) > 0 && m_smVisionInfo.g_arrLead[0].GetWantInspectLead() && !m_smVisionInfo.VM_PR_ByPassUnit)
            {
                m_smVisionInfo.g_arrLead[0].ref_fCenterUnitCompensateAngle_ForDrawing = m_fOrientFinalAngleForLead - m_fLeadPatternAngle;
            }

            m_smVisionInfo.ALL_VM_UpdatePictureBox = true;

            if (m_smVisionInfo.g_blnTrackBasic) STTrackLog.WriteLine("V1-Basic-18");
        }
        private void StartTest_MultiThreading_PreTest(bool blnAuto, int intSampleImageIndex)
        {
            m_smVisionInfo.g_objProcessTime.Start();

            //m_T1.Start();
            //m_strTrack = "";
            //m_fTimingPrev = 0;
            //m_fTiming = 0;
            //m_strResultTrack = "";

            WaitEventDone(ref m_bSubTh_StartAfterInspect, false, 10000, "StartTest_MultiThreading > m_bSubTh_StartAfterInspect A22");

            //m_fTiming = m_T1.Timing;
            //m_strTrack += ", 1=" + (m_fTiming - m_fTimingPrev).ToString();
            //m_fTimingPrev = m_fTiming;

            m_blnAuto = blnAuto;
            bool blnResultOK = true;
            m_fOrientFinalAngleForLead = 0;
            m_blnOrientDataUpdated = false;
            m_blnRotateImage1Updated = false;
            m_blnRotateImage2Updated = false;
            m_blnRotateImage3Updated = false;
            m_blnRotateImage4Updated = false;
            m_blnRotateImage5Updated = false;
            m_blnRotateImage6Updated = false;
            m_blnRotateImage7Updated = false;
            m_blnRotateColorImage1Updated = false;
            m_blnRotateColorImage2Updated = false;
            m_blnRotateColorImage3Updated = false;
            m_blnRotateColorImage4Updated = false;
            m_blnRotateColorImage5Updated = false;
            m_blnRotateColorImage6Updated = false;
            m_blnRotateColorImage7Updated = false;
            m_smVisionInfo.g_blnLeadInspected = false;
            m_smVisionInfo.g_blnMarkInspected = false;
            m_smVisionInfo.g_blnPackageInspected = false;
            m_smVisionInfo.g_blnDrawPin1Result = false;
            m_smVisionInfo.g_blnDrawMarkResult = false;
            m_smVisionInfo.g_blnDrawMark2DCodeResult = false;
            m_smVisionInfo.g_blnDrawPkgResult = false;
            m_smVisionInfo.g_blnViewOrientObject = false;
            m_smVisionInfo.g_blnViewGaugeNotFound = false;
            m_fOrientTotalRotateAngle = 0;
            m_pOrientRotateStartPoint = new Point(0, 0);
            m_pOrientRotateSize = new Size(1, 1);
            m_bLeadBaseCenterPointDone = false;
            m_bLeadBaseCenterPointResult = false;

            m_smVisionInfo.g_pMarkROIDrawing[0] = new Point(0, 0);
            m_smVisionInfo.g_pMarkROIDrawing[1] = new Point(0, 0);
            m_smVisionInfo.g_pMarkROIDrawing[2] = new Point(0, 0);
            m_smVisionInfo.g_pMarkROIDrawing[3] = new Point(0, 0);

            m_smVisionInfo.g_pMarkROIDrawing_Lead[0] = new Point(0, 0);
            m_smVisionInfo.g_pMarkROIDrawing_Lead[1] = new Point(0, 0);
            m_smVisionInfo.g_pMarkROIDrawing_Lead[2] = new Point(0, 0);
            m_smVisionInfo.g_pMarkROIDrawing_Lead[3] = new Point(0, 0);

            m_smVisionInfo.g_pLeadDontCareRotateCenter = new Point(-1, -1);

            m_bPackageSizeTestDone = false;
            m_bPackageSizePreTestDone = false;
            m_bPackageSizePreTestResult = false;
            m_smVisionInfo.g_blnGrabbing = true;
            m_bGrabImageFinalResult = m_bGrabImage1Result = m_bGrabImage2Result = m_bGrabImage3Result = m_bGrabImage4Result = m_bGrabImage5Result = m_bGrabImage6Result = m_bGrabImage7Result = false;
            m_bGrabImage1Done = m_bGrabImage2Done = m_bGrabImage3Done = m_bGrabImage4Done = m_bGrabImage5Done = m_bGrabImage6Done = m_bGrabImage7Done = false;
            m_smVisionInfo.g_blnNoGrabTime = false;

            //if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
            //{
            //    m_blnPackageFail_Out = false;
            //}
            //else
            //{
            //    if (m_objVisionIO.PackageFail != null)
            //        if (m_objVisionIO.PackageFail.IsOn())
            //            m_objVisionIO.PackageFail.SetOff("V4 PackageFail 100");
            //}

            //if (blnAuto)
            //{
            //    //Thread.Sleep(m_smVisionInfo.g_intCameraGrabDelay); //29-05-2019 ZJYEOH : Moved it to After Grabtime Start counting 

            //    if (!m_smProductionInfo.g_blnAllRunWithoutGrabImage)
            //    {
            //        m_bSubTh1_GrabImage = true;  // Trigger Sub Thread 1 to grab images
            //    }
            //    else
            //    {
            //        m_smVisionInfo.g_blnGrabbing = false;
            //        m_bGrabImage1Result = m_bGrabImage2Result = m_bGrabImage3Result = m_bGrabImage4Result = m_bGrabImage5Result = m_bGrabImage6Result = m_bGrabImage7Result = true;
            //        m_bGrabImage1Done = m_bGrabImage2Done = m_bGrabImage3Done = m_bGrabImage4Done = m_bGrabImage5Done = m_bGrabImage6Done = m_bGrabImage7Done = true;
            //        m_smVisionInfo.g_blnNoGrabTime = true;
            //        m_blnGrabbing_Out = false;
            //    }
            //}
            //else if (m_smVisionInfo.MN_PR_GrabImage)
            //{
            //    m_smVisionInfo.MN_PR_GrabImage = false;

            //    m_bSubTh1_GrabImage = true;  // Trigger Sub Thread 1 to grab images
            //}
            //else
            //{
            m_smVisionInfo.g_blnGrabbing = false;
                m_bGrabImage1Result = m_bGrabImage2Result = m_bGrabImage3Result = m_bGrabImage4Result = m_bGrabImage5Result = m_bGrabImage6Result = m_bGrabImage7Result = true;
                m_bGrabImage1Done = m_bGrabImage2Done = m_bGrabImage3Done = m_bGrabImage4Done = m_bGrabImage5Done = m_bGrabImage6Done = m_bGrabImage7Done = true;
                m_smVisionInfo.g_blnNoGrabTime = true;
            //}

            // ----------- Define what test going to do --------------------------------------------

            if ((m_smCustomizeInfo.g_intWantPackage & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
            {
                if (!m_blnWantPackageTest)
                    m_blnWantPackageTest = true;
            }
            else
            {
                if (m_blnWantPackageTest)
                    m_blnWantPackageTest = false;
            }

            if ((m_smCustomizeInfo.g_intWantOrient & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
            {
                if (!m_blnWantOrientTest)
                    m_blnWantOrientTest = true;
            }
            else
            {
                if (m_blnWantOrientTest)
                    m_blnWantOrientTest = false;
            }

            if ((m_smCustomizeInfo.g_intWantMark & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
            {
                if (!m_blnWantMarkTest)
                    m_blnWantMarkTest = true;
            }
            else
            {
                if (m_blnWantMarkTest)
                    m_blnWantMarkTest = false;
            }

            if ((m_smCustomizeInfo.g_intWantLead & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
            {
                if (!m_blnWantLeadTest)
                    m_blnWantLeadTest = true;
            }
            else
            {
                if (m_blnWantLeadTest)
                    m_blnWantLeadTest = false;
            }

            // ------------------ Reset Inspection data ----------------------------------------------
            if (m_blnWantPackageTest)
            {
                //if (!m_smVisionInfo.g_blnViewColorImage)
                {
                    if (m_smVisionInfo.g_arrPackage != null && m_smVisionInfo.g_arrPackage.Count > 0)
                        m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ResetPackageInspectionData();
                }
            }

            if (m_smVisionInfo.g_blnWantPin1)
            {
                for (int i = 0; i < m_smVisionInfo.g_arrPin1.Count; i++)
                {
                    m_smVisionInfo.g_arrPin1[i].ResetInspectionData();
                }
            }

            if (m_blnWantLeadTest)
            {
                for (int i = 0; i < m_smVisionInfo.g_arrLead.Length; i++)
                {
                    if (i == 0)
                        m_smVisionInfo.g_arrLead[i].ResetInspectionData();

                    if (!m_smVisionInfo.g_arrLead[i].ref_blnSelected)
                        continue;

                    m_smVisionInfo.g_arrLead[i].ref_blnLock = true;

                    // Reset previous inspection data
                    m_smVisionInfo.g_arrLead[i].ResetInspectionData();
                }
            }

            // ----------------- Trigger Sub Thread test now -----------------------------------------
#if (DEBUG || Debug_2_12 || RTXDebug)
            m_bSubTh_PackageTest_PackageSize_Result = false;
            m_bSubTh_PackageTest_MarkLightView_Result = false;
            m_bSubTh_PackageTest_SideLightView_Result = false;
            m_bSubTh_PackageTest_TopLightView_Result = false;

            if (m_blnWantMarkTest || m_blnWantOrientTest)
            {
                m_bSubTh_MarkTest = true;
            }
            else
            {
                m_bSubTh_MarkTest_Result = true;
            }

            if (m_blnWantPackageTest)
            {
                m_bSubTh_PackageTest_MarkLightView = true;
                if (m_blnTestHandMade_Mark)
                {
                    m_bSubTh_PackageTest_SideLightView_Result = true;
                    m_bSubTh_PackageTest_TopLightView_Result = true;
                }
                else
                {
                    m_bSubTh_PackageTest_SideLightView = true;
                    m_bSubTh_PackageTest_TopLightView = true;
                }
            }
            else
            {
                m_bSubTh_PackageTest_MarkLightView_Result = true;
                m_bSubTh_PackageTest_SideLightView_Result = true;
                m_bSubTh_PackageTest_TopLightView_Result = true;
            }

            if (m_blnWantLeadTest)
            {
                m_bSubTh_LeadTest = true;
            }
            else
            {
                m_bSubTh_LeadTest_Result = true;
            }

            if (m_blnCustomWantColor)
            {
                m_bSubTh_PackageColorTest = true;
            }
            else
            {
                m_bSubTh_PackageColorTest_Result = true;
            }

#else
            m_bSubTh_PackageTest_PackageSize_Result = false;
            m_bSubTh_PackageTest_MarkLightView_Result = false;
            m_bSubTh_PackageTest_SideLightView_Result = false;
            m_bSubTh_PackageTest_TopLightView_Result = false;


            if (m_blnWantMarkTest || m_blnWantOrientTest)
            {
                m_bSubTh_MarkTest = true;
            }
            else
            {
                m_bSubTh_MarkTest_Result = true;
            }

            if (m_blnWantPackageTest)
            {
                m_bSubTh_PackageTest_MarkLightView = true;
                if (m_blnTestHandMade_Mark)
                {
                    m_bSubTh_PackageTest_SideLightView_Result = true;
                    m_bSubTh_PackageTest_TopLightView_Result = true;
                }
                else
                {
                    m_bSubTh_PackageTest_SideLightView = true;
                    m_bSubTh_PackageTest_TopLightView = true;
                }
            }
            else
            {
                m_bSubTh_PackageTest_MarkLightView_Result = true;
                m_bSubTh_PackageTest_SideLightView_Result = true;
                m_bSubTh_PackageTest_TopLightView_Result = true;
            }

            if (m_blnWantLeadTest)
            {
                m_bSubTh_LeadTest = true;
            }
            else
            {
                m_bSubTh_LeadTest_Result = true;
            }
            
            if (m_blnCustomWantColor)
            {
                m_bSubTh_PackageColorTest = true;
            }
            else
            {
                m_bSubTh_PackageColorTest_Result = true;
            }

#endif
            // ------------------ Wait Sub Thread Test done --------------------------------------------------
            bool blnInspectionDone = false;
            HiPerfTimer timeout = new HiPerfTimer();
            timeout.Start();
            while (true)
            {
                if (!m_bSubTh_MarkTest &&
                    !m_bSubTh_PackageTest_MarkLightView &&
                    !m_bSubTh_PackageTest_SideLightView &&
                    !m_bSubTh_PackageTest_TopLightView &&
                    !m_bSubTh_LeadTest &&
                    !m_bSubTh_PackageColorTest)
                {
                    blnInspectionDone = true;
                    break;
                }

#if (RELEASE || RTXRelease || Release_2_12)

                if (timeout.Timing > 10000) // 2020 02 18 - CCENG: Change to 10ms to prevent inspection time out due to debug run too fast.
                {
                    string strFileName = DateTime.Now.ToString("yyyy-MM-dd_HH-mm");
                    for (int m = 0; m < m_smVisionInfo.g_arrImages.Count; m++)
                    {
                        m_smVisionInfo.g_arrImages[m].SaveImage("D:\\ErrorImage\\V1_image_" + strFileName + "_" + m.ToString() + ".bmp");
                    }
                    STTrackLog.WriteLine(">>>>>>>>>>>>> Vision 1 - time out 7.");
                    STTrackLog.WriteLine(">>>>>>>>>>>>> Vision 1 - m_bSubTh_MarkTest=" + m_bSubTh_MarkTest.ToString());
                    STTrackLog.WriteLine(">>>>>>>>>>>>> Vision 1 - m_bSubTh_PackageTest_MarkLightView=" + m_bSubTh_PackageTest_MarkLightView.ToString());
                    STTrackLog.WriteLine(">>>>>>>>>>>>> Vision 1 - m_bSubTh_PackageTest_SideLightView=" + m_bSubTh_PackageTest_SideLightView.ToString());
                    STTrackLog.WriteLine(">>>>>>>>>>>>> Vision 1 - m_bSubTh_PackageTest_TopLightView=" + m_bSubTh_PackageTest_TopLightView.ToString());
                    STTrackLog.WriteLine(">>>>>>>>>>>>> Vision 1 - m_bSubTh_LeadTest=" + m_bSubTh_LeadTest.ToString());
                    STTrackLog.WriteLine(">>>>>>>>>>>>> Vision 1 - m_bSubTh_PackageColorTest=" + m_bSubTh_PackageColorTest.ToString());

                    break;
                }

#endif
                Thread.Sleep(1);
            }

            // ---------------------- Action after Sub Thread Test Done -----------------------------------------------------------
            if (m_smVisionInfo.g_blnUnitInspected.Length > 0)
                m_smVisionInfo.g_blnUnitInspected[0] = true;

            // ------------------ Set IO to handler (set before save image for faster UPH) ----------------------------------------
            // Define Final result is pass or fail.
            if (blnInspectionDone &&
                m_bSubTh_MarkTest_Result &&
                m_bSubTh_PackageTest_MarkLightView_Result &&
                m_bSubTh_PackageTest_SideLightView_Result &&
                m_bSubTh_PackageTest_TopLightView_Result &&
                m_bSubTh_LeadTest_Result &&
                m_bSubTh_PackageColorTest_Result)
            {
                //if (blnAuto)
                //{
                //    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                //    {
                //        WaitEventDone(ref m_blnGrabbing_Out, false, 10000, "m_blnGrabbing_Out");//2021-03-24 ZJYEOH : Wait grab done send to handler first
                //        m_blnPass1_Out = true;

                //        //2021-03-24 ZJYEOH : Wait at least 5ms before send result
                //        float fDelay = 5 - Math.Max(0, m_smVisionInfo.g_objTotalTime.Timing - m_smVisionInfo.g_objGrabTime.Duration);
                //        if (fDelay >= 1)
                //            Thread.Sleep((int)fDelay);

                //        if (m_blnCheckOffset_In)
                //            m_smTCPIPIO.Send_ResultForCheckOffset(m_smVisionInfo.g_intVisionIndex, true, m_blnOrientResult1_Out, m_blnOrientResult2_Out, m_fOffsetX, m_fOffsetY, m_fOffsetAngle);
                //        else
                //            m_smTCPIPIO.Send_Result(m_smVisionInfo.g_intVisionIndex, true, m_blnOrientResult1_Out, m_blnOrientResult2_Out, m_intTCPIPResultID);
                //    }
                //    else
                //    {
                //        WaitEventDone(ref m_blnGrabbing_Out, false, 10000, "m_blnGrabbing_Out");
                //        float fGrabDelay = 5 - m_smVisionInfo.g_objGrabDoneTime.Timing;
                //        if (fGrabDelay >= 1)
                //            Thread.Sleep((int)fGrabDelay);

                //        m_objVisionIO.IOPass1.SetOn(strTrackHeadName + " IOPass1 19");
                //        m_smVisionInfo.g_objGrabDoneTime.Stop();
                //    }
                //}

                blnResultOK = true;
            }
            else
            {

                blnResultOK = false;

                ////want no mark feature
                //if (m_smVisionInfo.g_blnWantCheckNoMark)
                //{
                //    if ((m_smVisionInfo.g_arrMarks[0].ref_intFailResultMask & 0x1000) > 0)
                //    {
                //        if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                //        {
                //            m_blnMarkFail_Out = true;
                //            if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                //                if (m_intTCPIPResultID == -1)
                //                    m_intTCPIPResultID = (int)TCPIPResulID.FailMark;//FailNoMark;
                //        }
                //        else
                //        {
                //            m_objVisionIO.FailNoMark.SetOn(strTrackHeadName + " FailNoMark 20");
                //        }
                //    }
                //}

                //if (blnAuto && m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                //{
                //    WaitEventDone(ref m_blnGrabbing_Out, false, 10000, "m_blnGrabbing_Out");//2021-03-24 ZJYEOH : Wait grab done send to handler first

                //    //2021-03-24 ZJYEOH : Wait at least 5ms before send result
                //    float fDelay = 5 - Math.Max(0, m_smVisionInfo.g_objTotalTime.Timing - m_smVisionInfo.g_objGrabTime.Duration);
                //    if (fDelay >= 1)
                //        Thread.Sleep((int)fDelay);

                //    if (m_blnCheckOffset_In)
                //        m_smTCPIPIO.Send_ResultForCheckOffset(m_smVisionInfo.g_intVisionIndex, false, m_blnOrientResult1_Out, m_blnOrientResult2_Out, m_fOffsetX, m_fOffsetY, m_fOffsetAngle);
                //    else
                //        m_smTCPIPIO.Send_Result(m_smVisionInfo.g_intVisionIndex, false, m_blnOrientResult1_Out, m_blnOrientResult2_Out, m_intTCPIPResultID);
                //}
            }

            //m_objVisionIO.FailNoMark.SetOn(strTrackHeadName + " FailNoMark 20");
            // 2019 04 10 CCENG: Move this Single Orient Test to Sub tread already.
            // 2019 04 04 ZJYEOH: Test Orient Only 
            //if ((m_smCustomizeInfo.g_intWantOrient & (1 << m_smVisionInfo.g_intVisionPos)) > 0 && (m_smCustomizeInfo.g_intWantMark & (1 << m_smVisionInfo.g_intVisionPos)) == 0)
            //{
            //    if (!StartOrientTest(blnAuto))
            //        blnResultOK = false;
            //}

            //if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
            //{
            //    m_blnEndVision_Out = true;
            //}
            //else
            //{
            //    m_objVisionIO.IOEndVision.SetOn(strTrackHeadName + " IOEndVision 21");
            //}

            // Wait all images grab done to make sure latest images are saved.
            WaitAllImageGrabDone();
            m_smVisionInfo.g_blnGrabbing = false;

            if (blnResultOK)
            {
                //m_smVisionInfo.g_strResult = "Pass";

                //if (blnAuto)
                //{
                //    m_smVisionInfo.g_intPassTotal++;
                //    m_smVisionInfo.g_intContinuousPassUnitCount++;
                //    SavePassImage_AddToBuffer();
                //}
                //else
                //{
                //    m_smVisionInfo.g_cErrorMessageColor = Color.Black;
                //    m_smVisionInfo.g_strErrorMessage = "Offline Test Pass!";
                //}
                if (intSampleImageIndex >= 0)
                {
                    m_smVisionInfo.g_arrPreTestErrorMessage[intSampleImageIndex] = m_smVisionInfo.g_strErrorMessage;
                    m_smVisionInfo.g_arrPreTestErrorMessageColor[intSampleImageIndex] = Color.Black;
                }
            }
            else
            {
                //m_smVisionInfo.g_strResult = "Fail";

                //if (blnAuto)
                //{
                //    m_smVisionInfo.g_intContinuousFailUnitCount++;
                //}
                //else
                //{
                //    m_smVisionInfo.g_strErrorMessage = "Offline Test Fail! " + "*" + m_smVisionInfo.g_strErrorMessage;
                //}
                if (intSampleImageIndex >= 0)
                {
                    m_smVisionInfo.g_arrPreTestErrorMessage[intSampleImageIndex] = m_smVisionInfo.g_strErrorMessage;
                    m_smVisionInfo.g_arrPreTestErrorMessageColor[intSampleImageIndex] = Color.Red;
                }
            }

            if (intSampleImageIndex >= 0)
                m_smVisionInfo.g_arrPreTestResult[intSampleImageIndex] = blnResultOK;
            //if (blnAuto)
            //{
            //    m_smVisionInfo.g_intTestedTotal++;
            //    m_smVisionInfo.g_intLowYieldUnitCount++;
            //    CheckLowYield();
            //    CheckContinuousPass();
            //    CheckContinuousFail();
            //}

            // 2019 05 30 - JBTAN: Temporary solution for multi view test rotated images no update and show black image
            //// 2019 01 28 - CCENG: Not need purposely rotate image for user view.
            if (!m_blnRotateImage1Updated)
            {
                if (m_smVisionInfo.g_arrImages.Count > 0)
                    m_smVisionInfo.g_arrImages[0].CopyTo(ref m_smVisionInfo.g_arrRotatedImages, 0);
            }

            if (!m_blnRotateImage2Updated)
            {
                if (m_smVisionInfo.g_arrImages.Count > 1)
                    m_smVisionInfo.g_arrImages[1].CopyTo(ref m_smVisionInfo.g_arrRotatedImages, 1);
            }

            if (!m_blnRotateImage3Updated)
            {
                if (m_smVisionInfo.g_arrImages.Count > 2)
                    m_smVisionInfo.g_arrImages[2].CopyTo(ref m_smVisionInfo.g_arrRotatedImages, 2);
            }

            if (!m_blnRotateImage4Updated)
            {
                if (m_smVisionInfo.g_arrImages.Count > 3)
                    m_smVisionInfo.g_arrImages[3].CopyTo(ref m_smVisionInfo.g_arrRotatedImages, 3);
            }

            if (!m_blnRotateImage5Updated)
            {
                if (m_smVisionInfo.g_arrImages.Count > 4)
                    m_smVisionInfo.g_arrImages[4].CopyTo(ref m_smVisionInfo.g_arrRotatedImages, 4);
            }

            if (!m_blnRotateImage6Updated)
            {
                if (m_smVisionInfo.g_arrImages.Count > 5)
                    m_smVisionInfo.g_arrImages[5].CopyTo(ref m_smVisionInfo.g_arrRotatedImages, 5);
            }

            if (!m_blnRotateImage7Updated)
            {
                if (m_smVisionInfo.g_arrImages.Count > 6)
                    m_smVisionInfo.g_arrImages[6].CopyTo(ref m_smVisionInfo.g_arrRotatedImages, 6);
            }

            if (((m_smCustomizeInfo.g_intWantPackage & (1 << m_smVisionInfo.g_intVisionPos)) > 0) || ((m_smCustomizeInfo.g_intWantLead & (1 << m_smVisionInfo.g_intVisionPos)) > 0))
                m_bSubTh_StartAfterInspect = true;

            m_smVisionInfo.g_objProcessTime.Stop();

            //m_smVisionInfo.VS_AT_UpdateQuantity = true;
            //m_smVisionInfo.PR_VM_UpdateQuantity = true;
            //if (m_blnWantPackageTest)
            //{
            //    m_smVisionInfo.g_blnDrawPkgResult = true;
            //    m_smVisionInfo.g_blnPackageInspected = true;
            //}

            //m_smVisionInfo.g_arrblnImageRotated[0] = m_blnRotateImage1Updated || (m_blnRotateColorImage1Updated && m_blnCustomWantColor);
            //m_smVisionInfo.g_arrblnImageRotated[1] = m_blnRotateImage2Updated || (m_blnRotateColorImage2Updated && m_blnCustomWantColor);
            //m_smVisionInfo.g_arrblnImageRotated[2] = m_blnRotateImage3Updated || (m_blnRotateColorImage3Updated && m_blnCustomWantColor);
            //m_smVisionInfo.g_arrblnImageRotated[3] = m_blnRotateImage4Updated || (m_blnRotateColorImage4Updated && m_blnCustomWantColor);
            //m_smVisionInfo.g_arrblnImageRotated[4] = m_blnRotateImage5Updated || (m_blnRotateColorImage5Updated && m_blnCustomWantColor);
            //m_smVisionInfo.g_arrblnImageRotated[5] = m_blnRotateImage6Updated || (m_blnRotateColorImage6Updated && m_blnCustomWantColor);
            //m_smVisionInfo.g_arrblnImageRotated[6] = m_blnRotateImage7Updated || (m_blnRotateColorImage7Updated && m_blnCustomWantColor);

            // 2020 12 18 - CCENG: No need check also if ByPassUnit is true.
            if ((m_smCustomizeInfo.g_intWantLead & (1 << m_smVisionInfo.g_intVisionPos)) > 0 && m_smVisionInfo.g_arrLead[0].GetWantInspectLead() && !m_smVisionInfo.VM_PR_ByPassUnit)
            {
                m_smVisionInfo.g_arrLead[0].ref_fCenterUnitCompensateAngle_ForDrawing = m_fOrientFinalAngleForLead - m_fLeadPatternAngle;
            }

            //m_smVisionInfo.ALL_VM_UpdatePictureBox = true;
        }
        private string GetLeadDefinition(int intLeadIndex)
        {
            switch (intLeadIndex)
            {
                case 1:
                    return "*Top ROI: ";
                case 2:
                    return "*Right ROI: ";
                case 3:
                    return "*Bottom ROI: ";
                case 4:
                    return "*Left ROI: ";
                default:
                    SRMMessageBox.Show("GetLeadDefinition()->Lead Index " + intLeadIndex.ToString() + " no exist.");
                    return "";
            }
        }

        //find unit by pattern matching
        private bool FindUnit(int intLeadIndex, int intAngleTolerance, bool blnRecordPatternAngle)
        {
            {
                if (m_smVisionInfo.g_arrLeadROIs[0].Count > 0)
                {
                    m_smVisionInfo.g_arrLeadROIs[0][0].AttachImage(m_smVisionInfo.g_objLeadImage);
                }

                //HiPerfTimer timer = new HiPerfTimer();
                //timer.Start();

                if (!m_smVisionInfo.g_arrLead[intLeadIndex].FindUnitUsingPRS(m_smVisionInfo.g_arrLeadROIs[0][0], intAngleTolerance, false, intLeadIndex, m_smVisionInfo.g_arrLeadROIs[intLeadIndex][0])) // Side Lead angle is a bit only
                {
                    m_smVisionInfo.g_strErrorMessage += "*Lead : Fail to find unit." + m_smVisionInfo.g_arrLead[intLeadIndex].ref_strErrorMessage;

                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        if (m_intTCPIPResultID == -1)
                            m_intTCPIPResultID = (int)TCPIPResulID.Fail;

                    return false;
                }
                if (m_smVisionInfo.g_arrLead[intLeadIndex].ref_fUnitScore >= m_fLeadPatternScore)
                {
                    m_fLeadPatternScore = m_smVisionInfo.g_arrLead[intLeadIndex].ref_fUnitScore;
                    if (blnRecordPatternAngle)
                        m_fLeadPatternAngle = m_smVisionInfo.g_arrLead[intLeadIndex].ref_fUnitAngle;
                }
                //timer.Stop();
                //STTrackLog.WriteLine("Pattern Match Duration = " + timer.Duration.ToString());
                //timer.Start();

                //if (!m_smVisionInfo.g_arrLead[intLeadIndex].FindUnitUsingFinder(m_smVisionInfo.g_arrLeadROIs[intLeadIndex][0], 2, false)) // Side Lead angle is a bit only
                //{
                //    m_smVisionInfo.g_strErrorMessage += "*Fail to find unit." + m_smVisionInfo.g_arrLead[intLeadIndex].ref_strErrorMessage;
                //    return false;
                //}

                //timer.Stop();
                //STTrackLog.WriteLine("Pattern Finder Duration = " + timer.Duration.ToString());

                return true;
            }
        }
        private bool FindFixPocket(int intLeadIndex)
        {
            if (m_smVisionInfo.g_arrLeadPocketDontCareROIsFix.Count < intLeadIndex)
            {
                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        m_intTCPIPResultID = (int)TCPIPResulID.Fail;

                m_smVisionInfo.g_strErrorMessage += "*Lead : Please Learn Dont Care ROI first.";
                return false;
            }

            if (m_smVisionInfo.g_arrLeadPocketDontCareROIsFix[intLeadIndex].Count == 0)
            {
                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        m_intTCPIPResultID = (int)TCPIPResulID.Fail;

                m_smVisionInfo.g_strErrorMessage += "*Lead : Please Learn Dont Care ROI first.";
                return false;
            }

            //ROI objDontCareROI = new ROI();
            m_smVisionInfo.g_arrLeadPocketDontCareROIsFix[intLeadIndex][0].AttachImage(m_smVisionInfo.g_objLeadImage);
            m_smVisionInfo.g_arrLeadPocketDontCareROIsFix[intLeadIndex][0].LoadROISetting(m_smVisionInfo.g_arrLeadPocketDontCareROIsFix[intLeadIndex][0].ref_ROIPositionX, m_smVisionInfo.g_arrLeadPocketDontCareROIsFix[intLeadIndex][0].ref_ROIPositionY,
                                                                                          m_smVisionInfo.g_arrLeadPocketDontCareROIsFix[intLeadIndex][0].ref_ROIWidth, m_smVisionInfo.g_arrLeadPocketDontCareROIsFix[intLeadIndex][0].ref_ROIHeight);
            //m_smVisionInfo.g_objLeadImage.SaveImage("D:\\Img1.bmp");
            ROI.SubtractROI(m_smVisionInfo.g_arrLeadPocketDontCareROIsFix[intLeadIndex][0], m_smVisionInfo.g_arrLeadPocketDontCareROIsFix[intLeadIndex][0]);
            //m_smVisionInfo.g_objLeadImage.SaveImage("D:\\Img2.bmp");
            //objDontCareROI.Dispose();
            return true;

        }
        private bool FindPocketShadowBlob(int intLeadIndex, ref List<float> arrInwardDontCareROILimit)
        {
            if (m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob.Count < intLeadIndex)
            {
                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        m_intTCPIPResultID = (int)TCPIPResulID.Fail;

                m_smVisionInfo.g_strErrorMessage += "*Lead : Please Learn Dont Care ROI first.";
                return false;
            }

            if (m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[intLeadIndex].Count == 0)
            {
                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        m_intTCPIPResultID = (int)TCPIPResulID.Fail;

                m_smVisionInfo.g_strErrorMessage += "*Lead : Please Learn Dont Care ROI first.";
                return false;
            }

            if (m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[0].Count > 0)
            {
                m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[0][0].AttachImage(m_smVisionInfo.g_objLeadImage);
            }

            for (int i = 0; i < m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob.Count; i++)
            {
                for (int j = 0; j < m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[i].Count; j++)
                {
                    m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[i][j].AttachImage(m_smVisionInfo.g_objLeadImage);
                    //m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[i][j].SaveImage("D:\\TS\\LeadPocketDontCareROI_" + i.ToString() + "_" + j.ToString() + ".bmp");
                }
            }

            ROI objROI = new ROI();
            objROI.AttachImage(m_smVisionInfo.g_objLeadImage);
            switch (intLeadIndex)
            {
                case 1:
                    objROI.LoadROISetting(m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[intLeadIndex][0].ref_ROITotalX,
                            m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[intLeadIndex][0].ref_ROITotalY,
                            m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[intLeadIndex][0].ref_ROIWidth,
                            m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[intLeadIndex][0].ref_ROIHeight + m_smVisionInfo.g_arrLead[intLeadIndex].ref_intDontCareBlobROIInward);
                    break;
                case 2:
                    objROI.LoadROISetting(m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[intLeadIndex][0].ref_ROITotalX - m_smVisionInfo.g_arrLead[intLeadIndex].ref_intDontCareBlobROIInward,
                            m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[intLeadIndex][0].ref_ROITotalY,
                            m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[intLeadIndex][0].ref_ROIWidth + m_smVisionInfo.g_arrLead[intLeadIndex].ref_intDontCareBlobROIInward,
                            m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[intLeadIndex][0].ref_ROIHeight);
                    break;
                case 3:
                    objROI.LoadROISetting(m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[intLeadIndex][0].ref_ROITotalX,
                                    m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[intLeadIndex][0].ref_ROITotalY - m_smVisionInfo.g_arrLead[intLeadIndex].ref_intDontCareBlobROIInward,
                                    m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[intLeadIndex][0].ref_ROIWidth,
                                    m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[intLeadIndex][0].ref_ROIHeight + m_smVisionInfo.g_arrLead[intLeadIndex].ref_intDontCareBlobROIInward);
                    break;
                case 4:
                    objROI.LoadROISetting(m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[intLeadIndex][0].ref_ROITotalX,
                            m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[intLeadIndex][0].ref_ROITotalY,
                            m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[intLeadIndex][0].ref_ROIWidth + m_smVisionInfo.g_arrLead[intLeadIndex].ref_intDontCareBlobROIInward,
                            m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[intLeadIndex][0].ref_ROIHeight);
                    break;
            }

            //objROI.SaveImage("D:\\TS\\objROI.bmp");

            //STTrackLog.WriteLine("C: " + m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[intLeadIndex][0].ref_ROIPositionX.ToString() + ", " +
            //                             m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[intLeadIndex][0].ref_ROIPositionY.ToString() + ", " +
            //                             m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[intLeadIndex][0].ref_ROIWidth.ToString() + ", " +
            //                             m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[intLeadIndex][0].ref_ROIHeight.ToString());

            //STTrackLog.WriteLine("D: " + objROI.ref_ROIPositionX.ToString() + ", " +
            //                             objROI.ref_ROIPositionY.ToString() + ", " +
            //                             objROI.ref_ROIWidth.ToString() + ", " +
            //                             objROI.ref_ROIHeight.ToString());

            arrInwardDontCareROILimit[intLeadIndex] = m_smVisionInfo.g_arrLead[intLeadIndex].BuildDontCareArea(objROI, false);

            if (arrInwardDontCareROILimit[intLeadIndex] != -1f)
            {
                ROI objDontCareROI = new ROI();
                objDontCareROI.AttachImage(m_smVisionInfo.g_objLeadImage);
                switch (intLeadIndex)
                {
                    case 1:
                        objDontCareROI.LoadROISetting(objROI.ref_ROITotalX,
                                objROI.ref_ROITotalY,
                                objROI.ref_ROIWidth,
                                (int)arrInwardDontCareROILimit[intLeadIndex]);
                        break;
                    case 2:
                        objDontCareROI.LoadROISetting(objROI.ref_ROITotalX + (int)arrInwardDontCareROILimit[intLeadIndex],
                                objROI.ref_ROITotalY,
                                objROI.ref_ROIWidth,
                                objROI.ref_ROIHeight);
                        break;
                    case 3:
                        objDontCareROI.LoadROISetting(objROI.ref_ROITotalX,
                                        objROI.ref_ROITotalY + (int)arrInwardDontCareROILimit[intLeadIndex],
                                        objROI.ref_ROIWidth,
                                        objROI.ref_ROIHeight);
                        break;
                    case 4:
                        objDontCareROI.LoadROISetting(objROI.ref_ROITotalX,
                                objROI.ref_ROITotalY,
                                (int)arrInwardDontCareROILimit[intLeadIndex],
                                objROI.ref_ROIHeight);
                        break;
                }


                //m_smVisionInfo.g_objLeadImage.SaveImage("D:\\TS\\Img1.bmp");
                ROI.SubtractROI(objDontCareROI, objDontCareROI);
                //m_smVisionInfo.g_objLeadImage.SaveImage("D:\\TS\\Img2_" + intLeadIndex.ToString() + ".bmp");
                objDontCareROI.Dispose();
            }
            //objDontCareROI.Dispose();
            objROI.Dispose();
            return true;

        }
        private void FlipToOpposite_DontCareBlob(List<float> arrInwardDontCareROILimit)
        {
            if (((m_smVisionInfo.g_intLeadPocketDontCareROIBlobMask & 0x01) > 0) && ((m_smVisionInfo.g_intLeadPocketDontCareROIBlobMask & 0x04) > 0) &&
                ((arrInwardDontCareROILimit[1] == -1 && arrInwardDontCareROILimit[3] == -1) || (arrInwardDontCareROILimit[1] != -1 && arrInwardDontCareROILimit[3] != -1)))
                return;
            else if (((m_smVisionInfo.g_intLeadPocketDontCareROIBlobMask & 0x02) > 0) && ((m_smVisionInfo.g_intLeadPocketDontCareROIBlobMask & 0x08) > 0) &&
                ((arrInwardDontCareROILimit[2] == -1 && arrInwardDontCareROILimit[4] == -1) || (arrInwardDontCareROILimit[2] != -1 && arrInwardDontCareROILimit[4] != -1)))
                return;

            int intOffset = 0;

            if (((m_smVisionInfo.g_intLeadPocketDontCareROIBlobMask & 0x01) > 0) && ((m_smVisionInfo.g_intLeadPocketDontCareROIBlobMask & 0x04) > 0) && m_smVisionInfo.g_intLeadPocketDontCareROIBlobDistanceY > 0)
            {
                if (arrInwardDontCareROILimit[1] == -1)
                {
                    intOffset = (int)arrInwardDontCareROILimit[3] - m_smVisionInfo.g_arrLead[3].ref_intDontCareBlobROIInward;
                    ROI objDontCareROI = new ROI();
                    objDontCareROI.AttachImage(m_smVisionInfo.g_objLeadImage);
                    objDontCareROI.LoadROISetting(m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[1][0].ref_ROITotalX,
                            m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[3][0].ref_ROITotalY - m_smVisionInfo.g_arrLead[3].ref_intDontCareBlobROIInward + (int)arrInwardDontCareROILimit[3] - m_smVisionInfo.g_intLeadPocketDontCareROIBlobDistanceY - intOffset - m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[1][0].ref_ROIHeight,
                            m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[1][0].ref_ROIWidth,
                            m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[1][0].ref_ROIHeight);

                    //m_smVisionInfo.g_objLeadImage.SaveImage("D:\\TS\\ImgTop_1.bmp");
                    ROI.SubtractROI(objDontCareROI, objDontCareROI);
                    //m_smVisionInfo.g_objLeadImage.SaveImage("D:\\TS\\ImgTop_2.bmp");
                    objDontCareROI.Dispose();
                }
                else if (arrInwardDontCareROILimit[3] == -1)
                {
                    intOffset = m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[1][0].ref_ROIHeight - (int)arrInwardDontCareROILimit[1];
                    ROI objDontCareROI = new ROI();
                    objDontCareROI.AttachImage(m_smVisionInfo.g_objLeadImage);
                    objDontCareROI.LoadROISetting(m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[3][0].ref_ROITotalX,
                                m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[1][0].ref_ROITotalY + (int)arrInwardDontCareROILimit[1] + m_smVisionInfo.g_intLeadPocketDontCareROIBlobDistanceY + intOffset,
                                m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[3][0].ref_ROIWidth,
                                m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[3][0].ref_ROIHeight);

                    //m_smVisionInfo.g_objLeadImage.SaveImage("D:\\TS\\ImgBottom_1.bmp");
                    ROI.SubtractROI(objDontCareROI, objDontCareROI);
                    //m_smVisionInfo.g_objLeadImage.SaveImage("D:\\TS\\ImgBottom_2.bmp");
                    objDontCareROI.Dispose();
                }
            }
            else if (((m_smVisionInfo.g_intLeadPocketDontCareROIBlobMask & 0x02) > 0) && ((m_smVisionInfo.g_intLeadPocketDontCareROIBlobMask & 0x08) > 0) && m_smVisionInfo.g_intLeadPocketDontCareROIBlobDistanceX > 0)
            {
                if (arrInwardDontCareROILimit[2] == -1)
                {
                    intOffset = m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[4][0].ref_ROIWidth - (int)arrInwardDontCareROILimit[4];
                    ROI objDontCareROI = new ROI();
                    objDontCareROI.AttachImage(m_smVisionInfo.g_objLeadImage);
                    objDontCareROI.LoadROISetting(m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[4][0].ref_ROITotalX + (int)arrInwardDontCareROILimit[4] + m_smVisionInfo.g_intLeadPocketDontCareROIBlobDistanceX + intOffset,
                            m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[2][0].ref_ROITotalY,
                            m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[2][0].ref_ROIWidth,
                            m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[2][0].ref_ROIHeight);

                    //m_smVisionInfo.g_objLeadImage.SaveImage("D:\\TS\\ImgRight_1.bmp");
                    ROI.SubtractROI(objDontCareROI, objDontCareROI);
                    //m_smVisionInfo.g_objLeadImage.SaveImage("D:\\TS\\ImgRight_2.bmp");
                    objDontCareROI.Dispose();
                }
                else if (arrInwardDontCareROILimit[4] == -1)
                {
                    intOffset = (int)arrInwardDontCareROILimit[2] - m_smVisionInfo.g_arrLead[2].ref_intDontCareBlobROIInward;
                    ROI objDontCareROI = new ROI();
                    objDontCareROI.AttachImage(m_smVisionInfo.g_objLeadImage);
                    objDontCareROI.LoadROISetting(m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[2][0].ref_ROITotalX - m_smVisionInfo.g_arrLead[2].ref_intDontCareBlobROIInward + (int)arrInwardDontCareROILimit[2] - m_smVisionInfo.g_intLeadPocketDontCareROIBlobDistanceX - intOffset - m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[4][0].ref_ROIWidth,
                        m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[4][0].ref_ROITotalY,
                        m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[4][0].ref_ROIWidth,
                        m_smVisionInfo.g_arrLeadPocketDontCareROIsBlob[4][0].ref_ROIHeight);

                    //m_smVisionInfo.g_objLeadImage.SaveImage("D:\\TS\\ImgLeft_1.bmp");
                    ROI.SubtractROI(objDontCareROI, objDontCareROI);
                    //m_smVisionInfo.g_objLeadImage.SaveImage("D:\\TS\\ImgLeft_2.bmp");
                    objDontCareROI.Dispose();
                }
            }

        }
        private bool FindManualPocketReference(int intLeadIndex)
        {
            if (m_smVisionInfo.g_arrLeadPocketDontCareROIsManual[0].Count > 0)
            {
                m_smVisionInfo.g_arrLeadPocketDontCareROIsManual[0][0].AttachImage(m_smVisionInfo.g_objLeadImage);
            }

            if (m_smVisionInfo.g_arrLeadPocketDontCareROIsManual.Count < intLeadIndex)
            {
                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        m_intTCPIPResultID = (int)TCPIPResulID.Fail;

                m_smVisionInfo.g_strErrorMessage += "*Lead : Please Learn Dont Care ROI first.";
                return false;
            }

            if (m_smVisionInfo.g_arrLeadPocketDontCareROIsManual[intLeadIndex].Count == 0)
            {
                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        m_intTCPIPResultID = (int)TCPIPResulID.Fail;

                m_smVisionInfo.g_strErrorMessage += "*Lead : Please Learn Dont Care ROI first.";
                return false;
            }

            PointF pPatternCenter = new PointF(0, 0);
            if (!m_smVisionInfo.g_arrLead[intLeadIndex].FindManualPocketReferencePattern(m_smVisionInfo.g_arrLeadPocketDontCareROIsManual[0][0], ref pPatternCenter))
            {
                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        m_intTCPIPResultID = (int)TCPIPResulID.Fail;

                m_smVisionInfo.g_strErrorMessage += "*Lead : Fail to find Reference." + m_smVisionInfo.g_arrLead[intLeadIndex].ref_strErrorMessage;
                return false;
            }

            //ROI objDontCareROI = new ROI();
            m_smVisionInfo.g_arrLeadPocketDontCareROIsManual[intLeadIndex][0].AttachImage(m_smVisionInfo.g_objLeadImage);
            m_smVisionInfo.g_arrLeadPocketDontCareROIsManual[intLeadIndex][0].LoadROISetting((int)Math.Round((pPatternCenter.X - m_smVisionInfo.g_arrLead[intLeadIndex].ref_fManualPocketReferenceOffsetX) - (m_smVisionInfo.g_arrLeadPocketDontCareROIsManual[intLeadIndex][0].ref_ROIWidth / 2)),
                (int)Math.Round((pPatternCenter.Y - m_smVisionInfo.g_arrLead[intLeadIndex].ref_fManualPocketReferenceOffsetY) - (m_smVisionInfo.g_arrLeadPocketDontCareROIsManual[intLeadIndex][0].ref_ROIHeight / 2)),
                m_smVisionInfo.g_arrLeadPocketDontCareROIsManual[intLeadIndex][0].ref_ROIWidth, m_smVisionInfo.g_arrLeadPocketDontCareROIsManual[intLeadIndex][0].ref_ROIHeight);
            //m_smVisionInfo.g_objLeadImage.SaveImage("D:\\Img1.bmp");
            ROI.SubtractROI(m_smVisionInfo.g_arrLeadPocketDontCareROIsManual[intLeadIndex][0], m_smVisionInfo.g_arrLeadPocketDontCareROIsManual[intLeadIndex][0]);
            //m_smVisionInfo.g_objLeadImage.SaveImage("D:\\Img2.bmp");
            //objDontCareROI.Dispose();
            return true;

        }
        private bool FindAutoPocketReference(int intLeadIndex, ImageDrawing objImg)
        {
            if (m_smVisionInfo.g_arrLeadPocketDontCareROIsAuto[0].Count > 0)
            {
                m_smVisionInfo.g_arrLeadPocketDontCareROIsAuto[0][0].AttachImage(m_smVisionInfo.g_objLeadImage);
            }

            if (m_smVisionInfo.g_arrLeadPocketDontCareROIsAuto.Count < intLeadIndex)
            {
                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        m_intTCPIPResultID = (int)TCPIPResulID.Fail;

                m_smVisionInfo.g_strErrorMessage += "*Lead : Please Learn Dont Care ROI first.";
                return false;
            }

            if (m_smVisionInfo.g_arrLeadPocketDontCareROIsAuto[intLeadIndex].Count == 0)
            {
                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        m_intTCPIPResultID = (int)TCPIPResulID.Fail;

                m_smVisionInfo.g_strErrorMessage += "*Lead : Please Learn Dont Care ROI first.";
                return false;
            }

            PointF pPatternCenter = new PointF(0, 0);
            if (!m_smVisionInfo.g_arrLead[intLeadIndex].FindAutoPocketReferencePattern(m_smVisionInfo.g_arrLeadPocketDontCareROIsAuto[0][0], ref pPatternCenter))
            {
                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        m_intTCPIPResultID = (int)TCPIPResulID.Fail;

                m_smVisionInfo.g_strErrorMessage += "*Lead : Fail to find Reference." + m_smVisionInfo.g_arrLead[intLeadIndex].ref_strErrorMessage;
                return false;
            }

            //ROI objGaugeROI = new ROI();

            m_smVisionInfo.g_arrLeadPocketDontCareROIsAuto[intLeadIndex][0].AttachImage(objImg);
            m_smVisionInfo.g_arrLeadPocketDontCareROIsAuto[intLeadIndex][0].LoadROISetting((int)Math.Round((pPatternCenter.X - m_smVisionInfo.g_arrLead[intLeadIndex].ref_fAutoPocketReferenceOffsetX) - (m_smVisionInfo.g_arrLeadPocketDontCareROIsAuto[intLeadIndex][0].ref_ROIWidth / 2)),
                (int)Math.Round((pPatternCenter.Y - m_smVisionInfo.g_arrLead[intLeadIndex].ref_fAutoPocketReferenceOffsetY) - (m_smVisionInfo.g_arrLeadPocketDontCareROIsAuto[intLeadIndex][0].ref_ROIHeight / 2)),
                m_smVisionInfo.g_arrLeadPocketDontCareROIsAuto[intLeadIndex][0].ref_ROIWidth, m_smVisionInfo.g_arrLeadPocketDontCareROIsAuto[intLeadIndex][0].ref_ROIHeight);

            m_smVisionInfo.g_arrLead[intLeadIndex].ref_objPocketEdgeGauge.SetPGaugePlace(
                m_smVisionInfo.g_arrLeadPocketDontCareROIsAuto[intLeadIndex][0].ref_ROIPositionX,
                m_smVisionInfo.g_arrLeadPocketDontCareROIsAuto[intLeadIndex][0].ref_ROIPositionY,
                m_smVisionInfo.g_arrLeadPocketDontCareROIsAuto[intLeadIndex][0].ref_ROIWidth,
                m_smVisionInfo.g_arrLeadPocketDontCareROIsAuto[intLeadIndex][0].ref_ROIHeight);

            int m_intWidthLimit = m_smVisionInfo.g_arrLeadPocketDontCareROIsAuto[intLeadIndex][0].ref_ROIWidth;
            int m_intHeightLimit = m_smVisionInfo.g_arrLeadPocketDontCareROIsAuto[intLeadIndex][0].ref_ROIHeight;
            int m_intStartX = m_smVisionInfo.g_arrLeadPocketDontCareROIsAuto[intLeadIndex][0].ref_ROIPositionX;
            int m_intStartY = m_smVisionInfo.g_arrLeadPocketDontCareROIsAuto[intLeadIndex][0].ref_ROIPositionY;

            m_smVisionInfo.g_arrLeadPocketDontCareROIsAuto[intLeadIndex][0].GainTo_ROIToROISamePosition(ref objImg, m_smVisionInfo.g_arrLead[intLeadIndex].ref_objPocketEdgeGauge.ref_fGaugeImageGain);
            m_smVisionInfo.g_arrLeadPocketDontCareROIsAuto[intLeadIndex][0].ThresholdTo_ROIToROISamePosition(ref objImg, m_smVisionInfo.g_arrLead[intLeadIndex].ref_objPocketEdgeGauge.ref_intGaugeImageThreshold);

            if (m_smVisionInfo.g_blnViewPackageImage)
                m_smVisionInfo.g_arrLead[intLeadIndex].ref_objPocketEdgeGauge.MeasurePGauge(m_smVisionInfo.g_arrLeadPocketDontCareROIsAuto[intLeadIndex][0], m_smVisionInfo.g_objPackageImage);
            else
                m_smVisionInfo.g_arrLead[intLeadIndex].ref_objPocketEdgeGauge.MeasurePGauge(m_smVisionInfo.g_arrLeadPocketDontCareROIsAuto[intLeadIndex][0], m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo]);

            ROI objDontCareROI = new ROI();
            objDontCareROI.AttachImage(m_smVisionInfo.g_objLeadImage);

            if (intLeadIndex == 1)
            {
                float intStartY = m_smVisionInfo.g_arrLead[intLeadIndex].ref_objPocketEdgeGauge.ref_objLine.GetPointY(m_intStartX);
                float intEndY = m_smVisionInfo.g_arrLead[intLeadIndex].ref_objPocketEdgeGauge.ref_objLine.GetPointY(m_intStartX + m_intWidthLimit);
                if (!float.IsNaN(intStartY) && !float.IsInfinity(intStartY) && !float.IsNaN(intEndY) && !float.IsInfinity(intEndY))
                {

                    objDontCareROI.LoadROISetting(m_intStartX, (int)Math.Round(intStartY + m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLineOffset), m_intWidthLimit, m_smVisionInfo.g_arrLead[intLeadIndex].ref_intMaskThickness);

                }
            }
            else if (intLeadIndex == 2)
            {
                float intStartX = m_smVisionInfo.g_arrLead[intLeadIndex].ref_objPocketEdgeGauge.ref_objLine.GetPointX(m_intStartY);
                float intEndX = m_smVisionInfo.g_arrLead[intLeadIndex].ref_objPocketEdgeGauge.ref_objLine.GetPointX(m_intStartY + m_intHeightLimit);
                if (!float.IsNaN(intStartX) && !float.IsInfinity(intStartX) && !float.IsNaN(intEndX) && !float.IsInfinity(intEndX))
                {

                    objDontCareROI.LoadROISetting((int)Math.Round(intStartX - m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLineOffset - m_smVisionInfo.g_arrLead[intLeadIndex].ref_intMaskThickness), m_intStartY, m_smVisionInfo.g_arrLead[intLeadIndex].ref_intMaskThickness, m_intHeightLimit);

                }
            }
            else if (intLeadIndex == 3)
            {
                float intStartY = m_smVisionInfo.g_arrLead[intLeadIndex].ref_objPocketEdgeGauge.ref_objLine.GetPointY(m_intStartX);
                float intEndY = m_smVisionInfo.g_arrLead[intLeadIndex].ref_objPocketEdgeGauge.ref_objLine.GetPointY(m_intStartX + m_intWidthLimit);
                if (!float.IsNaN(intStartY) && !float.IsInfinity(intStartY) && !float.IsNaN(intEndY) && !float.IsInfinity(intEndY))
                {

                    objDontCareROI.LoadROISetting(m_intStartX, (int)Math.Round(intStartY - m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLineOffset - m_smVisionInfo.g_arrLead[intLeadIndex].ref_intMaskThickness), m_intWidthLimit, m_smVisionInfo.g_arrLead[intLeadIndex].ref_intMaskThickness);

                }
            }
            else if (intLeadIndex == 4)
            {
                float intStartX = m_smVisionInfo.g_arrLead[intLeadIndex].ref_objPocketEdgeGauge.ref_objLine.GetPointX(m_intStartY);
                float intEndX = m_smVisionInfo.g_arrLead[intLeadIndex].ref_objPocketEdgeGauge.ref_objLine.GetPointX(m_intStartY + m_intHeightLimit);
                if (!float.IsNaN(intStartX) && !float.IsInfinity(intStartX) && !float.IsNaN(intEndX) && !float.IsInfinity(intEndX))
                {

                    objDontCareROI.LoadROISetting((int)Math.Round(intStartX + m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLineOffset), m_intStartY, m_smVisionInfo.g_arrLead[intLeadIndex].ref_intMaskThickness, m_intHeightLimit);

                }
            }

            //m_smVisionInfo.g_objLeadImage.SaveImage("D:\\Img1.bmp");
            ROI.SubtractROI(objDontCareROI, objDontCareROI);
            //m_smVisionInfo.g_objLeadImage.SaveImage("D:\\Img2.bmp");
            m_smVisionInfo.g_arrLeadPocketDontCareROIsAuto[intLeadIndex][0].AttachImage(m_smVisionInfo.g_objLeadImage);
            objDontCareROI.Dispose();
            //objGaugeROI.Dispose();
            return true;

        }
        private bool IsLeadOK(int intLeadIndex, ref int intFailType)
        {
            if (!m_smVisionInfo.g_arrLead[0].GetWantInspectLead())//(!m_smVisionInfo.g_blnCheckLead)
                return true;

            if (m_objLeadImage == null)
                m_objLeadImage = new ImageDrawing(true);

            //Copy rotated image to a temp image

            m_smVisionInfo.g_objLeadImage.CopyTo(ref m_objLeadImage);

            // Define Sample Unit ROI attach to sample image          
            m_smVisionInfo.g_arrInspectLeadROI[intLeadIndex].AttachImage(m_objLeadImage);

            // Same size as Unit ROI 
            if (m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Top == 0 &&
                    m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Right == 0 &&
                    m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Bottom == 0 &&
                    m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Left == 0)
            {
                m_smVisionInfo.g_arrInspectLeadROI[intLeadIndex].LoadROISetting(
                   (int)Math.Round(m_smVisionInfo.g_arrLead[intLeadIndex].GetResultCenterPoint_UnitMatcher().X -
                   ((float)m_smVisionInfo.g_arrLeadROIs[intLeadIndex][0].ref_ROIWidth / 2) + m_smVisionInfo.g_arrLead[intLeadIndex].ref_fPatternROIOffsetX, 0, MidpointRounding.AwayFromZero),
                   (int)Math.Round(m_smVisionInfo.g_arrLead[intLeadIndex].GetResultCenterPoint_UnitMatcher().Y -
                   ((float)m_smVisionInfo.g_arrLeadROIs[intLeadIndex][0].ref_ROIHeight / 2) + m_smVisionInfo.g_arrLead[intLeadIndex].ref_fPatternROIOffsetY, 0, MidpointRounding.AwayFromZero),
                   m_smVisionInfo.g_arrLeadROIs[intLeadIndex][0].ref_ROIWidth,
                   m_smVisionInfo.g_arrLeadROIs[intLeadIndex][0].ref_ROIHeight);
            }
            else
            {
                m_smVisionInfo.g_arrInspectLeadROI[intLeadIndex].LoadROISetting(
             (int)Math.Round(m_smVisionInfo.g_arrLead[intLeadIndex].GetResultCenterPoint_UnitMatcher().X -
             ((float)m_smVisionInfo.g_arrLead[intLeadIndex].GetPatternSize_UnitMatcher().Width / 2) - m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Left, 0, MidpointRounding.AwayFromZero),
             (int)Math.Round(m_smVisionInfo.g_arrLead[intLeadIndex].GetResultCenterPoint_UnitMatcher().Y -
             ((float)m_smVisionInfo.g_arrLead[intLeadIndex].GetPatternSize_UnitMatcher().Height / 2) - m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Top, 0, MidpointRounding.AwayFromZero),
             m_smVisionInfo.g_arrLead[intLeadIndex].GetPatternSize_UnitMatcher().Width + m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Left + m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Right,
             m_smVisionInfo.g_arrLead[intLeadIndex].GetPatternSize_UnitMatcher().Height + m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Top + m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Bottom);
            }

            if (m_smVisionInfo.g_arrLead[0].ref_blnWantInspectBaseLead)
            {
                if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == m_smVisionInfo.g_arrLead[0].ref_intImageViewNo)
                    m_smVisionInfo.g_arrInspectLeadROI_BaseLead[intLeadIndex].AttachImage(m_objLeadImage);
                else
                    m_smVisionInfo.g_arrInspectLeadROI_BaseLead[intLeadIndex].AttachImage(m_smVisionInfo.g_arrRotatedImages[m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo]);

                if (m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Top == 0 &&
                m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Right == 0 &&
                m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Bottom == 0 &&
                m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Left == 0)
                {
                    m_smVisionInfo.g_arrInspectLeadROI_BaseLead[intLeadIndex].LoadROISetting(
                      (int)Math.Round(m_smVisionInfo.g_arrLead[intLeadIndex].GetResultCenterPoint_UnitMatcher().X -
                      ((float)m_smVisionInfo.g_arrLeadROIs[intLeadIndex][0].ref_ROIWidth / 2) + m_smVisionInfo.g_arrLead[intLeadIndex].ref_fPatternROIOffsetX, 0, MidpointRounding.AwayFromZero),
                      (int)Math.Round(m_smVisionInfo.g_arrLead[intLeadIndex].GetResultCenterPoint_UnitMatcher().Y -
                      ((float)m_smVisionInfo.g_arrLeadROIs[intLeadIndex][0].ref_ROIHeight / 2) + m_smVisionInfo.g_arrLead[intLeadIndex].ref_fPatternROIOffsetY, 0, MidpointRounding.AwayFromZero),
                      m_smVisionInfo.g_arrLeadROIs[intLeadIndex][0].ref_ROIWidth,
                      m_smVisionInfo.g_arrLeadROIs[intLeadIndex][0].ref_ROIHeight);
                }
                else
                {
                    m_smVisionInfo.g_arrInspectLeadROI_BaseLead[intLeadIndex].LoadROISetting(
                    (int)Math.Round(m_smVisionInfo.g_arrLead[intLeadIndex].GetResultCenterPoint_UnitMatcher().X -
                    (m_smVisionInfo.g_arrLead[intLeadIndex].GetPatternSize_UnitMatcher().Width / 2) - m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Left, 0, MidpointRounding.AwayFromZero),
                    (int)Math.Round(m_smVisionInfo.g_arrLead[intLeadIndex].GetResultCenterPoint_UnitMatcher().Y -
                    ((float)m_smVisionInfo.g_arrLead[intLeadIndex].GetPatternSize_UnitMatcher().Height / 2) - m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Top, 0, MidpointRounding.AwayFromZero),
                    m_smVisionInfo.g_arrLead[intLeadIndex].GetPatternSize_UnitMatcher().Width + m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Left + m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Right,
                    m_smVisionInfo.g_arrLead[intLeadIndex].GetPatternSize_UnitMatcher().Height + m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Top + m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Bottom);
                }
            }
            bool blnWantDebug = false;
            if (blnWantDebug)
            {
                m_smVisionInfo.g_arrInspectLeadROI[intLeadIndex].SaveImage("D:\\TS\\InspectLeadROI.bmp");
            }
            int j = 0;
            List<List<PointF>> arrDontCare = new List<List<PointF>>();


            //Draw don't care ROI edge to make sure Don't Care Area is not inspected
            for (int k = 1; k < m_smVisionInfo.g_arrLeadROIs[intLeadIndex].Count; k++)
            {
                PointF ptTemp;
                List<PointF> arrTemp = new List<PointF>();

                ptTemp = new PointF();
                ptTemp.X = m_smVisionInfo.g_arrLeadROIs[intLeadIndex][k].ref_ROIPositionX;
                ptTemp.Y = m_smVisionInfo.g_arrLeadROIs[intLeadIndex][k].ref_ROIPositionY;

                arrTemp.Add(ptTemp);

                ptTemp = new PointF();
                ptTemp.X = m_smVisionInfo.g_arrLeadROIs[intLeadIndex][k].ref_ROIPositionX + m_smVisionInfo.g_arrLeadROIs[intLeadIndex][k].ref_ROIWidth;
                ptTemp.Y = m_smVisionInfo.g_arrLeadROIs[intLeadIndex][k].ref_ROIPositionY + m_smVisionInfo.g_arrLeadROIs[intLeadIndex][k].ref_ROIHeight;

                arrTemp.Add(ptTemp);

                arrDontCare.Add(new List<PointF>());
                arrDontCare[j].Add(arrTemp[0]);
                arrDontCare[j].Add(arrTemp[1]);

                j++;

                m_smVisionInfo.g_arrLeadROIs[intLeadIndex][k].AttachImage(m_smVisionInfo.g_arrInspectLeadROI[intLeadIndex]);    // Attach to Sample Unit ROI or Package ROI
                m_smVisionInfo.g_arrLeadROIs[intLeadIndex][k].DrawDontCareEdge(0);
            }

            bool blnResult = true;

            if (!m_smVisionInfo.g_arrLead[intLeadIndex].InspectLead(
                m_smVisionInfo.g_arrInspectLeadROI[intLeadIndex],
                m_smVisionInfo.g_arrLeadROIs[intLeadIndex],
                arrDontCare))
            {
                intFailType |= 0x01;
                blnResult = false;
            }

            if (blnResult)
            {
                if (m_smVisionInfo.g_arrLead[0].ref_blnWantInspectBaseLead && (((m_smVisionInfo.g_arrLead[0].ref_intFailOptionMask & 0x10000) > 0) || ((m_smVisionInfo.g_arrLead[0].ref_intFailOptionMask & 0x20000) > 0)))
                {
                    //// Wait base lead image (default is image 3) grap done
                    //if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 0)
                    //    blnResult = WaitEventDone(ref m_bGrabImage1Done, true, ref m_bGrabImage1Result, "AAA58 1");
                    //else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 1)
                    //    blnResult = WaitEventDone(ref m_bGrabImage2Done, true, ref m_bGrabImage2Result, "AAA58 2");
                    //else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 2)
                    //    blnResult = WaitEventDone(ref m_bGrabImage3Done, true, ref m_bGrabImage3Result, "AAA58 3");
                    //else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 3)
                    //    blnResult = WaitEventDone(ref m_bGrabImage4Done, true, ref m_bGrabImage4Result, "AAA58 4");
                    //else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 4)
                    //    blnResult = WaitEventDone(ref m_bGrabImage5Done, true, ref m_bGrabImage5Result, "AAA58 5");
                    //else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 5)
                    //    blnResult = WaitEventDone(ref m_bGrabImage6Done, true, ref m_bGrabImage6Result, "AAA58 6");
                    //else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 6)
                    //    blnResult = WaitEventDone(ref m_bGrabImage7Done, true, ref m_bGrabImage7Result, "AAA58 7");

                    if (((m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo != m_smVisionInfo.g_arrLead[0].ref_intImageViewNo) &&
                       (m_blnWantPackageTest && m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetWantInspectPackage() &&
                        (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetGrabImageIndex(2) ||
                        m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetGrabImageIndex(3)))))
                    {
                        // Wait mark inspection done.
                        WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "IsLeadOK Base Lead > m_bSubTh_MarkTest");
                        if (!m_bSubTh_MarkTest_Result)
                        {
                            return blnResult;   // Skip if mark test fail.
                        }
                        // Wait package test done under mark light view 
                        WaitEventDone(ref m_bSubTh_PackageTest_MarkLightView, false, 10000, "IsLeadOK Base Lead > m_bSubTh_PackageTest_MarkLightView");
                        if (!m_bSubTh_PackageTest_MarkLightView_Result)
                        {
                            return blnResult;
                        }

                        if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetGrabImageIndex(2))
                        {
                            // Wait SideLightView Package done
                            WaitEventDone(ref m_bSubTh_PackageTest_SideLightView, false, 10000, "IsLeadOK Base Lead > m_bSubTh_PackageTest_SideLightView");
                            if (!m_bSubTh_PackageTest_SideLightView_Result)
                            {
                                return blnResult;
                            }

                            if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 0)
                                WaitEventDone(ref m_blnRotateImage1Updated, true, 10000, "IsLeadOK Base Lead > m_blnRotateImage1Updated");
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 1)
                                WaitEventDone(ref m_blnRotateImage2Updated, true, 10000, "IsLeadOK Base Lead > m_blnRotateImage2Updated");
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 2)
                                WaitEventDone(ref m_blnRotateImage3Updated, true, 10000, "IsLeadOK Base Lead > m_blnRotateImage3Updated");
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 3)
                                WaitEventDone(ref m_blnRotateImage4Updated, true, 10000, "IsLeadOK Base Lead > m_blnRotateImage4Updated");
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 4)
                                WaitEventDone(ref m_blnRotateImage5Updated, true, 10000, "IsLeadOK Base Lead > m_blnRotateImage5Updated");
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 5)
                                WaitEventDone(ref m_blnRotateImage6Updated, true, 10000, "IsLeadOK Base Lead > m_blnRotateImage6Updated");
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 6)
                                WaitEventDone(ref m_blnRotateImage7Updated, true, 10000, "IsLeadOK Base Lead > m_blnRotateImage7Updated");
                        }
                        else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetGrabImageIndex(3))
                        {
                            // Wait TopLightView Package done
                            WaitEventDone(ref m_bSubTh_PackageTest_TopLightView, false, 10000, "IsLeadOK Base Lead > m_bSubTh_PackageTest_TopLightView");
                            if (!m_bSubTh_PackageTest_TopLightView_Result)
                            {
                                return blnResult;
                            }

                            if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 0)
                                WaitEventDone(ref m_blnRotateImage1Updated, true, 10000, "IsLeadOK Base Lead > m_blnRotateImage1Updated");
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 1)
                                WaitEventDone(ref m_blnRotateImage2Updated, true, 10000, "IsLeadOK Base Lead > m_blnRotateImage2Updated");
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 2)
                                WaitEventDone(ref m_blnRotateImage3Updated, true, 10000, "IsLeadOK Base Lead > m_blnRotateImage3Updated");
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 3)
                                WaitEventDone(ref m_blnRotateImage4Updated, true, 10000, "IsLeadOK Base Lead > m_blnRotateImage4Updated");
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 4)
                                WaitEventDone(ref m_blnRotateImage5Updated, true, 10000, "IsLeadOK Base Lead > m_blnRotateImage5Updated");
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 5)
                                WaitEventDone(ref m_blnRotateImage6Updated, true, 10000, "IsLeadOK Base Lead > m_blnRotateImage6Updated");
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 6)
                                WaitEventDone(ref m_blnRotateImage7Updated, true, 10000, "IsLeadOK Base Lead > m_blnRotateImage7Updated");
                        }


                        m_smVisionInfo.g_arrInspectLeadROI_BaseLead[intLeadIndex].AttachImage(m_smVisionInfo.g_arrRotatedImages[m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo]);
                    }

                    if (blnResult)
                    {
                        if (!m_smVisionInfo.g_arrLead[intLeadIndex].InspectBaseLead(
                                       m_smVisionInfo.g_arrInspectLeadROI_BaseLead[intLeadIndex],
                                       m_smVisionInfo.g_arrLeadROIs[intLeadIndex],
                                       arrDontCare))
                        {
                            intFailType |= 0x02;

                            blnResult = false;
                        }
                    }
                }
            }

            return blnResult;
        }
        private bool IsLeadOK_ForBaseLineRotation(int intLeadIndex)
        {
            if (!m_smVisionInfo.g_arrLead[0].GetWantInspectLead())//(!m_smVisionInfo.g_blnCheckLead)
                return true;

            if (m_objLeadImage == null)
                m_objLeadImage = new ImageDrawing(true);

            //Copy rotated image to a temp image

            m_smVisionInfo.g_objLeadImage.CopyTo(ref m_objLeadImage);


            // Define Sample Unit ROI attach to sample image          
            m_smVisionInfo.g_arrInspectLeadROI[intLeadIndex].AttachImage(m_objLeadImage);

            // Same size as Unit ROI 
            if (m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Top == 0 &&
              m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Right == 0 &&
              m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Bottom == 0 &&
              m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Left == 0)
            {
                m_smVisionInfo.g_arrInspectLeadROI[intLeadIndex].LoadROISetting(
                   (int)Math.Round(m_smVisionInfo.g_arrLead[intLeadIndex].GetResultCenterPoint_UnitMatcher().X -
                   ((float)m_smVisionInfo.g_arrLeadROIs[intLeadIndex][0].ref_ROIWidth / 2), 0, MidpointRounding.AwayFromZero),
                   (int)Math.Round(m_smVisionInfo.g_arrLead[intLeadIndex].GetResultCenterPoint_UnitMatcher().Y -
                   ((float)m_smVisionInfo.g_arrLeadROIs[intLeadIndex][0].ref_ROIHeight / 2), 0, MidpointRounding.AwayFromZero),
                   m_smVisionInfo.g_arrLeadROIs[intLeadIndex][0].ref_ROIWidth,
                   m_smVisionInfo.g_arrLeadROIs[intLeadIndex][0].ref_ROIHeight);
            }
            else
            {
                m_smVisionInfo.g_arrInspectLeadROI[intLeadIndex].LoadROISetting(
              (int)Math.Round(m_smVisionInfo.g_arrLead[intLeadIndex].GetResultCenterPoint_UnitMatcher().X -
              ((float)m_smVisionInfo.g_arrLead[intLeadIndex].GetPatternSize_UnitMatcher().Width / 2) - m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Left, 0, MidpointRounding.AwayFromZero),
              (int)Math.Round(m_smVisionInfo.g_arrLead[intLeadIndex].GetResultCenterPoint_UnitMatcher().Y -
              ((float)m_smVisionInfo.g_arrLead[intLeadIndex].GetPatternSize_UnitMatcher().Height / 2) - m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Top, 0, MidpointRounding.AwayFromZero),
              m_smVisionInfo.g_arrLead[intLeadIndex].GetPatternSize_UnitMatcher().Width + m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Left + m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Right,
              m_smVisionInfo.g_arrLead[intLeadIndex].GetPatternSize_UnitMatcher().Height + m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Top + m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Bottom);
            }

            //m_smVisionInfo.g_arrInspectLeadROI[intLeadIndex].SaveImage("D:\\TS\\InspectLeadROI.bmp");
            //m_smVisionInfo.g_arrInspectLeadPkgROI[intLeadIndex][0].SaveImage("D:\\TS\\InspectLeadPkgROI.bmp");

            // 2021-08-20 ZJYEOH : dont care 4 sides of ROI to avoid built noise surrounding Lead because image is not rotated
            {
                if (m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Top == 0 &&
                    m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Right == 0 &&
                    m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Bottom == 0 &&
                    m_smVisionInfo.g_arrLead[intLeadIndex].ref_intLeadROITolerance_Left == 0)
                {
                    float fWidth = m_smVisionInfo.g_arrLead[intLeadIndex].GetPatternSize_UnitMatcher().Width;
                    float fHeight = m_smVisionInfo.g_arrLead[intLeadIndex].GetPatternSize_UnitMatcher().Height;

                    float CenterX = 0;
                    float CenterY = 0;

                    CenterX = m_smVisionInfo.g_arrLead[intLeadIndex].GetResultCenterPoint_UnitMatcher().X;

                    CenterY = m_smVisionInfo.g_arrLead[intLeadIndex].GetResultCenterPoint_UnitMatcher().Y;

                    List<Point> arrPoints = new List<Point>();
                    arrPoints.Add(new Point((int)(CenterX - (fWidth / 2)), (int)(CenterY - (fHeight / 2))));
                    arrPoints.Add(new Point((int)(CenterX + (fWidth / 2)), (int)(CenterY - (fHeight / 2))));
                    arrPoints.Add(new Point((int)(CenterX + (fWidth / 2)), (int)(CenterY + (fHeight / 2))));
                    arrPoints.Add(new Point((int)(CenterX - (fWidth / 2)), (int)(CenterY + (fHeight / 2))));

                    DontCareWithoutRotateImage.ProduceImage_ForLead(arrPoints, m_objLeadImage, m_smVisionInfo.g_objWhiteImage, m_smVisionInfo.g_objBlackImage, m_fLeadPatternAngle, true, m_smVisionInfo.g_arrInspectLeadROI[intLeadIndex]);
                }
                else
                {
                    float fWidth = m_smVisionInfo.g_arrInspectLeadROI[intLeadIndex].ref_ROIWidth;
                    float fHeight = m_smVisionInfo.g_arrInspectLeadROI[intLeadIndex].ref_ROIHeight;

                    float CenterX = 0;
                    float CenterY = 0;

                    CenterX = m_smVisionInfo.g_arrInspectLeadROI[intLeadIndex].ref_ROICenterX;

                    CenterY = m_smVisionInfo.g_arrInspectLeadROI[intLeadIndex].ref_ROICenterY;

                    List<Point> arrPoints = new List<Point>();
                    arrPoints.Add(new Point((int)(CenterX - (fWidth / 2)), (int)(CenterY - (fHeight / 2))));
                    arrPoints.Add(new Point((int)(CenterX + (fWidth / 2)), (int)(CenterY - (fHeight / 2))));
                    arrPoints.Add(new Point((int)(CenterX + (fWidth / 2)), (int)(CenterY + (fHeight / 2))));
                    arrPoints.Add(new Point((int)(CenterX - (fWidth / 2)), (int)(CenterY + (fHeight / 2))));

                    DontCareWithoutRotateImage.ProduceImage_ForLead(arrPoints, m_objLeadImage, m_smVisionInfo.g_objWhiteImage, m_smVisionInfo.g_objBlackImage, m_fLeadPatternAngle, true, m_smVisionInfo.g_arrInspectLeadROI[intLeadIndex]);
                }
                //m_smVisionInfo.g_arrInspectLeadROI[intLeadIndex].SaveImage("D:\\TS\\InspectLeadROI" + intLeadIndex + ".bmp");
            }

            int j = 0;
            List<List<PointF>> arrDontCare = new List<List<PointF>>();


            //Draw don't care ROI edge to make sure Don't Care Area is not inspected
            for (int k = 1; k < m_smVisionInfo.g_arrLeadROIs[intLeadIndex].Count; k++)
            {
                PointF ptTemp;
                List<PointF> arrTemp = new List<PointF>();

                ptTemp = new PointF();
                ptTemp.X = m_smVisionInfo.g_arrLeadROIs[intLeadIndex][k].ref_ROIPositionX;
                ptTemp.Y = m_smVisionInfo.g_arrLeadROIs[intLeadIndex][k].ref_ROIPositionY;

                arrTemp.Add(ptTemp);

                ptTemp = new PointF();
                ptTemp.X = m_smVisionInfo.g_arrLeadROIs[intLeadIndex][k].ref_ROIPositionX + m_smVisionInfo.g_arrLeadROIs[intLeadIndex][k].ref_ROIWidth;
                ptTemp.Y = m_smVisionInfo.g_arrLeadROIs[intLeadIndex][k].ref_ROIPositionY + m_smVisionInfo.g_arrLeadROIs[intLeadIndex][k].ref_ROIHeight;

                arrTemp.Add(ptTemp);

                arrDontCare.Add(new List<PointF>());
                arrDontCare[j].Add(arrTemp[0]);
                arrDontCare[j].Add(arrTemp[1]);

                j++;

                m_smVisionInfo.g_arrLeadROIs[intLeadIndex][k].AttachImage(m_smVisionInfo.g_arrInspectLeadROI[intLeadIndex]);    // Attach to Sample Unit ROI or Package ROI
                m_smVisionInfo.g_arrLeadROIs[intLeadIndex][k].DrawDontCareEdge(0);
            }

            if (!m_smVisionInfo.g_arrLead[intLeadIndex].InspectLead_ForBaseLineRotation(
                m_smVisionInfo.g_arrInspectLeadROI[intLeadIndex],
                m_smVisionInfo.g_arrLeadROIs[intLeadIndex],
                arrDontCare))
            {
                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        m_intTCPIPResultID = (int)TCPIPResulID.Fail;

                return false;
            }

            return true;
        }
        private bool IsUnitLengthVarianceOk()
        {
            float fLengthMinMM = -999;
            float fLengthMaxMM = -999;
            for (int i = 1; i < 5; i++)
            {
                if (m_smVisionInfo.g_arrLead[i].ref_blnSelected)
                {
                    if (m_smVisionInfo.g_arrLead[i].ref_fSampleLengthMinMM != -999)
                    {
                        if (fLengthMinMM == -999 || fLengthMinMM > m_smVisionInfo.g_arrLead[i].ref_fSampleLengthMinMM)
                            fLengthMinMM = m_smVisionInfo.g_arrLead[i].ref_fSampleLengthMinMM;
                    }

                    if (m_smVisionInfo.g_arrLead[i].ref_fSampleLengthMaxMM != -999)
                    {
                        if (fLengthMaxMM == -999 || fLengthMaxMM < m_smVisionInfo.g_arrLead[i].ref_fSampleLengthMaxMM)
                            fLengthMaxMM = m_smVisionInfo.g_arrLead[i].ref_fSampleLengthMaxMM;
                    }
                }
            }

            if (fLengthMinMM != -999 && fLengthMaxMM != -999)
            {
                m_smVisionInfo.g_arrLead[0].ref_fSampleLengthMinMM = fLengthMinMM;
                m_smVisionInfo.g_arrLead[0].ref_fSampleLengthMaxMM = fLengthMaxMM;
                m_smVisionInfo.g_arrLead[0].ref_fSampleLengthVarianceMM = fLengthMaxMM - fLengthMinMM;
            }

            if (m_smVisionInfo.g_arrLead[0].ref_fSampleLengthVarianceMM > m_smVisionInfo.g_arrLead[0].ref_fTemplateLengthVarianceMaxLimit)
            {
                //fail unit length variance
                m_smVisionInfo.g_arrLead[0].ref_intFailResultMask |= 0x800; // 0x800 mean fail variance. Lead index 0 mean comparison of all leads length.
                return false;
            }

            return true;
        }
        private bool IsUnitSpanOk()
        {
            if (m_smVisionInfo.g_arrLead[1].ref_blnSelected && m_smVisionInfo.g_arrLead[3].ref_blnSelected)
            {
                float fsampleUnitSpan = (m_smVisionInfo.g_arrLead[3].ref_fLeadUnitSpanTipCenterXY - m_smVisionInfo.g_arrLead[1].ref_fLeadUnitSpanTipCenterXY) / m_smVisionInfo.g_fCalibPixelX;

                m_smVisionInfo.g_arrLead[0].ref_fLeadSpanResultMM = fsampleUnitSpan;

                if (fsampleUnitSpan < m_smVisionInfo.g_arrLead[0].ref_fTemplateLeadMinSpanLimit || fsampleUnitSpan > m_smVisionInfo.g_arrLead[0].ref_fTemplateLeadMaxSpanLimit)
                {
                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        if (m_intTCPIPResultID == -1)
                            m_intTCPIPResultID = (int)TCPIPResulID.Fail;

                    //fail span
                    m_smVisionInfo.g_arrLead[0].ref_intFailResultMask |= 0x1000;
                    m_smVisionInfo.g_arrLead[1].ref_intFailResultMask |= 0x1000;
                    m_smVisionInfo.g_arrLead[3].ref_intFailResultMask |= 0x1000;
                    return false;
                }
            }
            else if (m_smVisionInfo.g_arrLead[2].ref_blnSelected && m_smVisionInfo.g_arrLead[4].ref_blnSelected)
            {
                float fsampleUnitSpan = (m_smVisionInfo.g_arrLead[2].ref_fLeadUnitSpanTipCenterXY - m_smVisionInfo.g_arrLead[4].ref_fLeadUnitSpanTipCenterXY) / m_smVisionInfo.g_fCalibPixelX;

                m_smVisionInfo.g_arrLead[0].ref_fLeadSpanResultMM = fsampleUnitSpan;

                if (fsampleUnitSpan < m_smVisionInfo.g_arrLead[0].ref_fTemplateLeadMinSpanLimit || fsampleUnitSpan > m_smVisionInfo.g_arrLead[0].ref_fTemplateLeadMaxSpanLimit)
                {
                    if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        if (m_intTCPIPResultID == -1)
                            m_intTCPIPResultID = (int)TCPIPResulID.Fail;

                    //fail span
                    m_smVisionInfo.g_arrLead[0].ref_intFailResultMask |= 0x1000;
                    m_smVisionInfo.g_arrLead[2].ref_intFailResultMask |= 0x1000;
                    m_smVisionInfo.g_arrLead[4].ref_intFailResultMask |= 0x1000;
                    return false;
                }
            }

            return true;
        }
        //private bool IsUnitSpanOk()
        //{
        //    if (m_smVisionInfo.g_arrLead[1].ref_blnSelected && m_smVisionInfo.g_arrLead[3].ref_blnSelected)
        //    {
        //        float fSampleLeadMinSpanStart = 0;
        //        float fSampleLeadMaxSpanStart = 0;
        //        float fSampleLeadMinSpanEnd = 0;
        //        float fSampleLeadMaxSpanEnd = 0;
        //        float fSampleMinSpan = 0;
        //        float fsampleMaxSpan = 0;

        //        m_smVisionInfo.g_arrLead[1].GetSampleSpanData(1, ref fSampleLeadMinSpanStart, ref fSampleLeadMaxSpanStart);
        //        m_smVisionInfo.g_arrLead[3].GetSampleSpanData(3, ref fSampleLeadMinSpanEnd, ref fSampleLeadMaxSpanEnd);

        //        fSampleMinSpan = (fSampleLeadMinSpanEnd - fSampleLeadMinSpanStart) / m_smVisionInfo.g_fCalibPixelY;
        //        fsampleMaxSpan = (fSampleLeadMaxSpanEnd - fSampleLeadMaxSpanStart) / m_smVisionInfo.g_fCalibPixelY;

        //        for (int i = 0; i < m_smVisionInfo.g_arrLead.Length; i++)
        //        {
        //            m_smVisionInfo.g_arrLead[i].ref_fLeadMinSpanResult = fSampleMinSpan;
        //            m_smVisionInfo.g_arrLead[i].ref_fLeadMaxSpanResult = fsampleMaxSpan;
        //        }

        //        if (fSampleMinSpan < m_smVisionInfo.g_arrLead[0].ref_fTemplateLeadMinSpanLimit || fsampleMaxSpan > m_smVisionInfo.g_arrLead[0].ref_fTemplateLeadMaxSpanLimit)
        //        {
        //            //fail span
        //            m_smVisionInfo.g_arrLead[0].ref_intFailResultMask |= 0x1000;

        //            if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
        //                if (m_intTCPIPResultID == -1)
        //                    m_intTCPIPResultID = (int)TCPIPResulID.Fail;

        //            return false;
        //        }
        //    }
        //    else if (m_smVisionInfo.g_arrLead[2].ref_blnSelected && m_smVisionInfo.g_arrLead[4].ref_blnSelected)
        //    {
        //        float fSampleLeadMinSpanStart = 0;
        //        float fSampleLeadMaxSpanStart = 0;
        //        float fSampleLeadMinSpanEnd = 0;
        //        float fSampleLeadMaxSpanEnd = 0;
        //        float fSampleMinSpan = 0;
        //        float fsampleMaxSpan = 0;

        //        m_smVisionInfo.g_arrLead[4].GetSampleSpanData(4, ref fSampleLeadMinSpanStart, ref fSampleLeadMaxSpanStart);
        //        m_smVisionInfo.g_arrLead[2].GetSampleSpanData(2, ref fSampleLeadMinSpanEnd, ref fSampleLeadMaxSpanEnd);

        //        fSampleMinSpan = (fSampleLeadMinSpanEnd - fSampleLeadMinSpanStart) / m_smVisionInfo.g_fCalibPixelX;
        //        fsampleMaxSpan = (fSampleLeadMaxSpanEnd - fSampleLeadMaxSpanStart) / m_smVisionInfo.g_fCalibPixelX;

        //        for (int i = 0; i < m_smVisionInfo.g_arrLead.Length; i++)
        //        {
        //            m_smVisionInfo.g_arrLead[i].ref_fLeadMinSpanResult = fSampleMinSpan;
        //            m_smVisionInfo.g_arrLead[i].ref_fLeadMaxSpanResult = fsampleMaxSpan;
        //        }

        //        if (fSampleMinSpan < m_smVisionInfo.g_arrLead[0].ref_fTemplateLeadMinSpanLimit || fsampleMaxSpan > m_smVisionInfo.g_arrLead[0].ref_fTemplateLeadMaxSpanLimit)
        //        {
        //            //fail span
        //            m_smVisionInfo.g_arrLead[0].ref_intFailResultMask |= 0x1000;

        //            if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
        //                if (m_intTCPIPResultID == -1)
        //                    m_intTCPIPResultID = (int)TCPIPResulID.Fail;

        //            return false;
        //        }
        //    }

        //    return true;
        //}

        private void TakeAction(string strMessage)
        {
            if (m_smVisionInfo.g_intMachineStatus == 2 && m_smVisionInfo.AT_PR_StartLiveImage && strMessage == "Client disconnected.")
            {
                m_smVisionInfo.AT_PR_StartLiveImage = false;
                m_smVisionInfo.AT_PR_TriggerLiveImage = true;
            }

            if (!(strMessage.StartsWith("<") && strMessage.EndsWith(">")))
                return;

            try
            {
                strMessage = strMessage.Remove(0, 1);
                string[] strString = strMessage.Split(',', '>');

                if (strString.Length == 0)
                    return;

                int intVisionIndex = 0;
                if (strString.Length < 3 || !int.TryParse(strString[2], out intVisionIndex))
                    intVisionIndex = -1;

                switch (strString[0])
                {
                    case "OCR":
                        if (intVisionIndex != Math.Pow(2, m_smVisionInfo.g_intVisionIndex) || m_smVisionInfo.g_intMachineStatus != 2)
                            m_smComThread.Send("<OCRRP,NG," + intVisionIndex + "," + m_smProductionInfo.g_arrSingleRecipeID[m_smVisionInfo.g_intVisionIndex] + ">");
                        else
                        {
                            m_smComThread.Send("<OCRRP,OK," + intVisionIndex + "," + m_smProductionInfo.g_arrSingleRecipeID[m_smVisionInfo.g_intVisionIndex] + ">");
                        }
                        break;
                    default:
                        break;
                }

            }
            catch (Exception ex)
            {
                SRMMessageBox.Show(ex.ToString());
            }
        }

        private void TakeAction_TCPIPIO(string strMessage)
        {
            if (m_smVisionInfo.g_intMachineStatus == 2 && m_smVisionInfo.AT_PR_StartLiveImage && strMessage == "Client disconnected.")
            {
                m_smVisionInfo.AT_PR_StartLiveImage = false;
                m_smVisionInfo.AT_PR_TriggerLiveImage = true;
            }

            if (!(strMessage.StartsWith("<") && strMessage.EndsWith(">")))
                return;

            try
            {
                strMessage = strMessage.Remove(0, 1);
                string[] strString = strMessage.Split(',', '>');

                if (strString.Length == 0)
                    return;

                int intTestOption = 0;
                if (strString.Length < 2 || !int.TryParse(strString[1], out intTestOption))
                    intTestOption = -1;

                int intVisionIndex = 0;
                if (strString.Length < 3 || !int.TryParse(strString[2], out intVisionIndex))
                    intVisionIndex = -1;

                switch (strString[0])
                {
                    case "SOV":
                        if (intVisionIndex != Math.Pow(2, m_smVisionInfo.g_intVisionIndex) || intTestOption < 0 || m_smVisionInfo.g_intMachineStatus != 2)
                            m_smTCPIPIO.Send(m_smVisionInfo.g_intVisionIndex, "SOVRP", false, -1/*intTestOption*/);
                        else
                        {
                            m_smTCPIPIO.Send(m_smVisionInfo.g_intVisionIndex, "SOVRP", true, intTestOption);

                            if ((intTestOption & 0x01) > 0)
                                m_blnStartVision_In = true;
                            else
                                m_blnStartVision_In = false;

                            if ((intTestOption & 0x40) > 0)
                                m_blnCheckOffset_In = true;
                            else
                                m_blnCheckOffset_In = false;

                            if ((intTestOption & 0x400) > 0)
                                m_blnMarkData0_In = true;
                            else
                                m_blnMarkData0_In = false;

                            if ((intTestOption & 0x800) > 0)
                                m_blnMarkData1_In = true;
                            else
                                m_blnMarkData1_In = false;

                            if ((intTestOption & 0x1000) > 0)
                                m_blnMarkData2_In = true;
                            else
                                m_blnMarkData2_In = false;

                            if ((intTestOption & 0x2000) > 0)
                                m_blnMarkData3_In = true;
                            else
                                m_blnMarkData3_In = false;

                            if ((intTestOption & 0x4000) > 0)
                                m_blnMarkData4_In = true;
                            else
                                m_blnMarkData4_In = false;

                            if ((intTestOption & 0x8000) > 0)
                                m_blnMarkData5_In = true;
                            else
                                m_blnMarkData5_In = false;

                        }
                        break;
                    case "EOV":
                        if (intVisionIndex != Math.Pow(2, m_smVisionInfo.g_intVisionIndex) || m_smVisionInfo.g_intMachineStatus != 2)
                            m_smTCPIPIO.Send(m_smVisionInfo.g_intVisionIndex, "EOVRP", false, intTestOption);
                        else
                        {
                            m_smTCPIPIO.Send(m_smVisionInfo.g_intVisionIndex, "EOVRP", true, intTestOption);
                        }
                        break;
                    default:
                        break;
                }

            }
            catch (Exception ex)
            {
                SRMMessageBox.Show(ex.ToString());
            }
        }
        
        private void UpdateProgress()
        {
            try
            {
                while (!m_blnStopping)
                {

                    if (!m_blnPause)
                    {

                        if (m_smVisionInfo.AT_PR_GrabImage)
                        {
                            m_smVisionInfo.g_blnGrabbing = true;
                            if (m_smVisionInfo.AT_PR_GrabImage) // 01-08-2019 ZJYEOH : Only clear drawing result when user pressed grab button, solved "grab before test" no drawings 
                                m_smVisionInfo.g_blnClearResult = true;
                            GrabImage(false);

                            // 2019-12-26 ZJYEOH : Copy Image to Rotated Image so that will not look weird when draw rotated Image
                            for (int i = 0; i < m_smVisionInfo.g_arrImages.Count; i++)
                                m_smVisionInfo.g_arrImages[i].CopyTo(m_smVisionInfo.g_arrRotatedImages[i]);

                            m_smVisionInfo.ALL_VM_UpdatePictureBox = true;
                            m_smVisionInfo.VS_AT_UpdateQuantity = true;
                            m_smVisionInfo.VM_AT_UpdateErrorMessage = true;
                            m_smVisionInfo.g_blnGrabbing = false;
                            m_smVisionInfo.AT_PR_GrabImage = false;
                        }

                        if (m_smVisionInfo.AT_PR_StartLiveImage && !m_smVisionInfo.AT_PR_PauseLiveImage)
                        {
                            m_smVisionInfo.g_blnGrabbing = true;
                            m_smVisionInfo.g_blnClearResult = true;

                            GrabImage(false);

                            // 2019-12-26 ZJYEOH : Copy Image to Rotated Image so that will not look weird when draw rotated Image
                            for (int i = 0; i < m_smVisionInfo.g_arrImages.Count; i++)
                                m_smVisionInfo.g_arrImages[i].CopyTo(m_smVisionInfo.g_arrRotatedImages[i]);

                            m_smVisionInfo.ALL_VM_UpdatePictureBox = true;
                            m_smVisionInfo.VS_AT_UpdateQuantity = true;
                            m_smVisionInfo.VM_AT_UpdateErrorMessage = true;
                            m_smVisionInfo.g_blnGrabbing = false;

                            Thread.Sleep(100);
                        }

                        if (m_smVisionInfo.AT_PR_AttachImagetoROI)
                        {
                            AttachImageToROI();

                            // 2019-10-14 ZJYEOH : AttachImageToROI for Lead move to here as crash may happen between UpdateSubProgress_MarkTest threading & UpdateSubProgress_LeadTest threading during attach and detach
                            // no need attach to Lead ROI during UpdateSubProgress_MarkTest
                            if ((m_smCustomizeInfo.g_intWantLead & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
                            {
                                if (m_smVisionInfo.g_objLeadImage == null)
                                    m_smVisionInfo.g_objLeadImage = new ImageDrawing(true);

                                m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo].CopyTo(ref m_smVisionInfo.g_objLeadImage);
                                AttachToROI(m_smVisionInfo.g_arrLeadROIs, m_smVisionInfo.g_objLeadImage);
                                //AttachToROI(m_smVisionInfo.g_arrLeadROIs, m_smVisionInfo.g_arrImages, m_smVisionInfo.g_arrLead[0].ref_intImageViewNo);
                            }

                            m_smVisionInfo.AT_PR_AttachImagetoROI = false;
                            m_smVisionInfo.ALL_VM_UpdatePictureBox = true;
                        }

                        if (m_smVisionInfo.CO_PR_DeleteTemplate)
                        {
                            m_smVisionInfo.CO_PR_DeleteTemplate = false;

                            //For bottom orient 
                            if ((m_smCustomizeInfo.g_intWantMark & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
                            {
                                if (m_smVisionInfo.g_blnWantClearMarkTemplateWhenNewLot)
                                    m_smVisionInfo.PR_CO_DeleteProcessSuccess = DeleteTemplate();
                                else
                                    m_smVisionInfo.PR_CO_DeleteProcessSuccess = true;
                            }
                            else
                                m_smVisionInfo.PR_CO_DeleteProcessSuccess = true;

                            m_smVisionInfo.PR_CO_DeleteTemplateDone = true;
                        }

                        if (m_smVisionInfo.MN_PR_StartTest)
                        {
                            //m_smVisionInfo.g_objGrabTime.Reset();
                            //m_smVisionInfo.g_objTransferTime.Reset();
                            m_smVisionInfo.g_objTotalTime.Start();
                            m_smVisionInfo.MN_PR_StartTest = false;

                            StartTest_MultiThreading(false);

                            m_smVisionInfo.g_objTotalTime.Stop();
                            m_smVisionInfo.VM_AT_BlockImageUpdate = false;
                            m_smVisionInfo.PR_MN_UpdateInfo = true;
                            m_smVisionInfo.PR_MN_TestDone = true;
                            if (m_smVisionInfo.g_intViewInspectionSetting == 0)
                                m_smVisionInfo.VM_AT_UpdateErrorMessage = true;
                            else
                                m_smVisionInfo.g_strErrorMessage = "";
                            //2020-08-12 ZJYEOH : After tolerance orm close just set to false so that when manual test will check all leads
                            //m_smVisionInfo.AT_VM_OfflineTestAllLead = false;
                            //Thread.Sleep(10);
                        }

                        if (m_smVisionInfo.MN_PR_StartTest_Verification)
                        {
                            m_blnRecipeVerificationTestMode = true;
                          
                            List<ImageDrawing> arrImg = new List<ImageDrawing>();
                            List<CImageDrawing> arrCImg = new List<CImageDrawing>();
                            if (m_smVisionInfo.g_blnViewColorImage)
                            {
                                for (int i = 0; i < m_smVisionInfo.g_arrColorImages.Count; i++)
                                {
                                    arrCImg.Add(new CImageDrawing());
                                    m_smVisionInfo.g_arrColorImages[i].CopyTo(ref arrCImg, i);
                                }
                            }

                            for (int i = 0; i < m_smVisionInfo.g_arrImages.Count; i++)
                            {
                                arrImg.Add(new ImageDrawing());
                                m_smVisionInfo.g_arrImages[i].CopyTo(ref arrImg, i);
                            }

                            //m_smVisionInfo.g_objGrabTime.Reset();
                            //m_smVisionInfo.g_objTransferTime.Reset();
                            m_smVisionInfo.g_objTotalTime.Start();
                            m_smVisionInfo.MN_PR_StartTest_Verification = false;
                            m_smVisionInfo.g_arrMarks[0].ref_intFailResultMask_ForPreTest = 0;

                            ImageDrawing objImage = new ImageDrawing();
                            CImageDrawing objCImage = new CImageDrawing();

                            if (m_smVisionInfo.g_arrMarks[0].ref_intFailOptionMask_ForPreTest > 0)
                            {
                                m_blnTestHandMade_Mark = true;
                                string strFolderPath = m_smProductionInfo.g_strRecipePath + m_smProductionInfo.g_arrSingleRecipeID[m_smVisionInfo.g_intVisionIndex] + "\\" + m_smVisionInfo.g_strVisionFolderName + "\\";

                                for (int i = 0; i < m_smVisionInfo.g_arrImages.Count; i++)
                                {
                                    string strTemplateImagePath;
                                    if (i == 0)
                                        strTemplateImagePath = strFolderPath + "Mark\\Template\\OriTemplate0_0.bmp";
                                    else
                                        strTemplateImagePath = strFolderPath + "Mark\\Template\\OriTemplate0_0_Image" + i.ToString() + ".bmp";
                                    if (File.Exists(strTemplateImagePath))
                                    {
                                        if (m_smVisionInfo.g_blnViewColorImage)
                                        {
                                            objCImage.LoadImage(strTemplateImagePath);
                                            objCImage.CopyTo(ref m_smVisionInfo.g_arrColorImages, i);
                                            m_smVisionInfo.g_arrColorImages[i].ConvertColorToMono(ref m_smVisionInfo.g_arrImages, i);
                                        }
                                        else
                                        {
                                            objImage.LoadImage(strTemplateImagePath);
                                            objImage.CopyTo(ref m_smVisionInfo.g_arrImages, i);
                                        }
                                    }
                                }
                                StartTest_MultiThreading_PreTest(false, -1);
                                m_blnTestHandMade_Mark = false;
                            }

                            for (int a = 0; a < 20; a++)
                            {
                                m_smVisionInfo.g_arrPreTestResult[a] = true;
                                m_smVisionInfo.g_arrPreTestErrorMessage[a] = m_smVisionInfo.g_strErrorMessage = "";
                                m_smVisionInfo.g_arrPreTestErrorMessageColor[a] = Color.Black;

                                if (!m_smVisionInfo.g_arrPreTestInspect[a])
                                    continue;
                                string strPath = "D:\\PreTest Image\\Recipe\\" + m_smProductionInfo.g_arrSingleRecipeID[m_smVisionInfo.g_intVisionIndex] + "\\" + m_smVisionInfo.g_strVisionFolderName + "\\";
                                for (int i = 0; i < m_smVisionInfo.g_arrImages.Count; i++)
                                {
                                    string strTemplateImagePath;
                                    if (i == 0)
                                        strTemplateImagePath = strPath + "SampleImage" + a.ToString() + ".bmp";
                                    else
                                        strTemplateImagePath = strPath + "SampleImage" + a.ToString() + "_Image" + i.ToString() + ".bmp";
                                    if (File.Exists(strTemplateImagePath))
                                    {
                                        if (m_smVisionInfo.g_blnViewColorImage)
                                        {
                                            objCImage.LoadImage(strTemplateImagePath);
                                            objCImage.CopyTo(ref m_smVisionInfo.g_arrColorImages, i);
                                            m_smVisionInfo.g_arrColorImages[i].ConvertColorToMono(ref m_smVisionInfo.g_arrImages, i);
                                        }
                                        else
                                        {
                                            objImage.LoadImage(strTemplateImagePath);
                                            objImage.CopyTo(ref m_smVisionInfo.g_arrImages, i);
                                        }
                                    }
                                }
                                StartTest_MultiThreading_PreTest(false, a);
                            }

                            if (m_smVisionInfo.g_blnViewColorImage)
                            {
                                for (int i = 0; i < arrCImg.Count; i++)
                                {
                                    arrCImg[i].CopyTo(ref m_smVisionInfo.g_arrColorImages, i);
                                }
                            }

                            for (int i = 0; i < arrImg.Count; i++)
                            {
                                arrImg[i].CopyTo(ref m_smVisionInfo.g_arrImages, i);
                            }

                            m_smVisionInfo.g_objTotalTime.Stop();
                            m_smVisionInfo.VM_AT_BlockImageUpdate = false;
                            m_smVisionInfo.PR_MN_UpdateInfo = true;
                            m_smVisionInfo.PR_MN_TestDone = true;
                   
                            //m_smVisionInfo.g_arrPreTestErrorMessage[] = m_smVisionInfo.g_strErrorMessage;
                            m_smVisionInfo.ALL_VM_UpdatePictureBox = true;
                            m_blnRecipeVerificationTestMode = false;
                        }

                        if ((!m_smCustomizeInfo.g_blnWantUseTCPIPIO && m_objVisionIO.IOStartVision.IsOn() && m_smVisionInfo.g_intMachineStatus == 2) ||
                            (m_smCustomizeInfo.g_blnWantUseTCPIPIO && m_blnStartVision_In && m_smVisionInfo.g_intMachineStatus == 2) ||
                            (m_smVisionInfo.g_blnDebugRUN && m_smVisionInfo.g_intMachineStatus == 2))
                        {
                            if (m_smVisionInfo.g_blnTrackBasic) STTrackLog.WriteLine("V1-Basic-1");

                            if (m_smVisionInfo.g_blnDebugRUN && (m_smProductionInfo.g_blnAllRunWithoutGrabImage || m_smProductionInfo.g_blnAllRunGrabWithoutUseImage) && (m_smProductionInfo.g_intDebugImageToUse == 1))
                            {
                                if (m_smVisionInfo.g_blnTrackBasic) STTrackLog.WriteLine("V1-Basic-2");
                                LoadNextImageForDebugRunTest();
                            }

                            //m_smVisionInfo.g_objGrabTime.Reset();
                            //m_smVisionInfo.g_objTransferTime.Reset();
                            m_smVisionInfo.g_objTotalTime.Start();
                            m_smVisionInfo.VS_AT_ProductionTestDone = false;

                            if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                            {
                                m_blnStartVision_In = false;
                                m_blnEndVision_Out = false;
                                m_blnPass1_Out = false;
                                //m_blnGrabbing_Out = true;
                                m_intTCPIPResultID = -1;
                                m_fOffsetX = 0;
                                m_fOffsetY = 0;
                                m_fOffsetAngle = 0;

                            }
                            else
                            {
                                m_objVisionIO.IOEndVision.SetOff(strTrackHeadName + " IOEndVision 9"); if (m_smVisionInfo.g_blnTrackIO) STTrackLog.WriteLine("IO-IOEndVision-Set OFF 1");
                                m_objVisionIO.IOPass1.SetOff(strTrackHeadName + " IOPass1 10"); if (m_smVisionInfo.g_blnTrackIO) STTrackLog.WriteLine("IO-IOPass1-Set OFF 2");
                                m_objVisionIO.IOGrabbing.SetOn(strTrackHeadName + " IOGrabbing 11"); if (m_smVisionInfo.g_blnTrackIO) STTrackLog.WriteLine("IO-IOGrabbing-Set ON 3");

                                if (m_smVisionInfo.g_blnTrackBasic) STTrackLog.WriteLine("V1-Basic-3");
                            }
                            m_blnGrabbing_Out = true;
                            //STTrackLog.WriteLine(m_smVisionInfo.g_strVisionName + "------------ Start");
                            StartTest_MultiThreading(true);
                            //STTrackLog.WriteLine(m_smVisionInfo.g_strVisionName + "------------ End");

                            if (m_smVisionInfo.g_blnTrackBasic) STTrackLog.WriteLine("V1-Basic-31");
                            if (!m_blnForceStopProduction)
                            {
                                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                                {
                                    m_blnEndVision_Out = true;
                                    //m_smTCPIPIO.Send(m_smVisionInfo.g_intVisionIndex, "EOVRP", m_blnEndVision_Out, -1);
                                }
                                else
                                    m_objVisionIO.IOEndVision.SetOn(strTrackHeadName + " IOEndVision 12"); if (m_smVisionInfo.g_blnTrackIO) STTrackLog.WriteLine("IO-IOEndVision-Set ON 100");

                            }
                            else
                            {
                                STTrackLog.WriteLine("Vision1Process > Force Stop Production");
                                m_blnForceStopProduction = false;
                                m_smVisionInfo.g_intMachineStatus = 1;
                            }

                            m_smVisionInfo.g_objTotalTime.Stop();
                            m_smProductionInfo.VM_TH_UpdateCount = true;
                            m_smVisionInfo.VM_AT_UpdateErrorMessage = true;

                            if ((m_smCustomizeInfo.g_intWant2DCode & (1 << m_smVisionInfo.g_intVisionPos)) > 0 && m_smVisionInfo.g_blnWantMark2DCode)
                            {
                                m_smProductionInfo.VM_TH_SaveData = true;
                            }

                            m_smVisionInfo.VS_AT_ProductionTestDone = true;

                            if (m_smVisionInfo.g_blnDebugRUN)
                                Thread.Sleep(m_smVisionInfo.g_intSleep);
                            else
                            {
                                if (m_smVisionInfo.g_intSleep > 1)              // Change to > 1 to prevent calling this sleep function during production when not necessary.
                                    Thread.Sleep(m_smVisionInfo.g_intSleep);
                            }

                            if (m_smProductionInfo.g_blnAllRunFromCenter)
                                m_smVisionInfo.g_blnDebugRUN = false;
                            
                            if (m_smVisionInfo.g_blnTrackBasic) STTrackLog.WriteLine("V1-Basic-32");
                        }

                        if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        {
                            if (m_blnEndVision_Out == true && m_smVisionInfo.g_intMachineStatus != 2)
                                m_blnEndVision_Out = false;
                            else if (m_blnEndVision_Out == false && m_smVisionInfo.g_intMachineStatus == 2)
                                m_blnEndVision_Out = true;
                        }
                        else
                        {
                            if (m_objVisionIO.IOEndVision.IsOn() && m_smVisionInfo.g_intMachineStatus != 2)
                                m_objVisionIO.IOEndVision.SetOff(strTrackHeadName + " IOEndVision 13");
                            else if (m_objVisionIO.IOEndVision.IsOff() && m_smVisionInfo.g_intMachineStatus == 2)
                                m_objVisionIO.IOEndVision.SetOn(strTrackHeadName + " IOEndVision 22");
                        }

                        if (m_smVisionInfo.g_blnWantClearSaveImageInfo)
                        {
                            m_arrPassNoBuffer = new int[m_smVisionInfo.g_intSaveImageBufferSize];
                            m_arrFailNoBuffer = new int[m_smVisionInfo.g_intSaveImageBufferSize];
                            m_arrOrientationBuffer = new int[m_smVisionInfo.g_intSaveImageBufferSize];
                            m_arrRejectNameBuffer = new string[m_smVisionInfo.g_intSaveImageBufferSize];
                            m_arrRejectMessageBuffer = new string[m_smVisionInfo.g_intSaveImageBufferSize];

                            m_arrRejectImageListPath.Clear();
                            m_arrRejectImageErrorMessageListPath.Clear();

                            m_smVisionInfo.g_blnWantClearSaveImageInfo = false;
                        }
                    }

                    Thread.Sleep(1);
                }
            }
            catch (Exception ex)
            {
                SRMMessageBox.Show("Vision1Process->UpdateProgress() :" + ex.ToString());
                SRMMessageBox.Show("Vision1Process has been terminated. Please Exit SRMVision software and Run again!", "Vision1Process", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
            finally
            {
                if (m_smVisionInfo.g_strCameraModel == "AVT")
                    m_objAVTFireGrab.OFFCamera();
                else if (m_smVisionInfo.g_strCameraModel == "Teli")
                {
                    if (m_blnCustomWantColor)
                        m_objTeliCamera.OFFCamera_LowLevelAPI();
                    else
                    {
                        if (m_smVisionInfo.g_intGrabMode == 0)
                            m_objTeliCamera.OFFCamera();
                        else
                            m_objTeliCamera.OFFCamera_LowLevelAPI();
                    }
                }
                //SetStopped();
                m_thThread = null;
                m_blnStopped = true;
            }
        }

        private void UpdateSubProgress_GrabImage()
        {
            while (!m_blnStopping)
            {

                try
                {
                    if (m_bSubTh1_GrabImage)
                    {
                        m_bSubTh1_GrabImage = false;
                        GrabImage(m_blnAuto);
                    }

                }
                catch (Exception ex)
                {
                    m_bSubTh1_GrabImage = false;

                    SRMMessageBox.Show("Vision1Process->UpdateSubProgress_GrabImage() :" + ex.ToString());
                }
                Thread.Sleep(1);
            }

            m_thSubThread_GrabImage = null;
            m_blnStopped_GrabImage = true;
        }
        private void UpdateSubProgress_TransferImage()  
        {
            while (!m_blnStopping)
            {

                try
                {
                    if (m_bSubTh1_TransferImage)
                    {
                        //HiPerfTimer tTransfer = new HiPerfTimer();
                        //tTransfer.Start();
                        bool blnStartTransfer = false;
                        for (int i = 0; i < m_intGrabRequire; i++)
                        {
                            blnStartTransfer = false;

                            switch (i)
                            {
                                case 0:
                                    blnStartTransfer = WaitEventDone(ref m_bGrabImage1LoadDone, true, ref m_bGrabImage1LoadResult, "WaitGrab1");
                                    if (!blnStartTransfer)
                                        STTrackLog.WriteLine("UpdateSubProgress_TransferImage > blnStartTransfer 0 fail");
                                    break;
                                case 1:
                                    blnStartTransfer = WaitEventDone(ref m_bGrabImage2LoadDone, true, ref m_bGrabImage2LoadResult, "WaitGrab2");
                                    if (!blnStartTransfer)
                                        STTrackLog.WriteLine("UpdateSubProgress_TransferImage > blnStartTransfer 1 fail");
                                    break;
                                case 2:
                                    blnStartTransfer = WaitEventDone(ref m_bGrabImage3LoadDone, true, ref m_bGrabImage3LoadResult, "WaitGrab3");
                                    if (!blnStartTransfer)
                                        STTrackLog.WriteLine("UpdateSubProgress_TransferImage > blnStartTransfer 2 fail");
                                    break;
                                case 3:
                                    blnStartTransfer = WaitEventDone(ref m_bGrabImage4LoadDone, true, ref m_bGrabImage4LoadResult, "WaitGrab4");
                                    if (!blnStartTransfer)
                                        STTrackLog.WriteLine("UpdateSubProgress_TransferImage > blnStartTransfer 3 fail");
                                    break;
                                case 4:
                                    blnStartTransfer = WaitEventDone(ref m_bGrabImage5LoadDone, true, ref m_bGrabImage5LoadResult, "WaitGrab5");
                                    if (!blnStartTransfer)
                                        STTrackLog.WriteLine("UpdateSubProgress_TransferImage > blnStartTransfer 4 fail");
                                    break;
                                case 5:
                                    blnStartTransfer = WaitEventDone(ref m_bGrabImage6LoadDone, true, ref m_bGrabImage6LoadResult, "WaitGrab6");
                                    if (!blnStartTransfer)
                                        STTrackLog.WriteLine("UpdateSubProgress_TransferImage > blnStartTransfer 5 fail");
                                    break;
                                case 6:
                                    blnStartTransfer = WaitEventDone(ref m_bGrabImage7LoadDone, true, ref m_bGrabImage7LoadResult, "WaitGrab7");
                                    if (!blnStartTransfer)
                                        STTrackLog.WriteLine("UpdateSubProgress_TransferImage > blnStartTransfer 6 fail");
                                    break;
                                default:
                                    blnStartTransfer = false;
                                    if (!blnStartTransfer)
                                        STTrackLog.WriteLine("UpdateSubProgress_TransferImage > blnStartTransfer default fail");
                                    break;
                            }

                            if (blnStartTransfer)
                            {
                                if (m_smProductionInfo.g_blnAllRunGrabWithoutUseImage)
                                {
                                    if (m_smVisionInfo.g_blnViewColorImage)
                                    {
                                        if (m_smVisionInfo.g_arrDebugColorImages.Count != m_smVisionInfo.g_arrColorImages.Count)
                                        {
                                            for (int d = 0; d < m_smVisionInfo.g_arrColorImages.Count; d++)
                                            {
                                                m_smVisionInfo.g_arrDebugColorImages.Add(new CImageDrawing(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight));
                                            }
                                        }
                                        m_objTeliCamera.ConvertImage(i);
                                        m_smVisionInfo.g_arrMemoryColorImage[i].LoadImageFromMemory(m_objTeliCamera.GetImagePointer());

                                        if (m_smVisionInfo.g_intRotateFlip == 1)
                                        {
                                            m_smVisionInfo.g_arrMemoryColorImage[i].Rotate180Image(ref m_smVisionInfo.g_arrCRotateImage, i);
                                        }
                                        else if (m_smVisionInfo.g_intRotateFlip == 2)
                                        {
                                            m_smVisionInfo.g_arrMemoryColorImage[i].Rotate90Image(ref m_smVisionInfo.g_arrCRotateImage, i);
                                        }
                                        else if (m_smVisionInfo.g_intRotateFlip == 3)
                                        {
                                            m_smVisionInfo.g_arrMemoryColorImage[i].RotateMinus90Image(ref m_smVisionInfo.g_arrCRotateImage, i);
                                        }
                                        else if (m_smVisionInfo.g_intRotateFlip == 4)
                                        {
                                            m_smVisionInfo.g_arrMemoryColorImage[i].FlipHorizontalImage(ref m_smVisionInfo.g_arrCRotateImage, i);
                                        }
                                        else if (m_smVisionInfo.g_intRotateFlip == 5)
                                        {
                                            m_smVisionInfo.g_arrMemoryColorImage[i].FlipVerticalImage(ref m_smVisionInfo.g_arrCRotateImage, i);
                                        }
                                        else
                                        {
                                            m_smVisionInfo.g_arrMemoryColorImage[i].CopyTo(ref m_smVisionInfo.g_arrCRotateImage, i);
                                        }

                                        m_smVisionInfo.g_arrCRotateImage[i].CopyTo(ref m_smVisionInfo.g_arrDebugColorImages, i);

                                        if (m_smVisionInfo.g_arrImageGain[i] != 1f)
                                        {
                                            m_smVisionInfo.g_arrDebugColorImages[i].AddGain(m_smVisionInfo.g_arrImageGain[i], m_smVisionInfo.g_intColorFormat);
                                        }

                                        if (i == 0)
                                        {
                                            if (m_smVisionInfo.g_blnEnhanceImage_Enable)
                                            {
                                                if (m_smVisionInfo.g_intEnhanceImage_Close > 0)
                                                    m_smVisionInfo.g_arrDebugColorImages[i].AddCloseMorphology(m_smVisionInfo.g_intEnhanceImage_Close);
                                                if (m_smVisionInfo.g_intEnhanceImage_Open > 0)
                                                    m_smVisionInfo.g_arrDebugColorImages[i].AddOpenMorphology(m_smVisionInfo.g_intEnhanceImage_Open);
                                                if (m_smVisionInfo.g_intEnhanceImage_Dilate > 0)
                                                    m_smVisionInfo.g_arrDebugColorImages[i].AddDilate(m_smVisionInfo.g_intEnhanceImage_Dilate);
                                                if (m_smVisionInfo.g_intEnhanceImage_Offset != 0)
                                                    m_smVisionInfo.g_arrDebugColorImages[i].AddOffset(m_smVisionInfo.g_intEnhanceImage_Offset, m_smVisionInfo.g_intColorFormat);
                                                if (m_smVisionInfo.g_fEnhanceImage_Gain != 1f)
                                                    m_smVisionInfo.g_arrDebugColorImages[i].AddGain(m_smVisionInfo.g_fEnhanceImage_Gain, m_smVisionInfo.g_intColorFormat);
                                            }
                                        }

                                        m_smVisionInfo.g_arrDebugColorImages[i].ConvertColorToMono(ref m_smVisionInfo.g_arrDebugImages, i);
                                    }
                                }
                                else
                                {
                                    if (m_smVisionInfo.g_blnViewColorImage)
                                    {
                                        //m_objTeliCamera.ConvertImage(i);
                                        //m_objTeliCamera.ConvertImage(/*m_arrBitmapData[i],*/ m_arrBufferPointer[i]);
                                        m_objTeliCamera.ConvertImage(i);
                                        m_smVisionInfo.g_arrMemoryColorImage[i].LoadImageFromMemory(m_objTeliCamera.GetImagePointer());

                                        if (m_smVisionInfo.g_intRotateFlip == 1)
                                        {
                                            m_smVisionInfo.g_arrMemoryColorImage[i].Rotate180Image(ref m_smVisionInfo.g_arrCRotateImage, i);
                                        }
                                        else if (m_smVisionInfo.g_intRotateFlip == 2)
                                        {
                                            m_smVisionInfo.g_arrMemoryColorImage[i].Rotate90Image(ref m_smVisionInfo.g_arrCRotateImage, i);
                                        }
                                        else if (m_smVisionInfo.g_intRotateFlip == 3)
                                        {
                                            m_smVisionInfo.g_arrMemoryColorImage[i].RotateMinus90Image(ref m_smVisionInfo.g_arrCRotateImage, i);
                                        }
                                        else if (m_smVisionInfo.g_intRotateFlip == 4)
                                        {
                                            m_smVisionInfo.g_arrMemoryColorImage[i].FlipHorizontalImage(ref m_smVisionInfo.g_arrCRotateImage, i);
                                        }
                                        else if (m_smVisionInfo.g_intRotateFlip == 5)
                                        {
                                            m_smVisionInfo.g_arrMemoryColorImage[i].FlipVerticalImage(ref m_smVisionInfo.g_arrCRotateImage, i);
                                        }
                                        else
                                        {
                                            m_smVisionInfo.g_arrMemoryColorImage[i].CopyTo(ref m_smVisionInfo.g_arrCRotateImage, i);
                                        }

                                        m_smVisionInfo.g_arrCRotateImage[i].CopyTo(ref m_smVisionInfo.g_arrColorImages, i);

                                        if (m_smVisionInfo.g_arrImageGain[i] != 1f)
                                        {
                                            m_smVisionInfo.g_arrColorImages[i].AddGain(m_smVisionInfo.g_arrImageGain[i], m_smVisionInfo.g_intColorFormat);
                                        }

                                        if (i == 0)
                                        {
                                            if (m_smVisionInfo.g_blnEnhanceImage_Enable)
                                            {
                                                if (m_smVisionInfo.g_intEnhanceImage_Close > 0)
                                                    m_smVisionInfo.g_arrColorImages[i].AddCloseMorphology(m_smVisionInfo.g_intEnhanceImage_Close);
                                                if (m_smVisionInfo.g_intEnhanceImage_Open > 0)
                                                    m_smVisionInfo.g_arrColorImages[i].AddOpenMorphology(m_smVisionInfo.g_intEnhanceImage_Open);
                                                if (m_smVisionInfo.g_intEnhanceImage_Dilate > 0)
                                                    m_smVisionInfo.g_arrColorImages[i].AddDilate(m_smVisionInfo.g_intEnhanceImage_Dilate);
                                                if (m_smVisionInfo.g_intEnhanceImage_Offset != 0)
                                                    m_smVisionInfo.g_arrColorImages[i].AddOffset(m_smVisionInfo.g_intEnhanceImage_Offset, m_smVisionInfo.g_intColorFormat);
                                                if (m_smVisionInfo.g_fEnhanceImage_Gain != 1f)
                                                    m_smVisionInfo.g_arrColorImages[i].AddGain(m_smVisionInfo.g_fEnhanceImage_Gain, m_smVisionInfo.g_intColorFormat);
                                            }
                                        }

                                        m_smVisionInfo.g_arrColorImages[i].ConvertColorToMono(ref m_smVisionInfo.g_arrImages, i);

                                    }
                                }

                                if (m_smProductionInfo.g_blnAllRunGrabWithoutUseImage)
                                {
                                    if (m_smVisionInfo.g_arrDebugImages.Count != m_smVisionInfo.g_arrImages.Count)
                                    {
                                        for (int d = 0; d < m_smVisionInfo.g_arrImages.Count; d++)
                                        {
                                            m_smVisionInfo.g_arrDebugImages.Add(new ImageDrawing(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight));
                                        }
                                    }
                                    if (!m_smVisionInfo.g_blnViewColorImage)
                                    {
                                        m_smVisionInfo.g_arrRotateImage[i].CopyTo(ref m_smVisionInfo.g_arrDebugImages, i);
                                        m_smVisionInfo.g_arrDebugImages[i].AddGain(m_smVisionInfo.g_arrImageGain[i]);

                                        // 2020 12 30 - CCENG: Do image processing to increase image contrast. (to solve mark no enough contrast case)
                                        if (i == 0)
                                        {
                                            if (m_smVisionInfo.g_blnEnhanceImage_Enable)
                                            {
                                                if (m_smVisionInfo.g_intEnhanceImage_Close > 0)
                                                    m_smVisionInfo.g_arrImages[i].AddCloseMorphology(m_smVisionInfo.g_intEnhanceImage_Close);
                                                if (m_smVisionInfo.g_intEnhanceImage_Open > 0)
                                                    m_smVisionInfo.g_arrImages[i].AddOpenMorphology(m_smVisionInfo.g_intEnhanceImage_Open);
                                                if (m_smVisionInfo.g_intEnhanceImage_Dilate > 0)
                                                    m_smVisionInfo.g_arrImages[i].AddDilate(m_smVisionInfo.g_intEnhanceImage_Dilate);
                                                if (m_smVisionInfo.g_intEnhanceImage_Offset != 0)
                                                    m_smVisionInfo.g_arrImages[i].AddOffset(m_smVisionInfo.g_intEnhanceImage_Offset);
                                                if (m_smVisionInfo.g_fEnhanceImage_Gain != 1f)
                                                    m_smVisionInfo.g_arrImages[i].AddGain(m_smVisionInfo.g_fEnhanceImage_Gain);
                                            }
                                        }
                                    }
                                    
                                }
                                else
                                {
                                    if (!m_smVisionInfo.g_blnViewColorImage)
                                    {
                                        m_smVisionInfo.g_arrRotateImage[i].CopyTo(ref m_smVisionInfo.g_arrImages, i);
                                        m_smVisionInfo.g_arrImages[i].AddGain(m_smVisionInfo.g_arrImageGain[i]);

                                        // 2020 12 30 - CCENG: Do image processing to increase image contrast. (to solve mark no enough contrast case)
                                        if (i == 0)
                                        {
                                            if (m_smVisionInfo.g_blnEnhanceImage_Enable)
                                            {
                                                if (m_smVisionInfo.g_intEnhanceImage_Close > 0)
                                                    m_smVisionInfo.g_arrImages[i].AddCloseMorphology(m_smVisionInfo.g_intEnhanceImage_Close);
                                                if (m_smVisionInfo.g_intEnhanceImage_Open > 0)
                                                    m_smVisionInfo.g_arrImages[i].AddOpenMorphology(m_smVisionInfo.g_intEnhanceImage_Open);
                                                if (m_smVisionInfo.g_intEnhanceImage_Dilate > 0)
                                                    m_smVisionInfo.g_arrImages[i].AddDilate(m_smVisionInfo.g_intEnhanceImage_Dilate);
                                                if (m_smVisionInfo.g_intEnhanceImage_Offset != 0)
                                                    m_smVisionInfo.g_arrImages[i].AddOffset(m_smVisionInfo.g_intEnhanceImage_Offset);
                                                if (m_smVisionInfo.g_fEnhanceImage_Gain != 1f)
                                                    m_smVisionInfo.g_arrImages[i].AddGain(m_smVisionInfo.g_fEnhanceImage_Gain);
                                            }
                                        }
                                    }
                                    
                                }

                                if (i == 0)
                                {
                                    m_bGrabImage1Result = true;
                                    m_bGrabImage1Done = true;
                                }
                                else if (i == 1)
                                {
                                    m_bGrabImage2Result = true;
                                    m_bGrabImage2Done = true;
                                }
                                else if (i == 2)
                                {
                                    m_bGrabImage3Result = true;
                                    m_bGrabImage3Done = true;
                                }
                                else if (i == 3)
                                {
                                    m_bGrabImage4Result = true;
                                    m_bGrabImage4Done = true;
                                }
                                else if (i == 4)
                                {
                                    m_bGrabImage5Result = true;
                                    m_bGrabImage5Done = true;
                                }
                                else if (i == 5)
                                {
                                    m_bGrabImage6Result = true;
                                    m_bGrabImage6Done = true;
                                }
                                else if (i == 6)
                                {
                                    m_bGrabImage7Result = true;
                                    m_bGrabImage7Done = true;
                                }

                            }
                            else
                            {
                                STTrackLog.WriteLine("UpdateSubProgress_TransferImage > Image Acquire Fail.");
                                m_smVisionInfo.g_strErrorMessage = "Image Acquire Fail.";

                                if (i == 0)
                                {
                                    m_bGrabImage1Result = false;
                                    m_bGrabImage1Done = true;
                                }
                                else if (i == 1)
                                {
                                    m_bGrabImage2Result = false;
                                    m_bGrabImage2Done = true;
                                }
                                else if (i == 2)
                                {
                                    m_bGrabImage3Result = false;
                                    m_bGrabImage3Done = true;
                                }
                                else if (i == 3)
                                {
                                    m_bGrabImage4Result = false;
                                    m_bGrabImage4Done = true;
                                }
                                else if (i == 4)
                                {
                                    m_bGrabImage5Result = false;
                                    m_bGrabImage5Done = true;
                                }
                                else if (i == 5)
                                {
                                    m_bGrabImage6Result = false;
                                    m_bGrabImage6Done = true;
                                }
                                else if (i == 6)
                                {
                                    m_bGrabImage7Result = false;
                                    m_bGrabImage7Done = true;
                                }
                            }
                        }

                        m_bGrabImage1Done = m_bGrabImage2Done = m_bGrabImage3Done = m_bGrabImage4Done = m_bGrabImage5Done = m_bGrabImage6Done = m_bGrabImage7Done = true;
                        
                        //tTransfer.Stop();
                        //STTrackLog.WriteLine("Transfer Time = " + tTransfer.Duration.ToString());
                        m_bSubTh1_TransferImage = false;

                    }

                }
                catch (Exception ex)
                {
                    SRMMessageBox.Show("Vision1Process->UpdateSubProgress_TransferImage() :" + ex.ToString());
                }
                Thread.Sleep(1);
            }

            m_thSubThread_TransferImage = null;
            m_blnStopped_TransferImage = true;

        }
        private void UpdateSubProgress_WaitFrame()
        {
            while (!m_blnStopping)
            {

                try
                {
                    if (m_bSubTh1_WaitFrame)
                    {
                        bool blnStartWaitFrame = false;
                        for (int i = 0; i < m_intGrabRequire; i++)
                        {
                            blnStartWaitFrame = false;

                            switch (i)
                            {
                                case 0:
                                    blnStartWaitFrame = WaitEventDone(ref m_bGrabImage1TriggerDone, true, ref m_bGrabImage1TriggerResult, "WaitTrigger1");
                                    if (!blnStartWaitFrame)
                                        STTrackLog.WriteLine("UpdateSubProgress_WaitFrame. > blnStartWaitFrame 0 fail");
                                    break;
                                case 1:
                                    blnStartWaitFrame = WaitEventDone(ref m_bGrabImage2TriggerDone, true, ref m_bGrabImage2TriggerResult, "WaitTrigger2");
                                    if (!blnStartWaitFrame)
                                        STTrackLog.WriteLine("UpdateSubProgress_WaitFrame. > blnStartWaitFrame 1 fail");
                                    break;
                                case 2:
                                    blnStartWaitFrame = WaitEventDone(ref m_bGrabImage3TriggerDone, true, ref m_bGrabImage3TriggerResult, "WaitTrigger3");
                                    if (!blnStartWaitFrame)
                                        STTrackLog.WriteLine("UpdateSubProgress_WaitFrame. > blnStartWaitFrame 2 fail");
                                    break;
                                case 3:
                                    blnStartWaitFrame = WaitEventDone(ref m_bGrabImage4TriggerDone, true, ref m_bGrabImage4TriggerResult, "WaitTrigger4");
                                    if (!blnStartWaitFrame)
                                        STTrackLog.WriteLine("UpdateSubProgress_WaitFrame. > blnStartWaitFrame 3 fail");
                                    break;
                                case 4:
                                    blnStartWaitFrame = WaitEventDone(ref m_bGrabImage5TriggerDone, true, ref m_bGrabImage5TriggerResult, "WaitTrigger5");
                                    if (!blnStartWaitFrame)
                                        STTrackLog.WriteLine("UpdateSubProgress_WaitFrame. > blnStartWaitFrame 4 fail");
                                    break;
                                case 5:
                                    blnStartWaitFrame = WaitEventDone(ref m_bGrabImage6TriggerDone, true, ref m_bGrabImage6TriggerResult, "WaitTrigger6");
                                    if (!blnStartWaitFrame)
                                        STTrackLog.WriteLine("UpdateSubProgress_WaitFrame. > blnStartWaitFrame 5 fail");
                                    break;
                                case 6:
                                    blnStartWaitFrame = WaitEventDone(ref m_bGrabImage7TriggerDone, true, ref m_bGrabImage7TriggerResult, "WaitTrigger7");
                                    if (!blnStartWaitFrame)
                                        STTrackLog.WriteLine("UpdateSubProgress_WaitFrame. > blnStartWaitFrame 6 fail");
                                    break;
                                default:
                                    if (!blnStartWaitFrame)
                                        STTrackLog.WriteLine("UpdateSubProgress_WaitFrame. > blnStartWaitFrame default fail");
                                    blnStartWaitFrame = false;
                                    break;
                            }
                            //if (blnStartWaitFrame)
                            //{
                            //    bool StartTriggerRead = false;
                            //    switch (i)
                            //    {
                            //        case 0:
                            //            StartTriggerRead = true;
                            //            break;
                            //        case 1:
                            //            StartTriggerRead = WaitEventDone(ref m_bGrabImage1LoadDone, true, "WaitLoad1");
                            //            break;
                            //        case 2:
                            //            StartTriggerRead = WaitEventDone(ref m_bGrabImage2LoadDone, true, "WaitLoad2");
                            //            break;
                            //        case 3:
                            //            StartTriggerRead = WaitEventDone(ref m_bGrabImage3LoadDone, true, "WaitLoad3");
                            //            break;
                            //        case 4:
                            //            StartTriggerRead = WaitEventDone(ref m_bGrabImage4LoadDone, true, "WaitLoad4");
                            //            break;
                            //    }
                            //    if (StartTriggerRead)
                            //    {
                            //        //STTrackLog.WriteLine("TriggerImageBufferRead = " + i.ToString());
                            //        m_objTeliCamera.TriggerImageBufferRead();
                            //    }
                            //}

                            if (blnStartWaitFrame && m_objTeliCamera.WaitFrameAcquiredReady(i))
                            {
                                //STTrackLog.WriteLine("Get Image Buffer " + (i + 1));
                                //STTrackLog.WriteLine("Get Image Buffer " + m_objTeliCamera.GetBufferPointer());
                                if (m_smVisionInfo.g_blnViewColorImage)
                                {
                                    //m_smVisionInfo.g_objMemoryColorImage.SetImageSize(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight);
                                    //m_smVisionInfo.g_objMemoryColorImage.LoadImageFromMemory(m_objTeliCamera.GetImagePointer());
                                    //m_smVisionInfo.g_objMemoryColorImage.CopyTo(ref m_smVisionInfo.g_arrColorImages, i - 1);
                                    //m_smVisionInfo.g_arrColorImages[i - 1].ConvertColorToMono(ref m_smVisionInfo.g_arrImages, i - 1);
                                    //if (m_smProductionInfo.g_blnAllRunGrabWithoutUseImage)
                                    //    m_smVisionInfo.g_arrColorImages[i - 1].ConvertColorToMono(ref m_smVisionInfo.g_arrDebugImages, i - 1);

                                    //m_smVisionInfo.g_arrMemoryColorImage[i].LoadImageFromMemory(m_objTeliCamera.GetImagePointer());
                                    //m_arrBitmapData.Add(m_objTeliCamera.GetBitmapData());
                                    //m_arrBufferPointer.Add(m_objTeliCamera.GetBufferPointer());
                                }
                                else
                                {
                                    //m_smVisionInfo.g_objMemoryImage.SetImageSize(m_smVisionInfo.g_intCameraResolutionWidth, m_smVisionInfo.g_intCameraResolutionHeight);
                                    //m_smVisionInfo.g_objMemoryImage.LoadImageFromMemory(m_objTeliCamera.GetImagePointer());
                                    m_smVisionInfo.g_arrMemoryImage[i].LoadImageFromMemory(m_objTeliCamera.GetImageBufferPointer(i));//(m_objTeliCamera.GetImagePointer());

                                    if (m_smVisionInfo.g_intRotateFlip == 1)
                                    {
                                        m_smVisionInfo.g_arrMemoryImage[i].Rotate180Image(ref m_smVisionInfo.g_arrRotateImage, i);
                                    }
                                    else if (m_smVisionInfo.g_intRotateFlip == 2)
                                    {
                                        m_smVisionInfo.g_arrMemoryImage[i].Rotate90Image(ref m_smVisionInfo.g_arrRotateImage, i);
                                    }
                                    else if (m_smVisionInfo.g_intRotateFlip == 3)
                                    {
                                        m_smVisionInfo.g_arrMemoryImage[i].RotateMinus90Image(ref m_smVisionInfo.g_arrRotateImage, i);
                                    }
                                    else if (m_smVisionInfo.g_intRotateFlip == 4)
                                    {
                                        m_smVisionInfo.g_arrMemoryImage[i].FlipHorizontalImage(ref m_smVisionInfo.g_arrRotateImage, i);
                                    }
                                    else if (m_smVisionInfo.g_intRotateFlip == 5)
                                    {
                                        m_smVisionInfo.g_arrMemoryImage[i].FlipVerticalImage(ref m_smVisionInfo.g_arrRotateImage, i);
                                    }
                                    else
                                    {
                                        m_smVisionInfo.g_arrMemoryImage[i].CopyTo(ref m_smVisionInfo.g_arrRotateImage, i);
                                    }

                                }


                                if (i == 0)
                                {
                                    m_bGrabImage1LoadResult = true;
                                    m_bGrabImage1LoadDone = true;
                                }
                                else if (i == 1)
                                {
                                    m_bGrabImage2LoadResult = true;
                                    m_bGrabImage2LoadDone = true;
                                }
                                else if (i == 2)
                                {
                                    m_bGrabImage3LoadResult = true;
                                    m_bGrabImage3LoadDone = true;
                                }
                                else if (i == 3)
                                {
                                    m_bGrabImage4LoadResult = true;
                                    m_bGrabImage4LoadDone = true;
                                }
                                else if (i == 4)
                                {
                                    m_bGrabImage5LoadResult = true;
                                    m_bGrabImage5LoadDone = true;
                                }
                                else if (i == 5)
                                {
                                    m_bGrabImage6LoadResult = true;
                                    m_bGrabImage6LoadDone = true;
                                }
                                else if (i == 6)
                                {
                                    m_bGrabImage7LoadResult = true;
                                    m_bGrabImage7LoadDone = true;
                                }

                            }
                            else
                            {
                                STTrackLog.WriteLine("Vision1Process UpdateSubProgress_WaitFrame. > Wait Frame Timeout");
                                m_smVisionInfo.g_strErrorMessage = "Wait Frame Timeout.";

                                //if (m_smVisionInfo.g_blnViewColorImage)
                                //m_arrBufferPointer.Add(IntPtr.Zero);
                                if (i == 0)
                                {
                                    m_bGrabImage1LoadResult = false;
                                    m_bGrabImage1LoadDone = true;
                                }
                                else if (i == 1)
                                {
                                    m_bGrabImage2LoadResult = false;
                                    m_bGrabImage2LoadDone = true;
                                }
                                else if (i == 2)
                                {
                                    m_bGrabImage3LoadResult = false;
                                    m_bGrabImage3LoadDone = true;
                                }
                                else if (i == 3)
                                {
                                    m_bGrabImage4LoadResult = false;
                                    m_bGrabImage4LoadDone = true;
                                }
                                else if (i == 4)
                                {
                                    m_bGrabImage5LoadResult = false;
                                    m_bGrabImage5LoadDone = true;
                                }
                                else if (i == 5)
                                {
                                    m_bGrabImage6LoadResult = false;
                                    m_bGrabImage6LoadDone = true;
                                }
                                else if (i == 6)
                                {
                                    m_bGrabImage7LoadResult = false;
                                    m_bGrabImage7LoadDone = true;
                                }
                            }
                        }

                        m_bGrabImage1LoadDone = m_bGrabImage2LoadDone = m_bGrabImage3LoadDone = m_bGrabImage4LoadDone = m_bGrabImage5LoadDone = m_bGrabImage6LoadDone = m_bGrabImage7LoadDone = true;
                        
                        m_bSubTh1_WaitFrame = false;

                    }

                }
                catch (Exception ex)
                {
                    SRMMessageBox.Show("Vision1Process->UpdateSubProgress_WaitFrame() :" + ex.ToString());
                }
                Thread.Sleep(1);
            }

            m_thSubThread_WaitFrame = null;
            m_blnStopped_WaitFrame = true;

        }
       
        private void UpdateSubProgress_SaveImage()
        {
            while (!m_blnStopping)
            {

                try
                {
                    if ((m_intPassStartNode != m_intPassEndNode) ||
                        (m_intFailStartNode != m_intFailEndNode))
                    {
                        SaveImageBuffer();
                    }
                }
                catch (Exception ex)
                {
                    SRMMessageBox.Show("Vision1Process->UpdateSubProgress_SaveImage() :" + ex.ToString());
                }
                Thread.Sleep(1);
            }

            m_thSubThread_SaveImage = null;
            m_blnStopped_SaveImage = true;
        }

        private void UpdateSubProgress_MarkTest()
        {
            while (!m_blnStopping)
            {

                try
                {
                    if (m_bSubTh_MarkTest)
                    {
                        m_bSubTh_MarkTest_Result = false;

                        //WaitEventDone(ref m_bGrabImage1Done, true);
                        bool blnResultOK = true;

                        // STTrackLog.WriteLine("start wait grab image result");
                        blnResultOK = WaitEventDone(ref m_bGrabImage1Done, true, ref m_bGrabImage1Result, "UpdateSubProgress_MarkTest > m_bGrabImage1Done 8670");

                        if (m_smVisionInfo.g_blnWantGauge) //If User want use mark gauge
                        {
                            int[] arrUserSelectImageViewIndex;

                            if (m_blnWantOrientTest)
                                arrUserSelectImageViewIndex = m_smVisionInfo.g_arrOrientGaugeM4L[0].GetGaugeImageNoList();
                            else
                                arrUserSelectImageViewIndex = m_smVisionInfo.g_arrMarkGaugeM4L[0].GetGaugeImageNoList();

                            blnResultOK = WaitEventDone(arrUserSelectImageViewIndex, "arrUserSelectImageViewIndex 8681");
                        }

                        //STTrackLog.WriteLine("Get image result = " + blnResultOK.ToString());

                        AttachImageToROI();

                        bool blnWantMark = false;
                        if (m_smVisionInfo.g_arrMarks != null && m_smVisionInfo.g_arrMarks.Count > 0)
                        {
                            blnWantMark = m_smVisionInfo.g_arrMarks[0].ref_blnCheckMark;
                        }

                        // 2020 11 19 - CCENG: User may select Option Want Check Orientation, but no check Mark. 
                        //                     So need to define blnWantOrient is true or not. 
                        //                     If true, then need to call the StartOrientTest function.
                        bool blnWantOrient = false;
                        if ((m_smCustomizeInfo.g_intWantOrient0Deg & (1 << m_smVisionInfo.g_intVisionPos)) == 0)    // mean it is Mark Orient vision, not Mark only vision.
                        {
                            if (m_smVisionInfo.g_arrOrients.Count > 0 && m_smVisionInfo.g_arrOrients[0].Count > 0)  // Option Want Orientation is checked.
                            {

                                if (m_smVisionInfo.g_arrOrients[0][0].ref_blnWantCheckOrientation)
                                    blnWantOrient = true;
                            }
                        }

                        //if ((m_smCustomizeInfo.g_intWantOrient0Deg & (1 << m_smVisionInfo.g_intVisionPos)) == 0)
                        //{
                        // 2020 06 28 - Need to check orientation also even though Mark Checking is not selected in option form. Because what user want is check mark but wont fail only.
                        // 2020 07 08 - Roll back to previous method, wont check mark if Mark Checking is not selected.
                        if (blnWantMark || blnWantOrient || ShowLiterationOnly)
                        {
                            if (blnWantMark)
                            {
                                if (m_smVisionInfo.g_blnWantCheckNoMark)
                                {
                                    ROI objNoMarkROI = new ROI();
                                    ImageDrawing objTempImage = new ImageDrawing(true, m_smVisionInfo.g_arrImages[0].ref_intImageWidth, m_smVisionInfo.g_arrImages[0].ref_intImageHeight);

                                    if (m_blnWantPackageTest && ((m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailMask & 0x1000) > 0 || m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetWantInspectPackage() || GetWantInspectPackageColor(m_smVisionInfo.g_intSelectedUnit))) // 2020-06-23 ZJYEOH : If inspection option got tick Check package size just can use pkg gauge
                                    {
                                        //2020-11-07 ZJYEOH : Need to wait package gauge measure finish just can take the angle 
                                        WaitEventDone(ref m_bPackageSizePreTestDone, true, 10000, "StartOrientTest > m_bPackageSizePreTestDone2");

                                        if (m_bPackageSizePreTestResult)
                                        {
                                            objNoMarkROI.LoadROISetting((int)Math.Round((m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X -
                                           m_smVisionInfo.g_objGauge_PkgSize.ref_fRectWidth / 2 +
                                           m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromLeft), 0, MidpointRounding.AwayFromZero),
                                           (int)Math.Round((m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y -
                                           m_smVisionInfo.g_objGauge_PkgSize.ref_fRectHeight / 2 +
                                           m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromEdge), 0, MidpointRounding.AwayFromZero),
                                           (int)Math.Round(m_smVisionInfo.g_objGauge_PkgSize.ref_fRectWidth - m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromRight - m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromLeft, 0, MidpointRounding.AwayFromZero),
                                           (int)Math.Round(m_smVisionInfo.g_objGauge_PkgSize.ref_fRectHeight - m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromEdge - m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intStartPixelFromBottom, 0, MidpointRounding.AwayFromZero));
                                            // 2020-06-25 ZJYEOH : Need to include Orient angle and package gauge angle for MOPkg, MarkPkg will not affected as Orient angle will always be 0
                                            ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[0], objNoMarkROI, m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle, m_smVisionInfo.g_intRotationInterpolation_Mark, ref objTempImage);
                                            objNoMarkROI.AttachImage(objTempImage);

                                        }
                                        else
                                        {
                                            objNoMarkROI.LoadROISetting(m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROITotalX,
                                                                        m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROITotalY,
                                                                        m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROIWidth,
                                                                        m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROIHeight);
                                            objNoMarkROI.AttachImage(m_smVisionInfo.g_arrImages[0]);
                                        }
                                    }
                                    else
                                    {
                                        objNoMarkROI.LoadROISetting(m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROITotalX,
                                                                         m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROITotalY,
                                                                         m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROIWidth,
                                                                         m_smVisionInfo.g_arrMarkROIs[0][1].ref_ROIHeight);
                                        objNoMarkROI.AttachImage(m_smVisionInfo.g_arrImages[0]);
                                    }
                                    //objNoMarkROI.SaveImage("D:\\TS\\objNoMarkROI.bmp");
                                    //objTempImage.SaveImage("D:\\TS\\objTempImage.bmp");
                                    if (!m_smVisionInfo.g_arrMarks[0].CheckNoMark(objNoMarkROI, m_smVisionInfo.g_intMarkDefectInspectionMethod, m_smVisionInfo.g_intMarkInspectionAreaGrayValueSensitivity, m_smVisionInfo.g_intMarkBrightSensitivity))
                                    {
                                        m_smVisionInfo.g_blnMarkInspected = true;
                                        m_smVisionInfo.g_blnDrawMarkResult = !m_blnRecipeVerificationTestMode;//true

                                        m_smVisionInfo.g_strErrorMessage += m_smVisionInfo.g_arrMarks[0].GetInspectionMessage(-1, false, 0);

                                        if (m_blnAuto)
                                        {
                                            SaveRejectImage_AddToBuffer("Mark", m_smVisionInfo.g_arrMarks[0].GetInspectionMessage(-1, false, 0));

                                            m_smVisionInfo.g_intMarkFailureTotal++;
                                        }

                                        blnResultOK = false;
                                    }
                                    objNoMarkROI.Dispose();
                                    objTempImage.Dispose();
                                }
                            }

                            // ------------------ Orientation Test ---------------------------------------------------
                            if ((m_smCustomizeInfo.g_intWantBottom & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
                            {
                                // Under Bottom Orientation Vision
                                if (blnResultOK && !StartBottomOrientTest(m_blnAuto))
                                    blnResultOK = false;
                            }
                            else
                            {
                                // Under Mark Orientation vision
                                //if (blnResultOK && !StartOrientTest_using4LGauge(m_blnAuto))   // Use orient gauge to measure unit location and size from image 1 only. No package here.
                                if (blnResultOK && !StartOrientTest_using4LGauge_OcvAngleAndPackageAngle(m_blnAuto, blnWantOrient))   // 2020 05 02 - CCENG: Orient Test with Ocv angle and package angle separated.
                                    blnResultOK = false;
                            }
                        }
                        //}
                        //else
                        //{
                        //    m_smVisionInfo.g_arrImages[0].CopyTo(m_smVisionInfo.g_arrRotatedImages[0]);
                        //}

                        //2021-04-13 ZJYEOH : Moved to after Pin 1 Inspection, because gt Pin 1 Orientation function
                        //m_blnOrientDataUpdated = true;// Set to true so that WaitEvent Loop can be break

                        // ------------------- Pin 1 Test --------------------------------------------------------
                        //if (m_smVisionInfo.g_blnWantPin1 && blnResultOK)
                        if (m_smVisionInfo.g_blnWantPin1 && m_smVisionInfo.g_arrPin1[0].getWantCheckPin1(m_smVisionInfo.g_intSelectedTemplate))
                        {
                            m_smVisionInfo.g_arrPin1[0].ResetInspectionData();

                            if (blnResultOK)
                            {
                                // MO vision + No Mark + No Orient + Adv Setting want use Pin 1 direction as Orientation Result + Want Pin 1 checking.
                                // For MO vision + Dummy Unit that do not have mark and need to use pin 1 to define the orientation.
                                if (m_smVisionInfo.g_WantUsePin1OrientationWhenNoMark &&
                                    ((m_smCustomizeInfo.g_intWantOrient & (1 << m_smVisionInfo.g_intVisionPos)) > 0) &&
                                    !blnWantMark && !blnWantOrient && m_smVisionInfo.g_arrPin1[0].getWantCheckPin1(m_smVisionInfo.g_intSelectedTemplate))
                                {
                                    if (m_blnWantPackageTest && ((m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailMask & 0x1000) > 0 || m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetWantInspectPackage() || GetWantInspectPackageColor(m_smVisionInfo.g_intSelectedUnit)))
                                    {
                                        if (m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetGrabImageIndex(2) == m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo || m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetGrabImageIndex(3) == m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo)
                                        {
                                            WaitEventDone(ref m_bPackageSizePreTestDone, true, 10000, "UpdateSubProgress_MarkTest > m_bPackageSizePreTestDone 8746");

                                            bool blnPin1ImageRotated = false;
                                            if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 0)
                                                blnPin1ImageRotated = m_blnRotateImage1Updated;
                                            else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 1)
                                                blnPin1ImageRotated = m_blnRotateImage2Updated;
                                            else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 2)
                                                blnPin1ImageRotated = m_blnRotateImage3Updated;
                                            else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 3)
                                                blnPin1ImageRotated = m_blnRotateImage4Updated;
                                            else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 4)
                                                blnPin1ImageRotated = m_blnRotateImage5Updated;
                                            else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 5)
                                                blnPin1ImageRotated = m_blnRotateImage6Updated;
                                            else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 6)
                                                blnPin1ImageRotated = m_blnRotateImage7Updated;

                                            if (!blnPin1ImageRotated)
                                            {
                                                if (m_bPackageSizePreTestResult)
                                                {
                                                    ROI objRotatedROI = new ROI();
                                                    objRotatedROI.AttachImage(m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo]);
                                                    objRotatedROI.LoadROISetting(m_pOrientRotateStartPoint.X, m_pOrientRotateStartPoint.Y, m_pOrientRotateSize.Width, m_pOrientRotateSize.Height);
                                                    ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo], objRotatedROI, m_intOrientAngle + m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle, m_smVisionInfo.g_intRotationInterpolation_Mark, ref m_smVisionInfo.g_arrRotatedImages, m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo);

                                                    if (m_blnCustomWantColor && !GetColorImageRotated(m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo) && !ContainColorSelectedImage(m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo, m_smVisionInfo.g_intSelectedUnit))
                                                    {
                                                        CROI objColorRotatedROI = new CROI();
                                                        objColorRotatedROI.AttachImage(m_smVisionInfo.g_arrColorImages[m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo]);

                                                        // Get RotateROI center point where the ROI center point == Package Unit Center Point
                                                        objColorRotatedROI.LoadROISetting(objRotatedROI.ref_ROIPositionX,
                                                                                     objRotatedROI.ref_ROIPositionY,
                                                                                     objRotatedROI.ref_ROIWidth,
                                                                                     objRotatedROI.ref_ROIHeight);

                                                        CROI.Rotate0Degree(m_smVisionInfo.g_arrColorImages[m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo], objColorRotatedROI, m_intOrientAngle + m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle, 4, ref m_smVisionInfo.g_arrColorRotatedImages, m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo);

                                                        SetColorImageRotated(m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo);
                                                        objColorRotatedROI.Dispose();
                                                    }

                                                    if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 0)
                                                        m_blnRotateImage1Updated = true;
                                                    else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 1)
                                                        m_blnRotateImage2Updated = true;
                                                    else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 2)
                                                        m_blnRotateImage3Updated = true;
                                                    else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 3)
                                                        m_blnRotateImage4Updated = true;
                                                    else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 4)
                                                        m_blnRotateImage5Updated = true;
                                                    else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 5)
                                                        m_blnRotateImage6Updated = true;
                                                    else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 6)
                                                        m_blnRotateImage7Updated = true;
                                                }
                                                else
                                                    m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo].CopyTo(ref m_smVisionInfo.g_arrRotatedImages, m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo);
                                            }
                                        }
                                        else
                                        {
                                            if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 0)
                                                blnResultOK = WaitEventDone(ref m_bGrabImage1Done, true, ref m_bGrabImage1Result, "UpdateSubProgress_MarkTest > m_bGrabImage1Done f");
                                            else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 1)
                                                blnResultOK = WaitEventDone(ref m_bGrabImage2Done, true, ref m_bGrabImage2Result, "UpdateSubProgress_MarkTest > m_bGrabImage2Done f");
                                            else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 2)
                                                blnResultOK = WaitEventDone(ref m_bGrabImage3Done, true, ref m_bGrabImage3Result, "UpdateSubProgress_MarkTest > m_bGrabImage3Done f");
                                            else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 3)
                                                blnResultOK = WaitEventDone(ref m_bGrabImage4Done, true, ref m_bGrabImage4Result, "UpdateSubProgress_MarkTest > m_bGrabImage4Done f");
                                            else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 4)
                                                blnResultOK = WaitEventDone(ref m_bGrabImage5Done, true, ref m_bGrabImage5Result, "UpdateSubProgress_MarkTest > m_bGrabImage5Done f");
                                            else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 5)
                                                blnResultOK = WaitEventDone(ref m_bGrabImage6Done, true, ref m_bGrabImage6Result, "UpdateSubProgress_MarkTest > m_bGrabImage6Done f");
                                            else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 6)
                                                blnResultOK = WaitEventDone(ref m_bGrabImage7Done, true, ref m_bGrabImage7Result, "UpdateSubProgress_MarkTest > m_bGrabImage7Done f");

                                            if (blnResultOK)
                                            {
                                                bool blnPin1ImageRotated = false;
                                                if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 0)
                                                    blnPin1ImageRotated = m_blnRotateImage1Updated;
                                                else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 1)
                                                    blnPin1ImageRotated = m_blnRotateImage2Updated;
                                                else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 2)
                                                    blnPin1ImageRotated = m_blnRotateImage3Updated;
                                                else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 3)
                                                    blnPin1ImageRotated = m_blnRotateImage4Updated;
                                                else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 4)
                                                    blnPin1ImageRotated = m_blnRotateImage5Updated;
                                                else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 5)
                                                    blnPin1ImageRotated = m_blnRotateImage6Updated;
                                                else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 6)
                                                    blnPin1ImageRotated = m_blnRotateImage7Updated;

                                                if (!blnPin1ImageRotated)
                                                {
                                                    m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo].CopyTo(ref m_smVisionInfo.g_arrRotatedImages, m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo);
                                                }

                                            }
                                        }
                                    }
                                    else
                                    {
                                        if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 0)
                                            blnResultOK = WaitEventDone(ref m_bGrabImage1Done, true, ref m_bGrabImage1Result, "UpdateSubProgress_MarkTest > m_bGrabImage1Done f");
                                        else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 1)
                                            blnResultOK = WaitEventDone(ref m_bGrabImage2Done, true, ref m_bGrabImage2Result, "UpdateSubProgress_MarkTest > m_bGrabImage2Done f");
                                        else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 2)
                                            blnResultOK = WaitEventDone(ref m_bGrabImage3Done, true, ref m_bGrabImage3Result, "UpdateSubProgress_MarkTest > m_bGrabImage3Done f");
                                        else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 3)
                                            blnResultOK = WaitEventDone(ref m_bGrabImage4Done, true, ref m_bGrabImage4Result, "UpdateSubProgress_MarkTest > m_bGrabImage4Done f");
                                        else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 4)
                                            blnResultOK = WaitEventDone(ref m_bGrabImage5Done, true, ref m_bGrabImage5Result, "UpdateSubProgress_MarkTest > m_bGrabImage5Done f");
                                        else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 5)
                                            blnResultOK = WaitEventDone(ref m_bGrabImage6Done, true, ref m_bGrabImage6Result, "UpdateSubProgress_MarkTest > m_bGrabImage6Done f");
                                        else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 6)
                                            blnResultOK = WaitEventDone(ref m_bGrabImage7Done, true, ref m_bGrabImage7Result, "UpdateSubProgress_MarkTest > m_bGrabImage7Done f");

                                        if (blnResultOK)
                                        {
                                            bool blnPin1ImageRotated = false;
                                            if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 0)
                                                blnPin1ImageRotated = m_blnRotateImage1Updated;
                                            else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 1)
                                                blnPin1ImageRotated = m_blnRotateImage2Updated;
                                            else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 2)
                                                blnPin1ImageRotated = m_blnRotateImage3Updated;
                                            else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 3)
                                                blnPin1ImageRotated = m_blnRotateImage4Updated;
                                            else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 4)
                                                blnPin1ImageRotated = m_blnRotateImage5Updated;
                                            else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 5)
                                                blnPin1ImageRotated = m_blnRotateImage6Updated;
                                            else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 6)
                                                blnPin1ImageRotated = m_blnRotateImage7Updated;

                                            if (!blnPin1ImageRotated)
                                            {
                                                m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo].CopyTo(ref m_smVisionInfo.g_arrRotatedImages, m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo);
                                            }

                                        }
                                    }

                                    if (blnResultOK && !StartPin1Test_WithOrientation(m_blnAuto))
                                        blnResultOK = false;
                                }
                                else
                                {
                                    // 2020-11-07 ZJYEOH : Pin 1 should wait wait package gauge done if want check package
                                    if (!blnWantOrient && !blnWantMark)
                                    {
                                        if (m_blnWantPackageTest && ((m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailMask & 0x1000) > 0 || m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetWantInspectPackage() || GetWantInspectPackageColor(m_smVisionInfo.g_intSelectedUnit)))
                                        {
                                            if (m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetGrabImageIndex(2) == m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo || m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetGrabImageIndex(3) == m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo)
                                            {
                                                WaitEventDone(ref m_bPackageSizePreTestDone, true, 10000, "UpdateSubProgress_MarkTest > m_bPackageSizePreTestDone 8746");

                                                bool blnPin1ImageRotated = false;
                                                if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 0)
                                                    blnPin1ImageRotated = m_blnRotateImage1Updated;
                                                else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 1)
                                                    blnPin1ImageRotated = m_blnRotateImage2Updated;
                                                else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 2)
                                                    blnPin1ImageRotated = m_blnRotateImage3Updated;
                                                else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 3)
                                                    blnPin1ImageRotated = m_blnRotateImage4Updated;
                                                else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 4)
                                                    blnPin1ImageRotated = m_blnRotateImage5Updated;
                                                else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 5)
                                                    blnPin1ImageRotated = m_blnRotateImage6Updated;
                                                else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 6)
                                                    blnPin1ImageRotated = m_blnRotateImage7Updated;

                                                if (!blnPin1ImageRotated)
                                                {
                                                    if (m_bPackageSizePreTestResult)
                                                    {
                                                        ROI objRotatedROI = new ROI();
                                                        objRotatedROI.AttachImage(m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo]);
                                                        objRotatedROI.LoadROISetting(m_pOrientRotateStartPoint.X, m_pOrientRotateStartPoint.Y, m_pOrientRotateSize.Width, m_pOrientRotateSize.Height);
                                                        ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo], objRotatedROI, m_intOrientAngle + m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle, m_smVisionInfo.g_intRotationInterpolation_Mark, ref m_smVisionInfo.g_arrRotatedImages, m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo);

                                                        if (m_blnCustomWantColor && !GetColorImageRotated(m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo) && !ContainColorSelectedImage(m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo, m_smVisionInfo.g_intSelectedUnit))
                                                        {
                                                            CROI objColorRotatedROI = new CROI();
                                                            objColorRotatedROI.AttachImage(m_smVisionInfo.g_arrColorImages[m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo]);

                                                            // Get RotateROI center point where the ROI center point == Package Unit Center Point
                                                            objColorRotatedROI.LoadROISetting(objRotatedROI.ref_ROIPositionX,
                                                                                         objRotatedROI.ref_ROIPositionY,
                                                                                         objRotatedROI.ref_ROIWidth,
                                                                                         objRotatedROI.ref_ROIHeight);

                                                            CROI.Rotate0Degree(m_smVisionInfo.g_arrColorImages[m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo], objColorRotatedROI, m_intOrientAngle + m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle, 4, ref m_smVisionInfo.g_arrColorRotatedImages, m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo);

                                                            SetColorImageRotated(m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo);
                                                            objColorRotatedROI.Dispose();
                                                        }

                                                        if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 0)
                                                            m_blnRotateImage1Updated = true;
                                                        else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 1)
                                                            m_blnRotateImage2Updated = true;
                                                        else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 2)
                                                            m_blnRotateImage3Updated = true;
                                                        else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 3)
                                                            m_blnRotateImage4Updated = true;
                                                        else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 4)
                                                            m_blnRotateImage5Updated = true;
                                                        else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 5)
                                                            m_blnRotateImage6Updated = true;
                                                        else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 6)
                                                            m_blnRotateImage7Updated = true;
                                                    }
                                                    else
                                                        m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo].CopyTo(ref m_smVisionInfo.g_arrRotatedImages, m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo);
                                                }
                                            }
                                            else
                                            {
                                                if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 0)
                                                    blnResultOK = WaitEventDone(ref m_bGrabImage1Done, true, ref m_bGrabImage1Result, "UpdateSubProgress_MarkTest > m_bGrabImage1Done f");
                                                else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 1)
                                                    blnResultOK = WaitEventDone(ref m_bGrabImage2Done, true, ref m_bGrabImage2Result, "UpdateSubProgress_MarkTest > m_bGrabImage2Done f");
                                                else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 2)
                                                    blnResultOK = WaitEventDone(ref m_bGrabImage3Done, true, ref m_bGrabImage3Result, "UpdateSubProgress_MarkTest > m_bGrabImage3Done f");
                                                else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 3)
                                                    blnResultOK = WaitEventDone(ref m_bGrabImage4Done, true, ref m_bGrabImage4Result, "UpdateSubProgress_MarkTest > m_bGrabImage4Done f");
                                                else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 4)
                                                    blnResultOK = WaitEventDone(ref m_bGrabImage5Done, true, ref m_bGrabImage5Result, "UpdateSubProgress_MarkTest > m_bGrabImage5Done f");
                                                else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 5)
                                                    blnResultOK = WaitEventDone(ref m_bGrabImage6Done, true, ref m_bGrabImage6Result, "UpdateSubProgress_MarkTest > m_bGrabImage6Done f");
                                                else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 6)
                                                    blnResultOK = WaitEventDone(ref m_bGrabImage7Done, true, ref m_bGrabImage7Result, "UpdateSubProgress_MarkTest > m_bGrabImage7Done f");

                                                if (blnResultOK)
                                                {
                                                    bool blnPin1ImageRotated = false;
                                                    if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 0)
                                                        blnPin1ImageRotated = m_blnRotateImage1Updated;
                                                    else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 1)
                                                        blnPin1ImageRotated = m_blnRotateImage2Updated;
                                                    else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 2)
                                                        blnPin1ImageRotated = m_blnRotateImage3Updated;
                                                    else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 3)
                                                        blnPin1ImageRotated = m_blnRotateImage4Updated;
                                                    else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 4)
                                                        blnPin1ImageRotated = m_blnRotateImage5Updated;
                                                    else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 5)
                                                        blnPin1ImageRotated = m_blnRotateImage6Updated;
                                                    else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 6)
                                                        blnPin1ImageRotated = m_blnRotateImage7Updated;

                                                    if (!blnPin1ImageRotated)
                                                    {
                                                        m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo].CopyTo(ref m_smVisionInfo.g_arrRotatedImages, m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo);
                                                    }

                                                }
                                            }
                                        }
                                        else
                                        {
                                            if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 0)
                                                blnResultOK = WaitEventDone(ref m_bGrabImage1Done, true, ref m_bGrabImage1Result, "UpdateSubProgress_MarkTest > m_bGrabImage1Done f");
                                            else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 1)
                                                blnResultOK = WaitEventDone(ref m_bGrabImage2Done, true, ref m_bGrabImage2Result, "UpdateSubProgress_MarkTest > m_bGrabImage2Done f");
                                            else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 2)
                                                blnResultOK = WaitEventDone(ref m_bGrabImage3Done, true, ref m_bGrabImage3Result, "UpdateSubProgress_MarkTest > m_bGrabImage3Done f");
                                            else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 3)
                                                blnResultOK = WaitEventDone(ref m_bGrabImage4Done, true, ref m_bGrabImage4Result, "UpdateSubProgress_MarkTest > m_bGrabImage4Done f");
                                            else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 4)
                                                blnResultOK = WaitEventDone(ref m_bGrabImage5Done, true, ref m_bGrabImage5Result, "UpdateSubProgress_MarkTest > m_bGrabImage5Done f");
                                            else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 5)
                                                blnResultOK = WaitEventDone(ref m_bGrabImage6Done, true, ref m_bGrabImage6Result, "UpdateSubProgress_MarkTest > m_bGrabImage6Done f");
                                            else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 6)
                                                blnResultOK = WaitEventDone(ref m_bGrabImage7Done, true, ref m_bGrabImage7Result, "UpdateSubProgress_MarkTest > m_bGrabImage7Done f");

                                            if (blnResultOK)
                                            {
                                                if (blnWantOrient)
                                                {
                                                    bool blnPin1ImageRotated = false;
                                                    if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 0)
                                                        blnPin1ImageRotated = m_blnRotateImage1Updated;
                                                    else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 1)
                                                        blnPin1ImageRotated = m_blnRotateImage2Updated;
                                                    else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 2)
                                                        blnPin1ImageRotated = m_blnRotateImage3Updated;
                                                    else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 3)
                                                        blnPin1ImageRotated = m_blnRotateImage4Updated;
                                                    else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 4)
                                                        blnPin1ImageRotated = m_blnRotateImage5Updated;
                                                    else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 5)
                                                        blnPin1ImageRotated = m_blnRotateImage6Updated;
                                                    else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 6)
                                                        blnPin1ImageRotated = m_blnRotateImage7Updated;

                                                    if (!blnPin1ImageRotated)//m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo != 0)
                                                    {
                                                        ROI objRotatedROI = new ROI();
                                                        objRotatedROI.AttachImage(m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo]);
                                                        objRotatedROI.LoadROISetting(m_pOrientRotateStartPoint.X, m_pOrientRotateStartPoint.Y, m_pOrientRotateSize.Width, m_pOrientRotateSize.Height);
                                                        ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo], objRotatedROI, m_fOrientTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_Mark, ref m_smVisionInfo.g_arrRotatedImages, m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo);

                                                        if (m_blnCustomWantColor && !GetColorImageRotated(m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo) && !ContainColorSelectedImage(m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo, m_smVisionInfo.g_intSelectedUnit))
                                                        {
                                                            CROI objColorRotatedROI = new CROI();
                                                            objColorRotatedROI.AttachImage(m_smVisionInfo.g_arrColorImages[m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo]);

                                                            // Get RotateROI center point where the ROI center point == Package Unit Center Point
                                                            objColorRotatedROI.LoadROISetting(objRotatedROI.ref_ROIPositionX,
                                                                                         objRotatedROI.ref_ROIPositionY,
                                                                                         objRotatedROI.ref_ROIWidth,
                                                                                         objRotatedROI.ref_ROIHeight);

                                                            CROI.Rotate0Degree(m_smVisionInfo.g_arrColorImages[m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo], objColorRotatedROI, m_fOrientTotalRotateAngle, 4, ref m_smVisionInfo.g_arrColorRotatedImages, m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo);

                                                            SetColorImageRotated(m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo);
                                                            objColorRotatedROI.Dispose();
                                                        }

                                                        if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 0)
                                                            m_blnRotateImage1Updated = true;
                                                        else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 1)
                                                            m_blnRotateImage2Updated = true;
                                                        else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 2)
                                                            m_blnRotateImage3Updated = true;
                                                        else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 3)
                                                            m_blnRotateImage4Updated = true;
                                                        else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 4)
                                                            m_blnRotateImage5Updated = true;
                                                        else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 5)
                                                            m_blnRotateImage6Updated = true;
                                                        else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 6)
                                                            m_blnRotateImage7Updated = true;
                                                    }
                                                }
                                                else
                                                {
                                                    m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo].CopyTo(ref m_smVisionInfo.g_arrRotatedImages, m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo);
                                                }
                                            }
                                        }
                                    }
                                    else
                                    {
                                        if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 0)
                                            blnResultOK = WaitEventDone(ref m_bGrabImage1Done, true, ref m_bGrabImage1Result, "UpdateSubProgress_MarkTest > m_bGrabImage1Done f");
                                        else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 1)
                                            blnResultOK = WaitEventDone(ref m_bGrabImage2Done, true, ref m_bGrabImage2Result, "UpdateSubProgress_MarkTest > m_bGrabImage2Done f");
                                        else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 2)
                                            blnResultOK = WaitEventDone(ref m_bGrabImage3Done, true, ref m_bGrabImage3Result, "UpdateSubProgress_MarkTest > m_bGrabImage3Done f");
                                        else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 3)
                                            blnResultOK = WaitEventDone(ref m_bGrabImage4Done, true, ref m_bGrabImage4Result, "UpdateSubProgress_MarkTest > m_bGrabImage4Done f");
                                        else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 4)
                                            blnResultOK = WaitEventDone(ref m_bGrabImage5Done, true, ref m_bGrabImage5Result, "UpdateSubProgress_MarkTest > m_bGrabImage5Done f");
                                        else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 5)
                                            blnResultOK = WaitEventDone(ref m_bGrabImage6Done, true, ref m_bGrabImage6Result, "UpdateSubProgress_MarkTest > m_bGrabImage6Done f");
                                        else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 6)
                                            blnResultOK = WaitEventDone(ref m_bGrabImage7Done, true, ref m_bGrabImage7Result, "UpdateSubProgress_MarkTest > m_bGrabImage7Done f");

                                        if (blnResultOK)
                                        {
                                            if (blnWantOrient)
                                            {
                                                bool blnPin1ImageRotated = false;
                                                if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 0)
                                                    blnPin1ImageRotated = m_blnRotateImage1Updated;
                                                else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 1)
                                                    blnPin1ImageRotated = m_blnRotateImage2Updated;
                                                else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 2)
                                                    blnPin1ImageRotated = m_blnRotateImage3Updated;
                                                else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 3)
                                                    blnPin1ImageRotated = m_blnRotateImage4Updated;
                                                else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 4)
                                                    blnPin1ImageRotated = m_blnRotateImage5Updated;
                                                else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 5)
                                                    blnPin1ImageRotated = m_blnRotateImage6Updated;
                                                else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 6)
                                                    blnPin1ImageRotated = m_blnRotateImage7Updated;

                                                // 2021 06 02 - CCENG: no need rotate image if already rotate image early.
                                                if (!blnPin1ImageRotated)
                                                {
                                                    if (m_blnWantPackageTest && ((m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailMask & 0x1000) > 0 || m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetWantInspectPackage() || GetWantInspectPackageColor(m_smVisionInfo.g_intSelectedUnit)))
                                                    {
                                                        if (m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetGrabImageIndex(2) == m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo || m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetGrabImageIndex(3) == m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo)
                                                        {
                                                            WaitEventDone(ref m_bPackageSizePreTestDone, true, 10000, "UpdateSubProgress_MarkTest > m_bPackageSizePreTestDone 8746");

                                                            if (m_bPackageSizePreTestResult)
                                                            {
                                                                ROI objRotatedROI = new ROI();
                                                                objRotatedROI.AttachImage(m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo]);
                                                                objRotatedROI.LoadROISetting(m_pOrientRotateStartPoint.X, m_pOrientRotateStartPoint.Y, m_pOrientRotateSize.Width, m_pOrientRotateSize.Height);
                                                                ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo], objRotatedROI, m_intOrientAngle + m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle, m_smVisionInfo.g_intRotationInterpolation_Mark, ref m_smVisionInfo.g_arrRotatedImages, m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo);

                                                                if (m_blnCustomWantColor && !GetColorImageRotated(m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo) && !ContainColorSelectedImage(m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo, m_smVisionInfo.g_intSelectedUnit))
                                                                {
                                                                    CROI objColorRotatedROI = new CROI();
                                                                    objColorRotatedROI.AttachImage(m_smVisionInfo.g_arrColorImages[m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo]);

                                                                    // Get RotateROI center point where the ROI center point == Package Unit Center Point
                                                                    objColorRotatedROI.LoadROISetting(objRotatedROI.ref_ROIPositionX,
                                                                                                 objRotatedROI.ref_ROIPositionY,
                                                                                                 objRotatedROI.ref_ROIWidth,
                                                                                                 objRotatedROI.ref_ROIHeight);

                                                                    CROI.Rotate0Degree(m_smVisionInfo.g_arrColorImages[m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo], objColorRotatedROI, m_intOrientAngle + m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle, 4, ref m_smVisionInfo.g_arrColorRotatedImages, m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo);

                                                                    SetColorImageRotated(m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo);
                                                                    objColorRotatedROI.Dispose();
                                                                }

                                                                if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 0)
                                                                    m_blnRotateImage1Updated = true;
                                                                else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 1)
                                                                    m_blnRotateImage2Updated = true;
                                                                else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 2)
                                                                    m_blnRotateImage3Updated = true;
                                                                else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 3)
                                                                    m_blnRotateImage4Updated = true;
                                                                else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 4)
                                                                    m_blnRotateImage5Updated = true;
                                                                else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 5)
                                                                    m_blnRotateImage6Updated = true;
                                                                else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 6)
                                                                    m_blnRotateImage7Updated = true;

                                                            }
                                                            else
                                                                m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo].CopyTo(ref m_smVisionInfo.g_arrRotatedImages, m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo);
                                                        }
                                                        else
                                                        {
                                                            m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo].CopyTo(ref m_smVisionInfo.g_arrRotatedImages, m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo);
                                                        }
                                                    }
                                                    else
                                                    {
                                                        ROI objRotatedROI = new ROI();
                                                        objRotatedROI.AttachImage(m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo]);
                                                        objRotatedROI.LoadROISetting(m_pOrientRotateStartPoint.X, m_pOrientRotateStartPoint.Y, m_pOrientRotateSize.Width, m_pOrientRotateSize.Height);

                                                        // 2021 06 02 - Use OrientAngle (0,90,180,270) + pacakge gauge angle, NOT using Orient Angle + mark angle.
                                                        //            - bcos image 1 has been rotated during orient mark test with Orient Angle + package gauge angle before pin 1 test. 
                                                        //            - However pin 1 score may not so good if using OrientAngle + Package gauge angle if the pin 1 is attach with mark.
                                                        //            - If pin 1 attach to package itself, then using OrientAngle + package gauge angle is good.
                                                        float fTotalRotateAngle = m_intOrientAngle + m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle;
                                                        //ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo], objRotatedROI, m_fOrientTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_Mark, ref m_smVisionInfo.g_arrRotatedImages, m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo);
                                                        ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo], objRotatedROI, fTotalRotateAngle, m_smVisionInfo.g_intRotationInterpolation_Mark, ref m_smVisionInfo.g_arrRotatedImages, m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo);

                                                        if (m_blnCustomWantColor && !GetColorImageRotated(m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo) && !ContainColorSelectedImage(m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo, m_smVisionInfo.g_intSelectedUnit))
                                                        {
                                                            CROI objColorRotatedROI = new CROI();
                                                            objColorRotatedROI.AttachImage(m_smVisionInfo.g_arrColorImages[m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo]);

                                                            // Get RotateROI center point where the ROI center point == Package Unit Center Point
                                                            objColorRotatedROI.LoadROISetting(objRotatedROI.ref_ROIPositionX,
                                                                                         objRotatedROI.ref_ROIPositionY,
                                                                                         objRotatedROI.ref_ROIWidth,
                                                                                         objRotatedROI.ref_ROIHeight);

                                                            CROI.Rotate0Degree(m_smVisionInfo.g_arrColorImages[m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo], objColorRotatedROI, fTotalRotateAngle, 4, ref m_smVisionInfo.g_arrColorRotatedImages, m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo);

                                                            SetColorImageRotated(m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo);
                                                            objColorRotatedROI.Dispose();
                                                        }

                                                        if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 0)
                                                            m_blnRotateImage1Updated = true;
                                                        else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 1)
                                                            m_blnRotateImage2Updated = true;
                                                        else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 2)
                                                            m_blnRotateImage3Updated = true;
                                                        else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 3)
                                                            m_blnRotateImage4Updated = true;
                                                        else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 4)
                                                            m_blnRotateImage5Updated = true;
                                                        else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 5)
                                                            m_blnRotateImage6Updated = true;
                                                        else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 6)
                                                            m_blnRotateImage7Updated = true;
                                                    }
                                                }
                                            }
                                            else
                                            {
                                                if (m_blnWantPackageTest && ((m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailMask & 0x1000) > 0 || m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetWantInspectPackage() || GetWantInspectPackageColor(m_smVisionInfo.g_intSelectedUnit)))
                                                {
                                                    if (m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetGrabImageIndex(2) == m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo || m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetGrabImageIndex(3) == m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo)
                                                    {
                                                        WaitEventDone(ref m_bPackageSizePreTestDone, true, 10000, "UpdateSubProgress_MarkTest > m_bPackageSizePreTestDone 8746");

                                                        if (m_bPackageSizePreTestResult)
                                                        {
                                                            bool blnPin1ImageRotated = false;
                                                            if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 0)
                                                                blnPin1ImageRotated = m_blnRotateImage1Updated;
                                                            else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 1)
                                                                blnPin1ImageRotated = m_blnRotateImage2Updated;
                                                            else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 2)
                                                                blnPin1ImageRotated = m_blnRotateImage3Updated;
                                                            else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 3)
                                                                blnPin1ImageRotated = m_blnRotateImage4Updated;
                                                            else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 4)
                                                                blnPin1ImageRotated = m_blnRotateImage5Updated;
                                                            else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 5)
                                                                blnPin1ImageRotated = m_blnRotateImage6Updated;
                                                            else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 6)
                                                                blnPin1ImageRotated = m_blnRotateImage7Updated;

                                                            if (!blnPin1ImageRotated)
                                                            {
                                                                ROI objRotatedROI = new ROI();
                                                                objRotatedROI.AttachImage(m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo]);
                                                                objRotatedROI.LoadROISetting(m_pOrientRotateStartPoint.X, m_pOrientRotateStartPoint.Y, m_pOrientRotateSize.Width, m_pOrientRotateSize.Height);
                                                                ROI.Rotate0Degree(m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo], objRotatedROI, m_intOrientAngle + m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle, m_smVisionInfo.g_intRotationInterpolation_Mark, ref m_smVisionInfo.g_arrRotatedImages, m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo);

                                                                if (m_blnCustomWantColor && !GetColorImageRotated(m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo) && !ContainColorSelectedImage(m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo, m_smVisionInfo.g_intSelectedUnit))
                                                                {
                                                                    CROI objColorRotatedROI = new CROI();
                                                                    objColorRotatedROI.AttachImage(m_smVisionInfo.g_arrColorImages[m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo]);

                                                                    // Get RotateROI center point where the ROI center point == Package Unit Center Point
                                                                    objColorRotatedROI.LoadROISetting(objRotatedROI.ref_ROIPositionX,
                                                                                                 objRotatedROI.ref_ROIPositionY,
                                                                                                 objRotatedROI.ref_ROIWidth,
                                                                                                 objRotatedROI.ref_ROIHeight);

                                                                    CROI.Rotate0Degree(m_smVisionInfo.g_arrColorImages[m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo], objColorRotatedROI, m_intOrientAngle + m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle, 4, ref m_smVisionInfo.g_arrColorRotatedImages, m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo);

                                                                    SetColorImageRotated(m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo);
                                                                    objColorRotatedROI.Dispose();
                                                                }

                                                                if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 0)
                                                                    m_blnRotateImage1Updated = true;
                                                                else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 1)
                                                                    m_blnRotateImage2Updated = true;
                                                                else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 2)
                                                                    m_blnRotateImage3Updated = true;
                                                                else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 3)
                                                                    m_blnRotateImage4Updated = true;
                                                                else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 4)
                                                                    m_blnRotateImage5Updated = true;
                                                                else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 5)
                                                                    m_blnRotateImage6Updated = true;
                                                                else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 6)
                                                                    m_blnRotateImage7Updated = true;
                                                            }
                                                        }
                                                        else
                                                        {
                                                            if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 0)
                                                                blnResultOK = WaitEventDone(ref m_bGrabImage1Done, true, ref m_bGrabImage1Result, "UpdateSubProgress_MarkTest > m_bGrabImage1Done f");
                                                            else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 1)
                                                                blnResultOK = WaitEventDone(ref m_bGrabImage2Done, true, ref m_bGrabImage2Result, "UpdateSubProgress_MarkTest > m_bGrabImage2Done f");
                                                            else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 2)
                                                                blnResultOK = WaitEventDone(ref m_bGrabImage3Done, true, ref m_bGrabImage3Result, "UpdateSubProgress_MarkTest > m_bGrabImage3Done f");
                                                            else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 3)
                                                                blnResultOK = WaitEventDone(ref m_bGrabImage4Done, true, ref m_bGrabImage4Result, "UpdateSubProgress_MarkTest > m_bGrabImage4Done f");
                                                            else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 4)
                                                                blnResultOK = WaitEventDone(ref m_bGrabImage5Done, true, ref m_bGrabImage5Result, "UpdateSubProgress_MarkTest > m_bGrabImage5Done f");
                                                            else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 5)
                                                                blnResultOK = WaitEventDone(ref m_bGrabImage6Done, true, ref m_bGrabImage6Result, "UpdateSubProgress_MarkTest > m_bGrabImage6Done f");
                                                            else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 6)
                                                                blnResultOK = WaitEventDone(ref m_bGrabImage7Done, true, ref m_bGrabImage7Result, "UpdateSubProgress_MarkTest > m_bGrabImage7Done f");

                                                            if (blnResultOK)
                                                            {
                                                                bool blnPin1ImageRotated = false;
                                                                if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 0)
                                                                    blnPin1ImageRotated = m_blnRotateImage1Updated;
                                                                else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 1)
                                                                    blnPin1ImageRotated = m_blnRotateImage2Updated;
                                                                else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 2)
                                                                    blnPin1ImageRotated = m_blnRotateImage3Updated;
                                                                else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 3)
                                                                    blnPin1ImageRotated = m_blnRotateImage4Updated;
                                                                else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 4)
                                                                    blnPin1ImageRotated = m_blnRotateImage5Updated;
                                                                else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 5)
                                                                    blnPin1ImageRotated = m_blnRotateImage6Updated;
                                                                else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 6)
                                                                    blnPin1ImageRotated = m_blnRotateImage7Updated;

                                                                if (!blnPin1ImageRotated)
                                                                {
                                                                    m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo].CopyTo(ref m_smVisionInfo.g_arrRotatedImages, m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo);
                                                                }

                                                            }
                                                        }
                                                    }
                                                    else
                                                    {
                                                        if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 0)
                                                            blnResultOK = WaitEventDone(ref m_bGrabImage1Done, true, ref m_bGrabImage1Result, "UpdateSubProgress_MarkTest > m_bGrabImage1Done f");
                                                        else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 1)
                                                            blnResultOK = WaitEventDone(ref m_bGrabImage2Done, true, ref m_bGrabImage2Result, "UpdateSubProgress_MarkTest > m_bGrabImage2Done f");
                                                        else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 2)
                                                            blnResultOK = WaitEventDone(ref m_bGrabImage3Done, true, ref m_bGrabImage3Result, "UpdateSubProgress_MarkTest > m_bGrabImage3Done f");
                                                        else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 3)
                                                            blnResultOK = WaitEventDone(ref m_bGrabImage4Done, true, ref m_bGrabImage4Result, "UpdateSubProgress_MarkTest > m_bGrabImage4Done f");
                                                        else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 4)
                                                            blnResultOK = WaitEventDone(ref m_bGrabImage5Done, true, ref m_bGrabImage5Result, "UpdateSubProgress_MarkTest > m_bGrabImage5Done f");
                                                        else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 5)
                                                            blnResultOK = WaitEventDone(ref m_bGrabImage6Done, true, ref m_bGrabImage6Result, "UpdateSubProgress_MarkTest > m_bGrabImage6Done f");
                                                        else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 6)
                                                            blnResultOK = WaitEventDone(ref m_bGrabImage7Done, true, ref m_bGrabImage7Result, "UpdateSubProgress_MarkTest > m_bGrabImage7Done f");

                                                        if (blnResultOK)
                                                        {
                                                            bool blnPin1ImageRotated = false;
                                                            if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 0)
                                                                blnPin1ImageRotated = m_blnRotateImage1Updated;
                                                            else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 1)
                                                                blnPin1ImageRotated = m_blnRotateImage2Updated;
                                                            else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 2)
                                                                blnPin1ImageRotated = m_blnRotateImage3Updated;
                                                            else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 3)
                                                                blnPin1ImageRotated = m_blnRotateImage4Updated;
                                                            else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 4)
                                                                blnPin1ImageRotated = m_blnRotateImage5Updated;
                                                            else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 5)
                                                                blnPin1ImageRotated = m_blnRotateImage6Updated;
                                                            else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 6)
                                                                blnPin1ImageRotated = m_blnRotateImage7Updated;

                                                            if (!blnPin1ImageRotated)
                                                            {
                                                                m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo].CopyTo(ref m_smVisionInfo.g_arrRotatedImages, m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo);
                                                            }

                                                        }
                                                    }
                                                }
                                                else
                                                {
                                                    bool blnPin1ImageRotated = false;
                                                    if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 0)
                                                        blnPin1ImageRotated = m_blnRotateImage1Updated;
                                                    else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 1)
                                                        blnPin1ImageRotated = m_blnRotateImage2Updated;
                                                    else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 2)
                                                        blnPin1ImageRotated = m_blnRotateImage3Updated;
                                                    else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 3)
                                                        blnPin1ImageRotated = m_blnRotateImage4Updated;
                                                    else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 4)
                                                        blnPin1ImageRotated = m_blnRotateImage5Updated;
                                                    else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 5)
                                                        blnPin1ImageRotated = m_blnRotateImage6Updated;
                                                    else if (m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo == 6)
                                                        blnPin1ImageRotated = m_blnRotateImage7Updated;

                                                    if (!blnPin1ImageRotated)
                                                    {
                                                        m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo].CopyTo(ref m_smVisionInfo.g_arrRotatedImages, m_smVisionInfo.g_arrMarks[0].ref_intPin1ImageNo);
                                                    }
                                                }
                                            }
                                        }
                                    }

                                    if (m_smVisionInfo.g_arrPin1[0].getWantCheckPin1(m_smVisionInfo.g_intSelectedTemplate)) // 12-07-2019 ZJYEOH : if inspection option there got tick, then just check pin 1
                                    {
                                        if (blnResultOK && !StartPin1Test(m_blnAuto))
                                            blnResultOK = false;
                                    }
                                }
                            }
                        }

                        m_blnOrientDataUpdated = true;// Set to true so that WaitEvent Loop can be break

                        // ------------------ 2D Code Test ----------------------------------------------------------
                        if ((m_smCustomizeInfo.g_intWant2DCode & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
                        {
                            if (m_smVisionInfo.g_blnWantMark2DCode)
                            {
                                if (blnResultOK && !StartMark2DCodeTest_using4LGauge(m_blnAuto))
                                    blnResultOK = false;
                            }
                        }

                        // ------------------ Mark Test ----------------------------------------------------------
                        if (blnWantMark || ShowLiterationOnly)
                        {
                            if (((m_smCustomizeInfo.g_intWantMark & (1 << m_smVisionInfo.g_intVisionPos)) > 0) && ((m_smCustomizeInfo.g_intWantOCR & (1 << m_smVisionInfo.g_intVisionPos)) == 0) && 
                                (((m_smCustomizeInfo.g_intWantOCR2 & (1 << m_smVisionInfo.g_intVisionPos)) == 0) || (((m_smCustomizeInfo.g_intWantOCR2 & (1 << m_smVisionInfo.g_intVisionPos)) > 0) && m_smVisionInfo.g_blnUseOCRandOCV)))
                            {
                                // 2020 04 15 - JBTAN: will continue to check mark even option uncheck check mark option
                                // Checking Mark
                                //if (blnWantMark && blnResultOK)
                                if (blnResultOK)
                                {
                                    //if (!StartMarkTest_using4LGauge(m_blnAuto))       // Mark OCV Test
                                    if (!StartMarkTest_using4LGauge_OcvAngleAndPackageAngle(m_blnAuto))       // Mark OCV Test With Ocv Angle and Package Angle Separated
                                    {
                                        // 2020 04 15 - JBTAN: check mark option enable only will set result fail
                                        if (blnWantMark)
                                            blnResultOK = false;
                                    }
                                }
                            }
                            else if ((m_smCustomizeInfo.g_intWantOCR & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
                            {
                                // 2020 04 15 - JBTAN: will continue to check mark even option uncheck check mark option
                                // Checking Mark OCR
                                //if (blnWantMark && blnResultOK)
                                if (blnResultOK)
                                {
                                    if (!StartMarkOCRTest(m_blnAuto))   // Mark OCR Test
                                    {
                                        // 2020 04 15 - JBTAN: check mark option enable only will set result fail
                                        if (blnWantMark)
                                            blnResultOK = false;
                                    }
                                }
                            }

                            if ((m_smCustomizeInfo.g_intWantOCR2 & (1 << m_smVisionInfo.g_intVisionPos)) > 0 && (m_smVisionInfo.g_blnUseOCR || m_smVisionInfo.g_blnUseOCRandOCV))
                            {
                                // 2020 04 15 - JBTAN: will continue to check mark even option uncheck check mark option
                                // Checking Mark OCR
                                //if (blnWantMark && blnResultOK)
                                if (!StartMarkOCR2Test(m_blnAuto))   // Mark OCR Test
                                {
                                    // 2020 04 15 - JBTAN: check mark option enable only will set result fail
                                    if (blnWantMark)
                                        blnResultOK = false;
                                }
                            }
                        }

                        m_bSubTh_MarkTest_Result = blnResultOK;

                        m_bSubTh_MarkTest = false;
                    }
                }
                catch (Exception ex)
                {
                    m_bSubTh_MarkTest = false;

                    SRMMessageBox.Show("Vision1Process->UpdateSubProgress_MarkTest() :" + ex.ToString());
                }
                Thread.Sleep(1);
            }

            m_thSubThread_MarkTest = null;
            m_blnStopped_MarkTest = true;
        }

        private void UpdateSubProgress_PackageTest_MarkLightView()
        {
            while (!m_blnStopping)
            {

                try
                {
                    if (m_bSubTh_PackageTest_MarkLightView)
                    {
                        m_bSubTh_PackageTest_MarkLightView_Result = false;

                        bool blnResultOK = true;

                        // ------------ Package Size Test ------------------------------------------------
                        if (!StartPackageSizeTest(m_blnAuto))
                        {
                            //if (m_bSubTh_MarkTest_Result)
                            {
                                blnResultOK = false;
                                m_eInspectionResult_PackageTest_Size = ResulType.FailPackageSize;
                                m_bSubTh_PackageTest_PackageSize_Result = false;
                            }

                            m_bPackageSizeTestDone = true;
                        }
                        else
                        {
                            if (blnResultOK)
                            {
                                m_eInspectionResult_PackageTest_Size = ResulType.Pass;
                                m_bSubTh_PackageTest_PackageSize_Result = true;
                                m_bPackageSizeTestDone = true;
                            }

                            // -------- Check Mark Text Shifted ----------------------------
                            // 2019 07 21 - When no gauge during mark test, it is not possible to check Mark Texted Shifted.
                            //            - So need to rely on Package Size result to check Mark Text Shifted.
                            //if (!m_smVisionInfo.g_blnWantGauge)
                            //{
                            //    // 2020 04 25 - CCENG: Need to make sure mark test done before call WantCheckMarkTextShifted(). Bcos WantCheckMarkTextShifted() relay on final m_intTemplateIndex value from mark test.
                            //    WaitEventDone(ref m_bSubTh_MarkTest, false); // wait mark test done first.

                            //    bool blnWantCheckMarkTextShifted = false;
                            //    if (m_smVisionInfo.g_arrMarks != null && m_smVisionInfo.g_arrMarks.Count > 0)
                            //    {
                            //        blnWantCheckMarkTextShifted = m_smVisionInfo.g_arrMarks[0].ref_blnCheckMark && m_smVisionInfo.g_arrMarks[0].WantCheckMarkTextShifted();
                            //    }

                            //    if (blnWantCheckMarkTextShifted)
                            //    {
                            //        WaitEventDone(ref m_bSubTh_MarkTest, false); // wait mark test done first.

                            //        if (m_bSubTh_MarkTest_Result && m_bPackageSizePreTestResult) // Only need to check text shifted if mark result pass, and package size inspection pass
                            //        {
                            //            if (!m_smVisionInfo.g_arrMarks[0].CheckTextShifted2(
                            //                (int)Math.Round(m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_fPackageResultCenterX - m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_fPackageResultWidth_px / 2, 0, MidpointRounding.AwayFromZero),
                            //                (int)Math.Round(m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_fPackageResultCenterY - m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_fPackageResultHeight_px / 2, 0, MidpointRounding.AwayFromZero),
                            //                (int)Math.Round(m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_fPackageResultCenterX + m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_fPackageResultWidth_px / 2, 0, MidpointRounding.AwayFromZero),
                            //                (int)Math.Round(m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_fPackageResultCenterY + m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_fPackageResultHeight_px / 2, 0, MidpointRounding.AwayFromZero)))
                            //            {
                            //                m_smVisionInfo.g_strErrorMessage += "*Mark Shifted";
                            //                if (m_blnAuto)
                            //                {
                            //                    m_smVisionInfo.g_intPkgDefectFailureTotal++;
                            //                    SaveRejectImage_AddToBuffer("TextShifted", m_smVisionInfo.g_strErrorMessage);
                            //                }
                            //                m_eInspectionResult_PackageTest_Size = ResulType.FailPackageSize;
                            //                m_bSubTh_PackageTest_PackageSize_Result = false;
                            //                m_bPackageSizeTestDone = true;
                            //                blnResultOK = false;
                            //            }
                            //        }
                            //    }
                            //}
                            // --------------- End Check Mark Text Shifted ---------------------------------------------

                            //RecordGRR2(); // 06-03-2019 ZJYEOH : Temporary remove

                            //if (blnResultOK)
                            //{
                            //    m_eInspectionResult_PackageTest_Size = ResulType.Pass;
                            //    m_bSubTh_PackageTest_PackageSize_Result = true;
                            //    m_bPackageSizeTestDone = true;
                            //}
                        }

                        // 2020-04-28 ZJYEOH : Record Package Size Result
                        if (m_blnAuto && m_smVisionInfo.g_blnWantRecordResult && ((m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailMask & 0x1000) > 0) && (m_smVisionInfo.g_intTestedTotal <= m_smVisionInfo.g_intResultLogMaxCount))
                        {
                            string strLotSaveResultLogPath;
                            string strVisionResultLogFileName;
                            string strPath;
                            if (m_smVisionInfo.g_intVisionResetCount == 0)
                            {
                                strLotSaveResultLogPath = m_smProductionInfo.g_strHistoryDataLocation + "ResultLog\\" + m_smProductionInfo.g_strLotID + "_" + m_smProductionInfo.g_strLotStartTime;
                                strVisionResultLogFileName = m_smVisionInfo.g_strVisionFolderName + "(" + m_smVisionInfo.g_strVisionDisplayName + " " + m_smVisionInfo.g_strVisionNameRemark + ")" + "_" + m_smProductionInfo.g_strLotStartTime;

                                if (!Directory.Exists(strLotSaveResultLogPath))
                                    Directory.CreateDirectory(strLotSaveResultLogPath);

                                strPath = strLotSaveResultLogPath + "\\" + strVisionResultLogFileName + ".txt";
                            }
                            else
                            {
                                strLotSaveResultLogPath = m_smProductionInfo.g_strHistoryDataLocation + "ResultLog\\" + m_smProductionInfo.g_strLotID + "_" + m_smProductionInfo.g_strLotStartTime;
                                strVisionResultLogFileName = m_smVisionInfo.g_strVisionFolderName + "(" + m_smVisionInfo.g_strVisionDisplayName + " " + m_smVisionInfo.g_strVisionNameRemark + ")" + "_" + m_smVisionInfo.g_strVisionResetCountTime;

                                if (!Directory.Exists(strLotSaveResultLogPath))
                                    Directory.CreateDirectory(strLotSaveResultLogPath);

                                strPath = strLotSaveResultLogPath + "\\" + strVisionResultLogFileName + ".txt";
                            }

                            STTrackLog.WriteLine_ForResultLog(strLotSaveResultLogPath, strVisionResultLogFileName,// "Number=" + (lines.Count + 1).ToString() + "," +
                                          "Date Time=" + DateTime.Now.ToString() + "," +
                                          "Package Width=" + m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_fUnitResultWidth.ToString() + "," +
                                          "Package Height=" + m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_fUnitResultHeight.ToString());
                        }

                        // ------------- Package Defect Test on Mark Light View -------------------------
                        WaitEventDone(ref m_bGrabImage1Done, true, 10000, "UpdateSubProgress_PackageTest_MarkLightView > m_bGrabImage1Done 8941");
                        WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "UpdateSubProgress_PackageTest_MarkLightView > m_bSubTh_MarkTest 8942");

                        if (m_bPackageSizeTestDone && m_bSubTh_PackageTest_PackageSize_Result && m_bSubTh_MarkTest_Result)
                        {
                            //2021-06-29 ZJYEOH : Color Inspection will have another thread
                            if (false)//m_smVisionInfo.g_blnViewColorImage
                            {
                                if (!StartColorPackageTest(m_blnAuto))
                                    blnResultOK = false;
                            }
                            else
                            {

                                if (!StartPackageTest_MarkLightView(m_blnAuto))
                                    blnResultOK = false;
                            }
                        }

                        m_bSubTh_PackageTest_MarkLightView_Result = blnResultOK;

                        // -----------------------------------------------------------------------------

                        m_bSubTh_PackageTest_MarkLightView = false;
                    }
                }
                catch (Exception ex)
                {
                    m_bSubTh_PackageTest_MarkLightView = false;

                    SRMMessageBox.Show("Vision1Process->UpdateSubProgress_PackageTest_MarkLightView() :" + ex.ToString());
                }
                Thread.Sleep(1);
            }

            m_thSubThread_PackageTest_MarkLightView = null;
            m_blnStopped_PackageTest_MarkLightView = true;
        }

        private void UpdateSubProgress_PackageTest_SideLightView()
        {
            while (!m_blnStopping)
            {

                try
                {
                    if (m_bSubTh_PackageTest_SideLightView)
                    {
                        m_bSubTh_PackageTest_SideLightView_Result = false;

                        bool blnResultOK = true;

                        WaitEventDone(ref m_bPackageSizeTestDone, true, 10000, "UpdateSubProgress_PackageTest_SideLightView > m_bPackageSizeTestDone 8992");

                        // ------------- Package Defect Test on Side Light View -------------------------
                        if (m_bSubTh_PackageTest_PackageSize_Result)
                        {
                            //2021-06-29 ZJYEOH : Color Inspection will have another thread
                            if (false)//m_smVisionInfo.g_blnViewColorImage
                            {
                                if (!StartColorPackageTest(m_blnAuto))
                                    blnResultOK = false;
                            }
                            else
                            {

                                if (!StartPackageTest_SideLightView(m_blnAuto))
                                    blnResultOK = false;
                            }
                        }

                        m_bSubTh_PackageTest_SideLightView_Result = blnResultOK;

                        // -----------------------------------------------------------------------------

                        m_bSubTh_PackageTest_SideLightView = false;
                    }
                }
                catch (Exception ex)
                {
                    m_bSubTh_PackageTest_SideLightView = false;

                    SRMMessageBox.Show("Vision1Process->UpdateSubProgress_PackageTest_SideLightView() :" + ex.ToString());
                }
                Thread.Sleep(1);
            }

            m_thSubThread_PackageTest_SideLightView = null;
            m_blnStopped_PackageTest_SideLightView = true;
        }

        private void UpdateSubProgress_PackageTest_TopLightView()
        {
            while (!m_blnStopping)
            {

                try
                {
                    if (m_bSubTh_PackageTest_TopLightView)
                    {
                        m_bSubTh_PackageTest_TopLightView_Result = false;

                        bool blnResultOK = true;

                        WaitEventDone(ref m_bPackageSizeTestDone, true, 10000, "UpdateSubProgress_PackageTest_TopLightView > m_bPackageSizeTestDone 9043");

                        // ------------- Package Defect Test on Top Light View -------------------------
                        if (m_bSubTh_PackageTest_PackageSize_Result)
                        {
                            //2021-06-29 ZJYEOH : Color Inspection will have another thread
                            if (false)//m_smVisionInfo.g_blnViewColorImage
                            {
                                if (!StartColorPackageTest(m_blnAuto))
                                    blnResultOK = false;
                            }
                            else
                            {

                                if (!StartPackageTest_TopLightView(m_blnAuto))
                                    blnResultOK = false;
                            }
                        }
                        else
                        {

                        }

                        m_bSubTh_PackageTest_TopLightView_Result = blnResultOK;

                        m_bSubTh_PackageTest_TopLightView = false;
                    }
                }
                catch (Exception ex)
                {
                    m_bSubTh_PackageTest_TopLightView = false;

                    SRMMessageBox.Show("Vision1Process->UpdateSubProgress_PackageTest_TopLightView() :" + ex.ToString());
                }
                Thread.Sleep(1);
            }

            m_thSubThread_PackageTest_TopLightView = null;
            m_blnStopped_PackageTest_TopLightView = true;
        }

        private void UpdateSubProgress_LeadTest()
        {
            while (!m_blnStopping)
            {

                try
                {
                    if (m_bSubTh_LeadTest)
                    {
                        m_bSubTh_LeadTest_Result = false;

                        //WaitEventDone(ref m_bGrabImage1Done, true);
                        bool blnResultOK = true;

                        // STTrackLog.WriteLine("start wait grab image result");
                        if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 0)
                            blnResultOK = WaitEventDone(ref m_bGrabImage1Done, true, ref m_bGrabImage1Result, "UpdateSubProgress_LeadTest > m_bGrabImage1Done f");
                        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 1)
                            blnResultOK = WaitEventDone(ref m_bGrabImage2Done, true, ref m_bGrabImage2Result, "UpdateSubProgress_LeadTest > m_bGrabImage2Done f");
                        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 2)
                            blnResultOK = WaitEventDone(ref m_bGrabImage3Done, true, ref m_bGrabImage3Result, "UpdateSubProgress_LeadTest > m_bGrabImage3Done f");
                        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 3)
                            blnResultOK = WaitEventDone(ref m_bGrabImage4Done, true, ref m_bGrabImage4Result, "UpdateSubProgress_LeadTest > m_bGrabImage4Done f");
                        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 4)
                            blnResultOK = WaitEventDone(ref m_bGrabImage5Done, true, ref m_bGrabImage5Result, "UpdateSubProgress_LeadTest > m_bGrabImage5Done f");
                        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 5)
                            blnResultOK = WaitEventDone(ref m_bGrabImage6Done, true, ref m_bGrabImage6Result, "UpdateSubProgress_LeadTest > m_bGrabImage6Done f");
                        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 6)
                            blnResultOK = WaitEventDone(ref m_bGrabImage7Done, true, ref m_bGrabImage7Result, "UpdateSubProgress_LeadTest > m_bGrabImage7Done f");

                        if (m_smVisionInfo.g_arrLead[0].ref_blnWantInspectBaseLead && (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo != m_smVisionInfo.g_arrLead[0].ref_intImageViewNo))
                        {
                            // Wait base lead image (default is image 3) grap done
                            if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 0)
                                blnResultOK = WaitEventDone(ref m_bGrabImage1Done, true, ref m_bGrabImage1Result, "AAA87 1");
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 1)
                                blnResultOK = WaitEventDone(ref m_bGrabImage2Done, true, ref m_bGrabImage2Result, "AAA87 2");
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 2)
                                blnResultOK = WaitEventDone(ref m_bGrabImage3Done, true, ref m_bGrabImage3Result, "AAA87 3");
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 3)
                                blnResultOK = WaitEventDone(ref m_bGrabImage4Done, true, ref m_bGrabImage4Result, "AAA87 4");
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 4)
                                blnResultOK = WaitEventDone(ref m_bGrabImage5Done, true, ref m_bGrabImage5Result, "AAA87 5");
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 5)
                                blnResultOK = WaitEventDone(ref m_bGrabImage6Done, true, ref m_bGrabImage6Result, "AAA87 6");
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 6)
                                blnResultOK = WaitEventDone(ref m_bGrabImage7Done, true, ref m_bGrabImage7Result, "AAA87 7");
                        }

                        //STTrackLog.WriteLine("Get image result = " + blnResultOK.ToString());

                        //AttachImageToROI();
                        if ((m_smCustomizeInfo.g_intWantLead & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
                        {
                            if (m_smVisionInfo.g_objLeadImage == null)
                                m_smVisionInfo.g_objLeadImage = new ImageDrawing(true);

                            m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo].CopyTo(ref m_smVisionInfo.g_objLeadImage);
                            m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo].CopyTo(ref m_smVisionInfo.g_arrRotatedImages, m_smVisionInfo.g_arrLead[0].ref_intImageViewNo);
                            if (m_smVisionInfo.g_arrLead[0].ref_blnWantInspectBaseLead)
                                m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo].CopyTo(ref m_smVisionInfo.g_arrRotatedImages, m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo);
                            AttachToROI(m_smVisionInfo.g_arrLeadROIs, m_smVisionInfo.g_objLeadImage);
                            //AttachToROI(m_smVisionInfo.g_arrLeadROIs, m_smVisionInfo.g_arrImages, m_smVisionInfo.g_arrLead[0].ref_intImageViewNo);
                        }

                        bool blnWantLead = false;
                        if (m_smVisionInfo.g_arrLead != null && m_smVisionInfo.g_arrLead.Length > 0)
                        {
                            blnWantLead = m_smVisionInfo.g_arrLead[0].GetWantInspectLead();// m_smVisionInfo.g_blnCheckLead;
                        }
                        
                        // ------------------ Lead Test ----------------------------------------------------------
                        if (blnWantLead)
                        {
                            if ((m_smCustomizeInfo.g_intWantLead & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
                            {
                                // Checking Lead
                                if (blnWantLead && blnResultOK)
                                {
                                    if (!StartLeadTest_MultiThreading(m_blnAuto))
                                    {
                                        blnResultOK = false;
                                    }
                                }
                            }

                        }

                        m_bLeadBaseCenterPointDone = true;

                        m_bSubTh_LeadTest_Result = blnResultOK;

                        m_bSubTh_LeadTest = false;
                    }
                }
                catch (Exception ex)
                {
                    m_bSubTh_LeadTest = false;

                    SRMMessageBox.Show("Vision1Process->UpdateSubProgress_LeadTest() :" + ex.ToString());
                }
                Thread.Sleep(1);
            }

            m_thSubThread_LeadTest = null;
            m_blnStopped_LeadTest = true;
        }
        private void UpdateSubProgress_PackageColorTest()
        {
            while (!m_blnStopping)
            {

                try
                {
                    if (m_bSubTh_PackageColorTest)
                    {
                        m_bSubTh_PackageColorTest_Result = false;

                        //WaitEventDone(ref m_bGrabImage1Done, true);
                        bool blnResultOK = true;

                        if (m_smVisionInfo.g_blnCheckPackageColor)
                        {
                            // STTrackLog.WriteLine("start wait grab image result");
                            List<int> arrColorSelectedImage = GetColorSelectedImage(m_smVisionInfo.g_intSelectedUnit);
                            if (arrColorSelectedImage.Contains(0))
                                blnResultOK = WaitEventDone(ref m_bGrabImage1Done, true, ref m_bGrabImage1Result, "UpdateSubProgress_PackageColorTest > m_bGrabImage1Done f");
                            if (arrColorSelectedImage.Contains(1))
                                blnResultOK = WaitEventDone(ref m_bGrabImage2Done, true, ref m_bGrabImage2Result, "UpdateSubProgress_PackageColorTest > m_bGrabImage2Done f");
                            if (arrColorSelectedImage.Contains(2))
                                blnResultOK = WaitEventDone(ref m_bGrabImage3Done, true, ref m_bGrabImage3Result, "UpdateSubProgress_PackageColorTest > m_bGrabImage3Done f");
                            if (arrColorSelectedImage.Contains(3))
                                blnResultOK = WaitEventDone(ref m_bGrabImage4Done, true, ref m_bGrabImage4Result, "UpdateSubProgress_PackageColorTest > m_bGrabImage4Done f");
                            if (arrColorSelectedImage.Contains(4))
                                blnResultOK = WaitEventDone(ref m_bGrabImage5Done, true, ref m_bGrabImage5Result, "UpdateSubProgress_PackageColorTest > m_bGrabImage5Done f");
                            if (arrColorSelectedImage.Contains(5))
                                blnResultOK = WaitEventDone(ref m_bGrabImage6Done, true, ref m_bGrabImage6Result, "UpdateSubProgress_PackageColorTest > m_bGrabImage6Done f");
                            if (arrColorSelectedImage.Contains(6))
                                blnResultOK = WaitEventDone(ref m_bGrabImage7Done, true, ref m_bGrabImage7Result, "UpdateSubProgress_PackageColorTest > m_bGrabImage7Done f");

                            //STTrackLog.WriteLine("Get image result = " + blnResultOK.ToString());

                            ////AttachImageToROI();
                            //if ((m_smCustomizeInfo.g_intWantLead & (1 << m_smVisionInfo.g_intVisionPos)) > 0)
                            //{
                            //    if (m_smVisionInfo.g_objLeadImage == null)
                            //        m_smVisionInfo.g_objLeadImage = new ImageDrawing(true);

                            //    m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo].CopyTo(ref m_smVisionInfo.g_objLeadImage);
                            //    m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo].CopyTo(ref m_smVisionInfo.g_arrRotatedImages, m_smVisionInfo.g_arrLead[0].ref_intImageViewNo);
                            //    AttachToROI(m_smVisionInfo.g_arrLeadROIs, m_smVisionInfo.g_objLeadImage);
                            //    //AttachToROI(m_smVisionInfo.g_arrLeadROIs, m_smVisionInfo.g_arrImages, m_smVisionInfo.g_arrLead[0].ref_intImageViewNo);
                            //}


                            // 2020-08-11 ZJYEOH : Only need Orient data to rotate when got package
                            WaitEventDone(ref m_blnOrientDataUpdated, true, 10000, "UpdateSubProgress_PackageColorTest > m_blnOrientDataUpdated 9136");

                            // Get RotateROI where the ROI center point == Unit Center Point
                            CROI objRotatedROI = new CROI();

                            if (m_blnWantPackageTest && ((m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailMask & 0x1000) > 0 || m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetWantInspectPackage() || GetWantInspectPackageColor(m_smVisionInfo.g_intSelectedUnit))) // 2020-06-23 ZJYEOH : If inspection option got tick Check package size just can use pkg gauge
                            {

                                WaitEventDone(ref m_bPackageSizePreTestDone, true, 10000, "UpdateSubProgress_PackageColorTest > m_bPackageSizePreTestDone");
                                
                                for (int i = 0; i < m_smVisionInfo.g_arrColorImages.Count; i++)
                                {
                                    if (arrColorSelectedImage.Contains(i))
                                    {
                                        if (m_bPackageSizePreTestResult)
                                        {
                                            float fSizeX, fSizeY;
                                            fSizeX = m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIWidth - m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIWidth % 2; // why %2? To get "even" number
                                            fSizeY = m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIHeight - m_smVisionInfo.g_arrOrientROIs[0][0].ref_ROIHeight % 2;

                                            objRotatedROI.AttachImage(m_smVisionInfo.g_arrColorImages[i]);

                                            // Get RotateROI center point where the ROI center point == Package Unit Center Point
                                            objRotatedROI.LoadROISetting((int)Math.Round(m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X - fSizeX / 2, 0, MidpointRounding.AwayFromZero),
                                                                         (int)Math.Round(m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y - fSizeY / 2, 0, MidpointRounding.AwayFromZero),
                                                                         (int)Math.Round(fSizeX, 0, MidpointRounding.AwayFromZero),
                                                                         (int)Math.Round(fSizeY, 0, MidpointRounding.AwayFromZero));

                                            CROI.Rotate0Degree(m_smVisionInfo.g_arrColorImages[i], objRotatedROI, m_intOrientAngle + m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle, 4, ref m_smVisionInfo.g_arrColorRotatedImages, i);
                                            
                                            m_smVisionInfo.g_arrColorRotatedImages[i].CopyTo(ref m_arrColorImage_ForInspection, i);

                                            SetColorImageRotated(i);

                                        }
                                        else
                                        {
                                            m_smVisionInfo.g_arrColorImages[i].CopyTo(ref m_smVisionInfo.g_arrColorRotatedImages, i);
                                        }
                                    }
                                }
                            }

                            // ------------------ Package Color Test ----------------------------------------------------------

                            if (blnResultOK && m_bPackageSizePreTestResult)
                            {
                                WaitEventDone(ref m_bPackageSizeTestDone, true, 10000, "UpdateSubProgress_PackageColorTest > m_bPackageSizeTestDone 8992");

                                // ------------- Package Defect Test on Side Light View -------------------------
                                if (m_bSubTh_PackageTest_PackageSize_Result)
                                {
                                    if (!StartPackageColorTest_MultiThreading(m_blnAuto))
                                    {
                                        blnResultOK = false;
                                    }
                                }
                            }

                            objRotatedROI.Dispose();
                        }

                        m_bSubTh_PackageColorTest_Result = blnResultOK;

                        m_bSubTh_PackageColorTest = false;
                    }
                }
                catch (Exception ex)
                {
                    m_bSubTh_PackageColorTest = false;

                    SRMMessageBox.Show("Vision1Process->UpdateSubProgress_PackageColorTest() :" + ex.ToString());
                }
                Thread.Sleep(1);
            }

            m_thSubThread_PackageColorTest = null;
            m_blnStopped_PackageColorTest = true;
        }
        private void SaveImageBuffer()
        {
            try
            {
                if (m_blnTrackingON_SaveImageBuffer)
                {
                    m_strTrackingData_SaveImageBuffer = "";

                    if (m_intPassStartNode != m_intPassEndNode)
                    {
                        //STTrackLog.WriteLine("Start=" + m_intPassStartNode.ToString() + ", End=" + m_intPassEndNode.ToString());

                        m_strTrackingData_SaveImageBuffer += "1[" + m_intPassStartNode.ToString() + "," + m_intPassEndNode.ToString() + "], ";


                        // 2020 03 27 - JBTAN: Save to different folder if reset count
                        string strPath;
                        if (m_smVisionInfo.g_intVisionResetCount == 0)
                        {
                            strPath = m_smVisionInfo.g_strSaveImageLocation +
                                    m_smProductionInfo.g_strLotID + "_" + m_smProductionInfo.g_strLotStartTime +
                                    "\\" + m_smVisionInfo.g_strVisionFolderName +
                                    "(" + m_smVisionInfo.g_strVisionDisplayName + " " + m_smVisionInfo.g_strVisionNameRemark + ")" + "_" + m_smProductionInfo.g_strLotStartTime +
                                    "\\Pass\\";
                        }
                        else
                        {
                            string strLotSaveImagePath = m_smVisionInfo.g_strSaveImageLocation + m_smProductionInfo.g_strLotID + "_" + m_smProductionInfo.g_strLotStartTime;
                            string strVisionImageFolderName = m_smVisionInfo.g_strVisionFolderName + "(" + m_smVisionInfo.g_strVisionDisplayName + " " + m_smVisionInfo.g_strVisionNameRemark + ")" + "_" + m_smVisionInfo.g_strVisionResetCountTime;

                            if (!Directory.Exists(strLotSaveImagePath + "\\" + strVisionImageFolderName))
                                Directory.CreateDirectory(strLotSaveImagePath + "\\" + strVisionImageFolderName);
                            if (!Directory.Exists(strLotSaveImagePath + "\\" + strVisionImageFolderName + "\\Pass"))
                                Directory.CreateDirectory(strLotSaveImagePath + "\\" + strVisionImageFolderName + "\\Pass");

                            strPath = strLotSaveImagePath + "\\" + strVisionImageFolderName + "\\Pass\\";
                        }


                        m_strTrackingData_SaveImageBuffer += "2, ";
                        string strDegree = "0";
                        switch (m_arrOrientationBuffer[m_intPassStartNode])
                        {
                            case 0:
                                strDegree = "0";
                                break;
                            case 1:
                                strDegree = "90";
                                break;
                            case 2:
                                strDegree = "180";
                                break;
                            case 3:
                                strDegree = "270";
                                break;
                        }

                        m_strTrackingData_SaveImageBuffer += "3, ";
                        if (m_smVisionInfo.g_blnViewColorImage)
                        {
                            m_arrPassCImage1Buffer[m_intPassStartNode].SaveImage(strPath + m_arrPassNoBuffer[m_intPassStartNode] + "_Pass_" + strDegree + "Degree" + ".bmp");
                            //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                            m_arrPassCImage1Buffer[m_intPassStartNode].Dispose();
                            m_arrPassCImage1Buffer[m_intPassStartNode] = new CImageDrawing(true);
                        }
                        else
                        {
                            m_arrPassImage1Buffer[m_intPassStartNode].SaveImage(strPath + m_arrPassNoBuffer[m_intPassStartNode] + "_Pass_" + strDegree + "Degree" + ".bmp");
                            //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                            m_arrPassImage1Buffer[m_intPassStartNode].Dispose();
                            m_arrPassImage1Buffer[m_intPassStartNode] = new ImageDrawing(true);
                        }

                        m_strTrackingData_SaveImageBuffer += "4, ";
                        if (m_smVisionInfo.g_arrImages.Count > 1)
                        {
                            if (m_smVisionInfo.g_blnViewColorImage)
                            {
                                m_arrPassCImage2Buffer[m_intPassStartNode].SaveImage(strPath + m_arrPassNoBuffer[m_intPassStartNode] + "_Pass_" + strDegree + "Degree" + "_Image1.bmp");
                                //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                                m_arrPassCImage2Buffer[m_intPassStartNode].Dispose();
                                m_arrPassCImage2Buffer[m_intPassStartNode] = new CImageDrawing(true);
                            }
                            else
                            {
                                m_arrPassImage2Buffer[m_intPassStartNode].SaveImage(strPath + m_arrPassNoBuffer[m_intPassStartNode] + "_Pass_" + strDegree + "Degree" + "_Image1.bmp");
                                //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                                m_arrPassImage2Buffer[m_intPassStartNode].Dispose();
                                m_arrPassImage2Buffer[m_intPassStartNode] = new ImageDrawing(true);
                            }
                        }

                        m_strTrackingData_SaveImageBuffer += "5, ";
                        if (m_smVisionInfo.g_arrImages.Count > 2)
                        {
                            if (m_smVisionInfo.g_blnViewColorImage)
                            {
                                m_arrPassCImage3Buffer[m_intPassStartNode].SaveImage(strPath + m_arrPassNoBuffer[m_intPassStartNode] + "_Pass_" + strDegree + "Degree" + "_Image2.bmp");
                                //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                                m_arrPassCImage3Buffer[m_intPassStartNode].Dispose();
                                m_arrPassCImage3Buffer[m_intPassStartNode] = new CImageDrawing(true);
                            }
                            else
                            {
                                m_arrPassImage3Buffer[m_intPassStartNode].SaveImage(strPath + m_arrPassNoBuffer[m_intPassStartNode] + "_Pass_" + strDegree + "Degree" + "_Image2.bmp");
                                //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                                m_arrPassImage3Buffer[m_intPassStartNode].Dispose();
                                m_arrPassImage3Buffer[m_intPassStartNode] = new ImageDrawing(true);
                            }
                        }

                        m_strTrackingData_SaveImageBuffer += "6,  ";
                        if (m_smVisionInfo.g_arrImages.Count > 3)
                        {
                            if (m_smVisionInfo.g_blnViewColorImage)
                            {
                                m_arrPassCImage4Buffer[m_intPassStartNode].SaveImage(strPath + m_arrPassNoBuffer[m_intPassStartNode] + "_Pass_" + strDegree + "Degree" + "_Image3.bmp");
                                //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                                m_arrPassCImage4Buffer[m_intPassStartNode].Dispose();
                                m_arrPassCImage4Buffer[m_intPassStartNode] = new CImageDrawing(true);
                            }
                            else
                            {
                                m_arrPassImage4Buffer[m_intPassStartNode].SaveImage(strPath + m_arrPassNoBuffer[m_intPassStartNode] + "_Pass_" + strDegree + "Degree" + "_Image3.bmp");
                                //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                                m_arrPassImage4Buffer[m_intPassStartNode].Dispose();
                                m_arrPassImage4Buffer[m_intPassStartNode] = new ImageDrawing(true);
                            }
                        }

                        m_strTrackingData_SaveImageBuffer += "7,  ";
                        if (m_smVisionInfo.g_arrImages.Count > 4)
                        {
                            if (m_smVisionInfo.g_blnViewColorImage)
                            {
                                m_arrPassCImage5Buffer[m_intPassStartNode].SaveImage(strPath + m_arrPassNoBuffer[m_intPassStartNode] + "_Pass_" + strDegree + "Degree" + "_Image4.bmp");
                                //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                                m_arrPassCImage5Buffer[m_intPassStartNode].Dispose();
                                m_arrPassCImage5Buffer[m_intPassStartNode] = new CImageDrawing(true);
                            }
                            else
                            {
                                m_arrPassImage5Buffer[m_intPassStartNode].SaveImage(strPath + m_arrPassNoBuffer[m_intPassStartNode] + "_Pass_" + strDegree + "Degree" + "_Image4.bmp");
                                //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                                m_arrPassImage5Buffer[m_intPassStartNode].Dispose();
                                m_arrPassImage5Buffer[m_intPassStartNode] = new ImageDrawing(true);
                            }
                        }

                        m_strTrackingData_SaveImageBuffer += "8,  ";
                        if (m_smVisionInfo.g_arrImages.Count > 5)
                        {
                            if (m_smVisionInfo.g_blnViewColorImage)
                            {
                                m_arrPassCImage6Buffer[m_intPassStartNode].SaveImage(strPath + m_arrPassNoBuffer[m_intPassStartNode] + "_Pass_" + strDegree + "Degree" + "_Image5.bmp");
                                //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                                m_arrPassCImage6Buffer[m_intPassStartNode].Dispose();
                                m_arrPassCImage6Buffer[m_intPassStartNode] = new CImageDrawing(true);
                            }
                            else
                            {
                                m_arrPassImage6Buffer[m_intPassStartNode].SaveImage(strPath + m_arrPassNoBuffer[m_intPassStartNode] + "_Pass_" + strDegree + "Degree" + "_Image5.bmp");
                                //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                                m_arrPassImage6Buffer[m_intPassStartNode].Dispose();
                                m_arrPassImage6Buffer[m_intPassStartNode] = new ImageDrawing(true);
                            }
                        }

                        m_strTrackingData_SaveImageBuffer += "9,  ";
                        if (m_smVisionInfo.g_arrImages.Count > 6)
                        {
                            if (m_smVisionInfo.g_blnViewColorImage)
                            {
                                m_arrPassCImage7Buffer[m_intPassStartNode].SaveImage(strPath + m_arrPassNoBuffer[m_intPassStartNode] + "_Pass_" + strDegree + "Degree" + "_Image6.bmp");
                                //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                                m_arrPassCImage7Buffer[m_intPassStartNode].Dispose();
                                m_arrPassCImage7Buffer[m_intPassStartNode] = new CImageDrawing(true);
                            }
                            else
                            {
                                m_arrPassImage7Buffer[m_intPassStartNode].SaveImage(strPath + m_arrPassNoBuffer[m_intPassStartNode] + "_Pass_" + strDegree + "Degree" + "_Image6.bmp");
                                //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                                m_arrPassImage7Buffer[m_intPassStartNode].Dispose();
                                m_arrPassImage7Buffer[m_intPassStartNode] = new ImageDrawing(true);
                            }
                        }

                        m_strTrackingData_SaveImageBuffer += "10, ";
                        m_smVisionInfo.g_strLastImageFolder = strPath;
                        m_smVisionInfo.g_strLastImageName = m_arrPassNoBuffer[m_intPassStartNode] + "_Pass_" + strDegree + "Degree" + ".bmp";

                        m_strTrackingData_SaveImageBuffer += "11, ";
                        m_intPassStartNode++;
                        if (m_intPassStartNode == m_smVisionInfo.g_intSaveImageBufferSize)
                        {
                            m_intPassStartNode = 0;
                        }

                        m_strTrackingData_SaveImageBuffer += "12, ";
                    }

                    if (m_intFailStartNode != m_intFailEndNode)
                    {
                        //STTrackLog.WriteLine("Start=" + m_intFailStartNode.ToString() + ", End=" + m_intFailEndNode.ToString());

                        m_strTrackingData_SaveImageBuffer += "A[" + m_intFailStartNode.ToString() + "," + m_intFailEndNode.ToString() + "], ";

                        //2021-02-24 ZJYEOH : Should use m_smVisionInfo.g_intFailImageCount to compare
                        if (/*m_arrFailNoBuffer[m_intFailStartNode]*/ m_smVisionInfo.g_intFailImageCount > m_smCustomizeInfo.g_intFailImagePics)//>=
                        {
                            m_strTrackingData_SaveImageBuffer += "B, ";
                            if (!m_blnLoadRejectImageListPath)
                            {
                                m_strTrackingData_SaveImageBuffer += "C, ";
                                LoadRejectImageListPath();
                                m_strTrackingData_SaveImageBuffer += "D, ";
                                m_blnLoadRejectImageListPath = true;
                            }

                            m_strTrackingData_SaveImageBuffer += "E, ";
                            if (m_arrRejectImageListPath.Count > 0)
                            {
                                m_strTrackingData_SaveImageBuffer += "F, ";
                                string strDeleteFile = m_arrRejectImageListPath[0];
                                if (File.Exists(strDeleteFile))
                                {
                                    File.Delete(strDeleteFile);
                                }

                                m_strTrackingData_SaveImageBuffer += "G, ";
                                if (m_smVisionInfo.g_arrImages.Count > 1)
                                {
                                    int intStartIndex = strDeleteFile.LastIndexOf(".bmp");
                                    if (intStartIndex > 0)
                                    {
                                        string strDeleteFileImage1 = strDeleteFile.Substring(0, intStartIndex) + "_Image1.bmp";
                                        if (File.Exists(strDeleteFileImage1))
                                        {
                                            File.Delete(strDeleteFileImage1);
                                        }
                                    }
                                }
                                m_strTrackingData_SaveImageBuffer += "H, ";

                                if (m_smVisionInfo.g_arrImages.Count > 2)
                                {
                                    int intStartIndex = strDeleteFile.LastIndexOf(".bmp");
                                    if (intStartIndex > 0)
                                    {
                                        string strDeleteFileImage2 = strDeleteFile.Substring(0, intStartIndex) + "_Image2.bmp";
                                        if (File.Exists(strDeleteFileImage2))
                                        {
                                            File.Delete(strDeleteFileImage2);
                                        }
                                    }
                                }

                                m_strTrackingData_SaveImageBuffer += "I, ";
                                if (m_smVisionInfo.g_arrImages.Count > 3)
                                {
                                    int intStartIndex = strDeleteFile.LastIndexOf(".bmp");
                                    if (intStartIndex > 0)
                                    {
                                        string strDeleteFileImage3 = strDeleteFile.Substring(0, intStartIndex) + "_Image3.bmp";
                                        if (File.Exists(strDeleteFileImage3))
                                        {
                                            File.Delete(strDeleteFileImage3);
                                        }
                                    }
                                }

                                m_strTrackingData_SaveImageBuffer += "J, ";
                                if (m_smVisionInfo.g_arrImages.Count > 4)
                                {
                                    int intStartIndex = strDeleteFile.LastIndexOf(".bmp");
                                    if (intStartIndex > 0)
                                    {
                                        string strDeleteFileImage4 = strDeleteFile.Substring(0, intStartIndex) + "_Image4.bmp";
                                        if (File.Exists(strDeleteFileImage4))
                                        {
                                            File.Delete(strDeleteFileImage4);
                                        }
                                    }
                                }

                                m_strTrackingData_SaveImageBuffer += "K, ";
                                if (m_smVisionInfo.g_arrImages.Count > 5)
                                {
                                    int intStartIndex = strDeleteFile.LastIndexOf(".bmp");
                                    if (intStartIndex > 0)
                                    {
                                        string strDeleteFileImage5 = strDeleteFile.Substring(0, intStartIndex) + "_Image5.bmp";
                                        if (File.Exists(strDeleteFileImage5))
                                        {
                                            File.Delete(strDeleteFileImage5);
                                        }
                                    }
                                }

                                m_strTrackingData_SaveImageBuffer += "L, ";
                                if (m_smVisionInfo.g_arrImages.Count > 6)
                                {
                                    int intStartIndex = strDeleteFile.LastIndexOf(".bmp");
                                    if (intStartIndex > 0)
                                    {
                                        string strDeleteFileImage6 = strDeleteFile.Substring(0, intStartIndex) + "_Image6.bmp";
                                        if (File.Exists(strDeleteFileImage6))
                                        {
                                            File.Delete(strDeleteFileImage6);
                                        }
                                    }
                                }

                                m_strTrackingData_SaveImageBuffer += "M, ";
                                m_arrRejectImageListPath.RemoveAt(0);

                                m_strTrackingData_SaveImageBuffer += "N, ";
                            }
                        }
                        else if (m_arrFailNoBuffer[m_intFailStartNode] == 0)
                        {
                            m_strTrackingData_SaveImageBuffer += "O, ";
                            m_arrRejectImageListPath.Clear();
                        }

                        m_strTrackingData_SaveImageBuffer += "P, ";
                        //string strPath = m_smVisionInfo.g_strSaveImageLocation +
                        //        m_smProductionInfo.g_strLotID + "_" + m_smProductionInfo.g_strLotStartTime +
                        //        "\\" + m_smVisionInfo.g_strVisionFolderName +
                        //        "(" + m_smVisionInfo.g_strVisionDisplayName + " " + m_smVisionInfo.g_strVisionNameRemark + ")" +
                        //        "\\" + m_arrRejectNameBuffer[m_intFailStartNode] + "\\";

                        // 2020 03 27 - JBTAN: Save to different folder if reset count
                        string strPath;
                        if (m_smVisionInfo.g_intVisionResetCount == 0)
                        {
                            strPath = m_smVisionInfo.g_strSaveImageLocation +
                                m_smProductionInfo.g_strLotID + "_" + m_smProductionInfo.g_strLotStartTime +
                                "\\" + m_smVisionInfo.g_strVisionFolderName +
                                "(" + m_smVisionInfo.g_strVisionDisplayName + " " + m_smVisionInfo.g_strVisionNameRemark + ")" + "_" + m_smProductionInfo.g_strLotStartTime +
                                "\\" + m_arrRejectNameBuffer[m_intFailStartNode] + "\\";
                        }
                        else
                        {
                            string strLotSaveImagePath = m_smVisionInfo.g_strSaveImageLocation + m_smProductionInfo.g_strLotID + "_" + m_smProductionInfo.g_strLotStartTime;
                            string strVisionImageFolderName = m_smVisionInfo.g_strVisionFolderName + "(" + m_smVisionInfo.g_strVisionDisplayName + " " + m_smVisionInfo.g_strVisionNameRemark + ")" + "_" + m_smVisionInfo.g_strVisionResetCountTime;

                            if (!Directory.Exists(strLotSaveImagePath + "\\" + strVisionImageFolderName))
                                Directory.CreateDirectory(strLotSaveImagePath + "\\" + strVisionImageFolderName);
                            if (!Directory.Exists(strLotSaveImagePath + "\\" + strVisionImageFolderName + "\\" + m_arrRejectNameBuffer[m_intFailStartNode] + "\\"))
                                Directory.CreateDirectory(strLotSaveImagePath + "\\" + strVisionImageFolderName + "\\" + m_arrRejectNameBuffer[m_intFailStartNode] + "\\");

                            strPath = strLotSaveImagePath + "\\" + strVisionImageFolderName + "\\" + m_arrRejectNameBuffer[m_intFailStartNode] + "\\";
                        }

                        m_strTrackingData_SaveImageBuffer += "Q, ";
                        if (m_smVisionInfo.g_blnViewColorImage)
                        {
                            m_arrFailCImage1Buffer[m_intFailStartNode].SaveImage(strPath + m_arrFailNoBuffer[m_intFailStartNode] + "_" + m_arrRejectNameBuffer[m_intFailStartNode] + ".bmp");
                            //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                            m_arrFailCImage1Buffer[m_intFailStartNode].Dispose();
                            m_arrFailCImage1Buffer[m_intFailStartNode] = new CImageDrawing(true);
                        }
                        else
                        {
                            m_arrFailImage1Buffer[m_intFailStartNode].SaveImage(strPath + m_arrFailNoBuffer[m_intFailStartNode] + "_" + m_arrRejectNameBuffer[m_intFailStartNode] + ".bmp");
                            //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                            m_arrFailImage1Buffer[m_intFailStartNode].Dispose();
                            m_arrFailImage1Buffer[m_intFailStartNode] = new ImageDrawing(true);
                        }

                        m_strTrackingData_SaveImageBuffer += "R, ";
                        if (m_smVisionInfo.g_arrImages.Count > 1)
                        {
                            if (m_smVisionInfo.g_blnViewColorImage)
                            {
                                m_arrFailCImage2Buffer[m_intFailStartNode].SaveImage(strPath + m_arrFailNoBuffer[m_intFailStartNode] + "_" + m_arrRejectNameBuffer[m_intFailStartNode] + "_Image1.bmp");
                                //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                                m_arrFailCImage2Buffer[m_intFailStartNode].Dispose();
                                m_arrFailCImage2Buffer[m_intFailStartNode] = new CImageDrawing(true);
                            }
                            else
                            {
                                m_arrFailImage2Buffer[m_intFailStartNode].SaveImage(strPath + m_arrFailNoBuffer[m_intFailStartNode] + "_" + m_arrRejectNameBuffer[m_intFailStartNode] + "_Image1.bmp");
                                //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                                m_arrFailImage2Buffer[m_intFailStartNode].Dispose();
                                m_arrFailImage2Buffer[m_intFailStartNode] = new ImageDrawing(true);
                            }
                        }

                        m_strTrackingData_SaveImageBuffer += "S, ";
                        if (m_smVisionInfo.g_arrImages.Count > 2)
                        {
                            if (m_smVisionInfo.g_blnViewColorImage)
                            {
                                m_arrFailCImage3Buffer[m_intFailStartNode].SaveImage(strPath + m_arrFailNoBuffer[m_intFailStartNode] + "_" + m_arrRejectNameBuffer[m_intFailStartNode] + "_Image2.bmp");
                                //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                                m_arrFailCImage3Buffer[m_intFailStartNode].Dispose();
                                m_arrFailCImage3Buffer[m_intFailStartNode] = new CImageDrawing(true);
                            }
                            else
                            {
                                m_arrFailImage3Buffer[m_intFailStartNode].SaveImage(strPath + m_arrFailNoBuffer[m_intFailStartNode] + "_" + m_arrRejectNameBuffer[m_intFailStartNode] + "_Image2.bmp");
                                //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                                m_arrFailImage3Buffer[m_intFailStartNode].Dispose();
                                m_arrFailImage3Buffer[m_intFailStartNode] = new ImageDrawing(true);
                            }
                        }

                        m_strTrackingData_SaveImageBuffer += "T, ";
                        if (m_smVisionInfo.g_arrImages.Count > 3)
                        {
                            if (m_smVisionInfo.g_blnViewColorImage)
                            {
                                m_arrFailCImage4Buffer[m_intFailStartNode].SaveImage(strPath + m_arrFailNoBuffer[m_intFailStartNode] + "_" + m_arrRejectNameBuffer[m_intFailStartNode] + "_Image3.bmp");
                                //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                                m_arrFailCImage4Buffer[m_intFailStartNode].Dispose();
                                m_arrFailCImage4Buffer[m_intFailStartNode] = new CImageDrawing(true);
                            }
                            else
                            {
                                m_arrFailImage4Buffer[m_intFailStartNode].SaveImage(strPath + m_arrFailNoBuffer[m_intFailStartNode] + "_" + m_arrRejectNameBuffer[m_intFailStartNode] + "_Image3.bmp");
                                //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                                m_arrFailImage4Buffer[m_intFailStartNode].Dispose();
                                m_arrFailImage4Buffer[m_intFailStartNode] = new ImageDrawing(true);
                            }
                        }

                        m_strTrackingData_SaveImageBuffer += "U, ";
                        if (m_smVisionInfo.g_arrImages.Count > 4)
                        {
                            if (m_smVisionInfo.g_blnViewColorImage)
                            {
                                m_arrFailCImage5Buffer[m_intFailStartNode].SaveImage(strPath + m_arrFailNoBuffer[m_intFailStartNode] + "_" + m_arrRejectNameBuffer[m_intFailStartNode] + "_Image4.bmp");
                                //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                                m_arrFailCImage5Buffer[m_intFailStartNode].Dispose();
                                m_arrFailCImage5Buffer[m_intFailStartNode] = new CImageDrawing(true);
                            }
                            else
                            {
                                m_arrFailImage5Buffer[m_intFailStartNode].SaveImage(strPath + m_arrFailNoBuffer[m_intFailStartNode] + "_" + m_arrRejectNameBuffer[m_intFailStartNode] + "_Image4.bmp");
                                //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                                m_arrFailImage5Buffer[m_intFailStartNode].Dispose();
                                m_arrFailImage5Buffer[m_intFailStartNode] = new ImageDrawing(true);
                            }
                        }

                        m_strTrackingData_SaveImageBuffer += "V, ";
                        if (m_smVisionInfo.g_arrImages.Count > 5)
                        {
                            if (m_smVisionInfo.g_blnViewColorImage)
                            {
                                m_arrFailCImage6Buffer[m_intFailStartNode].SaveImage(strPath + m_arrFailNoBuffer[m_intFailStartNode] + "_" + m_arrRejectNameBuffer[m_intFailStartNode] + "_Image5.bmp");
                                //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                                m_arrFailCImage6Buffer[m_intFailStartNode].Dispose();
                                m_arrFailCImage6Buffer[m_intFailStartNode] = new CImageDrawing(true);
                            }
                            else
                            {
                                m_arrFailImage6Buffer[m_intFailStartNode].SaveImage(strPath + m_arrFailNoBuffer[m_intFailStartNode] + "_" + m_arrRejectNameBuffer[m_intFailStartNode] + "_Image5.bmp");
                                //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                                m_arrFailImage6Buffer[m_intFailStartNode].Dispose();
                                m_arrFailImage6Buffer[m_intFailStartNode] = new ImageDrawing(true);
                            }
                        }

                        m_strTrackingData_SaveImageBuffer += "W, ";
                        if (m_smVisionInfo.g_arrImages.Count > 6)
                        {
                            if (m_smVisionInfo.g_blnViewColorImage)
                            {
                                m_arrFailCImage7Buffer[m_intFailStartNode].SaveImage(strPath + m_arrFailNoBuffer[m_intFailStartNode] + "_" + m_arrRejectNameBuffer[m_intFailStartNode] + "_Image6.bmp");
                                //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                                m_arrFailCImage7Buffer[m_intFailStartNode].Dispose();
                                m_arrFailCImage7Buffer[m_intFailStartNode] = new CImageDrawing(true);
                            }
                            else
                            {
                                m_arrFailImage7Buffer[m_intFailStartNode].SaveImage(strPath + m_arrFailNoBuffer[m_intFailStartNode] + "_" + m_arrRejectNameBuffer[m_intFailStartNode] + "_Image6.bmp");
                                //2021-02-04 ZJYEOH : Dispose and init again can reduce RAM consumption
                                m_arrFailImage7Buffer[m_intFailStartNode].Dispose();
                                m_arrFailImage7Buffer[m_intFailStartNode] = new ImageDrawing(true);
                            }
                        }

                        m_strTrackingData_SaveImageBuffer += "X, ";
                        m_smVisionInfo.g_strLastImageFolder = strPath;
                        m_smVisionInfo.g_strLastImageName = m_arrFailNoBuffer[m_intFailStartNode] + "_" + m_arrRejectNameBuffer[m_intFailStartNode] + ".bmp";

                        m_strTrackingData_SaveImageBuffer += "Y, ";
                        m_arrRejectImageListPath.Add(strPath + m_arrFailNoBuffer[m_intFailStartNode] + "_" + m_arrRejectNameBuffer[m_intFailStartNode] + ".bmp");

                        m_strTrackingData_SaveImageBuffer += "Z, ";
                        
                        if ((m_intFailStartNode + 1) == m_smVisionInfo.g_intSaveImageBufferSize)
                        {
                            m_intFailStartNode = 0;
                        }
                        else
                            m_intFailStartNode++;

                        m_strTrackingData_SaveImageBuffer += "AA, ";
                    }
                }
                else
                {
                    if (m_intPassStartNode != m_intPassEndNode)
                    {
                        //STTrackLog.WriteLine("Start=" + m_intPassStartNode.ToString() + ", End=" + m_intPassEndNode.ToString());

                        //string strPath = m_smVisionInfo.g_strSaveImageLocation +
                        //            m_smProductionInfo.g_strLotID + "_" + m_smProductionInfo.g_strLotStartTime +
                        //            "\\" + m_smVisionInfo.g_strVisionFolderName +
                        //            "(" + m_smVisionInfo.g_strVisionDisplayName + " " + m_smVisionInfo.g_strVisionNameRemark + ")" +
                        //            "\\Pass\\";

                        // 2020 03 27 - JBTAN: Save to different folder if reset count
                        string strPath;
                        if (m_smVisionInfo.g_intVisionResetCount == 0)
                        {
                            strPath = m_smVisionInfo.g_strSaveImageLocation +
                                    m_smProductionInfo.g_strLotID + "_" + m_smProductionInfo.g_strLotStartTime +
                                    "\\" + m_smVisionInfo.g_strVisionFolderName +
                                    "(" + m_smVisionInfo.g_strVisionDisplayName + " " + m_smVisionInfo.g_strVisionNameRemark + ")" + "_" + m_smProductionInfo.g_strLotStartTime +
                                    "\\Pass\\";
                        }
                        else
                        {
                            string strLotSaveImagePath = m_smVisionInfo.g_strSaveImageLocation + m_smProductionInfo.g_strLotID + "_" + m_smProductionInfo.g_strLotStartTime;
                            string strVisionImageFolderName = m_smVisionInfo.g_strVisionFolderName + "(" + m_smVisionInfo.g_strVisionDisplayName + " " + m_smVisionInfo.g_strVisionNameRemark + ")" + "_" + m_smVisionInfo.g_strVisionResetCountTime;

                            if (!Directory.Exists(strLotSaveImagePath + "\\" + strVisionImageFolderName))
                                Directory.CreateDirectory(strLotSaveImagePath + "\\" + strVisionImageFolderName);
                            if (!Directory.Exists(strLotSaveImagePath + "\\" + strVisionImageFolderName + "\\Pass"))
                                Directory.CreateDirectory(strLotSaveImagePath + "\\" + strVisionImageFolderName + "\\Pass");

                            strPath = strLotSaveImagePath + "\\" + strVisionImageFolderName + "\\Pass\\";
                        }

                        string strDegree = "0";
                        switch (m_arrOrientationBuffer[m_intPassStartNode])
                        {
                            case 0:
                                strDegree = "0";
                                break;
                            case 1:
                                strDegree = "90";
                                break;
                            case 2:
                                strDegree = "180";
                                break;
                            case 3:
                                strDegree = "270";
                                break;
                        }

                        if (m_smVisionInfo.g_blnViewColorImage)
                            m_arrPassCImage1Buffer[m_intPassStartNode].SaveImage(strPath + m_arrPassNoBuffer[m_intPassStartNode] + "_Pass_" + strDegree + "Degree" + ".bmp");
                        else
                            m_arrPassImage1Buffer[m_intPassStartNode].SaveImage(strPath + m_arrPassNoBuffer[m_intPassStartNode] + "_Pass_" + strDegree + "Degree" + ".bmp");

                        if (m_smVisionInfo.g_arrImages.Count > 1)
                        {
                            if (m_smVisionInfo.g_blnViewColorImage)
                                m_arrPassCImage2Buffer[m_intPassStartNode].SaveImage(strPath + m_arrPassNoBuffer[m_intPassStartNode] + "_Pass_" + strDegree + "Degree" + "_Image1.bmp");
                            else
                                m_arrPassImage2Buffer[m_intPassStartNode].SaveImage(strPath + m_arrPassNoBuffer[m_intPassStartNode] + "_Pass_" + strDegree + "Degree" + "_Image1.bmp");
                        }

                        if (m_smVisionInfo.g_arrImages.Count > 2)
                        {
                            if (m_smVisionInfo.g_blnViewColorImage)
                                m_arrPassCImage3Buffer[m_intPassStartNode].SaveImage(strPath + m_arrPassNoBuffer[m_intPassStartNode] + "_Pass_" + strDegree + "Degree" + "_Image2.bmp");
                            else
                                m_arrPassImage3Buffer[m_intPassStartNode].SaveImage(strPath + m_arrPassNoBuffer[m_intPassStartNode] + "_Pass_" + strDegree + "Degree" + "_Image2.bmp");
                        }

                        if (m_smVisionInfo.g_arrImages.Count > 3)
                        {
                            if (m_smVisionInfo.g_blnViewColorImage)
                                m_arrPassCImage4Buffer[m_intPassStartNode].SaveImage(strPath + m_arrPassNoBuffer[m_intPassStartNode] + "_Pass_" + strDegree + "Degree" + "_Image3.bmp");
                            else
                                m_arrPassImage4Buffer[m_intPassStartNode].SaveImage(strPath + m_arrPassNoBuffer[m_intPassStartNode] + "_Pass_" + strDegree + "Degree" + "_Image3.bmp");
                        }

                        if (m_smVisionInfo.g_arrImages.Count > 4)
                        {
                            if (m_smVisionInfo.g_blnViewColorImage)
                                m_arrPassCImage5Buffer[m_intPassStartNode].SaveImage(strPath + m_arrPassNoBuffer[m_intPassStartNode] + "_Pass_" + strDegree + "Degree" + "_Image4.bmp");
                            else
                                m_arrPassImage5Buffer[m_intPassStartNode].SaveImage(strPath + m_arrPassNoBuffer[m_intPassStartNode] + "_Pass_" + strDegree + "Degree" + "_Image4.bmp");
                        }

                        if (m_smVisionInfo.g_arrImages.Count > 5)
                        {
                            if (m_smVisionInfo.g_blnViewColorImage)
                                m_arrPassCImage6Buffer[m_intPassStartNode].SaveImage(strPath + m_arrPassNoBuffer[m_intPassStartNode] + "_Pass_" + strDegree + "Degree" + "_Image5.bmp");
                            else
                                m_arrPassImage6Buffer[m_intPassStartNode].SaveImage(strPath + m_arrPassNoBuffer[m_intPassStartNode] + "_Pass_" + strDegree + "Degree" + "_Image5.bmp");
                        }

                        if (m_smVisionInfo.g_arrImages.Count > 6)
                        {
                            if (m_smVisionInfo.g_blnViewColorImage)
                                m_arrPassCImage7Buffer[m_intPassStartNode].SaveImage(strPath + m_arrPassNoBuffer[m_intPassStartNode] + "_Pass_" + strDegree + "Degree" + "_Image6.bmp");
                            else
                                m_arrPassImage7Buffer[m_intPassStartNode].SaveImage(strPath + m_arrPassNoBuffer[m_intPassStartNode] + "_Pass_" + strDegree + "Degree" + "_Image6.bmp");
                        }

                        m_smVisionInfo.g_strLastImageFolder = strPath;
                        m_smVisionInfo.g_strLastImageName = m_arrPassNoBuffer[m_intPassStartNode] + "_Pass_" + strDegree + "Degree" + ".bmp";

                        m_intPassStartNode++;
                        if (m_intPassStartNode == m_smVisionInfo.g_intSaveImageBufferSize)
                        {
                            m_intPassStartNode = 0;
                        }
                    }

                    if (m_intFailStartNode != m_intFailEndNode)
                    {
                        //STTrackLog.WriteLine("Start=" + m_intFailStartNode.ToString() + ", End=" + m_intFailEndNode.ToString());

                        //2021-02-24 ZJYEOH : Should use m_smVisionInfo.g_intFailImageCount to compare
                        if (/*m_arrFailNoBuffer[m_intFailStartNode]*/ m_smVisionInfo.g_intFailImageCount > m_smCustomizeInfo.g_intFailImagePics)//>=
                        {
                            if (!m_blnLoadRejectImageListPath)
                            {
                                LoadRejectImageListPath();

                                m_blnLoadRejectImageListPath = true;
                            }

                            if (m_arrRejectImageListPath.Count > 0)
                            {
                                string strDeleteFile = m_arrRejectImageListPath[0];
                                if (File.Exists(strDeleteFile))
                                {
                                    try
                                    {
                                        File.Delete(strDeleteFile);
                                    }
                                    catch (Exception ex)
                                    {
                                        STTrackLog.WriteLine("Vision1Process.cs > SaveImageBuffer Delete _image0 > Ex=" + ex.ToString());
                                    }
                                }

                                if (m_smVisionInfo.g_arrImages.Count > 1)
                                {
                                    int intStartIndex = strDeleteFile.LastIndexOf(".bmp");
                                    if (intStartIndex > 0)
                                    {
                                        string strDeleteFileImage1 = strDeleteFile.Substring(0, intStartIndex) + "_Image1.bmp";
                                        if (File.Exists(strDeleteFileImage1))
                                        {
                                            try
                                            {
                                                File.Delete(strDeleteFileImage1);
                                            }
                                            catch (Exception ex)
                                            {
                                                STTrackLog.WriteLine("Vision1Process.cs > SaveImageBuffer Delete _image1 > Ex=" + ex.ToString());
                                            }
                                        }
                                    }
                                }

                                if (m_smVisionInfo.g_arrImages.Count > 2)
                                {
                                    int intStartIndex = strDeleteFile.LastIndexOf(".bmp");
                                    if (intStartIndex > 0)
                                    {
                                        string strDeleteFileImage2 = strDeleteFile.Substring(0, intStartIndex) + "_Image2.bmp";
                                        if (File.Exists(strDeleteFileImage2))
                                        {
                                            try
                                            {
                                                File.Delete(strDeleteFileImage2);
                                            }
                                            catch (Exception ex)
                                            {
                                                STTrackLog.WriteLine("Vision1Process.cs > SaveImageBuffer Delete _image2 > Ex=" + ex.ToString());
                                            }
                                        }
                                    }
                                }

                                if (m_smVisionInfo.g_arrImages.Count > 3)
                                {
                                    int intStartIndex = strDeleteFile.LastIndexOf(".bmp");
                                    if (intStartIndex > 0)
                                    {
                                        string strDeleteFileImage3 = strDeleteFile.Substring(0, intStartIndex) + "_Image3.bmp";
                                        if (File.Exists(strDeleteFileImage3))
                                        {
                                            try
                                            {
                                                File.Delete(strDeleteFileImage3);
                                            }
                                            catch (Exception ex)
                                            {
                                                STTrackLog.WriteLine("Vision1Process.cs > SaveImageBuffer Delete _image3 > Ex=" + ex.ToString());
                                            }
                                        }
                                    }
                                }

                                if (m_smVisionInfo.g_arrImages.Count > 4)
                                {
                                    int intStartIndex = strDeleteFile.LastIndexOf(".bmp");
                                    if (intStartIndex > 0)
                                    {
                                        string strDeleteFileImage4 = strDeleteFile.Substring(0, intStartIndex) + "_Image4.bmp";
                                        if (File.Exists(strDeleteFileImage4))
                                        {
                                            try
                                            {
                                                File.Delete(strDeleteFileImage4);
                                            }
                                            catch (Exception ex)
                                            {
                                                STTrackLog.WriteLine("Vision1Process.cs > SaveImageBuffer Delete _image4 > Ex=" + ex.ToString());
                                            }
                                        }
                                    }
                                }

                                if (m_smVisionInfo.g_arrImages.Count > 5)
                                {
                                    int intStartIndex = strDeleteFile.LastIndexOf(".bmp");
                                    if (intStartIndex > 0)
                                    {
                                        string strDeleteFileImage5 = strDeleteFile.Substring(0, intStartIndex) + "_Image5.bmp";
                                        if (File.Exists(strDeleteFileImage5))
                                        {
                                            try
                                            {
                                                File.Delete(strDeleteFileImage5);
                                            }
                                            catch (Exception ex)
                                            {
                                                STTrackLog.WriteLine("Vision1Process.cs > SaveImageBuffer Delete _image5 > Ex=" + ex.ToString());
                                            }
                                        }
                                    }
                                }

                                if (m_smVisionInfo.g_arrImages.Count > 6)
                                {
                                    int intStartIndex = strDeleteFile.LastIndexOf(".bmp");
                                    if (intStartIndex > 0)
                                    {
                                        string strDeleteFileImage6 = strDeleteFile.Substring(0, intStartIndex) + "_Image6.bmp";
                                        if (File.Exists(strDeleteFileImage6))
                                        {
                                            try
                                            {
                                                File.Delete(strDeleteFileImage6);
                                            }
                                            catch (Exception ex)
                                            {
                                                STTrackLog.WriteLine("Vision1Process.cs > SaveImageBuffer Delete _image6 > Ex=" + ex.ToString());
                                            }
                                        }
                                    }
                                }

                                m_arrRejectImageListPath.RemoveAt(0);
                            }
                        }
                        else if (m_arrFailNoBuffer[m_intFailStartNode] == 0)
                        {
                            m_arrRejectImageListPath.Clear();

                            LoadRejectImageListPath();
                        }

                        //string strPath = m_smVisionInfo.g_strSaveImageLocation +
                        //        m_smProductionInfo.g_strLotID + "_" + m_smProductionInfo.g_strLotStartTime +
                        //        "\\" + m_smVisionInfo.g_strVisionFolderName +
                        //        "(" + m_smVisionInfo.g_strVisionDisplayName + " " + m_smVisionInfo.g_strVisionNameRemark + ")" +
                        //        "\\" + m_arrRejectNameBuffer[m_intFailStartNode] + "\\";

                        // 2020 03 27 - JBTAN: Save to different folder if reset count
                        string strPath;
                        if (m_smVisionInfo.g_intVisionResetCount == 0)
                        {
                            strPath = m_smVisionInfo.g_strSaveImageLocation +
                                m_smProductionInfo.g_strLotID + "_" + m_smProductionInfo.g_strLotStartTime +
                                "\\" + m_smVisionInfo.g_strVisionFolderName +
                                "(" + m_smVisionInfo.g_strVisionDisplayName + " " + m_smVisionInfo.g_strVisionNameRemark + ")" + "_" + m_smProductionInfo.g_strLotStartTime +
                                "\\" + m_arrRejectNameBuffer[m_intFailStartNode] + "\\";
                        }
                        else
                        {
                            string strLotSaveImagePath = m_smVisionInfo.g_strSaveImageLocation + m_smProductionInfo.g_strLotID + "_" + m_smProductionInfo.g_strLotStartTime;
                            string strVisionImageFolderName = m_smVisionInfo.g_strVisionFolderName + "(" + m_smVisionInfo.g_strVisionDisplayName + " " + m_smVisionInfo.g_strVisionNameRemark + ")" + "_" + m_smVisionInfo.g_strVisionResetCountTime;

                            if (!Directory.Exists(strLotSaveImagePath + "\\" + strVisionImageFolderName))
                                Directory.CreateDirectory(strLotSaveImagePath + "\\" + strVisionImageFolderName);
                            if (!Directory.Exists(strLotSaveImagePath + "\\" + strVisionImageFolderName + "\\" + m_arrRejectNameBuffer[m_intFailStartNode] + "\\"))
                                Directory.CreateDirectory(strLotSaveImagePath + "\\" + strVisionImageFolderName + "\\" + m_arrRejectNameBuffer[m_intFailStartNode] + "\\");

                            strPath = strLotSaveImagePath + "\\" + strVisionImageFolderName + "\\" + m_arrRejectNameBuffer[m_intFailStartNode] + "\\";
                        }


                        if (m_smVisionInfo.g_blnViewColorImage)
                            m_arrFailCImage1Buffer[m_intFailStartNode].SaveImage(strPath + m_arrFailNoBuffer[m_intFailStartNode] + "_" + m_arrRejectNameBuffer[m_intFailStartNode] + ".bmp");
                        else
                            m_arrFailImage1Buffer[m_intFailStartNode].SaveImage(strPath + m_arrFailNoBuffer[m_intFailStartNode] + "_" + m_arrRejectNameBuffer[m_intFailStartNode] + ".bmp");

                        if (m_smVisionInfo.g_arrImages.Count > 1)
                        {
                            if (m_smVisionInfo.g_blnViewColorImage)
                                m_arrFailCImage2Buffer[m_intFailStartNode].SaveImage(strPath + m_arrFailNoBuffer[m_intFailStartNode] + "_" + m_arrRejectNameBuffer[m_intFailStartNode] + "_Image1.bmp");
                            else
                                m_arrFailImage2Buffer[m_intFailStartNode].SaveImage(strPath + m_arrFailNoBuffer[m_intFailStartNode] + "_" + m_arrRejectNameBuffer[m_intFailStartNode] + "_Image1.bmp");
                        }

                        if (m_smVisionInfo.g_arrImages.Count > 2)
                        {
                            if (m_smVisionInfo.g_blnViewColorImage)
                                m_arrFailCImage3Buffer[m_intFailStartNode].SaveImage(strPath + m_arrFailNoBuffer[m_intFailStartNode] + "_" + m_arrRejectNameBuffer[m_intFailStartNode] + "_Image2.bmp");
                            else
                                m_arrFailImage3Buffer[m_intFailStartNode].SaveImage(strPath + m_arrFailNoBuffer[m_intFailStartNode] + "_" + m_arrRejectNameBuffer[m_intFailStartNode] + "_Image2.bmp");
                        }

                        if (m_smVisionInfo.g_arrImages.Count > 3)
                        {
                            if (m_smVisionInfo.g_blnViewColorImage)
                                m_arrFailCImage4Buffer[m_intFailStartNode].SaveImage(strPath + m_arrFailNoBuffer[m_intFailStartNode] + "_" + m_arrRejectNameBuffer[m_intFailStartNode] + "_Image3.bmp");
                            else
                                m_arrFailImage4Buffer[m_intFailStartNode].SaveImage(strPath + m_arrFailNoBuffer[m_intFailStartNode] + "_" + m_arrRejectNameBuffer[m_intFailStartNode] + "_Image3.bmp");
                        }

                        if (m_smVisionInfo.g_arrImages.Count > 4)
                        {
                            if (m_smVisionInfo.g_blnViewColorImage)
                                m_arrFailCImage5Buffer[m_intFailStartNode].SaveImage(strPath + m_arrFailNoBuffer[m_intFailStartNode] + "_" + m_arrRejectNameBuffer[m_intFailStartNode] + "_Image4.bmp");
                            else
                                m_arrFailImage5Buffer[m_intFailStartNode].SaveImage(strPath + m_arrFailNoBuffer[m_intFailStartNode] + "_" + m_arrRejectNameBuffer[m_intFailStartNode] + "_Image4.bmp");
                        }

                        if (m_smVisionInfo.g_arrImages.Count > 5)
                        {
                            if (m_smVisionInfo.g_blnViewColorImage)
                                m_arrFailCImage6Buffer[m_intFailStartNode].SaveImage(strPath + m_arrFailNoBuffer[m_intFailStartNode] + "_" + m_arrRejectNameBuffer[m_intFailStartNode] + "_Image5.bmp");
                            else
                                m_arrFailImage6Buffer[m_intFailStartNode].SaveImage(strPath + m_arrFailNoBuffer[m_intFailStartNode] + "_" + m_arrRejectNameBuffer[m_intFailStartNode] + "_Image5.bmp");
                        }

                        if (m_smVisionInfo.g_arrImages.Count > 6)
                        {
                            if (m_smVisionInfo.g_blnViewColorImage)
                                m_arrFailCImage7Buffer[m_intFailStartNode].SaveImage(strPath + m_arrFailNoBuffer[m_intFailStartNode] + "_" + m_arrRejectNameBuffer[m_intFailStartNode] + "_Image6.bmp");
                            else
                                m_arrFailImage7Buffer[m_intFailStartNode].SaveImage(strPath + m_arrFailNoBuffer[m_intFailStartNode] + "_" + m_arrRejectNameBuffer[m_intFailStartNode] + "_Image6.bmp");
                        }

                        m_smVisionInfo.g_strLastImageFolder = strPath;
                        m_smVisionInfo.g_strLastImageName = m_arrFailNoBuffer[m_intFailStartNode] + "_" + m_arrRejectNameBuffer[m_intFailStartNode] + ".bmp";
                        m_arrRejectImageListPath.Add(strPath + m_arrFailNoBuffer[m_intFailStartNode] + "_" + m_arrRejectNameBuffer[m_intFailStartNode] + ".bmp");

                        if ((m_intFailStartNode + 1) == m_smVisionInfo.g_intSaveImageBufferSize)
                        {
                            m_intFailStartNode = 0;
                        }
                        else
                            m_intFailStartNode++;
                    }
                }
            }
            catch (Exception ex)
            {
                SRMMessageBox.Show("Vision1Process.cs > SaveImageBuffer > Ex=" + ex.ToString());
                STTrackLog.WriteLine("Vision1Process.cs > SaveImageBuffer > Ex=" + ex.ToString());

                if (m_blnTrackingON_SaveImageBuffer)
                {
                    STTrackLog.WriteLine(m_strTrackingData_SaveImageBuffer);
                    m_intPassStartNode = m_intPassEndNode = 0;
                    m_intFailStartNode = m_intFailEndNode = 0;
                    m_blnTrackingON_SaveImageBuffer = false;
                }
                else
                    m_blnTrackingON_SaveImageBuffer = true;

            }
        }

        //private void WaitEventDone(ref bool bTriggerEvent, bool bBreakResult)
        //{
        //    while (true)
        //    {
        //        if (bTriggerEvent == bBreakResult)
        //        {
        //            return;
        //        }

        //        Thread.Sleep(1);    // 2018 10 01 - CCENG: Dun use Sleep(0) as it may cause other internal thread hang especially during waiting for grab image done. (Grab frame timeout happen)
        //    }
        //}
        private bool WaitEventDone(ref bool bTriggerEvent, bool bBreakResult, ref bool bReturnResult, string strTrackName)
        {
            HiPerfTimer timeout = new HiPerfTimer();
            timeout.Start();

            while (true)
            {
                if (bTriggerEvent == bBreakResult)
                {
                    return bReturnResult;
                }

#if (RELEASE || RTXRelease || Release_2_12)
                if (timeout.Timing > 10000)
                {
                    STTrackLog.WriteLine(">>>>>>>>>>>>> Vision 1 time out 10 - " + strTrackName);
                    bTriggerEvent = bBreakResult;
                    break;
                }
#endif

                Thread.Sleep(1);    // 2018 10 01 - CCENG: Dun use Sleep(0) as it may cause other internal thread hang especially during waiting for grab image done. (Grab frame timeout happen)
            }

            timeout.Stop();

            return false;
        }

        private void WaitEventDone(ref bool bTriggerEvent1, ref bool bTriggerEvent2, bool bBreakResult1, bool bBreakResult2, string strTrackName)
        {
            HiPerfTimer timeout = new HiPerfTimer();
            timeout.Start();

            while (true)
            {
                if (bTriggerEvent1 == bBreakResult1)
                {
                    return;
                }

                if (bTriggerEvent2 == bBreakResult2)
                {
                    return;
                }

#if (RELEASE || RTXRelease || Release_2_12)
                if (timeout.Timing > 10000)
                {
                    STTrackLog.WriteLine(">>>>>>>>>>>>> Vision 1 time out 11 - " + strTrackName);
                    bTriggerEvent1 = bBreakResult1;
                    bTriggerEvent2 = bBreakResult2;
                    break;
                }
#endif

                Thread.Sleep(1);    // 2018 10 01 - CCENG: Dun use Sleep(0) as it may cause other internal thread hang especially during waiting for grab image done. (Grab frame timeout happen)
            }

            timeout.Stop();
        }

        //private bool WaitEventDone(int[] arrImageIndex, ROIPartition eROIArea, string strTrackName)
        //{
        //    for (int i = 0; i < arrImageIndex.Length; i++)
        //    {
        //        if (eROIArea == ROIPartition.Side)
        //        {
        //            if (m_smVisionInfo.g_intImageMergeType == 0)
        //            {
        //                if (arrImageIndex[i] == 0)
        //                    return WaitEventDone(ref m_bGrabImage1Done, true, ref m_bGrabImage1Result, strTrackName);
        //                else if (arrImageIndex[i] == 1)
        //                    return WaitEventDone(ref m_bGrabImage2Done, true, ref m_bGrabImage2Result, strTrackName);
        //                else if (arrImageIndex[i] == 2)
        //                    return WaitEventDone(ref m_bGrabImage3Done, true, ref m_bGrabImage3Result, strTrackName);
        //                else if (arrImageIndex[i] == 3)
        //                    return WaitEventDone(ref m_bGrabImage4Done, true, ref m_bGrabImage4Result, strTrackName);
        //                else if (arrImageIndex[i] == 4)
        //                    return WaitEventDone(ref m_bGrabImage5Done, true, ref m_bGrabImage5Result, strTrackName);
        //            }
        //            else if (m_smVisionInfo.g_intImageMergeType == 1)   // Merge grab 1 and 2
        //            {
        //                if (arrImageIndex[i] == 0)
        //                    return WaitEventDone(ref m_bGrabImage2Done, true, ref m_bGrabImage1Result, strTrackName);
        //                else if (arrImageIndex[i] == 1)
        //                    return WaitEventDone(ref m_bGrabImage2Done, true, ref m_bGrabImage2Result, strTrackName);
        //                else if (arrImageIndex[i] == 2)
        //                    return WaitEventDone(ref m_bGrabImage3Done, true, ref m_bGrabImage3Result, strTrackName);
        //                else if (arrImageIndex[i] == 3)
        //                    return WaitEventDone(ref m_bGrabImage4Done, true, ref m_bGrabImage4Result, strTrackName);
        //                else if (arrImageIndex[i] == 4)
        //                    return WaitEventDone(ref m_bGrabImage5Done, true, ref m_bGrabImage5Result, strTrackName);
        //            }
        //            else if (m_smVisionInfo.g_intImageMergeType == 3)   // Merge grab 1 and 2, Merge grab 3 and 4
        //            {
        //                if (arrImageIndex[i] == 0)
        //                    return WaitEventDone(ref m_bGrabImage2Done, true, ref m_bGrabImage1Result, strTrackName);
        //                else if (arrImageIndex[i] == 1)
        //                    return WaitEventDone(ref m_bGrabImage2Done, true, ref m_bGrabImage2Result, strTrackName);
        //                else if (arrImageIndex[i] == 2)
        //                    return WaitEventDone(ref m_bGrabImage4Done, true, ref m_bGrabImage3Result, strTrackName);
        //                else if (arrImageIndex[i] == 3)
        //                    return WaitEventDone(ref m_bGrabImage4Done, true, ref m_bGrabImage4Result, strTrackName);
        //                else if (arrImageIndex[i] == 4)
        //                    return WaitEventDone(ref m_bGrabImage5Done, true, ref m_bGrabImage5Result, strTrackName);
        //            }
        //        }
        //        else // Center ROI
        //        {
        //            if (arrImageIndex[i] == 0)
        //                return WaitEventDone(ref m_bGrabImage1Done, true, ref m_bGrabImage1Result, strTrackName);
        //            else if (arrImageIndex[i] == 1)
        //                return WaitEventDone(ref m_bGrabImage2Done, true, ref m_bGrabImage2Result, strTrackName);
        //            else if (arrImageIndex[i] == 2)
        //                return WaitEventDone(ref m_bGrabImage3Done, true, ref m_bGrabImage3Result, strTrackName);
        //            else if (arrImageIndex[i] == 3)
        //                return WaitEventDone(ref m_bGrabImage4Done, true, ref m_bGrabImage4Result, strTrackName);
        //            else if (arrImageIndex[i] == 4)
        //                return WaitEventDone(ref m_bGrabImage5Done, true, ref m_bGrabImage5Result, strTrackName);
        //        }
        //    }

        //    return m_bGrabImageFinalResult_Center;
        //}
        private void WaitImageBufferClear(ref int intStartNode, ref int intEndNode)
        {
            while (true)
            {
                int intNextEndNode = intEndNode + 1;
                if (intNextEndNode >= m_smVisionInfo.g_intSaveImageBufferSize)
                    intNextEndNode = 0;

                if (intNextEndNode != intStartNode)
                {
                    return;
                }

                Thread.Sleep(1);
            }
        }

        private void WaitAllImageGrabDone()
        {
            bool blnReturn = false;

            while (true)
            {
                switch (m_intGrabRequire)
                {
                    case 1:
                        if (m_bGrabImage1Done)
                            blnReturn = true;
                        break;
                    case 2:
                        if (m_bGrabImage2Done)
                            blnReturn = true;
                        break;
                    case 3:
                        if (m_bGrabImage3Done)
                            blnReturn = true;
                        break;
                    case 4:
                        if (m_bGrabImage4Done)
                            blnReturn = true;
                        break;
                    case 5:
                        if (m_bGrabImage5Done)
                            blnReturn = true;
                        break;
                    case 6:
                        if (m_bGrabImage6Done)
                            blnReturn = true;
                        break;
                    case 7:
                        if (m_bGrabImage7Done)
                            blnReturn = true;
                        break;
                }

                if (blnReturn)
                    return;

                Thread.Sleep(1);
            }
        }

        private void LoadRejectImageListPath()
        {
            //string strRejectImageFolderPath = m_smVisionInfo.g_strSaveImageLocation +
            //               m_smProductionInfo.g_strLotID + "_" + m_smProductionInfo.g_strLotStartTime +
            //               "\\" + m_smVisionInfo.g_strVisionFolderName +
            //               "(" + m_smVisionInfo.g_strVisionDisplayName + " " + m_smVisionInfo.g_strVisionNameRemark + ")";

            // 2020 03 27 - JBTAN: Load from different folder if reset count
            string strRejectImageFolderPath;
            if (m_smVisionInfo.g_intVisionResetCount == 0)
            {
                strRejectImageFolderPath = m_smVisionInfo.g_strSaveImageLocation +
                    m_smProductionInfo.g_strLotID + "_" + m_smProductionInfo.g_strLotStartTime +
                    "\\" + m_smVisionInfo.g_strVisionFolderName +
                    "(" + m_smVisionInfo.g_strVisionDisplayName + " " + m_smVisionInfo.g_strVisionNameRemark + ")" + "_" + m_smProductionInfo.g_strLotStartTime;
            }
            else
            {
                strRejectImageFolderPath = m_smVisionInfo.g_strSaveImageLocation +
                    m_smProductionInfo.g_strLotID + "_" + m_smProductionInfo.g_strLotStartTime +
                    "\\" + m_smVisionInfo.g_strVisionFolderName +
                    "(" + m_smVisionInfo.g_strVisionDisplayName + " " + m_smVisionInfo.g_strVisionNameRemark + ")" + "_" + m_smVisionInfo.g_strVisionResetCountTime;
            }

            if (Directory.Exists(strRejectImageFolderPath))
            {
                string[] arrRejectImageFoldderList = Directory.GetDirectories(strRejectImageFolderPath);

                List<int> arrRejectImageNo = new List<int>();
                m_arrRejectImageListPath.Clear();
                m_arrRejectImageErrorMessageListPath.Clear();
                foreach (string strFolderPath in arrRejectImageFoldderList)
                {
                    //2021-02-24 ZJYHEOH : No need to delete pass image
                    if (strFolderPath.Substring(strFolderPath.LastIndexOf('\\') + 1, strFolderPath.Length - strFolderPath.LastIndexOf('\\') - 1) == "Pass")
                        continue;

                    string[] arrRejectImageList = Directory.GetFiles(strFolderPath);
                    foreach (string strFilePath in arrRejectImageList)
                    {
                        if (Path.GetFileName(strFilePath).Contains(".xml"))
                        {
                            continue;
                        }

                        string strFileName = Path.GetFileNameWithoutExtension(strFilePath);

                        if (strFileName.LastIndexOf("_Image") > 0)
                        {
                            continue;
                        }

                        int intFileNo = 0;

                        if (int.TryParse(new string(strFileName
                         .SkipWhile(x => !char.IsDigit(x))
                         .TakeWhile(x => char.IsDigit(x))
                         .ToArray()), out intFileNo))
                        {
                            int intSelectedIndex = arrRejectImageNo.Count;
                            for (int i = 0; i < arrRejectImageNo.Count; i++)
                            {
                                if (intFileNo < arrRejectImageNo[i])
                                {
                                    intSelectedIndex = i;
                                    break;
                                }

                            }

                            m_arrRejectImageListPath.Insert(intSelectedIndex, strFilePath);
                            arrRejectImageNo.Insert(intSelectedIndex, intFileNo);

                            //for error message xml file
                            string strErrorMessagePath = strFilePath.Replace(".bmp", ".xml");
                            if (File.Exists(strErrorMessagePath))
                            {
                                if (intSelectedIndex > m_arrRejectImageErrorMessageListPath.Count)
                                {
                                    if (m_arrRejectImageErrorMessageListPath.Count == 0)
                                        m_arrRejectImageErrorMessageListPath.Insert(0, strErrorMessagePath);
                                    else
                                        m_arrRejectImageErrorMessageListPath.Insert(m_arrRejectImageErrorMessageListPath.Count - 1, strErrorMessagePath);
                                }
                                else
                                    m_arrRejectImageErrorMessageListPath.Insert(intSelectedIndex, strErrorMessagePath);
                            }

                        }

                    }
                }
            }
        }

        public void WaitAllThreadStopped()
        {
            HiPerfTimer timesout = new HiPerfTimer();
            timesout.Start();

            while (true)
            {
                if (m_blnStopped &&
                    m_blnStopped_AfterInspect &&
                    m_blnStopped_SaveImage &&
                    m_blnStopped_GrabImage &&
                    m_blnStopped_MarkTest &&
                    m_blnStopped_PackageTest_MarkLightView &&
                    m_blnStopped_PackageTest_SideLightView &&
                    m_blnStopped_PackageTest_TopLightView &&
                    m_blnStopped_LeadTest &&
                    m_blnStopped_PackageColorTest)
                {
                    STTrackLog.WriteLine("Vision1Process All threads have stopped.");
                    break;
                }

                if (timesout.Timing > 3000)
                {
                    STTrackLog.WriteLine("Vision1Process : m_blnStopped = " + m_blnStopped.ToString());
                    STTrackLog.WriteLine("Vision1Process : m_blnStopped_AfterInspect = " + m_blnStopped_AfterInspect.ToString());
                    STTrackLog.WriteLine("Vision1Process : m_blnStopped_CenterThread = " + m_blnStopped_MarkTest.ToString());
                    STTrackLog.WriteLine("Vision1Process : m_blnStopped_GrabImage = " + m_blnStopped_GrabImage.ToString());
                    STTrackLog.WriteLine("Vision1Process : m_blnStopped_TransferImage = " + m_blnStopped_PackageTest_MarkLightView.ToString());
                    STTrackLog.WriteLine("Vision1Process : m_blnStopped_WaitFrame = " + m_blnStopped_PackageTest_SideLightView.ToString());
                    STTrackLog.WriteLine("Vision1Process : m_blnStopped_SideBRThread = " + m_blnStopped_PackageTest_TopLightView.ToString());
                    STTrackLog.WriteLine("Vision1Process : m_blnStopped_SideTLThread = " + m_blnStopped_LeadTest.ToString());
                    STTrackLog.WriteLine("Vision1Process : m_blnStopped_PackageColorTest = " + m_blnStopped_PackageColorTest.ToString());
                    STTrackLog.WriteLine("Vision1Process : m_blnStopped_SaveImage = " + m_blnStopped_SaveImage.ToString());
                    STTrackLog.WriteLine("Vision1Process : >>>>>>>>>>>>> time out 3");
                    break;
                }

                Thread.Sleep(1);
            }
        }


        private void RecordGRR2()
        {
            // Check GRR turn ON or not
            if (!m_smVisionInfo.g_blnGRRON)
                return;

            try
            {

                string[] strSampleFeature = new string[100];

                int intRecordIndex = 0;

                for (int p = 0; p < m_smVisionInfo.g_arrPackage.Count; p++)
                {

                    //for (int i = 0; i < 2; i++)
                    //{
                    //    if (i == 0)
                    //    {
                    if (!m_smVisionInfo.g_objGRR.Record(0, intRecordIndex, "Package", Convert.ToSingle(m_smVisionInfo.g_arrPackage[p].ref_fUnitResultWidth)))
                        return;
                    //  }
                    //  if (i == 1)
                    //   {
                    if (!m_smVisionInfo.g_objGRR.Record(1, intRecordIndex, "Package", Convert.ToSingle(m_smVisionInfo.g_arrPackage[p].ref_fUnitResultHeight)))
                        return;
                    //  }

                    intRecordIndex++;
                    // }
                }

                m_smVisionInfo.g_objGRR.NextIndex();
            }
            catch (Exception ex)
            {
                SRMMessageBox.Show("Vision 1 GRR Error: " + ex.ToString());
            }
        }

        private void LoadNextImageForDebugRunTest()
        {
            if (m_smVisionInfo.g_arrImageFiles.Count == 0)
                return;

            Random rand = new Random();
            m_smVisionInfo.g_intFileIndex = rand.Next(0, m_smVisionInfo.g_arrImageFiles.Count - 1);

            if (m_smVisionInfo.g_intFileIndex < 0 || m_smVisionInfo.g_intFileIndex >= m_smVisionInfo.g_arrImageFiles.Count)
                m_smVisionInfo.g_intFileIndex = 0;

            string strFileName = m_smVisionInfo.g_arrImageFiles[m_smVisionInfo.g_intFileIndex].ToString();

            if (!m_smVisionInfo.g_blnViewColorImage)
            {
                m_smVisionInfo.g_arrImages[0].LoadImage(strFileName);
                for (int i = 1; i < m_smVisionInfo.g_arrImages.Count; i++)
                {
                    string strDirPath = Path.GetDirectoryName(strFileName);
                    string strPkgView = strDirPath + "\\" + Path.GetFileNameWithoutExtension(strFileName) + "_Image" + i.ToString() + ".BMP";

                    if (File.Exists(strPkgView))
                        m_smVisionInfo.g_arrImages[i].LoadImage(strPkgView);
                    else
                        m_smVisionInfo.g_arrImages[i].LoadImage(strFileName);
                }
            }
            else
            {
                m_smVisionInfo.g_arrColorImages[0].LoadImage(strFileName);
                m_smVisionInfo.g_arrColorImages[0].ConvertColorToMono(ref m_smVisionInfo.g_arrImages, 0);
                for (int i = 1; i < m_smVisionInfo.g_arrColorImages.Count; i++)
                {
                    string strDirPath = Path.GetDirectoryName(strFileName);
                    string strPkgView = strDirPath + "\\" + Path.GetFileNameWithoutExtension(strFileName) + "_Image" + i.ToString() + ".BMP";

                    if (File.Exists(strPkgView))
                        m_smVisionInfo.g_arrColorImages[i].LoadImage(strPkgView);
                    else
                        m_smVisionInfo.g_arrColorImages[i].LoadImage(strFileName);
                    m_smVisionInfo.g_arrColorImages[i].ConvertColorToMono(ref m_smVisionInfo.g_arrImages, i);
                }
            }

            if (++m_smVisionInfo.g_intFileIndex == m_smVisionInfo.g_arrImageFiles.Count)
                m_smVisionInfo.g_intFileIndex = 0;
        }

        private void InitSaveImageBuffer(int intGrabRequire)
        {
            if (m_smVisionInfo.g_blnViewColorImage)
            {
                if (intGrabRequire > 0)
                    m_arrPassCImage1Buffer = new CImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];
                if (intGrabRequire > 1)
                    m_arrPassCImage2Buffer = new CImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];
                if (intGrabRequire > 2)
                    m_arrPassCImage3Buffer = new CImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];
                if (intGrabRequire > 3)
                    m_arrPassCImage4Buffer = new CImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];
                if (intGrabRequire > 4)
                    m_arrPassCImage5Buffer = new CImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];
                if (intGrabRequire > 5)
                    m_arrPassCImage6Buffer = new CImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];
                if (intGrabRequire > 6)
                    m_arrPassCImage7Buffer = new CImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];

                if (intGrabRequire > 0)
                    m_arrFailCImage1Buffer = new CImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];
                if (intGrabRequire > 1)
                    m_arrFailCImage2Buffer = new CImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];
                if (intGrabRequire > 2)
                    m_arrFailCImage3Buffer = new CImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];
                if (intGrabRequire > 3)
                    m_arrFailCImage4Buffer = new CImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];
                if (intGrabRequire > 4)
                    m_arrFailCImage5Buffer = new CImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];
                if (intGrabRequire > 5)
                    m_arrFailCImage6Buffer = new CImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];
                if (intGrabRequire > 6)
                    m_arrFailCImage7Buffer = new CImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];

                for (int i = 0; i < m_smVisionInfo.g_intSaveImageBufferSize; i++)
                {
                    if (intGrabRequire > 0)
                        m_arrPassCImage1Buffer[i] = new CImageDrawing(true);
                    if (intGrabRequire > 1)
                        m_arrPassCImage2Buffer[i] = new CImageDrawing(true);
                    if (intGrabRequire > 2)
                        m_arrPassCImage3Buffer[i] = new CImageDrawing(true);
                    if (intGrabRequire > 3)
                        m_arrPassCImage4Buffer[i] = new CImageDrawing(true);
                    if (intGrabRequire > 4)
                        m_arrPassCImage5Buffer[i] = new CImageDrawing(true);
                    if (intGrabRequire > 5)
                        m_arrPassCImage6Buffer[i] = new CImageDrawing(true);
                    if (intGrabRequire > 6)
                        m_arrPassCImage7Buffer[i] = new CImageDrawing(true);

                    if (intGrabRequire > 0)
                        m_arrFailCImage1Buffer[i] = new CImageDrawing(true);
                    if (intGrabRequire > 1)
                        m_arrFailCImage2Buffer[i] = new CImageDrawing(true);
                    if (intGrabRequire > 2)
                        m_arrFailCImage3Buffer[i] = new CImageDrawing(true);
                    if (intGrabRequire > 3)
                        m_arrFailCImage4Buffer[i] = new CImageDrawing(true);
                    if (intGrabRequire > 4)
                        m_arrFailCImage5Buffer[i] = new CImageDrawing(true);
                    if (intGrabRequire > 5)
                        m_arrFailCImage6Buffer[i] = new CImageDrawing(true);
                    if (intGrabRequire > 6)
                        m_arrFailCImage7Buffer[i] = new CImageDrawing(true);
                }
            }
            else
            {
                if (intGrabRequire > 0)
                    m_arrPassImage1Buffer = new ImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];
                if (intGrabRequire > 1)
                    m_arrPassImage2Buffer = new ImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];
                if (intGrabRequire > 2)
                    m_arrPassImage3Buffer = new ImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];
                if (intGrabRequire > 3)
                    m_arrPassImage4Buffer = new ImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];
                if (intGrabRequire > 4)
                    m_arrPassImage5Buffer = new ImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];
                if (intGrabRequire > 5)
                    m_arrPassImage6Buffer = new ImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];
                if (intGrabRequire > 6)
                    m_arrPassImage7Buffer = new ImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];

                if (intGrabRequire > 0)
                    m_arrFailImage1Buffer = new ImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];
                if (intGrabRequire > 1)
                    m_arrFailImage2Buffer = new ImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];
                if (intGrabRequire > 2)
                    m_arrFailImage3Buffer = new ImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];
                if (intGrabRequire > 3)
                    m_arrFailImage4Buffer = new ImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];
                if (intGrabRequire > 4)
                    m_arrFailImage5Buffer = new ImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];
                if (intGrabRequire > 5)
                    m_arrFailImage6Buffer = new ImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];
                if (intGrabRequire > 6)
                    m_arrFailImage7Buffer = new ImageDrawing[m_smVisionInfo.g_intSaveImageBufferSize];

                for (int i = 0; i < m_smVisionInfo.g_intSaveImageBufferSize; i++)
                {
                    if (intGrabRequire > 0)
                        m_arrPassImage1Buffer[i] = new ImageDrawing(true);
                    if (intGrabRequire > 1)
                        m_arrPassImage2Buffer[i] = new ImageDrawing(true);
                    if (intGrabRequire > 2)
                        m_arrPassImage3Buffer[i] = new ImageDrawing(true);
                    if (intGrabRequire > 3)
                        m_arrPassImage4Buffer[i] = new ImageDrawing(true);
                    if (intGrabRequire > 4)
                        m_arrPassImage5Buffer[i] = new ImageDrawing(true);
                    if (intGrabRequire > 5)
                        m_arrPassImage6Buffer[i] = new ImageDrawing(true);
                    if (intGrabRequire > 6)
                        m_arrPassImage7Buffer[i] = new ImageDrawing(true);

                    if (intGrabRequire > 0)
                        m_arrFailImage1Buffer[i] = new ImageDrawing(true);
                    if (intGrabRequire > 1)
                        m_arrFailImage2Buffer[i] = new ImageDrawing(true);
                    if (intGrabRequire > 2)
                        m_arrFailImage3Buffer[i] = new ImageDrawing(true);
                    if (intGrabRequire > 3)
                        m_arrFailImage4Buffer[i] = new ImageDrawing(true);
                    if (intGrabRequire > 4)
                        m_arrFailImage5Buffer[i] = new ImageDrawing(true);
                    if (intGrabRequire > 5)
                        m_arrFailImage6Buffer[i] = new ImageDrawing(true);
                    if (intGrabRequire > 6)
                        m_arrFailImage7Buffer[i] = new ImageDrawing(true);
                }
            }
            m_arrPassNoBuffer = new int[m_smVisionInfo.g_intSaveImageBufferSize];
            m_arrFailNoBuffer = new int[m_smVisionInfo.g_intSaveImageBufferSize];
            m_arrOrientationBuffer = new int[m_smVisionInfo.g_intSaveImageBufferSize];
            m_arrRejectNameBuffer = new string[m_smVisionInfo.g_intSaveImageBufferSize];
            m_arrRejectMessageBuffer = new string[m_smVisionInfo.g_intSaveImageBufferSize];

        }

        private bool StartLeadTest_MultiThreading(bool blnAuto)
        {
            bool blnWantDebug = false;
            bool bWholeTestFail = false;
            m_fLeadPatternScore = 0;
            m_fLeadPatternAngle = 0;
            if ((m_smCustomizeInfo.g_intWantLead & (1 << m_smVisionInfo.g_intVisionPos)) == 0 || !m_smVisionInfo.g_arrLead[0].GetWantInspectLead())//!m_smVisionInfo.g_blnCheckLead
                return true;

            if (m_smVisionInfo.g_arrLeadROIs[0].Count == 0)
            {
                m_bLeadBaseCenterPointDone = true;
                m_bLeadBaseCenterPointResult = false;

                if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                {
                    WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_MarkTest 1");
                    if (!m_bSubTh_MarkTest_Result)
                    {
                        return false;
                    }

                    WaitEventDone(ref m_bSubTh_PackageTest_MarkLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_MarkLightView 1");
                    if (!m_bSubTh_PackageTest_MarkLightView_Result)
                    {
                        return false;
                    }

                    WaitEventDone(ref m_bSubTh_PackageTest_SideLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_SideLightView 1");
                    if (!m_bSubTh_PackageTest_SideLightView_Result)
                    {
                        return false;
                    }

                    WaitEventDone(ref m_bSubTh_PackageTest_TopLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_TopLightView 1");
                    if (!m_bSubTh_PackageTest_TopLightView_Result)
                    {
                        return false;
                    }
                }

                m_smVisionInfo.g_strErrorMessage += "*Lead : No Template Found";
                if (blnAuto)
                {
                    m_smVisionInfo.g_intNoTemplateFailureTotal++;
                }

                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        m_intTCPIPResultID = (int)TCPIPResulID.Fail;

                return false;
            }
            // Reset inspection drawing
            for (int i = 0; i < m_smVisionInfo.g_arrLead.Length; i++)
            {
                m_smVisionInfo.g_arrLead[i].ref_blnViewLeadResultDrawing = false;

                if (!m_smVisionInfo.g_arrLead[i].ref_blnSelected)
                    continue;

                if ((m_smVisionInfo.g_arrLead[i].GetBlobsFeaturesNumber() == 0) || (m_smVisionInfo.g_arrLead[0].ref_blnWantInspectBaseLead && (m_smVisionInfo.g_arrLead[i].GetBlobsFeaturesNumber_BaseLead() == 0)))
                {
                    m_bLeadBaseCenterPointDone = true;
                    m_bLeadBaseCenterPointResult = false;

                    if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                    {
                        WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_MarkTest 1");
                        if (!m_bSubTh_MarkTest_Result)
                        {
                            return false;
                        }

                        WaitEventDone(ref m_bSubTh_PackageTest_MarkLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_MarkLightView 1");
                        if (!m_bSubTh_PackageTest_MarkLightView_Result)
                        {
                            return false;
                        }

                        WaitEventDone(ref m_bSubTh_PackageTest_SideLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_SideLightView 1");
                        if (!m_bSubTh_PackageTest_SideLightView_Result)
                        {
                            return false;
                        }

                        WaitEventDone(ref m_bSubTh_PackageTest_TopLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_TopLightView 1");
                        if (!m_bSubTh_PackageTest_TopLightView_Result)
                        {
                            return false;
                        }
                    }

                    if (m_smVisionInfo.g_arrLead[0].ref_blnWantInspectBaseLead && (m_smVisionInfo.g_arrLead[i].GetBlobsFeaturesNumber_BaseLead() == 0))
                        m_smVisionInfo.g_strErrorMessage += "*Lead : Base Lead Template is Empty";
                    else
                        m_smVisionInfo.g_strErrorMessage += "*Lead : Lead Template is Empty";
                    if (m_blnAuto)
                    {
                        m_smVisionInfo.g_intNoTemplateFailureTotal++;
                    }
                    if (blnAuto)
                    {
                        if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                            if (m_intTCPIPResultID == -1)
                                m_intTCPIPResultID = (int)TCPIPResulID.Fail;
                    }
                    return false;
                }
            }
            //m_smVisionInfo.g_objLeadImage.SaveImage("D:\\LeadImage1.bmp");
            //m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo].CopyTo(ref m_smVisionInfo.g_objLeadImage);

            bool blnFailPocketReference = false;
            if (m_smVisionInfo.g_blnWantPocketDontCareAreaFix_Lead)
            {
                for (int i = 1; i < m_smVisionInfo.g_arrLead.Length; i++)
                {
                    string strPosition = GetLeadDefinition(i);

                    if ((i == 1) && ((m_smVisionInfo.g_intLeadPocketDontCareROIFixMask & 0x01) == 0))
                        continue;
                    else if ((i == 2) && ((m_smVisionInfo.g_intLeadPocketDontCareROIFixMask & 0x02) == 0))
                        continue;
                    else if ((i == 3) && ((m_smVisionInfo.g_intLeadPocketDontCareROIFixMask & 0x04) == 0))
                        continue;
                    else if ((i == 4) && ((m_smVisionInfo.g_intLeadPocketDontCareROIFixMask & 0x08) == 0))
                        continue;

                    if (!FindFixPocket(i))
                    {
                        if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                        {
                            m_bLeadBaseCenterPointDone = true;
                            m_bLeadBaseCenterPointResult = false;

                            WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_MarkTest 1");
                            if (!m_bSubTh_MarkTest_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_MarkLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_MarkLightView 1");
                            if (!m_bSubTh_PackageTest_MarkLightView_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_SideLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_SideLightView 1");
                            if (!m_bSubTh_PackageTest_SideLightView_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_TopLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_TopLightView 1");
                            if (!m_bSubTh_PackageTest_TopLightView_Result)
                            {
                                return false;
                            }
                        }

                        blnFailPocketReference = true;
                        bWholeTestFail = true;
                        m_smVisionInfo.g_strErrorMessage = strPosition + m_smVisionInfo.g_strErrorMessage;

                        if (blnAuto)
                        {
                            SaveRejectImage_AddToBuffer("Lead", m_smVisionInfo.g_strErrorMessage);    // Should save then
                        }
                        if (blnAuto)
                        {
                            m_smVisionInfo.g_intLeadFailureTotal++;
                        }
                        if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                            break;
                    }
                }
            }
            else if (m_smVisionInfo.g_blnWantPocketDontCareAreaManual_Lead)
            {
                for (int i = 1; i < m_smVisionInfo.g_arrLead.Length; i++)
                {
                    string strPosition = GetLeadDefinition(i);

                    if ((i == 1) && ((m_smVisionInfo.g_intLeadPocketDontCareROIManualMask & 0x01) == 0))
                        continue;
                    else if ((i == 2) && ((m_smVisionInfo.g_intLeadPocketDontCareROIManualMask & 0x02) == 0))
                        continue;
                    else if ((i == 3) && ((m_smVisionInfo.g_intLeadPocketDontCareROIManualMask & 0x04) == 0))
                        continue;
                    else if ((i == 4) && ((m_smVisionInfo.g_intLeadPocketDontCareROIManualMask & 0x08) == 0))
                        continue;

                    if (!FindManualPocketReference(i))
                    {
                        if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                        {
                            m_bLeadBaseCenterPointDone = true;
                            m_bLeadBaseCenterPointResult = false;

                            WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_MarkTest 1");
                            if (!m_bSubTh_MarkTest_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_MarkLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_MarkLightView 1");
                            if (!m_bSubTh_PackageTest_MarkLightView_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_SideLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_SideLightView 1");
                            if (!m_bSubTh_PackageTest_SideLightView_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_TopLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_TopLightView 1");
                            if (!m_bSubTh_PackageTest_TopLightView_Result)
                            {
                                return false;
                            }
                        }

                        blnFailPocketReference = true;
                        bWholeTestFail = true;
                        m_smVisionInfo.g_strErrorMessage = strPosition + m_smVisionInfo.g_strErrorMessage;

                        if (blnAuto)
                        {
                            SaveRejectImage_AddToBuffer("Lead", m_smVisionInfo.g_strErrorMessage);    // Should save then
                        }
                        if (blnAuto)
                        {
                            m_smVisionInfo.g_intLeadFailureTotal++;
                        }
                        if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                            break;
                    }
                }
            }
            else if (m_smVisionInfo.g_blnWantPocketDontCareAreaAuto_Lead)
            {
                if (blnWantDebug)
                {
                    m_smVisionInfo.g_objLeadImage.SaveImage("D:\\TS\\1.g_objLeadImage.bmp");
                }
                ImageDrawing objImg = new ImageDrawing(true);
                m_smVisionInfo.g_objLeadImage.CopyTo(objImg);
                for (int i = 1; i < m_smVisionInfo.g_arrLead.Length; i++)
                {
                    string strPosition = GetLeadDefinition(i);

                    if ((i == 1) && ((m_smVisionInfo.g_intLeadPocketDontCareROIAutoMask & 0x01) == 0))
                        continue;
                    else if ((i == 2) && ((m_smVisionInfo.g_intLeadPocketDontCareROIAutoMask & 0x02) == 0))
                        continue;
                    else if ((i == 3) && ((m_smVisionInfo.g_intLeadPocketDontCareROIAutoMask & 0x04) == 0))
                        continue;
                    else if ((i == 4) && ((m_smVisionInfo.g_intLeadPocketDontCareROIAutoMask & 0x08) == 0))
                        continue;

                    if (!FindAutoPocketReference(i, objImg))
                    {
                        if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                        {
                            m_bLeadBaseCenterPointDone = true;
                            m_bLeadBaseCenterPointResult = false;

                            WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_MarkTest 1");
                            if (!m_bSubTh_MarkTest_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_MarkLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_MarkLightView 1");
                            if (!m_bSubTh_PackageTest_MarkLightView_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_SideLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_SideLightView 1");
                            if (!m_bSubTh_PackageTest_SideLightView_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_TopLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_TopLightView 1");
                            if (!m_bSubTh_PackageTest_TopLightView_Result)
                            {
                                return false;
                            }
                        }

                        blnFailPocketReference = true;
                        bWholeTestFail = true;
                        m_smVisionInfo.g_strErrorMessage = strPosition + m_smVisionInfo.g_strErrorMessage;

                        if (blnAuto)
                        {
                            SaveRejectImage_AddToBuffer("Lead", m_smVisionInfo.g_strErrorMessage);    // Should save then
                        }
                        if (blnAuto)
                        {
                            m_smVisionInfo.g_intLeadFailureTotal++;
                        }
                        if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                            break;
                    }
                }
                objImg.Dispose();

                if (blnWantDebug)
                {
                    m_smVisionInfo.g_objLeadImage.SaveImage("D:\\TS\\2.g_objLeadImage.bmp");
                }
            }
            else if (m_smVisionInfo.g_blnWantPocketDontCareAreaBlob_Lead)
            {
                m_smVisionInfo.g_arrInwardDontCareROIBlobLimit = new List<float>(5) { 0, 0, 0, 0, 0 };

                for (int i = 1; i < m_smVisionInfo.g_arrLead.Length; i++)
                {
                    string strPosition = GetLeadDefinition(i);

                    if ((i == 1) && ((m_smVisionInfo.g_intLeadPocketDontCareROIBlobMask & 0x01) == 0))
                        continue;
                    else if ((i == 2) && ((m_smVisionInfo.g_intLeadPocketDontCareROIBlobMask & 0x02) == 0))
                        continue;
                    else if ((i == 3) && ((m_smVisionInfo.g_intLeadPocketDontCareROIBlobMask & 0x04) == 0))
                        continue;
                    else if ((i == 4) && ((m_smVisionInfo.g_intLeadPocketDontCareROIBlobMask & 0x08) == 0))
                        continue;

                    FindPocketShadowBlob(i, ref m_smVisionInfo.g_arrInwardDontCareROIBlobLimit);
                }

                if (blnWantDebug)
                {
                    m_smVisionInfo.g_objLeadImage.SaveImage("D:\\TS\\1.g_objLeadImage.bmp");
                }

                if (m_smVisionInfo.g_arrLead[0].ref_blnFlipToOppositeFunction && m_smVisionInfo.g_arrInwardDontCareROIBlobLimit.Contains(-1))
                {
                    FlipToOpposite_DontCareBlob(m_smVisionInfo.g_arrInwardDontCareROIBlobLimit);
                    if (blnWantDebug)
                    {
                        m_smVisionInfo.g_objLeadImage.SaveImage("D:\\TS\\2.g_objLeadImage.bmp");
                    }
                }
            }

            //// 2020-08-11 ZJYEOH : Only need Orient data to rotate when got package
            //if (m_blnWantPackageTest)
            //    WaitEventDone(ref m_blnOrientDataUpdated, true, 10000, "UpdateSubProgress_LeadTest > m_blnOrientDataUpdated 9136");

            if (!blnFailPocketReference || m_smVisionInfo.AT_VM_OfflineTestAllLead)
            {
                WaitEventDone(ref m_blnOrientDataUpdated, true, 10000, "UpdateSubProgress_LeadTest > m_blnOrientDataUpdated 9136");

                if (m_blnWantPackageTest && ((m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailMask & 0x1000) > 0 || m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetWantInspectPackage() || GetWantInspectPackageColor(m_smVisionInfo.g_intSelectedUnit)))
                {
                    //2019-10-02 ZJYEOH : If Lead Image not same with Package, then use package gauge angle to rotate
                    WaitEventDone(ref m_bPackageSizePreTestDone, true, 10000, "StartLeadTest_MultiThreading > m_bPackageSizePreTestDone 10694");

                    if (!m_bPackageSizePreTestResult && !m_smVisionInfo.AT_VM_OfflineTestAllLead)
                        return true; // No need to check lead anymore if package size fail

                    if (m_bPackageSizePreTestResult)
                    {
                        float fTotalRotateAngle = m_intOrientAngle + m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle;
                        m_fLeadPatternAngle = m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle;
                        // Get RotateROI where the ROI center point == Unit Center Point
                        ROI objROI = new ROI();
                        objROI.LoadROISetting(m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIPositionX, m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIPositionY, m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIWidth, m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIHeight);
                        objROI.AttachImage(m_smVisionInfo.g_objLeadImage);
                        objROI.SetPosition_Center(m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X, m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y);

                        ROI.Rotate0Degree(objROI, fTotalRotateAngle, 4, ref m_smVisionInfo.g_objLeadImage);

                        if (m_smVisionInfo.g_pLeadDontCareRotateCenter == new Point(-1, -1))
                            m_smVisionInfo.g_pLeadDontCareRotateCenter = new Point(objROI.ref_ROITotalCenterX, objROI.ref_ROITotalCenterY);

                        m_smVisionInfo.g_arrLeadROIs[0][0].AttachImage(m_smVisionInfo.g_objLeadImage);

                        if (m_smVisionInfo.g_arrLead[0].ref_blnWantInspectBaseLead &&
                           ((m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo != m_smVisionInfo.g_arrLead[0].ref_intImageViewNo) &&
                           (!m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetWantInspectPackage() ||
                            (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo != m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetGrabImageIndex(2) &&
                             m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo != m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetGrabImageIndex(3)))))
                        {
                            objROI.AttachImage(m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo]);
                            ROI.Rotate0Degree(objROI, fTotalRotateAngle, 4, ref m_smVisionInfo.g_arrRotatedImages, m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo);

                            if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 0)
                                m_blnRotateImage1Updated = true;
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 1)
                                m_blnRotateImage2Updated = true;
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 2)
                                m_blnRotateImage3Updated = true;
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 3)
                                m_blnRotateImage4Updated = true;
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 4)
                                m_blnRotateImage5Updated = true;
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 5)
                                m_blnRotateImage6Updated = true;
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 6)
                                m_blnRotateImage7Updated = true;

                        }

                        m_smVisionInfo.g_arrLead[0].ref_fRotateCenterX_ForDrawing = objROI.ref_ROITotalCenterX;
                        m_smVisionInfo.g_arrLead[0].ref_fRotateCenterY_ForDrawing = objROI.ref_ROITotalCenterY;

                        objROI.Dispose();
                    }
                    else
                    {
                        m_smVisionInfo.g_arrLeadROIs[0][0].AttachImage(m_smVisionInfo.g_objLeadImage);
                    }

                    for (int i = 1; i < m_smVisionInfo.g_arrLead.Length; i++)
                    {
                        if (!m_smVisionInfo.g_arrLead[i].ref_blnSelected)
                            continue;

                        m_smVisionInfo.g_arrLeadROIs[i][0].AttachImage(m_smVisionInfo.g_objLeadImage);
                    }

                    if (m_bPackageSizePreTestResult)
                    {
                        //2020-07-23 ZJYEOH : In case not same image with package then need Copy To m_smVisionInfo.g_arrRotatedImages so that displayed image is rotated
                        if (!m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetWantInspectPackage() || ((m_smVisionInfo.g_arrLead[0].ref_intImageViewNo != m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetGrabImageIndex(2)
                        && m_smVisionInfo.g_arrLead[0].ref_intImageViewNo != m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetGrabImageIndex(3))))
                        {
                            //m_smVisionInfo.g_objLeadImage.CopyTo(m_smVisionInfo.g_arrRotatedImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo]);

                            float fTotalRotateAngle = m_intOrientAngle + m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle;
                            ROI objROI = new ROI();
                            objROI.LoadROISetting(m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIPositionX, m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIPositionY, m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIWidth, m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIHeight);
                            objROI.AttachImage(m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo]);
                            objROI.SetPosition_Center(m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X, m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y);

                            ROI.Rotate0Degree(objROI, fTotalRotateAngle, 4, ref m_smVisionInfo.g_arrRotatedImages, m_smVisionInfo.g_arrLead[0].ref_intImageViewNo);

                            objROI.Dispose();

                            if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 0)
                                m_blnRotateImage1Updated = true;
                            else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 1)
                                m_blnRotateImage2Updated = true;
                            else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 2)
                                m_blnRotateImage3Updated = true;
                            else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 3)
                                m_blnRotateImage4Updated = true;
                            else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 4)
                                m_blnRotateImage5Updated = true;
                            else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 5)
                                m_blnRotateImage6Updated = true;
                            else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 6)
                                m_blnRotateImage7Updated = true;

                        }
                    }

                    for (int j = 0; j < m_smVisionInfo.g_arrLead.Length; j++)
                    {
                        if (m_smVisionInfo.g_arrLead[j].ref_blnSelected)
                        {
                            if (m_smVisionInfo.g_arrLead[0].ref_blnWantUsePkgToBaseTolerance)
                                m_smVisionInfo.g_arrLead[j].AssignLineGaugeDataFromPackageGaugeM4L(m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X, m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y, m_smVisionInfo.g_objGauge_PkgSize.ref_fRectWidth, m_smVisionInfo.g_objGauge_PkgSize.ref_fRectHeight, m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle);
                        }
                    }
                }
                //else if(m_intOrientAngle != 0)
                //{
                //    float fTotalRotateAngle = m_intOrientAngle;

                //    // Get RotateROI where the ROI center point == Unit Center Point
                //    ROI objROI = new ROI();
                //    objROI.LoadROISetting(m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIPositionX, m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIPositionY, m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIWidth, m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIHeight);
                //    objROI.AttachImage(m_smVisionInfo.g_objLeadImage);

                //    ROI.Rotate0Degree(objROI, fTotalRotateAngle, 4, ref m_smVisionInfo.g_objLeadImage);

                //    m_smVisionInfo.g_arrLeadROIs[0][0].AttachImage(m_smVisionInfo.g_objLeadImage);

                //    if (m_smVisionInfo.g_arrLead[0].ref_blnWantInspectBaseLead)
                //    {
                //        objROI.AttachImage(m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo]);
                //        ROI.Rotate0Degree(objROI, fTotalRotateAngle, 4, ref m_smVisionInfo.g_arrRotatedImages, m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo);

                //        if ((m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo != m_smVisionInfo.g_arrLead[0].ref_intImageViewNo) && (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo != m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetGrabImageIndex(2)
                //           && m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo != m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetGrabImageIndex(3)))
                //        {
                //            if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 0)
                //                m_blnRotateImage1Updated = true;
                //            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 1)
                //                m_blnRotateImage2Updated = true;
                //            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 2)
                //                m_blnRotateImage3Updated = true;
                //            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 3)
                //                m_blnRotateImage4Updated = true;
                //            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 4)
                //                m_blnRotateImage5Updated = true;
                //            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 5)
                //                m_blnRotateImage6Updated = true;
                //            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 6)
                //                m_blnRotateImage7Updated = true;

                //        }
                //    }

                //    if (m_blnWantPackageTest)
                //    {
                //        //2020-07-23 ZJYEOH : In case not same image with package then need Copy To m_smVisionInfo.g_arrRotatedImages so that displayed image is rotated
                //        if ((m_smVisionInfo.g_arrLead[0].ref_intImageViewNo != m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetGrabImageIndex(2)
                //        && m_smVisionInfo.g_arrLead[0].ref_intImageViewNo != m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetGrabImageIndex(3)))
                //        {
                //            //m_smVisionInfo.g_objLeadImage.CopyTo(m_smVisionInfo.g_arrRotatedImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo]);

                //            objROI.LoadROISetting(m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIPositionX, m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIPositionY, m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIWidth, m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIHeight);
                //            objROI.AttachImage(m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo]);

                //            ROI.Rotate0Degree(objROI, fTotalRotateAngle, 4, ref m_smVisionInfo.g_arrRotatedImages, m_smVisionInfo.g_arrLead[0].ref_intImageViewNo);

                //            objROI.Dispose();

                //            if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 0)
                //                m_blnRotateImage1Updated = true;
                //            else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 1)
                //                m_blnRotateImage2Updated = true;
                //            else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 2)
                //                m_blnRotateImage3Updated = true;
                //            else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 3)
                //                m_blnRotateImage4Updated = true;
                //            else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 4)
                //                m_blnRotateImage5Updated = true;
                //            else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 5)
                //                m_blnRotateImage6Updated = true;
                //            else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 6)
                //                m_blnRotateImage7Updated = true;

                //        }
                //    }

                //    objROI.Dispose();

                //}

                //m_smVisionInfo.g_objLeadImage.SaveImage("D:\\LeadImage2.bmp");
            }

            if (!blnFailPocketReference || m_smVisionInfo.AT_VM_OfflineTestAllLead)
            {
                if (m_blnWantPackageTest && ((m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailMask & 0x1000) == 0 && !m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetWantInspectPackage() && !GetWantInspectPackageColor(m_smVisionInfo.g_intSelectedUnit)) && (m_smVisionInfo.g_arrLead[0].ref_intRotationMethod == 2 || m_smVisionInfo.g_arrLead[0].ref_blnWantUsePkgToBaseTolerance))//&& m_smVisionInfo.g_arrLead[0].ref_blnWantUsePkgToBaseTolerance)
                {
                    if (m_smVisionInfo.g_objGauge_PkgSize == null)
                    {
                        m_smVisionInfo.g_objGauge_PkgSize = new RectGaugeM4L(m_smVisionInfo.g_WorldShape, 0, m_smVisionInfo.g_intVisionIndex);
                    }
                    m_smVisionInfo.g_arrPackageGaugeM4L[m_smVisionInfo.g_intSelectedUnit].CopyTo(ref m_smVisionInfo.g_objGauge_PkgSize);

                    bool blnResult = true;
                    blnResult = m_smVisionInfo.g_objGauge_PkgSize.Measure_WithDontCareArea(m_smVisionInfo.g_arrImages, m_smVisionInfo.g_objWhiteImage);

                    if (!blnResult)
                    {
                        m_bLeadBaseCenterPointDone = true;
                        m_bLeadBaseCenterPointResult = false;

                        if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                        {
                            WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_MarkTest 1");
                            if (!m_bSubTh_MarkTest_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_MarkLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_MarkLightView 1");
                            if (!m_bSubTh_PackageTest_MarkLightView_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_SideLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_SideLightView 1");
                            if (!m_bSubTh_PackageTest_SideLightView_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_TopLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_TopLightView 1");
                            if (!m_bSubTh_PackageTest_TopLightView_Result)
                            {
                                return false;
                            }
                        }

                        bWholeTestFail = true;
                        m_smVisionInfo.g_strErrorMessage = m_smVisionInfo.g_strErrorMessage + m_smVisionInfo.g_objGauge_PkgSize.ref_strErrorMessage;

                        if (blnAuto)
                        {
                            m_smVisionInfo.g_intEdgeNotFoundFailureTotal++;
                            SaveRejectImage_AddToBuffer("EdgeNotFound", m_smVisionInfo.g_strErrorMessage);    // Should save then
                        }
                        blnFailPocketReference = true;
                        bWholeTestFail = true;
                    }
                    else
                    {
                        for (int j = 0; j < m_smVisionInfo.g_arrLead.Length; j++)
                        {
                            if (m_smVisionInfo.g_arrLead[j].ref_blnSelected)
                            {
                                if (m_smVisionInfo.g_arrLead[0].ref_blnWantUsePkgToBaseTolerance)
                                    m_smVisionInfo.g_arrLead[j].AssignLineGaugeDataFromPackageGaugeM4L(m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X, m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y, m_smVisionInfo.g_objGauge_PkgSize.ref_fRectWidth, m_smVisionInfo.g_objGauge_PkgSize.ref_fRectHeight, m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle);
                            }
                        }

                    }
                }
                else if (!m_blnWantPackageTest && m_smVisionInfo.g_arrLead[0].ref_intRotationMethod == 2)//&& m_smVisionInfo.g_arrLead[0].ref_blnWantUsePkgToBaseTolerance)
                {
                    if (m_smVisionInfo.g_objGauge_PkgSize == null)
                    {
                        m_smVisionInfo.g_objGauge_PkgSize = new RectGaugeM4L(m_smVisionInfo.g_WorldShape, 0, m_smVisionInfo.g_intVisionIndex);
                    }
                    m_smVisionInfo.g_arrPackageGaugeM4L[m_smVisionInfo.g_intSelectedUnit].CopyTo(ref m_smVisionInfo.g_objGauge_PkgSize);

                    //HiPerfTimer t1 = new HiPerfTimer();
                    //t1.Start();
                    //float fPrev = 0;
                    //string strT = "";
                    //float fTime;

                    bool blnResult = true;
                    blnResult = m_smVisionInfo.g_objGauge_PkgSize.Measure_WithDontCareArea(m_smVisionInfo.g_arrImages, m_smVisionInfo.g_arrLeadROIs[0][0], m_smVisionInfo.g_objWhiteImage);

                    //fTime = t1.Timing;
                    //strT += ", M=" + (fTime - fPrev).ToString("F4");
                    //t1.Stop();
                    //float fT = t1.Duration;

                    if (!blnResult)
                    {
                        m_bLeadBaseCenterPointDone = true;
                        m_bLeadBaseCenterPointResult = false;

                        if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                        {
                            WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_MarkTest 1");
                            if (!m_bSubTh_MarkTest_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_MarkLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_MarkLightView 1");
                            if (!m_bSubTh_PackageTest_MarkLightView_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_SideLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_SideLightView 1");
                            if (!m_bSubTh_PackageTest_SideLightView_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_TopLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_TopLightView 1");
                            if (!m_bSubTh_PackageTest_TopLightView_Result)
                            {
                                return false;
                            }
                        }

                        bWholeTestFail = true;
                        m_smVisionInfo.g_strErrorMessage = m_smVisionInfo.g_strErrorMessage + m_smVisionInfo.g_objGauge_PkgSize.ref_strErrorMessage;

                        if (blnAuto)
                        {
                            m_smVisionInfo.g_intEdgeNotFoundFailureTotal++;
                            SaveRejectImage_AddToBuffer("EdgeNotFound", m_smVisionInfo.g_strErrorMessage);    // Should save then
                        }
                        blnFailPocketReference = true;
                        bWholeTestFail = true;
                    }
                    else
                    {
                        for (int j = 0; j < m_smVisionInfo.g_arrLead.Length; j++)
                        {
                            if (m_smVisionInfo.g_arrLead[j].ref_blnSelected)
                            {
                                if (m_smVisionInfo.g_arrLead[0].ref_blnWantUsePkgToBaseTolerance)
                                    m_smVisionInfo.g_arrLead[j].AssignLineGaugeDataFromPackageGaugeM4L(m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X, m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y, m_smVisionInfo.g_objGauge_PkgSize.ref_fRectWidth, m_smVisionInfo.g_objGauge_PkgSize.ref_fRectHeight, m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle);
                            }
                        }

                    }
                }
            }

            float fTotalX = 0, fTotalY = 0;
            int intCount = 0;
            // Reset each arrLead[] inspection data
            // find unit usign Partition Unit PR 
            // Record match angle using the highest score of partition Unit PR
            // Total up the match partition unit PR center point.
            if (!blnFailPocketReference || m_smVisionInfo.AT_VM_OfflineTestAllLead)
            {
                //HiPerfTimer t1 = new HiPerfTimer();
                //t1.Start();
                //float fPrev = 0;
                //string strT = "";
                //float fTime;
                // Loop Lead Test From Up, Right, Down to Left
                for (int i = 0; i < m_smVisionInfo.g_arrLead.Length; i++)
                {
                    if (i == 0)
                        m_smVisionInfo.g_arrLead[i].ResetInspectionData();

                    if (!m_smVisionInfo.g_arrLead[i].ref_blnSelected)
                        continue;

                    m_smVisionInfo.g_arrLead[i].ref_blnLock = true;

                    // Reset previous inspection data
                    m_smVisionInfo.g_arrLead[i].ResetInspectionData();

                    // Identify Lead definition for displaying fail message
                    string strPosition = GetLeadDefinition(i);

                    //fTime = t1.Timing;
                    //strT += ", M=" + (fTime - fPrev).ToString("F4");
                    //fPrev = fTime;
                    bool blnRecordPatternAngle = true;
                    if (m_blnWantPackageTest && ((m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailMask & 0x1000) > 0 || m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetWantInspectPackage() || GetWantInspectPackageColor(m_smVisionInfo.g_intSelectedUnit)))
                        blnRecordPatternAngle = false;
                    //Find unit
                    if (!FindUnit(i, m_smVisionInfo.g_arrLead[i].ref_intLeadAngleTolerance, blnRecordPatternAngle))
                    {
                        if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                        {
                            m_bLeadBaseCenterPointDone = true;
                            m_bLeadBaseCenterPointResult = false;

                            WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_MarkTest 1");
                            if (!m_bSubTh_MarkTest_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_MarkLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_MarkLightView 1");
                            if (!m_bSubTh_PackageTest_MarkLightView_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_SideLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_SideLightView 1");
                            if (!m_bSubTh_PackageTest_SideLightView_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_TopLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_TopLightView 1");
                            if (!m_bSubTh_PackageTest_TopLightView_Result)
                            {
                                return false;
                            }
                        }

                        bWholeTestFail = true;
                        m_smVisionInfo.g_strErrorMessage = strPosition + m_smVisionInfo.g_strErrorMessage;

                        if (blnAuto)
                        {
                            //m_smVisionInfo.g_intPositionFailureTotal++;
                            m_smVisionInfo.g_intLeadFailureTotal++;
                            SaveRejectImage_AddToBuffer("Lead", strPosition + m_smVisionInfo.g_strErrorMessage);    // Should save then
                        }

                        if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                            break;
                    }
                    fTotalX += m_smVisionInfo.g_arrLead[i].GetResultCenterPoint_UnitMatcher().X;
                    fTotalY += m_smVisionInfo.g_arrLead[i].GetResultCenterPoint_UnitMatcher().Y;
                    intCount++;
                }
            }
            //t1.Stop();
            //float fT = t1.Duration;

            //t1.Start();
            // Attach g_arrLeadROIs[0][0] (whole unit search ROI ) to g_objLeadImage
            // Rotate g_arrLeadROIs[0][0] (whole unit search ROI ) to 0 deg based on highest score partition matcher angle.
            // Attach g_arrLeadROIs[i][0] (partition unit ROI) to 
            if (!bWholeTestFail || m_smVisionInfo.AT_VM_OfflineTestAllLead)
            {
                if ((!m_blnWantPackageTest || (m_blnWantPackageTest && ((m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailMask & 0x1000) == 0 && !m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetWantInspectPackage() && !GetWantInspectPackageColor(m_smVisionInfo.g_intSelectedUnit))))
                    && m_smVisionInfo.g_arrLead[0].ref_intRotationMethod == 0) // Unit PR
                {
                    m_smVisionInfo.g_arrLeadROIs[0][0].AttachImage(m_smVisionInfo.g_objLeadImage);

                    if (blnWantDebug)
                    {
                        m_smVisionInfo.g_objLeadImage.SaveImage("D:\\TS\\1.g_objLeadImage.bmp");
                    }
                    ROI.Rotate0Degree(m_smVisionInfo.g_arrLeadROIs[0][0], m_intOrientAngle + m_fLeadPatternAngle, 4, ref m_smVisionInfo.g_objLeadImage);

                    if (blnWantDebug)
                    {
                        m_smVisionInfo.g_objLeadImage.SaveImage("D:\\TS\\2.g_objLeadImage.bmp");
                    }

                    //m_smVisionInfo.g_arrLead[0].ref_fRotateCenterX_ForDrawing = m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROITotalCenterX;
                    //m_smVisionInfo.g_arrLead[0].ref_fRotateCenterY_ForDrawing = m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROITotalCenterY;

                    for (int i = 1; i < m_smVisionInfo.g_arrLead.Length; i++)
                    {
                        if (!m_smVisionInfo.g_arrLead[i].ref_blnSelected)
                            continue;

                        m_smVisionInfo.g_arrLeadROIs[i][0].AttachImage(m_smVisionInfo.g_objLeadImage);
                    }

                    // Get equal size of center point
                    float fSizeX, fSizeY;
                    fSizeX = m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIWidth - m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIWidth % 2; // why %2? To get "even" number
                    fSizeY = m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIHeight - m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIHeight % 2;
                    
                    ROI objROI = new ROI();
                    //objROI.LoadROISetting(m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIPositionX, m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIPositionY, m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIWidth, m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIHeight);
                    objROI.LoadROISetting((int)Math.Round(m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROITotalCenterX - fSizeX / 2, 0, MidpointRounding.AwayFromZero),
                            (int)Math.Round(m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROITotalCenterY - fSizeY / 2, 0, MidpointRounding.AwayFromZero),
                            (int)Math.Round(fSizeX, 0, MidpointRounding.AwayFromZero),
                            (int)Math.Round(fSizeY, 0, MidpointRounding.AwayFromZero));

                    objROI.AttachImage(m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo]);

                    if (blnWantDebug)
                        {
                            m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo].SaveImage("D:\\TS\\3a.arrImage.bmp");
                            m_smVisionInfo.g_arrRotatedImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo].SaveImage("D:\\TS\\3b.arrRotatedImage.bmp");

                        }

                        ROI.Rotate0Degree(objROI, m_intOrientAngle + m_fLeadPatternAngle, 4, ref m_smVisionInfo.g_arrRotatedImages, m_smVisionInfo.g_arrLead[0].ref_intImageViewNo);

                    if (m_smVisionInfo.g_pLeadDontCareRotateCenter == new Point(-1, -1))
                        m_smVisionInfo.g_pLeadDontCareRotateCenter = new Point(objROI.ref_ROITotalCenterX, objROI.ref_ROITotalCenterY);

                    if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 0)
                            m_blnRotateImage1Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 1)
                            m_blnRotateImage2Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 2)
                            m_blnRotateImage3Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 3)
                            m_blnRotateImage4Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 4)
                            m_blnRotateImage5Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 5)
                            m_blnRotateImage6Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 6)
                            m_blnRotateImage7Updated = true;

                        if (blnWantDebug)
                        {
                            m_smVisionInfo.g_arrRotatedImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo].SaveImage("D:\\TS\\3c.arrRotatedImage.bmp");
                            m_smVisionInfo.g_arrImages[0].SaveImage("D:\\TS\\4a.arrImage.bmp");
                        }

                        m_smVisionInfo.g_arrLead[0].ref_fRotateCenterX_ForDrawing = objROI.ref_ROITotalCenterX;
                        m_smVisionInfo.g_arrLead[0].ref_fRotateCenterY_ForDrawing = objROI.ref_ROITotalCenterY;
                    
                    if (m_smVisionInfo.g_arrLead[0].ref_blnWantInspectBaseLead && (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo != m_smVisionInfo.g_arrLead[0].ref_intImageViewNo))
                    {

                        objROI.AttachImage(m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo]);
                        ROI.Rotate0Degree(objROI, m_intOrientAngle + m_fLeadPatternAngle, 4, ref m_smVisionInfo.g_arrRotatedImages, m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo);
                        
                        if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 0)
                            m_blnRotateImage1Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 1)
                            m_blnRotateImage2Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 2)
                            m_blnRotateImage3Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 3)
                            m_blnRotateImage4Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 4)
                            m_blnRotateImage5Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 5)
                            m_blnRotateImage6Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 6)
                            m_blnRotateImage7Updated = true;

                    }

                    if (m_blnCustomWantColor && !GetColorImageRotated(m_smVisionInfo.g_arrLead[0].ref_intImageViewNo) && !ContainColorSelectedImage(m_smVisionInfo.g_arrLead[0].ref_intImageViewNo, m_smVisionInfo.g_intSelectedUnit))
                    {
                        CROI objColorRotatedROI = new CROI();
                        objColorRotatedROI.AttachImage(m_smVisionInfo.g_arrColorImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo]);

                        // Get RotateROI center point where the ROI center point == Package Unit Center Point
                        objColorRotatedROI.LoadROISetting(objROI.ref_ROIPositionX,
                                                     objROI.ref_ROIPositionY,
                                                     objROI.ref_ROIWidth,
                                                     objROI.ref_ROIHeight);

                        CROI.Rotate0Degree(m_smVisionInfo.g_arrColorImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo], objColorRotatedROI, m_intOrientAngle + m_fLeadPatternAngle, 4, ref m_smVisionInfo.g_arrColorRotatedImages, m_smVisionInfo.g_arrLead[0].ref_intImageViewNo);

                        SetColorImageRotated(m_smVisionInfo.g_arrLead[0].ref_intImageViewNo);
                        objColorRotatedROI.Dispose();
                    }

                    objROI.Dispose();

                    fTotalX = 0;
                    fTotalY = 0;
                    intCount = 0;

                    for (int i = 0; i < m_smVisionInfo.g_arrLead.Length; i++)
                    {
                        if (!m_smVisionInfo.g_arrLead[i].ref_blnSelected)
                            continue;

                        m_smVisionInfo.g_arrLead[i].ref_blnLock = true;

                        // Reset previous inspection data
                        m_smVisionInfo.g_arrLead[i].ResetInspectionData();

                        // Identify Lead definition for displaying fail message
                        string strPosition = GetLeadDefinition(i);

                        //fTime = t1.Timing;
                        //strT += ", M=" + (fTime - fPrev).ToString("F4");
                        //fPrev = fTime;

                        //Find unit
                        if (!FindUnit(i, 0, false))
                        {
                            if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                            {
                                m_bLeadBaseCenterPointDone = true;
                                m_bLeadBaseCenterPointResult = false;

                                WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_MarkTest 1");
                                if (!m_bSubTh_MarkTest_Result)
                                {
                                    return false;
                                }

                                WaitEventDone(ref m_bSubTh_PackageTest_MarkLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_MarkLightView 1");
                                if (!m_bSubTh_PackageTest_MarkLightView_Result)
                                {
                                    return false;
                                }

                                WaitEventDone(ref m_bSubTh_PackageTest_SideLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_SideLightView 1");
                                if (!m_bSubTh_PackageTest_SideLightView_Result)
                                {
                                    return false;
                                }

                                WaitEventDone(ref m_bSubTh_PackageTest_TopLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_TopLightView 1");
                                if (!m_bSubTh_PackageTest_TopLightView_Result)
                                {
                                    return false;
                                }
                            }

                            bWholeTestFail = true;
                            m_smVisionInfo.g_strErrorMessage = strPosition + m_smVisionInfo.g_strErrorMessage;

                            if (blnAuto)
                            {
                                m_smVisionInfo.g_intLeadFailureTotal++;
                                SaveRejectImage_AddToBuffer("Lead", m_smVisionInfo.g_strErrorMessage);    // Should save then
                            }
                           
                            if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                                break;
                        }
                        fTotalX += m_smVisionInfo.g_arrLead[i].GetResultCenterPoint_UnitMatcher().X;
                        fTotalY += m_smVisionInfo.g_arrLead[i].GetResultCenterPoint_UnitMatcher().Y;
                        intCount++;
                    }
                    //m_smVisionInfo.g_objLeadImage.SaveImage("D:\\objImg.bmp");
                    //m_smVisionInfo.g_arrRotatedImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo].SaveImage("D:\\objImg2.bmp");
                }
                else if ((!m_blnWantPackageTest || (m_blnWantPackageTest && ((m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailMask & 0x1000) == 0 && !m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetWantInspectPackage() && !GetWantInspectPackageColor(m_smVisionInfo.g_intSelectedUnit)))) 
                          && m_smVisionInfo.g_arrLead[0].ref_intRotationMethod == 1) //Base Line
                {
                    List<Line> arrBaseLine = new List<Line>();
                    for (int i = 0; i < m_smVisionInfo.g_arrLead.Length; i++)
                    {
                        if (!m_smVisionInfo.g_arrLead[i].ref_blnSelected)
                            continue;

                        m_smVisionInfo.g_arrLead[i].ref_blnViewLeadResultDrawing = true;

                        if (IsLeadOK_ForBaseLineRotation(i))
                        {
                            // 2020 08 14 - CCENG: cannot add line to arrBaseLine if cannot find the reference point. Bcos the arrBaseLine will be used to calculate unit angle. 
                            if (m_smVisionInfo.g_arrLead[i].ref_fSampleReferencePointStartX != -999 && m_smVisionInfo.g_arrLead[i].ref_fSampleReferencePointStartY != -999 &&
                                m_smVisionInfo.g_arrLead[i].ref_fSampleReferencePointEndX != -999 && m_smVisionInfo.g_arrLead[i].ref_fSampleReferencePointEndY != -999)
                            {
                                Line objLine = new Line();
                                objLine.CalculateStraightLine(new PointF(m_smVisionInfo.g_arrLead[i].ref_fSampleReferencePointStartX, m_smVisionInfo.g_arrLead[i].ref_fSampleReferencePointStartY),
                                    new PointF(m_smVisionInfo.g_arrLead[i].ref_fSampleReferencePointEndX, m_smVisionInfo.g_arrLead[i].ref_fSampleReferencePointEndY));
                                arrBaseLine.Add(objLine);
                            }
                        }
                    }

                    if (arrBaseLine.Count > 0)
                    {
                        m_smVisionInfo.g_arrLeadROIs[0][0].AttachImage(m_smVisionInfo.g_objLeadImage);

                        float fAngle = 0;
                        for (int j = 0; j < arrBaseLine.Count; j++)
                        {
                            float angle = (float)arrBaseLine[j].ref_dAngle;
                            if (angle >= 90)
                            {
                                angle -= 90;
                            }
                            else if (angle < 90 && angle > 45)
                            {
                                angle -= 90;
                            }
                            else if (angle <= -90)
                            {
                                angle += 90;
                            }
                            else if (angle > -90 && angle < -45)
                            {
                                angle += 90;
                            }

                            fAngle += angle;
                        }
                        fAngle /= arrBaseLine.Count;

                        //2021-05-26 ZJYEOH : Need update m_fLeadPatternAngle with Base Line Angle
                        m_fLeadPatternAngle = fAngle;

                        ROI.Rotate0Degree(m_smVisionInfo.g_arrLeadROIs[0][0], m_intOrientAngle + fAngle, 4, ref m_smVisionInfo.g_objLeadImage);
                        //m_smVisionInfo.g_objLeadImage.SaveImage("D:\\LeadImg.bmp");
                        for (int i = 1; i < m_smVisionInfo.g_arrLead.Length; i++)
                        {
                            if (!m_smVisionInfo.g_arrLead[i].ref_blnSelected)
                                continue;

                            m_smVisionInfo.g_arrLeadROIs[i][0].AttachImage(m_smVisionInfo.g_objLeadImage);
                        }

                        ROI objROI = new ROI();
                        objROI.LoadROISetting(m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIPositionX, m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIPositionY, m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIWidth, m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIHeight);
                        
                            objROI.AttachImage(m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo]);

                            ROI.Rotate0Degree(objROI, m_intOrientAngle + fAngle, 4, ref m_smVisionInfo.g_arrRotatedImages, m_smVisionInfo.g_arrLead[0].ref_intImageViewNo);

                        if (m_smVisionInfo.g_pLeadDontCareRotateCenter == new Point(-1, -1))
                            m_smVisionInfo.g_pLeadDontCareRotateCenter = new Point(objROI.ref_ROITotalCenterX, objROI.ref_ROITotalCenterY);

                        if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 0)
                                m_blnRotateImage1Updated = true;
                            else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 1)
                                m_blnRotateImage2Updated = true;
                            else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 2)
                                m_blnRotateImage3Updated = true;
                            else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 3)
                                m_blnRotateImage4Updated = true;
                            else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 4)
                                m_blnRotateImage5Updated = true;
                            else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 5)
                                m_blnRotateImage6Updated = true;
                            else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 6)
                                m_blnRotateImage7Updated = true;

                            m_smVisionInfo.g_arrLead[0].ref_fRotateCenterX_ForDrawing = objROI.ref_ROITotalCenterX;
                            m_smVisionInfo.g_arrLead[0].ref_fRotateCenterY_ForDrawing = objROI.ref_ROITotalCenterY;
                        
                        if (m_smVisionInfo.g_arrLead[0].ref_blnWantInspectBaseLead && (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo != m_smVisionInfo.g_arrLead[0].ref_intImageViewNo))
                        {

                            objROI.AttachImage(m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo]);
                            ROI.Rotate0Degree(objROI, m_intOrientAngle + fAngle, 4, ref m_smVisionInfo.g_arrRotatedImages, m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo);

                            if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 0)
                                m_blnRotateImage1Updated = true;
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 1)
                                m_blnRotateImage2Updated = true;
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 2)
                                m_blnRotateImage3Updated = true;
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 3)
                                m_blnRotateImage4Updated = true;
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 4)
                                m_blnRotateImage5Updated = true;
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 5)
                                m_blnRotateImage6Updated = true;
                            else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 6)
                                m_blnRotateImage7Updated = true;

                        }

                        if (m_blnCustomWantColor && !GetColorImageRotated(m_smVisionInfo.g_arrLead[0].ref_intImageViewNo) && !ContainColorSelectedImage(m_smVisionInfo.g_arrLead[0].ref_intImageViewNo, m_smVisionInfo.g_intSelectedUnit))
                        {
                            CROI objColorRotatedROI = new CROI();
                            objColorRotatedROI.AttachImage(m_smVisionInfo.g_arrColorImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo]);

                            // Get RotateROI center point where the ROI center point == Package Unit Center Point
                            objColorRotatedROI.LoadROISetting(objROI.ref_ROIPositionX,
                                                         objROI.ref_ROIPositionY,
                                                         objROI.ref_ROIWidth,
                                                         objROI.ref_ROIHeight);

                            CROI.Rotate0Degree(m_smVisionInfo.g_arrColorImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo], objColorRotatedROI, m_intOrientAngle + fAngle, 4, ref m_smVisionInfo.g_arrColorRotatedImages, m_smVisionInfo.g_arrLead[0].ref_intImageViewNo);

                            SetColorImageRotated(m_smVisionInfo.g_arrLead[0].ref_intImageViewNo);
                            objColorRotatedROI.Dispose();
                        }

                        objROI.Dispose();

                    }
                    //m_smVisionInfo.g_objLeadImage.SaveImage("D:\\objImg.bmp");
                    //m_smVisionInfo.g_arrRotatedImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo].SaveImage("D:\\objImg2.bmp");

                    fTotalX = 0;
                    fTotalY = 0;
                    intCount = 0;

                    for (int i = 0; i < m_smVisionInfo.g_arrLead.Length; i++)
                    {
                        if (!m_smVisionInfo.g_arrLead[i].ref_blnSelected)
                            continue;

                        m_smVisionInfo.g_arrLead[i].ref_blnLock = true;

                        // Reset previous inspection data
                        m_smVisionInfo.g_arrLead[i].ResetInspectionData();

                        // Identify Lead definition for displaying fail message
                        string strPosition = GetLeadDefinition(i);

                        //fTime = t1.Timing;
                        //strT += ", M=" + (fTime - fPrev).ToString("F4");
                        //fPrev = fTime;

                        //Find unit
                        if (!FindUnit(i, 0, false))//2021-05-26 ZJYEOH : changed true to false, because no need record pattern angle as now pattern angle sure 0
                        {
                            if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                            {
                                m_bLeadBaseCenterPointDone = true;
                                m_bLeadBaseCenterPointResult = false;

                                WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_MarkTest 1");
                                if (!m_bSubTh_MarkTest_Result)
                                {
                                    return false;
                                }

                                WaitEventDone(ref m_bSubTh_PackageTest_MarkLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_MarkLightView 1");
                                if (!m_bSubTh_PackageTest_MarkLightView_Result)
                                {
                                    return false;
                                }

                                WaitEventDone(ref m_bSubTh_PackageTest_SideLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_SideLightView 1");
                                if (!m_bSubTh_PackageTest_SideLightView_Result)
                                {
                                    return false;
                                }

                                WaitEventDone(ref m_bSubTh_PackageTest_TopLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_TopLightView 1");
                                if (!m_bSubTh_PackageTest_TopLightView_Result)
                                {
                                    return false;
                                }
                            }

                            bWholeTestFail = true;
                            m_smVisionInfo.g_strErrorMessage = strPosition + m_smVisionInfo.g_strErrorMessage;

                            if (blnAuto)
                            {
                                m_smVisionInfo.g_intLeadFailureTotal++;
                                SaveRejectImage_AddToBuffer("Position", m_smVisionInfo.g_strErrorMessage);    // Should save then
                            }
                            
                            if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                                break;
                        }
                        fTotalX += m_smVisionInfo.g_arrLead[i].GetResultCenterPoint_UnitMatcher().X;
                        fTotalY += m_smVisionInfo.g_arrLead[i].GetResultCenterPoint_UnitMatcher().Y;
                        intCount++;
                    }
                }
                else if ((!m_blnWantPackageTest || (m_blnWantPackageTest && ((m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailMask & 0x1000) == 0 && !m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].GetWantInspectPackage() && !GetWantInspectPackageColor(m_smVisionInfo.g_intSelectedUnit))))
                          && (m_smVisionInfo.g_arrLead[0].ref_intRotationMethod == 2 || m_smVisionInfo.g_arrLead[0].ref_blnWantUsePkgToBaseTolerance)) // Gauge
                {
                    m_smVisionInfo.g_arrLeadROIs[0][0].AttachImage(m_smVisionInfo.g_objLeadImage);
                    
                    //2021-05-26 ZJYEOH : Need update m_fLeadPatternAngle with m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle
                    m_fLeadPatternAngle = m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle;
                    
                    ROI.Rotate0Degree(m_smVisionInfo.g_arrLeadROIs[0][0], m_intOrientAngle + m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle, 4, ref m_smVisionInfo.g_objLeadImage);

                    for (int i = 1; i < m_smVisionInfo.g_arrLead.Length; i++)
                    {
                        if (!m_smVisionInfo.g_arrLead[i].ref_blnSelected)
                            continue;

                        m_smVisionInfo.g_arrLeadROIs[i][0].AttachImage(m_smVisionInfo.g_objLeadImage);
                    }

                    ROI objROI = new ROI();
                    objROI.LoadROISetting(m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIPositionX, m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIPositionY, m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIWidth, m_smVisionInfo.g_arrLeadROIs[0][0].ref_ROIHeight);
                    objROI.AttachImage(m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo]);

                        ROI.Rotate0Degree(objROI, m_intOrientAngle + m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle, 4, ref m_smVisionInfo.g_arrRotatedImages, m_smVisionInfo.g_arrLead[0].ref_intImageViewNo);

                    if (m_smVisionInfo.g_pLeadDontCareRotateCenter == new Point(-1, -1))
                        m_smVisionInfo.g_pLeadDontCareRotateCenter = new Point(objROI.ref_ROITotalCenterX, objROI.ref_ROITotalCenterY);

                    if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 0)
                            m_blnRotateImage1Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 1)
                            m_blnRotateImage2Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 2)
                            m_blnRotateImage3Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 3)
                            m_blnRotateImage4Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 4)
                            m_blnRotateImage5Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 5)
                            m_blnRotateImage6Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intImageViewNo == 6)
                            m_blnRotateImage7Updated = true;

                    m_smVisionInfo.g_arrLead[0].ref_fRotateCenterX_ForDrawing = objROI.ref_ROITotalCenterX;
                    m_smVisionInfo.g_arrLead[0].ref_fRotateCenterY_ForDrawing = objROI.ref_ROITotalCenterY;

                    if (m_smVisionInfo.g_arrLead[0].ref_blnWantInspectBaseLead && (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo != m_smVisionInfo.g_arrLead[0].ref_intImageViewNo))
                    {

                        objROI.AttachImage(m_smVisionInfo.g_arrImages[m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo]);
                        ROI.Rotate0Degree(objROI, m_intOrientAngle + m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle, 4, ref m_smVisionInfo.g_arrRotatedImages, m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo);

                        if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 0)
                            m_blnRotateImage1Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 1)
                            m_blnRotateImage2Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 2)
                            m_blnRotateImage3Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 3)
                            m_blnRotateImage4Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 4)
                            m_blnRotateImage5Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 5)
                            m_blnRotateImage6Updated = true;
                        else if (m_smVisionInfo.g_arrLead[0].ref_intBaseLeadImageViewNo == 6)
                            m_blnRotateImage7Updated = true;

                    }

                    if (m_blnCustomWantColor && !GetColorImageRotated(m_smVisionInfo.g_arrLead[0].ref_intImageViewNo) && !ContainColorSelectedImage(m_smVisionInfo.g_arrLead[0].ref_intImageViewNo, m_smVisionInfo.g_intSelectedUnit))
                    {
                        CROI objColorRotatedROI = new CROI();
                        objColorRotatedROI.AttachImage(m_smVisionInfo.g_arrColorImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo]);

                        // Get RotateROI center point where the ROI center point == Package Unit Center Point
                        objColorRotatedROI.LoadROISetting(objROI.ref_ROIPositionX,
                                                     objROI.ref_ROIPositionY,
                                                     objROI.ref_ROIWidth,
                                                     objROI.ref_ROIHeight);

                        CROI.Rotate0Degree(m_smVisionInfo.g_arrColorImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo], objColorRotatedROI, m_intOrientAngle + m_smVisionInfo.g_objGauge_PkgSize.ref_fRectAngle, 4, ref m_smVisionInfo.g_arrColorRotatedImages, m_smVisionInfo.g_arrLead[0].ref_intImageViewNo);

                        SetColorImageRotated(m_smVisionInfo.g_arrLead[0].ref_intImageViewNo);
                        objColorRotatedROI.Dispose();
                    }

                    objROI.Dispose();

                    fTotalX = 0;
                    fTotalY = 0;
                    intCount = 0;

                    for (int i = 0; i < m_smVisionInfo.g_arrLead.Length; i++)
                    {
                        if (!m_smVisionInfo.g_arrLead[i].ref_blnSelected)
                            continue;

                        m_smVisionInfo.g_arrLead[i].ref_blnLock = true;

                        // Reset previous inspection data
                        m_smVisionInfo.g_arrLead[i].ResetInspectionData();

                        // Identify Lead definition for displaying fail message
                        string strPosition = GetLeadDefinition(i);

                        //fTime = t1.Timing;
                        //strT += ", M=" + (fTime - fPrev).ToString("F4");
                        //fPrev = fTime;

                        //Find unit
                        if (!FindUnit(i, 0, false))//2021-05-26 ZJYEOH : changed true to false, because no need record pattern angle as now pattern angle sure 0
                        {
                            if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                            {
                                m_bLeadBaseCenterPointDone = true;
                                m_bLeadBaseCenterPointResult = false;

                                WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_MarkTest 1");
                                if (!m_bSubTh_MarkTest_Result)
                                {
                                    return false;
                                }

                                WaitEventDone(ref m_bSubTh_PackageTest_MarkLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_MarkLightView 1");
                                if (!m_bSubTh_PackageTest_MarkLightView_Result)
                                {
                                    return false;
                                }

                                WaitEventDone(ref m_bSubTh_PackageTest_SideLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_SideLightView 1");
                                if (!m_bSubTh_PackageTest_SideLightView_Result)
                                {
                                    return false;
                                }

                                WaitEventDone(ref m_bSubTh_PackageTest_TopLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_TopLightView 1");
                                if (!m_bSubTh_PackageTest_TopLightView_Result)
                                {
                                    return false;
                                }
                            }

                            bWholeTestFail = true;
                            m_smVisionInfo.g_strErrorMessage = strPosition + m_smVisionInfo.g_strErrorMessage;

                            if (blnAuto)
                            {
                                m_smVisionInfo.g_intLeadFailureTotal++;
                                SaveRejectImage_AddToBuffer("Position", m_smVisionInfo.g_strErrorMessage);    // Should save then
                            }
                            
                            if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                                break;
                        }
                        fTotalX += m_smVisionInfo.g_arrLead[i].GetResultCenterPoint_UnitMatcher().X;
                        fTotalY += m_smVisionInfo.g_arrLead[i].GetResultCenterPoint_UnitMatcher().Y;
                        intCount++;
                    }
                    //m_smVisionInfo.g_objLeadImage.SaveImage("D:\\objImg.bmp");
                    //m_smVisionInfo.g_arrRotatedImages[m_smVisionInfo.g_arrLead[0].ref_intImageViewNo].SaveImage("D:\\objImg2.bmp");
                }
                
                m_smVisionInfo.g_fPreciseAngle = m_intOrientAngle - m_fLeadPatternAngle;

                if (!bWholeTestFail || m_smVisionInfo.AT_VM_OfflineTestAllLead)
                {
                    m_smVisionInfo.g_intSelectedLeadExtraBlobID = 0;
                    int Count = 0;
                    // Loop Lead Test From Up, Right, Down to Left
                    for (int i = 0; i < m_smVisionInfo.g_arrLead.Length; i++)
                    {
                        if (!m_smVisionInfo.g_arrLead[i].ref_blnSelected)
                            continue;

                        m_smVisionInfo.g_arrLead[i].ref_intExtraBlobID = Count;

                        m_smVisionInfo.g_arrLead[i].ref_blnViewLeadResultDrawing = true;

                        // Identify Lead definition for displaying fail message
                        string strPosition = GetLeadDefinition(i);

                        m_smVisionInfo.g_arrLead[i].ref_fUnitAverageCenterX = fTotalX / intCount;
                        m_smVisionInfo.g_arrLead[i].ref_fUnitAverageCenterY = fTotalY / intCount;
                        int intFailType = 0;
                        if (!IsLeadOK(i, ref intFailType))
                        {
                            if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                            {
                                m_bLeadBaseCenterPointDone = true;
                                m_bLeadBaseCenterPointResult = false;

                                WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_MarkTest 1");
                                if (!m_bSubTh_MarkTest_Result)
                                {
                                    return false;
                                }

                                WaitEventDone(ref m_bSubTh_PackageTest_MarkLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_MarkLightView 1");
                                if (!m_bSubTh_PackageTest_MarkLightView_Result)
                                {
                                    return false;
                                }

                                WaitEventDone(ref m_bSubTh_PackageTest_SideLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_SideLightView 1");
                                if (!m_bSubTh_PackageTest_SideLightView_Result)
                                {
                                    return false;
                                }

                                WaitEventDone(ref m_bSubTh_PackageTest_TopLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_TopLightView 1");
                                if (!m_bSubTh_PackageTest_TopLightView_Result)
                                {
                                    return false;
                                }
                            }

                            bWholeTestFail = true;

                            m_smVisionInfo.g_strErrorMessage += m_smVisionInfo.g_arrLead[i].GetLeadFailTestDisplayResult(strPosition);
                            if (blnAuto)
                            {
                                m_smVisionInfo.g_intLeadFailureTotal++;
                                if ((intFailType & 0x01) > 0)
                                    SaveRejectImage_AddToBuffer("Lead", m_smVisionInfo.g_arrLead[i].GetLeadFailTestDisplayResult(strPosition));
                                else if (m_smVisionInfo.g_arrLead[i].ref_blnWantInspectBaseLead)
                                    SaveRejectImage_AddToBuffer("Lead", m_smVisionInfo.g_arrLead[i].GetLeadFailTestDisplayResult_BaseLead(strPosition));
                            }

                            m_smVisionInfo.g_strErrorMessage += m_smVisionInfo.g_arrLead[i].GetLeadFailTestDisplayResult(strPosition);
                            if (m_smVisionInfo.g_arrLead[0].ref_blnWantInspectBaseLead)
                            {
                                m_smVisionInfo.g_strErrorMessage += m_smVisionInfo.g_arrLead[i].GetLeadFailTestDisplayResult_BaseLead(strPosition);
                            }
                            if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                                break;
                        }
                        Count = m_smVisionInfo.g_arrLead[i].ref_intExtraBlobID;
                    }
                }
            }

            //if (!bWholeTestFail)
            //{
            //    if (m_smVisionInfo.g_arrLead[1].ref_blnSelected && m_smVisionInfo.g_arrLead[3].ref_blnSelected)
            //    {
            //    }
            //    else if (m_smVisionInfo.g_arrLead[2].ref_blnSelected && m_smVisionInfo.g_arrLead[4].ref_blnSelected)
            //    {
            //    }

            //    //m_smVisionInfo.g_arrLead[0].CalculateUnitCenterPointReferingToLeadBaseCenterX()
            //}

            m_bLeadBaseCenterPointResult = !bWholeTestFail;
            m_bLeadBaseCenterPointDone = true;

            // Check Length Variance
            if (!bWholeTestFail || m_smVisionInfo.AT_VM_OfflineTestAllLead)
            {
                if ((m_smVisionInfo.g_arrLead[0].ref_intFailOptionMask & 0x800) > 0)
                {
                    //Check Span only if 2 opposite lead is use
                    if (!IsUnitLengthVarianceOk())
                    {
                        if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                        {
                            WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_MarkTest 1");
                            if (!m_bSubTh_MarkTest_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_MarkLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_MarkLightView 1");
                            if (!m_bSubTh_PackageTest_MarkLightView_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_SideLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_SideLightView 1");
                            if (!m_bSubTh_PackageTest_SideLightView_Result)
                            {
                                return false;
                            }

                            WaitEventDone(ref m_bSubTh_PackageTest_TopLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_TopLightView 1");
                            if (!m_bSubTh_PackageTest_TopLightView_Result)
                            {
                                return false;
                            }
                        }

                        bWholeTestFail = true;

                        if (blnAuto)
                        {
                            m_smVisionInfo.g_intLeadFailureTotal++;
                            SaveRejectImage_AddToBuffer("Lead", m_smVisionInfo.g_arrLead[0].GetUnitLengthVarianceFailTestDisplayResult());
                        }
                        
                        m_smVisionInfo.g_strErrorMessage += m_smVisionInfo.g_arrLead[0].GetUnitLengthVarianceFailTestDisplayResult();
                    }
                }
            }

            //Check Lead Span here
            if (!bWholeTestFail || m_smVisionInfo.AT_VM_OfflineTestAllLead)
            {
                if ((m_smVisionInfo.g_arrLead[0].ref_intFailOptionMask & 0x1000) > 0)
                {
                    if (!m_smVisionInfo.AT_VM_OfflineTestAllLead)
                    {
                        WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_MarkTest 1");
                        if (!m_bSubTh_MarkTest_Result)
                        {
                            return false;
                        }

                        WaitEventDone(ref m_bSubTh_PackageTest_MarkLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_MarkLightView 1");
                        if (!m_bSubTh_PackageTest_MarkLightView_Result)
                        {
                            return false;
                        }

                        WaitEventDone(ref m_bSubTh_PackageTest_SideLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_SideLightView 1");
                        if (!m_bSubTh_PackageTest_SideLightView_Result)
                        {
                            return false;
                        }

                        WaitEventDone(ref m_bSubTh_PackageTest_TopLightView, false, 10000, "StartLeadTest_MultiThreading > m_bSubTh_PackageTest_TopLightView 1");
                        if (!m_bSubTh_PackageTest_TopLightView_Result)
                        {
                            return false;
                        }
                    }

                    //Check Span only if 2 opposite lead is use
                    if (!IsUnitSpanOk())
                    {
                        bWholeTestFail = true;

                        if (blnAuto)
                        {
                            m_smVisionInfo.g_intLeadFailureTotal++;
                            SaveRejectImage_AddToBuffer("LeadSpan", m_smVisionInfo.g_arrLead[0].GetLeadSpanFailTestDisplayResult());
                        }

                        m_smVisionInfo.g_strErrorMessage += m_smVisionInfo.g_arrLead[0].GetLeadSpanFailTestDisplayResult();
                    }
                }
            }

            //t1.Stop();
            //float fT3 = t1.Duration;
            if (m_smVisionInfo.g_intViewInspectionSetting == 0)
            {
                m_smVisionInfo.g_blnViewLeadInspection = true;
                //m_smVisionInfo.VM_AT_UpdateErrorMessage = true;   // 2020 10 23 - CCENG: Set this event after all inspection done, Do not set here bcos error msg will be displayed weird.
            }
            else
                m_smVisionInfo.g_strErrorMessage = "";

            m_smVisionInfo.g_blnLeadInspected = true;

            if (bWholeTestFail)
            {
                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        m_intTCPIPResultID = (int)TCPIPResulID.Fail;

                return false;
            }
            else
                return true;
        }
        private bool StartPackageColorTest_MultiThreading(bool blnAuto)
        {
            bool blnResult = true;
            bool blnWantDebug = false;

            if (!GetWantInspectPackageColor(m_smVisionInfo.g_intSelectedUnit))
                return true;

            // Check is templates learnt
            if (m_smVisionInfo.g_arrPackageROIs[m_smVisionInfo.g_intSelectedUnit].Count == 0)
            {
                // Wait mark inspection done.
                WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartPackageColorTest_MultiThreading > m_bSubTh_MarkTest 1");    // need to wait for mark inspection done. Because package inspection need to use mark char area to set dont care area on package roi.
                if (!m_bSubTh_MarkTest_Result)
                {
                    return false;   // Skip package inspection if mark test fail.
                }
                // Wait package test done under mark light view 
                WaitEventDone(ref m_bSubTh_PackageTest_MarkLightView, false, 10000, "StartPackageColorTest_MultiThreading > m_bSubTh_PackageTest_MarkLightView 2");
                if (!m_bSubTh_PackageTest_MarkLightView_Result)
                {
                    return false;
                }
                // Wait SideLightView Package done because using same database (array)
                WaitEventDone(ref m_bSubTh_PackageTest_SideLightView, false, 10000, "StartPackageColorTest_MultiThreading > m_bSubTh_PackageTest_SideLightView 3");
                if (!m_bSubTh_PackageTest_SideLightView_Result)
                {
                    return false;
                }
                // Wait TopLightView Package done because using same database (array)
                WaitEventDone(ref m_bSubTh_PackageTest_TopLightView, false, 10000, "StartPackageColorTest_MultiThreading > m_bSubTh_PackageTest_TopLightView 4");
                if (!m_bSubTh_PackageTest_TopLightView_Result)
                {
                    return false;
                }

                m_smVisionInfo.g_strErrorMessage += "*Package : No Template Found";
                if (blnAuto)
                {
                    m_smVisionInfo.g_intNoTemplateFailureTotal++;
                }
                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        SetPackageResultID(m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailResultMask);

                return false;
            }

            // Make sure template unit size not set to zero
            if ((m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_fUnitWidthMin == 0 || m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_fUnitHeightMin == 0) ||
                (m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_fUnitWidthMax == 0 || m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_fUnitHeightMax == 0))
            {
                // Wait mark inspection done.
                WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartPackageColorTest_MultiThreading > m_bSubTh_MarkTest 5");    // need to wait for mark inspection done. Because package inspection need to use mark char area to set dont care area on package roi.
                if (!m_bSubTh_MarkTest_Result)
                {
                    return false;   // Skip package inspection if mark test fail.
                }
                // Wait package test done under mark light view 
                WaitEventDone(ref m_bSubTh_PackageTest_MarkLightView, false, 10000, "StartPackageColorTest_MultiThreading > m_bSubTh_PackageTest_MarkLightView 6");
                if (!m_bSubTh_PackageTest_MarkLightView_Result)
                {
                    return false;
                }
                // Wait SideLightView Package done because using same database (array)
                WaitEventDone(ref m_bSubTh_PackageTest_SideLightView, false, 10000, "StartPackageColorTest_MultiThreading > m_bSubTh_PackageTest_SideLightView 7");
                if (!m_bSubTh_PackageTest_SideLightView_Result)
                {
                    return false;
                }
                // Wait TopLightView Package done because using same database (array)
                WaitEventDone(ref m_bSubTh_PackageTest_TopLightView, false, 10000, "StartPackageColorTest_MultiThreading > m_bSubTh_PackageTest_TopLightView 8");
                if (!m_bSubTh_PackageTest_TopLightView_Result)
                {
                    return false;
                }

                m_smVisionInfo.g_strErrorMessage += "*Package : Template Unit Size Min Max Setting cannot be zero.";
                if (blnAuto)
                {
                    m_smVisionInfo.g_intPackageFailureTotal++;
                }
                if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                    if (m_intTCPIPResultID == -1)
                        m_intTCPIPResultID = (int)TCPIPResulID.FailPackage;//FailPackageDimension;

                return false;
            }
            
            // Wait mark inspection done.
            WaitEventDone(ref m_bSubTh_MarkTest, false, 10000, "StartPackageColorTest_MultiThreading > m_bSubTh_MarkTest 9");    // need to wait for mark inspection done. Because package inspection need to use mark char area to set dont care area on package roi.
            if (!m_bSubTh_MarkTest_Result)
            {
                return false;   // Skip package inspection if mark test fail.
            }
            // Wait package test done under mark light view 
            WaitEventDone(ref m_bSubTh_PackageTest_MarkLightView, false, 10000, "StartPackageColorTest_MultiThreading > m_bSubTh_PackageTest_MarkLightView 10");
            if (!m_bSubTh_PackageTest_MarkLightView_Result)
            {
                return false;
            }
            // Wait SideLightView Package done because using same database (array)
            WaitEventDone(ref m_bSubTh_PackageTest_SideLightView, false, 10000, "StartPackageColorTest_MultiThreading > m_bSubTh_PackageTest_SideLightView 11");
            if (!m_bSubTh_PackageTest_SideLightView_Result)
            {
                return false;
            }
            // Wait TopLightView Package done because using same database (array)
            WaitEventDone(ref m_bSubTh_PackageTest_TopLightView, false, 10000, "StartPackageColorTest_MultiThreading > m_bSubTh_PackageTest_TopLightView 12");
            if (!m_bSubTh_PackageTest_TopLightView_Result)
            {
                return false;
            }

            bool blnWantMark = false;
            int intCharDilateHalfWidth = 2;
            if (m_smVisionInfo.g_arrMarks != null && m_smVisionInfo.g_arrMarks.Count > 0)
            {
                // 2020 04 15 - JBTAN: will continue to check mark even option uncheck check mark option
                // 2020 07 08 - Roll back to previous method, wont check mark if Mark Checking is not selected.
                blnWantMark = m_smVisionInfo.g_arrMarks[0].ref_blnCheckMark;
                //blnWantMark = true;
                intCharDilateHalfWidth = m_smVisionInfo.g_arrMarks[0].ref_intCharDilateHalfWidth; // thick iteration
            }

            List<int> arrStartX = new List<int>();
            List<int> arrStartY = new List<int>();
            List<int> arrEndX = new List<int>();
            List<int> arrEndY = new List<int>();
            if (blnWantMark)
            {
                // ---------- Fill Mark Image's mark area with black color -------------------
                int intNumChars = m_smVisionInfo.g_arrMarks[0].GetNumChars();
                int intStartX = 0, intStartY = 0, intEndX = 0, intEndY = 0;

                int intOffsetX;
                int intOffsetY;

                if (m_smVisionInfo.g_blnWantGauge)  // Mean during mark inspection, orient gauge is used to measure unit position for m_objMarkTrainROI
                {
                    intOffsetX = m_objMarkTrainROI.ref_ROITotalX;
                    intOffsetY = m_objMarkTrainROI.ref_ROITotalY;
                }
                else if (m_smVisionInfo.g_arrMarkROIs[0].Count > 3)    // Mean during mark inspection, Unit PR is used to find unit surface position for m_objMarkTrainROI
                {
                    intOffsetX = m_objMarkTrainROI.ref_ROITotalX;
                    intOffsetY = m_objMarkTrainROI.ref_ROITotalY;
                }
                else // Mean during mark inspection, m_objMarkSearchROI is used.
                {
                    intOffsetX = m_objMarkTrainROI.ref_ROITotalX;
                    intOffsetY = m_objMarkTrainROI.ref_ROITotalY;
                }

                for (int i = 0; i < intNumChars; i++)
                {
                    bool blnIsBarPin1 = m_smVisionInfo.g_arrMarks[0].GetCharIsBarPin1(m_smVisionInfo.g_arrMarks[0].ref_intGroupIndex, m_smVisionInfo.g_arrMarks[0].ref_intTemplateIndex, i);
                    int intBarPin1Type = m_smVisionInfo.g_arrMarks[0].GetCharBarPin1Type(m_smVisionInfo.g_arrMarks[0].ref_intGroupIndex, m_smVisionInfo.g_arrMarks[0].ref_intTemplateIndex, i);

                    int intRectStartX, intRectStartY, intRectEndX, intRectEndY;
                    intRectStartX = intRectStartY = intRectEndX = intRectEndY = 0;
                    m_smVisionInfo.g_arrMarks[0].GetCharStartXY(i, ref intStartX, ref intStartY);
                    m_smVisionInfo.g_arrMarks[0].GetCharEndXY(i, ref intEndX, ref intEndY);

                    if (m_smVisionInfo.g_arrMarks[0].ref_blnWantDontCareIgnoredMarkWholeArea && !m_smVisionInfo.g_arrMarks[0].GetEnableMarkSetting(i))
                    {
                        //2021-01-18 ZJYEOH : Should use sample position
                        Point pStartTemplate = new Point(intStartX, intStartY);//m_smVisionInfo.g_arrMarks[0].GetTemplateCharROIStartPoint(i);
                        Point pEndTemplate = new Point(intEndX, intEndY);//m_smVisionInfo.g_arrMarks[0].GetTemplateCharROIEndPoint(i);

                        if ((intOffsetX + pStartTemplate.X - m_smVisionInfo.g_arrMarks[0].GetTemplateCharShiftX(i)) >= 0)
                            intRectStartX = intOffsetX + pStartTemplate.X - m_smVisionInfo.g_arrMarks[0].GetTemplateCharShiftX(i);
                        else
                            intRectStartX = intOffsetX;

                        if ((intOffsetY + pStartTemplate.Y - m_smVisionInfo.g_arrMarks[0].GetTemplateCharShiftY(i)) >= 0)
                            intRectStartY = intOffsetY + pStartTemplate.Y - m_smVisionInfo.g_arrMarks[0].GetTemplateCharShiftY(i);
                        else
                            intRectStartY = intOffsetY;

                        if ((intOffsetX + pEndTemplate.X + m_smVisionInfo.g_arrMarks[0].GetTemplateCharShiftX(i)) < m_smVisionInfo.g_intCameraResolutionWidth)
                            intRectEndX = intOffsetX + pEndTemplate.X + m_smVisionInfo.g_arrMarks[0].GetTemplateCharShiftX(i);
                        else
                            continue;
                        if ((intOffsetY + pEndTemplate.Y + m_smVisionInfo.g_arrMarks[0].GetTemplateCharShiftY(i)) < m_smVisionInfo.g_intCameraResolutionHeight)
                            intRectEndY = intOffsetY + pEndTemplate.Y + m_smVisionInfo.g_arrMarks[0].GetTemplateCharShiftY(i);
                        else
                            continue;
                    }
                    else
                    {
                        // 2019 10 11 - CCENG   : add intOffsetXY checking because rectangle will be filled on m_objPkgViewImage (Full image)
                        //                      : without the intOffsetXY, intRectStartX will set to intOffsetX and fill position may be shifted                       
                        if ((intOffsetX + intStartX - intCharDilateHalfWidth) >= 0)  //if ((intStartX - intCharDilateHalfWidth) >= 0)   
                            intRectStartX = intOffsetX + intStartX - intCharDilateHalfWidth;
                        else
                            intRectStartX = intOffsetX;

                        // 2019 10 11 - CCENG   : add intOffsetXY checking because rectangle will be filled on m_objPkgViewImage (Full image)
                        //                      : without the intOffsetXY, intRectStartX will set to intOffsetX and fill position may be shifted
                        if ((intOffsetY + intStartY - intCharDilateHalfWidth) >= 0)    //if ((intStartY - intCharDilateHalfWidth) >= 0) 
                            intRectStartY = intOffsetY + intStartY - intCharDilateHalfWidth;
                        else
                            intRectStartY = intOffsetY;

                        if ((intEndX + intCharDilateHalfWidth) < m_smVisionInfo.g_intCameraResolutionWidth)
                            intRectEndX = intOffsetX + intEndX + intCharDilateHalfWidth;
                        else
                            intRectEndX = intOffsetX + intEndX;

                        if ((intEndY + intCharDilateHalfWidth) < m_smVisionInfo.g_intCameraResolutionHeight)
                            intRectEndY = intOffsetY + intEndY + intCharDilateHalfWidth;
                        else
                            intRectEndY = intOffsetY + intEndY;
                    }

                    //2020-05-28 ZJYEOH : extend the dont care area to fit the m_objMarkTrainROI size
                    if (blnIsBarPin1 && !m_smVisionInfo.g_blnWantCheckBarPin1)
                    {
                        if (intBarPin1Type == 0) // Virtical bar
                        {
                            intRectStartY = intOffsetY;
                            intRectEndY = intOffsetY + m_objMarkTrainROI.ref_ROIHeight;
                        }
                        else if (intBarPin1Type == 1) // Horizontal bar
                        {
                            intRectStartX = intOffsetX;
                            intRectEndX = intOffsetX + m_objMarkTrainROI.ref_ROIWidth;
                        }
                    }

                    arrStartX.Add(intRectStartX);
                    arrStartY.Add(intRectStartY);
                    arrEndX.Add(intRectEndX);
                    arrEndY.Add(intRectEndY);
                    //if (blnWantDebug)
                    //{
                    //    m_arrColorImage_ForInspection[0].SaveImage("D:\\TS\\1.m_arrColorImage_ForInspection" + i.ToString() + ".bmp");
                    //}

                    //Shape.FillRectangle(m_arrColorImage_ForInspection[0], intRectStartX, intRectStartY, intRectEndX, intRectEndY, 0);

                    //if (blnWantDebug)
                    //{
                    //    m_arrColorImage_ForInspection[0].SaveImage("D:\\TS\\2.m_arrColorImage_ForInspection" + i.ToString() + ".bmp");
                    //}
                }
            }

            // ----------- Define the actual location for unit and place the package roi on that location. ------------------------
            CROI objPkgViewROI = null; // Image 2 - Package ROI
            
                objPkgViewROI = new CROI();
                objPkgViewROI.AttachImage(m_arrColorImage_ForInspection[0]);
                objPkgViewROI.LoadROISetting((int)Math.Round((m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.X -
                                             m_smVisionInfo.g_objGauge_PkgSize.ref_fRectWidth / 2), 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round((m_smVisionInfo.g_objGauge_PkgSize.ref_pRectCenterPoint.Y -
                                             m_smVisionInfo.g_objGauge_PkgSize.ref_fRectHeight / 2), 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round(m_smVisionInfo.g_objGauge_PkgSize.ref_fRectWidth, 0, MidpointRounding.AwayFromZero),
                                             (int)Math.Round(m_smVisionInfo.g_objGauge_PkgSize.ref_fRectHeight, 0, MidpointRounding.AwayFromZero));

            if (m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intColorDefectLinkMethod == 1)
            {
                if (!m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].CheckColorDefect_CombineSameName_LinkNearest(objPkgViewROI, m_arrColorImage_ForInspection, m_smVisionInfo.g_objWhiteImage, m_smVisionInfo.g_objBlackImage, arrStartX, arrStartY, arrEndX, arrEndY))
                {
                    m_smVisionInfo.g_strErrorMessage += m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_strErrorMessage;
                    if (blnAuto)
                    {
                        if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        {
                            m_blnPackageFail_Out = true;
                            if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                                if (m_intTCPIPResultID == -1)
                                    SetPackageResultID(m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailResultMask);
                        }
                        else
                        {
                            m_objVisionIO.PackageFail.SetOn(strTrackHeadName + " PackageFail 16");
                        }

                        SaveRejectImage_AddToBuffer("Package Color", m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_strErrorMessage);

                        m_smVisionInfo.g_intPkgColorDefectFailureTotal++;
                    }
                    blnResult = false;
                }
            }
            else
            {
                if (!m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].CheckColorDefect_CombineSameName(objPkgViewROI, m_arrColorImage_ForInspection, m_smVisionInfo.g_objWhiteImage, m_smVisionInfo.g_objBlackImage, arrStartX, arrStartY, arrEndX, arrEndY))
                {
                    m_smVisionInfo.g_strErrorMessage += m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_strErrorMessage;
                    if (blnAuto)
                    {
                        if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                        {
                            m_blnPackageFail_Out = true;
                            if (m_smCustomizeInfo.g_blnWantUseTCPIPIO)
                                if (m_intTCPIPResultID == -1)
                                    SetPackageResultID(m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_intFailResultMask);
                        }
                        else
                        {
                            m_objVisionIO.PackageFail.SetOn(strTrackHeadName + " PackageFail 16");
                        }

                        SaveRejectImage_AddToBuffer("Package Color", m_smVisionInfo.g_arrPackage[m_smVisionInfo.g_intSelectedUnit].ref_strErrorMessage);

                        m_smVisionInfo.g_intPkgColorDefectFailureTotal++;
                    }
                    blnResult = false;
                }
            }

            objPkgViewROI.Dispose();

            m_smVisionInfo.g_blnDrawPkgResult = true;
            m_smVisionInfo.g_blnPackageInspected = true;

            return blnResult;
        }
        private bool WaitEventDone(int[] arrImageIndex, string strTrackName)
        {
            for (int i = 0; i < arrImageIndex.Length; i++)
            {
                if (arrImageIndex[i] == 0)
                    return WaitEventDone(ref m_bGrabImage1Done, true, ref m_bGrabImage1Result, strTrackName + "- 1");
                else if (arrImageIndex[i] == 1)
                    return WaitEventDone(ref m_bGrabImage2Done, true, ref m_bGrabImage2Result, strTrackName + "- 2");
                else if (arrImageIndex[i] == 2)
                    return WaitEventDone(ref m_bGrabImage3Done, true, ref m_bGrabImage3Result, strTrackName + "- 3");
                else if (arrImageIndex[i] == 3)
                    return WaitEventDone(ref m_bGrabImage4Done, true, ref m_bGrabImage4Result, strTrackName + "- 4");
                else if (arrImageIndex[i] == 4)
                    return WaitEventDone(ref m_bGrabImage5Done, true, ref m_bGrabImage5Result, strTrackName + "- 5");
                else if (arrImageIndex[i] == 5)
                    return WaitEventDone(ref m_bGrabImage6Done, true, ref m_bGrabImage6Result, strTrackName + "- 6");
                else if (arrImageIndex[i] == 6)
                    return WaitEventDone(ref m_bGrabImage7Done, true, ref m_bGrabImage7Result, strTrackName + "- 7");
            }

            return false;
        }
        private void UpdateSubProgress_AfterInspect()
        {
            while (!m_blnStopping)
            {
                try
                {
                    if (m_bSubTh_StartAfterInspect)
                    {
                        
                        //2020-04-30 ZJYEOH : Record Result Log
                        if (m_blnAuto && m_smVisionInfo.g_blnWantRecordResult && (m_smVisionInfo.g_intTestedTotal <= m_smVisionInfo.g_intResultLogMaxCount))
                            RecordResultLog();

                        m_bSubTh_StartAfterInspect = false;
                    }
                }
                catch (Exception ex)
                {
                    SRMMessageBox.Show("Vision1Process->UpdateSubProgress_SideBR() :" + ex.ToString());
                }
                Thread.Sleep(1);
            }

            m_thSubThread_AfterInspect = null;
            m_blnStopped_AfterInspect = true;
        }
        private void RecordResultLog()
        {
            string strLotSaveResultLogPath;
            string strVisionResultLogFileName;
            string strPath;
            if (m_smVisionInfo.g_intVisionResetCount == 0)
            {
                strLotSaveResultLogPath = m_smProductionInfo.g_strHistoryDataLocation + "ResultLog\\" + m_smProductionInfo.g_strLotID + "_" + m_smProductionInfo.g_strLotStartTime;
                strVisionResultLogFileName = m_smVisionInfo.g_strVisionFolderName + "(" + m_smVisionInfo.g_strVisionDisplayName + " " + m_smVisionInfo.g_strVisionNameRemark + ")" + "_" + m_smProductionInfo.g_strLotStartTime;

                if (!Directory.Exists(strLotSaveResultLogPath))
                    Directory.CreateDirectory(strLotSaveResultLogPath);

                strPath = strLotSaveResultLogPath + "\\" + strVisionResultLogFileName + ".txt";
            }
            else
            {
                strLotSaveResultLogPath = m_smProductionInfo.g_strHistoryDataLocation + "ResultLog\\" + m_smProductionInfo.g_strLotID + "_" + m_smProductionInfo.g_strLotStartTime;
                strVisionResultLogFileName = m_smVisionInfo.g_strVisionFolderName + "(" + m_smVisionInfo.g_strVisionDisplayName + " " + m_smVisionInfo.g_strVisionNameRemark + ")" + "_" + m_smVisionInfo.g_strVisionResetCountTime;

                if (!Directory.Exists(strLotSaveResultLogPath))
                    Directory.CreateDirectory(strLotSaveResultLogPath);

                strPath = strLotSaveResultLogPath + "\\" + strVisionResultLogFileName + ".txt";
            }

            string ResultData = "";

            if (m_smVisionInfo.g_arrLead != null)
            {
                for (int a = 0; a < m_smVisionInfo.g_arrLead.Length; a++)
                {
                    if (!m_smVisionInfo.g_arrLead[a].ref_blnSelected)
                        continue;

                    int intBlobsCount = m_smVisionInfo.g_arrLead[a].GetBlobsFeaturesNumber();

                    if (intBlobsCount > 0)
                        ResultData += "Date Time=" + DateTime.Now.ToString() + ",";

                    string strLeadDirection = "";
                    switch (a)
                    {
                        case 0:
                            strLeadDirection = "Center ";
                            break;
                        case 1:
                            strLeadDirection = "Top ";
                            break;
                        case 2:
                            strLeadDirection = "Right ";
                            break;
                        case 3:
                            strLeadDirection = "Bottom ";
                            break;
                        case 4:
                            strLeadDirection = "Left ";
                            break;
                    }

                    for (int i = 0; i < intBlobsCount; i++)
                    {
                        List<string> arrResultList = new List<string>();

                        arrResultList = m_smVisionInfo.g_arrLead[a].GetBlobFeaturesResult_WithPassFailIndicator(i);

                        int intFailMask = Convert.ToInt32(arrResultList[arrResultList.Count - 1]);
                        int intFailOptionMask = m_smVisionInfo.g_arrLead[a].ref_intFailOptionMask;
                        bool blnWantCheckWidthLength = false, blnWantCheckPitchGap = false,
                            blnWantCheckBaseLeadArea = false;

                        if ((intFailOptionMask & 0xC0) > 0)
                            blnWantCheckWidthLength = true;
                        if ((intFailOptionMask & 0x600) > 0)
                            blnWantCheckPitchGap = true;
                        if ((intFailOptionMask & 0x20000) > 0)
                            blnWantCheckBaseLeadArea = true;

                        if (blnWantCheckWidthLength)
                        {
                            ResultData += strLeadDirection + "Lead " + (i + 1).ToString() + " Tip Width=" + arrResultList[2].ToString() + ",";

                            ResultData += strLeadDirection + "Lead " + (i + 1).ToString() + " Tip Length=" + arrResultList[3].ToString() + ",";
                        }

                        if (blnWantCheckPitchGap && a == 0)
                        {
                            ResultData += strLeadDirection + "Lead " + (i + 1).ToString() + " Pitch=" + arrResultList[4].ToString() + ",";

                            ResultData += strLeadDirection + "Lead " + (i + 1).ToString() + " Gap=" + arrResultList[5].ToString() + ",";
                        }

                        if (blnWantCheckBaseLeadArea && a == 0)
                        {
                            ResultData += strLeadDirection + "Lead " + (i + 1).ToString() + " Base Lead Area=" + arrResultList[6].ToString() + ",";
                        }

                    }

                }
            }

            if (ResultData != "")
            {
                ResultData = ResultData.Substring(0, ResultData.Length - 1); // Remove comma
                STTrackLog.WriteLine_ForResultLog(strLotSaveResultLogPath, strVisionResultLogFileName, ResultData);
            }
        }
        private void SetPackageResultID(int intFailResultMask)
        {
            if ((intFailResultMask & 0x01) > 0) //Crack
                m_intTCPIPResultID = (int)TCPIPResulID.FailPackage;// FailCrack;
            else if (((intFailResultMask & 0x02) > 0) || ((intFailResultMask & 0x04) > 0)) //Chipped Off, Scratches
                m_intTCPIPResultID = (int)TCPIPResulID.FailPackage;//FailChippedOffOrScractches;
            else if ((intFailResultMask & 0x10) > 0) //Contamination
                m_intTCPIPResultID = (int)TCPIPResulID.FailPackage;//FailForeignMaterial;
            else
                m_intTCPIPResultID = (int)TCPIPResulID.FailPackage;
        }
        private static bool CopyAllFiles(string Source, string Destination)
        {
            try
            {
                // Get the subdirectories for the specified directory.
                DirectoryInfo dir = new DirectoryInfo(Source);

                if (!dir.Exists)
                {
                    return false;
                }
                DirectoryInfo[] dirs = dir.GetDirectories();
                // If the destination directory doesn't exist, create it.
                if (!Directory.Exists(Destination))
                {
                    Directory.CreateDirectory(Destination);
                }

                // Get the files in the directory and copy them to the new location.
                FileInfo[] files = dir.GetFiles();
                foreach (FileInfo file in files)
                {
                    string temppath = Path.Combine(Destination, file.Name);
                    file.CopyTo(temppath, true);
                }
                foreach (DirectoryInfo subdir in dirs)
                {
                    string temppath = Path.Combine(Destination, subdir.Name);
                    CopyAllFiles(subdir.FullName, temppath);
                }

            }
            catch (Exception ex)
            {

            }
            return true;
        }
        private bool ContainColorSelectedImage(int intImageIndex, int intUnitIndex)
        {
            List<int> arrDefectImage = new List<int>();
         
            for (int i = 0; i < m_smVisionInfo.g_arrPackage[intUnitIndex].ref_arrDefectImageNo.Count; i++)
            {
                if (!arrDefectImage.Contains(CImageDrawing.GetArrayImageIndex(m_smVisionInfo.g_arrPackage[intUnitIndex].ref_arrDefectImageNo[i], m_smVisionInfo.g_intVisionIndex)))
                    arrDefectImage.Add(CImageDrawing.GetArrayImageIndex(m_smVisionInfo.g_arrPackage[intUnitIndex].ref_arrDefectImageNo[i], m_smVisionInfo.g_intVisionIndex));
            }

            if (arrDefectImage.Contains(intImageIndex))
                return true;

            return false;
        }
        private List<int> GetColorSelectedImage(int intUnitIndex)
        {
            List<int> arrDefectImage = new List<int>();

            for (int i = 0; i < m_smVisionInfo.g_arrPackage[intUnitIndex].ref_arrDefectImageNo.Count; i++)
            {
                if (!arrDefectImage.Contains(CImageDrawing.GetArrayImageIndex(m_smVisionInfo.g_arrPackage[intUnitIndex].ref_arrDefectImageNo[i], m_smVisionInfo.g_intVisionIndex)))
                    arrDefectImage.Add(CImageDrawing.GetArrayImageIndex(m_smVisionInfo.g_arrPackage[intUnitIndex].ref_arrDefectImageNo[i], m_smVisionInfo.g_intVisionIndex));
            }

            return arrDefectImage;
        }
        private bool GetWantInspectPackageColor(int intUnitIndex)
        {
            if (m_blnCustomWantColor &&
                m_smVisionInfo.g_blnCheckPackageColor &&
                (m_smVisionInfo.g_arrPackage.Count > intUnitIndex) && 
                (m_smVisionInfo.g_arrPackage[intUnitIndex].ref_arrDefectColor.Count > 0) &&
                (m_smVisionInfo.g_arrPackage[intUnitIndex].ref_intFailColorOptionMask > 0)
                )
            {
                return true;
            }
            return false;
        }

        private bool GetColorImageRotated(int intImageIndex)
        {
            switch (intImageIndex)
            {
                case 0:
                    return m_blnRotateColorImage1Updated;
                    break;
                case 1:
                    return m_blnRotateColorImage2Updated;
                    break;
                case 2:
                    return m_blnRotateColorImage3Updated;
                    break;
                case 3:
                    return m_blnRotateColorImage4Updated;
                    break;
                case 4:
                    return m_blnRotateColorImage5Updated;
                    break;
                case 5:
                    return m_blnRotateColorImage6Updated;
                    break;
                case 6:
                    return m_blnRotateColorImage7Updated;
                    break;
            }
            return true;
        }
        private void SetColorImageRotated(int intImageIndex)
        {
            switch (intImageIndex)
            {
                case 0:
                    m_blnRotateColorImage1Updated = true;
                    break;
                case 1:
                    m_blnRotateColorImage2Updated = true;
                    break;
                case 2:
                    m_blnRotateColorImage3Updated = true;
                    break;
                case 3:
                    m_blnRotateColorImage4Updated = true;
                    break;
                case 4:
                    m_blnRotateColorImage5Updated = true;
                    break;
                case 5:
                    m_blnRotateColorImage6Updated = true;
                    break;
                case 6:
                    m_blnRotateColorImage7Updated = true;
                    break;
            }
        }
    }
}
