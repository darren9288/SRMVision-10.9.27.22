using System;
using System.Collections.Generic;
using System.Drawing;
using System.IO;
using System.Threading;
using System.Text;
using Common;
#if (Debug_2_12 || Release_2_12)
using Euresys.Open_eVision_2_12;
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
using Euresys.Open_eVision_1_2;
#endif

namespace VisionProcessing
{
    public class Mark
    {
        //public enum MarkGrid
        //{
        //    EndPoint,
        //    Line,
        //    Empty,
        //    CornerTL,
        //    CornerTR,
        //    CornerBL,
        //    CornerBR,
        //    UTurn0,
        //    UTurn90,
        //    UTurn180,
        //    UTurn270
        //};

        #region Member Variables
        private int m_intPin1PositionControl = 0;
        private int m_intPin1ImageNo = 0;
        private int m_intDecimal = 4;
        private int m_intMarkTextShiftMethod = 0; // 0 = Max, 1 = Min, 2 = Manual
        private bool m_blnWantUseGrayValue = false;
        private int m_intMarkInspectionAreaGrayValueSensitivity = 45;
        private int m_intMarkBrightSensitivity = 0;
        private bool m_blnWantSampleAreaScore = false;
        private bool m_blnWhiteOnBlack = true;
        private bool m_blnInspectAllTemplate = true;
        private bool m_blnIsSplitLineDisplaying = false;
        private bool m_blnCheckMark = true;
        private bool m_blnSplitHorizontal = true;
        private bool m_blnExtraSaveImageAndRecipeDueToException = false;
        private bool[][] m_blnCharResult = new bool[8][];
        private bool[][] m_blnOCRCharResult = new bool[8][];
        private bool[][] m_blnTextResult = new bool[8][];
        private bool m_blnUseDefaultSettingMarkAfterClearTemplate = false;
        private int m_intImageWidth = 640;                  // Top Parent Image size used to learn mark
        private int m_intImageHeight = 480;                 // Top Parent Image size used to learn mark
        private int m_intBlobOCVOffSetX = 0;
        private int m_intBlobOCVOffSetY = 0;
        private int m_intDefaultCharSetting = 75;
        private int m_intTotalBlobArea = -1;    // 2020 11 07 - CCENG: set to -1 to indicate "no tested yet"
        private int m_intFailOptionMask_ForPreTest = 0;
        private int m_intFailOptionMask = 0;
        //0x01: Extra Mark Char Area / Excess Mark
        //0x02: Extra Mark Check Area
        //0x04: Extra Mark Uncheck Area
        //0x08: Group Extra Mark
        //0x10: Missing Mark 
        //0x20: Broken Mark
        //0x40: Text Shifted
        //0x80: Joint Mark
        //0x100: Group Excess Mark
        //0x200: Mark Average Gray Value
        //0x2000: Mark Angle
        //0x4000: Mark Average Gray Value
        private int m_intFailResultMask = 0;
        private int m_intFailResultMask_ForPreTest = 0;
        //0x01: Extra Mark (for all area)
        //0x02: -
        //0x04: -
        //0x08: Group Extra Mark Fail
        //0x10: Missing Mark Fail
        //0x20: Broken Mark Fail
        //0x40: Text Shifted Fail
        //0x80: Joint Mark
        //0x100: Score Fail
        //0x200: OCV Text Fail (Loc.Score/Mismatch/OverPrint/UnderPrint)
        //0x400: OCR Ref Char mismatch
        //0x800: General error fail
        //0x1000: No Mark Fail
        //0x2000: Group Excess Mark Fail
        //0x4000: Mark Average Gray Value
        private int m_intGroupIndex = -1;           //Current selected group index
        private int m_intGroupNum = 1;              //Max counter of group
        private int m_intHitCharIndex = -1;
        private int m_intHitTextIndex = -1;
        private int m_intInspectionMode = 0;    //0 = OCV, 1 = OCR
        // 2021-08-25 : Hide this because no more using Lead base point to offset mark ROI
        //private int m_intMarkROIOffsetTop = 0;
        //private int m_intMarkROIOffsetRight = 0;
        //private int m_intMarkROIOffsetBottom = 0;
        //private int m_intMarkROIOffsetLeft = 0;
        private int m_intLeadDontCareInwardTolerance_Top = 0;
        private int m_intLeadDontCareInwardTolerance_Right = 0;
        private int m_intLeadDontCareInwardTolerance_Bottom = 0;
        private int m_intLeadDontCareInwardTolerance_Left = 0;
        private int m_intMinArea = 20;
        private int m_intMaxArea = 100000;
        private int m_intLearnMinArea = 20;
        private int m_intROIOffSetX = 0;
        private int m_intROIOffSetY = 0;
        private int m_intTemplateIndex = -1;
        private int m_intTemplateMask = 0;          //Keep the template Enable/Disable state
        private int m_intCharErodeHalfWidth = 1;
        private int m_intCharOpenHalfWidth = 0;
        private int m_intCharDilateHalfWidth = 1;
        private int m_intEnhanceMark_LinkMark_HalfWidth = 0;    // Do Morphology Close before build blob for mark image.
        private int m_intEnhanceMark_ReduceNoise_HalfWidth = 0; // Do Morphology Open  befre build blb for mark image.
        private int m_intMissingMarkInspectionMethod = 0;   // 0=Thin on Template Mark, 1=Thick on Sample Mark
        private long m_intTemplatePriority = 0;      //Keep the template priority number. Each Hex represent each template.       
        private int[] m_intHitCharCounter;
        private int m_intSelectedBuildOcvForSplitLine = -1;
        private List<Point> m_arrBuildOcvSplitStart = new List<Point>();
        private List<Point> m_arrBuildOcvSplitEnd = new List<Point>();
        private List<int> m_arrBuildOcvBlobNo = new List<int>();
        private List<int> m_arrBuildOcvStartX = new List<int>();
        private List<int> m_arrBuildOcvStartY = new List<int>();
        private List<int> m_arrBuildOcvEndX = new List<int>();
        private List<int> m_arrBuildOcvEndY = new List<int>();
        private List<int> m_arrBuildOcvNo = new List<int>();
        private List<bool> m_arrBuildOcvEnableStatus = new List<bool>();
        private List<int> m_arrBuildOcvType = new List<int>(); // 0=Char , 1=Logo , 2=Symbol1 , 3=Symbol2
        private List<int> m_arrBuildOcvTypeOri = new List<int>(); // 0=Char , 1=Logo , 2=Symbol1 , 3=Symbol2
        private List<int> m_arrBuildOcvSelectStatus = new List<int>();  // 0=Not Selected, 1=Selected, 2= Selected For Action.
        private List<int> m_arrBuildOcvSelectStatusPrev = new List<int>();  // 0=Not Selected, 1=Selected, 2= Selected For Action.
        private List<int> m_arrBuildOcvSelectStatusOri = new List<int>();  // 0=Not Selected, 1=Selected, 2= Selected For Action.
        private List<int> m_arrBuildOcvStartXOri = new List<int>();
        private List<int> m_arrBuildOcvStartYOri = new List<int>();
        private List<int> m_arrBuildOcvEndXOri = new List<int>();
        private List<int> m_arrBuildOcvEndYOri = new List<int>();
        private List<float> m_arrBuildOcvCharShiftX = new List<float>();
        private List<float> m_arrBuildOcvCharShiftY = new List<float>();
        private List<float> m_arrBuildOcvTextCharOffsetX = new List<float>();
        private List<float> m_arrBuildOcvTextCharOffsetY = new List<float>();
        private List<PointF> m_arrBuildOcvCutLineStartPoint = new List<PointF>();
        private List<PointF> m_arrBuildOcvCutLineEndPoint = new List<PointF>();
        private LineROI m_objSplitMarkLine = new LineROI();
        // --------------- Result Data-------------------------------------------------------------------------
        private int[] m_intGroupExcessMarkArea = new int[8];      // 1st: Template
        private int[] m_intGroupExtraMarkArea = new int[8];      // 1st: Template
        private int[] m_intSmallestExtraMarkArea = new int[8];  // 1st: Template
        private int[] m_intSmallestExcessMarkArea = new int[8];  // 1st: Template
        private int[] m_intSmallestMissingMarkArea = new int[8];// 1st: Template
        private int[] m_intBiggestExtraMarkArea = new int[8];  // 1st: Template
        private int[] m_intBiggestExcessMarkArea = new int[8];  // 1st: Template
        private int[] m_intBiggestMissingMarkArea = new int[8];// 1st: Template
        private float[] m_arrTestMatchScore = new float[8];     // 1st: Template
        private float[] m_fGroupBrokenMarkLength = new float[8];      // 1st: Template
        private float[] m_arrTextShiftedTop = new float[8];
        private float[] m_arrTextShiftedBottom = new float[8];
        private float[] m_arrTextShiftedLeft = new float[8];
        private float[] m_arrTextShiftedRight = new float[8];
        private int[][] m_intBlobResult = new int[8][];         // 1st: Template, 2nd: Blobs index
        private int[][] m_intJointMarkBlobResult = new int[8][];         // 1st: Template, 2nd: Blobs index
        private int[][] m_intExcessBlobResult = new int[8][];   // 1st: Template, 2nd: Blobs index
        private float[][] m_fAveGrayDiffBlobResult = new float[8][];   // 1st: Template, 2nd: Blobs index
        private int[][] m_intMissingBlobResult = new int[8][];  // 1st: Template, 2nd: Blobs index
        private int[][] m_arrCharExcessAreaResult = new int[8][];   // 1st: Template, 2nd: char index
        private int[][] m_arrCharBrokenAreaResult = new int[8][];   // 1st: Template, 2nd: char index
        private bool[][] m_arrCharBrokenMarkResult = new bool[8][];   // 1st: Template, 2nd: char index
        private bool[][] m_arrCharJointMarkResult = new bool[8][];   // 1st: Template, 2nd: char index
        private bool[][] m_arrCharWantBrokenMarkResult = new bool[8][];   // 1st: Template, 2nd: char index
        private string m_strErrorMessage = "";
        private string m_strResultTrack = "";
        private bool m_blnWantCheckTotalExcessMark = false;
        private bool m_blnWantCheckMarkAverageGrayValue = false;
        private bool m_blnWantUseUnitPatternAsMarkPattern = false;
        private bool m_blnWantUseExcessMissingMarkAffectScore = false;
        private float m_fCharROIOffsetX = 0;
        private float m_fCharROIOffsetY = 0;

        private bool m_blnWantUseMarkTypeInspectionSetting = false;
        private bool m_blnWantCheckCharExcessMark = true;
        private bool m_blnWantCheckCharMissingMark = true;
        private bool m_blnWantCheckCharBrokenMark = true;
        private bool m_blnWantCheckLogoExcessMark = true;
        private bool m_blnWantCheckLogoMissingMark = true;
        private bool m_blnWantCheckLogoBrokenMark = true;
        private bool m_blnWantCheckSymbol1ExcessMark = true;
        private bool m_blnWantCheckSymbol1MissingMark = true;
        private bool m_blnWantCheckSymbol1BrokenMark = true;
        private bool m_blnWantCheckSymbol2ExcessMark = true;
        private bool m_blnWantCheckSymbol2MissingMark = true;
        private bool m_blnWantCheckSymbol2BrokenMark = true;

        private ROI m_objBuildObjectROI = new ROI();
        private ROI m_objJointMarkROI = new ROI();
        private ROI m_objLocalTemporary_RotateSearchROI = new ROI();
        private Blobs[] m_objLearnBlobs = new Blobs[8];
        private EBlobs[] m_objBlobs = new EBlobs[8];
        private EBlobs[] m_objAveGrayBlobs = new EBlobs[8];
        private EBlobs[] m_objJointMarkBlobs = new EBlobs[8];
        private EBlobs[] m_objExcessBlobs = new EBlobs[8];
        private EBlobs[] m_objMissingBlobs = new EBlobs[8];
        private EBlobs[] m_objBrokenBlobs = new EBlobs[8];
        private Font m_Font = new Font("Verdana", 10);
        private List<String> m_arrRefChars = new List<String>();
        private List<List<NOCV>> m_arrOCV = new List<List<NOCV>>();   // First Dimension: Group, Second Dimension: Template    
        private Mark2DCode m_objMark2DCode; // = new Mark2DCode(); // 2019-10-11 ZJYEOH : Cannot Init here as dongle dont have this lisence will cause error
        private List<List<TemplateSetting>> m_arrTemplateSetting = new List<List<TemplateSetting>>();   // First Dimension: Group/ Unit No, Second Dimension: Template    
        private OCR m_objOCR = new OCR();               // OCR no group and template dimension. 1 used for all.
        private OCR2 mobjOCR = new OCR2();
        private NOCV m_objOCV;             // For learning purpose. (Tolerance will be reset after learning, separately ocv will be use for learning.)
        private Object m_objLockBlobs = new Object();
        private bool m_blnLockBlobs = false;
        private Object m_objLockLearningBlobs = new object();
        private bool m_blnLock = false;
        private float m_fNoMarkMaximumBlobArea = 200f;
        private bool m_blnSeparateExtraMarkThreshold = false;
        private bool m_blnWantExcessMarkThresholdFollowExtraMarkThreshold = false;
        private bool m_blnWantDontCareArea = false;
        private bool m_blnWantCheckBarPin1 = false;
        private int m_intExtraExcessMarkInspectionAreaCutMode = 0;//0=No Cut, 1=Cut OCV ROI, 2=Cut Char ROI
        private int m_intCompensateMarkDiffSizeMode = 0;//0=Manual Iteration, 1=Auto Iteration
        private int m_intMarkScoreMode = 0; // 0 = Gradient + Binary (Default), 1 = Gradient, 2 = Binary
        private bool m_blnWantDontCareIgnoredMarkWholeArea = false;
        private bool m_blnWantCheckMakrAngle = false;
        private bool m_blnTrackOcvInspect = false;
        private int m_intMarkScoreOffset = 0;
        private int m_intMarkOriPositionScore = 70;
        private int m_intCharMinWidth = 0;
        private int m_intCharMaxWidth = 5;
        private int m_intCharHeight = 5;
        private string m_strConvertedTopologyValue = "";
        private object m_HitObject;
        private List<NOCV> m_arrOCVPrev = new List<NOCV>();
        private List<TemplateSetting> m_arrTemplateSettingPrev = new List<TemplateSetting>();
        public List<int> arrOCRCharSetting = new List<int>();
        private ImageDrawing obj_temp = new ImageDrawing();
        private ImageDrawing obj_temp2 = new ImageDrawing();

        class TemplateSetting
        {
            public int intFailOptionMask;
            public int intBrokenSize;
            public int intCharShiftXY;
            public float fExtraMinArea;
            public float fGroupExtraMinArea;
            public int intExcessMinArea;
            public float fGroupExcessMinArea;
            public int intMissingMinArea;
            public int intTextMinScore;
            public int intExtraMarkThreshold;
            public int intThreshold;
            public float fUnCheckAreaBottom;
            public float fUnCheckAreaLeft;
            public float fUnCheckAreaRight;
            public float fUnCheckAreaTop;
            public float fTextShiftX;
            public float fTextShiftY;
            public float fMarkAngleTolerance;
            public ImageDrawing objTemplateImage = new ImageDrawing();
            public ImageDrawing objLearnDilateImage = new ImageDrawing();
            public List<ImageDrawing> arrLearnDilateImage = new List<ImageDrawing>();
            public List<ImageDrawing> arrLearnErodeImage = new List<ImageDrawing>();
            public ImageDrawing objLearnErodeImage = new ImageDrawing();
            public ImageDrawing objDontCareImage = new ImageDrawing();
            public List<ImageDrawing> arrDontCareImage = new List<ImageDrawing>();
            public List<int> intCharSetting = new List<int>();
            public List<int> intCharDividedLargestArea = new List<int>();

            //public List<List<List<float>>> fCharPartitionArea = new List<List<List<float>>>();  // [char index][grid y index][grid x index]
            //public List<List<List<float>>> fCharPartitionPercent = new List<List<List<float>>>(); // [char index][grid y index][grid x index]

            //// hex 0x01 for touch ROI, 0x02 for link ROI, 0x04 center white.
            //public List<List<List<int>>> intCharLink_Left = new List<List<List<int>>>();
            //public List<List<List<int>>> intCharLink_Right = new List<List<List<int>>>();
            //public List<List<List<int>>> intCharLink_Top = new List<List<List<int>>>();
            //public List<List<List<int>>> intCharLink_Bottom = new List<List<List<int>>>();
            //public List<List<List<int>>> arrCharInfo = new List<List<List<int>>>();

            //public List<List<List<MarkGrid>>> arrMarkGrid = new List<List<List<MarkGrid>>>();

            public List<float> fAverageGray = new List<float>();
            public List<float> fMaxAGVPercent = new List<float>();
            public List<float> fCharShiftX = new List<float>();
            public List<float> fCharShiftY = new List<float>();
            public List<float> intTextCharOffsetX = new List<float>();
            public List<float> intTextCharOffsetY = new List<float>();
            public List<float> arrMaxExcessArea = new List<float>();
            public List<float> arrMaxBrokenArea = new List<float>();
            public List<bool> arrWantBrokenMark = new List<bool>();
            public List<bool> blnEnable = new List<bool>();
            public List<int> arrMarkType = new List<int>(); // 0=Char , 1=Logo , 2=Symbol1 , 3=Symbol2
            public List<ROI> arrTemplateTextROI = new List<ROI>();
            public List<ROI> arrTemplateCharErodeROI = new List<ROI>();
            public List<ROI> arrTemplateCharDilateROI = new List<ROI>();
            public List<bool> blnIsBarPin1 = new List<bool>();
            public List<int> arrBarPin1Type = new List<int>(); //0 = height > width, 1= width > height
        }

        private ImageDrawing m_objSampleImage = new ImageDrawing(true);
        private ImageDrawing m_objDontCareBackupImage = new ImageDrawing();
        private ImageDrawing m_objHandMadeImage = new ImageDrawing(true);


        // Calibration
        private float m_fMMPerPixelX = 1;
        private float m_fMMPerPixelY = 1;
        private float m_fMMPerPixelArea = 1;
        private float m_fMMToPixelXValue = 1;
        private float m_fMMToPixelYValue = 1;
        private float m_fMMtoPixelAreaValue = 1;

        private float m_fMMToUnitValue = 1;
        private float m_fMMToUnitValueArea = 1;
        private int m_intDisplayUnitMode = 0; // 0=pixel(default) , 1=mm, 2=mil, 3=micron
        #endregion

        #region Properties
        public int ref_intPin1PositionControl { get { return m_intPin1PositionControl; } set { m_intPin1PositionControl = value; } }
        public int ref_intPin1ImageNo { get { return m_intPin1ImageNo; } set { m_intPin1ImageNo = value; } }
        public int ref_intDisplayUnitMode { get { return m_intDisplayUnitMode; } set { m_intDisplayUnitMode = value; } }
        public bool ref_blnUseDefaultSettingMarkAfterClearTemplate { get { return m_blnUseDefaultSettingMarkAfterClearTemplate; } set { m_blnUseDefaultSettingMarkAfterClearTemplate = value; } }
        public bool ref_blnWantUseMarkTypeInspectionSetting { get { return m_blnWantUseMarkTypeInspectionSetting; } set { m_blnWantUseMarkTypeInspectionSetting = value; } }
        public bool ref_blnWantCheckCharExcessMark { get { return m_blnWantCheckCharExcessMark; } set { m_blnWantCheckCharExcessMark = value; } }
        public bool ref_blnWantCheckCharMissingMark { get { return m_blnWantCheckCharMissingMark; } set { m_blnWantCheckCharMissingMark = value; } }
        public bool ref_blnWantCheckCharBrokenMark { get { return m_blnWantCheckCharBrokenMark; } set { m_blnWantCheckCharBrokenMark = value; } }
        public bool ref_blnWantCheckTotalExcessMark { get { return m_blnWantCheckTotalExcessMark; } set { m_blnWantCheckTotalExcessMark = value; } }
        public bool ref_blnWantCheckMarkAverageGrayValue { get { return m_blnWantCheckMarkAverageGrayValue; } set { m_blnWantCheckMarkAverageGrayValue = value; } }
        public bool ref_blnWantUseUnitPatternAsMarkPattern { get { return m_blnWantUseUnitPatternAsMarkPattern; } set { m_blnWantUseUnitPatternAsMarkPattern = value; } }
        public bool ref_blnWantUseExcessMissingMarkAffectScore { get { return m_blnWantUseExcessMissingMarkAffectScore; } set { m_blnWantUseExcessMissingMarkAffectScore = value; } }
        public float ref_fCharROIOffsetX { get { return m_fCharROIOffsetX; } set { m_fCharROIOffsetX = value; } }
        public float ref_fCharROIOffsetY { get { return m_fCharROIOffsetY; } set { m_fCharROIOffsetY = value; } }
        public bool ref_blnWantCheckLogoExcessMark { get { return m_blnWantCheckLogoExcessMark; } set { m_blnWantCheckLogoExcessMark = value; } }
        public bool ref_blnWantCheckLogoMissingMark { get { return m_blnWantCheckLogoMissingMark; } set { m_blnWantCheckLogoMissingMark = value; } }
        public bool ref_blnWantCheckLogoBrokenMark { get { return m_blnWantCheckLogoBrokenMark; } set { m_blnWantCheckLogoBrokenMark = value; } }
        public bool ref_blnWantCheckSymbol1ExcessMark { get { return m_blnWantCheckSymbol1ExcessMark; } set { m_blnWantCheckSymbol1ExcessMark = value; } }
        public bool ref_blnWantCheckSymbol1MissingMark { get { return m_blnWantCheckSymbol1MissingMark; } set { m_blnWantCheckSymbol1MissingMark = value; } }
        public bool ref_blnWantCheckSymbol1BrokenMark { get { return m_blnWantCheckSymbol1BrokenMark; } set { m_blnWantCheckSymbol1BrokenMark = value; } }
        public bool ref_blnWantCheckSymbol2ExcessMark { get { return m_blnWantCheckSymbol2ExcessMark; } set { m_blnWantCheckSymbol2ExcessMark = value; } }
        public bool ref_blnWantCheckSymbol2MissingMark { get { return m_blnWantCheckSymbol2MissingMark; } set { m_blnWantCheckSymbol2MissingMark = value; } }
        public bool ref_blnWantCheckSymbol2BrokenMark { get { return m_blnWantCheckSymbol2BrokenMark; } set { m_blnWantCheckSymbol2BrokenMark = value; } }
        public int ref_intTotalBlob { get { return m_intTotalBlobArea; } set { m_intTotalBlobArea = value; } }
        public int ref_intMarkTextShiftMethod { get { return m_intMarkTextShiftMethod; } set { m_intMarkTextShiftMethod = value; } }
        public bool ref_blnWantUseGrayValue { get { return m_blnWantUseGrayValue; } set { m_blnWantUseGrayValue = value; } }
        public int ref_intMarkInspectionAreaGrayValueSensitivity { get { return m_intMarkInspectionAreaGrayValueSensitivity; } set { m_intMarkInspectionAreaGrayValueSensitivity = value; } }
        public int ref_intMarkBrightSensitivity { get { return m_intMarkBrightSensitivity; } set { m_intMarkBrightSensitivity = value; } }
        public bool ref_blnInspectAllTemplate { get { return m_blnInspectAllTemplate; } set { m_blnInspectAllTemplate = value; } }
        public bool ref_blnWhiteOnBlack { get { return m_blnWhiteOnBlack; } set { m_blnWhiteOnBlack = value; } }
        public bool ref_blnWantSampleAreaScore { get { return m_blnWantSampleAreaScore; } set { m_blnWantSampleAreaScore = value; } }
        public bool ref_blnCheckMark { get { return m_blnCheckMark; } set { m_blnCheckMark = value; } }
        public int ref_intDefaultCharSetting { get { return m_intDefaultCharSetting; } set { m_intDefaultCharSetting = value; } }
        public int ref_intFailOptionMask { get { return m_intFailOptionMask; } set { m_intFailOptionMask = value; } }
        public int ref_intFailOptionMask_ForPreTest { get { return m_intFailOptionMask_ForPreTest; } set { m_intFailOptionMask_ForPreTest = value; } }
        public int ref_intFailResultMask { get { return m_intFailResultMask; } set { m_intFailResultMask = value; } }
        public int ref_intFailResultMask_ForPreTest { get { return m_intFailResultMask_ForPreTest; } set { m_intFailResultMask_ForPreTest = value; } }
        public int ref_intGroupIndex { get { return m_intGroupIndex; } set { m_intGroupIndex = value; } }
        public int ref_intHitCharIndex { get { return m_intHitCharIndex; } set { m_intHitCharIndex = value; } }
        public int ref_intMinArea { get { return m_intMinArea; } set { m_intMinArea = value; } }
        //public int ref_intMarkROIOffsetTop { get { return m_intMarkROIOffsetTop; } set { m_intMarkROIOffsetTop = value; } }
        //public int ref_intMarkROIOffsetRight { get { return m_intMarkROIOffsetRight; } set { m_intMarkROIOffsetRight = value; } }
        //public int ref_intMarkROIOffsetBottom { get { return m_intMarkROIOffsetBottom; } set { m_intMarkROIOffsetBottom = value; } }
        //public int ref_intMarkROIOffsetLeft { get { return m_intMarkROIOffsetLeft; } set { m_intMarkROIOffsetLeft = value; } }
        public int ref_intLeadDontCareInwardTolerance_Top { get { return m_intLeadDontCareInwardTolerance_Top; } set { m_intLeadDontCareInwardTolerance_Top = value; } }
        public int ref_intLeadDontCareInwardTolerance_Right { get { return m_intLeadDontCareInwardTolerance_Right; } set { m_intLeadDontCareInwardTolerance_Right = value; } }
        public int ref_intLeadDontCareInwardTolerance_Bottom { get { return m_intLeadDontCareInwardTolerance_Bottom; } set { m_intLeadDontCareInwardTolerance_Bottom = value; } }
        public int ref_intLeadDontCareInwardTolerance_Left { get { return m_intLeadDontCareInwardTolerance_Left; } set { m_intLeadDontCareInwardTolerance_Left = value; } }
        public int ref_intLearnMinArea { get { return m_intLearnMinArea; } set { m_intLearnMinArea = value; } }
        public int ref_intMaxArea { get { return m_intMaxArea; } set { m_intMaxArea = value; } }
        public int ref_intTemplateIndex { get { return m_intTemplateIndex; } set { m_intTemplateIndex = value; } }
        public int ref_intTemplateMask { get { return m_intTemplateMask; } set { m_intTemplateMask = value; } }
        public int ref_intCharErodeHalfWidth { get { return m_intCharErodeHalfWidth; } set { m_intCharErodeHalfWidth = value; } }
        public int ref_intCharOpenHalfWidth { get { return m_intCharOpenHalfWidth; } set { m_intCharOpenHalfWidth = value; } }
        public int ref_intEnhanceMark_LinkMark_HalfWidth { get { return m_intEnhanceMark_LinkMark_HalfWidth; } set { m_intEnhanceMark_LinkMark_HalfWidth = value; } }
        public int ref_intEnhanceMark_ReduceNoise_HalfWidth { get { return m_intEnhanceMark_ReduceNoise_HalfWidth; } set { m_intEnhanceMark_ReduceNoise_HalfWidth = value; } }
        public int ref_intCharDilateHalfWidth { get { return m_intCharDilateHalfWidth; } set { m_intCharDilateHalfWidth = value; } }
        public long ref_intTemplatePriority { get { return m_intTemplatePriority; } set { m_intTemplatePriority = value; } }
        public int ref_intMissingMarkInspectionMethod { get { return m_intMissingMarkInspectionMethod; } set { m_intMissingMarkInspectionMethod = value; } }
        public string ref_strErrorMessage { get { return m_strErrorMessage; } }
        public float ref_fNoMarkMaximumBlobArea { get { return m_fNoMarkMaximumBlobArea; } set { m_fNoMarkMaximumBlobArea = value; } }
        public bool ref_blnWantDontCareArea { get { return m_blnWantDontCareArea; } set { m_blnWantDontCareArea = value; } }
        public int ref_intMarkScoreOffset { get { return m_intMarkScoreOffset; } set { m_intMarkScoreOffset = value; } }
        public int ref_intMarkOriPositionScore { get { return m_intMarkOriPositionScore; } set { m_intMarkOriPositionScore = value; } }
        public bool ref_blnSeparateExtraMarkThreshold { get { return m_blnSeparateExtraMarkThreshold; } set { m_blnSeparateExtraMarkThreshold = value; } }
        public bool ref_blnWantExcessMarkThresholdFollowExtraMarkThreshold { get { return m_blnWantExcessMarkThresholdFollowExtraMarkThreshold; } set { m_blnWantExcessMarkThresholdFollowExtraMarkThreshold = value; } }
        public bool ref_blnWantCheckBarPin1 { get { return m_blnWantCheckBarPin1; } set { m_blnWantCheckBarPin1 = value; } }
        public int ref_intExtraExcessMarkInspectionAreaCutMode { get { return m_intExtraExcessMarkInspectionAreaCutMode; } set { m_intExtraExcessMarkInspectionAreaCutMode = value; } }
        public int ref_intCompensateMarkDiffSizeMode { get { return m_intCompensateMarkDiffSizeMode; } set { m_intCompensateMarkDiffSizeMode = value; } }
        public int ref_intMarkScoreMode { get { return m_intMarkScoreMode; } set { m_intMarkScoreMode = value; } }
        public bool ref_blnWantDontCareIgnoredMarkWholeArea { get { return m_blnWantDontCareIgnoredMarkWholeArea; } set { m_blnWantDontCareIgnoredMarkWholeArea = value; } }
        public bool[][] ref_blnCharResult { get { return m_blnCharResult; } }
        public int ref_intCharHeight { get { return m_intCharHeight; } set { m_intCharHeight = value; } }
        public int ref_intCharMinWidth { get { return m_intCharMinWidth; } set { m_intCharMinWidth = value; } }
        public int ref_intCharMaxWidth { get { return m_intCharMaxWidth; } set { m_intCharMaxWidth = value; } }
        public string ref_strTopologyValue { get { return m_strConvertedTopologyValue; } set { m_strConvertedTopologyValue = value; } }
        public object ref_HitObject { get { return m_HitObject; } set { m_HitObject = value; } }
        #endregion

        private TrackLog m_objTL = new TrackLog();
        public TrackLog ref_objTL { get { return m_objTL; } set { m_objTL = value; } }

        public string ref_strResultTrack { get { return m_strResultTrack; } }
        public bool ref_blnTrackOcvInspect { get { return m_blnTrackOcvInspect; } set { m_blnTrackOcvInspect = value; } }
        public bool ref_blnExtraSaveImageAndRecipeDueToException { get { return m_blnExtraSaveImageAndRecipeDueToException; } set { m_blnExtraSaveImageAndRecipeDueToException = value; } }
        /// <summary>
        /// Construction of Class
        /// </summary>
        /// <param name="intInspectionMode">0 = OCV mode, 1 = OCR mode</param>
        public Mark(int intInspectionMode, int intImageWidth, int intImageHeight)
        {
            m_intInspectionMode = intInspectionMode;
            m_intImageWidth = intImageWidth;
            m_intImageHeight = intImageHeight;

            m_objOCV = new NOCV(intImageWidth, intImageHeight);

            // Only 1 group
            m_intGroupNum = 1;

            if (m_intInspectionMode == 0)
                m_arrOCV.Add(new List<NOCV>());
            else
                m_arrRefChars.Add("");

            m_arrTemplateSetting.Add(new List<TemplateSetting>());
            m_intGroupIndex = 0;
        }

        public Mark(int intInspectionMode, int intGroupNum)
        {
            m_intInspectionMode = intInspectionMode;

            // Multi group
            m_intGroupNum = intGroupNum;

            for (int i = 0; i < intGroupNum; i++)
            {
                if (m_intInspectionMode == 0)
                    m_arrOCV.Add(new List<NOCV>());
                else
                    m_arrRefChars.Add("");

                m_arrTemplateSetting.Add(new List<TemplateSetting>());
            }
            m_intGroupIndex = 0;
        }

        public void Init2DCode()
        {
            if (m_objMark2DCode == null)
                m_objMark2DCode = new Mark2DCode();
        }

        public bool BuildObject(ROI objROI, bool blnRemoveBorder, bool blnConnexity4)
        {
            if (m_objBlobs[m_intTemplateIndex] == null)
                m_objBlobs[m_intTemplateIndex] = new EBlobs();
            else
                m_objBlobs[m_intTemplateIndex].CleanAllBlobs();

            return BuildObject(m_objBlobs[m_intTemplateIndex], objROI, blnRemoveBorder, blnConnexity4, m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intThreshold);
        }

        public bool BuildLearnObject(ROI objROI, bool blnRemoveBorder, bool blnConnexity4)
        {
            //lock (m_objLockLearningBlobs)
            //{
            //    if (m_objLearnBlobs[m_intTemplateIndex] != null)
            //    {
            //        m_objLearnBlobs[m_intTemplateIndex].ref_Blob.RemoveAllFeats();
            //        m_objLearnBlobs[m_intTemplateIndex].ref_Blob.RemoveAllRuns();
            //        m_objLearnBlobs[m_intTemplateIndex].ref_Blob.RemoveAllObjects();

            //        m_objLearnBlobs[m_intTemplateIndex].Dispose();
            //        m_objLearnBlobs[m_intTemplateIndex] = null;
            //    }

            //    m_objLearnBlobs[m_intTemplateIndex] = new Blobs();

            //    return BuildLearnObject(m_objLearnBlobs[m_intTemplateIndex], objROI, blnRemoveBorder, blnConnexity4, m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intThreshold);
            //}

            lock (m_objLockLearningBlobs)
            {
                //m_objLearnBlobs[m_intTemplateIndex] = new Blobs();
                if (m_objLearnBlobs[m_intTemplateIndex] == null)
                {
                    m_objLearnBlobs[m_intTemplateIndex] = new Blobs();
                }
                else
                {
                    //m_objLearnBlobs[m_intTemplateIndex].ref_Blob.RemoveAllFeats();    // 2020 06 29 - CCENG: dont call this function, it will cause "Error Close After Learn Mark" issue.
                    m_objLearnBlobs[m_intTemplateIndex].ref_Blob.RemoveAllRuns();
                    m_objLearnBlobs[m_intTemplateIndex].ref_Blob.RemoveAllObjects();
                }

                return BuildLearnObject(m_objLearnBlobs[m_intTemplateIndex], objROI, blnRemoveBorder, blnConnexity4, m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intThreshold);
            }
        }
        public bool BuildLearnObject_UsingGrayValue(ROI objROI, bool blnRemoveBorder, bool blnConnexity4, int intInspectionAreaGrayValueSensitivity, int intBrightSensitivity)
        {
            lock (m_objLockLearningBlobs)
            {
                if (m_objLearnBlobs[m_intTemplateIndex] != null)
                {
                    //m_objLearnBlobs[m_intTemplateIndex].ref_Blob.RemoveAllFeats();    // 2020 06 29 - CCENG: dont call this function, it will cause "Error Close After Learn Mark" issue.
                    m_objLearnBlobs[m_intTemplateIndex].ref_Blob.RemoveAllRuns();
                    m_objLearnBlobs[m_intTemplateIndex].ref_Blob.RemoveAllObjects();

                    m_objLearnBlobs[m_intTemplateIndex].Dispose();
                    m_objLearnBlobs[m_intTemplateIndex] = null;
                }

                m_objLearnBlobs[m_intTemplateIndex] = new Blobs();

                int intThreshold = GetGrayValueThreshold(objROI, intInspectionAreaGrayValueSensitivity, intBrightSensitivity);

                return BuildLearnObject(m_objLearnBlobs[m_intTemplateIndex], objROI, blnRemoveBorder, blnConnexity4, intThreshold);
            }
        }
        public bool BuildLearnObject(Blobs objBlobs, ROI objROI, bool blnRemoveBorder, bool blnConnexity4, int intThreshold)
        {
            if (objROI.ref_ROIWidth == 0 || objROI.ref_ROIHeight == 0)
            {
                m_strErrorMessage = "ROI size is zero!";
                return false;
            }

            objBlobs.ref_intThreshold = intThreshold;
            if (blnConnexity4)
                objBlobs.SetConnexity(4);
            else
                objBlobs.SetConnexity(8);
            if (m_blnWhiteOnBlack)
                objBlobs.SetClassSelection(2);
            else
                objBlobs.SetClassSelection(1);

            objBlobs.SetObjectAreaRange(m_intLearnMinArea, objROI.ref_ROIWidth * objROI.ref_ROIHeight + 1);//m_intMaxArea 2021-04-11 ZJYEOH : dont use hard code max area, because cnt build blob for unit without mark

            // 2019 02 12 - why use NoSorting because the sorting function [m_Blob.SortObjectsUsingFeature] will cause application auto exit in production pc (weird case)
            objBlobs.BuildObjects_NoSorting(objROI, blnRemoveBorder);

            if (objBlobs.ref_intNumSelectedObject == 0)
                return false;

            return true;
        }
       
        public bool BuildObject(EBlobs objBlobs, ROI objROI, bool blnRemoveBorder, bool blnConnexity4, int intThreshold)
        {
            if (objROI.ref_ROIWidth == 0 || objROI.ref_ROIHeight == 0)
            {
                m_strErrorMessage = "ROI size is zero!";
                return false;
            }


            if (objBlobs.BuildObjects_Filter_GetElement(objROI, !m_blnWhiteOnBlack, false, 0, intThreshold,
                m_intMinArea, m_intMaxArea, blnRemoveBorder, 0xFF) == 0)
                return false;

            return true;
        }

        public bool BuildObject(EBlobs objBlobs, ROI objROI, bool blnRemoveBorder, bool blnConnexity4, int intThreshold, int intMinArea, int intMaxArea, int intCriteria)
        {
            if (objROI.ref_ROIWidth == 0 || objROI.ref_ROIHeight == 0)
            {
                m_strErrorMessage = "ROI size is zero!";
                return false;
            }

            if (objBlobs.BuildObjects_Filter_GetElement(objROI, !m_blnWhiteOnBlack, blnConnexity4, 0, intThreshold, intMinArea, intMaxArea, blnRemoveBorder, intCriteria) == 0)
                return false;

            //objBlobs.ref_intThreshold = intThreshold;
            //if (blnConnexity4)
            //    objBlobs.SetConnexity(4);
            //else
            //    objBlobs.SetConnexity(8);
            //if (m_blnWhiteOnBlack)
            //    objBlobs.SetClassSelection(2);
            //else
            //    objBlobs.SetClassSelection(1);

            //objBlobs.SetObjectAreaRange(intMinArea, intMaxArea);
            //objBlobs.ref_intFeature = intCriteria;
            //objBlobs.BuildObjects(objROI, blnRemoveBorder);

            //if (objBlobs.ref_intNumSelectedObject == 0)
            //    return false;

            return true;
        }

        public bool GetCharResult(int intCharIndex)
        {
            if (intCharIndex >= m_blnCharResult[m_intTemplateIndex].Length)
                return false;

            return m_blnCharResult[m_intTemplateIndex][intCharIndex];
        }
        public bool GetCharResult(int intCharIndex, int intTemplateIndex)
        {
            if (m_blnCharResult[intTemplateIndex] == null)
                return false;

            if (intCharIndex >= m_blnCharResult[intTemplateIndex].Length)
                return false;

            return m_blnCharResult[intTemplateIndex][intCharIndex];
        }
        public bool InspectOCRMark(ImageDrawing objImage, ROI objROI, bool blnRecogPosition)
        {
            /*
             *  Reset previous inspection data
             *  Get true threshold
             *  Build objects
             *  OCV/OCR inspection
             *      - Check ref char
             *      - Check recognized char score
             *      - Check recognized char position
             *  Check Text Shifted
             *  Blobs Inspection : Extra Mark(Check Area, Uncheck Area, Group Area), Missing Mark, Broken Mark)
             *  Subtract Inspection : Extra Mark Char Area
             */

            m_blnLock = true;

            WaitEventDone(ref m_blnLockBlobs, false);

            //lock (m_objLockBlobs)
            {
                m_blnLockBlobs = true;
                int intNoSelectedBlobs = 0;
                int intNumChars = 0;
                int j;
                ResetInspectionData(true);

                // Check valid image
                if (objROI.ref_ROI.Width == 0)
                {
                    m_strErrorMessage = "ROI image is empty!";
                    m_blnLock = false;
                    m_blnLockBlobs = false;
                    return false;
                }

                // Get threshold true value
                int intThresholdValue = GetAutoThreshold(objROI);

                // Get off set ROI for drawing purpose
                m_intROIOffSetX = objROI.ref_ROI.Parent.OrgX + objROI.ref_ROI.OrgX;
                m_intROIOffSetY = objROI.ref_ROI.Parent.OrgY + objROI.ref_ROI.OrgY;

                // Define build blob ROI
                ROI m_objBuildObjectROI = DefineBuildBlobROI(objImage, objROI, (m_intFailOptionMask & 0x04) > 0);

                // Get off set ROI for blob-OCV matching and drawing purpose 
                m_intROIOffSetX = objROI.ref_ROI.TotalOrgX;
                m_intROIOffSetY = objROI.ref_ROI.TotalOrgY;
                m_intBlobOCVOffSetX = m_objBuildObjectROI.ref_ROIPositionX - m_intROIOffSetX;
                m_intBlobOCVOffSetY = m_objBuildObjectROI.ref_ROIPositionY - m_intROIOffSetY;

                m_strErrorMessage = "";
                m_intFailResultMask = 0;

                // Build blobs 
                if (m_objBlobs[m_intTemplateIndex] == null)
                    m_objBlobs[m_intTemplateIndex] = new EBlobs();
                else
                    m_objBlobs[m_intTemplateIndex].CleanAllBlobs();

                if (!BuildObject(m_objBlobs[m_intTemplateIndex], m_objBuildObjectROI, false, true, intThresholdValue, 0, 1000000, 0x1F))
                {
                    m_strErrorMessage = "BuildObjects : No blobs object selected!";
                    m_blnLock = false;
                    m_blnLockBlobs = false;
                    return false;
                }

                intNoSelectedBlobs = m_objBlobs[m_intTemplateIndex].ref_intNumSelectedObject;

                #region OCR Inspection

                // Set ref char counter if multi group
                if (m_intGroupNum > 1)
                    m_objOCR.SetRefCharCounter(m_arrRefChars[m_intGroupIndex]);

                // Recognize characters
                string strRecogString = m_objOCR.RecognizeCharsTextArea(objImage, objROI, blnRecogPosition);//.RecognizePatternByMatcher(objImage, objROI, m_arrRefChars[m_intGroupIndex]); //m_objOCR.RecognizePattern(objImage, objROI);

                // init char data
                intNumChars = m_objOCR.ref_NumChars;
                m_blnCharResult[0] = new bool[intNumChars];
                m_intHitCharCounter = new int[intNumChars];
                for (int i = 0; i < intNumChars; i++)
                {
                    m_intHitCharCounter[i] = 0;
                }

                // Check Ref Chars Mismatch
                if (m_intGroupIndex < m_arrRefChars.Count)
                {
                    if (strRecogString != m_arrRefChars[m_intGroupIndex])
                        m_intFailResultMask |= 0x400;
                }

                // Check score setting
                int[] intMatchPatternIndex;
                float fScore;
                for (int i = 0; i < intNumChars; i++)
                {
                    fScore = m_objOCR.GetCharScore(i);
                    intMatchPatternIndex = m_objOCR.GetMatchPatternIndexes(i);
                    for (j = 0; j < intMatchPatternIndex.Length; j++)
                    {
                        if (fScore >= m_arrTemplateSetting[m_intGroupIndex][0].intCharSetting[intMatchPatternIndex[j]])
                            break;
                    }

                    if (j == intMatchPatternIndex.Length)
                    {
                        m_blnCharResult[0][i] = false;
                        if ((m_intFailResultMask & 0x100) == 0)
                            m_intFailResultMask |= 0x100;
                    }
                    else
                        m_blnCharResult[0][i] = true;
                }

                //if (m_intFailResultMask > 0)
                //{
                //    m_blnLock = false;
                //    return false;
                //}

                #endregion

                #region Check Text Shifted
                if ((m_intFailOptionMask & 0x40) > 0)
                {
                    if (!CheckTextShifted(0, 0, objROI.ref_ROIWidth, objROI.ref_ROIHeight))
                    {
                        m_intFailResultMask |= 0x40;
                        m_blnLock = false;
                        m_blnLockBlobs = false;
                        return false;
                    }
                }
                #endregion

                #region Blobs Inspection
                bool blnGroupExtraMark = false;
                float fCenterX, fCenterY, fWidth, fHeight, fAngle, fGravityCenterX, fGravityCenterY, fStartX, fStartY, fEndX, fEndY;
                int intArea = 0, intContourX = 0, intContourY = 0;
                int intTotalExtraMarkArea = 0;

                // Init blob data
                m_intBlobResult[m_intTemplateIndex] = new int[intNoSelectedBlobs];
                for (j = 0; j < intNoSelectedBlobs; j++)
                {
                    m_intBlobResult[m_intTemplateIndex][j] = 0;
                }

                TemplateSetting objTemplateSetting = m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex];

                fCenterX = fCenterY = fWidth = fHeight = fAngle = fGravityCenterX = fGravityCenterY = 0;

                for (int i = 0; i < intNoSelectedBlobs; i++)
                {
                    fCenterX = m_objBlobs[m_intTemplateIndex].ref_arrLimitCenterX[i];
                    fCenterY = m_objBlobs[m_intTemplateIndex].ref_arrLimitCenterY[i];
                    fWidth = m_objBlobs[m_intTemplateIndex].ref_arrWidth[i];
                    fHeight = m_objBlobs[m_intTemplateIndex].ref_arrHeight[i];
                    fGravityCenterX = m_objBlobs[m_intTemplateIndex].ref_arrGravityCenterX[i];
                    fGravityCenterY = m_objBlobs[m_intTemplateIndex].ref_arrGravityCenterY[i];
                    intArea = m_objBlobs[m_intTemplateIndex].ref_arrArea[i];
                    intContourX = m_objBlobs[m_intTemplateIndex].ref_arrContourX[i];
                    intContourY = m_objBlobs[m_intTemplateIndex].ref_arrContourY[i];

                    // Use m_intMinArea as min area if m_intMinArea < 5, else use 5 as min area
                    if (m_intMinArea < 5)
                    {
                        // skip checking if blob area lower than setting
                        if (intArea <= m_intMinArea)
                        {
                            continue;
                        }
                    }
                    else
                    {
                        // skip checking if blob area lower than setting
                        if (intArea <= 5)
                        {
                            continue;
                        }
                    }

                    // Get blob start point and end point
                    fStartX = fCenterX - fWidth / 2 + m_intBlobOCVOffSetX;
                    fStartY = fCenterY - fHeight / 2 + m_intBlobOCVOffSetY;
                    fEndX = fCenterX + fWidth / 2 + m_intBlobOCVOffSetX;
                    fEndY = fCenterY + fHeight / 2 + m_intBlobOCVOffSetY;

                    List<int> intMatchNumber = m_objOCR.GetMatchCharIndexes(fStartX, fStartY, fEndX, fEndY);
                    // By using contour, double check again the selected OCV Char rectangle box is/are really matched by blobs
                    if (intMatchNumber.Count > 0)
                    {
                        for (int e = 0; e < intMatchNumber.Count; e++)
                        {
                            // Build contour elements for the selected blob
                            Contour objContour = new Contour();
                            objContour.ClearContour();
                            if (objContour.BuildContour(m_objBuildObjectROI, intContourX, intContourY, intThresholdValue, 4))
                            {
                                // Check is the blob in OCV Char rectangle box
                                if (!m_objOCR.IsInOCRCharArea(objContour, intMatchNumber[e]))
                                {
                                    intMatchNumber.RemoveAt(e);
                                    e--;
                                }
                            }
                        }
                    }

                    if (intMatchNumber.Count == 0)
                    {
                        // Check Group Extra Mark
                        if ((m_intFailOptionMask & 0x08) > 0)
                        {
                            m_intGroupExtraMarkArea[m_intTemplateIndex] += intArea;
                            m_intBlobResult[m_intTemplateIndex][i] = 1;

                            if (m_intGroupExtraMarkArea[m_intTemplateIndex] > (int)Math.Round(objTemplateSetting.fGroupExtraMinArea))
                            {
                                m_intBlobResult[m_intTemplateIndex][i] = 2;

                                if (!blnGroupExtraMark)
                                {
                                    m_intFailResultMask |= 0x08;
                                    blnGroupExtraMark = true;

                                    // Upgrade result from 1 to 2
                                    for (j = 0; j < intNoSelectedBlobs; j++)
                                    {
                                        if (m_intBlobResult[m_intTemplateIndex][j] == 1)
                                            m_intBlobResult[m_intTemplateIndex][j] = 2;
                                    }
                                }
                            }
                        }

                        // Make sure object area is higher than min area and extra min area
                        if ((intArea < m_intMinArea) || (intArea < (int)Math.Round(objTemplateSetting.fExtraMinArea)))
                        {
                            continue;
                        }

                        // Check Extra Mark 
                        if (((m_intFailOptionMask & 0x02) > 0) || ((m_intFailOptionMask & 0x04) > 0))
                        {
                            m_intBlobResult[m_intTemplateIndex][i] = 2;

                            if ((m_intFailResultMask & 0x01) == 0)
                                m_intFailResultMask |= 0x01;
                        }
                    }
                    else
                    {
                        // Make sure area >= min area
                        if (intArea < m_intMinArea)
                        {
                            continue;
                        }

                        // Set char hit by blob counter
                        for (j = 0; j < intMatchNumber.Count; j++)
                        {
                            m_intHitCharCounter[intMatchNumber[j]]++;
                        }

                        // Check joint mark
                        if (intMatchNumber.Count > 1)
                        {
                            if ((m_intFailOptionMask & 0x80) > 0)
                            {
                                m_intBlobResult[m_intTemplateIndex][i] = 2;

                                for (int q = 0; q < intMatchNumber.Count; q++)
                                    m_blnCharResult[m_intTemplateIndex][intMatchNumber[q]] = false;

                                if ((m_intFailResultMask & 0x80) == 0)
                                    m_intFailResultMask |= 0x80;
                            }
                        }
                        else if (intMatchNumber.Count == 1)
                        {
                            // Check Broken Mark (based on size)
                            int intWidth = 0, intHeight = 0;
                            m_objOCR.GetCharSize(intMatchNumber[0], ref intWidth, ref intHeight);

                            if ((m_intFailOptionMask & 0x20) > 0)
                            {
                                if (fWidth < (intWidth - objTemplateSetting.intBrokenSize))
                                {
                                    m_fGroupBrokenMarkLength[m_intTemplateIndex] = intWidth - fWidth;
                                    m_intBlobResult[m_intTemplateIndex][i] = 2;

                                    m_blnCharResult[m_intTemplateIndex][intMatchNumber[0]] = false;

                                    if ((m_intFailResultMask & 0x20) == 0)
                                        m_intFailResultMask |= 0x20;
                                }
                                else if (fHeight < (intHeight - objTemplateSetting.intBrokenSize))
                                {
                                    m_fGroupBrokenMarkLength[m_intTemplateIndex] = intHeight - fHeight;
                                    m_intBlobResult[m_intTemplateIndex][i] = 2;

                                    m_blnCharResult[m_intTemplateIndex][intMatchNumber[0]] = false;

                                    if ((m_intFailResultMask & 0x20) == 0)
                                        m_intFailResultMask |= 0x20;
                                }
                            }
                        }
                    }
                }

                for (int i = 0; i < intNumChars; i++)
                {
                    // Check Missing Mark
                    if ((m_intFailOptionMask & 0x10) > 0)
                    {
                        if (m_intHitCharCounter[i] == 0)
                        {
                            m_blnCharResult[m_intTemplateIndex][i] = false;

                            if ((m_intFailResultMask & 0x10) == 0)
                                m_intFailResultMask |= 0x10;
                        }
                    }

                    // Check Broken Mark (Based on quantity blobs in char area)
                    if ((m_intFailOptionMask & 0x20) > 0)
                    {
                        if (m_intHitCharCounter[i] > 1)
                        {
                            m_blnCharResult[m_intTemplateIndex][i] = false;

                            if ((m_intFailResultMask & 0x20) == 0)
                                m_intFailResultMask |= 0x20;
                        }
                    }
                }
                #endregion

                //#region Check extra mark in characters area using substract function and grey value

                //if (((m_intFailOptionMask & 0x01) > 0) && m_intFailResultMask == 0)
                //{
                //    /*
                //     * Sample ROI = objROI
                //     * Template ROI = ocr pattern roi
                //     * Subtract ROI = new ROI
                //     */

                //    // Init Template ROI
                //    ROI objTemplateROI;
                //    // Init Sample ROI
                //    ROI objSampleROI = new ROI();
                //    objSampleROI.AttachImage(objROI);
                //    // Init Subtracted ROI (result)
                //    ImageDrawing objSubtractedImage = new ImageDrawing();
                //    objImage.CopyTo(ref objSubtractedImage);
                //    ROI objSubtractedROI = new ROI();
                //    objSubtractedROI.AttachImage(objSubtractedImage);

                //    int intStartX, intStartY, intWidth, intHeight;
                //    intStartX = intStartY = intWidth = intHeight = 0;
                //    for (int i = 0; i < intNumChars; i++)
                //    {
                //        objTemplateROI = m_objOCR.GetCharPatternROI(i);
                //        m_objOCR.GetCharStartPoint(i, ref intStartX, ref intStartY);
                //        m_objOCR.GetCharSize(i, ref intWidth, ref intHeight);

                //        objSampleROI.LoadROISetting(intStartX, intStartY, intWidth, intHeight);
                //        objSubtractedROI.LoadROISetting(m_intROIOffSetX + intStartX, m_intROIOffSetY + intStartY, intWidth, intHeight);

                //        EasyImage.Oper(EArithmeticLogicOperation.Subtract, objSampleROI.ref_ROI, objTemplateROI.ref_ROI, objSubtractedROI.ref_ROI);
                //    }

                //    objSubtractedROI.LoadROISetting(m_intROIOffSetX, m_intROIOffSetY, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
                //    if (BuildObject(m_objDefectBlobs, objSubtractedROI, false, true, intThresholdValue))
                //    {
                //        intNoSelectedBlobs = m_objDefectBlobs.ref_intNumSelectedObject;
                //        m_intDefectBlobResult[0] = new int[intNoSelectedBlobs];

                //        m_objDefectBlobs.SetFirstListBlobs();
                //        for (int i = 0; i < intNoSelectedBlobs; i++)
                //        {
                //            m_objDefectBlobs.GetSelectedListBlobsLimitCenterX(ref fCenterX);
                //            m_objDefectBlobs.GetSelectedListBlobsLimitCenterY(ref fCenterY);
                //            m_objDefectBlobs.GetSelectedListBlobsWidth(ref fWidth);
                //            m_objDefectBlobs.GetSelectedListBlobsHeight(ref fHeight);
                //            m_objDefectBlobs.GetSelectedListBlobsArea(ref intArea);

                //            fStartX = fCenterX - fWidth / 2;
                //            fStartY = fCenterY - fHeight / 2;
                //            fEndX = fCenterX + fWidth / 2;
                //            fEndY = fCenterY + fHeight / 2;

                //            if ((intArea > m_intMinArea) && (intArea > objTemplateSetting.intExtraMinArea) &&
                //               (m_objOCR.GetMatchCharIndexes(fStartX, fStartY, fEndX, fEndY).Length > 0))
                //            {
                //                m_intDefectBlobResult[0][i] = 2;

                //                if ((m_intFailResultMask & 0x01) == 0)
                //                    m_intFailResultMask |= 0x01;
                //            }
                //            else
                //                m_intDefectBlobResult[0][i] = 0;

                //            m_objDefectBlobs.SetListBlobsToNext();
                //        }

                //    }
                //}

                //#endregion

                m_blnLock = false;
                m_blnLockBlobs = false;

                if (m_intFailResultMask > 0)
                    return false;
                else
                    return true;
            }
        }

        public bool InspectOCVMark_NewMethodForMultiExcessMark(bool blnAuto, ImageDrawing objImage, ROI objSearchROI, ROI objMarkROI, bool blnSkipExtraPadAndTextShiftedChecking, ImageDrawing objWhiteImage, ImageDrawing objBlackImage, bool blnWantCheckNoMark, bool blnContourCheck, bool blnWantCheckBrokenMark, bool blnByPassUnit, int intMinMarkScore)
        {
            /*
             *  Reset previous inspection data
             *  Get true threshold
             *  Build objects
             *  OCV/OCR inspection
             *      - Check ref char
             *      - Check recognized char score
             *      - Check recognized char position
             *  Check Text Shifted
             *  Blobs Inspection : Extra Mark(Check Area, Uncheck Area, Group Area), Missing Mark, Broken Mark)
             *  Subtract Inspection : Extra Mark Char Area and Missing Mark
             * 
             * Note: blnSkipExtraPadAndTextShiftedChecking should set to true if WantGauge is false. 
             * The reason is without Gauge to measure unit edge, vision can't know the exact unit location. Without the unit location information, extra pad and text shifted cannot be detected as well. 
             */

            //objROI.SaveImage("D:\\TS\\objSearchROI.bmp");
            //objROI.SaveImage("D:\\TS\\objMarkROI.bmp");

            try
            {
                m_blnLock = true;
                m_strResultTrack = "";

                WaitEventDone(ref m_blnLockBlobs, false);
                //lock (m_objLockBlobs)
                {
                    m_blnLockBlobs = true;

                    // Init and reset all inspection data
                    int intNoSelectedBlobs = 0;
                    int intNumChars = 0;
                    int j;

                    ResetInspectionData(blnWantCheckNoMark);

                    for (int i = 0; i < m_arrOCV[m_intGroupIndex].Count; i++)
                        m_arrOCV[m_intGroupIndex][i].DeleteSample();

                    // Check valid image
                    if (objMarkROI.ref_ROI.Width == 0)
                    {
                        m_strErrorMessage = "ROI image is empty!";
                        m_blnLock = false;
                        m_blnLockBlobs = false;
                        return false;
                    }

                    int intTemplateCount = 0;

                    if (m_blnWantDontCareArea)
                    {
                        //keep test image in m_objDontCareBackupImage before modify with dont care pattern, so that can be reuse by other template dont care pattern
                        objImage.CopyTo(ref m_objDontCareBackupImage);
                    }

                    // ------------------- checking loop timeout ---------------------------------------------------
                    HiPerfTimer timeout = new HiPerfTimer();
                    timeout.Start();

                    // Loop from first template until last to do OCV inspection
                    while (intTemplateCount < m_arrOCV[m_intGroupIndex].Count)
                    {

                        // ------------------- checking loop timeout ---------------------------------------------------
                        if (timeout.Timing > 10000)
                        {
                            STTrackLog.WriteLine(">>>>>>>>>>>>> time out 802");
                            break;
                        }
                        // ---------------------------------------------------------------------------------------------


                        // Get selected template index
                        int intTemplateIndex;
                        if (m_blnInspectAllTemplate)
                        {
                            intTemplateIndex = (int)((m_intTemplatePriority >> (0x04 * intTemplateCount)) & 0x0F) - 1;

                            if ((m_intTemplateMask & (0x01 << intTemplateIndex)) > 0)
                                m_intTemplateIndex = intTemplateIndex;
                            else
                                goto SkipInspection;
                        }

                        // Reset error message and result mask
                        m_strErrorMessage = "";
                        m_intFailResultMask = 0;

                        // Get fix value threshold
                        int intThresholdValue = GetAutoThreshold(objMarkROI);
                        // Get fail option mask (Each template has own fail option setting)
                        int intFailOptionMask = m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intFailOptionMask;

                        // Subtract dont care area according to template (Each template has own dont care setting)
                        if (m_blnWantDontCareArea)
                        {
                            m_objDontCareBackupImage.CopyTo(ref objImage);
                            objSearchROI.AttachImage(objImage);

                            ROI objDontCareROI = new ROI();
                            objDontCareROI.LoadROISetting(0, 0, objMarkROI.ref_ROIWidth, objMarkROI.ref_ROIHeight);
                            objDontCareROI.AttachImage(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].objDontCareImage);
                            ROI.SubtractROI(objMarkROI, objDontCareROI);
                            objDontCareROI.Dispose();
                        }

                        // Define build blob ROI
                        //ROI m_objBuildObjectROI = DefineBuildBlobROI(objImage, objMarkROI, (intFailOptionMask & 0x04) > 0);
                        if (blnSkipExtraPadAndTextShiftedChecking) // No Gauge
                            DefineBuildBlobROI_SaveTime(objImage, objMarkROI, true);
                        else
                            DefineBuildBlobROI_SaveTime(objImage, objMarkROI, (intFailOptionMask & 0x04) > 0);
                        // Get off set ROI for blob-OCV matching and drawing purpose 
                        m_intROIOffSetX = objMarkROI.ref_ROI.TotalOrgX;
                        m_intROIOffSetY = objMarkROI.ref_ROI.TotalOrgY;
                        m_intBlobOCVOffSetX = m_objBuildObjectROI.ref_ROIPositionX - m_intROIOffSetX;
                        m_intBlobOCVOffSetY = m_objBuildObjectROI.ref_ROIPositionY - m_intROIOffSetY;

                        //if (m_objBlobs[m_intTemplateIndex] != null)
                        //    m_objBlobs[m_intTemplateIndex].Dispose();

                        //// Build blobs 
                        //if (m_objBlobs[m_intTemplateIndex] == null)
                        //    m_objBlobs[m_intTemplateIndex] = new EBlobs();
                        //else
                        //    m_objBlobs[m_intTemplateIndex].CleanAllBlobs();

                        // 2019 08 30 - CCENG: change Connexity 4 to 8. Connexity 8 will link small items into 1 blobs which will make result more stable.
                        if (!BuildObject(m_objBlobs[m_intTemplateIndex], m_objBuildObjectROI, false, false, intThresholdValue, 0, 1000000, 0x1F))
                        //if (!BuildObject(m_objBlobs[m_intTemplateIndex], m_objBuildObjectROI, false, true, intThresholdValue, 0, 1000000, 0x1F))
                        {
                            //m_strErrorMessage = "BuildObjects : No blobs object selected!";
                            //m_blnLock = false;
                            //m_blnLockBlobs = false;
                            //return false;
                        }

                        intNoSelectedBlobs = m_objBlobs[m_intTemplateIndex].ref_intNumSelectedObject;
                        //#region ------------- No Mark Inspection --------------------------------------------------------------------------------
                        if (blnWantCheckNoMark)
                        {
                            m_intTotalBlobArea = 0;

                            for (int i = 0; i < intNoSelectedBlobs; i++)
                            {
                                m_intTotalBlobArea += m_objBlobs[m_intTemplateIndex].ref_arrArea[i];
                            }

                            if (m_intTotalBlobArea < (int)Math.Round(m_fNoMarkMaximumBlobArea))
                            {
                                if ((m_intFailResultMask & 0x1000) == 0)
                                    m_intFailResultMask |= 0x1000;

                                m_strErrorMessage = "*No Mark! Set = " + GetNoMarkMaximumBlobArea().ToString() + " " + GetDisplayUnitName(m_intDisplayUnitMode, true) + ", " +
                                    "Result = " + GetResultTotalBlobArea().ToString() + " " + GetDisplayUnitName(m_intDisplayUnitMode, true) + ".";

                                m_blnLock = false;
                                m_blnLockBlobs = false;
                                return false;
                            }
                        }
                        //#endregion ----------------------------------------------------------------------------------------------------------

                        #region ------------- OCV Inspection --------------------------------------------------------------------------------

                        NOCV objOCV = m_arrOCV[m_intGroupIndex][m_intTemplateIndex];
                        TemplateSetting objTemplateSetting = m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex];

                        //for (int a = 0; a < m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrTemplateCharDilateROI.Count; a++)
                        //{
                        //    m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrTemplateCharDilateROI[a]
                        //}
                        float fMinTextOffsetAllowX = 0;
                        float fMinTextOffsetAllowY = 0;

                        for (int i = 0; i < objTemplateSetting.fCharShiftX.Count; i++)
                        {
                            if (i == 0)
                                fMinTextOffsetAllowX = ((int)Math.Round(objTemplateSetting.fCharShiftX[i] + m_fCharROIOffsetX));
                            else
                            {
                                if (fMinTextOffsetAllowX > ((int)Math.Round(objTemplateSetting.fCharShiftX[i] + m_fCharROIOffsetX)))
                                    fMinTextOffsetAllowX = ((int)Math.Round(objTemplateSetting.fCharShiftX[i] + m_fCharROIOffsetX));
                            }

                            if (i == 0)
                                fMinTextOffsetAllowY = ((int)Math.Round(objTemplateSetting.fCharShiftY[i] + m_fCharROIOffsetY));
                            else
                            {
                                if (fMinTextOffsetAllowY > ((int)Math.Round(objTemplateSetting.fCharShiftY[i] + m_fCharROIOffsetY)))
                                    fMinTextOffsetAllowY = ((int)Math.Round(objTemplateSetting.fCharShiftY[i] + m_fCharROIOffsetY));
                            }
                        }

                        objOCV.Inspect(m_objTL, objSearchROI, intThresholdValue, objMarkROI.ref_ROIPositionX,
                            objMarkROI.ref_ROIPositionY, fMinTextOffsetAllowX, fMinTextOffsetAllowY, m_blnWantSampleAreaScore);

                        // Check Text Score
                        int intSetValue;

                        // 2019 07 16 - CCENG: Not need OCV Text Score Test -----------------------------
                        //int intNumTexts = objOCV.GetNumTexts();
                        //m_blnTextResult[m_intTemplateIndex] = new bool[intNumTexts];
                        //for (int i = 0; i < intNumTexts; i++)
                        //{
                        //    intSetValue = m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intTextMinScore;
                        //    m_arrTestMatchScore[m_intTemplateIndex] = objOCV.GetTextScore(i);

                        //    // Fail if score lower than setting
                        //    if (m_arrTestMatchScore[m_intTemplateIndex] < intSetValue)
                        //    {
                        //        m_blnTextResult[m_intTemplateIndex][i] = false;
                        //        if ((m_intFailResultMask & 0x200) == 0)
                        //            m_intFailResultMask |= 0x200;
                        //    }
                        //    else
                        //        m_blnTextResult[m_intTemplateIndex][i] = true;
                        //}
                        //m_blnTextResult[m_intTemplateIndex][i] = true;

                        // Check Char Score
                        float fSampleScore;
                        intNumChars = objOCV.GetNumChars();
                        m_intHitCharCounter = new int[intNumChars];
                        m_blnCharResult[m_intTemplateIndex] = new bool[intNumChars];
                        for (int i = 0; i < intNumChars; i++)
                        {
                            //// 24-07-2019 ZJYEOH : Skip if the mark is disabled
                            //if (!m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i])
                            //    continue;

                            m_intHitCharCounter[i] = 0;

                            //intSetValue = m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting[i];
                            if (blnByPassUnit)
                            {
                                intSetValue = intMinMarkScore;
                            }
                            else
                            {
                                intSetValue = m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting[i];
                            }

                            fSampleScore = objOCV.GetCharScore(i);
                            m_strResultTrack += ", CharScore=" + fSampleScore.ToString();

                            // Fail if score lower than setting
                            if ((intSetValue > 0 && fSampleScore < intSetValue) && m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i])
                            {
                                m_blnCharResult[m_intTemplateIndex][i] = false;
                                if ((m_intFailResultMask & 0x100) == 0)
                                    m_intFailResultMask |= 0x100;
                            }
                            else
                                m_blnCharResult[m_intTemplateIndex][i] = true;
                        }


                        #endregion ----------------------------------------------------------------------------------------------------------

                        if (blnByPassUnit)
                        {
                            // Stop to test next template if return pass
                            if (m_intFailResultMask == 0)
                                break;

                            // Go to next template
                            intTemplateCount++;

                            continue;
                        }

                        #region ----------------------------- Check Text Shifted ------------------------------------------------------------
                        if (!blnSkipExtraPadAndTextShiftedChecking && ((intFailOptionMask & 0x40) > 0))      // Want Gauge
                        {
                            if (!CheckTextShifted(0, 0, objMarkROI.ref_ROIWidth, objMarkROI.ref_ROIHeight))
                            {
                                m_intFailResultMask |= 0x40;
                            }
                        }
                        #endregion ---------------------------------------------------------------------------------------------------------

                        #region ----------------------------- Blobs Inspection ------------------------------------------------------------
                        bool blnGroupExtraMark = false;
                        float fCenterX, fCenterY, fWidth, fHeight, fAngle, fGravityCenterX, fGravityCenterY, fStartX, fStartY, fEndX, fEndY;
                        int intArea = 0, intContourX = 0, intContourY = 0;
                        List<float> arrExcessStartX = new List<float>();
                        List<float> arrExcessStartY = new List<float>();
                        List<float> arrExcessEndX = new List<float>();
                        List<float> arrExcessEndY = new List<float>();

                        for (int a = 0; a < intNumChars; a++)
                        {
                            arrExcessStartX.Add(-1);
                            arrExcessStartY.Add(-1);
                            arrExcessEndX.Add(-1);
                            arrExcessEndY.Add(-1);
                        }

                        // Init blob data
                        m_intBlobResult[m_intTemplateIndex] = new int[intNoSelectedBlobs];
                        for (j = 0; j < intNoSelectedBlobs; j++)
                        {
                            m_intBlobResult[m_intTemplateIndex][j] = 0;
                        }

                        fCenterX = fCenterY = fWidth = fHeight = fAngle = fGravityCenterX = fGravityCenterY = 0;

                        for (int i = 0; i < intNoSelectedBlobs; i++)
                        {
                            fCenterX = m_objBlobs[m_intTemplateIndex].ref_arrLimitCenterX[i];
                            fCenterY = m_objBlobs[m_intTemplateIndex].ref_arrLimitCenterY[i];
                            fWidth = m_objBlobs[m_intTemplateIndex].ref_arrWidth[i];
                            fHeight = m_objBlobs[m_intTemplateIndex].ref_arrHeight[i];
                            fGravityCenterX = m_objBlobs[m_intTemplateIndex].ref_arrGravityCenterX[i];
                            fGravityCenterY = m_objBlobs[m_intTemplateIndex].ref_arrGravityCenterY[i];
                            intArea = m_objBlobs[m_intTemplateIndex].ref_arrArea[i];
                            intContourX = m_objBlobs[m_intTemplateIndex].ref_arrContourX[i];
                            intContourY = m_objBlobs[m_intTemplateIndex].ref_arrContourY[i];


                            // Use m_intMinArea as min area if m_intMinArea < 5, else use 5 as min area
                            if (m_intMinArea < 5)
                            {
                                // skip checking if blob area lower than setting
                                if (intArea <= m_intMinArea)
                                {
                                    continue;
                                }
                            }
                            else
                            {
                                // skip checking if blob area lower than setting
                                if (intArea <= 5)
                                {
                                    continue;
                                }
                            }

                            // Get blob start point and end point
                            fStartX = fCenterX - fWidth / 2 + m_intBlobOCVOffSetX;
                            fStartY = fCenterY - fHeight / 2 + m_intBlobOCVOffSetY;
                            fEndX = fCenterX + fWidth / 2 + m_intBlobOCVOffSetX;
                            fEndY = fCenterY + fHeight / 2 + m_intBlobOCVOffSetY;

                            //2021-01-19 ZJYEOH : Matching area added shift tolerance ao that extra mark inside char area will not consider as extra mark
                            //bool blnContourCheck = false;
                            List<int> intMatchNumber = objOCV.GetMatchCharIndexes(fStartX, fStartY, fEndX, fEndY,
                                                                                                                    fCenterX + m_intBlobOCVOffSetX, fCenterY + m_intBlobOCVOffSetY,
                                                                                                                    fWidth, fHeight, ref blnContourCheck
                                                                                                                    , m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftX,
                                                                                                                    m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftY,
                                                                                                                    m_fCharROIOffsetX, m_fCharROIOffsetY,
                                                                                                                    m_intExtraExcessMarkInspectionAreaCutMode == 1);

                            // By using contour, double check again the selected OCV Char rectangle box is/are really matched by blobs
                            if (blnContourCheck && intMatchNumber.Count > 0)
                            {
                                for (int e = 0; e < intMatchNumber.Count; e++)
                                {
                                    // Build contour elements for the selected blob
                                    Contour objContour = new Contour();
                                    objContour.ClearContour();
                                    if (objContour.BuildContour(m_objBuildObjectROI, intContourX, intContourY, intThresholdValue, 4))
                                    {
                                        // Check is the blob in OCV Char rectangle box
                                        if (!objOCV.IsInOcvCharArea(objContour, intMatchNumber[e], m_intBlobOCVOffSetX, m_intBlobOCVOffSetY))
                                        {
                                            intMatchNumber.RemoveAt(e);
                                            e--;
                                        }
                                    }
                                }
                            }

                            if (intMatchNumber.Count == 0)
                            {
                                // Check Group Extra Mark
                                if (((intFailOptionMask & 0x08) > 0)) //!blnSkipExtraPadAndTextShiftedChecking &&
                                {
                                    m_intGroupExtraMarkArea[m_intTemplateIndex] += intArea;
                                    m_intBlobResult[m_intTemplateIndex][i] = 1;

                                    if (m_intGroupExtraMarkArea[m_intTemplateIndex] > (int)Math.Round(objTemplateSetting.fGroupExtraMinArea))
                                    {
                                        m_intBlobResult[m_intTemplateIndex][i] = 2;

                                        if (!blnGroupExtraMark)
                                        {
                                            m_intFailResultMask |= 0x08;
                                            blnGroupExtraMark = true;

                                            // Upgrade result from 1 to 2
                                            for (j = 0; j < intNoSelectedBlobs; j++)
                                            {
                                                if (m_intBlobResult[m_intTemplateIndex][j] == 1)
                                                    m_intBlobResult[m_intTemplateIndex][j] = 2;
                                            }
                                        }
                                    }
                                }

                                // Make sure object area is higher than min area and extra min area
                                if ((intArea <= m_intMinArea) || (intArea <= (int)Math.Round(objTemplateSetting.fExtraMinArea)))
                                {
                                    continue;
                                }

                                if (m_intSmallestExtraMarkArea[m_intTemplateIndex] == 0 || intArea < m_intSmallestExtraMarkArea[m_intTemplateIndex])
                                    m_intSmallestExtraMarkArea[m_intTemplateIndex] = intArea;

                                if (m_intBiggestExtraMarkArea[m_intTemplateIndex] == 0 || intArea > m_intBiggestExtraMarkArea[m_intTemplateIndex])
                                    m_intBiggestExtraMarkArea[m_intTemplateIndex] = intArea;

                                // Check Extra Mark 
                                if ((((intFailOptionMask & 0x02) > 0) || (!blnSkipExtraPadAndTextShiftedChecking && ((intFailOptionMask & 0x04) > 0)))) // Want Gauge !blnSkipExtraPadAndTextShiftedChecking &&
                                {
                                    m_intBlobResult[m_intTemplateIndex][i] = 2;

                                    //if (m_intSmallestExtraMarkArea[m_intTemplateIndex] == 0 || intArea < m_intSmallestExtraMarkArea[m_intTemplateIndex])
                                    //    m_intSmallestExtraMarkArea[m_intTemplateIndex] = intArea;

                                    if ((m_intFailResultMask & 0x02) == 0)
                                        m_intFailResultMask |= 0x02;
                                }
                            }
                            else
                            {
                                // Make sure area >= min area
                                if (intArea < m_intMinArea)
                                {
                                    continue;
                                }

                                // Set char hit by blob counter
                                for (j = 0; j < intMatchNumber.Count; j++)
                                {
                                    m_intHitCharCounter[intMatchNumber[j]]++;
                                }

                                for (j = 0; j < intMatchNumber.Count; j++)
                                {
                                    if (arrExcessStartX[intMatchNumber[j]] == -1)
                                    {
                                        arrExcessStartX[intMatchNumber[j]] = fStartX;
                                    }
                                    else
                                    {
                                        if (arrExcessStartX[intMatchNumber[j]] > fStartX)
                                            arrExcessStartX[intMatchNumber[j]] = fStartX;
                                    }

                                    if (arrExcessStartY[intMatchNumber[j]] == -1)
                                    {
                                        arrExcessStartY[intMatchNumber[j]] = fStartY;
                                    }
                                    else
                                    {
                                        if (arrExcessStartY[intMatchNumber[j]] > fStartY)
                                            arrExcessStartY[intMatchNumber[j]] = fStartY;
                                    }

                                    if (arrExcessEndX[intMatchNumber[j]] == -1)
                                    {
                                        arrExcessEndX[intMatchNumber[j]] = fEndX;
                                    }
                                    else
                                    {
                                        if (arrExcessEndX[intMatchNumber[j]] < fEndX)
                                            arrExcessEndX[intMatchNumber[j]] = fEndX;
                                    }

                                    if (arrExcessEndY[intMatchNumber[j]] == -1)
                                    {
                                        arrExcessEndY[intMatchNumber[j]] = fEndY;
                                    }
                                    else
                                    {
                                        if (arrExcessEndY[intMatchNumber[j]] < fEndY)
                                            arrExcessEndY[intMatchNumber[j]] = fEndY;
                                    }
                                }

                                // Check joint mark (1 blob match to more than 1 char)
                                if (intMatchNumber.Count > 1)
                                {
                                    if ((intFailOptionMask & 0x80) > 0)
                                    {
                                        int intDisabledMarkCounter = 0;
                                        int intEnabledMarkCounter = 0;
                                        for (int q = 0; q < intMatchNumber.Count; q++)
                                        {
                                            if (!m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[intMatchNumber[q]])
                                                intDisabledMarkCounter++;
                                            else
                                                intEnabledMarkCounter++;
                                        }

                                        if (intDisabledMarkCounter > 1 && intEnabledMarkCounter < intDisabledMarkCounter || intEnabledMarkCounter <= 1)
                                            goto Skip;

                                        m_intBlobResult[m_intTemplateIndex][i] = 2;

                                        for (int q = 0; q < intMatchNumber.Count; q++)
                                            m_blnCharResult[m_intTemplateIndex][intMatchNumber[q]] = false;

                                        if ((m_intFailResultMask & 0x80) == 0)
                                            m_intFailResultMask |= 0x80;
                                    }
                                    Skip: { }
                                }
                                else if (intMatchNumber.Count == 1)
                                {
                                    // 2018 11 27 - CCENG: Use missing mark to check broken mark will be better.
                                    //// Check Broken Mark (based on size)
                                    //int intWidth = 0, intHeight = 0;
                                    //objOCV.GetCharSize(intMatchNumber[0], ref intWidth, ref intHeight);

                                    //if ((intFailOptionMask & 0x20) > 0)
                                    //{
                                    //    if (fWidth < (intWidth - objTemplateSetting.intBrokenSize))
                                    //    {
                                    //        m_fGroupBrokenMarkLength[m_intTemplateIndex] = intWidth - fWidth;
                                    //        m_intBlobResult[m_intTemplateIndex][i] = 2;

                                    //        m_blnCharResult[m_intTemplateIndex][intMatchNumber[0]] = false;

                                    //        if ((m_intFailResultMask & 0x20) == 0)
                                    //            m_intFailResultMask |= 0x20;
                                    //    }
                                    //    else if (fHeight < (intHeight - objTemplateSetting.intBrokenSize))
                                    //    {
                                    //        m_fGroupBrokenMarkLength[m_intTemplateIndex] = intHeight - fHeight;
                                    //        m_intBlobResult[m_intTemplateIndex][i] = 2;

                                    //        m_blnCharResult[m_intTemplateIndex][intMatchNumber[0]] = false;

                                    //        if ((m_intFailResultMask & 0x20) == 0)
                                    //            m_intFailResultMask |= 0x20;
                                    //    }
                                    //}
                                }
                            }
                        }

                        for (int i = 0; i < intNumChars; i++)
                        {
                            // 2019 06 07 - CCENG: Check missing character using subtraction, but not use the m_intHitCharCounter. 
                            //// Check Missing Mark 
                            //if ((intFailOptionMask & 0x10) > 0)
                            //{
                            //    if (m_intHitCharCounter[i] == 0)
                            //    {
                            //        m_blnCharResult[m_intTemplateIndex][i] = false;

                            //        if ((m_intFailResultMask & 0x10) == 0)
                            //            m_intFailResultMask |= 0x10;
                            //    }
                            //}

                            // 2018 11 19 - CCENG: Use missing mark to check broken mark will be better.
                            // Check Broken Mark (Based on quantity blobs in char area)
                            //if ((intFailOptionMask & 0x20) > 0)
                            //{
                            //    if (m_intHitCharCounter[i] > 1)
                            //    {
                            //        m_blnCharResult[m_intTemplateIndex][i] = false;

                            //        if ((m_intFailResultMask & 0x20) == 0)
                            //            m_intFailResultMask |= 0x20;
                            //    }
                            //}
                        }
                        #endregion ----------------------------------------------------------------------------------------------------------

                        if ((intFailOptionMask & 0x20) > 0 && blnWantCheckBrokenMark)
                        {
                            bool blnWantDebug = false;
                            // Copy rotated image to sample image
                            objImage.CopyTo(ref m_objSampleImage);
                            ImageDrawing objSampleImage_Temp = new ImageDrawing(true, m_objSampleImage.ref_intImageWidth, m_objSampleImage.ref_intImageHeight);
                            objImage.CopyTo(ref objSampleImage_Temp);
                            ImageDrawing objSampleImage_Temp2 = new ImageDrawing(true, m_objSampleImage.ref_intImageWidth, m_objSampleImage.ref_intImageHeight);
                            objImage.CopyTo(ref objSampleImage_Temp2);
                            ROI objSubtractCharROI = new ROI();
                            objSubtractCharROI.AttachImage(m_objSampleImage);

                            if (blnWantDebug)
                            {
                                m_objSampleImage.SaveImage("D:\\TS\\20.m_objSampleImage.bmp");

                            }

                            System.Drawing.Point pStart, pEnd;
                            List<ROI> arrTemplateCharErodeROI = new List<ROI>();

                            int intNumChars2 = objOCV.GetNumChars();

                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 111");

                            //List<float> arrMarkStartX = new List<float>();
                            //List<float> arrMarkStartY = new List<float>();
                            //List<float> arrMarkEndX = new List<float>();
                            //List<float> arrMarkEndY = new List<float>();

                            if (m_arrCharBrokenMarkResult[m_intTemplateIndex] == null)
                                m_arrCharBrokenMarkResult[m_intTemplateIndex] = new bool[intNumChars];

                            if (m_arrCharBrokenMarkResult[m_intTemplateIndex].Length != intNumChars)
                                m_arrCharBrokenMarkResult[m_intTemplateIndex] = new bool[intNumChars];

                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 112");
                            for (int a = 0; a < intNumChars; a++)
                            {
                                m_arrCharBrokenMarkResult[m_intTemplateIndex][a] = true;
                            }

                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 113");

                            for (int i = 0; i < intNumChars2; i++)
                            {
                                if (!m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrWantBrokenMark[i])
                                {
                                    // 2021 01 05 - CCENG: need to add into array also to prevent out of index
                                    arrTemplateCharErodeROI.Add(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrTemplateCharErodeROI[i]);
                                    continue;
                                }

                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 114");

                                arrTemplateCharErodeROI.Add(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrTemplateCharErodeROI[i]);
#if (Debug_2_12 || Release_2_12)
                                EasyImage.Threshold(arrTemplateCharErodeROI[i].ref_ROI, arrTemplateCharErodeROI[i].ref_ROI, (uint)intThresholdValue);
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                                EasyImage.Threshold(arrTemplateCharErodeROI[i].ref_ROI, arrTemplateCharErodeROI[i].ref_ROI, intThresholdValue);
#endif
                                pStart = objOCV.GetCharStartXY(i);
                                pEnd = objOCV.GetCharEndXY(i);

                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 115");

                                float fMinAddSizeX = (float)(arrTemplateCharErodeROI[i].ref_ROIWidth - (pEnd.X - pStart.X)) / 2;
                                float fMinAddSizeY = (float)(arrTemplateCharErodeROI[i].ref_ROIHeight - (pEnd.Y - pStart.Y)) / 2;

                                int intMinAddSizeStartX, intMinAddSizeStartY, intMinAddSizeEndX, intMinAddSizeEndY;
                                if (fMinAddSizeX == (int)fMinAddSizeX)
                                {
                                    intMinAddSizeStartX = (int)fMinAddSizeX;
                                    intMinAddSizeEndX = (int)fMinAddSizeX;
                                }
                                else
                                {
                                    intMinAddSizeStartX = (int)Math.Ceiling(fMinAddSizeX);
                                    intMinAddSizeEndX = (int)Math.Floor(fMinAddSizeX);
                                }

                                if (fMinAddSizeY == (int)fMinAddSizeY)
                                {
                                    intMinAddSizeStartY = (int)fMinAddSizeY;
                                    intMinAddSizeEndY = (int)fMinAddSizeY;
                                }
                                else
                                {
                                    intMinAddSizeStartY = (int)Math.Ceiling(fMinAddSizeY);
                                    intMinAddSizeEndY = (int)Math.Floor(fMinAddSizeY);
                                }

                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 116");

                                ROI objSampleCharROI = new ROI();

                                if ((m_intROIOffSetX + pStart.X - intMinAddSizeStartX) >= 0) //if ((pStart.X - intMinAddSizeStartX) >= 0)   // 2019 10 11 - CCENG: add m_intROIOffSetXY because objSampleCharROI attach to main Image.
                                    objSampleCharROI.ref_ROIPositionX = m_intROIOffSetX + pStart.X - intMinAddSizeStartX;
                                else
                                    objSampleCharROI.ref_ROIPositionX = m_intROIOffSetX;

                                if ((m_intROIOffSetY + pStart.Y - intMinAddSizeStartY) >= 0)  //if ((pStart.Y - intMinAddSizeStartY) >= 0)  // 2019 10 11 - CCENG: add m_intROIOffSetXY because objSampleCharROI attach to main Image.
                                    objSampleCharROI.ref_ROIPositionY = m_intROIOffSetY + pStart.Y - intMinAddSizeStartY;
                                else
                                    objSampleCharROI.ref_ROIPositionY = m_intROIOffSetY;

                                if ((pEnd.X + intMinAddSizeEndX * 2) < m_intImageWidth)
                                    objSampleCharROI.ref_ROIWidth = pEnd.X - pStart.X + intMinAddSizeStartX + intMinAddSizeEndX;
                                else
                                    continue;
                                if ((pEnd.Y + intMinAddSizeEndY * 2) < m_intImageHeight)
                                    objSampleCharROI.ref_ROIHeight = pEnd.Y - pStart.Y + intMinAddSizeStartY + intMinAddSizeEndY;
                                else
                                    continue;

                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 117");

                                // 2020 03 01 - CCENG: Attached to m_objSampleImage because objSampleCharROI will be Dilated when m_intMissingMarkInspectionMethod is 1. 
                                //                   : Also Dilate and subtract's image source and destination can be same.          
                                //objSampleCharROI.AttachImage(objImage);

                                //2020-06-17 ZJYEOH : objSampleCharROI should attach another image as m_objSampleImage will be image processsed
                                objSampleCharROI.AttachImage(objSampleImage_Temp);//m_objSampleImage

                                objSubtractCharROI.LoadROISetting(objSampleCharROI.ref_ROIPositionX, objSampleCharROI.ref_ROIPositionY,
                                                                    objSampleCharROI.ref_ROIWidth, objSampleCharROI.ref_ROIHeight);

                                if ((objSampleCharROI.ref_ROIWidth != arrTemplateCharErodeROI[i].ref_ROIWidth) ||
                                    (arrTemplateCharErodeROI[i].ref_ROIWidth != objSubtractCharROI.ref_ROIWidth))
                                    continue;

                                if ((objSampleCharROI.ref_ROIHeight != arrTemplateCharErodeROI[i].ref_ROIHeight) ||
                                    (arrTemplateCharErodeROI[i].ref_ROIHeight != objSubtractCharROI.ref_ROIHeight))
                                    continue;

                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 118");

                                //arrMarkStartX.Add(objSubtractCharROI.ref_ROIPositionX - m_intROIOffSetX);
                                //arrMarkStartY.Add(objSubtractCharROI.ref_ROIPositionY - m_intROIOffSetY);
                                //arrMarkEndX.Add(objSubtractCharROI.ref_ROIPositionX + objSubtractCharROI.ref_ROIWidth - m_intROIOffSetX);
                                //arrMarkEndY.Add(objSubtractCharROI.ref_ROIPositionY + objSubtractCharROI.ref_ROIHeight - m_intROIOffSetY);

                                if (!m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i] || !CheckWantInspectBrokenMark(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMarkType[i]))
                                {
                                    EasyImage.Oper(EArithmeticLogicOperation.Subtract, arrTemplateCharErodeROI[i].ref_ROI, arrTemplateCharErodeROI[i].ref_ROI, objSubtractCharROI.ref_ROI);
                                }
                                else
                                {
#if (Debug_2_12 || Release_2_12)
                                    EasyImage.Threshold(objSampleCharROI.ref_ROI, objSampleCharROI.ref_ROI, (uint)intThresholdValue);
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                                    EasyImage.Threshold(objSampleCharROI.ref_ROI, objSampleCharROI.ref_ROI, intThresholdValue);
#endif
                                    //2020-06-17 ZJYEOH : Image processing will be different for white on black and black one white

                                    if (m_blnWhiteOnBlack)
                                    {
                                        ROI.InvertOperationROI(arrTemplateCharErodeROI[i]);
                                        EasyImage.Oper(EArithmeticLogicOperation.Subtract, objSampleCharROI.ref_ROI, arrTemplateCharErodeROI[i].ref_ROI, objSubtractCharROI.ref_ROI);
                                        //2020-06-17 ZJYEOH : Invert back so that arrTemplateCharErodeROI[i] will not inverted if it is used again because inverted area may overlap another mark
                                        ROI.InvertOperationROI(arrTemplateCharErodeROI[i]);
                                    }
                                    else
                                    {
                                        //ROI.InvertOperationROI(objSampleCharROI);
                                        EasyImage.Oper(EArithmeticLogicOperation.Add, arrTemplateCharErodeROI[i].ref_ROI, objSampleCharROI.ref_ROI, objSubtractCharROI.ref_ROI);
                                        ////2020-06-17 ZJYEOH : Invert back so that objSampleCharROI will not inverted if it is used again because inverted area may overlap another mark
                                        //ROI.InvertOperationROI(objSampleCharROI);
                                    }

                                }

                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 119");

                                if (blnWantDebug)
                                {
                                    arrTemplateCharErodeROI[i].SaveImage("D:\\TS\\34.arrTemplateCharErodeROI[i]" + i.ToString() + ".bmp");
                                    objSampleCharROI.SaveImage("D:\\TS\\35.objSampleCharROI" + i.ToString() + ".bmp");
                                    objSubtractCharROI.SaveImage("D:\\TS\\36.objSubtractCharROI" + i.ToString() + ".bmp");
                                    m_objSampleImage.SaveImage("D:\\TS\\37.m_objSampleImage" + i.ToString() + ".bmp");
                                }

                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 120");
#if (Debug_2_12 || Release_2_12)
                                if (m_intEnhanceMark_LinkMark_HalfWidth > 0)
                                {
                                    if (m_blnWhiteOnBlack)
                                        EasyImage.CloseBox(objSubtractCharROI.ref_ROI, objSubtractCharROI.ref_ROI, (uint)m_intEnhanceMark_LinkMark_HalfWidth);
                                    else
                                        EasyImage.OpenBox(objSubtractCharROI.ref_ROI, objSubtractCharROI.ref_ROI, (uint)m_intEnhanceMark_LinkMark_HalfWidth);
                                }

                                if (m_intEnhanceMark_ReduceNoise_HalfWidth > 0)
                                {
                                    if (m_blnWhiteOnBlack)
                                        EasyImage.OpenBox(objSubtractCharROI.ref_ROI, objSubtractCharROI.ref_ROI, (uint)m_intEnhanceMark_ReduceNoise_HalfWidth);
                                    else
                                        EasyImage.CloseBox(objSubtractCharROI.ref_ROI, objSubtractCharROI.ref_ROI, (uint)m_intEnhanceMark_ReduceNoise_HalfWidth);
                                }
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                                if (m_intEnhanceMark_LinkMark_HalfWidth > 0)
                                {
                                    if (m_blnWhiteOnBlack)
                                        EasyImage.CloseBox(objSubtractCharROI.ref_ROI, objSubtractCharROI.ref_ROI, m_intEnhanceMark_LinkMark_HalfWidth);
                                    else
                                        EasyImage.OpenBox(objSubtractCharROI.ref_ROI, objSubtractCharROI.ref_ROI, m_intEnhanceMark_LinkMark_HalfWidth);
                                }

                                if (m_intEnhanceMark_ReduceNoise_HalfWidth > 0)
                                {
                                    if (m_blnWhiteOnBlack)
                                        EasyImage.OpenBox(objSubtractCharROI.ref_ROI, objSubtractCharROI.ref_ROI, m_intEnhanceMark_ReduceNoise_HalfWidth);
                                    else
                                        EasyImage.CloseBox(objSubtractCharROI.ref_ROI, objSubtractCharROI.ref_ROI, m_intEnhanceMark_ReduceNoise_HalfWidth);
                                }
#endif
                                if (m_objBrokenBlobs[m_intTemplateIndex] == null)
                                    m_objBrokenBlobs[m_intTemplateIndex] = new EBlobs();
                                else
                                    m_objBrokenBlobs[m_intTemplateIndex].CleanAllBlobs();

                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 123");
                                if (blnWantDebug)
                                {
                                    objSubtractCharROI.SaveImage("D:\\TS\\42.objSubtractCharROI.bmp");
                                }

                                //2020-06-17 ZJYEOH : Threshold will invert for white on black
                                int intMissingThreshold = intThresholdValue;
                                if (m_blnWhiteOnBlack)
                                {
                                    intMissingThreshold = intThresholdValue;
                                }


                                if (BuildObject(m_objBrokenBlobs[m_intTemplateIndex], objSubtractCharROI, false, true, intMissingThreshold, m_intMinArea, 1000000, 0x1F)) //255 - intThresholdValue
                                {
                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 124");
                                    int intNoBlobs = m_objBrokenBlobs[m_intTemplateIndex].ref_intNumSelectedObject;

                                    if (intNoBlobs > 1)
                                    {
                                        // 2021 01 05 - m_blnCharResult is for score result, not for broken mark
                                        //if (m_blnCharResult[m_intTemplateIndex][i])
                                        //    m_blnCharResult[m_intTemplateIndex][i] = false;

                                        if (m_arrCharBrokenMarkResult[m_intTemplateIndex][i])
                                            m_arrCharBrokenMarkResult[m_intTemplateIndex][i] = false;

                                        if ((m_intFailResultMask & 0x20) == 0)
                                            m_intFailResultMask |= 0x20;
                                    }
                                }

                                objSampleCharROI.Dispose();
                            }

                            objSampleImage_Temp.Dispose();
                            objSampleImage_Temp2.Dispose();
                            objSubtractCharROI.Dispose();
                        }

                        #region ----------- Check Excess mark and Missing Mark in characters area using substract function and grey value ---------------------
                        // If text score does not fail
                        if ((m_intFailResultMask & 0x200) == 0)
                        {
                            //-------------------------------------- Check Excess mark in characters area ---------------------------------------//
                            if ((intFailOptionMask & 0x01) > 0) // Excess Mark Char Area is ON
                            {
                                //if ((m_intFailResultMask & 0x08) == 0)      // 2019 06 28 - Check Excess Mark only if no Group extra mark failure. Because excess inpsection take quite long time and if too many extra makr, it will take too long time for isnpection.
                                {

                                    // Copy rotated image to sample image
                                    //ImageDrawing objSampleImage = new ImageDrawing();
                                    objImage.CopyTo(ref m_objSampleImage);

                                    ROI objSubtractCharROI = new ROI();
                                    objSubtractCharROI.AttachImage(m_objSampleImage);

                                    System.Drawing.Point pStart, pEnd;
                                    List<ROI> arrTemplateCharDilateROI = new List<ROI>();
                                    List<float> arrTemplateStartX = new List<float>();
                                    List<float> arrTemplateStartY = new List<float>();
                                    List<float> arrTemplateEndX = new List<float>();
                                    List<float> arrTemplateEndY = new List<float>();
                                    for (int i = 0; i < intNumChars; i++)
                                    {

                                        //// 24-07-2019 ZJYEOH : Skip if the mark is disabled
                                        //if (!m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i])
                                        //    continue;


                                        arrTemplateCharDilateROI.Add(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrTemplateCharDilateROI[i]);
#if (Debug_2_12 || Release_2_12)
                                        EasyImage.Threshold(arrTemplateCharDilateROI[i].ref_ROI, arrTemplateCharDilateROI[i].ref_ROI, (uint)intThresholdValue);
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                                        EasyImage.Threshold(arrTemplateCharDilateROI[i].ref_ROI, arrTemplateCharDilateROI[i].ref_ROI, intThresholdValue);
#endif

                                        pStart = objOCV.GetCharStartXY(i);
                                        pEnd = objOCV.GetCharEndXY(i);

                                        float fMinAddSizeX = (float)(arrTemplateCharDilateROI[i].ref_ROIWidth - (pEnd.X - pStart.X)) / 2;
                                        float fMinAddSizeY = (float)(arrTemplateCharDilateROI[i].ref_ROIHeight - (pEnd.Y - pStart.Y)) / 2;

                                        int intMinAddSizeStartX, intMinAddSizeStartY, intMinAddSizeEndX, intMinAddSizeEndY;
                                        if (fMinAddSizeX == (int)fMinAddSizeX)
                                        {
                                            intMinAddSizeStartX = (int)fMinAddSizeX;
                                            intMinAddSizeEndX = (int)fMinAddSizeX;
                                        }
                                        else
                                        {
                                            intMinAddSizeStartX = (int)Math.Ceiling(fMinAddSizeX);
                                            intMinAddSizeEndX = (int)Math.Floor(fMinAddSizeX);
                                        }

                                        if (fMinAddSizeY == (int)fMinAddSizeY)
                                        {
                                            intMinAddSizeStartY = (int)fMinAddSizeY;
                                            intMinAddSizeEndY = (int)fMinAddSizeY;
                                        }
                                        else
                                        {
                                            intMinAddSizeStartY = (int)Math.Ceiling(fMinAddSizeY);
                                            intMinAddSizeEndY = (int)Math.Floor(fMinAddSizeY);
                                        }

                                        ROI objSampleCharROI = new ROI();
                                        if (m_blnWantDontCareIgnoredMarkWholeArea && !m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i] || !CheckWantInspectExcessMark(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMarkType[i]))
                                        {
                                            //2021-01-18 ZJYEOH : Should use sample position
                                            Point pStartTemplate = pStart;//new Point(arrTemplateCharDilateROI[i].ref_ROIPositionX, arrTemplateCharDilateROI[i].ref_ROIPositionY);
                                            Point pEndTemplate = pEnd;//new Point(arrTemplateCharDilateROI[i].ref_ROIPositionX + arrTemplateCharDilateROI[i].ref_ROIWidth, arrTemplateCharDilateROI[i].ref_ROIPositionY + arrTemplateCharDilateROI[i].ref_ROIHeight);

                                            if ((m_intROIOffSetX + pStartTemplate.X - ((int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftX[i] + m_fCharROIOffsetX))) >= 0)
                                                objSampleCharROI.ref_ROIPositionX = m_intROIOffSetX + pStartTemplate.X - ((int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftX[i] + m_fCharROIOffsetX));
                                            else
                                                objSampleCharROI.ref_ROIPositionX = m_intROIOffSetX;

                                            if ((m_intROIOffSetY + pStartTemplate.Y - ((int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftY[i] + m_fCharROIOffsetY))) >= 0)
                                                objSampleCharROI.ref_ROIPositionY = m_intROIOffSetY + pStartTemplate.Y - ((int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftY[i] + m_fCharROIOffsetY));
                                            else
                                                objSampleCharROI.ref_ROIPositionY = m_intROIOffSetY;

                                            if ((m_intROIOffSetX + pEndTemplate.X + ((int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftX[i] + m_fCharROIOffsetX))) < m_intImageWidth)
                                                objSampleCharROI.ref_ROIWidth = pEndTemplate.X - pStartTemplate.X + ((int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftX[i] + m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftX[i] + m_fCharROIOffsetX + m_fCharROIOffsetX));
                                            else
                                                continue;
                                            if ((m_intROIOffSetY + pEndTemplate.Y + ((int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftY[i] + m_fCharROIOffsetY))) < m_intImageHeight)
                                                objSampleCharROI.ref_ROIHeight = pEndTemplate.Y - pStartTemplate.Y + ((int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftY[i] + m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftY[i] + m_fCharROIOffsetY + m_fCharROIOffsetY));
                                            else
                                                continue;
                                        }
                                        else
                                        {
                                            if ((m_intROIOffSetX + pStart.X - intMinAddSizeStartX) >= 0) //if ((pStart.X - intMinAddSizeStartX) >= 0)   // 2019 10 11 - CCENG: add m_intROIOffSetXY because objSampleCharROI attach to main Image.
                                                objSampleCharROI.ref_ROIPositionX = m_intROIOffSetX + pStart.X - intMinAddSizeStartX;
                                            else
                                                objSampleCharROI.ref_ROIPositionX = m_intROIOffSetX;

                                            if ((m_intROIOffSetY + pStart.Y - intMinAddSizeStartY) >= 0)  //if ((pStart.Y - intMinAddSizeStartY) >= 0)  // 2019 10 11 - CCENG: add m_intROIOffSetXY because objSampleCharROI attach to main Image.
                                                objSampleCharROI.ref_ROIPositionY = m_intROIOffSetY + pStart.Y - intMinAddSizeStartY;
                                            else
                                                objSampleCharROI.ref_ROIPositionY = m_intROIOffSetY;

                                            if ((pEnd.X + intMinAddSizeEndX * 2) < m_intImageWidth)
                                                objSampleCharROI.ref_ROIWidth = pEnd.X - pStart.X + intMinAddSizeStartX + intMinAddSizeEndX;
                                            else
                                                continue;
                                            if ((pEnd.Y + intMinAddSizeEndY * 2) < m_intImageHeight)
                                                objSampleCharROI.ref_ROIHeight = pEnd.Y - pStart.Y + intMinAddSizeStartY + intMinAddSizeEndY;
                                            else
                                                continue;
                                        }

                                        objSampleCharROI.AttachImage(objImage);

                                        objSubtractCharROI.LoadROISetting(objSampleCharROI.ref_ROIPositionX, objSampleCharROI.ref_ROIPositionY,
                                                                            objSampleCharROI.ref_ROIWidth, objSampleCharROI.ref_ROIHeight);

                                        arrTemplateStartX.Add(objSampleCharROI.ref_ROIPositionX - m_intROIOffSetX);
                                        arrTemplateStartY.Add(objSampleCharROI.ref_ROIPositionY - m_intROIOffSetY);
                                        arrTemplateEndX.Add(objSampleCharROI.ref_ROIPositionX + objSampleCharROI.ref_ROIWidth - m_intROIOffSetX);
                                        arrTemplateEndY.Add(objSampleCharROI.ref_ROIPositionY + objSampleCharROI.ref_ROIHeight - m_intROIOffSetY);

                                        if (!m_blnWantDontCareIgnoredMarkWholeArea)
                                        {
                                            if ((objSampleCharROI.ref_ROIWidth != arrTemplateCharDilateROI[i].ref_ROIWidth) ||
                                            (arrTemplateCharDilateROI[i].ref_ROIWidth != objSubtractCharROI.ref_ROIWidth))
                                                continue;

                                            if ((objSampleCharROI.ref_ROIHeight != arrTemplateCharDilateROI[i].ref_ROIHeight) ||
                                                (arrTemplateCharDilateROI[i].ref_ROIHeight != objSubtractCharROI.ref_ROIHeight))
                                                continue;
                                        }

                                        if (!m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i])
                                        {
                                            EasyImage.Oper(EArithmeticLogicOperation.Subtract, objSampleCharROI.ref_ROI, objSampleCharROI.ref_ROI, objSubtractCharROI.ref_ROI);
                                        }
                                        else
                                        {
                                            EasyImage.Oper(EArithmeticLogicOperation.Subtract, objSampleCharROI.ref_ROI, arrTemplateCharDilateROI[i].ref_ROI, objSubtractCharROI.ref_ROI);
                                        }

                                        //objSampleCharROI.SaveImage("D:\\TS\\objSampleCharROI.bmp");
                                        //arrTemplateCharDilateROI[i].SaveImage("D:\\TS\\arrTemplateCharDilateROI[i].bmp");
                                        //objSubtractCharROI.SaveImage("D:\\TS\\objSubtractCharROI.bmp");
                                    }

                                    // Reload ROI size and placement to same location and same size as Mark ROI
                                    objSubtractCharROI.LoadROISetting(m_intROIOffSetX, m_intROIOffSetY, objMarkROI.ref_ROIWidth, objMarkROI.ref_ROIHeight);
                                    if (m_objExcessBlobs[m_intTemplateIndex] == null)
                                        m_objExcessBlobs[m_intTemplateIndex] = new EBlobs();
                                    else
                                        m_objExcessBlobs[m_intTemplateIndex].CleanAllBlobs();

                                    if (m_arrCharExcessAreaResult[m_intTemplateIndex] == null)
                                        m_arrCharExcessAreaResult[m_intTemplateIndex] = new int[intNumChars];

                                    if (m_arrCharExcessAreaResult[m_intTemplateIndex].Length != intNumChars)
                                        m_arrCharExcessAreaResult[m_intTemplateIndex] = new int[intNumChars];

                                    for (int a = 0; a < intNumChars; a++)
                                    {
                                        m_arrCharExcessAreaResult[m_intTemplateIndex][a] = 0;
                                    }

                                    if (BuildObject(m_objExcessBlobs[m_intTemplateIndex], objSubtractCharROI, false, true, intThresholdValue, m_intMinArea, 1000000, 0x1F))
                                    {
                                        int intNoExcessBlobs = m_objExcessBlobs[m_intTemplateIndex].ref_intNumSelectedObject;

                                        // Init blob data
                                        m_intExcessBlobResult[m_intTemplateIndex] = new int[intNoExcessBlobs];
                                        List<int> arrintMatchNo = new List<int>(intNoExcessBlobs);
                                        for (j = 0; j < intNoExcessBlobs; j++)
                                        {
                                            m_intExcessBlobResult[m_intTemplateIndex][j] = 0;
                                            arrintMatchNo.Add(-1);
                                        }
                                        float fExcessCenterX = 0.0f, fExcessCenterY = 0.0f;

                                        // Scan all subtracted blobs to check whether the blob has been fail in Extra Mark/Group Extra Mark checking above.(For extra mark in check area)
                                        for (int i = 0; i < intNoExcessBlobs; i++)
                                        {
                                            fExcessCenterX = m_objExcessBlobs[m_intTemplateIndex].ref_arrLimitCenterX[i];
                                            fExcessCenterY = m_objExcessBlobs[m_intTemplateIndex].ref_arrLimitCenterY[i];
                                            intArea = m_objExcessBlobs[m_intTemplateIndex].ref_arrArea[i];     // Get subtracted blob area                                                                                                                      // Get subtracted blob contour xy first point
                                            intContourX = m_objExcessBlobs[m_intTemplateIndex].ref_arrContourX[i];
                                            intContourY = m_objExcessBlobs[m_intTemplateIndex].ref_arrContourY[i];
                                            m_objExcessBlobs[m_intTemplateIndex].DisposeElement(i);

                                            // Make sure the subtracted blob pass min area requirement before consider it as excess mark
                                            // Use m_intMinArea as min area if m_intMinArea < 5, else use 5 as min area
                                            if (m_intMinArea < 5)
                                            {
                                                // skip checking if blob area lower than setting
                                                if (intArea <= m_intMinArea)
                                                {
                                                    continue;
                                                }
                                            }
                                            else
                                            {
                                                // skip checking if blob area lower than setting
                                                if (intArea <= 5)
                                                {
                                                    continue;
                                                }
                                            }

                                            // Make sure subtracted blob is in Char area before consider it as excess mark
                                            int intMatchNo = -1;
                                            List<int> arrSingleMatchNo = new List<int>();
                                            bool IsInExcessROIArea = false;
                                            for (j = 0; j < arrExcessStartX.Count; j++)
                                            {
                                                // 06-02-2020 JBTAN : for Bar Pin 1 Mark, skip if the extra/broken mark is at the end of both tip
                                                if (m_blnWantCheckBarPin1)
                                                {
                                                    if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnIsBarPin1[j])
                                                    {
                                                        if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrBarPin1Type[j] == 0)
                                                        {
                                                            if ((fExcessCenterX > arrTemplateStartX[j] && fExcessCenterX < arrTemplateEndX[j]))
                                                                continue;
                                                        }
                                                        else
                                                        {
                                                            if ((fExcessCenterY > arrTemplateStartY[j] && fExcessCenterY < arrTemplateEndY[j]))
                                                                continue;
                                                        }
                                                    }
                                                }

                                                if (fExcessCenterX > arrExcessStartX[j] && fExcessCenterX < arrExcessEndX[j] &&
                                                    fExcessCenterY > arrExcessStartY[j] && fExcessCenterY < arrExcessEndY[j])
                                                {
                                                    arrSingleMatchNo.Add(j);
                                                    intMatchNo = j;
                                                    IsInExcessROIArea = true;
                                                }
                                            }

                                            //If is bar pin 1, dont add to excess area
                                            if (!IsInExcessROIArea)
                                            //if (!objOCV.IsInOcvCharArea(objContour, ref intMatchNo))
                                            {
                                                // 2019 08 01 - CCENG: If no group extra makr or single extra mark fail, mean this object is attached to mark.
                                                if (((intFailOptionMask & 0x0A) == 0) || ((m_intFailResultMask & 0x0A) > 0))
                                                {
                                                    continue;
                                                }

                                                // 31-07-3019 ZJYEOH : Consider as group extra mark if contours cannot hit within the character's area, because if straight skip the inspection and continue next blob, there will be some extra/excess mark undetected
                                                if ((intFailOptionMask & 0x08) > 0) // Check Group Extra Mark 
                                                {
                                                    bool blnAdd = true;

                                                    //if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting[intMatchNo] == 0)
                                                    //{
                                                    //    blnAdd = false;
                                                    //}


                                                    if (blnAdd)
                                                    {


                                                        m_intGroupExtraMarkArea[m_intTemplateIndex] += intArea;
                                                        m_intExcessBlobResult[m_intTemplateIndex][i] = 1;

                                                        if (m_intGroupExtraMarkArea[m_intTemplateIndex] > (int)Math.Round(objTemplateSetting.fGroupExtraMinArea))
                                                        {
                                                            m_intExcessBlobResult[m_intTemplateIndex][i] = 2;

                                                            if (!blnGroupExtraMark)
                                                            {
                                                                m_intFailResultMask |= 0x08;
                                                                blnGroupExtraMark = true;

                                                                // Upgrade result from 1 to 2
                                                                for (j = 0; j < intNoExcessBlobs; j++)
                                                                {
                                                                    if (m_intExcessBlobResult[m_intTemplateIndex][j] == 1)
                                                                        m_intExcessBlobResult[m_intTemplateIndex][j] = 2;
                                                                }

                                                                for (j = 0; j < intNoSelectedBlobs; j++)
                                                                {
                                                                    if (m_intBlobResult[m_intTemplateIndex][j] == 1)
                                                                        m_intBlobResult[m_intTemplateIndex][j] = 2;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                continue;
                                            }

                                            arrintMatchNo[i] = intMatchNo;
                                            // Check Group Extra Mark
                                            if ((intFailOptionMask & 0x08) > 0)
                                            {
                                                bool blnAdd = true;
                                                if (intMatchNo >= 0 && intMatchNo < m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting.Count)
                                                {
                                                    if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting[intMatchNo] == 0)
                                                    {
                                                        blnAdd = false;
                                                    }
                                                }

                                                if (blnAdd)
                                                {


                                                    m_intGroupExtraMarkArea[m_intTemplateIndex] += intArea;
                                                    m_intExcessBlobResult[m_intTemplateIndex][i] = 1;

                                                    if (m_intGroupExtraMarkArea[m_intTemplateIndex] > (int)Math.Round(objTemplateSetting.fGroupExtraMinArea))
                                                    {
                                                        m_intExcessBlobResult[m_intTemplateIndex][i] = 2;

                                                        if (!blnGroupExtraMark)
                                                        {
                                                            m_intFailResultMask |= 0x08;
                                                            blnGroupExtraMark = true;

                                                            // Upgrade result from 1 to 2
                                                            for (j = 0; j < intNoExcessBlobs; j++)
                                                            {
                                                                if (m_intExcessBlobResult[m_intTemplateIndex][j] == 1)
                                                                    m_intExcessBlobResult[m_intTemplateIndex][j] = 2;
                                                            }

                                                            for (j = 0; j < intNoSelectedBlobs; j++)
                                                            {
                                                                if (m_intBlobResult[m_intTemplateIndex][j] == 1)
                                                                    m_intBlobResult[m_intTemplateIndex][j] = 2;
                                                            }
                                                        }
                                                    }
                                                }
                                            }

                                            for (j = 0; j < arrSingleMatchNo.Count; j++)
                                            {
                                                m_arrCharExcessAreaResult[m_intTemplateIndex][arrSingleMatchNo[j]] += intArea;
                                            }
                                        }

                                        // 31-07-2019 ZJYEOH : Check Excess here so that the total excess area is correct for each mark
                                        for (int b = 0; b < m_arrCharExcessAreaResult[m_intTemplateIndex].Length; b++)
                                        {
                                            if (m_arrCharExcessAreaResult[m_intTemplateIndex][b] == 0)
                                                continue;
                                            // Make sure object area is higher than min area and extra min area
                                            if ((m_arrCharExcessAreaResult[m_intTemplateIndex][b] < m_intMinArea) ||
                                                (m_arrCharExcessAreaResult[m_intTemplateIndex][b] <= (int)Math.Round(objTemplateSetting.arrMaxExcessArea[b])))
                                            {
                                                continue;
                                            }
                                            else
                                            {

                                                if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting[b] == 0)
                                                {
                                                    continue;
                                                }

                                                for (int c = 0; c < arrintMatchNo.Count; c++)
                                                {
                                                    if (arrintMatchNo[c] == b)
                                                        m_intExcessBlobResult[m_intTemplateIndex][c] = 2;
                                                }

                                                if ((m_intFailResultMask & 0x01) == 0)
                                                    m_intFailResultMask |= 0x01;
                                            }
                                        }
                                    }
                                }
                            }

                            //-------------------------------------- Check miss mark area ---------------------------------------
                            if ((intFailOptionMask & 0x10) > 0 && (m_intFailResultMask & 0x01) == 0)
                            {
                                // Copy rotated image to sample image
                                objBlackImage.CopyTo(ref m_objSampleImage);//objImage //2021-07-06 ZJYEOH : Use Black Image so that background is not included

                                ROI objSubtractCharROI = new ROI();
                                objSubtractCharROI.AttachImage(m_objSampleImage);

                                System.Drawing.Point pStart, pEnd;
                                List<ROI> arrTemplateCharErodeROI = new List<ROI>();

                                int intNumChars2 = objOCV.GetNumChars();
                                //for (int i = 0; i < intNumChars2; i++)
                                //{
                                //    arrTemplateCharErodeROI.Add(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrTemplateCharErodeROI[i]);

                                //    ROI objSampleCharROI = new ROI();

                                //    pStart = objOCV.GetCharStartXY(i);
                                //    pEnd = objOCV.GetCharEndXY(i);

                                //    int intMinAddSizeX = (arrTemplateCharErodeROI[i].ref_ROIWidth - (pEnd.X - pStart.X)) / 2;
                                //    int intMinAddSizeY = (arrTemplateCharErodeROI[i].ref_ROIHeight - (pEnd.Y - pStart.Y)) / 2;

                                //    if ((pStart.X - intMinAddSizeX) >= 0)
                                //        objSampleCharROI.ref_ROIPositionX = m_intROIOffSetX + pStart.X - intMinAddSizeX;
                                //    else
                                //        objSampleCharROI.ref_ROIPositionX = m_intROIOffSetX;

                                //    if ((pStart.Y - intMinAddSizeY) >= 0)
                                //        objSampleCharROI.ref_ROIPositionY = m_intROIOffSetY + pStart.Y - intMinAddSizeY;
                                //    else
                                //        objSampleCharROI.ref_ROIPositionY = m_intROIOffSetY;

                                //    if ((pEnd.X + intMinAddSizeX * 2) < m_intImageWidth)
                                //        objSampleCharROI.ref_ROIWidth = pEnd.X - pStart.X + intMinAddSizeX * 2;
                                //    else
                                //        continue;
                                //    if ((pEnd.Y + intMinAddSizeY * 2) < m_intImageHeight)
                                //        objSampleCharROI.ref_ROIHeight = pEnd.Y - pStart.Y + intMinAddSizeY * 2;
                                //    else
                                //        continue;


                                //    objSampleCharROI.AttachImage(m_objSampleImage);
                                //    EasyImage.Threshold(objSampleCharROI.ref_ROI, objSampleCharROI.ref_ROI, intThresholdValue);

                                //    objSubtractCharROI.LoadROISetting(objSampleCharROI.ref_ROIPositionX, objSampleCharROI.ref_ROIPositionY,
                                //                                        objSampleCharROI.ref_ROIWidth, objSampleCharROI.ref_ROIHeight);


                                //    if ((objSampleCharROI.ref_ROIWidth != arrTemplateCharErodeROI[i].ref_ROIWidth) ||
                                //        (arrTemplateCharErodeROI[i].ref_ROIWidth != objSubtractCharROI.ref_ROIWidth))
                                //        continue;

                                //    if ((objSampleCharROI.ref_ROIHeight != arrTemplateCharErodeROI[i].ref_ROIHeight) ||
                                //        (arrTemplateCharErodeROI[i].ref_ROIHeight != objSubtractCharROI.ref_ROIHeight))
                                //        continue;

                                //    EasyImage.Oper(EArithmeticLogicOperation.Subtract, arrTemplateCharErodeROI[i].ref_ROI, objSampleCharROI.ref_ROI, objSubtractCharROI.ref_ROI);
                                //}

                                if (m_arrCharBrokenAreaResult[m_intTemplateIndex] == null)
                                    m_arrCharBrokenAreaResult[m_intTemplateIndex] = new int[intNumChars];

                                if (m_arrCharBrokenAreaResult[m_intTemplateIndex].Length != intNumChars)
                                    m_arrCharBrokenAreaResult[m_intTemplateIndex] = new int[intNumChars];

                                for (int a = 0; a < intNumChars; a++)
                                {
                                    m_arrCharBrokenAreaResult[m_intTemplateIndex][a] = 0;
                                }

                                List<float> arrMarkStartX = new List<float>();
                                List<float> arrMarkStartY = new List<float>();
                                List<float> arrMarkEndX = new List<float>();
                                List<float> arrMarkEndY = new List<float>();

                                for (int i = 0; i < intNumChars2; i++)
                                {
                                    //// 24-07-2019 ZJYEOH : Skip if the mark is disabled
                                    //if (!m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i])
                                    //    continue;

                                    arrTemplateCharErodeROI.Add(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrTemplateCharErodeROI[i]);
#if (Debug_2_12 || Release_2_12)
                                    EasyImage.Threshold(arrTemplateCharErodeROI[i].ref_ROI, arrTemplateCharErodeROI[i].ref_ROI, (uint)intThresholdValue);
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                                    EasyImage.Threshold(arrTemplateCharErodeROI[i].ref_ROI, arrTemplateCharErodeROI[i].ref_ROI, intThresholdValue);
#endif

                                    pStart = objOCV.GetCharStartXY(i);
                                    pEnd = objOCV.GetCharEndXY(i);

                                    float fMinAddSizeX = (float)(arrTemplateCharErodeROI[i].ref_ROIWidth - (pEnd.X - pStart.X)) / 2;
                                    float fMinAddSizeY = (float)(arrTemplateCharErodeROI[i].ref_ROIHeight - (pEnd.Y - pStart.Y)) / 2;

                                    int intMinAddSizeStartX, intMinAddSizeStartY, intMinAddSizeEndX, intMinAddSizeEndY;
                                    if (fMinAddSizeX == (int)fMinAddSizeX)
                                    {
                                        intMinAddSizeStartX = (int)fMinAddSizeX;
                                        intMinAddSizeEndX = (int)fMinAddSizeX;
                                    }
                                    else
                                    {
                                        intMinAddSizeStartX = (int)Math.Ceiling(fMinAddSizeX);
                                        intMinAddSizeEndX = (int)Math.Floor(fMinAddSizeX);
                                    }

                                    if (fMinAddSizeY == (int)fMinAddSizeY)
                                    {
                                        intMinAddSizeStartY = (int)fMinAddSizeY;
                                        intMinAddSizeEndY = (int)fMinAddSizeY;
                                    }
                                    else
                                    {
                                        intMinAddSizeStartY = (int)Math.Ceiling(fMinAddSizeY);
                                        intMinAddSizeEndY = (int)Math.Floor(fMinAddSizeY);
                                    }

                                    ROI objSampleCharROI = new ROI();

                                    if ((m_intROIOffSetX + pStart.X - intMinAddSizeStartX) >= 0) //if ((pStart.X - intMinAddSizeStartX) >= 0)   // 2019 10 11 - CCENG: add m_intROIOffSetXY because objSampleCharROI attach to main Image.
                                        objSampleCharROI.ref_ROIPositionX = m_intROIOffSetX + pStart.X - intMinAddSizeStartX;
                                    else
                                        objSampleCharROI.ref_ROIPositionX = m_intROIOffSetX;

                                    if ((m_intROIOffSetY + pStart.Y - intMinAddSizeStartY) >= 0)  //if ((pStart.Y - intMinAddSizeStartY) >= 0)  // 2019 10 11 - CCENG: add m_intROIOffSetXY because objSampleCharROI attach to main Image.
                                        objSampleCharROI.ref_ROIPositionY = m_intROIOffSetY + pStart.Y - intMinAddSizeStartY;
                                    else
                                        objSampleCharROI.ref_ROIPositionY = m_intROIOffSetY;

                                    if ((pEnd.X + intMinAddSizeEndX * 2) < m_intImageWidth)
                                        objSampleCharROI.ref_ROIWidth = pEnd.X - pStart.X + intMinAddSizeStartX + intMinAddSizeEndX;
                                    else
                                        continue;
                                    if ((pEnd.Y + intMinAddSizeEndY * 2) < m_intImageHeight)
                                        objSampleCharROI.ref_ROIHeight = pEnd.Y - pStart.Y + intMinAddSizeStartY + intMinAddSizeEndY;
                                    else
                                        continue;

                                    // 2020 03 01 - CCENG: Attached to m_objSampleImage because objSampleCharROI will be Dilated when m_intMissingMarkInspectionMethod is 1. 
                                    //                   : Also Dilate and subtract's image source and destination can be same.          
                                    //objSampleCharROI.AttachImage(objImage);
                                    objSampleCharROI.AttachImage(m_objSampleImage);

                                    objSubtractCharROI.LoadROISetting(objSampleCharROI.ref_ROIPositionX, objSampleCharROI.ref_ROIPositionY,
                                                                        objSampleCharROI.ref_ROIWidth, objSampleCharROI.ref_ROIHeight);

                                    if ((objSampleCharROI.ref_ROIWidth != arrTemplateCharErodeROI[i].ref_ROIWidth) ||
                                        (arrTemplateCharErodeROI[i].ref_ROIWidth != objSubtractCharROI.ref_ROIWidth))
                                        continue;

                                    if ((objSampleCharROI.ref_ROIHeight != arrTemplateCharErodeROI[i].ref_ROIHeight) ||
                                        (arrTemplateCharErodeROI[i].ref_ROIHeight != objSubtractCharROI.ref_ROIHeight))
                                        continue;

                                    arrMarkStartX.Add(objSubtractCharROI.ref_ROIPositionX - m_intROIOffSetX);
                                    arrMarkStartY.Add(objSubtractCharROI.ref_ROIPositionY - m_intROIOffSetY);
                                    arrMarkEndX.Add(objSubtractCharROI.ref_ROIPositionX + objSubtractCharROI.ref_ROIWidth - m_intROIOffSetX);
                                    arrMarkEndY.Add(objSubtractCharROI.ref_ROIPositionY + objSubtractCharROI.ref_ROIHeight - m_intROIOffSetY);

                                    if (!m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i])
                                    {
                                        EasyImage.Oper(EArithmeticLogicOperation.Subtract, arrTemplateCharErodeROI[i].ref_ROI, arrTemplateCharErodeROI[i].ref_ROI, objSubtractCharROI.ref_ROI);
                                    }
                                    else
                                    {
                                        // 2020 08 30 - CCENG: Fix to use "thick on sample mark" bcos more stable and applicable for thin and thick mark.
                                        //if (m_intMissingMarkInspectionMethod == 0) // 2020 03 01 - CCENG: 0=Thin on Template Mark
                                        //{
                                        //    EasyImage.Oper(EArithmeticLogicOperation.Subtract, arrTemplateCharErodeROI[i].ref_ROI, objSampleCharROI.ref_ROI, objSubtractCharROI.ref_ROI);
                                        //}
                                        //else
                                        {
                                            // 2020 03 01 - CCENG: m_intMissingMarkInspectionMethod == 0 mean thick on sample mark
#if (Debug_2_12 || Release_2_12)
                                            EasyImage.DilateBox(objSampleCharROI.ref_ROI, objSampleCharROI.ref_ROI, (uint)m_intCharErodeHalfWidth);
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                                            EasyImage.DilateBox(objSampleCharROI.ref_ROI, objSampleCharROI.ref_ROI, m_intCharErodeHalfWidth);
#endif

                                            EasyImage.Oper(EArithmeticLogicOperation.Subtract, arrTemplateCharErodeROI[i].ref_ROI, objSampleCharROI.ref_ROI, objSubtractCharROI.ref_ROI);
                                        }
                                    }
                                }
                                // Reload ROI size and placement to same location and same size as Mark ROI
                                objSubtractCharROI.LoadROISetting(m_intROIOffSetX, m_intROIOffSetY, objMarkROI.ref_ROIWidth, objMarkROI.ref_ROIHeight);

                                if (m_objMissingBlobs[m_intTemplateIndex] == null)
                                    m_objMissingBlobs[m_intTemplateIndex] = new EBlobs();
                                else
                                    m_objMissingBlobs[m_intTemplateIndex].CleanAllBlobs();

                                if (BuildObject(m_objMissingBlobs[m_intTemplateIndex], objSubtractCharROI, false, true, 255 - intThresholdValue, m_intMinArea, 1000000, 0x1F))
                                {
                                    int intNoMissingBlobs = m_objMissingBlobs[m_intTemplateIndex].ref_intNumSelectedObject;

                                    // Init blob data
                                    List<int> arrintMatchNo = new List<int>();
                                    m_intMissingBlobResult[m_intTemplateIndex] = new int[intNoMissingBlobs];
                                    for (j = 0; j < intNoMissingBlobs; j++)
                                    {
                                        m_intMissingBlobResult[m_intTemplateIndex][j] = 0;
                                    }

                                    for (int i = 0; i < intNoMissingBlobs; i++)
                                    {
                                        arrintMatchNo.Add(-1);

                                        intArea = m_objMissingBlobs[m_intTemplateIndex].ref_arrArea[i];     // Get subtracted blob area
                                        fCenterX = m_objMissingBlobs[m_intTemplateIndex].ref_arrLimitCenterX[i];
                                        fCenterY = m_objMissingBlobs[m_intTemplateIndex].ref_arrLimitCenterY[i];
                                        fWidth = m_objMissingBlobs[m_intTemplateIndex].ref_arrWidth[i];
                                        fHeight = m_objMissingBlobs[m_intTemplateIndex].ref_arrHeight[i];
                                        bool blnIsInOcvCharArea = false;

                                        int intMatchNo = -1;
                                        for (j = 0; j < arrMarkStartX.Count; j++)
                                        {
                                            // 2020 02 27 - CCENG: Check after loop.
                                            // 06-02-2020 JBTAN : for Bar Pin 1 Mark, skip if the extra/broken mark is at the end of both tip
                                            //if (m_blnWantCheckBarPin1)
                                            //{
                                            //    if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnIsBarPin1[j])
                                            //    {
                                            //        if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrBarPin1Type[j] == 0)
                                            //        {
                                            //            if ((fCenterX > arrExcessStartX[j] && fCenterX < arrExcessEndX[j]) &&
                                            //                (fCenterY < arrExcessStartY[j] || fCenterY > arrExcessEndY[j]))
                                            //                continue;
                                            //        }
                                            //        else
                                            //        {
                                            //            if ((fCenterY > arrExcessStartY[j] && fCenterY < arrExcessEndY[j]) &&
                                            //                (fCenterX < arrExcessStartX[j] || fCenterX > arrExcessEndX[j]))
                                            //                continue;
                                            //        }
                                            //    }
                                            //}

                                            //2022-01-09 ZJYEOH : This Size comparing condition need add m_intCharOpenHalfWidth as tolerance because if whole char is missing the defect after dilate sure will bigger than OCV size
                                            // Broken Mark area should always smaller than ocv mark roi. 
                                            if ((fWidth < (arrMarkEndX[j] - arrMarkStartX[j]) + m_intCharOpenHalfWidth + 2) &&
                                            (fHeight < (arrMarkEndY[j] - arrMarkStartY[j]) + m_intCharOpenHalfWidth + 2))
                                            {
                                                // Broken Mark center point should always within ocv mark roi area.
                                                if (fCenterX > arrMarkStartX[j] && fCenterX < arrMarkEndX[j] &&
                                                    fCenterY > arrMarkStartY[j] && fCenterY < arrMarkEndY[j])
                                                {
                                                    //2021-07-07 ZJYEOH : No need meet min 2 corner points requirement as now built on black image
                                                    //// 2019 10 14 - CCENG: Broken Mark center point and at least 2 corner points must within ocv mark roi area. - This is because whole mark ROI image are blobs builded sometime outside char area will be build also and considered as broken if size are big. 
                                                    //int intCornerMatchCount = 0;

                                                    //if ((fCenterX - fWidth / 2) > arrMarkStartX[j] && (fCenterX - fWidth / 2) < arrMarkEndX[j] &&
                                                    //    (fCenterY - fHeight / 2) > arrMarkStartY[j] && (fCenterY - fHeight / 2) < arrMarkEndY[j])
                                                    //{
                                                    //    intCornerMatchCount++;
                                                    //}

                                                    //if ((fCenterX + fWidth / 2) > arrMarkStartX[j] && (fCenterX + fWidth / 2) < arrMarkEndX[j] &&
                                                    //    (fCenterY - fHeight / 2) > arrMarkStartY[j] && (fCenterY - fHeight / 2) < arrMarkEndY[j])
                                                    //{
                                                    //    intCornerMatchCount++;
                                                    //}

                                                    //if ((fCenterX + fWidth / 2) > arrMarkStartX[j] && (fCenterX + fWidth / 2) < arrMarkEndX[j] &&
                                                    //    (fCenterY + fHeight / 2) > arrMarkStartY[j] && (fCenterY + fHeight / 2) < arrMarkEndY[j])
                                                    //{
                                                    //    intCornerMatchCount++;
                                                    //}

                                                    //if ((fCenterX - fWidth / 2) > arrMarkStartX[j] && (fCenterX - fWidth / 2) < arrMarkEndX[j] &&
                                                    //    (fCenterY + fHeight / 2) > arrMarkStartY[j] && (fCenterY + fHeight / 2) < arrMarkEndY[j])
                                                    //{
                                                    //    intCornerMatchCount++;
                                                    //}

                                                    //if (intCornerMatchCount >= 2)
                                                    {
                                                        intMatchNo = j;
                                                        blnIsInOcvCharArea = true;
                                                        break;
                                                    }
                                                }
                                            }
                                        }

                                        if (blnIsInOcvCharArea) // 2019 04 13-CCENG: Only blob under Ocv Char Area will recorded.
                                        {
                                            // 2020 02 27 - CCENG: Move this checking to here.
                                            // 06-02-2020 JBTAN : for Bar Pin 1 Mark, skip if the extra/broken mark is at the end of both tip
                                            if (m_blnWantCheckBarPin1)
                                            {
                                                if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnIsBarPin1[j])
                                                {
                                                    if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrBarPin1Type[j] == 0)
                                                    {
                                                        // 2020 02 27 - CCENG: check x only because sometime the excess area will partially inside the bar.
                                                        //if ((fCenterX > arrExcessStartX[j] && fCenterX < arrExcessEndX[j]) &&
                                                        //    (fCenterY < arrExcessStartY[j] || fCenterY > arrExcessEndY[j]))
                                                        if (fCenterX > arrExcessStartX[j] && fCenterX < arrExcessEndX[j])
                                                            continue;
                                                    }
                                                    else
                                                    {
                                                        // 2020 02 27 - CCENG: check y only because sometime the excess area will partially inside the bar.
                                                        //if ((fCenterY > arrExcessStartY[j] && fCenterY < arrExcessEndY[j]) &&
                                                        //    (fCenterX < arrExcessStartX[j] || fCenterX > arrExcessEndX[j]))
                                                        if (fCenterY > arrExcessStartY[j] && fCenterY < arrExcessEndY[j])
                                                            continue;
                                                    }
                                                }
                                            }

                                            if (m_intSmallestMissingMarkArea[m_intTemplateIndex] == 0 || intArea < m_intSmallestMissingMarkArea[m_intTemplateIndex])
                                                m_intSmallestMissingMarkArea[m_intTemplateIndex] = intArea;

                                            if (m_intBiggestMissingMarkArea[m_intTemplateIndex] == 0 || intArea > m_intBiggestMissingMarkArea[m_intTemplateIndex])
                                                m_intBiggestMissingMarkArea[m_intTemplateIndex] = intArea;

                                            m_arrCharBrokenAreaResult[m_intTemplateIndex][intMatchNo] += intArea;

                                            arrintMatchNo[i] = intMatchNo;

                                        }


                                        //// Check whether the blob has been fail
                                        //for (j = 0; j < intNoSelectedBlobs; j++)
                                        //{
                                        //    if (m_intBlobResult[m_intTemplateIndex][j] == 2)
                                        //    {
                                        //        float fMissingCenterX, fMissingCenterY;
                                        //        fMissingCenterX = fMissingCenterY = 0.0f;

                                        //        fCenterX = m_objBlobs[m_intTemplateIndex].ref_arrLimitCenterX[j];
                                        //        fCenterY = m_objBlobs[m_intTemplateIndex].ref_arrLimitCenterY[j];
                                        //        m_objBlobs[m_intTemplateIndex].DisposeElement(j);

                                        //        fMissingCenterX = m_objMissingBlobs[m_intTemplateIndex].ref_arrLimitCenterX[i];
                                        //        fMissingCenterY = m_objMissingBlobs[m_intTemplateIndex].ref_arrLimitCenterY[i];

                                        //        if (fCenterX == fMissingCenterX && fCenterY == fMissingCenterY)
                                        //        {
                                        //            break;
                                        //        }
                                        //    }
                                        //}

                                        // The blob has been fail 
                                        //if (intNoSelectedBlobs != 0 && j != intNoSelectedBlobs)
                                        //{
                                        //    continue;
                                        //}



                                        //intArea = m_objMissingBlobs[m_intTemplateIndex].ref_arrArea[i];     // Get subtracted blob area // Get subtracted blob contour xy first point
                                        //bool blnIsInOcvCharArea = false;
                                        //if (!blnAuto || (blnAuto && (intArea > objTemplateSetting.intMissingMinArea)))  // 2018 10 08 - CCENG: For faster inspection during production test (blnAuto is true), if blob area small than MissingMinArea, then skip checking IsInOcvCharArea  
                                        //if (intArea > objTemplateSetting.intMissingMinArea)
                                        //{
                                        //    intContourX = m_objMissingBlobs[m_intTemplateIndex].ref_arrContourX[i];
                                        //    intContourY = m_objMissingBlobs[m_intTemplateIndex].ref_arrContourY[i];

                                        //    Contour objContour = new Contour();

                                        //    if (objContour.BuildContour(objSubtractCharROI, intContourX, intContourY, intThresholdValue, 4))
                                        //    {
                                        //        int intMatchCharNo = -1;

                                        //        if (objOCV.IsInOcvCharArea(objContour, ref intMatchCharNo))
                                        //        {
                                        //            blnIsInOcvCharArea = true;
                                        //            if (intArea > objTemplateSetting.intMissingMinArea)
                                        //            {
                                        //                m_blnCharResult[m_intTemplateIndex][intMatchCharNo] = false;

                                        //                m_intMissingBlobResult[m_intTemplateIndex][i] = 2;

                                        //                if ((m_intFailResultMask & 0x10) == 0)
                                        //                    m_intFailResultMask |= 0x10;
                                        //            }
                                        //        }
                                        //    }
                                        //}

                                        //if (blnIsInOcvCharArea) // 2019 04 13-CCENG: Only blob under Ocv Char Area will recorded.
                                        //{
                                        //    if (m_intSmallestMissingMarkArea[m_intTemplateIndex] == 0 || intArea < m_intSmallestMissingMarkArea[m_intTemplateIndex])
                                        //        m_intSmallestMissingMarkArea[m_intTemplateIndex] = intArea;

                                        //    if (m_intBiggestMissingMarkArea[m_intTemplateIndex] == 0 || intArea > m_intBiggestMissingMarkArea[m_intTemplateIndex])
                                        //        m_intBiggestMissingMarkArea[m_intTemplateIndex] = intArea;
                                        //}
                                    }

                                    for (int b = 0; b < m_arrCharBrokenAreaResult[m_intTemplateIndex].Length; b++)
                                    {
                                        if (m_arrCharBrokenAreaResult[m_intTemplateIndex][b] == 0)
                                            continue;

                                        // Make sure object area is higher than min area and broken min area
                                        if ((m_arrCharBrokenAreaResult[m_intTemplateIndex][b] < m_intMinArea) ||
                                            (m_arrCharBrokenAreaResult[m_intTemplateIndex][b] <= (int)Math.Round(objTemplateSetting.arrMaxBrokenArea[b])))   // 2021 02 23 - CCENG: change from < to <= bcos == mean pass also
                                        {
                                            continue;
                                        }
                                        else
                                        {
                                            if (m_intSmallestMissingMarkArea[m_intTemplateIndex] == 0 || m_arrCharBrokenAreaResult[m_intTemplateIndex][b] < m_intSmallestMissingMarkArea[m_intTemplateIndex])
                                                m_intSmallestMissingMarkArea[m_intTemplateIndex] = m_arrCharBrokenAreaResult[m_intTemplateIndex][b];

                                            if (m_intBiggestMissingMarkArea[m_intTemplateIndex] == 0 || m_arrCharBrokenAreaResult[m_intTemplateIndex][b] > m_intBiggestMissingMarkArea[m_intTemplateIndex])
                                                m_intBiggestMissingMarkArea[m_intTemplateIndex] = m_arrCharBrokenAreaResult[m_intTemplateIndex][b];

                                            for (int c = 0; c < arrintMatchNo.Count; c++)
                                            {
                                                if (arrintMatchNo[c] == b)
                                                    m_intMissingBlobResult[m_intTemplateIndex][c] = 2;
                                            }

                                            if ((m_intFailResultMask & 0x10) == 0)
                                                m_intFailResultMask |= 0x10;
                                        }
                                    }
                                }
                            }
                        }

                        #endregion ---------------------------------------------------------------------------------------------------------

                        // Stop to test next template if return pass
                        if (m_intFailResultMask == 0)
                            break;

                        SkipInspection:
                        // Stop to test next template if not inspect all
                        if (!m_blnInspectAllTemplate)
                            break;

                        // Go to next template
                        intTemplateCount++;
                    }
                    timeout.Stop(); // ------------------- checking loop timeout ---------------------------------------------------
                    m_blnLock = false;
                    m_blnLockBlobs = false;

                    if (m_intFailResultMask > 0)
                        return false;
                    else
                        return true;
                }
            }
            catch (Exception ex)
            {
                // 2021 01 05 - CCENG: Need to set FailResultMask in order to fail the unit. 
                if ((m_intFailResultMask & 0x1000) == 0)
                    m_intFailResultMask |= 0x1000;

                m_blnExtraSaveImageAndRecipeDueToException = true;
                m_blnLock = false;
                m_blnLockBlobs = false;
                //m_objTL.WriteLine("InspectOCVMark ex: " + ex.ToString());
                return false;
            }
        }
        public bool InspectOCVOnly(ROI objMarkOcvSearchROI, int intMarkOcvTrainROIWidth, int intMarkOcvTrainROIHeight, ROI objMarkPackageMarkROI,
                                   PointF pRotatedCenterPoint, SizeF SPackageSize, int intInspectionMethod, int intInspectionAreaGrayValueSensitivity, int intBrightSensitivity
            )
        {
            bool blnWantDebug = false;
            m_blnExtraSaveImageAndRecipeDueToException = false;
            if (blnWantDebug)
            {
                objMarkOcvSearchROI.SaveImage("D:\\TS\\objMarkOcvSearchROI.bmp");
                objMarkPackageMarkROI.SaveImage("D:\\TS\\objMarkPackageMarkROI.bmp");
            }
            try
            {
                    // Init and reset all inspection data
                    int intNoSelectedBlobs = 0;
                    int intNumChars = 0;
                    int j;

                    ResetInspectionData(true);

                    for (int i = 0; i < m_arrOCV[m_intGroupIndex].Count; i++)
                        m_arrOCV[m_intGroupIndex][i].DeleteSample();

                    // Check valid image
                    if (objMarkPackageMarkROI.ref_ROI.Width == 0 || objMarkPackageMarkROI.ref_ROI.Height == 0)
                    {
                        // 2021 01 05 - CCENG: Need to set FailResultMask in order to fail the unit. 
                        if ((m_intFailResultMask & 0x1000) == 0)
                            m_intFailResultMask |= 0x1000;
                        
                        m_strErrorMessage = "Mark ROI size is 0!";
                        m_blnLock = false;
                        m_blnLockBlobs = false;
                        return false;
                    }

                    int intTemplateCount = 0;

                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 3");
                    
                    // ------------------- checking loop timeout ---------------------------------------------------
                    HiPerfTimer timeout = new HiPerfTimer();
                    timeout.Start();

                    // Loop from first template until last to do OCV inspection
                    while (intTemplateCount < m_arrOCV[m_intGroupIndex].Count)
                    {

                        // ------------------- checking loop timeout ---------------------------------------------------
                        if (timeout.Timing > 10000)
                        {
                            STTrackLog.WriteLine(">>>>>>>>>>>>> time out 801");
                            break;
                        }
                        // ---------------------------------------------------------------------------------------------

                        // Get selected template index
                        int intTemplateIndex;
                        if (m_blnInspectAllTemplate)
                        {
                            intTemplateIndex = (int)((m_intTemplatePriority >> (0x04 * intTemplateCount)) & 0x0F) - 1;

                            if ((m_intTemplateMask & (0x01 << intTemplateIndex)) > 0)
                                m_intTemplateIndex = intTemplateIndex;
                            else
                                goto SkipInspection;
                        }

                        // Reset error message and result mask
                        m_strErrorMessage = "";
                        m_intFailResultMask = 0;

                        // Get fix value threshold
                        int intThresholdValue = GetAutoThreshold(objMarkPackageMarkROI);

                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 4");

                        //2020-05-20 ZJYEOH : Use gray value threshold
                        if (intInspectionMethod == 1)
                            intThresholdValue = GetGrayValueThreshold(objMarkPackageMarkROI, intInspectionAreaGrayValueSensitivity, intBrightSensitivity);

                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 5");

                        // Get fail option mask (Each template has own fail option setting)
                        int intFailOptionMask = GetFailOptionMask(false);//m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intFailOptionMask;

                        #region ------------- OCV Inspection --------------------------------------------------------------------------------

                        NOCV objOCV = m_arrOCV[m_intGroupIndex][m_intTemplateIndex];
                        TemplateSetting objTemplateSetting = m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex];

                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 6");

                        //for (int a = 0; a < m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrTemplateCharDilateROI.Count; a++)
                        //{
                        //    m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrTemplateCharDilateROI[a]
                        //}
                        float fMinTextOffsetAllowX = 0;
                        float fMinTextOffsetAllowY = 0;

                        for (int i = 0; i < objTemplateSetting.fCharShiftX.Count; i++)
                        {
                            if (i == 0)
                                fMinTextOffsetAllowX = ((int)Math.Round(objTemplateSetting.fCharShiftX[i] + m_fCharROIOffsetX));
                            else
                            {
                                if (fMinTextOffsetAllowX > ((int)Math.Round(objTemplateSetting.fCharShiftX[i] + m_fCharROIOffsetX)))
                                    fMinTextOffsetAllowX = ((int)Math.Round(objTemplateSetting.fCharShiftX[i] + m_fCharROIOffsetX));
                            }

                            if (i == 0)
                                fMinTextOffsetAllowY = ((int)Math.Round(objTemplateSetting.fCharShiftY[i] + m_fCharROIOffsetY));
                            else
                            {
                                if (fMinTextOffsetAllowY > ((int)Math.Round(objTemplateSetting.fCharShiftY[i] + m_fCharROIOffsetY)))
                                    fMinTextOffsetAllowY = ((int)Math.Round(objTemplateSetting.fCharShiftY[i] + m_fCharROIOffsetY));
                            }
                        }

                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 7");
                        
                        int intOCVThresholdValue = intThresholdValue;
                        ////2020-06-17 ZJYEOH : Invert threshold value if black on white
                        //if (!m_blnWhiteOnBlack)
                        //{
                        //    intOCVThresholdValue = 255 - intOCVThresholdValue;
                        //}

                    //2022-02-18 ZJYEOH : When collect data, set OCV text angle = 0, as during learn color package, image will rotate to 0 degree according to orient angle
                        bool blnIsTextInsideMarkROI = objOCV.Inspect_First2(m_objTL, objMarkOcvSearchROI, objMarkPackageMarkROI, intOCVThresholdValue, objMarkPackageMarkROI.ref_ROIPositionX,
                               objMarkPackageMarkROI.ref_ROIPositionY, fMinTextOffsetAllowX, fMinTextOffsetAllowY, m_blnWantSampleAreaScore, m_intMarkScoreOffset, m_intMarkOriPositionScore, 
                               0, m_intMarkScoreMode);

                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 8");

                        if (blnIsTextInsideMarkROI)
                        {
                            // Check Text Score
                            int intSetValue;
                            
                            // Check Char Score
                            float fSampleScore;
                            intNumChars = objOCV.GetNumChars();
                            m_intHitCharCounter = new int[intNumChars];
                            m_blnCharResult[m_intTemplateIndex] = new bool[intNumChars];

                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 9");
                            for (int i = 0; i < intNumChars; i++)
                            {
                                m_intHitCharCounter[i] = 0;

                                //intSetValue = m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting[i];
                              
                                    //intSetValue = m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting[i];
                                
                                //fSampleScore = objOCV.GetCharScore(i);
                                //m_strResultTrack += ", CharScore=" + fSampleScore.ToString();

                                // Fail if score lower than setting
                                //if ((intSetValue > 0 && fSampleScore < intSetValue) && m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i])
                                //{
                                //    m_blnCharResult[m_intTemplateIndex][i] = false;
                                //    if ((m_intFailResultMask & 0x100) == 0)
                                //        m_intFailResultMask |= 0x100;
                                    
                                //}
                                //else
                                    m_blnCharResult[m_intTemplateIndex][i] = true;
                                
                            }
                            
                        }
                        else
                        {
                            ROI objNarrowMarkSearchROI = new ROI();
                            objNarrowMarkSearchROI.AttachImage(objMarkOcvSearchROI);
                           
                            int intTextWidth = 0, intTextHeight = 0;
                            objOCV.GetTextSize(0, ref intTextWidth, ref intTextHeight);


                            int intBiggestSizeWidth;
                            int intBiggestSizeHeight;
                            int intAddXTolerance;
                            int intAddYTolerance;

                            if (intMarkOcvTrainROIWidth > objMarkPackageMarkROI.ref_ROIWidth)   // 2020 06 26 - CCENG: use mark train roi size if mark train roi size bigger than package size. (this happen sometime when unit half flip and package size is measured incorrectly.)
                            {
                                intBiggestSizeWidth = intMarkOcvTrainROIWidth;
                                if (intTextWidth > intBiggestSizeWidth)                         // 2020 06 26 - CCENG: use ocv text roi size if ocv text roi size bigger than mark train roi. (this happen when use multi template and user drag mark train roi with different size.
                                {
                                    intBiggestSizeWidth = intTextWidth + 4;
                                }

                                intAddXTolerance = (intBiggestSizeWidth - objMarkPackageMarkROI.ref_ROIWidth) / 2;
                            }
                            else if (intTextWidth > objMarkPackageMarkROI.ref_ROIWidth)         // 2020 06 26 - CCENG: use ocv text roi size if ocv text roi size bigger than mark train roi. (this happen when use multi template and user drag mark train roi with different size.
                            {
                                intBiggestSizeWidth = intTextWidth + 4;

                                intAddXTolerance = (intBiggestSizeWidth - objMarkPackageMarkROI.ref_ROIWidth) / 2;
                            }
                            else
                            {
                                intAddXTolerance = Math.Min(10, objMarkPackageMarkROI.ref_ROIWidth / 4);
                            }

                            if (intMarkOcvTrainROIHeight > objMarkPackageMarkROI.ref_ROIHeight) // 2020 06 26 - CCENG: use mark train roi size if mark train roi size bigger than package size. (this happen sometime when unit half flip and package size is measured incorrectly.)
                            {
                                intBiggestSizeHeight = intMarkOcvTrainROIHeight;
                                if (intTextHeight > intBiggestSizeHeight)                       // 2020 06 26 - CCENG: use ocv text roi size if ocv text roi size bigger than mark train roi. (this happen when use multi template and user drag mark train roi with different size.
                                {
                                    intBiggestSizeHeight = intTextHeight + 4;
                                }

                                intAddYTolerance = (intBiggestSizeHeight - objMarkPackageMarkROI.ref_ROIHeight) / 2;
                            }
                            else if (intTextHeight > objMarkPackageMarkROI.ref_ROIHeight)       // 2020 06 26 - CCENG: use ocv text roi size if ocv text roi size bigger than mark train roi. (this happen when use multi template and user drag mark train roi with different size.
                            {
                                intBiggestSizeHeight = intTextHeight + 4;

                                intAddYTolerance = (intBiggestSizeHeight - objMarkPackageMarkROI.ref_ROIHeight) / 2;
                            }
                            else
                            {
                                intAddYTolerance = Math.Min(10, objMarkPackageMarkROI.ref_ROIHeight / 4);
                            }


                            //2021-04-30 ZJYEOH : Limit to package ROI
                            if (SPackageSize.Width != -1 && SPackageSize.Height != -1 && pRotatedCenterPoint.X != -1 && pRotatedCenterPoint.X != -1)
                            {
                                int intStartX = objMarkPackageMarkROI.ref_ROIPositionX - intAddXTolerance;
                                int intStartY = objMarkPackageMarkROI.ref_ROIPositionY - intAddYTolerance;
                                int intWidth = objMarkPackageMarkROI.ref_ROIWidth + intAddXTolerance * 2;
                                int intHeight = objMarkPackageMarkROI.ref_ROIHeight + intAddYTolerance * 2;

                                int intTotalStartX = objMarkPackageMarkROI.ref_ROITotalX - intAddXTolerance;
                                int intTotalStartY = objMarkPackageMarkROI.ref_ROITotalY - intAddYTolerance;

                                int intOffsetX = 0;
                                int intOffsetY = 0;
                                int intOffsetWidth = 0;
                                int intOffsetHeight = 0;

                                if (intTotalStartX < (pRotatedCenterPoint.X - (SPackageSize.Width / 2)))
                                {
                                    intOffsetX = (int)Math.Round((pRotatedCenterPoint.X - (SPackageSize.Width / 2)) - intTotalStartX);
                                }

                                if (intTotalStartY < (pRotatedCenterPoint.Y - (SPackageSize.Height / 2)))
                                {
                                    intOffsetY = (int)Math.Round((pRotatedCenterPoint.Y - (SPackageSize.Height / 2)) - intTotalStartY);
                                }

                                if ((intTotalStartX + intOffsetX + intWidth) > (pRotatedCenterPoint.X + (SPackageSize.Width / 2)))
                                {
                                    intOffsetWidth = (int)Math.Round((pRotatedCenterPoint.X + (SPackageSize.Width / 2)) - (intTotalStartX + intOffsetX + intWidth));
                                }

                                if ((intTotalStartY + intOffsetY + intHeight) > (pRotatedCenterPoint.Y + (SPackageSize.Height / 2)))
                                {
                                    intOffsetHeight = (int)Math.Round((pRotatedCenterPoint.Y + (SPackageSize.Height / 2)) - (intTotalStartY + intOffsetY + intHeight));
                                }

                                objNarrowMarkSearchROI.LoadROISetting(intStartX + intOffsetX,
                                                                   intStartY + intOffsetY,
                                                                   intWidth + intOffsetWidth,
                                                                   intHeight + intOffsetHeight);

                                // 2021 08 18 - CCENG: Incase objNarrowMarkSearchROI size still smaller than OCV text ROI, then need to resetting the objNarrowMarkSearchROI again. (This happen when wrong orientation)
                                if (objNarrowMarkSearchROI.ref_ROIWidth < intTextWidth || objNarrowMarkSearchROI.ref_ROIHeight < intTextHeight)
                                {
                                    int intNewWidth = objNarrowMarkSearchROI.ref_ROIWidth;
                                    if (objNarrowMarkSearchROI.ref_ROIWidth < intTextWidth)
                                    {
                                        intNewWidth = intTextHeight + 4;
                                    }

                                    int intNewHeight = objNarrowMarkSearchROI.ref_ROIHeight;
                                    if (objNarrowMarkSearchROI.ref_ROIHeight < intTextHeight)
                                    {
                                        intNewHeight = intTextHeight + 4;
                                    }

                                    objNarrowMarkSearchROI.LoadROISetting(objNarrowMarkSearchROI.ref_ROIPositionX,
                                                                   objNarrowMarkSearchROI.ref_ROIPositionY,
                                                                   intNewWidth,
                                                                   intNewHeight);
                                }

                                //objNarrowMarkSearchROI.SaveImage("D:\\TS\\objNarrowMarkSearchROI" + m_intTemplateIndex.ToString() + ".bmp");
                                objOCV.Inspect(m_objTL, objNarrowMarkSearchROI, intOCVThresholdValue,//intThresholdValue,
                                    intAddXTolerance - intOffsetX, intAddYTolerance - intOffsetY,
                                    fMinTextOffsetAllowX, fMinTextOffsetAllowY, m_blnWantSampleAreaScore);

                            }
                            else
                            {
                                objNarrowMarkSearchROI.LoadROISetting(objMarkPackageMarkROI.ref_ROIPositionX - intAddXTolerance,
                                                                      objMarkPackageMarkROI.ref_ROIPositionY - intAddYTolerance,
                                                                      objMarkPackageMarkROI.ref_ROIWidth + intAddXTolerance * 2,
                                                                      objMarkPackageMarkROI.ref_ROIHeight + intAddYTolerance * 2);

                                // 2021 08 18 - CCENG: Incase objNarrowMarkSearchROI size smaller than OCV text ROI, then need to resetting the objNarrowMarkSearchROI again.(This happen when wrong orientation)
                                if (objNarrowMarkSearchROI.ref_ROIWidth < intTextWidth || objNarrowMarkSearchROI.ref_ROIHeight < intTextHeight)
                                {
                                    int intNewWidth = objNarrowMarkSearchROI.ref_ROIWidth;
                                    if (objNarrowMarkSearchROI.ref_ROIWidth < intTextWidth)
                                    {
                                        intNewWidth = intTextHeight + 4;
                                    }

                                    int intNewHeight = objNarrowMarkSearchROI.ref_ROIHeight;
                                    if (objNarrowMarkSearchROI.ref_ROIHeight < intTextHeight)
                                    {
                                        intNewHeight = intTextHeight + 4;
                                    }

                                    objNarrowMarkSearchROI.LoadROISetting(objNarrowMarkSearchROI.ref_ROIPositionX,
                                                                   objNarrowMarkSearchROI.ref_ROIPositionY,
                                                                   intNewWidth,
                                                                   intNewHeight);
                                }

                                //objNarrowMarkSearchROI.SaveImage("D:\\TS\\objNarrowMarkSearchROI" + m_intTemplateIndex.ToString() + ".bmp");
                                objOCV.Inspect(m_objTL, objNarrowMarkSearchROI, intOCVThresholdValue,//intThresholdValue,
                                    intAddXTolerance, intAddYTolerance,
                                    fMinTextOffsetAllowX, fMinTextOffsetAllowY, m_blnWantSampleAreaScore);

                            }

                            objNarrowMarkSearchROI.Dispose();

                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 12");
                            // Check Text Score
                            int intSetValue;

                            // Check Char Score
                            float fSampleScore;
                            intNumChars = objOCV.GetNumChars();
                            m_intHitCharCounter = new int[intNumChars];
                            m_blnCharResult[m_intTemplateIndex] = new bool[intNumChars];
                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 13");
                            for (int i = 0; i < intNumChars; i++)
                            {
                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 14");
                                m_intHitCharCounter[i] = 0;
                                //if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 15");
                             
                                //    intSetValue = m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting[i];
                                
                                //if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 16");
                                //fSampleScore = objOCV.GetCharScore(i);
                                //if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 17");
                                //m_strResultTrack += ", CharScore=" + fSampleScore.ToString();

                                //// Fail if score lower than setting
                                //if ((intSetValue > 0 && fSampleScore < intSetValue) && m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i])
                                //{
                                //    m_blnCharResult[m_intTemplateIndex][i] = false;
                                //    if ((m_intFailResultMask & 0x100) == 0)
                                //        m_intFailResultMask |= 0x100;
                                    
                                //}
                                //else
                                    m_blnCharResult[m_intTemplateIndex][i] = true;
                                
                            }
                        }
                        
                        #endregion ----------------------------------------------------------------------------------------------------------
                        
                        // Stop to test next template if return pass
                        if (m_intFailResultMask == 0)
                            break;

                        SkipInspection:
                        // Stop to test next template if not inspect all
                        if (!m_blnInspectAllTemplate)
                            break;
                        
                        // Go to next template
                        intTemplateCount++;
                    }
                    
                    timeout.Stop(); // ------------------- checking loop timeout ---------------------------------------------------
                    m_blnLock = false;
                    m_blnLockBlobs = false;

                    if (m_intFailResultMask > 0)
                        return false;
                    else
                        return true;
            }
            catch (Exception ex)
            {
                // 2021 01 05 - CCENG: Need to set FailResultMask in order to fail the unit. 
                if ((m_intFailResultMask & 0x1000) == 0)
                    m_intFailResultMask |= 0x1000;
                
                return false;
            }
        }
        public bool InspectOCVMark_NewMethodForMultiExcessMark_OcvAngleAndPackageAngle(bool blnAuto,
            ref ImageDrawing objImage, ImageDrawing objOcvRotatedImage,
            ROI objMarkOcvSearchROI, int intMarkOcvTrainROIWidth, int intMarkOcvTrainROIHeight,
            ROI objMarkPackageSearchROI, ROI objMarkPackageMarkROI,
            bool blnSkipExtraPadAndTextShiftedChecking, ImageDrawing objWhiteImage, ImageDrawing objBlackImage, bool blnWantCheckNoMark, bool blnContourCheck, bool blnWantCheckBrokenMark,
            PointF pRotatedCenterPoint, SizeF SPackageSize, float fPackageAngle, float fMarkAngle, int intInspectionMethod, int intInspectionAreaGrayValueSensitivity, int intBrightSensitivity,
            bool blnByPassUnit, int intMinMarkScore, List<float> arrDontCareLeadAreaStartX, List<float> arrDontCareLeadAreaStartY, List<float> arrDontCareLeadAreaEndX, List<float> arrDontCareLeadAreaEndY, List<int> arrDontCareLeadDirection,
            List<ROI> arrMarkDontCareROI, ImageDrawing objBlackWhiteTopImage, ImageDrawing objBlackWhiteRightImage, ImageDrawing objBlackWhiteBottomImage, ImageDrawing objBlackWhiteLeftImage,
            bool blnTestHandMade, string strPreTestImagePath, bool ShowLiterationOnly)
{
            /*
             *  Reset previous inspection data
             *  Get true threshold
             *  Build objects
             *  OCV/OCR inspection
             *      - Check ref char
             *      - Check recognized char score
             *      - Check recognized char position
             *  Check Text Shifted
             *  Blobs Inspection : Extra Mark(Check Area, Uncheck Area, Group Area), Missing Mark, Broken Mark)
             *  Subtract Inspection : Extra Mark Char Area and Missing Mark
             * 
             * Note: blnSkipExtraPadAndTextShiftedChecking should set to true if WantGauge is false. 
             * The reason is without Gauge to measure unit edge, vision can't know the exact unit location. Without the unit location information, extra pad and text shifted cannot be detected as well. 
             */

            bool blnWantDebug = false;
            m_blnExtraSaveImageAndRecipeDueToException = false;
            if (blnWantDebug)
            {
                objImage.SaveImage("D:\\TS\\objImage.bmp");
                objOcvRotatedImage.SaveImage("D:\\TS\\objOcvRotatedImage.bmp");
                objMarkOcvSearchROI.SaveImage("D:\\TS\\objMarkOcvSearchROI.bmp");
                objMarkPackageSearchROI.SaveImage("D:\\TS\\objMarkPackageSearchROI.bmp");
                objMarkPackageMarkROI.SaveImage("D:\\TS\\objMarkPackageMarkROI.bmp");
            }
            try
            {
                m_blnLock = true;
                m_strResultTrack = "";

                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 1");
                WaitEventDone(ref m_blnLockBlobs, false);
                //lock (m_objLockBlobs)
                {
                    m_blnLockBlobs = true;

                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 2");

                    // Init and reset all inspection data
                    int intNoSelectedBlobs = 0;
                    int intNumChars = 0;
                    int j;

                    ResetInspectionData(blnWantCheckNoMark);

                    for (int i = 0; i < m_arrOCV[m_intGroupIndex].Count; i++)
                        m_arrOCV[m_intGroupIndex][i].DeleteSample();

                    // Check valid image
                    if (objMarkPackageMarkROI.ref_ROI.Width == 0 || objMarkPackageMarkROI.ref_ROI.Height == 0)
                    {
                        // 2021 01 05 - CCENG: Need to set FailResultMask in order to fail the unit. 
                        if ((m_intFailResultMask & 0x1000) == 0)
                            m_intFailResultMask |= 0x1000;

                        if (blnTestHandMade)
                        {
                            if ((m_intFailResultMask_ForPreTest & 0x1000) == 0)
                                m_intFailResultMask_ForPreTest |= 0x1000;
                        }

                        m_strErrorMessage = "Mark ROI size is 0!";
                        m_blnLock = false;
                        m_blnLockBlobs = false;
                        return false;
                    }

                    int intTemplateCount = 0;

                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 3");

                    if (m_blnWantDontCareArea)
                    {
                        //keep test image in m_objDontCareBackupImage before modify with dont care pattern, so that can be reuse by other template dont care pattern
                        if (m_intExtraExcessMarkInspectionAreaCutMode == 0)
                            objImage.CopyTo(ref m_objDontCareBackupImage);
                        else
                            objOcvRotatedImage.CopyTo(ref m_objDontCareBackupImage);
                    }

                    // ------------------- checking loop timeout ---------------------------------------------------
                    HiPerfTimer timeout = new HiPerfTimer();
                    timeout.Start();

                    // Loop from first template until last to do OCV inspection
                    while (intTemplateCount < m_arrOCV[m_intGroupIndex].Count)
                    {

                        // ------------------- checking loop timeout ---------------------------------------------------
                        if (timeout.Timing > 10000)
                        {
                            STTrackLog.WriteLine(">>>>>>>>>>>>> time out 801");
                            break;
                        }
                        // ---------------------------------------------------------------------------------------------

                        // Get selected template index
                        int intTemplateIndex;
                        if (m_blnInspectAllTemplate)
                        {
                            intTemplateIndex = (int)((m_intTemplatePriority >> (0x04 * intTemplateCount)) & 0x0F) - 1;

                            if ((m_intTemplateMask & (0x01 << intTemplateIndex)) > 0)
                                m_intTemplateIndex = intTemplateIndex;
                            else
                                goto SkipInspection;
                        }

                        // Reset error message and result mask
                        m_strErrorMessage = "";
                        m_intFailResultMask = 0;

                        // Get fix value threshold
                        int intThresholdValue = GetAutoThreshold(objMarkPackageMarkROI);

                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 4");

                        //2020-05-20 ZJYEOH : Use gray value threshold
                        if (intInspectionMethod == 1)
                            intThresholdValue = GetGrayValueThreshold(objMarkPackageMarkROI, intInspectionAreaGrayValueSensitivity, intBrightSensitivity);

                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 5");

                        // Get fail option mask (Each template has own fail option setting)
                        int intFailOptionMask = GetFailOptionMask(blnTestHandMade);//m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intFailOptionMask;

                        #region ------------- OCV Inspection --------------------------------------------------------------------------------

                        NOCV objOCV = m_arrOCV[m_intGroupIndex][m_intTemplateIndex];
                        TemplateSetting objTemplateSetting = m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex];

                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 6");

                        //for (int a = 0; a < m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrTemplateCharDilateROI.Count; a++)
                        //{
                        //    m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrTemplateCharDilateROI[a]
                        //}
                        float fMinTextOffsetAllowX = 0;
                        float fMinTextOffsetAllowY = 0;

                        for (int i = 0; i < objTemplateSetting.fCharShiftX.Count; i++)
                        {
                            if (i == 0)
                                fMinTextOffsetAllowX = ((int)Math.Round(objTemplateSetting.fCharShiftX[i] + m_fCharROIOffsetX));
                            else
                            {
                                if (fMinTextOffsetAllowX > ((int)Math.Round(objTemplateSetting.fCharShiftX[i] + m_fCharROIOffsetX)))
                                    fMinTextOffsetAllowX = ((int)Math.Round(objTemplateSetting.fCharShiftX[i] + m_fCharROIOffsetX));
                            }

                            if (i == 0)
                                fMinTextOffsetAllowY = ((int)Math.Round(objTemplateSetting.fCharShiftY[i] + m_fCharROIOffsetY));
                            else
                            {
                                if (fMinTextOffsetAllowY > ((int)Math.Round(objTemplateSetting.fCharShiftY[i] + m_fCharROIOffsetY)))
                                    fMinTextOffsetAllowY = ((int)Math.Round(objTemplateSetting.fCharShiftY[i] + m_fCharROIOffsetY));
                            }
                        }

                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 7");

                        //////objOCV.Inspect(m_objTL, objMarkOcvSearchROI, intThresholdValue, objMarkPackageMarkROI.ref_ROIPositionX,
                        //////    objMarkPackageMarkROI.ref_ROIPositionY, fMinTextOffsetAllowX, fMinTextOffsetAllowY, m_blnWantSampleAreaScore);

                        //////// Check Text Score
                        //////int intSetValue;

                        //////// Check Char Score
                        //////float fSampleScore;
                        //////intNumChars = objOCV.GetNumChars();
                        //////m_intHitCharCounter = new int[intNumChars];
                        //////m_blnCharResult[m_intTemplateIndex] = new bool[intNumChars];
                        //////for (int i = 0; i < intNumChars; i++)
                        //////{
                        //////    //// 24-07-2019 ZJYEOH : Skip if the mark is disabled
                        //////    //if (!m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i])
                        //////    //    continue;

                        //////    m_intHitCharCounter[i] = 0;

                        //////    intSetValue = m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting[i];
                        //////    fSampleScore = objOCV.GetCharScore(i);
                        //////    m_strResultTrack += ", CharScore=" + fSampleScore.ToString();

                        //////    // Fail if score lower than setting
                        //////    if ((intSetValue > 0 && fSampleScore < intSetValue) && m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i])
                        //////    {
                        //////        m_blnCharResult[m_intTemplateIndex][i] = false;
                        //////        if ((m_intFailResultMask & 0x100) == 0)
                        //////            m_intFailResultMask |= 0x100;
                        //////    }
                        //////    else
                        //////        m_blnCharResult[m_intTemplateIndex][i] = true;
                        //////}

                        //objMarkOcvSearchROI.SaveImage("D:\\objMarkOcvSearchROI1.bmp");
                        ////2020-06-17 ZJYEOH : Invert if black on white
                        //ImageDrawing objOCVImage = new ImageDrawing(true, objMarkOcvSearchROI.ref_ROI.TopParent.Width, objMarkOcvSearchROI.ref_ROI.TopParent.Height);
                        //if (!m_blnWhiteOnBlack)
                        //{
                        //    EasyImage.Oper(EArithmeticLogicOperation.Copy, objMarkOcvSearchROI.ref_ROI.TopParent, objOCVImage.ref_objMainImage);
                        //    objMarkOcvSearchROI.ref_ROI.Detach();
                        //    objMarkOcvSearchROI.ref_ROI.Attach(objOCVImage.ref_objMainImage);
                        //    //EasyImage.Oper(EArithmeticLogicOperation.Invert, objMarkOcvSearchROI.ref_ROI, objMarkOcvSearchROI.ref_ROI);
                        //    ROI.InvertOperationROI(objMarkOcvSearchROI);
                        //}
                        //objMarkOcvSearchROI.SaveImage("D:\\objMarkOcvSearchROI2.bmp");

                        int intOCVThresholdValue = intThresholdValue;
                        ////2020-06-17 ZJYEOH : Invert threshold value if black on white
                        //if (!m_blnWhiteOnBlack)
                        //{
                        //    intOCVThresholdValue = 255 - intOCVThresholdValue;
                        //}

                        bool blnIsTextInsideMarkROI = objOCV.Inspect_First2(m_objTL, objMarkOcvSearchROI, objMarkPackageMarkROI, intOCVThresholdValue, objMarkPackageMarkROI.ref_ROIPositionX,
                               objMarkPackageMarkROI.ref_ROIPositionY, fMinTextOffsetAllowX, fMinTextOffsetAllowY, m_blnWantSampleAreaScore, m_intMarkScoreOffset, m_intMarkOriPositionScore, 
                               m_intMarkScoreMode);

                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 8");

                        bool[] arrCharFailOtherThanScore;

                        if (blnIsTextInsideMarkROI)
                        {
                            // Check Text Score
                            int intSetValue;

                            // 2019 07 16 - CCENG: Not need OCV Text Score Test -----------------------------
                            //int intNumTexts = objOCV.GetNumTexts();
                            //m_blnTextResult[m_intTemplateIndex] = new bool[intNumTexts];
                            //for (int i = 0; i < intNumTexts; i++)
                            //{
                            //    intSetValue = m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intTextMinScore;
                            //    m_arrTestMatchScore[m_intTemplateIndex] = objOCV.GetTextScore(i);

                            //    // Fail if score lower than setting
                            //    if (m_arrTestMatchScore[m_intTemplateIndex] < intSetValue)
                            //    {
                            //        m_blnTextResult[m_intTemplateIndex][i] = false;
                            //        if ((m_intFailResultMask & 0x200) == 0)
                            //            m_intFailResultMask |= 0x200;
                            //    }
                            //    else
                            //        m_blnTextResult[m_intTemplateIndex][i] = true;
                            //}
                            //m_blnTextResult[m_intTemplateIndex][i] = true;

                            // Check Char Score
                            float fSampleScore;
                            intNumChars = objOCV.GetNumChars();
                            m_intHitCharCounter = new int[intNumChars];
                            m_blnCharResult[m_intTemplateIndex] = new bool[intNumChars];
                            arrCharFailOtherThanScore = new bool[intNumChars];
                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 9");
                            for (int i = 0; i < intNumChars; i++)
                            {
                                //// 24-07-2019 ZJYEOH : Skip if the mark is disabled
                                //if (!m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i])
                                //    continue;

                                m_intHitCharCounter[i] = 0;

                                //intSetValue = m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting[i];
                                // 2020 08 01 - CCENG: Goodark customer request to check minimum mark score when press bypass button in IPM
                                if (blnByPassUnit)
                                {
                                    intSetValue = intMinMarkScore;
                                }
                                else
                                {
                                    intSetValue = m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting[i];
                                }

                                if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnIsBarPin1[i] && m_blnWantCheckBarPin1)
                                    objOCV.SetCharScore_BarPin1AffectScore(i);

                                fSampleScore = objOCV.GetCharScore(i);
                                m_strResultTrack += ", CharScore=" + fSampleScore.ToString();

                                // Fail if score lower than setting
                                if ((intSetValue > 0 && fSampleScore < intSetValue) && m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i])
                                {
                                    m_blnCharResult[m_intTemplateIndex][i] = false;
                                    if ((m_intFailResultMask & 0x100) == 0)
                                        m_intFailResultMask |= 0x100;

                                    if (blnTestHandMade)
                                    {
                                        if ((m_intFailResultMask_ForPreTest & 0x100) == 0)
                                            m_intFailResultMask_ForPreTest |= 0x100;
                                    }

                                }
                                else
                                    m_blnCharResult[m_intTemplateIndex][i] = true;

                                //// Fail if AGV Percent lower than setting
                                //if (m_blnWantCheckMarkAverageGrayValue && ((intFailOptionMask & 0x200) > 0))
                                //{
                                //    if ((m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fMaxAGVPercent[i] > 0 && Math.Abs(objOCV.GetCharForeAreaSumPercent(i)) > m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fMaxAGVPercent[i]) && m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i])
                                //    {
                                //        arrCharFailOtherThanScore[i] = true;
                                //        if (m_blnCharResult[m_intTemplateIndex][i])
                                //            m_blnCharResult[m_intTemplateIndex][i] = false;
                                //        if ((m_intFailResultMask & 0x4000) == 0)
                                //            m_intFailResultMask |= 0x4000;

                                //        if (blnTestHandMade)
                                //        {
                                //            if ((m_intFailResultMask_ForPreTest & 0x4000) == 0)
                                //                m_intFailResultMask_ForPreTest |= 0x4000;
                                //        }

                                //    }
                                //}
                            }

                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 10");
                        }
                        else
                        {
                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 11");
                            // 2020 04 25 - CCENG: Sometime search ROI is too big until ocv inspection cannot find the mark even though the mark is there.
                            //              so need to narror the search ROI.
                            //              The narror search roi == mark roi + 10 or 1/4 or mark roi size.
                            ROI objNarrowMarkSearchROI = new ROI();
                            objNarrowMarkSearchROI.AttachImage(objMarkOcvSearchROI);
                            //int intAddXTolerance = Math.Min(10, objMarkPackageMarkROI.ref_ROIWidth / 4);
                            //int intAddYTolerance = Math.Min(10, objMarkPackageMarkROI.ref_ROIHeight / 4);
                            //objNarrowMarkSearchROI.LoadROISetting(objMarkPackageMarkROI.ref_ROIPositionX - intAddXTolerance,
                            //                                      objMarkPackageMarkROI.ref_ROIPositionY - intAddYTolerance,
                            //                                      objMarkPackageMarkROI.ref_ROIWidth + intAddXTolerance * 2,
                            //                                      objMarkPackageMarkROI.ref_ROIHeight + intAddYTolerance * 2);

                            // 2020 06 26   - CCENG: Need to make sure narror roi is bigger than ocv text size.
                            //              - Euresys error will display during ocv inspection if roi size smaller ocv text size 
                            //              - Then why cannot direct use ocv text size for narror roi size. bcos ocv text sometime too small compare to package size.
                            //              - 
                            //
                            int intTextWidth = 0, intTextHeight = 0;
                            objOCV.GetTextSize(0, ref intTextWidth, ref intTextHeight);


                            int intBiggestSizeWidth;
                            int intBiggestSizeHeight;
                            int intAddXTolerance;
                            int intAddYTolerance;

                            if (intMarkOcvTrainROIWidth > objMarkPackageMarkROI.ref_ROIWidth)   // 2020 06 26 - CCENG: use mark train roi size if mark train roi size bigger than package size. (this happen sometime when unit half flip and package size is measured incorrectly.)
                            {
                                intBiggestSizeWidth = intMarkOcvTrainROIWidth;
                                if (intTextWidth > intBiggestSizeWidth)                         // 2020 06 26 - CCENG: use ocv text roi size if ocv text roi size bigger than mark train roi. (this happen when use multi template and user drag mark train roi with different size.
                                {
                                    intBiggestSizeWidth = intTextWidth + 4;
                                }

                                intAddXTolerance = (intBiggestSizeWidth - objMarkPackageMarkROI.ref_ROIWidth) / 2;
                            }
                            else if (intTextWidth > objMarkPackageMarkROI.ref_ROIWidth)         // 2020 06 26 - CCENG: use ocv text roi size if ocv text roi size bigger than mark train roi. (this happen when use multi template and user drag mark train roi with different size.
                            {
                                intBiggestSizeWidth = intTextWidth + 4;

                                intAddXTolerance = (intBiggestSizeWidth - objMarkPackageMarkROI.ref_ROIWidth) / 2;
                            }
                            else
                            {
                                intAddXTolerance = Math.Min(10, objMarkPackageMarkROI.ref_ROIWidth / 4);
                            }

                            if (intMarkOcvTrainROIHeight > objMarkPackageMarkROI.ref_ROIHeight) // 2020 06 26 - CCENG: use mark train roi size if mark train roi size bigger than package size. (this happen sometime when unit half flip and package size is measured incorrectly.)
                            {
                                intBiggestSizeHeight = intMarkOcvTrainROIHeight;
                                if (intTextHeight > intBiggestSizeHeight)                       // 2020 06 26 - CCENG: use ocv text roi size if ocv text roi size bigger than mark train roi. (this happen when use multi template and user drag mark train roi with different size.
                                {
                                    intBiggestSizeHeight = intTextHeight + 4;
                                }

                                intAddYTolerance = (intBiggestSizeHeight - objMarkPackageMarkROI.ref_ROIHeight) / 2;
                            }
                            else if (intTextHeight > objMarkPackageMarkROI.ref_ROIHeight)       // 2020 06 26 - CCENG: use ocv text roi size if ocv text roi size bigger than mark train roi. (this happen when use multi template and user drag mark train roi with different size.
                            {
                                intBiggestSizeHeight = intTextHeight + 4;

                                intAddYTolerance = (intBiggestSizeHeight - objMarkPackageMarkROI.ref_ROIHeight) / 2;
                            }
                            else
                            {
                                intAddYTolerance = Math.Min(10, objMarkPackageMarkROI.ref_ROIHeight / 4);
                            }


                            //2021-04-30 ZJYEOH : Limit to package ROI
                            if (SPackageSize.Width != -1 && SPackageSize.Height != -1 && pRotatedCenterPoint.X != -1 && pRotatedCenterPoint.X != -1)
                            {
                                int intStartX = objMarkPackageMarkROI.ref_ROIPositionX - intAddXTolerance;
                                int intStartY = objMarkPackageMarkROI.ref_ROIPositionY - intAddYTolerance;
                                int intWidth = objMarkPackageMarkROI.ref_ROIWidth + intAddXTolerance * 2;
                                int intHeight = objMarkPackageMarkROI.ref_ROIHeight + intAddYTolerance * 2;

                                int intTotalStartX = objMarkPackageMarkROI.ref_ROITotalX - intAddXTolerance;
                                int intTotalStartY = objMarkPackageMarkROI.ref_ROITotalY - intAddYTolerance;

                                int intOffsetX = 0;
                                int intOffsetY = 0;
                                int intOffsetWidth = 0;
                                int intOffsetHeight = 0;

                                if (intTotalStartX < (pRotatedCenterPoint.X - (SPackageSize.Width / 2)))
                                {
                                    intOffsetX = (int)Math.Round((pRotatedCenterPoint.X - (SPackageSize.Width / 2)) - intTotalStartX);
                                }

                                if (intTotalStartY < (pRotatedCenterPoint.Y - (SPackageSize.Height / 2)))
                                {
                                    intOffsetY = (int)Math.Round((pRotatedCenterPoint.Y - (SPackageSize.Height / 2)) - intTotalStartY);
                                }

                                if ((intTotalStartX + intOffsetX + intWidth) > (pRotatedCenterPoint.X + (SPackageSize.Width / 2)))
                                {
                                    intOffsetWidth = (int)Math.Round((pRotatedCenterPoint.X + (SPackageSize.Width / 2)) - (intTotalStartX + intOffsetX + intWidth));
                                }

                                if ((intTotalStartY + intOffsetY + intHeight) > (pRotatedCenterPoint.Y + (SPackageSize.Height / 2)))
                                {
                                    intOffsetHeight = (int)Math.Round((pRotatedCenterPoint.Y + (SPackageSize.Height / 2)) - (intTotalStartY + intOffsetY + intHeight));
                                }

                                objNarrowMarkSearchROI.LoadROISetting(intStartX + intOffsetX,
                                                                   intStartY + intOffsetY,
                                                                   intWidth + intOffsetWidth,
                                                                   intHeight + intOffsetHeight);

                                // 2021 08 18 - CCENG: Incase objNarrowMarkSearchROI size still smaller than OCV text ROI, then need to resetting the objNarrowMarkSearchROI again. (This happen when wrong orientation)
                                if (objNarrowMarkSearchROI.ref_ROIWidth < intTextWidth || objNarrowMarkSearchROI.ref_ROIHeight < intTextHeight)
                                {
                                    int intNewWidth = objNarrowMarkSearchROI.ref_ROIWidth;
                                    if (objNarrowMarkSearchROI.ref_ROIWidth < intTextWidth)
                                    {
                                        intNewWidth = intTextWidth + 4;
                                    }

                                    int intNewHeight = objNarrowMarkSearchROI.ref_ROIHeight;
                                    if (objNarrowMarkSearchROI.ref_ROIHeight < intTextHeight)
                                    {
                                        intNewHeight = intTextHeight + 4;
                                    }

                                    objNarrowMarkSearchROI.LoadROISetting(objNarrowMarkSearchROI.ref_ROIPositionX,
                                                                   objNarrowMarkSearchROI.ref_ROIPositionY,
                                                                   intNewWidth,
                                                                   intNewHeight);
                                }

                                //objNarrowMarkSearchROI.SaveImage("D:\\TS\\objNarrowMarkSearchROI" + m_intTemplateIndex.ToString() + ".bmp");
                                objOCV.Inspect(m_objTL, objNarrowMarkSearchROI, intOCVThresholdValue,//intThresholdValue,
                                    intAddXTolerance - intOffsetX, intAddYTolerance - intOffsetY,
                                    fMinTextOffsetAllowX, fMinTextOffsetAllowY, m_blnWantSampleAreaScore);

                            }
                            else
                            {
                                objNarrowMarkSearchROI.LoadROISetting(objMarkPackageMarkROI.ref_ROIPositionX - intAddXTolerance,
                                                                      objMarkPackageMarkROI.ref_ROIPositionY - intAddYTolerance,
                                                                      objMarkPackageMarkROI.ref_ROIWidth + intAddXTolerance * 2,
                                                                      objMarkPackageMarkROI.ref_ROIHeight + intAddYTolerance * 2);

                                // 2021 08 18 - CCENG: Incase objNarrowMarkSearchROI size smaller than OCV text ROI, then need to resetting the objNarrowMarkSearchROI again.(This happen when wrong orientation)
                                if (objNarrowMarkSearchROI.ref_ROIWidth < intTextWidth || objNarrowMarkSearchROI.ref_ROIHeight < intTextHeight)
                                {
                                    int intNewWidth = objNarrowMarkSearchROI.ref_ROIWidth;
                                    if (objNarrowMarkSearchROI.ref_ROIWidth < intTextWidth)
                                    {
                                        intNewWidth = intTextWidth + 4;
                                    }

                                    int intNewHeight = objNarrowMarkSearchROI.ref_ROIHeight;
                                    if (objNarrowMarkSearchROI.ref_ROIHeight < intTextHeight)
                                    {
                                        intNewHeight = intTextHeight + 4;
                                    }

                                    objNarrowMarkSearchROI.LoadROISetting(objNarrowMarkSearchROI.ref_ROIPositionX,
                                                                   objNarrowMarkSearchROI.ref_ROIPositionY,
                                                                   intNewWidth,
                                                                   intNewHeight);
                                }

                                //objNarrowMarkSearchROI.SaveImage("D:\\TS\\objNarrowMarkSearchROI" + m_intTemplateIndex.ToString() + ".bmp");
                                objOCV.Inspect(m_objTL, objNarrowMarkSearchROI, intOCVThresholdValue,//intThresholdValue,
                                    intAddXTolerance, intAddYTolerance,
                                    fMinTextOffsetAllowX, fMinTextOffsetAllowY, m_blnWantSampleAreaScore);

                            }

                            objNarrowMarkSearchROI.Dispose();

                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 12");
                            // Check Text Score
                            int intSetValue;

                            // Check Char Score
                            float fSampleScore;
                            intNumChars = objOCV.GetNumChars();
                            m_intHitCharCounter = new int[intNumChars];
                            m_blnCharResult[m_intTemplateIndex] = new bool[intNumChars];
                            arrCharFailOtherThanScore = new bool[intNumChars];
                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 13");
                            for (int i = 0; i < intNumChars; i++)
                            {
                                //// 24-07-2019 ZJYEOH : Skip if the mark is disabled
                                //if (!m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i])
                                //    continue;
                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 14");
                                m_intHitCharCounter[i] = 0;
                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 15");
                                //intSetValue = m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting[i];
                                // 2020 08 01 - CCENG: Goodark customer request to check minimum mark score when press bypass button in IPM
                                if (blnByPassUnit)
                                {
                                    intSetValue = intMinMarkScore;
                                }
                                else
                                {
                                    intSetValue = m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting[i];
                                }

                                if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnIsBarPin1[i] && m_blnWantCheckBarPin1)
                                    objOCV.SetCharScore_BarPin1AffectScore(i);

                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 16");
                                fSampleScore = objOCV.GetCharScore(i);
                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 17");
                                m_strResultTrack += ", CharScore=" + fSampleScore.ToString();

                                // Fail if score lower than setting
                                if ((intSetValue > 0 && fSampleScore < intSetValue) && m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i])
                                {
                                    m_blnCharResult[m_intTemplateIndex][i] = false;
                                    if ((m_intFailResultMask & 0x100) == 0)
                                        m_intFailResultMask |= 0x100;

                                    if (blnTestHandMade)
                                    {
                                        if ((m_intFailResultMask_ForPreTest & 0x100) == 0)
                                            m_intFailResultMask_ForPreTest |= 0x100;
                                    }

                                }
                                else
                                    m_blnCharResult[m_intTemplateIndex][i] = true;

                                //// Fail if AGV Percent lower than setting
                                //if (m_blnWantCheckMarkAverageGrayValue && ((intFailOptionMask & 0x200) > 0))
                                //{
                                //    if ((m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fMaxAGVPercent[i] > 0 && Math.Abs(objOCV.GetCharForeAreaSumPercent(i)) > m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fMaxAGVPercent[i]) && m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i])
                                //    {
                                //        arrCharFailOtherThanScore[i] = true;
                                //        if (m_blnCharResult[m_intTemplateIndex][i])
                                //            m_blnCharResult[m_intTemplateIndex][i] = false;
                                //        if ((m_intFailResultMask & 0x4000) == 0)
                                //            m_intFailResultMask |= 0x4000;

                                //        if (blnTestHandMade)
                                //        {
                                //            if ((m_intFailResultMask_ForPreTest & 0x4000) == 0)
                                //                m_intFailResultMask_ForPreTest |= 0x4000;
                                //        }

                                //    }
                                //}
                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 18");
                            }
                        }
                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 19");

                        // 2021 0303 - CCENG: Function added by ZJYoeh. To repossition sample character with template character using blob information.
                        //if (BuildObject(m_objBlobs[m_intTemplateIndex], objMarkOcvSearchROI, false, false, intOCVThresholdValue, 0, objMarkOcvSearchROI.ref_ROIWidth * objMarkOcvSearchROI.ref_ROIHeight, 0x1F))
                        //{
                        //    float fCenterX1, fCenterY1, fWidth1, fHeight1, fGravityCenterX1, fGravityCenterY1;
                        //    int intArea1, intContourX1, intContourY1;
                        //    List<int> arrSkipBlob = new List<int>();
                        //    for (int a = 0; a < intNumChars; a++)
                        //    {
                        //        uint uintAreaDiff = uint.MaxValue;
                        //        float fCenterX1_Final = 0, fCenterY1_Final = 0;

                        //        Point pStart = objOCV.GetCharStartXY(a);
                        //        Point pEnd = objOCV.GetCharEndXY(a);

                        //        pStart = new Point(objMarkPackageMarkROI.ref_ROI.TotalOrgX + pStart.X, objMarkPackageMarkROI.ref_ROI.TotalOrgY + pStart.Y);
                        //        pEnd = new Point(objMarkPackageMarkROI.ref_ROI.TotalOrgX + pEnd.X, objMarkPackageMarkROI.ref_ROI.TotalOrgY + pEnd.Y);

                        //        for (int b = 0; b < m_objBlobs[m_intTemplateIndex].ref_intNumSelectedObject; b++)
                        //        {
                        //            if (arrSkipBlob.Contains(b))
                        //                continue;

                        //            fCenterX1 = objMarkOcvSearchROI.ref_ROITotalX + m_objBlobs[m_intTemplateIndex].ref_arrLimitCenterX[b];
                        //            fCenterY1 = objMarkOcvSearchROI.ref_ROITotalY + m_objBlobs[m_intTemplateIndex].ref_arrLimitCenterY[b];
                        //            //fWidth1 = m_objBlobs[m_intTemplateIndex].ref_arrWidth[b];
                        //            //fHeight1 = m_objBlobs[m_intTemplateIndex].ref_arrHeight[b];
                        //            //fGravityCenterX1 = m_objBlobs[m_intTemplateIndex].ref_arrGravityCenterX[b];
                        //            //fGravityCenterY1 = m_objBlobs[m_intTemplateIndex].ref_arrGravityCenterY[b];
                        //            intArea1 = m_objBlobs[m_intTemplateIndex].ref_arrArea[b];
                        //            //intContourX1 = m_objBlobs[m_intTemplateIndex].ref_arrContourX[b];
                        //            //intContourY1 = m_objBlobs[m_intTemplateIndex].ref_arrContourY[b];

                        //            if ((pStart.X < fCenterX1) && (pEnd.X > fCenterX1) && (pStart.Y < fCenterY1) && (pEnd.Y > fCenterY1))
                        //            {
                        //                if (!arrSkipBlob.Contains(b))
                        //                    arrSkipBlob.Add(b);

                        //                if (uintAreaDiff > (uint)Math.Abs(objOCV.GetCharForeArea(a) - intArea1))
                        //                {
                        //                    uintAreaDiff = (uint)Math.Abs(objOCV.GetCharForeArea(a) - intArea1);
                        //                    fCenterX1_Final = fCenterX1 - objMarkPackageMarkROI.ref_ROI.TotalOrgX;
                        //                    fCenterY1_Final = fCenterY1 - objMarkPackageMarkROI.ref_ROI.TotalOrgY;
                        //                }
                        //            }
                        //        }

                        //        if (uintAreaDiff != uint.MaxValue && fCenterX1_Final != 0 && fCenterY1_Final != 0)
                        //        {
                        //            objOCV.SetCharXY(a, (int)Math.Round(fCenterX1_Final), (int)Math.Round(fCenterY1_Final));
                        //        }
                        //    }
                        //}

                        //objOCVImage.Dispose();

                        #endregion ----------------------------------------------------------------------------------------------------------
                        if (m_blnWantCheckMarkAverageGrayValue && ((intFailOptionMask & 0x200) > 0))
                        {
                            Point pOCVStart;
                            Point pOCVEnd;
                            ROI objOCVROI = new ROI();
                            // Init blob data
                            m_fAveGrayDiffBlobResult[m_intTemplateIndex] = new float[intNumChars];

                            for (int i = 0; i < intNumChars; i++)
                            {
                                pOCVStart = objOCV.GetCharStartXY(i);
                                pOCVEnd = objOCV.GetCharEndXY(i);
                                objOCVROI.LoadROISetting((int)(objMarkPackageMarkROI.ref_ROIPositionX + pOCVStart.X), (int)(objMarkPackageMarkROI.ref_ROIPositionY + pOCVStart.Y), (int)(pOCVEnd.X - pOCVStart.X), (int)(pOCVEnd.Y - pOCVStart.Y));
                                objOCVROI.AttachImage(objMarkOcvSearchROI);
                                //objOCVROI.SaveImage("D:\\TS\\objOCVROI" + i + ".bmp");

                                //ImageDrawing objThresholdImage = new ImageDrawing(true, objOCVROI.ref_ROIWidth, objOCVROI.ref_ROIHeight);
                                //ROI objThresholdROI = new ROI();
                                //objThresholdROI.AttachImage(objThresholdImage);
                                //objThresholdROI.LoadROISetting(0, 0, objOCVROI.ref_ROIWidth, objOCVROI.ref_ROIHeight);
                                //float fAverageGrayValue = 0;
                                //EasyImage.PixelAverage(objOCVROI.ref_ROI, out fAverageGrayValue);
                                //EasyImage.Threshold(objOCVROI.ref_ROI, objThresholdROI.ref_ROI, (uint)Math.Round(fAverageGrayValue));
                                ////objThresholdROI.SaveImage("D:\\TS\\objThresholdROI" + i + ".bmp");
                                //EasyImage.PixelAverage(objOCVROI.ref_ROI, objThresholdROI.ref_ROI, out fAverageGrayValue);

                                //objThresholdImage.Dispose();
                                //objThresholdROI.Dispose();

                                //m_fAveGrayDiffBlobResult[m_intTemplateIndex][i] = Math.Abs((float)Math.Round(fAverageGrayValue, 2) - m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fAverageGray[i]);

                                if (m_objAveGrayBlobs[m_intTemplateIndex].BuildObjects_Filter_GetElement(objOCVROI, !m_blnWhiteOnBlack, false, 0, intThresholdValue, 0, objOCVROI.ref_ROIWidth * objOCVROI.ref_ROIHeight + 1, false, 0x800) > 0)
                                {
                                    //m_fAveGrayDiffBlobResult[m_intTemplateIndex][i] = Math.Abs((float)Math.Round(m_objAveGrayBlobs[m_intTemplateIndex].ref_arrAverageGray[0], 2) - m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fAverageGray[i]);
                                    if ((float)Math.Round(m_objAveGrayBlobs[m_intTemplateIndex].ref_arrAverageGray[0], 2) < m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fAverageGray[i])
                                        m_fAveGrayDiffBlobResult[m_intTemplateIndex][i] = Math.Abs((float)Math.Round(m_objAveGrayBlobs[m_intTemplateIndex].ref_arrAverageGray[0], 2) - m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fAverageGray[i]);
                                    else
                                        m_fAveGrayDiffBlobResult[m_intTemplateIndex][i] = 0;
                                }
                                else
                                    m_fAveGrayDiffBlobResult[m_intTemplateIndex][i] = -999;

                                // Fail if AGV Percent lower than setting
                                if (m_fAveGrayDiffBlobResult[m_intTemplateIndex][i] != -999 && (m_fAveGrayDiffBlobResult[m_intTemplateIndex][i] > m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fMaxAGVPercent[i]) && m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i])
                                {
                                    arrCharFailOtherThanScore[i] = true;
                                    if (m_blnCharResult[m_intTemplateIndex][i])
                                        m_blnCharResult[m_intTemplateIndex][i] = false;
                                    if ((m_intFailResultMask & 0x4000) == 0)
                                        m_intFailResultMask |= 0x4000;

                                    if (blnTestHandMade)
                                    {
                                        if ((m_intFailResultMask_ForPreTest & 0x4000) == 0)
                                            m_intFailResultMask_ForPreTest |= 0x4000;
                                    }


                                }
                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 18");
                            }
                            objOCVROI.Dispose();
                        }
                        #region ----------------------------- Check Text Shifted ------------------------------------------------------------
                        if (!blnSkipExtraPadAndTextShiftedChecking && ((intFailOptionMask & 0x40) > 0))      // Want Gauge
                        {
                            if (!CheckTextShifted(0, 0, objMarkPackageMarkROI.ref_ROIWidth, objMarkPackageMarkROI.ref_ROIHeight))
                            {
                                m_intFailResultMask |= 0x40;

                                if (blnTestHandMade)
                                {
                                    if ((m_intFailResultMask_ForPreTest & 0x40) == 0)
                                        m_intFailResultMask_ForPreTest |= 0x40;
                                }

                            }
                        }
                        #endregion ---------------------------------------------------------------------------------------------------------
                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 20");

                        // Subtract dont care area according to template (Each template has own dont care setting)
                        if (m_blnWantDontCareArea)
                        {
                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 21");
                            //m_objDontCareBackupImage.CopyTo(ref objImage);
                            objMarkPackageSearchROI.AttachImage(m_objDontCareBackupImage);//objImage

                            ROI objDontCareROI = new ROI();
                            //objDontCareROI.LoadROISetting(0, 0, objMarkPackageMarkROI.ref_ROIWidth, objMarkPackageMarkROI.ref_ROIHeight);
                            //objDontCareROI.AttachImage(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].objDontCareImage);
                            ////2020-06-17 ZJYEOH : Subtract or Add depends on white on black or black on white
                            //if (m_blnWhiteOnBlack)
                            //    ROI.SubtractROI(objMarkPackageMarkROI, objDontCareROI);
                            //else
                            //    ROI.LogicOperationAddROI(objMarkPackageMarkROI, objDontCareROI);
                            ROI objOriROI = new ROI();
                            for (int i = 0; i < arrMarkDontCareROI.Count; i++)
                            {
                                objOriROI.AttachImage(m_objDontCareBackupImage);//objImage

                                objDontCareROI.AttachImage(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrDontCareImage[i]);// objWhiteImage

                                objOriROI.LoadROISetting(objMarkPackageMarkROI.ref_ROITotalCenterX - arrMarkDontCareROI[i].ref_intStartOffsetX,
                                                         objMarkPackageMarkROI.ref_ROITotalCenterY - arrMarkDontCareROI[i].ref_intStartOffsetY,
                                                         arrMarkDontCareROI[i].ref_ROIWidth, arrMarkDontCareROI[i].ref_ROIHeight);

                                objDontCareROI.LoadROISetting(objMarkPackageMarkROI.ref_ROITotalCenterX - arrMarkDontCareROI[i].ref_intStartOffsetX,
                                                              objMarkPackageMarkROI.ref_ROITotalCenterY - arrMarkDontCareROI[i].ref_intStartOffsetY,
                                                              arrMarkDontCareROI[i].ref_ROIWidth, arrMarkDontCareROI[i].ref_ROIHeight);

                                if (m_blnWhiteOnBlack)
                                    ROI.SubtractROI(objOriROI, objDontCareROI);
                                else
                                    ROI.LogicOperationAddROI(objOriROI, objDontCareROI);
                                //m_objDontCareBackupImage.SaveImage("D:\\m_objDontCareBackupImage.bmp");
                                //objMarkPackageMarkROI.SaveImage("D:\\objMarkPackageMarkROI" + i.ToString() + ".bmp");
                            }
                            objOriROI.Dispose();
                            objDontCareROI.Dispose();

                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 22");

                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 23");
                            // Define build blob ROI
                            if (blnSkipExtraPadAndTextShiftedChecking) // No Gauge
                                DefineBuildBlobROI_SaveTime(m_objDontCareBackupImage, objMarkPackageMarkROI, true);//objImage
                            else
                                DefineBuildBlobROI_SaveTime(m_objDontCareBackupImage, objMarkPackageMarkROI, (intFailOptionMask & 0x04) > 0);//objImage

                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 24");

                        }
                        else
                        {

                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 23");
                            // Define build blob ROI
                            if (blnSkipExtraPadAndTextShiftedChecking) // No Gauge
                                DefineBuildBlobROI_SaveTime(objImage, objMarkPackageMarkROI, true);
                            else
                                DefineBuildBlobROI_SaveTime(objImage, objMarkPackageMarkROI, (intFailOptionMask & 0x04) > 0);

                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 24");

                        }
                        // Get off set ROI for blob-OCV matching and drawing purpose 
                        m_intROIOffSetX = objMarkPackageMarkROI.ref_ROI.TotalOrgX;
                        m_intROIOffSetY = objMarkPackageMarkROI.ref_ROI.TotalOrgY;
                        m_intBlobOCVOffSetX = m_objBuildObjectROI.ref_ROIPositionX - m_intROIOffSetX;
                        m_intBlobOCVOffSetY = m_objBuildObjectROI.ref_ROIPositionY - m_intROIOffSetY;

                        ImageDrawing objImage_Temp = new ImageDrawing(true, objImage.ref_intImageWidth, objImage.ref_intImageHeight);
                        if (m_intExtraExcessMarkInspectionAreaCutMode == 1)
                        {
                            if (m_blnWantDontCareArea)
                                m_objDontCareBackupImage.CopyTo(ref objImage_Temp);
                            else
                                objOcvRotatedImage.CopyTo(ref objImage_Temp);//objImage
                            m_objBuildObjectROI.AttachImage(objImage_Temp);
                            ROI objLineROI1 = new ROI();
                            ROI objLineROI2 = new ROI();
                            ROI objTempROI = new ROI();
                            ImageDrawing objImage_Temp2 = new ImageDrawing(true, objImage_Temp.ref_intImageWidth, objImage_Temp.ref_intImageHeight);
                            objLineROI1.AttachImage(objImage_Temp);
                            //objLineROI2.AttachImage(objWhiteImage);
                            objTempROI.AttachImage(objImage_Temp2);
                            for (int i = 0; i < intNumChars; i++)
                            {
                                Point pStart = objOCV.GetCharStartXY(i);
                                Point pEnd = objOCV.GetCharEndXY(i);

                                ////pStart = new Point(pStart.X - m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharShiftX[i], pStart.Y - m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharShiftY[i]);
                                ////pEnd = new Point(pEnd.X + m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharShiftX[i], pEnd.Y + m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharShiftY[i]);

                                //int intOCVWidth = pEnd.X - pStart.X;
                                //int intOCVHeight = pEnd.Y - pStart.Y;

                                //// Top Line
                                //objLineROI1.LoadROISetting(m_intROIOffSetX + pStart.X, m_intROIOffSetY + pStart.Y, intOCVWidth, 1);
                                //objLineROI2.LoadROISetting(m_intROIOffSetX + pStart.X, m_intROIOffSetY + pStart.Y, intOCVWidth, 1);
                                //if (m_blnWhiteOnBlack)
                                //    ROI.SubtractROI(objLineROI1, objLineROI2);
                                //else
                                //    ROI.LogicOperationAddROI(objLineROI1, objLineROI2);

                                //// Right Line
                                //objLineROI1.LoadROISetting(m_intROIOffSetX + pStart.X + intOCVWidth - 1, m_intROIOffSetY + pStart.Y, 1, intOCVHeight);
                                //objLineROI2.LoadROISetting(m_intROIOffSetX + pStart.X + intOCVWidth - 1, m_intROIOffSetY + pStart.Y, 1, intOCVHeight);
                                //if (m_blnWhiteOnBlack)
                                //    ROI.SubtractROI(objLineROI1, objLineROI2);
                                //else
                                //    ROI.LogicOperationAddROI(objLineROI1, objLineROI2);

                                //// Bottom Line
                                //objLineROI1.LoadROISetting(m_intROIOffSetX + pStart.X, m_intROIOffSetY + pStart.Y + intOCVHeight - 1, intOCVWidth, 1);
                                //objLineROI2.LoadROISetting(m_intROIOffSetX + pStart.X, m_intROIOffSetY + pStart.Y + intOCVHeight - 1, intOCVWidth, 1);
                                //if (m_blnWhiteOnBlack)
                                //    ROI.SubtractROI(objLineROI1, objLineROI2);
                                //else
                                //    ROI.LogicOperationAddROI(objLineROI1, objLineROI2);

                                //// Left Line
                                //objLineROI1.LoadROISetting(m_intROIOffSetX + pStart.X, m_intROIOffSetY + pStart.Y, 1, intOCVHeight);
                                //objLineROI2.LoadROISetting(m_intROIOffSetX + pStart.X, m_intROIOffSetY + pStart.Y, 1, intOCVHeight);
                                //if (m_blnWhiteOnBlack)
                                //    ROI.SubtractROI(objLineROI1, objLineROI2);
                                //else
                                //    ROI.LogicOperationAddROI(objLineROI1, objLineROI2);

                                pStart = new Point(m_intROIOffSetX + pStart.X, m_intROIOffSetY + pStart.Y);
                                pEnd = new Point(m_intROIOffSetX + pEnd.X, m_intROIOffSetY + pEnd.Y);

                                List<PointF> arrPoints = new List<PointF>();
                                arrPoints.Add(pStart);
                                arrPoints.Add(new Point(pStart.X + (pEnd.X - pStart.X), pStart.Y));
                                arrPoints.Add(new Point(pStart.X, pStart.Y + (pEnd.Y - pStart.Y)));
                                arrPoints.Add(pEnd);

                                //PointF pTemp = new PointF();
                                //Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
                                //                                 arrPoints[0],
                                //                                 (/*intOrientationAngle +*/ fMarkAngle),
                                //                                 ref pTemp);
                                //arrPoints[0] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

                                //Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
                                //                                 arrPoints[1],
                                //                                 (/*intOrientationAngle +*/ fMarkAngle),
                                //                                 ref pTemp);
                                //arrPoints[1] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

                                //Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
                                //                                 arrPoints[2],
                                //                                 (/*intOrientationAngle +*/ fMarkAngle),
                                //                                 ref pTemp);
                                //arrPoints[2] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

                                //Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
                                //                                 arrPoints[3],
                                //                                 (/*intOrientationAngle +*/ fMarkAngle),
                                //                                 ref pTemp);
                                //arrPoints[3] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

                                float fMinX = float.MaxValue;
                                float fMinY = float.MaxValue;
                                float fMaxX = 0;
                                float fMaxY = 0;
                                for (int a = 0; a < arrPoints.Count; a++)
                                {
                                    if (fMinX > arrPoints[a].X)
                                        fMinX = arrPoints[a].X;

                                    if (fMinY > arrPoints[a].Y)
                                        fMinY = arrPoints[a].Y;

                                    if (fMaxX < arrPoints[a].X)
                                        fMaxX = arrPoints[a].X;

                                    if (fMaxY < arrPoints[a].Y)
                                        fMaxY = arrPoints[a].Y;
                                }

                                objLineROI1.LoadROISetting((int)Math.Round(fMinX), (int)Math.Round(fMinY),
                                   (int)Math.Round(fMaxX - fMinX), (int)Math.Round(fMaxY - fMinY));

                                objLineROI2.LoadROISetting((int)Math.Round(fMinX), (int)Math.Round(fMinY),
                                   (int)Math.Round(fMaxX - fMinX), (int)Math.Round(fMaxY - fMinY));

                                objTempROI.LoadROISetting((int)Math.Round(fMinX), (int)Math.Round(fMinY),
                                   (int)Math.Round(fMaxX - fMinX), (int)Math.Round(fMaxY - fMinY));

                                ////objLineROI2.AttachImage(objBlackImage);
                                ////objLineROI2.CopyImage(ref objTempROI);

                                ////objLineROI2.LoadROISetting(pStart.X, pStart.Y,
                                ////   pEnd.X - pStart.X, pEnd.Y - pStart.Y);

                                ////objTempROI.LoadROISetting(pStart.X, pStart.Y,
                                ////   pEnd.X - pStart.X, pEnd.Y - pStart.Y);

                                objLineROI2.AttachImage(objWhiteImage);
                                objLineROI2.CopyImage(ref objTempROI);
                                //ROI.Rotate0Degree_ForDontCare(objLineROI2, -(intOrientationAngle + fMarkAngle), 4, objTempROI);

                                ////objLineROI2.LoadROISetting((int)Math.Round(fMinX), (int)Math.Round(fMinY),
                                ////   (int)Math.Round(fMaxX - fMinX), (int)Math.Round(fMaxY - fMinY));

                                ////objTempROI.LoadROISetting((int)Math.Round(fMinX), (int)Math.Round(fMinY),
                                ////   (int)Math.Round(fMaxX - fMinX), (int)Math.Round(fMaxY - fMinY));

                                //if (blnWantDebug)
                                //{
                                //    objLineROI1.SaveImage("D:\\TS\\objLineROIBefore" + i + ".bmp");
                                //}

                                if (m_blnWhiteOnBlack)
                                {
                                    DontCareWithoutRotateImage.ProduceImage_WithoutLoopMaxPoints(arrPoints, objTempROI, objImage_Temp2
                                    , objBlackWhiteTopImage, objBlackWhiteRightImage, objBlackWhiteBottomImage, objBlackWhiteLeftImage, false);
                                }
                                else
                                {
                                    DontCareWithoutRotateImage.ProduceImage_WithoutLoopMaxPoints(arrPoints, objTempROI, objImage_Temp2
                                    , objBlackWhiteTopImage, objBlackWhiteRightImage, objBlackWhiteBottomImage, objBlackWhiteLeftImage, true);
                                }

                                if (m_blnWhiteOnBlack)
                                    EasyImage.Oper(EArithmeticLogicOperation.Subtract, objLineROI1.ref_ROI, objTempROI.ref_ROI, objLineROI1.ref_ROI);
                                else
                                    EasyImage.Oper(EArithmeticLogicOperation.Add, objLineROI1.ref_ROI, objTempROI.ref_ROI, objLineROI1.ref_ROI);

                                if (blnWantDebug)
                                {
                                    objImage_Temp.SaveImage("D:\\TS\\objImage_Temp" + i + ".bmp");
                                    objTempROI.SaveImage("D:\\TS\\objTempROI" + i + ".bmp");
                                    objLineROI1.SaveImage("D:\\TS\\objLineROI" + i + ".bmp");
                                }
                            }
                            objTempROI.Dispose();
                            objLineROI1.Dispose();
                            objLineROI2.Dispose();
                            objImage_Temp2.Dispose();
                        }
                        else if (m_intExtraExcessMarkInspectionAreaCutMode == 2)
                        {
                            if (m_blnWantDontCareArea)
                                m_objDontCareBackupImage.CopyTo(ref objImage_Temp);
                            else
                                objOcvRotatedImage.CopyTo(ref objImage_Temp);//objImage
                            m_objBuildObjectROI.AttachImage(objImage_Temp);
                            ROI objLineROI1 = new ROI();
                            ROI objLineROI2 = new ROI();
                            ROI objTempROI = new ROI();
                            ImageDrawing objImage_Temp2 = new ImageDrawing(true, objImage_Temp.ref_intImageWidth, objImage_Temp.ref_intImageHeight);
                            objLineROI1.AttachImage(objImage_Temp);
                            //objLineROI2.AttachImage(objWhiteImage);
                            objTempROI.AttachImage(objImage_Temp2);
                            for (int i = 0; i < intNumChars; i++)
                            {
                                Point pStart = objOCV.GetCharStartXY(i);
                                Point pEnd = objOCV.GetCharEndXY(i);

                                pStart = new Point(pStart.X - ((int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftX[i] + m_fCharROIOffsetX)),
                                                   pStart.Y - ((int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftY[i] + m_fCharROIOffsetY)));
                                pEnd = new Point(pEnd.X + ((int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftX[i] + m_fCharROIOffsetX)),
                                                 pEnd.Y + ((int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftY[i] + m_fCharROIOffsetY)));

                                //int intOCVWidth = pEnd.X - pStart.X;
                                //int intOCVHeight = pEnd.Y - pStart.Y;

                                //// Top Line
                                //objLineROI1.LoadROISetting(m_intROIOffSetX + pStart.X, m_intROIOffSetY + pStart.Y, intOCVWidth, 1);
                                //objLineROI2.LoadROISetting(m_intROIOffSetX + pStart.X, m_intROIOffSetY + pStart.Y, intOCVWidth, 1);
                                //if (m_blnWhiteOnBlack)
                                //    ROI.SubtractROI(objLineROI1, objLineROI2);
                                //else
                                //    ROI.LogicOperationAddROI(objLineROI1, objLineROI2);

                                //// Right Line
                                //objLineROI1.LoadROISetting(m_intROIOffSetX + pStart.X + intOCVWidth - 1, m_intROIOffSetY + pStart.Y, 1, intOCVHeight);
                                //objLineROI2.LoadROISetting(m_intROIOffSetX + pStart.X + intOCVWidth - 1, m_intROIOffSetY + pStart.Y, 1, intOCVHeight);
                                //if (m_blnWhiteOnBlack)
                                //    ROI.SubtractROI(objLineROI1, objLineROI2);
                                //else
                                //    ROI.LogicOperationAddROI(objLineROI1, objLineROI2);

                                //// Bottom Line
                                //objLineROI1.LoadROISetting(m_intROIOffSetX + pStart.X, m_intROIOffSetY + pStart.Y + intOCVHeight - 1, intOCVWidth, 1);
                                //objLineROI2.LoadROISetting(m_intROIOffSetX + pStart.X, m_intROIOffSetY + pStart.Y + intOCVHeight - 1, intOCVWidth, 1);
                                //if (m_blnWhiteOnBlack)
                                //    ROI.SubtractROI(objLineROI1, objLineROI2);
                                //else
                                //    ROI.LogicOperationAddROI(objLineROI1, objLineROI2);

                                //// Left Line
                                //objLineROI1.LoadROISetting(m_intROIOffSetX + pStart.X, m_intROIOffSetY + pStart.Y, 1, intOCVHeight);
                                //objLineROI2.LoadROISetting(m_intROIOffSetX + pStart.X, m_intROIOffSetY + pStart.Y, 1, intOCVHeight);
                                //if (m_blnWhiteOnBlack)
                                //    ROI.SubtractROI(objLineROI1, objLineROI2);
                                //else
                                //    ROI.LogicOperationAddROI(objLineROI1, objLineROI2);

                                pStart = new Point(m_intROIOffSetX + pStart.X, m_intROIOffSetY + pStart.Y);
                                pEnd = new Point(m_intROIOffSetX + pEnd.X, m_intROIOffSetY + pEnd.Y);

                                List<PointF> arrPoints = new List<PointF>();
                                arrPoints.Add(pStart);
                                arrPoints.Add(new Point(pStart.X + (pEnd.X - pStart.X), pStart.Y));
                                arrPoints.Add(new Point(pStart.X, pStart.Y + (pEnd.Y - pStart.Y)));
                                arrPoints.Add(pEnd);

                                //PointF pTemp = new PointF();
                                //Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
                                //                                 arrPoints[0],
                                //                                 (/*intOrientationAngle +*/ fMarkAngle),
                                //                                 ref pTemp);
                                //arrPoints[0] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

                                //Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
                                //                                 arrPoints[1],
                                //                                 (/*intOrientationAngle +*/ fMarkAngle),
                                //                                 ref pTemp);
                                //arrPoints[1] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

                                //Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
                                //                                 arrPoints[2],
                                //                                 (/*intOrientationAngle +*/ fMarkAngle),
                                //                                 ref pTemp);
                                //arrPoints[2] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

                                //Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
                                //                                 arrPoints[3],
                                //                                 (/*intOrientationAngle +*/ fMarkAngle),
                                //                                 ref pTemp);
                                //arrPoints[3] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

                                float fMinX = float.MaxValue;
                                float fMinY = float.MaxValue;
                                float fMaxX = 0;
                                float fMaxY = 0;
                                for (int a = 0; a < arrPoints.Count; a++)
                                {
                                    if (fMinX > arrPoints[a].X)
                                        fMinX = arrPoints[a].X;

                                    if (fMinY > arrPoints[a].Y)
                                        fMinY = arrPoints[a].Y;

                                    if (fMaxX < arrPoints[a].X)
                                        fMaxX = arrPoints[a].X;

                                    if (fMaxY < arrPoints[a].Y)
                                        fMaxY = arrPoints[a].Y;
                                }

                                objLineROI1.LoadROISetting((int)Math.Round(fMinX), (int)Math.Round(fMinY),
                                   (int)Math.Round(fMaxX - fMinX), (int)Math.Round(fMaxY - fMinY));

                                objLineROI2.LoadROISetting((int)Math.Round(fMinX), (int)Math.Round(fMinY),
                                   (int)Math.Round(fMaxX - fMinX), (int)Math.Round(fMaxY - fMinY));

                                objTempROI.LoadROISetting((int)Math.Round(fMinX), (int)Math.Round(fMinY),
                                   (int)Math.Round(fMaxX - fMinX), (int)Math.Round(fMaxY - fMinY));

                                ////objLineROI2.AttachImage(objBlackImage);
                                ////objLineROI2.CopyImage(ref objTempROI);

                                ////objLineROI2.LoadROISetting(pStart.X, pStart.Y,
                                ////   pEnd.X - pStart.X, pEnd.Y - pStart.Y);

                                ////objTempROI.LoadROISetting(pStart.X, pStart.Y,
                                ////   pEnd.X - pStart.X, pEnd.Y - pStart.Y);

                                objLineROI2.AttachImage(objWhiteImage);
                                objLineROI2.CopyImage(ref objTempROI);
                                //ROI.Rotate0Degree_ForDontCare(objLineROI2, -(intOrientationAngle + fMarkAngle), 4, objTempROI);

                                ////objLineROI2.LoadROISetting((int)Math.Round(fMinX), (int)Math.Round(fMinY),
                                ////   (int)Math.Round(fMaxX - fMinX), (int)Math.Round(fMaxY - fMinY));

                                ////objTempROI.LoadROISetting((int)Math.Round(fMinX), (int)Math.Round(fMinY),
                                ////   (int)Math.Round(fMaxX - fMinX), (int)Math.Round(fMaxY - fMinY));

                                //if (blnWantDebug)
                                //{
                                //    objLineROI1.SaveImage("D:\\TS\\objLineROIBefore" + i + ".bmp");
                                //}

                                if (m_blnWhiteOnBlack)
                                {
                                    DontCareWithoutRotateImage.ProduceImage_WithoutLoopMaxPoints(arrPoints, objTempROI, objImage_Temp2
                                    , objBlackWhiteTopImage, objBlackWhiteRightImage, objBlackWhiteBottomImage, objBlackWhiteLeftImage, false);
                                }
                                else
                                {
                                    DontCareWithoutRotateImage.ProduceImage_WithoutLoopMaxPoints(arrPoints, objTempROI, objImage_Temp2
                                    , objBlackWhiteTopImage, objBlackWhiteRightImage, objBlackWhiteBottomImage, objBlackWhiteLeftImage, true);
                                }

                                if (m_blnWhiteOnBlack)
                                    EasyImage.Oper(EArithmeticLogicOperation.Subtract, objLineROI1.ref_ROI, objTempROI.ref_ROI, objLineROI1.ref_ROI);
                                else
                                    EasyImage.Oper(EArithmeticLogicOperation.Add, objLineROI1.ref_ROI, objTempROI.ref_ROI, objLineROI1.ref_ROI);

                                if (blnWantDebug)
                                {
                                    objImage_Temp.SaveImage("D:\\TS\\objImage_Temp" + i + ".bmp");
                                    objTempROI.SaveImage("D:\\TS\\objTempROI" + i + ".bmp");
                                    objLineROI1.SaveImage("D:\\TS\\objLineROI" + i + ".bmp");
                                }
                            }
                            objTempROI.Dispose();
                            objLineROI1.Dispose();
                            objLineROI2.Dispose();
                            objImage_Temp2.Dispose();
                        }

                        //2021-02-17 ZJYEOH : rotate to let blob build match with package image
                        //if (m_intExtraExcessMarkInspectionAreaCutMode != 0)
                        //{
                        //    //2020-06-23 ZJYEOH : if no check package size, pRotatedCenterPoint will be (-1, -1)
                        //    if (pRotatedCenterPoint != new PointF(-1, -1))
                        //    {
                        //        m_objLocalTemporary_RotateSearchROI.AttachImage(objImage_Temp);
                        //        m_objLocalTemporary_RotateSearchROI.LoadROISetting((int)Math.Round(pRotatedCenterPoint.X - objMarkPackageSearchROI.ref_ROIWidth / 2, 0, MidpointRounding.AwayFromZero),
                        //                                          (int)Math.Round(pRotatedCenterPoint.Y - objMarkPackageSearchROI.ref_ROIHeight / 2, 0, MidpointRounding.AwayFromZero),
                        //                                          objMarkPackageSearchROI.ref_ROIWidth, objMarkPackageSearchROI.ref_ROIHeight);

                        //        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 82");
                        //        ROI.RotateROI(m_objLocalTemporary_RotateSearchROI, fPackageAngle - fMarkAngle, ref objImage_Temp, 4);
                        //    }
                        //}

                        if (blnWantDebug)
                        {
                            m_objBuildObjectROI.SaveImage("D:\\TS\\m_objBuildObjectROI.bmp");
                            m_objBuildObjectROI.ref_ROI.TopParent.Save("D:\\TS\\m_objBuildObjectROI_Parent.bmp");
                        }

                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 25");

                        int intExtraMarkThreshold = intThresholdValue;
                        // 2020-11-03 ZJYEOH: Will Use extra mark threshold if want separate threshold
                        if (m_blnSeparateExtraMarkThreshold)
                            intExtraMarkThreshold = GetAutoThresholdExtraMark(objMarkPackageMarkROI);

                        // 2019 08 30 - CCENG: change Connexity 4 to 8. Connexity 8 will link small items into 1 blobs which will make result more stable.
                        if (!BuildObject(m_objBlobs[m_intTemplateIndex], m_objBuildObjectROI, false, false, intExtraMarkThreshold, 0, m_objBuildObjectROI.ref_ROIWidth * m_objBuildObjectROI.ref_ROIHeight + 1, 0x1F))//1000000
                        {
                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 26");
                            //m_strErrorMessage = "BuildObjects : No blobs object selected!";
                            //m_blnLock = false;
                            //m_blnLockBlobs = false;
                            //return false;
                        }

                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 27");
                        intNoSelectedBlobs = m_objBlobs[m_intTemplateIndex].ref_intNumSelectedObject;
                        //#region ------------- No Mark Inspection --------------------------------------------------------------------------------
                        if (blnWantCheckNoMark && !blnTestHandMade && !ShowLiterationOnly)
                        {
                            m_intTotalBlobArea = 0;
                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 28");
                            ////for (int i = 0; i < intNoSelectedBlobs; i++)
                            //for (int i = 0; i < m_objBlobs[m_intTemplateIndex].ref_arrArea.Count; i++)
                            //{
                            //    m_intTotalBlobArea += m_objBlobs[m_intTemplateIndex].ref_arrArea[i];
                            //}

                            //2021-04-14 ZJYEOH : Use White pixel to find no mark
                            ROI objNoMarkROI = new ROI();
                            objNoMarkROI.AttachImage(objOcvRotatedImage);
                            objNoMarkROI.LoadROISetting(m_objBuildObjectROI.ref_ROIPositionX, m_objBuildObjectROI.ref_ROIPositionY, m_objBuildObjectROI.ref_ROIWidth, m_objBuildObjectROI.ref_ROIHeight);
                            if (m_blnWhiteOnBlack)
                                m_intTotalBlobArea = ROI.GetPixelArea(objNoMarkROI, intThresholdValue, 1);
                            else
                                m_intTotalBlobArea = ROI.GetPixelArea(objNoMarkROI, intThresholdValue, 0);

                            objNoMarkROI.Dispose();

                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 29");

                            if (m_intTotalBlobArea < (int)Math.Round(m_fNoMarkMaximumBlobArea))
                            {
                                if ((m_intFailResultMask & 0x1000) == 0)
                                    m_intFailResultMask |= 0x1000;

                                if (blnTestHandMade)
                                {
                                    if ((m_intFailResultMask_ForPreTest & 0x1000) == 0)
                                        m_intFailResultMask_ForPreTest |= 0x1000;
                                }

                                m_strErrorMessage = "*No Mark! Set = " + GetNoMarkMaximumBlobArea().ToString() + " " + GetDisplayUnitName(m_intDisplayUnitMode, true) + ", " +
                                    "Result = " + GetResultTotalBlobArea().ToString() + " " + GetDisplayUnitName(m_intDisplayUnitMode, true) + ".";

                                objImage_Temp.Dispose();
                                m_blnLock = false;
                                m_blnLockBlobs = false;
                                return false;
                            }
                        }
                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 30");
                        //#endregion ----------------------------------------------------------------------------------------------------------

                        #region ----------------------------- Blobs Inspection ------------------------------------------------------------
                        bool blnGroupExtraMark = false;
                        bool blnGroupExcessMark = false;
                        float fCenterX, fCenterY, fWidth, fHeight, fAngle, fGravityCenterX, fGravityCenterY, fStartX, fStartY, fEndX, fEndY;
                        int intArea = 0, intContourX = 0, intContourY = 0;
                        List<float> arrExcessStartX = new List<float>();
                        List<float> arrExcessStartY = new List<float>();
                        List<float> arrExcessEndX = new List<float>();
                        List<float> arrExcessEndY = new List<float>();
                        List<PointF> arrCharStartPoint_RotateTo0Deg = new List<PointF>();
                        List<PointF> arrCharEndPoint_RotateTo0Deg = new List<PointF>();

                        for (int a = 0; a < intNumChars; a++)
                        {
                            arrExcessStartX.Add(-1);
                            arrExcessStartY.Add(-1);
                            arrExcessEndX.Add(-1);
                            arrExcessEndY.Add(-1);

                            int intStartX, intStartY, intEndX, intEndY;

                            //2021-02-11 ZJYEOH: Collect OCV point with 0 degree for matching index use
                            Point pStart = objOCV.GetCharStartXY(a);
                            Point pEnd = objOCV.GetCharEndXY(a);

                            intStartX = m_intROIOffSetX + pStart.X;
                            intStartY = m_intROIOffSetY + pStart.Y;
                            intEndX = m_intROIOffSetX + pEnd.X;
                            intEndY = m_intROIOffSetY + pEnd.Y;

                            arrCharStartPoint_RotateTo0Deg.Add(new PointF(intStartX, intStartY));
                            arrCharEndPoint_RotateTo0Deg.Add(new PointF(intEndX, intEndY));
                        }

                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 31");
                        // Init blob data
                        m_intBlobResult[m_intTemplateIndex] = new int[intNoSelectedBlobs];
                        for (j = 0; j < intNoSelectedBlobs; j++)
                        {
                            m_intBlobResult[m_intTemplateIndex][j] = 0;
                        }

                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 32");
                        fCenterX = fCenterY = fWidth = fHeight = fAngle = fGravityCenterX = fGravityCenterY = 0;
                        if ((intFailOptionMask & 0x80) > 0)
                        {
                            if (m_arrCharJointMarkResult[m_intTemplateIndex] == null)
                                m_arrCharJointMarkResult[m_intTemplateIndex] = new bool[intNumChars];

                            if (m_arrCharJointMarkResult[m_intTemplateIndex].Length != intNumChars)
                                m_arrCharJointMarkResult[m_intTemplateIndex] = new bool[intNumChars];

                            for (int a = 0; a < intNumChars; a++)
                            {
                                m_arrCharJointMarkResult[m_intTemplateIndex][a] = true;
                            }

                            if (m_intExtraExcessMarkInspectionAreaCutMode == 0)
                            {
                                for (int i = 0; i < intNoSelectedBlobs; i++)
                                {
                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 33");
                                    fCenterX = m_objBlobs[m_intTemplateIndex].ref_arrLimitCenterX[i];
                                    fCenterY = m_objBlobs[m_intTemplateIndex].ref_arrLimitCenterY[i];
                                    fWidth = m_objBlobs[m_intTemplateIndex].ref_arrWidth[i];
                                    fHeight = m_objBlobs[m_intTemplateIndex].ref_arrHeight[i];
                                    fGravityCenterX = m_objBlobs[m_intTemplateIndex].ref_arrGravityCenterX[i];
                                    fGravityCenterY = m_objBlobs[m_intTemplateIndex].ref_arrGravityCenterY[i];
                                    intArea = m_objBlobs[m_intTemplateIndex].ref_arrArea[i];
                                    intContourX = m_objBlobs[m_intTemplateIndex].ref_arrContourX[i];
                                    intContourY = m_objBlobs[m_intTemplateIndex].ref_arrContourY[i];

                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 34");
                                    // Use m_intMinArea as min area if m_intMinArea < 5, else use 5 as min area
                                    if (m_intMinArea < 5)
                                    {
                                        // skip checking if blob area lower than setting
                                        if (intArea <= m_intMinArea)
                                        {
                                            continue;
                                        }
                                    }
                                    else
                                    {
                                        // skip checking if blob area lower than setting
                                        if (intArea <= 5)
                                        {
                                            continue;
                                        }
                                    }

                                    float fRotateCenterX = fCenterX;
                                    float fRotateCenterY = fCenterY;
                                    //float fRotateRefCenterX = pRotatedCenterPoint.X - m_objBuildObjectROI.ref_ROITotalX;
                                    //float fRotateRefCenterY = pRotatedCenterPoint.Y - m_objBuildObjectROI.ref_ROITotalY;

                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 35");

                                    //2020-06-23 ZJYEOH : if no check package size, pRotatedCenterPoint will be (-1, -1)
                                    if (pRotatedCenterPoint != new PointF(-1, -1))
                                    {
                                        Math2.GetNewXYAfterRotate_360deg((float)m_objBuildObjectROI.ref_ROIWidth / 2, (float)m_objBuildObjectROI.ref_ROIHeight / 2,
                                                                    fCenterX, fCenterY,
                                                                    fPackageAngle - fMarkAngle,
                                                                    ref fRotateCenterX, ref fRotateCenterY);
                                    }

                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 36");

                                    // Get blob start point and end point
                                    fStartX = fRotateCenterX - fWidth / 2 + m_intBlobOCVOffSetX;
                                    fStartY = fRotateCenterY - fHeight / 2 + m_intBlobOCVOffSetY;
                                    fEndX = fRotateCenterX + fWidth / 2 + m_intBlobOCVOffSetX;
                                    fEndY = fRotateCenterY + fHeight / 2 + m_intBlobOCVOffSetY;

                                    // 2020 11 03 - CCENG: igore those blob object on Lead Area.
                                    if (arrDontCareLeadAreaStartX.Count > 0)
                                    {
                                        if (IsInDontCareLeadArea(arrDontCareLeadAreaStartX, arrDontCareLeadAreaStartY, arrDontCareLeadAreaEndX, arrDontCareLeadAreaEndY, arrDontCareLeadDirection,
                                            m_objBuildObjectROI.ref_ROITotalX + (fEndX + fStartX) / 2, m_objBuildObjectROI.ref_ROITotalY + (fEndY + fStartY) / 2))
                                            continue;

                                    }

                                    //2021-01-19 ZJYEOH : Matching area added shift tolerance so that extra mark inside char area will not consider as extra mark
                                    //bool blnContourCheck = false;
                                    List<int> intMatchNumber = new List<int>();
                                    if (m_intExtraExcessMarkInspectionAreaCutMode == 0)
                                    {
                                        intMatchNumber = objOCV.GetMatchCharIndexes(fStartX, fStartY, fEndX, fEndY,
                                                                                    fRotateCenterX + m_intBlobOCVOffSetX, fRotateCenterY + m_intBlobOCVOffSetY, fWidth, fHeight, ref blnContourCheck, 
                                                                                    m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftX, m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftY,
                                                                                    m_fCharROIOffsetX, m_fCharROIOffsetY, true);
                                    }
                                    
                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 37");
                                    // By using contour, double check again the selected OCV Char rectangle box is/are really matched by blobs
                                    if (blnContourCheck && intMatchNumber.Count > 0)
                                    {
                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 38");
                                        for (int e = 0; e < intMatchNumber.Count; e++)
                                        {
                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 39");
                                            // Build contour elements for the selected blob
                                            Contour objContour = new Contour();
                                            objContour.ClearContour();
                                            if (objContour.BuildContour(m_objBuildObjectROI, intContourX, intContourY, intExtraMarkThreshold, 8))//intThresholdValue, 4 //2021-02-10 ZJYEOH : Use connexity 8 because blob is built using connexity 8
                                            {
                                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 40");
                                                // Check is the blob in OCV Char rectangle box
                                                if (!objOCV.IsInOcvCharArea(objContour, intMatchNumber[e], m_intBlobOCVOffSetX, m_intBlobOCVOffSetY))
                                                {
                                                    intMatchNumber.RemoveAt(e);
                                                    e--;
                                                }

                                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 41");
                                            }
                                        }
                                    }

                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 42");

                                    if (intMatchNumber.Count > 1)
                                    {
                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 56");
                                        // Make sure area >= min area
                                        if (intArea < m_intMinArea)
                                        {
                                            continue;
                                        }

                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 57");
                                        //// Set char hit by blob counter
                                        //for (j = 0; j < intMatchNumber.Count; j++)
                                        //{
                                        //    m_intHitCharCounter[intMatchNumber[j]]++;
                                        //}

                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 59");
                                        // Check joint mark (1 blob match to more than 1 char)
                                        //if (intMatchNumber.Count > 1)
                                        {
                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 60");
                                            //if ((intFailOptionMask & 0x80) > 0)
                                            //{
                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 61");
                                            int intDisabledMarkCounter = 0;
                                            int intEnabledMarkCounter = 0;
                                            for (int q = 0; q < intMatchNumber.Count; q++)
                                            {
                                                if (!m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[intMatchNumber[q]])
                                                    intDisabledMarkCounter++;
                                                else
                                                    intEnabledMarkCounter++;
                                            }

                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 63");

                                            if (intDisabledMarkCounter > 1 && intEnabledMarkCounter < intDisabledMarkCounter || intEnabledMarkCounter <= 1)
                                                goto Skip;

                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 64");
                                            m_intBlobResult[m_intTemplateIndex][i] = 2;

                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 65");

                                            for (int q = 0; q < intMatchNumber.Count; q++)
                                            {
                                                // 2021 11 28 - CCENG:  arrCharFailOtherThanSco index is from intNumChar, 
                                                //                      but this i value is not from inNumChar anymore, 
                                                //                      this i from m_objJointMarkROI object during build blob,
                                                //                      so need to use intMatchNumber[q] which has number char value.
                                                arrCharFailOtherThanScore[intMatchNumber[q]] = true; //arrCharFailOtherThanScore[i] = true; 
                                                m_blnCharResult[m_intTemplateIndex][intMatchNumber[q]] = false;

                                                if (m_arrCharJointMarkResult[m_intTemplateIndex][intMatchNumber[q]])
                                                    m_arrCharJointMarkResult[m_intTemplateIndex][intMatchNumber[q]] = false;
                                            }

                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 66");
                                            if ((m_intFailResultMask & 0x80) == 0)
                                                m_intFailResultMask |= 0x80;
                                            if (blnTestHandMade)
                                            {
                                                if ((m_intFailResultMask_ForPreTest & 0x80) == 0)
                                                    m_intFailResultMask_ForPreTest |= 0x80;
                                            }

                                            //}

                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 67");
                                            Skip: { }

                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 68");
                                        }
                                    }
                                }
                            }
                            else
                            {
                                if (blnWantDebug)
                                {
                                    m_objJointMarkROI.SaveImage("D:\\TS\\m_objJointMarkROI.bmp");
                                    m_objJointMarkROI.ref_ROI.TopParent.Save("D:\\TS\\m_objJointMarkROI_Parent.bmp");
                                }

                                // 2019 08 30 - CCENG: change Connexity 4 to 8. Connexity 8 will link small items into 1 blobs which will make result more stable.
                                if (!BuildObject(m_objJointMarkBlobs[m_intTemplateIndex], m_objJointMarkROI, false, false, intExtraMarkThreshold, 0, 1000000, 0x1F))
                                {
                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 26");
                                    //m_strErrorMessage = "BuildObjects : No blobs object selected!";
                                    //m_blnLock = false;
                                    //m_blnLockBlobs = false;
                                    //return false;
                                }

                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 27");

                                if (m_intExtraExcessMarkInspectionAreaCutMode != 0)
                                {
                                    m_intJointMarkBlobResult[m_intTemplateIndex] = new int[m_objJointMarkBlobs[m_intTemplateIndex].ref_intNumSelectedObject];
                                    for (j = 0; j < m_objJointMarkBlobs[m_intTemplateIndex].ref_intNumSelectedObject; j++)
                                    {
                                        m_intJointMarkBlobResult[m_intTemplateIndex][j] = 0;
                                    }

                                }

                                for (int i = 0; i < m_objJointMarkBlobs[m_intTemplateIndex].ref_intNumSelectedObject; i++)
                                {
                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 33");
                                    fCenterX = m_objJointMarkBlobs[m_intTemplateIndex].ref_arrLimitCenterX[i];
                                    fCenterY = m_objJointMarkBlobs[m_intTemplateIndex].ref_arrLimitCenterY[i];
                                    fWidth = m_objJointMarkBlobs[m_intTemplateIndex].ref_arrWidth[i];
                                    fHeight = m_objJointMarkBlobs[m_intTemplateIndex].ref_arrHeight[i];
                                    fGravityCenterX = m_objJointMarkBlobs[m_intTemplateIndex].ref_arrGravityCenterX[i];
                                    fGravityCenterY = m_objJointMarkBlobs[m_intTemplateIndex].ref_arrGravityCenterY[i];
                                    intArea = m_objJointMarkBlobs[m_intTemplateIndex].ref_arrArea[i];
                                    intContourX = m_objJointMarkBlobs[m_intTemplateIndex].ref_arrContourX[i];
                                    intContourY = m_objJointMarkBlobs[m_intTemplateIndex].ref_arrContourY[i];
                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 34");
                                    // Use m_intMinArea as min area if m_intMinArea < 5, else use 5 as min area
                                    if (m_intMinArea < 5)
                                    {
                                        // skip checking if blob area lower than setting
                                        if (intArea <= m_intMinArea)
                                        {
                                            continue;
                                        }
                                    }
                                    else
                                    {
                                        // skip checking if blob area lower than setting
                                        if (intArea <= 5)
                                        {
                                            continue;
                                        }
                                    }

                                    float fRotateCenterX = fCenterX;
                                    float fRotateCenterY = fCenterY;
                                    //float fRotateRefCenterX = pRotatedCenterPoint.X - m_objBuildObjectROI.ref_ROITotalX;
                                    //float fRotateRefCenterY = pRotatedCenterPoint.Y - m_objBuildObjectROI.ref_ROITotalY;

                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 35");

                                    //2020-06-23 ZJYEOH : if no check package size, pRotatedCenterPoint will be (-1, -1)
                                    if (pRotatedCenterPoint != new PointF(-1, -1))
                                    {
                                        Math2.GetNewXYAfterRotate_360deg((float)m_objJointMarkROI.ref_ROIWidth / 2, (float)m_objJointMarkROI.ref_ROIHeight / 2,
                                                                    fCenterX, fCenterY,
                                                                    fPackageAngle - fMarkAngle,
                                                                    ref fRotateCenterX, ref fRotateCenterY);
                                    }

                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 36");

                                    // Get blob start point and end point
                                    fStartX = fRotateCenterX - fWidth / 2 + m_intBlobOCVOffSetX;
                                    fStartY = fRotateCenterY - fHeight / 2 + m_intBlobOCVOffSetY;
                                    fEndX = fRotateCenterX + fWidth / 2 + m_intBlobOCVOffSetX;
                                    fEndY = fRotateCenterY + fHeight / 2 + m_intBlobOCVOffSetY;

                                    //2021-01-19 ZJYEOH : Matching area added shift tolerance so that extra mark inside char area will not consider as extra mark
                                    //bool blnContourCheck = false;
                                    List<int> intMatchNumber = new List<int>();
                                    //if (m_intExtraExcessMarkInspectionAreaCutMode == 0)
                                    {
                                        intMatchNumber = objOCV.GetMatchCharIndexes(fStartX, fStartY, fEndX, fEndY,
                                                                                                  fRotateCenterX + m_intBlobOCVOffSetX, fRotateCenterY + m_intBlobOCVOffSetY,
                                                                                                  fWidth, fHeight, ref blnContourCheck
                                                                                                  , m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftX,
                                                                                                  m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftY,
                                                                                                  m_fCharROIOffsetX, m_fCharROIOffsetY
                                                                                                  , true);
                                    }

                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 37");
                                    // By using contour, double check again the selected OCV Char rectangle box is/are really matched by blobs
                                    if (blnContourCheck && intMatchNumber.Count > 0)
                                    {
                                     
                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 38");
                                        for (int e = 0; e < intMatchNumber.Count; e++)
                                        {
                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 39");
                                            // Build contour elements for the selected blob
                                            Contour objContour = new Contour();
                                            objContour.ClearContour();
                                            if (objContour.BuildContour(m_objJointMarkROI, intContourX, intContourY, intExtraMarkThreshold, 8))//intThresholdValue, 4 //2021-02-10 ZJYEOH : Use connexity 8 because blob is built using connexity 8
                                            {
                                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 40");
                                                // Check is the blob in OCV Char rectangle box
                                                if (!objOCV.IsInOcvCharArea(objContour, intMatchNumber[e], m_intBlobOCVOffSetX, m_intBlobOCVOffSetY))
                                                {
                                                    intMatchNumber.RemoveAt(e);
                                                    e--;
                                                }

                                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 41");
                                            }
                                            
                                        }
                                    }

                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 42");

                                    if (intMatchNumber.Count > 1)
                                    {
                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 56");
                                        // Make sure area >= min area
                                        if (intArea < m_intMinArea)
                                        {
                                            continue;
                                        }

                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 57");
                                        //// Set char hit by blob counter
                                        //for (j = 0; j < intMatchNumber.Count; j++)
                                        //{
                                        //    m_intHitCharCounter[intMatchNumber[j]]++;
                                        //}

                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 59");
                                        // Check joint mark (1 blob match to more than 1 char)
                                        //if (intMatchNumber.Count > 1)
                                        {
                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 60");
                                            //if ((intFailOptionMask & 0x80) > 0)
                                            //{
                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 61");
                                            int intDisabledMarkCounter = 0;
                                            int intEnabledMarkCounter = 0;
                                            for (int q = 0; q < intMatchNumber.Count; q++)
                                            {
                                                if (!m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[intMatchNumber[q]])
                                                    intDisabledMarkCounter++;
                                                else
                                                    intEnabledMarkCounter++;
                                            }

                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 63");

                                            if (intDisabledMarkCounter > 1 && intEnabledMarkCounter < intDisabledMarkCounter || intEnabledMarkCounter <= 1)
                                                goto Skip;

                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 64");
                                            m_intJointMarkBlobResult[m_intTemplateIndex][i] = 2;

                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 65");

                                            for (int q = 0; q < intMatchNumber.Count; q++)
                                            {
                                                // 2021 11 28 - CCENG:  arrCharFailOtherThanSco index is from intNumChar, 
                                                //                      but this i value is not from inNumChar anymore, 
                                                //                      this i from m_objJointMarkROI object during build blob,
                                                //                      so need to use intMatchNumber[q] which has number char value.
                                                arrCharFailOtherThanScore[intMatchNumber[q]] = true; //arrCharFailOtherThanScore[i] = true; 
                                                m_blnCharResult[m_intTemplateIndex][intMatchNumber[q]] = false;

                                                if (m_arrCharJointMarkResult[m_intTemplateIndex][intMatchNumber[q]])
                                                    m_arrCharJointMarkResult[m_intTemplateIndex][intMatchNumber[q]] = false;
                                            }

                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 66");
                                            if ((m_intFailResultMask & 0x80) == 0)
                                                m_intFailResultMask |= 0x80;

                                            if (blnTestHandMade)
                                            {
                                                if ((m_intFailResultMask_ForPreTest & 0x80) == 0)
                                                    m_intFailResultMask_ForPreTest |= 0x80;
                                            }

                                            //}

                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 67");
                                            Skip: { }

                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 68");
                                        }
                                    }
                                }
                            }
                        }

                        for (int i = 0; i < intNoSelectedBlobs; i++)
                        {
                            if (m_intBlobResult[m_intTemplateIndex][i] == 2) // 2021-02-25 ZJYEOH : If m_intBlobResult == 2 means fail joint mark
                                continue;

                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 33");
                            fCenterX = m_objBlobs[m_intTemplateIndex].ref_arrLimitCenterX[i];
                            fCenterY = m_objBlobs[m_intTemplateIndex].ref_arrLimitCenterY[i];
                            fWidth = m_objBlobs[m_intTemplateIndex].ref_arrWidth[i];
                            fHeight = m_objBlobs[m_intTemplateIndex].ref_arrHeight[i];
                            fGravityCenterX = m_objBlobs[m_intTemplateIndex].ref_arrGravityCenterX[i];
                            fGravityCenterY = m_objBlobs[m_intTemplateIndex].ref_arrGravityCenterY[i];
                            intArea = m_objBlobs[m_intTemplateIndex].ref_arrArea[i];
                            intContourX = m_objBlobs[m_intTemplateIndex].ref_arrContourX[i];
                            intContourY = m_objBlobs[m_intTemplateIndex].ref_arrContourY[i];

                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 34");
                            // Use m_intMinArea as min area if m_intMinArea < 5, else use 5 as min area
                            if (m_intMinArea < 5)
                            {
                                // skip checking if blob area lower than setting
                                if (intArea <= m_intMinArea)
                                {
                                    continue;
                                }
                            }
                            else
                            {
                                // skip checking if blob area lower than setting
                                if (intArea <= 5)
                                {
                                    continue;
                                }
                            }

                            float fRotateCenterX = fCenterX;
                            float fRotateCenterY = fCenterY;
                            //float fRotateRefCenterX = pRotatedCenterPoint.X - m_objBuildObjectROI.ref_ROITotalX;
                            //float fRotateRefCenterY = pRotatedCenterPoint.Y - m_objBuildObjectROI.ref_ROITotalY;

                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 35");

                            //2020-06-23 ZJYEOH : if no check package size, pRotatedCenterPoint will be (-1, -1)
                            if (pRotatedCenterPoint != new PointF(-1, -1))
                            {
                                Math2.GetNewXYAfterRotate_360deg((float)m_objBuildObjectROI.ref_ROIWidth / 2, (float)m_objBuildObjectROI.ref_ROIHeight / 2,
                                                            fCenterX, fCenterY,
                                                            fPackageAngle - fMarkAngle,
                                                            ref fRotateCenterX, ref fRotateCenterY);
                            }

                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 36");

                            // Get blob start point and end point
                            fStartX = fRotateCenterX - fWidth / 2 + m_intBlobOCVOffSetX;
                            fStartY = fRotateCenterY - fHeight / 2 + m_intBlobOCVOffSetY;
                            fEndX = fRotateCenterX + fWidth / 2 + m_intBlobOCVOffSetX;
                            fEndY = fRotateCenterY + fHeight / 2 + m_intBlobOCVOffSetY;

                            // 2020 11 03 - CCENG: igore those blob object on Lead Area.
                            if (arrDontCareLeadAreaStartX.Count > 0)
                            {
                                if (IsInDontCareLeadArea(arrDontCareLeadAreaStartX, arrDontCareLeadAreaStartY, arrDontCareLeadAreaEndX, arrDontCareLeadAreaEndY, arrDontCareLeadDirection,
                                    m_objBuildObjectROI.ref_ROITotalX + (fEndX + fStartX) / 2, m_objBuildObjectROI.ref_ROITotalY + (fEndY + fStartY) / 2))
                                    continue;

                            }

                            //2021-01-19 ZJYEOH : Matching area added shift tolerance so that extra mark inside char area will not consider as extra mark
                            //bool blnContourCheck = false;
                            List<int> intMatchNumber = new List<int>();
                            if (m_intExtraExcessMarkInspectionAreaCutMode == 0)
                            {
                                intMatchNumber = objOCV.GetMatchCharIndexes(fStartX, fStartY, fEndX, fEndY,
                                                                                          fRotateCenterX + m_intBlobOCVOffSetX, fRotateCenterY + m_intBlobOCVOffSetY,
                                                                                          fWidth, fHeight, ref blnContourCheck
                                                                                          , m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftX,
                                                                                          m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftY,
                                                                                          m_fCharROIOffsetX, m_fCharROIOffsetY
                                                                                          , m_intExtraExcessMarkInspectionAreaCutMode == 1);
                            }
                            
                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 37");
                            // By using contour, double check again the selected OCV Char rectangle box is/are really matched by blobs
                            if (blnContourCheck && intMatchNumber.Count > 0)
                            {
                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 38");
                                for (int e = 0; e < intMatchNumber.Count; e++)
                                {
                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 39");
                                    // Build contour elements for the selected blob
                                    Contour objContour = new Contour();
                                    objContour.ClearContour();
                                    if (objContour.BuildContour(m_objBuildObjectROI, intContourX, intContourY, intExtraMarkThreshold, 8))//intThresholdValue, 4 //2021-02-10 ZJYEOH : Use connexity 8 because blob is built using connexity 8
                                    {
                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 40");
                                        // Check is the blob in OCV Char rectangle box
                                        if (!objOCV.IsInOcvCharArea(objContour, intMatchNumber[e], m_intBlobOCVOffSetX, m_intBlobOCVOffSetY))
                                        {
                                            intMatchNumber.RemoveAt(e);
                                            e--;
                                        }

                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 41");
                                    }
                                }
                            }

                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 42");

                            if (intMatchNumber.Count == 0)
                            {

                                // Check Group Extra Mark
                                if (((intFailOptionMask & 0x08) > 0)) //!blnSkipExtraPadAndTextShiftedChecking &&
                                {
                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 43");
                                    m_intGroupExtraMarkArea[m_intTemplateIndex] += intArea;
                                    m_intBlobResult[m_intTemplateIndex][i] = 1;

                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 44");
                                    if (m_intGroupExtraMarkArea[m_intTemplateIndex] > (int)Math.Round(objTemplateSetting.fGroupExtraMinArea))
                                    {
                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 45");
                                        m_intBlobResult[m_intTemplateIndex][i] = 2;

                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 46");
                                        if (!blnGroupExtraMark)
                                        {
                                            m_intFailResultMask |= 0x08;

                                            if (blnTestHandMade)
                                            {
                                                if ((m_intFailResultMask_ForPreTest & 0x08) == 0)
                                                    m_intFailResultMask_ForPreTest |= 0x08;
                                            }

                                            blnGroupExtraMark = true;

                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 47");
                                            // Upgrade result from 1 to 2
                                            for (j = 0; j < intNoSelectedBlobs; j++)
                                            {
                                                if (m_intBlobResult[m_intTemplateIndex][j] == 1)
                                                    m_intBlobResult[m_intTemplateIndex][j] = 2;
                                            }

                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 48");
                                        }
                                    }
                                }

                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 49");

                                //2020-06-02 ZJYEOH : filter blob with area less than min area
                                if ((intArea <= m_intMinArea))
                                {
                                    continue;
                                }

                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 50");

                                // 2020 05 22 - CCENG: Move the "record extra mark area" coding to before check ExtraMinArea. This let user know current size of extra area and easier for them to do setting.
                                if (m_intSmallestExtraMarkArea[m_intTemplateIndex] == 0 || intArea < m_intSmallestExtraMarkArea[m_intTemplateIndex])
                                    m_intSmallestExtraMarkArea[m_intTemplateIndex] = intArea;

                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 51");
                                if (m_intBiggestExtraMarkArea[m_intTemplateIndex] == 0 || intArea > m_intBiggestExtraMarkArea[m_intTemplateIndex])
                                    m_intBiggestExtraMarkArea[m_intTemplateIndex] = intArea;

                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 52");
                                // Make sure object area is higher than min area and extra min area
                                if ((intArea <= (int)Math.Round(objTemplateSetting.fExtraMinArea))) // if ((intArea <= m_intMinArea) || (intArea <= objTemplateSetting.intExtraMinArea))
                                {
                                    continue;
                                }

                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 53");
                                // 2020 05 22 - CCENG: Move the "record extra mark area" coding to before check ExtraMinArea. This let user know current size of extra area and easier for them to do setting.
                                //if (m_intSmallestExtraMarkArea[m_intTemplateIndex] == 0 || intArea < m_intSmallestExtraMarkArea[m_intTemplateIndex])
                                //    m_intSmallestExtraMarkArea[m_intTemplateIndex] = intArea;

                                //if (m_intBiggestExtraMarkArea[m_intTemplateIndex] == 0 || intArea > m_intBiggestExtraMarkArea[m_intTemplateIndex])
                                //    m_intBiggestExtraMarkArea[m_intTemplateIndex] = intArea;

                                // Check Extra Mark 
                                if ((((intFailOptionMask & 0x02) > 0) || (!blnSkipExtraPadAndTextShiftedChecking && ((intFailOptionMask & 0x04) > 0)))) // Want Gauge !blnSkipExtraPadAndTextShiftedChecking &&
                                {
                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 54");
                                    m_intBlobResult[m_intTemplateIndex][i] = 2;

                                    //if (m_intSmallestExtraMarkArea[m_intTemplateIndex] == 0 || intArea < m_intSmallestExtraMarkArea[m_intTemplateIndex])
                                    //    m_intSmallestExtraMarkArea[m_intTemplateIndex] = intArea;

                                    if ((m_intFailResultMask & 0x02) == 0)
                                        m_intFailResultMask |= 0x02;

                                    if (blnTestHandMade)
                                    {
                                        if ((m_intFailResultMask_ForPreTest & 0x02) == 0)
                                            m_intFailResultMask_ForPreTest |= 0x02;
                                    }

                                }

                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 55");

                            }
                            else
                            {
                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 56");
                                // Make sure area >= min area
                                if (intArea < m_intMinArea)
                                {
                                    continue;
                                }

                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 57");
                                // Set char hit by blob counter
                                for (j = 0; j < intMatchNumber.Count; j++)
                                {
                                    m_intHitCharCounter[intMatchNumber[j]]++;
                                }

                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 58");
                                for (j = 0; j < intMatchNumber.Count; j++)
                                {
                                    if (arrExcessStartX[intMatchNumber[j]] == -1)
                                    {
                                        arrExcessStartX[intMatchNumber[j]] = fStartX;
                                    }
                                    else
                                    {
                                        if (arrExcessStartX[intMatchNumber[j]] > fStartX)
                                            arrExcessStartX[intMatchNumber[j]] = fStartX;
                                    }

                                    if (arrExcessStartY[intMatchNumber[j]] == -1)
                                    {
                                        arrExcessStartY[intMatchNumber[j]] = fStartY;
                                    }
                                    else
                                    {
                                        if (arrExcessStartY[intMatchNumber[j]] > fStartY)
                                            arrExcessStartY[intMatchNumber[j]] = fStartY;
                                    }

                                    if (arrExcessEndX[intMatchNumber[j]] == -1)
                                    {
                                        arrExcessEndX[intMatchNumber[j]] = fEndX;
                                    }
                                    else
                                    {
                                        if (arrExcessEndX[intMatchNumber[j]] < fEndX)
                                            arrExcessEndX[intMatchNumber[j]] = fEndX;
                                    }

                                    if (arrExcessEndY[intMatchNumber[j]] == -1)
                                    {
                                        arrExcessEndY[intMatchNumber[j]] = fEndY;
                                    }
                                    else
                                    {
                                        if (arrExcessEndY[intMatchNumber[j]] < fEndY)
                                            arrExcessEndY[intMatchNumber[j]] = fEndY;
                                    }
                                }

                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 59");
                                // Check joint mark (1 blob match to more than 1 char)
                                if (intMatchNumber.Count > 1)
                                {
                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 60");
                                    //if ((intFailOptionMask & 0x80) > 0)
                                    //{
                                    //    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 61");
                                    //    int intDisabledMarkCounter = 0;
                                    //    int intEnabledMarkCounter = 0;
                                    //    for (int q = 0; q < intMatchNumber.Count; q++)
                                    //    {
                                    //        if (!m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[intMatchNumber[q]])
                                    //            intDisabledMarkCounter++;
                                    //        else
                                    //            intEnabledMarkCounter++;
                                    //    }

                                    //    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 63");

                                    //    if (intDisabledMarkCounter > 1 && intEnabledMarkCounter < intDisabledMarkCounter || intEnabledMarkCounter <= 1)
                                    //        goto Skip;

                                    //    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 64");
                                    //    m_intBlobResult[m_intTemplateIndex][i] = 2;

                                    //    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 65");
                                    //    for (int q = 0; q < intMatchNumber.Count; q++)
                                    //        m_blnCharResult[m_intTemplateIndex][intMatchNumber[q]] = false;

                                    //    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 66");
                                    //    if ((m_intFailResultMask & 0x80) == 0)
                                    //        m_intFailResultMask |= 0x80;
                                    //}

                                    //if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 67");
                                    //Skip: { }

                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 68");
                                }
                                else if (intMatchNumber.Count == 1)
                                {
                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 69");
                                    // 2018 11 27 - CCENG: Use missing mark to check broken mark will be better.
                                    //// Check Broken Mark (based on size)
                                    //int intWidth = 0, intHeight = 0;
                                    //objOCV.GetCharSize(intMatchNumber[0], ref intWidth, ref intHeight);

                                    //if ((intFailOptionMask & 0x20) > 0)
                                    //{
                                    //    if (fWidth < (intWidth - objTemplateSetting.intBrokenSize))
                                    //    {
                                    //        m_fGroupBrokenMarkLength[m_intTemplateIndex] = intWidth - fWidth;
                                    //        m_intBlobResult[m_intTemplateIndex][i] = 2;

                                    //        m_blnCharResult[m_intTemplateIndex][intMatchNumber[0]] = false;

                                    //        if ((m_intFailResultMask & 0x20) == 0)
                                    //            m_intFailResultMask |= 0x20;
                                    //    }
                                    //    else if (fHeight < (intHeight - objTemplateSetting.intBrokenSize))
                                    //    {
                                    //        m_fGroupBrokenMarkLength[m_intTemplateIndex] = intHeight - fHeight;
                                    //        m_intBlobResult[m_intTemplateIndex][i] = 2;

                                    //        m_blnCharResult[m_intTemplateIndex][intMatchNumber[0]] = false;

                                    //        if ((m_intFailResultMask & 0x20) == 0)
                                    //            m_intFailResultMask |= 0x20;
                                    //    }
                                    //}
                                }
                            }
                        }

                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 70");

                        for (int i = 0; i < intNumChars; i++)
                        {
                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 71");

                            // 2019 06 07 - CCENG: Check missing character using subtraction, but not use the m_intHitCharCounter. 
                            //// Check Missing Mark 
                            //if ((intFailOptionMask & 0x10) > 0)
                            //{
                            //    if (m_intHitCharCounter[i] == 0)
                            //    {
                            //        m_blnCharResult[m_intTemplateIndex][i] = false;

                            //        if ((m_intFailResultMask & 0x10) == 0)
                            //            m_intFailResultMask |= 0x10;
                            //    }
                            //}

                            // 2018 11 19 - CCENG: Use missing mark to check broken mark will be better.
                            // Check Broken Mark (Based on quantity blobs in char area)
                            //if ((intFailOptionMask & 0x20) > 0)
                            //{
                            //    if (m_intHitCharCounter[i] > 1)
                            //    {
                            //        m_blnCharResult[m_intTemplateIndex][i] = false;

                            //        if ((m_intFailResultMask & 0x20) == 0)
                            //            m_intFailResultMask |= 0x20;
                            //    }
                            //}
                        }

                        #endregion ----------------------------------------------------------------------------------------------------------
                        //2021-01-02 ZJYEOH : Broken mark use new method
                        if ((intFailOptionMask & 0x20) > 0 && blnWantCheckBrokenMark)
                        {
                            // Copy rotated image to sample image
                            objOcvRotatedImage.CopyTo(ref m_objSampleImage);
                            ImageDrawing objSampleImage_Temp = new ImageDrawing(true, m_objSampleImage.ref_intImageWidth, m_objSampleImage.ref_intImageHeight);
                            objOcvRotatedImage.CopyTo(ref objSampleImage_Temp);
                            ImageDrawing objSampleImage_Temp2 = new ImageDrawing(true, m_objSampleImage.ref_intImageWidth, m_objSampleImage.ref_intImageHeight);
                            objOcvRotatedImage.CopyTo(ref objSampleImage_Temp2);
                            ROI objSubtractCharROI = new ROI();
                            objSubtractCharROI.AttachImage(m_objSampleImage);

                            if (blnWantDebug)
                            {
                                m_objSampleImage.SaveImage("D:\\TS\\20.m_objSampleImage.bmp");

                            }

                            System.Drawing.Point pStart, pEnd;
                            List<ROI> arrTemplateCharErodeROI = new List<ROI>();

                            int intNumChars2 = objOCV.GetNumChars();

                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 111");

                            //List<float> arrMarkStartX = new List<float>();
                            //List<float> arrMarkStartY = new List<float>();
                            //List<float> arrMarkEndX = new List<float>();
                            //List<float> arrMarkEndY = new List<float>();

                            if (m_arrCharBrokenMarkResult[m_intTemplateIndex] == null)
                                m_arrCharBrokenMarkResult[m_intTemplateIndex] = new bool[intNumChars];

                            if (m_arrCharBrokenMarkResult[m_intTemplateIndex].Length != intNumChars)
                                m_arrCharBrokenMarkResult[m_intTemplateIndex] = new bool[intNumChars];

                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 112");
                            for (int a = 0; a < intNumChars; a++)
                            {
                                m_arrCharBrokenMarkResult[m_intTemplateIndex][a] = true;
                            }

                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 113");

                            for (int i = 0; i < intNumChars2; i++)
                            {
                                if (!m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrWantBrokenMark[i])
                                {
                                    // 2021 01 05 - CCENG: need to add into array also to prevent out of index
                                    arrTemplateCharErodeROI.Add(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrTemplateCharErodeROI[i]);
                                    continue;
                                }

                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 114");

                                arrTemplateCharErodeROI.Add(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrTemplateCharErodeROI[i]);
#if (Debug_2_12 || Release_2_12)
                                EasyImage.Threshold(arrTemplateCharErodeROI[i].ref_ROI, arrTemplateCharErodeROI[i].ref_ROI, (uint)intThresholdValue);
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                                EasyImage.Threshold(arrTemplateCharErodeROI[i].ref_ROI, arrTemplateCharErodeROI[i].ref_ROI, intThresholdValue);
#endif
                                pStart = objOCV.GetCharStartXY(i);
                                pEnd = objOCV.GetCharEndXY(i);

                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 115");

                                float fMinAddSizeX = (float)(arrTemplateCharErodeROI[i].ref_ROIWidth - (pEnd.X - pStart.X)) / 2;
                                float fMinAddSizeY = (float)(arrTemplateCharErodeROI[i].ref_ROIHeight - (pEnd.Y - pStart.Y)) / 2;

                                int intMinAddSizeStartX, intMinAddSizeStartY, intMinAddSizeEndX, intMinAddSizeEndY;
                                if (fMinAddSizeX == (int)fMinAddSizeX)
                                {
                                    intMinAddSizeStartX = (int)fMinAddSizeX;
                                    intMinAddSizeEndX = (int)fMinAddSizeX;
                                }
                                else
                                {
                                    intMinAddSizeStartX = (int)Math.Ceiling(fMinAddSizeX);
                                    intMinAddSizeEndX = (int)Math.Floor(fMinAddSizeX);
                                }

                                if (fMinAddSizeY == (int)fMinAddSizeY)
                                {
                                    intMinAddSizeStartY = (int)fMinAddSizeY;
                                    intMinAddSizeEndY = (int)fMinAddSizeY;
                                }
                                else
                                {
                                    intMinAddSizeStartY = (int)Math.Ceiling(fMinAddSizeY);
                                    intMinAddSizeEndY = (int)Math.Floor(fMinAddSizeY);
                                }

                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 116");

                                ROI objSampleCharROI = new ROI();

                                if ((m_intROIOffSetX + pStart.X - intMinAddSizeStartX) >= 0) //if ((pStart.X - intMinAddSizeStartX) >= 0)   // 2019 10 11 - CCENG: add m_intROIOffSetXY because objSampleCharROI attach to main Image.
                                    objSampleCharROI.ref_ROIPositionX = m_intROIOffSetX + pStart.X - intMinAddSizeStartX;
                                else
                                    objSampleCharROI.ref_ROIPositionX = m_intROIOffSetX;

                                if ((m_intROIOffSetY + pStart.Y - intMinAddSizeStartY) >= 0)  //if ((pStart.Y - intMinAddSizeStartY) >= 0)  // 2019 10 11 - CCENG: add m_intROIOffSetXY because objSampleCharROI attach to main Image.
                                    objSampleCharROI.ref_ROIPositionY = m_intROIOffSetY + pStart.Y - intMinAddSizeStartY;
                                else
                                    objSampleCharROI.ref_ROIPositionY = m_intROIOffSetY;

                                if ((pEnd.X + intMinAddSizeEndX * 2) < m_intImageWidth)
                                    objSampleCharROI.ref_ROIWidth = pEnd.X - pStart.X + intMinAddSizeStartX + intMinAddSizeEndX;
                                else
                                    continue;
                                if ((pEnd.Y + intMinAddSizeEndY * 2) < m_intImageHeight)
                                    objSampleCharROI.ref_ROIHeight = pEnd.Y - pStart.Y + intMinAddSizeStartY + intMinAddSizeEndY;
                                else
                                    continue;

                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 117");

                                // 2020 03 01 - CCENG: Attached to m_objSampleImage because objSampleCharROI will be Dilated when m_intMissingMarkInspectionMethod is 1. 
                                //                   : Also Dilate and subtract's image source and destination can be same.          
                                //objSampleCharROI.AttachImage(objImage);

                                //2020-06-17 ZJYEOH : objSampleCharROI should attach another image as m_objSampleImage will be image processsed
                                objSampleCharROI.AttachImage(objSampleImage_Temp);//m_objSampleImage

                                objSubtractCharROI.LoadROISetting(objSampleCharROI.ref_ROIPositionX, objSampleCharROI.ref_ROIPositionY,
                                                                    objSampleCharROI.ref_ROIWidth, objSampleCharROI.ref_ROIHeight);

                                if ((objSampleCharROI.ref_ROIWidth != arrTemplateCharErodeROI[i].ref_ROIWidth) ||
                                    (arrTemplateCharErodeROI[i].ref_ROIWidth != objSubtractCharROI.ref_ROIWidth))
                                    continue;

                                if ((objSampleCharROI.ref_ROIHeight != arrTemplateCharErodeROI[i].ref_ROIHeight) ||
                                    (arrTemplateCharErodeROI[i].ref_ROIHeight != objSubtractCharROI.ref_ROIHeight))
                                    continue;

                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 118");

                                //arrMarkStartX.Add(objSubtractCharROI.ref_ROIPositionX - m_intROIOffSetX);
                                //arrMarkStartY.Add(objSubtractCharROI.ref_ROIPositionY - m_intROIOffSetY);
                                //arrMarkEndX.Add(objSubtractCharROI.ref_ROIPositionX + objSubtractCharROI.ref_ROIWidth - m_intROIOffSetX);
                                //arrMarkEndY.Add(objSubtractCharROI.ref_ROIPositionY + objSubtractCharROI.ref_ROIHeight - m_intROIOffSetY);

                                if (!m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i] || !CheckWantInspectBrokenMark(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMarkType[i]))
                                {
                                    EasyImage.Oper(EArithmeticLogicOperation.Subtract, arrTemplateCharErodeROI[i].ref_ROI, arrTemplateCharErodeROI[i].ref_ROI, objSubtractCharROI.ref_ROI);
                                }
                                else
                                {
#if (Debug_2_12 || Release_2_12)
                                    EasyImage.Threshold(objSampleCharROI.ref_ROI, objSampleCharROI.ref_ROI, (uint)intThresholdValue);
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                                    EasyImage.Threshold(objSampleCharROI.ref_ROI, objSampleCharROI.ref_ROI, intThresholdValue);
#endif
                                    //2020-06-17 ZJYEOH : Image processing will be different for white on black and black one white

                                    if (m_blnWhiteOnBlack)
                                    {
                                        ROI.InvertOperationROI(arrTemplateCharErodeROI[i]);
                                        EasyImage.Oper(EArithmeticLogicOperation.Subtract, objSampleCharROI.ref_ROI, arrTemplateCharErodeROI[i].ref_ROI, objSubtractCharROI.ref_ROI);
                                        //2020-06-17 ZJYEOH : Invert back so that arrTemplateCharErodeROI[i] will not inverted if it is used again because inverted area may overlap another mark
                                        ROI.InvertOperationROI(arrTemplateCharErodeROI[i]);
                                    }
                                    else
                                    {
                                        //ROI.InvertOperationROI(objSampleCharROI);
                                        EasyImage.Oper(EArithmeticLogicOperation.Add, arrTemplateCharErodeROI[i].ref_ROI, objSampleCharROI.ref_ROI, objSubtractCharROI.ref_ROI);
                                        ////2020-06-17 ZJYEOH : Invert back so that objSampleCharROI will not inverted if it is used again because inverted area may overlap another mark
                                        //ROI.InvertOperationROI(objSampleCharROI);
                                    }

                                }

                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 119");

                                if (blnWantDebug)
                                {
                                    arrTemplateCharErodeROI[i].SaveImage("D:\\TS\\34.arrTemplateCharErodeROI[i]" + i.ToString() + ".bmp");
                                    objSampleCharROI.SaveImage("D:\\TS\\35.objSampleCharROI" + i.ToString() + ".bmp");
                                    objSubtractCharROI.SaveImage("D:\\TS\\36.objSubtractCharROI" + i.ToString() + ".bmp");
                                    m_objSampleImage.SaveImage("D:\\TS\\37.m_objSampleImage" + i.ToString() + ".bmp");
                                }

                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 120");
#if (Debug_2_12 || Release_2_12)
                                if (m_intEnhanceMark_LinkMark_HalfWidth > 0)
                                {
                                    if (m_blnWhiteOnBlack)
                                        EasyImage.CloseBox(objSubtractCharROI.ref_ROI, objSubtractCharROI.ref_ROI, (uint)m_intEnhanceMark_LinkMark_HalfWidth);
                                    else
                                        EasyImage.OpenBox(objSubtractCharROI.ref_ROI, objSubtractCharROI.ref_ROI, (uint)m_intEnhanceMark_LinkMark_HalfWidth);
                                }

                                if (m_intEnhanceMark_ReduceNoise_HalfWidth > 0)
                                {
                                    if (m_blnWhiteOnBlack)
                                        EasyImage.OpenBox(objSubtractCharROI.ref_ROI, objSubtractCharROI.ref_ROI, (uint)m_intEnhanceMark_ReduceNoise_HalfWidth);
                                    else
                                        EasyImage.CloseBox(objSubtractCharROI.ref_ROI, objSubtractCharROI.ref_ROI, (uint)m_intEnhanceMark_ReduceNoise_HalfWidth);
                                }
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                                  if (m_intEnhanceMark_LinkMark_HalfWidth > 0)
                                {
                                    if (m_blnWhiteOnBlack)
                                        EasyImage.CloseBox(objSubtractCharROI.ref_ROI, objSubtractCharROI.ref_ROI, m_intEnhanceMark_LinkMark_HalfWidth);
                                    else
                                        EasyImage.OpenBox(objSubtractCharROI.ref_ROI, objSubtractCharROI.ref_ROI, m_intEnhanceMark_LinkMark_HalfWidth);
                                }

                                if (m_intEnhanceMark_ReduceNoise_HalfWidth > 0)
                                {
                                    if (m_blnWhiteOnBlack)
                                        EasyImage.OpenBox(objSubtractCharROI.ref_ROI, objSubtractCharROI.ref_ROI, m_intEnhanceMark_ReduceNoise_HalfWidth);
                                    else
                                        EasyImage.CloseBox(objSubtractCharROI.ref_ROI, objSubtractCharROI.ref_ROI, m_intEnhanceMark_ReduceNoise_HalfWidth);
                                }
#endif
                                if (m_objBrokenBlobs[m_intTemplateIndex] == null)
                                    m_objBrokenBlobs[m_intTemplateIndex] = new EBlobs();
                                else
                                    m_objBrokenBlobs[m_intTemplateIndex].CleanAllBlobs();

                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 123");
                                if (blnWantDebug)
                                {
                                    objSubtractCharROI.SaveImage("D:\\TS\\42.objSubtractCharROI.bmp");
                                }

                                //2020-06-17 ZJYEOH : Threshold will invert for white on black
                                int intMissingThreshold = intThresholdValue;
                                if (m_blnWhiteOnBlack)
                                {
                                    intMissingThreshold = intThresholdValue;
                                }


                                if (BuildObject(m_objBrokenBlobs[m_intTemplateIndex], objSubtractCharROI, false, true, intMissingThreshold, m_intMinArea, 1000000, 0x1F)) //255 - intThresholdValue
                                {
                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 124");
                                    int intNoBlobs = m_objBrokenBlobs[m_intTemplateIndex].ref_intNumSelectedObject;

                                    if (intNoBlobs > 1)
                                    {
                                        // 2021 01 05 - m_blnCharResult is for score result, not for broken mark
                                        //if (m_blnCharResult[m_intTemplateIndex][i])
                                        //    m_blnCharResult[m_intTemplateIndex][i] = false;

                                        if (m_arrCharBrokenMarkResult[m_intTemplateIndex][i])
                                            m_arrCharBrokenMarkResult[m_intTemplateIndex][i] = false;

                                        if ((m_intFailResultMask & 0x20) == 0)
                                            m_intFailResultMask |= 0x20;

                                        if (blnTestHandMade)
                                        {
                                            if ((m_intFailResultMask_ForPreTest & 0x20) == 0)
                                                m_intFailResultMask_ForPreTest |= 0x20;
                                        }

                                    }
                                }

                                objSampleCharROI.Dispose();
                            }

                            objSampleImage_Temp.Dispose();
                            objSampleImage_Temp2.Dispose();
                            objSubtractCharROI.Dispose();
                        }


                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 72");

                        #region ----------- Check Excess mark and Missing Mark in characters area using substract function and grey value ---------------------
                        // If text score does not fail
                        if ((m_intFailResultMask & 0x200) == 0 || blnTestHandMade || m_blnWantUseExcessMissingMarkAffectScore)
                        {
                            //-------------------------------------- Check Excess mark in characters area ---------------------------------------//
                            if (((intFailOptionMask & 0x01) > 0) || (((intFailOptionMask & 0x100) > 0) && m_blnWantCheckTotalExcessMark) || blnTestHandMade || m_blnWantUseExcessMissingMarkAffectScore || ShowLiterationOnly) // Excess Mark Char Area is ON
                            {
                                //if ((m_intFailResultMask & 0x08) == 0)      // 2019 06 28 - Check Excess Mark only if no Group extra mark failure. Because excess inpsection take quite long time and if too many extra makr, it will take too long time for isnpection.
                                {
                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 73");
                                    // Copy rotated image to sample image
                                    //ImageDrawing objSampleImage = new ImageDrawing();
                                    if (blnWantDebug)
                                    {
                                        objOcvRotatedImage.SaveImage("D:\\TS\\10.objOcvRotatedImage.bmp");
                                        objImage.SaveImage("D:\\TS\\10.objImage.bmp");
                                    }

                                    if (m_blnWantDontCareArea)
                                    {
                                        m_objDontCareBackupImage.CopyTo(ref m_objSampleImage);

                                        if (blnTestHandMade)
                                            m_objDontCareBackupImage.CopyTo(m_objHandMadeImage);
                                    }
                                    else
                                    {
                                        objOcvRotatedImage.CopyTo(ref m_objSampleImage);

                                        if (blnTestHandMade)
                                            objOcvRotatedImage.CopyTo(m_objHandMadeImage);
                                    }
                                    //objImage.CopyTo(ref m_objSampleImage);

                                    ROI objSubtractCharROI = new ROI();

                                    ImageDrawing objSubtractImage_Temp = new ImageDrawing(true, m_objSampleImage.ref_intImageWidth, m_objSampleImage.ref_intImageHeight);
                                    if (m_intExtraExcessMarkInspectionAreaCutMode != 0)
                                    {
                                        if (m_blnWhiteOnBlack)
                                            objBlackImage.CopyTo(ref objSubtractImage_Temp);
                                        else
                                            objWhiteImage.CopyTo(ref objSubtractImage_Temp);
                                        objSubtractCharROI.AttachImage(objSubtractImage_Temp);
                                    }
                                    else
                                        objSubtractCharROI.AttachImage(m_objSampleImage);

                                    if (m_blnWantDontCareArea)
                                    {
                                        objSubtractCharROI.LoadROISetting(objMarkPackageMarkROI.ref_ROITotalX, objMarkPackageMarkROI.ref_ROITotalY, objMarkPackageMarkROI.ref_ROIWidth, objMarkPackageMarkROI.ref_ROIHeight);

                                        ROI objDontCareROI = new ROI();
                                        //objDontCareROI.LoadROISetting(0, 0, objMarkPackageMarkROI.ref_ROIWidth, objMarkPackageMarkROI.ref_ROIHeight);
                                        //objDontCareROI.AttachImage(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].objDontCareImage);
                                        ////2020-06-17 ZJYEOH : Subtract or Add depends on white on black or black on white
                                        //if (m_blnWhiteOnBlack)
                                        //    ROI.SubtractROI(objSubtractCharROI, objDontCareROI);
                                        //else
                                        //    ROI.LogicOperationAddROI(objSubtractCharROI, objDontCareROI);
                                        ROI objOriROI = new ROI();
                                        for (int i = 0; i < arrMarkDontCareROI.Count; i++)
                                        {
                                            objOriROI.AttachImage(m_objSampleImage);

                                            objDontCareROI.AttachImage(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrDontCareImage[i]);// objWhiteImage

                                            objOriROI.LoadROISetting(objMarkPackageMarkROI.ref_ROITotalCenterX - arrMarkDontCareROI[i].ref_intStartOffsetX,
                                                                     objMarkPackageMarkROI.ref_ROITotalCenterY - arrMarkDontCareROI[i].ref_intStartOffsetY,
                                                                     arrMarkDontCareROI[i].ref_ROIWidth, arrMarkDontCareROI[i].ref_ROIHeight);

                                            objDontCareROI.LoadROISetting(objMarkPackageMarkROI.ref_ROITotalCenterX - arrMarkDontCareROI[i].ref_intStartOffsetX,
                                                                          objMarkPackageMarkROI.ref_ROITotalCenterY - arrMarkDontCareROI[i].ref_intStartOffsetY,
                                                                          arrMarkDontCareROI[i].ref_ROIWidth, arrMarkDontCareROI[i].ref_ROIHeight);
                                            if (m_blnWhiteOnBlack)
                                                ROI.SubtractROI(objOriROI, objDontCareROI);
                                            else
                                                ROI.LogicOperationAddROI(objOriROI, objDontCareROI);
                                            //m_objSampleImage.SaveImage("D:\\m_objSampleImage.bmp");
                                            //objMarkPackageMarkROI.SaveImage("D:\\objMarkPackageMarkROI" + i.ToString() + ".bmp");
                                            //objSubtractCharROI.SaveImage("D:\\objSubtractCharROI" + i.ToString() + ".bmp");
                                        }
                                        objOriROI.Dispose();
                                        objDontCareROI.Dispose();

                                        if (blnWantDebug)
                                        {
                                            m_objSampleImage.SaveImage("D:\\TS\\11.m_objSampleImage_AfterDontCare.bmp");
                                        }

                                    }

                                    System.Drawing.Point pStart, pEnd;
                                    List<ROI> arrTemplateCharDilateROI = new List<ROI>();
                                    List<float> arrTemplateStartX = new List<float>();
                                    List<float> arrTemplateStartY = new List<float>();
                                    List<float> arrTemplateEndX = new List<float>();
                                    List<float> arrTemplateEndY = new List<float>();
                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 74");
                                    for (int i = 0; i < intNumChars; i++)
                                    {

                                        //// 2020-08-11 ZJYEOH : Skip Check Excess if mark is disabled
                                        //if (!m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i])
                                        //    continue;

                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 75");
                                        arrTemplateCharDilateROI.Add(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrTemplateCharDilateROI[i]);
#if (Debug_2_12 || Release_2_12)
                                        EasyImage.Threshold(arrTemplateCharDilateROI[i].ref_ROI, arrTemplateCharDilateROI[i].ref_ROI, (uint)intThresholdValue);
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                                        EasyImage.Threshold(arrTemplateCharDilateROI[i].ref_ROI, arrTemplateCharDilateROI[i].ref_ROI, intThresholdValue);
#endif

                                        pStart = objOCV.GetCharStartXY(i);
                                        pEnd = objOCV.GetCharEndXY(i);

                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 76");
                                        float fMinAddSizeX = (float)(arrTemplateCharDilateROI[i].ref_ROIWidth - (pEnd.X - pStart.X)) / 2;
                                        float fMinAddSizeY = (float)(arrTemplateCharDilateROI[i].ref_ROIHeight - (pEnd.Y - pStart.Y)) / 2;

                                        int intMinAddSizeStartX, intMinAddSizeStartY, intMinAddSizeEndX, intMinAddSizeEndY;
                                        if (fMinAddSizeX == (int)fMinAddSizeX)
                                        {
                                            intMinAddSizeStartX = (int)fMinAddSizeX;
                                            intMinAddSizeEndX = (int)fMinAddSizeX;
                                        }
                                        else
                                        {
                                            intMinAddSizeStartX = (int)Math.Ceiling(fMinAddSizeX);
                                            intMinAddSizeEndX = (int)Math.Floor(fMinAddSizeX);
                                        }

                                        if (fMinAddSizeY == (int)fMinAddSizeY)
                                        {
                                            intMinAddSizeStartY = (int)fMinAddSizeY;
                                            intMinAddSizeEndY = (int)fMinAddSizeY;
                                        }
                                        else
                                        {
                                            intMinAddSizeStartY = (int)Math.Ceiling(fMinAddSizeY);
                                            intMinAddSizeEndY = (int)Math.Floor(fMinAddSizeY);
                                        }

                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 77");
                                        ROI objSampleCharROI = new ROI();

                                        if (m_blnWantDontCareIgnoredMarkWholeArea && (!m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i] || !CheckWantInspectExcessMark(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMarkType[i])))
                                        {
                                            //2021-01-18 ZJYEOH : Should use sample position
                                            Point pStartTemplate = pStart;// new Point(arrTemplateCharDilateROI[i].ref_ROIPositionX, arrTemplateCharDilateROI[i].ref_ROIPositionY);
                                            Point pEndTemplate = pEnd;// new Point(arrTemplateCharDilateROI[i].ref_ROIPositionX + arrTemplateCharDilateROI[i].ref_ROIWidth, arrTemplateCharDilateROI[i].ref_ROIPositionY + arrTemplateCharDilateROI[i].ref_ROIHeight);

                                            if ((m_intROIOffSetX + pStartTemplate.X - ((int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftX[i] + m_fCharROIOffsetX))) >= 0)
                                                objSampleCharROI.ref_ROIPositionX = m_intROIOffSetX + pStartTemplate.X - ((int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftX[i] + m_fCharROIOffsetX));
                                            else
                                                objSampleCharROI.ref_ROIPositionX = m_intROIOffSetX;

                                            if ((m_intROIOffSetY + pStartTemplate.Y - ((int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftY[i] + m_fCharROIOffsetY))) >= 0)
                                                objSampleCharROI.ref_ROIPositionY = m_intROIOffSetY + pStartTemplate.Y - ((int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftY[i] + m_fCharROIOffsetY));
                                            else
                                                objSampleCharROI.ref_ROIPositionY = m_intROIOffSetY;

                                            if ((m_intROIOffSetX + pEndTemplate.X + ((int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftX[i] + m_fCharROIOffsetX))) < m_intImageWidth)
                                                objSampleCharROI.ref_ROIWidth = pEndTemplate.X - pStartTemplate.X + ((int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftX[i] + m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftX[i] + m_fCharROIOffsetX + m_fCharROIOffsetX));
                                            else
                                                continue;
                                            if ((m_intROIOffSetY + pEndTemplate.Y + ((int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftY[i] + m_fCharROIOffsetY))) < m_intImageHeight)
                                                objSampleCharROI.ref_ROIHeight = pEndTemplate.Y - pStartTemplate.Y + ((int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftY[i] + m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftY[i] + m_fCharROIOffsetY + m_fCharROIOffsetY));
                                            else
                                                continue;
                                        }
                                        else
                                        {
                                            if ((m_intROIOffSetX + pStart.X - intMinAddSizeStartX) >= 0) //if ((pStart.X - intMinAddSizeStartX) >= 0)   // 2019 10 11 - CCENG: add m_intROIOffSetXY because objSampleCharROI attach to main Image.
                                                objSampleCharROI.ref_ROIPositionX = m_intROIOffSetX + pStart.X - intMinAddSizeStartX;
                                            else
                                                objSampleCharROI.ref_ROIPositionX = m_intROIOffSetX;

                                            if ((m_intROIOffSetY + pStart.Y - intMinAddSizeStartY) >= 0)  //if ((pStart.Y - intMinAddSizeStartY) >= 0)  // 2019 10 11 - CCENG: add m_intROIOffSetXY because objSampleCharROI attach to main Image.
                                                objSampleCharROI.ref_ROIPositionY = m_intROIOffSetY + pStart.Y - intMinAddSizeStartY;
                                            else
                                                objSampleCharROI.ref_ROIPositionY = m_intROIOffSetY;

                                            if ((pEnd.X + intMinAddSizeEndX * 2) < m_intImageWidth)
                                                objSampleCharROI.ref_ROIWidth = pEnd.X - pStart.X + intMinAddSizeStartX + intMinAddSizeEndX;
                                            else
                                                continue;
                                            if ((pEnd.Y + intMinAddSizeEndY * 2) < m_intImageHeight)
                                                objSampleCharROI.ref_ROIHeight = pEnd.Y - pStart.Y + intMinAddSizeStartY + intMinAddSizeEndY;
                                            else
                                                continue;
                                        }

                                        objSampleCharROI.AttachImage(m_objSampleImage);//objOcvRotatedImage

                                        objSubtractCharROI.LoadROISetting(objSampleCharROI.ref_ROIPositionX, objSampleCharROI.ref_ROIPositionY,
                                                                            objSampleCharROI.ref_ROIWidth, objSampleCharROI.ref_ROIHeight);

                                        arrTemplateStartX.Add(objSampleCharROI.ref_ROIPositionX - m_intROIOffSetX);
                                        arrTemplateStartY.Add(objSampleCharROI.ref_ROIPositionY - m_intROIOffSetY);
                                        arrTemplateEndX.Add(objSampleCharROI.ref_ROIPositionX + objSampleCharROI.ref_ROIWidth - m_intROIOffSetX);
                                        arrTemplateEndY.Add(objSampleCharROI.ref_ROIPositionY + objSampleCharROI.ref_ROIHeight - m_intROIOffSetY);

                                        if (!m_blnWantDontCareIgnoredMarkWholeArea)
                                        {
                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 78");
                                            if ((objSampleCharROI.ref_ROIWidth != arrTemplateCharDilateROI[i].ref_ROIWidth) ||
                                                (arrTemplateCharDilateROI[i].ref_ROIWidth != objSubtractCharROI.ref_ROIWidth))
                                                continue;

                                            if ((objSampleCharROI.ref_ROIHeight != arrTemplateCharDilateROI[i].ref_ROIHeight) ||
                                                (arrTemplateCharDilateROI[i].ref_ROIHeight != objSubtractCharROI.ref_ROIHeight))
                                                continue;
                                        }

                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 79");
                                        if (m_intExtraExcessMarkInspectionAreaCutMode != 0)
                                        {
                                            if (!m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i] || !CheckWantInspectExcessMark(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMarkType[i]))
                                            {
                                                //ROI.InvertOperationROI(objSubtractCharROI);
                                                EasyImage.Oper(EArithmeticLogicOperation.Add, objSubtractCharROI.ref_ROI, new EBW8(255), objSubtractCharROI.ref_ROI);
                                            }
                                            else
                                            {
                                                if (blnTestHandMade)
                                                {
                                                    if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i] && CheckWantInspectExcessMark(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMarkType[i]))
                                                    {
                                                        ROI objROI = new ROI();
                                                        ImageDrawing objImg = new ImageDrawing();
                                                        objBlackImage.CopyTo(ref objImg);
                                                        objROI.AttachImage(objImg);
                                                        objROI.LoadROISetting(objSubtractCharROI.ref_ROIPositionX, objSubtractCharROI.ref_ROIPositionY,
                                                                                    objSubtractCharROI.ref_ROIWidth, objSubtractCharROI.ref_ROIHeight);

                                                        objROI.AddWhiteCrossX();
                                                        EasyImage.DilateBox(objROI.ref_ROI);

                                                        //2020-06-17 ZJYEOH : Image processing will be different for white on black and black one white
                                                        if (m_blnWhiteOnBlack)
                                                        {
                                                            EasyImage.Oper(EArithmeticLogicOperation.Add, objSubtractCharROI.ref_ROI, objROI.ref_ROI, objSubtractCharROI.ref_ROI);
                                                        }
                                                        else
                                                        {
                                                            EasyImage.Oper(EArithmeticLogicOperation.Subtract, objSubtractCharROI.ref_ROI, objROI.ref_ROI, objSubtractCharROI.ref_ROI);
                                                        }
                                                        objROI.AttachImage(m_objHandMadeImage);
                                                        objSubtractCharROI.CopyImage(ref objROI);
                                                        objROI.Dispose();
                                                        objImg.Dispose();
                                                    }
                                                }
                                                //2020-06-17 ZJYEOH : Image processing will be different for white on black and black one white
                                                if (m_blnWhiteOnBlack)
                                                {
                                                    EasyImage.Oper(EArithmeticLogicOperation.Add, objSubtractCharROI.ref_ROI, arrTemplateCharDilateROI[i].ref_ROI, objSubtractCharROI.ref_ROI);
                                                }
                                                else
                                                {
                                                    //EasyImage.Oper(EArithmeticLogicOperation.Invert, arrTemplateCharDilateROI[i].ref_ROI, arrTemplateCharDilateROI[i].ref_ROI);
                                                    //ROI.InvertOperationROI(arrTemplateCharDilateROI[i]);
                                                    EasyImage.Oper(EArithmeticLogicOperation.Subtract, objSubtractCharROI.ref_ROI, arrTemplateCharDilateROI[i].ref_ROI, objSubtractCharROI.ref_ROI);
                                                    //EasyImage.Oper(EArithmeticLogicOperation.Invert, arrTemplateCharDilateROI[i].ref_ROI, arrTemplateCharDilateROI[i].ref_ROI);
                                                    //ROI.InvertOperationROI(arrTemplateCharDilateROI[i]);
                                                }

                                            }
                                        }
                                        else
                                        {
                                            if (!m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i] || !CheckWantInspectExcessMark(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMarkType[i]))
                                            {
                                                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objSampleCharROI.ref_ROI, objSampleCharROI.ref_ROI, objSubtractCharROI.ref_ROI);
                                            }
                                            else
                                            {
                                                if (blnTestHandMade)
                                                {
                                                    if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i] && CheckWantInspectExcessMark(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMarkType[i]))
                                                    {
                                                        ROI objROI = new ROI();
                                                        ImageDrawing objImg = new ImageDrawing();
                                                        objBlackImage.CopyTo(ref objImg);
                                                        objROI.AttachImage(objImg);
                                                        objROI.LoadROISetting(objSampleCharROI.ref_ROIPositionX, objSampleCharROI.ref_ROIPositionY,
                                                                                    objSampleCharROI.ref_ROIWidth, objSampleCharROI.ref_ROIHeight);

                                                        objROI.AddWhiteCrossX();
                                                        EasyImage.DilateBox(objROI.ref_ROI);

                                                        //2020-06-17 ZJYEOH : Image processing will be different for white on black and black one white
                                                        if (m_blnWhiteOnBlack)
                                                        {
                                                            EasyImage.Oper(EArithmeticLogicOperation.Add, objSampleCharROI.ref_ROI, objROI.ref_ROI, objSampleCharROI.ref_ROI);
                                                        }
                                                        else
                                                        {
                                                            EasyImage.Oper(EArithmeticLogicOperation.Subtract, objSampleCharROI.ref_ROI, objROI.ref_ROI, objSampleCharROI.ref_ROI);
                                                        }
                                                        objROI.AttachImage(m_objHandMadeImage);
                                                        objSampleCharROI.CopyImage(ref objROI);
                                                        objROI.Dispose();
                                                        objImg.Dispose();
                                                    }
                                                }
                                                //2020-06-17 ZJYEOH : Image processing will be different for white on black and black one white
                                                if (m_blnWhiteOnBlack)
                                                {
                                                    EasyImage.Oper(EArithmeticLogicOperation.Subtract, objSampleCharROI.ref_ROI, arrTemplateCharDilateROI[i].ref_ROI, objSubtractCharROI.ref_ROI);
                                                }
                                                else
                                                {
                                                    //EasyImage.Oper(EArithmeticLogicOperation.Invert, arrTemplateCharDilateROI[i].ref_ROI, arrTemplateCharDilateROI[i].ref_ROI);
                                                    ROI.InvertOperationROI(arrTemplateCharDilateROI[i]);
                                                    EasyImage.Oper(EArithmeticLogicOperation.Add, objSampleCharROI.ref_ROI, arrTemplateCharDilateROI[i].ref_ROI, objSubtractCharROI.ref_ROI);
                                                    //EasyImage.Oper(EArithmeticLogicOperation.Invert, arrTemplateCharDilateROI[i].ref_ROI, arrTemplateCharDilateROI[i].ref_ROI);
                                                    ROI.InvertOperationROI(arrTemplateCharDilateROI[i]);
                                                }

                                            }
                                        }

                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 80");

                                        if (blnWantDebug)
                                        {
                                            objSampleCharROI.SaveImage("D:\\TS\\13.objSampleCharROI" + i.ToString() + ".bmp");
                                            arrTemplateCharDilateROI[i].SaveImage("D:\\TS\\14.arrTemplateCharDilateROI[i]" + i.ToString() + ".bmp");
                                            objSubtractCharROI.SaveImage("D:\\TS\\15.objSubtractCharROI" + i.ToString() + ".bmp");
                                            m_objSampleImage.SaveImage("D:\\TS\\16.m_objSampleImage" + i.ToString() + ".bmp");
                                        }

                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 81");

                                        objSampleCharROI.Dispose();
                                    }

                                    if(blnTestHandMade)
                                        m_objHandMadeImage.SaveImage(strPreTestImagePath + "ExcessMark.bmp");

                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 83");
                                    if (blnWantDebug)
                                    {
                                        objSubtractImage_Temp.SaveImage("D:\\TS\\17objSubtractImage_Temp.bmp");
                                        m_objSampleImage.SaveImage("D:\\TS\\17m_objSampleImage.bmp");
                                    }

                                    if (m_intExtraExcessMarkInspectionAreaCutMode != 0)
                                        objSubtractCharROI.AttachImage(objSubtractImage_Temp);
                                    else
                                        objSubtractCharROI.AttachImage(m_objSampleImage);

                                    // Reload ROI size and placement to same location and same size as Mark ROI
                                    objSubtractCharROI.LoadROISetting(m_intROIOffSetX, m_intROIOffSetY, objMarkPackageMarkROI.ref_ROIWidth, objMarkPackageMarkROI.ref_ROIHeight);

                                    if (blnWantDebug)
                                    {
                                        objSubtractCharROI.SaveImage("D:\\TS\\18.objSubtractCharROI.bmp");
                                    }

                                    if (m_intExtraExcessMarkInspectionAreaCutMode != 0)
                                    {
                                        ROI objSampleCharROI_Temp = new ROI();
                                        objSampleCharROI_Temp.AttachImage(m_objSampleImage);//objImage_Temp
                                        objSampleCharROI_Temp.LoadROISetting(m_intROIOffSetX, m_intROIOffSetY, objMarkPackageMarkROI.ref_ROIWidth, objMarkPackageMarkROI.ref_ROIHeight);

                                        if (blnWantDebug)
                                        {
                                            objSampleCharROI_Temp.SaveImage("D:\\TS\\18_0.objSampleCharROI_Temp.bmp");
                                        }

                                        //2020-06-17 ZJYEOH : Image processing will be different for white on black and black one white
                                        if (m_blnWhiteOnBlack)
                                        {
                                            EasyImage.Oper(EArithmeticLogicOperation.Subtract, objSampleCharROI_Temp.ref_ROI, objSubtractCharROI.ref_ROI, objSubtractCharROI.ref_ROI);
                                            objSampleCharROI_Temp.AttachImage(objImage_Temp);
                                            EasyImage.Oper(EArithmeticLogicOperation.Subtract, objSubtractCharROI.ref_ROI, objSampleCharROI_Temp.ref_ROI, objSubtractCharROI.ref_ROI);
                                        }
                                        else
                                        {
                                            //ROI.InvertOperationROI(objSubtractCharROI);
                                            EasyImage.Oper(EArithmeticLogicOperation.Add, objSampleCharROI_Temp.ref_ROI, objSubtractCharROI.ref_ROI, objSubtractCharROI.ref_ROI);
                                            //objSampleCharROI_Temp.AttachImage(objImage_Temp);
                                            //EasyImage.Oper(EArithmeticLogicOperation.Add, objSampleCharROI_Temp.ref_ROI, objSubtractCharROI.ref_ROI, objSubtractCharROI.ref_ROI);
                                        }

                                        if (blnWantDebug)
                                        {
                                            objSampleCharROI_Temp.SaveImage("D:\\TS\\18_1.objSampleCharROI_Temp.bmp");
                                            objSubtractCharROI.SaveImage("D:\\TS\\18_1.objSubtractCharROI.bmp");
                                        }
                                        objSampleCharROI_Temp.Dispose();

                                    }

                                    //2020-06-23 ZJYEOH : if no check package size, pRotatedCenterPoint will be (-1, -1)
                                    if (pRotatedCenterPoint != new PointF(-1, -1))
                                    {
                                        m_objLocalTemporary_RotateSearchROI.AttachImage(m_objSampleImage);
                                        m_objLocalTemporary_RotateSearchROI.LoadROISetting((int)Math.Round(pRotatedCenterPoint.X - objMarkPackageSearchROI.ref_ROIWidth / 2, 0, MidpointRounding.AwayFromZero),
                                                                          (int)Math.Round(pRotatedCenterPoint.Y - objMarkPackageSearchROI.ref_ROIHeight / 2, 0, MidpointRounding.AwayFromZero),
                                                                          objMarkPackageSearchROI.ref_ROIWidth, objMarkPackageSearchROI.ref_ROIHeight);

                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 82");
                                        ROI.RotateROI(m_objLocalTemporary_RotateSearchROI, fPackageAngle - fMarkAngle, ref m_objSampleImage, 0);
                                    }

//////////#if (Debug_2_12 || Release_2_12)
//////////                                    if (m_intCharOpenHalfWidth > 0)
//////////                                        EasyImage.OpenBox(objSubtractCharROI.ref_ROI, objSubtractCharROI.ref_ROI, (uint)m_intCharOpenHalfWidth);
//////////#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)

//////////                                if (m_intCharOpenHalfWidth > 0)
//////////                                    EasyImage.OpenBox(objSubtractCharROI.ref_ROI, objSubtractCharROI.ref_ROI, m_intCharOpenHalfWidth);
//////////#endif


                                    if (m_objExcessBlobs[m_intTemplateIndex] == null)
                                        m_objExcessBlobs[m_intTemplateIndex] = new EBlobs();
                                    else
                                        m_objExcessBlobs[m_intTemplateIndex].CleanAllBlobs();

                                    if (m_arrCharExcessAreaResult[m_intTemplateIndex] == null)
                                        m_arrCharExcessAreaResult[m_intTemplateIndex] = new int[intNumChars];

                                    if (m_arrCharExcessAreaResult[m_intTemplateIndex].Length != intNumChars)
                                        m_arrCharExcessAreaResult[m_intTemplateIndex] = new int[intNumChars];

                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 84");

                                    for (int a = 0; a < intNumChars; a++)
                                    {
                                        m_arrCharExcessAreaResult[m_intTemplateIndex][a] = 0;
                                    }

                                    if (blnWantDebug)
                                    {
                                        objSubtractCharROI.SaveImage("D:\\TS\\19.objSubtractCharROI.bmp");
                                    }

                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 85");

                                    int intExcessThreshold = intThresholdValue; // 2021-02-17 ZJYEOH : Use back mark threshold as excess mark will attach to mark

                                    if (m_blnSeparateExtraMarkThreshold)
                                    {
                                        if (m_blnWantExcessMarkThresholdFollowExtraMarkThreshold)
                                            intExcessThreshold = GetAutoThresholdExtraMark(objMarkPackageMarkROI);
                                    }

                                    if (ShowLiterationOnly)
                                    {
                                        obj_temp2.Dispose();
                                        obj_temp2 = new ImageDrawing();
                                        objSubtractCharROI.CopyToImage(ref obj_temp2);
                                    }

                                    if (BuildObject(m_objExcessBlobs[m_intTemplateIndex], objSubtractCharROI, false, true, intExcessThreshold, m_intMinArea, 1000000, 0x1F)) //intThresholdValue
                                    {
                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 86");

                                        int intNoExcessBlobs = m_objExcessBlobs[m_intTemplateIndex].ref_intNumSelectedObject;

                                        // Init blob data
                                        m_intExcessBlobResult[m_intTemplateIndex] = new int[intNoExcessBlobs];
                                        List<int> arrintMatchNo = new List<int>(intNoExcessBlobs);
                                        for (j = 0; j < intNoExcessBlobs; j++)
                                        {
                                            m_intExcessBlobResult[m_intTemplateIndex][j] = 0;
                                            arrintMatchNo.Add(-1);
                                        }
                                        float fExcessCenterX = 0.0f, fExcessCenterY = 0.0f;

                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 87");
                                        // Scan all subtracted blobs to check whether the blob has been fail in Extra Mark/Group Extra Mark checking above.(For extra mark in check area)
                                        for (int i = 0; i < intNoExcessBlobs; i++)
                                        {
                                            fExcessCenterX = m_objExcessBlobs[m_intTemplateIndex].ref_arrLimitCenterX[i];
                                            fExcessCenterY = m_objExcessBlobs[m_intTemplateIndex].ref_arrLimitCenterY[i];
                                            intArea = m_objExcessBlobs[m_intTemplateIndex].ref_arrArea[i];     // Get subtracted blob area                                                                                                                      // Get subtracted blob contour xy first point
                                            intContourX = m_objExcessBlobs[m_intTemplateIndex].ref_arrContourX[i];
                                            intContourY = m_objExcessBlobs[m_intTemplateIndex].ref_arrContourY[i];
                                            m_objExcessBlobs[m_intTemplateIndex].DisposeElement(i);

                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 88");
                                            // Make sure the subtracted blob pass min area requirement before consider it as excess mark
                                            // Use m_intMinArea as min area if m_intMinArea < 5, else use 5 as min area
                                            if (m_intMinArea < 5)
                                            {
                                                // skip checking if blob area lower than setting
                                                if (intArea <= m_intMinArea)
                                                {
                                                    continue;
                                                }
                                            }
                                            else
                                            {
                                                // skip checking if blob area lower than setting
                                                if (intArea <= 5)
                                                {
                                                    continue;
                                                }
                                            }

                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 89");
                                            // Make sure subtracted blob is in Char area before consider it as excess mark
                                            int intMatchNo = -1;
                                            List<int> arrSingleMatchNo = new List<int>();
                                            bool IsInExcessROIArea = false;
                                            for (j = 0; j < arrExcessStartX.Count; j++)
                                            {
                                                // 06-02-2020 JBTAN : for Bar Pin 1 Mark, skip if the extra/broken mark is at the end of both tip
                                                if (m_blnWantCheckBarPin1)
                                                {
                                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 90");
                                                    if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnIsBarPin1[j])
                                                    {
                                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 91");
                                                        if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrBarPin1Type[j] == 0)
                                                        {
                                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 92");
                                                            if ((fExcessCenterX > arrTemplateStartX[j] && fExcessCenterX < arrTemplateEndX[j]))
                                                                continue;
                                                        }
                                                        else
                                                        {
                                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 93");
                                                            if ((fExcessCenterY > arrTemplateStartY[j] && fExcessCenterY < arrTemplateEndY[j]))
                                                                continue;
                                                        }
                                                    }
                                                }

                                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 94");
                                                if (m_intExtraExcessMarkInspectionAreaCutMode == 0)
                                                {
                                                    if (fExcessCenterX > arrExcessStartX[j] && fExcessCenterX < arrExcessEndX[j] &&
                                                        fExcessCenterY > arrExcessStartY[j] && fExcessCenterY < arrExcessEndY[j])
                                                    {
                                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 95");
                                                        if (CheckWantInspectExcessMark(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMarkType[j]))
                                                        {
                                                            arrSingleMatchNo.Add(j);
                                                            intMatchNo = j;
                                                        }
                                                        IsInExcessROIArea = true;
                                                    }
                                                }
                                                else
                                                {
                                                    if (m_intExtraExcessMarkInspectionAreaCutMode == 1)
                                                    {
                                                        if ((m_intROIOffSetX + fExcessCenterX) > arrCharStartPoint_RotateTo0Deg[j].X && (m_intROIOffSetX + fExcessCenterX) < arrCharEndPoint_RotateTo0Deg[j].X &&
                                                            (m_intROIOffSetY + fExcessCenterY) > arrCharStartPoint_RotateTo0Deg[j].Y && (m_intROIOffSetY + fExcessCenterY) < arrCharEndPoint_RotateTo0Deg[j].Y)
                                                        {
                                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 95");
                                                            if (CheckWantInspectExcessMark(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMarkType[j]))
                                                            {
                                                                arrSingleMatchNo.Add(j);
                                                                intMatchNo = j;
                                                            }
                                                            IsInExcessROIArea = true;
                                                        }
                                                    }
                                                    else
                                                    {
                                                        if ((m_intROIOffSetX + fExcessCenterX) > (arrCharStartPoint_RotateTo0Deg[j].X - ((int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftX[j] + m_fCharROIOffsetX))) &&
                                                            (m_intROIOffSetX + fExcessCenterX) < (arrCharEndPoint_RotateTo0Deg[j].X + ((int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftX[j] + m_fCharROIOffsetX))) &&
                                                            (m_intROIOffSetY + fExcessCenterY) > (arrCharStartPoint_RotateTo0Deg[j].Y - ((int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftY[j] + m_fCharROIOffsetY))) &&
                                                            (m_intROIOffSetY + fExcessCenterY) < (arrCharEndPoint_RotateTo0Deg[j].Y + ((int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftY[j] + m_fCharROIOffsetY))))
                                                        {
                                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 95");
                                                            if (CheckWantInspectExcessMark(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMarkType[j]))
                                                            {
                                                                arrSingleMatchNo.Add(j);
                                                                intMatchNo = j;
                                                            }
                                                            IsInExcessROIArea = true;
                                                        }
                                                    }
                                                }
                                            }

                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 96");
                                            //If is bar pin 1, dont add to excess area
                                            if (!IsInExcessROIArea && (intFailOptionMask & 0x01) > 0)
                                            //if (!objOCV.IsInOcvCharArea(objContour, ref intMatchNo))
                                            {
                                                // 2019 08 01 - CCENG: If no group extra makr or single extra mark fail, mean this object is attached to mark.
                                                if (((intFailOptionMask & 0x0A) == 0) || ((m_intFailResultMask & 0x0A) > 0))
                                                {
                                                    continue;
                                                }

                                                // 31-07-3019 ZJYEOH : Consider as group extra mark if contours cannot hit within the character's area, because if straight skip the inspection and continue next blob, there will be some extra/excess mark undetected
                                                if ((intFailOptionMask & 0x08) > 0) // Check Group Extra Mark 
                                                {
                                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 97");
                                                    bool blnAdd = true;

                                                    //if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting[intMatchNo] == 0)
                                                    //{
                                                    //    blnAdd = false;
                                                    //}


                                                    if (blnAdd)
                                                    {
                                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 98");

                                                        m_intGroupExtraMarkArea[m_intTemplateIndex] += intArea;
                                                        m_intExcessBlobResult[m_intTemplateIndex][i] = 1;

                                                        if (m_intGroupExtraMarkArea[m_intTemplateIndex] > (int)Math.Round(objTemplateSetting.fGroupExtraMinArea))
                                                        {
                                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 99");
                                                            m_intExcessBlobResult[m_intTemplateIndex][i] = 2;

                                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 99b");

                                                            if (!blnGroupExtraMark)
                                                            {
                                                                m_intFailResultMask |= 0x08;

                                                                if (blnTestHandMade)
                                                                {
                                                                    if ((m_intFailResultMask_ForPreTest & 0x08) == 0)
                                                                        m_intFailResultMask_ForPreTest |= 0x08;
                                                                }

                                                                blnGroupExtraMark = true;

                                                                // Upgrade result from 1 to 2
                                                                for (j = 0; j < intNoExcessBlobs; j++)
                                                                {
                                                                    if (m_intExcessBlobResult[m_intTemplateIndex][j] == 1)
                                                                        m_intExcessBlobResult[m_intTemplateIndex][j] = 2;
                                                                }

                                                                for (j = 0; j < intNoSelectedBlobs; j++)
                                                                {
                                                                    if (m_intBlobResult[m_intTemplateIndex][j] == 1)
                                                                        m_intBlobResult[m_intTemplateIndex][j] = 2;
                                                                }
                                                            }

                                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 100");
                                                        }
                                                    }
                                                }
                                                continue;
                                            }

                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 101");
                                            arrintMatchNo[i] = intMatchNo;
                                            // Check Group Extra Mark
                                            if ((intFailOptionMask & 0x08) > 0 && (intFailOptionMask & 0x01) > 0)
                                            {
                                                bool blnAdd = true;
                                                if (intMatchNo >= 0 && intMatchNo < m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting.Count)
                                                {
                                                    if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting[intMatchNo] == 0)
                                                    {
                                                        blnAdd = false;
                                                    }
                                                }

                                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 102");
                                                if (blnAdd)
                                                {


                                                    m_intGroupExtraMarkArea[m_intTemplateIndex] += intArea;
                                                    m_intExcessBlobResult[m_intTemplateIndex][i] = 1;

                                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 103");

                                                    if (m_intGroupExtraMarkArea[m_intTemplateIndex] > (int)Math.Round(objTemplateSetting.fGroupExtraMinArea))
                                                    {
                                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 104");
                                                        m_intExcessBlobResult[m_intTemplateIndex][i] = 2;

                                                        if (!blnGroupExtraMark)
                                                        {
                                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 105");
                                                            m_intFailResultMask |= 0x08;

                                                            if (blnTestHandMade)
                                                            {
                                                                if ((m_intFailResultMask_ForPreTest & 0x08) == 0)
                                                                    m_intFailResultMask_ForPreTest |= 0x08;
                                                            }

                                                            blnGroupExtraMark = true;

                                                            // Upgrade result from 1 to 2
                                                            for (j = 0; j < intNoExcessBlobs; j++)
                                                            {
                                                                if (m_intExcessBlobResult[m_intTemplateIndex][j] == 1)
                                                                    m_intExcessBlobResult[m_intTemplateIndex][j] = 2;
                                                            }

                                                            for (j = 0; j < intNoSelectedBlobs; j++)
                                                            {
                                                                if (m_intBlobResult[m_intTemplateIndex][j] == 1)
                                                                    m_intBlobResult[m_intTemplateIndex][j] = 2;
                                                            }
                                                        }
                                                    }
                                                }
                                            }

                                            // Check Group Excess Mark
                                            if (((intFailOptionMask & 0x100) > 0) && m_blnWantCheckTotalExcessMark && (intFailOptionMask & 0x01) > 0)
                                            {
                                                bool blnAdd = IsInExcessROIArea;
                                                if (intMatchNo >= 0 && intMatchNo < m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting.Count)
                                                {
                                                    blnAdd = true;
                                                    if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting[intMatchNo] == 0)
                                                    {
                                                        blnAdd = false;
                                                    }
                                                }

                                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 102 - b");
                                                if (blnAdd)
                                                {


                                                    m_intGroupExcessMarkArea[m_intTemplateIndex] += intArea;
                                                    m_intExcessBlobResult[m_intTemplateIndex][i] = 1;

                                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 103 - b");

                                                    if (m_intGroupExcessMarkArea[m_intTemplateIndex] > (int)Math.Round(objTemplateSetting.fGroupExcessMinArea))
                                                    {
                                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 104 - b");
                                                        m_intExcessBlobResult[m_intTemplateIndex][i] = 2;

                                                        if (!blnGroupExcessMark)
                                                        {
                                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 105 - b");
                                                            m_intFailResultMask |= 0x2000;

                                                            if (blnTestHandMade)
                                                            {
                                                                if ((m_intFailResultMask_ForPreTest & 0x2000) == 0)
                                                                    m_intFailResultMask_ForPreTest |= 0x2000;
                                                            }

                                                            blnGroupExcessMark = true;

                                                            // Upgrade result from 1 to 2
                                                            for (j = 0; j < intNoExcessBlobs; j++)
                                                            {
                                                                if (m_intExcessBlobResult[m_intTemplateIndex][j] == 1)
                                                                    m_intExcessBlobResult[m_intTemplateIndex][j] = 2;
                                                            }

                                                            for (j = 0; j < intNoSelectedBlobs; j++)
                                                            {
                                                                if (m_intBlobResult[m_intTemplateIndex][j] == 1)
                                                                    m_intBlobResult[m_intTemplateIndex][j] = 2;
                                                            }
                                                        }
                                                    }
                                                }
                                            }

                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 106");
                                            if ((intFailOptionMask & 0x01) > 0 || m_blnWantUseExcessMissingMarkAffectScore)
                                            {
                                                for (j = 0; j < arrSingleMatchNo.Count; j++)
                                                {
                                                    if (!CheckWantInspectExcessMark(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMarkType[arrSingleMatchNo[j]]))
                                                        continue;

                                                    m_arrCharExcessAreaResult[m_intTemplateIndex][arrSingleMatchNo[j]] += intArea;
                                                }
                                            }
                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 107");
                                        }

                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 108");
                                        // 31-07-2019 ZJYEOH : Check Excess here so that the total excess area is correct for each mark
                                        for (int b = 0; b < m_arrCharExcessAreaResult[m_intTemplateIndex].Length; b++)
                                        {
                                            if (m_arrCharExcessAreaResult[m_intTemplateIndex][b] == 0 || !m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[b]  // 2020-08-11 ZJYEOH : Skip Excess if mark disabled
                                                || m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting[b] == 0) // 2020-08-11 ZJYEOH : Skip Excess if mark score setting = 0
                                            {
                                                // 2020-08-11 ZJYEOH : Set to 0 so that offline page will not display red color
                                                if (m_arrCharExcessAreaResult[m_intTemplateIndex][b] != 0)
                                                    m_arrCharExcessAreaResult[m_intTemplateIndex][b] = 0;
                                                continue;
                                            }
                                            // Make sure object area is higher than min area and extra min area
                                            if ((m_arrCharExcessAreaResult[m_intTemplateIndex][b] < m_intMinArea) ||
                                                (m_arrCharExcessAreaResult[m_intTemplateIndex][b] <= (int)Math.Round(objTemplateSetting.arrMaxExcessArea[b])) ||
                                                (intFailOptionMask & 0x01) == 0)
                                            {
                                                continue;
                                            }
                                            else
                                            {

                                                if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting[b] == 0)
                                                {
                                                    continue;
                                                }

                                                for (int c = 0; c < arrintMatchNo.Count; c++)
                                                {
                                                    if (arrintMatchNo[c] == b)
                                                        m_intExcessBlobResult[m_intTemplateIndex][c] = 2;
                                                }

                                                if ((m_intFailResultMask & 0x01) == 0)
                                                    m_intFailResultMask |= 0x01;

                                                if (blnTestHandMade)
                                                {
                                                    if ((m_intFailResultMask_ForPreTest & 0x01) == 0)
                                                        m_intFailResultMask_ForPreTest |= 0x01;
                                                }

                                            }
                                        }

                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 109");
                                    }
                                    objSubtractImage_Temp.Dispose();
                                }
                            }

                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 110");
                            //-------------------------------------- Check miss mark area ---------------------------------------
                            if (((intFailOptionMask & 0x10) > 0 && ((m_intFailResultMask & 0x01) == 0) || blnTestHandMade || m_blnWantUseExcessMissingMarkAffectScore) || ShowLiterationOnly)
                            {
                                // Copy rotated image to sample image
                                if (m_blnWhiteOnBlack)
                                    objBlackImage.CopyTo(ref m_objSampleImage);//objOcvRotatedImage //2021-07-06 ZJYEOH : Use Black Image so that background is not included
                                else
                                    objWhiteImage.CopyTo(ref m_objSampleImage);

                                ImageDrawing objSampleImage_Temp = new ImageDrawing(true, m_objSampleImage.ref_intImageWidth, m_objSampleImage.ref_intImageHeight);
                                objOcvRotatedImage.CopyTo(ref objSampleImage_Temp);
                                ImageDrawing objSampleImage_Temp2 = new ImageDrawing(true, m_objSampleImage.ref_intImageWidth, m_objSampleImage.ref_intImageHeight);
                                objOcvRotatedImage.CopyTo(ref objSampleImage_Temp2);
                                ROI objSubtractCharROI = new ROI();
                                objSubtractCharROI.AttachImage(m_objSampleImage);

                                if (blnTestHandMade)
                                    objOcvRotatedImage.CopyTo(m_objHandMadeImage);

                                System.Drawing.Point pStart, pEnd;
                                List<ImageDrawing> arrTemplateCharErodeImage = new List<ImageDrawing>();
                                List<ROI> arrTemplateCharErodeROI = new List<ROI>();

                                int intNumChars2 = objOCV.GetNumChars();

                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 111");

                                if (m_arrCharBrokenAreaResult[m_intTemplateIndex] == null)
                                    m_arrCharBrokenAreaResult[m_intTemplateIndex] = new int[intNumChars];

                                if (m_arrCharBrokenAreaResult[m_intTemplateIndex].Length != intNumChars)
                                    m_arrCharBrokenAreaResult[m_intTemplateIndex] = new int[intNumChars];

                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 112");
                                for (int a = 0; a < intNumChars; a++)
                                {
                                    m_arrCharBrokenAreaResult[m_intTemplateIndex][a] = 0;
                                }

                                List<float> arrMarkStartX = new List<float>();
                                List<float> arrMarkStartY = new List<float>();
                                List<float> arrMarkEndX = new List<float>();
                                List<float> arrMarkEndY = new List<float>();

                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 113");

                                for (int i = 0; i < intNumChars2; i++)
                                {
                                    //// 2020-08-11 ZJYEOH : Skip if the mark is disabled
                                    //if (!m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i])
                                    //    continue;

                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 114");


                                    //arrTemplateCharErodeROI.Add(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrTemplateCharErodeROI[i]);

                                    ImageDrawing objTemplateCharErodeImage = new ImageDrawing(true,
                                        m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrTemplateCharErodeROI[i].ref_ROIWidth,
                                        m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrTemplateCharErodeROI[i].ref_ROIHeight);

                                    m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrTemplateCharErodeROI[i].CopyToImage(ref objTemplateCharErodeImage);
                                    arrTemplateCharErodeImage.Add(objTemplateCharErodeImage);

                                    ROI objTemplateCharErodeROI = new ROI();
                                    objTemplateCharErodeROI.AttachImage(objTemplateCharErodeImage);
                                    objTemplateCharErodeROI.LoadROISetting(0, 0, objTemplateCharErodeImage.ref_intImageWidth, objTemplateCharErodeImage.ref_intImageHeight);
                                    arrTemplateCharErodeROI.Add(objTemplateCharErodeROI);


                                    //arrTemplateCharErodeROI[i].SaveImage("D:\\TS\\TemplateImage.bmp");
                                    //arrTemplateCharErodeROI[i].ref_ROI.TopParent.Save("D:\\TS\\TopParent.bmp");
#if (Debug_2_12 || Release_2_12)
                                    EasyImage.Threshold(arrTemplateCharErodeROI[i].ref_ROI, arrTemplateCharErodeROI[i].ref_ROI, (uint)intThresholdValue);
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                                    EasyImage.Threshold(arrTemplateCharErodeROI[i].ref_ROI, arrTemplateCharErodeROI[i].ref_ROI, intThresholdValue);
#endif

                                    pStart = objOCV.GetCharStartXY(i);
                                    pEnd = objOCV.GetCharEndXY(i);

                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 115");

                                    float fMinAddSizeX = (float)(arrTemplateCharErodeROI[i].ref_ROIWidth - (pEnd.X - pStart.X)) / 2;
                                    float fMinAddSizeY = (float)(arrTemplateCharErodeROI[i].ref_ROIHeight - (pEnd.Y - pStart.Y)) / 2;

                                    int intMinAddSizeStartX, intMinAddSizeStartY, intMinAddSizeEndX, intMinAddSizeEndY;
                                    if (fMinAddSizeX == (int)fMinAddSizeX)
                                    {
                                        intMinAddSizeStartX = (int)fMinAddSizeX;
                                        intMinAddSizeEndX = (int)fMinAddSizeX;
                                    }
                                    else
                                    {
                                        intMinAddSizeStartX = (int)Math.Ceiling(fMinAddSizeX);
                                        intMinAddSizeEndX = (int)Math.Floor(fMinAddSizeX);
                                    }

                                    if (fMinAddSizeY == (int)fMinAddSizeY)
                                    {
                                        intMinAddSizeStartY = (int)fMinAddSizeY;
                                        intMinAddSizeEndY = (int)fMinAddSizeY;
                                    }
                                    else
                                    {
                                        intMinAddSizeStartY = (int)Math.Ceiling(fMinAddSizeY);
                                        intMinAddSizeEndY = (int)Math.Floor(fMinAddSizeY);
                                    }

                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 116");

                                    ROI objSampleCharROI = new ROI();

                                    if ((m_intROIOffSetX + pStart.X - intMinAddSizeStartX) >= 0) //if ((pStart.X - intMinAddSizeStartX) >= 0)   // 2019 10 11 - CCENG: add m_intROIOffSetXY because objSampleCharROI attach to main Image.
                                        objSampleCharROI.ref_ROIPositionX = m_intROIOffSetX + pStart.X - intMinAddSizeStartX;
                                    else
                                        objSampleCharROI.ref_ROIPositionX = m_intROIOffSetX;

                                    if ((m_intROIOffSetY + pStart.Y - intMinAddSizeStartY) >= 0)  //if ((pStart.Y - intMinAddSizeStartY) >= 0)  // 2019 10 11 - CCENG: add m_intROIOffSetXY because objSampleCharROI attach to main Image.
                                        objSampleCharROI.ref_ROIPositionY = m_intROIOffSetY + pStart.Y - intMinAddSizeStartY;
                                    else
                                        objSampleCharROI.ref_ROIPositionY = m_intROIOffSetY;

                                    if ((pEnd.X + intMinAddSizeEndX * 2) < m_intImageWidth)
                                        objSampleCharROI.ref_ROIWidth = pEnd.X - pStart.X + intMinAddSizeStartX + intMinAddSizeEndX;
                                    else
                                        continue;
                                    if ((pEnd.Y + intMinAddSizeEndY * 2) < m_intImageHeight)
                                        objSampleCharROI.ref_ROIHeight = pEnd.Y - pStart.Y + intMinAddSizeStartY + intMinAddSizeEndY;
                                    else
                                        continue;

                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 117");

                                    // 2020 03 01 - CCENG: Attached to m_objSampleImage because objSampleCharROI will be Dilated when m_intMissingMarkInspectionMethod is 1. 
                                    //                   : Also Dilate and subtract's image source and destination can be same.          
                                    //objSampleCharROI.AttachImage(objImage);

                                    //2020-06-17 ZJYEOH : objSampleCharROI should attach another image as m_objSampleImage will be image processsed
                                    objSampleCharROI.AttachImage(objSampleImage_Temp);//m_objSampleImage

                                    objSubtractCharROI.LoadROISetting(objSampleCharROI.ref_ROIPositionX, objSampleCharROI.ref_ROIPositionY,
                                                                        objSampleCharROI.ref_ROIWidth, objSampleCharROI.ref_ROIHeight);

                                    if ((objSampleCharROI.ref_ROIWidth != arrTemplateCharErodeROI[i].ref_ROIWidth) ||
                                        (arrTemplateCharErodeROI[i].ref_ROIWidth != objSubtractCharROI.ref_ROIWidth))
                                        continue;

                                    if ((objSampleCharROI.ref_ROIHeight != arrTemplateCharErodeROI[i].ref_ROIHeight) ||
                                        (arrTemplateCharErodeROI[i].ref_ROIHeight != objSubtractCharROI.ref_ROIHeight))
                                        continue;

                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 118");

                                    arrMarkStartX.Add(objSubtractCharROI.ref_ROIPositionX - m_intROIOffSetX);
                                    arrMarkStartY.Add(objSubtractCharROI.ref_ROIPositionY - m_intROIOffSetY);
                                    arrMarkEndX.Add(objSubtractCharROI.ref_ROIPositionX + objSubtractCharROI.ref_ROIWidth - m_intROIOffSetX);
                                    arrMarkEndY.Add(objSubtractCharROI.ref_ROIPositionY + objSubtractCharROI.ref_ROIHeight - m_intROIOffSetY);

                                    if (!m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i] || !CheckWantInspectMissingMark(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMarkType[i]))
                                    {
                                        EasyImage.Oper(EArithmeticLogicOperation.Subtract, arrTemplateCharErodeROI[i].ref_ROI, arrTemplateCharErodeROI[i].ref_ROI, objSubtractCharROI.ref_ROI);
                                    }
                                    else
                                    {
                                        // 2020 08 30 - CCENG: Fix to use "thick on sample mark" bcos more stable and applicable for thin and thick mark.
                                        //if (m_intMissingMarkInspectionMethod == 0) // 2020 03 01 - CCENG: 0=Thin on Template Mark
                                        //{
                                        //    //2020-06-17 ZJYEOH : Image processing will be different for white on black and black one white
                                        //    if (m_blnWhiteOnBlack)
                                        //    {
                                        //        EasyImage.Oper(EArithmeticLogicOperation.Subtract, arrTemplateCharErodeROI[i].ref_ROI, objSampleCharROI.ref_ROI, objSubtractCharROI.ref_ROI);
                                        //    }
                                        //    else
                                        //    {
                                        //        EasyImage.Oper(EArithmeticLogicOperation.Invert, objSampleCharROI.ref_ROI, objSampleCharROI.ref_ROI);
                                        //        EasyImage.Oper(EArithmeticLogicOperation.Add, arrTemplateCharErodeROI[i].ref_ROI, objSampleCharROI.ref_ROI, objSubtractCharROI.ref_ROI);
                                        //        //2020-06-17 ZJYEOH : Invert back so that objSampleCharROI will not inverted if it is used again because inverted area may overlap another mark
                                        //        EasyImage.Oper(EArithmeticLogicOperation.Invert, objSampleCharROI.ref_ROI, objSampleCharROI.ref_ROI);
                                        //    }
                                        //}
                                        //else
                                        {
                                            if (m_intCompensateMarkDiffSizeMode == 1) //This method only apply to white on black unit
                                            {
                                                if (blnTestHandMade)
                                                {
                                                    if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i])
                                                    {
                                                        ROI objROI = new ROI();
                                                        ImageDrawing objImg = new ImageDrawing();
                                                        objBlackImage.CopyTo(ref objImg);
                                                        objROI.AttachImage(objImg);
                                                        objROI.LoadROISetting(objSampleCharROI.ref_ROIPositionX, objSampleCharROI.ref_ROIPositionY,
                                                                                    objSampleCharROI.ref_ROIWidth, objSampleCharROI.ref_ROIHeight);

                                                        objROI.AddWhiteCrossX();
                                                        EasyImage.DilateBox(objROI.ref_ROI);

                                                        //2020-06-17 ZJYEOH : Image processing will be different for white on black and black one white
                                                        if (m_blnWhiteOnBlack)
                                                        {
                                                            EasyImage.Oper(EArithmeticLogicOperation.Subtract, objSampleCharROI.ref_ROI, objROI.ref_ROI, objSampleCharROI.ref_ROI);
                                                        }
                                                        else
                                                        {
                                                            EasyImage.Oper(EArithmeticLogicOperation.Add, objSampleCharROI.ref_ROI, objROI.ref_ROI, objSampleCharROI.ref_ROI);
                                                        }
                                                        objROI.AttachImage(m_objHandMadeImage);
                                                        objSampleCharROI.CopyImage(ref objROI);
                                                        objROI.Dispose();
                                                        objImg.Dispose();
                                                    }
                                                }

                                                if (m_objMissingBlobs[m_intTemplateIndex] == null)
                                                    m_objMissingBlobs[m_intTemplateIndex] = new EBlobs();
                                                else
                                                    m_objMissingBlobs[m_intTemplateIndex].CleanAllBlobs();

                                                if (blnWantDebug)
                                                    arrTemplateCharErodeROI[i].SaveImage("D:\\TS\\100.TemplateROI.bmp");
                                                float fTemplateSizeX = 0, fTemplateSizeY = 0;
                                                float fTemplateCenterX = 0, fTemplateCenterY = 0;
                                                float fSampleSizeX1 = 0, fSampleSizeX12 = 0, fSampleSizeXTotal = 0;
                                                float fSampleSizeY1 = 0, fSampleSizeY12 = 0, fSampleSizeYTotal = 0;
                                                float fSampleCenterX1 = 0, fSampleCenterX12 = 0, fSampleCenterXTotal = 0;
                                                float fSampleCenterY1 = 0, fSampleCenterY12 = 0, fSampleCenterYTotal = 0;
                                                if (BuildObject(m_objMissingBlobs[m_intTemplateIndex], arrTemplateCharErodeROI[i], false, true, intThresholdValue, m_intMinArea, 1000000, 0x1F)) //255 - intThresholdValue
                                                {
                                                    fTemplateSizeX = m_objMissingBlobs[m_intTemplateIndex].ref_arrWidth[0];
                                                    fTemplateSizeY = m_objMissingBlobs[m_intTemplateIndex].ref_arrHeight[0];
                                                    fTemplateCenterX = m_objMissingBlobs[m_intTemplateIndex].ref_arrLimitCenterX[0];
                                                    fTemplateCenterY = m_objMissingBlobs[m_intTemplateIndex].ref_arrLimitCenterY[0];
                                                }

#if (Debug_2_12 || Release_2_12)
                                                EasyImage.Threshold(objSampleCharROI.ref_ROI, objSampleCharROI.ref_ROI, (uint)intThresholdValue);
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                                                EasyImage.Threshold(objSampleCharROI.ref_ROI, objSampleCharROI.ref_ROI, intThresholdValue);
#endif

                                                bool bWantSmoothSampleMark = false;
                                                if (bWantSmoothSampleMark)
                                                {
                                                    EasyImage.OpenBox(objSampleCharROI.ref_ROI, objSampleCharROI.ref_ROI, 1);
                                                }
                                                if (blnWantDebug)
                                                    objSampleCharROI.SaveImage("D:\\TS\\101.objSampleCharROI.bmp");
                                                m_objMissingBlobs[m_intTemplateIndex].CleanAllBlobs();
                                                if (BuildObject(m_objMissingBlobs[m_intTemplateIndex], objSampleCharROI, false, true, intThresholdValue, m_intMinArea, 1000000, 0x21F)) //255 - intThresholdValue
                                                {
                                                    fSampleSizeX1 = m_objMissingBlobs[m_intTemplateIndex].ref_arrWidth[0];
                                                    fSampleSizeY1 = m_objMissingBlobs[m_intTemplateIndex].ref_arrHeight[0];
                                                    fSampleCenterX1 = m_objMissingBlobs[m_intTemplateIndex].ref_arrLimitCenterX[0];
                                                    fSampleCenterY1 = m_objMissingBlobs[m_intTemplateIndex].ref_arrLimitCenterY[0];
                                                    fSampleSizeXTotal = m_objMissingBlobs[m_intTemplateIndex].ref_fTotalLimitWidth;
                                                    fSampleSizeYTotal = m_objMissingBlobs[m_intTemplateIndex].ref_fTotalLimitHeight;
                                                    fSampleCenterXTotal = m_objMissingBlobs[m_intTemplateIndex].ref_fTotalLimitCenterX;
                                                    fSampleCenterYTotal = m_objMissingBlobs[m_intTemplateIndex].ref_fTotalLimitCenterY;
                                                }

                                                //int intIterationX = (int)Math.Max(0,  fTemplateSizeX - fSampleSizeX) / 2;
                                                //int intIterationY = (int)Math.Max(0, fTemplateSizeY - fSampleSizeY) / 2;
                                                int intIterationX, intIterationY;
                                                float fSampleCenterX;
                                                float fSampleCenterY;
                                                float fDiffSizeX = fTemplateSizeX - fSampleSizeX1;
                                                if (Math.Abs(fTemplateSizeX - fSampleSizeX1) <= Math.Abs(fTemplateSizeX - fSampleSizeXTotal))
                                                {
                                                    fDiffSizeX = fTemplateSizeX - fSampleSizeX1;
                                                    fDiffSizeX += m_intCharErodeHalfWidth * 2;
                                                    fSampleCenterX = fSampleCenterX1;
                                                }
                                                else
                                                {
                                                    fDiffSizeX = fTemplateSizeX - fSampleSizeXTotal;
                                                    fDiffSizeX += m_intCharErodeHalfWidth * 2;
                                                    fSampleCenterX = fSampleCenterXTotal;
                                                }
                                                float fDiffSizeY = fTemplateSizeY - fSampleSizeY1;
                                                if (Math.Abs(fTemplateSizeY - fSampleSizeY1) <= Math.Abs(fTemplateSizeY - fSampleSizeYTotal))
                                                {
                                                    fDiffSizeY = fTemplateSizeY - fSampleSizeY1;
                                                    fDiffSizeY += m_intCharErodeHalfWidth * 2;
                                                    fSampleCenterY = fSampleCenterY1;
                                                }
                                                else
                                                {
                                                    fDiffSizeY = fTemplateSizeY - fSampleSizeYTotal;
                                                    fDiffSizeY += m_intCharErodeHalfWidth * 2;
                                                    fSampleCenterY = fSampleCenterYTotal;
                                                }

                                                if (fDiffSizeX == 0)
                                                    intIterationX = 0;
                                                else if (fDiffSizeX > 0)
                                                    intIterationX = (int)Math.Ceiling(fDiffSizeX / 2);
                                                else
                                                    intIterationX = (int)Math.Abs(Math.Floor(fDiffSizeX / 2));

                                                if (fDiffSizeY == 0)
                                                    intIterationY = 0;
                                                else if (fDiffSizeY > 0)
                                                    intIterationY = (int)Math.Ceiling(fDiffSizeY / 2);
                                                else
                                                    intIterationY = (int)Math.Abs(Math.Floor(fDiffSizeY / 2));

                                                if ((intIterationX < Math.Min(fTemplateSizeX, fTemplateSizeY) / 4) && (intIterationY < Math.Min(fTemplateSizeX, fTemplateSizeY) / 4))
                                                {
                                                    if (fDiffSizeX != 0 || fDiffSizeY != 0)
                                                    {
                                                        if (blnWantDebug)
                                                            arrTemplateCharErodeROI[i].SaveImage("D:\\TS\\102.TemplateROI.bmp");
                                                        if (fDiffSizeX >= 0 && fDiffSizeY >= 0)
                                                        {
                                                            int intIterationLimit = (int)Math.Ceiling(Math.Min(fTemplateSizeX, fTemplateSizeY) / 4 / 2 - 2);
                                                            intIterationX = Math.Min(intIterationX, intIterationLimit);
                                                            intIterationY = Math.Min(intIterationX, intIterationLimit);

                                                            if (intIterationX < 0)
                                                                intIterationX = 0;
                                                            if (intIterationY < 0)
                                                                intIterationY = 0;

#if (Debug_2_12 || Release_2_12)
                                                            EasyImage.ErodeBox(arrTemplateCharErodeROI[i].ref_ROI, arrTemplateCharErodeROI[i].ref_ROI, (uint)(intIterationX), (uint)(intIterationY));
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                                                            EasyImage.ErodeBox(arrTemplateCharErodeROI[i].ref_ROI, arrTemplateCharErodeROI[i].ref_ROI, (intIterationX), (intIterationY));
#endif

                                                            if (blnWantDebug)
                                                                arrTemplateCharErodeROI[i].SaveImage("D:\\TS\\103.TemplateROI.bmp");
                                                        }
                                                        else if (fDiffSizeX < 0 && fDiffSizeY < 0)
                                                        {
                                                            //EasyImage.DilateBox(arrTemplateCharErodeROI[i].ref_ROI, arrTemplateCharErodeROI[i].ref_ROI, (uint)intIterationX, (uint)intIterationY);
                                                            //arrTemplateCharErodeROI[i].SaveImage("D:\\TS\\104.TemplateROI.bmp");
                                                        }
                                                        else
                                                        {
                                                            if (fDiffSizeX > 0)
                                                            {
#if (Debug_2_12 || Release_2_12)
                                                                EasyImage.ErodeBox(arrTemplateCharErodeROI[i].ref_ROI, arrTemplateCharErodeROI[i].ref_ROI, (uint)(intIterationX), 0);
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                                                                EasyImage.ErodeBox(arrTemplateCharErodeROI[i].ref_ROI, arrTemplateCharErodeROI[i].ref_ROI, (intIterationX), 0);
#endif
                                                            }
                                                            //else if (fDiffSizeX < 0)
                                                            //    EasyImage.DilateBox(arrTemplateCharErodeROI[i].ref_ROI, arrTemplateCharErodeROI[i].ref_ROI, (uint)intIterationX, 0);

                                                            if (blnWantDebug)
                                                                arrTemplateCharErodeROI[i].SaveImage("D:\\TS\\105.TemplateROI.bmp");

                                                            if (fDiffSizeY > 0)
                                                            {
#if (Debug_2_12 || Release_2_12)
                                                                EasyImage.ErodeBox(arrTemplateCharErodeROI[i].ref_ROI, arrTemplateCharErodeROI[i].ref_ROI, 0, (uint)(intIterationY));
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                                                                EasyImage.ErodeBox(arrTemplateCharErodeROI[i].ref_ROI, arrTemplateCharErodeROI[i].ref_ROI, 0, (intIterationY));
#endif
                                                            }
                                                            //else if (fDiffSizeY < 0)
                                                            //    EasyImage.DilateBox(arrTemplateCharErodeROI[i].ref_ROI, arrTemplateCharErodeROI[i].ref_ROI, 0, (uint)intIterationY);

                                                            if (blnWantDebug)
                                                                arrTemplateCharErodeROI[i].SaveImage("D:\\TS\\106.TemplateROI.bmp");

                                                        }
                                                    }

                                                    // -------------------- Correct sample ROI position due to blob different size
                                                    objSampleCharROI.LoadROISetting(objSampleCharROI.ref_ROIPositionX + (int)(fSampleCenterX - fTemplateCenterX),
                                                        objSampleCharROI.ref_ROIPositionY + (int)(fSampleCenterY - fTemplateCenterY),
                                                        objSampleCharROI.ref_ROIWidth, objSampleCharROI.ref_ROIHeight);
                                                }
                                                else
                                                {
                                                    //2021-10-29 ZJYEOH: use back the iteration setting here
#if (Debug_2_12 || Release_2_12)
                                                    if (m_intCharErodeHalfWidth > 0)
                                                    {
                                                        if (m_blnWhiteOnBlack)
                                                            EasyImage.DilateBox(objSampleCharROI.ref_ROI, objSampleCharROI.ref_ROI, (uint)m_intCharErodeHalfWidth);
                                                        else
                                                            EasyImage.ErodeBox(objSampleCharROI.ref_ROI, objSampleCharROI.ref_ROI, (uint)m_intCharErodeHalfWidth);
                                                    }
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                                            if (m_intCharErodeHalfWidth > 0)
                                                {
                                                    if (m_blnWhiteOnBlack)
                                                        EasyImage.DilateBox(objSampleCharROI.ref_ROI, objSampleCharROI.ref_ROI, m_intCharErodeHalfWidth);
                                                    else
                                                        EasyImage.ErodeBox(objSampleCharROI.ref_ROI, objSampleCharROI.ref_ROI, m_intCharErodeHalfWidth);
                                                }
#endif
                                                }

                                                //2020-06-17 ZJYEOH : Image processing will be different for white on black and black one white
                                                if (m_blnWhiteOnBlack)
                                                {
                                                    //#if (Debug_2_12 || Release_2_12)
                                                    //                                                    EasyImage.Threshold(objSampleCharROI.ref_ROI, objSampleCharROI.ref_ROI, (uint)intThresholdValue);
                                                    //#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                                                    //                                    EasyImage.Threshold(objSampleCharROIref_ROI, objSampleCharROIref_ROI, intThresholdValue);
                                                    //#endif

                                                    EasyImage.Oper(EArithmeticLogicOperation.Subtract, arrTemplateCharErodeROI[i].ref_ROI, objSampleCharROI.ref_ROI, objSubtractCharROI.ref_ROI);
                                                }
                                                else
                                                {
                                                    //EasyImage.Oper(EArithmeticLogicOperation.Invert, objSampleCharROI.ref_ROI, objSampleCharROI.ref_ROI);
                                                    ROI.InvertOperationROI(objSampleCharROI);
                                                    EasyImage.Oper(EArithmeticLogicOperation.Add, arrTemplateCharErodeROI[i].ref_ROI, objSampleCharROI.ref_ROI, objSubtractCharROI.ref_ROI);
                                                    //2020-06-17 ZJYEOH : Invert back so that objSampleCharROI will not inverted if it is used again because inverted area may overlap another mark
                                                    //EasyImage.Oper(EArithmeticLogicOperation.Invert, objSampleCharROI.ref_ROI, objSampleCharROI.ref_ROI);
                                                    ROI.InvertOperationROI(objSampleCharROI);
                                                }
                                            }
                                            else
                                            {
                                                if (blnTestHandMade)
                                                {
                                                    if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i])
                                                    {
                                                        ROI objROI = new ROI();
                                                        ImageDrawing objImg = new ImageDrawing();
                                                        objBlackImage.CopyTo(ref objImg);
                                                        objROI.AttachImage(objImg);
                                                        objROI.LoadROISetting(objSampleCharROI.ref_ROIPositionX, objSampleCharROI.ref_ROIPositionY,
                                                                                    objSampleCharROI.ref_ROIWidth, objSampleCharROI.ref_ROIHeight);

                                                        objROI.AddWhiteCrossX();
                                                        EasyImage.DilateBox(objROI.ref_ROI, objROI.ref_ROI, 2);

                                                        //2020-06-17 ZJYEOH : Image processing will be different for white on black and black one white
                                                        if (m_blnWhiteOnBlack)
                                                        {
                                                            EasyImage.Oper(EArithmeticLogicOperation.Subtract, objSampleCharROI.ref_ROI, objROI.ref_ROI, objSampleCharROI.ref_ROI);
                                                        }
                                                        else
                                                        {
                                                            EasyImage.Oper(EArithmeticLogicOperation.Add, objSampleCharROI.ref_ROI, objROI.ref_ROI, objSampleCharROI.ref_ROI);
                                                        }
                                                        objROI.AttachImage(m_objHandMadeImage);
                                                        objSampleCharROI.CopyImage(ref objROI);
                                                        objROI.Dispose();
                                                        objImg.Dispose();
                                                    }
                                                }

                                                // 2020 03 01 - CCENG: m_intMissingMarkInspectionMethod == 0 mean thick on sample mark
#if (Debug_2_12 || Release_2_12)
                                                if (m_intCharErodeHalfWidth > 0)
                                                {
                                                    if (m_blnWhiteOnBlack)
                                                        EasyImage.DilateBox(objSampleCharROI.ref_ROI, objSampleCharROI.ref_ROI, (uint)m_intCharErodeHalfWidth);
                                                    else
                                                        EasyImage.ErodeBox(objSampleCharROI.ref_ROI, objSampleCharROI.ref_ROI, (uint)m_intCharErodeHalfWidth);
                                                }
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                                            if (m_intCharErodeHalfWidth > 0)
                                                {
                                                    if (m_blnWhiteOnBlack)
                                                        EasyImage.DilateBox(objSampleCharROI.ref_ROI, objSampleCharROI.ref_ROI, m_intCharErodeHalfWidth);
                                                    else
                                                        EasyImage.ErodeBox(objSampleCharROI.ref_ROI, objSampleCharROI.ref_ROI, m_intCharErodeHalfWidth);
                                                }
#endif

#if (Debug_2_12 || Release_2_12)
                                                EasyImage.Threshold(objSampleCharROI.ref_ROI, objSampleCharROI.ref_ROI, (uint)intThresholdValue);
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                                                    EasyImage.Threshold(objSampleCharROI.ref_ROI, objSampleCharROI.ref_ROI, intThresholdValue);
#endif

                                                //2020-06-17 ZJYEOH : Image processing will be different for white on black and black one white
                                                if (m_blnWhiteOnBlack)
                                                {
                                                    EasyImage.Oper(EArithmeticLogicOperation.Subtract, arrTemplateCharErodeROI[i].ref_ROI, objSampleCharROI.ref_ROI, objSubtractCharROI.ref_ROI);
                                                }
                                                else
                                                {
                                                    //EasyImage.Oper(EArithmeticLogicOperation.Invert, objSampleCharROI.ref_ROI, objSampleCharROI.ref_ROI);
                                                    ROI.InvertOperationROI(objSampleCharROI);
                                                    EasyImage.Oper(EArithmeticLogicOperation.Add, arrTemplateCharErodeROI[i].ref_ROI, objSampleCharROI.ref_ROI, objSubtractCharROI.ref_ROI);
                                                    //2020-06-17 ZJYEOH : Invert back so that objSampleCharROI will not inverted if it is used again because inverted area may overlap another mark
                                                    //EasyImage.Oper(EArithmeticLogicOperation.Invert, objSampleCharROI.ref_ROI, objSampleCharROI.ref_ROI);
                                                    ROI.InvertOperationROI(objSampleCharROI);
                                                }
                                            }
                                        }
                                    }

                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 119");

                                    if (blnWantDebug)
                                    {
                                        arrTemplateCharErodeROI[i].SaveImage("D:\\TS\\34.arrTemplateCharErodeROI[i]" + i.ToString() + ".bmp");
                                        objSampleCharROI.SaveImage("D:\\TS\\35.objSampleCharROI" + i.ToString() + ".bmp");
                                        objSubtractCharROI.SaveImage("D:\\TS\\36.objSubtractCharROI" + i.ToString() + ".bmp");
                                        m_objSampleImage.SaveImage("D:\\TS\\37.m_objSampleImage" + i.ToString() + ".bmp");
                                    }

                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 120");

                                    objSampleCharROI.Dispose();
                                }

                                if (blnTestHandMade)
                                    m_objHandMadeImage.SaveImage(strPreTestImagePath + "MissingMark.bmp");

                                //2020-06-23 ZJYEOH : if no check package size, pRotatedCenterPoint will be (-1, -1)
                                if (pRotatedCenterPoint != new PointF(-1, -1))
                                {
                                    m_objLocalTemporary_RotateSearchROI.AttachImage(m_objSampleImage);
                                    m_objLocalTemporary_RotateSearchROI.LoadROISetting((int)Math.Round(pRotatedCenterPoint.X - objMarkPackageSearchROI.ref_ROIWidth / 2, 0, MidpointRounding.AwayFromZero),
                                                                      (int)Math.Round(pRotatedCenterPoint.Y - objMarkPackageSearchROI.ref_ROIHeight / 2, 0, MidpointRounding.AwayFromZero),
                                                                      objMarkPackageSearchROI.ref_ROIWidth, objMarkPackageSearchROI.ref_ROIHeight);

                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 121");

                                    ROI.RotateROI(m_objLocalTemporary_RotateSearchROI, fPackageAngle - fMarkAngle, ref m_objSampleImage, 0);
                                }

                                if (blnWantDebug)
                                {
                                    m_objSampleImage.SaveImage("D:\\TS\\40m_objSampleImage.bmp");
                                }

                                objSubtractCharROI.AttachImage(m_objSampleImage);

                                if (blnWantDebug)
                                {
                                    objSubtractCharROI.SaveImage("D:\\TS\\41.objSubtractCharROI.bmp");
                                }

                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 122");
                                // Reload ROI size and placement to same location and same size as Mark ROI
                                objSubtractCharROI.LoadROISetting(m_intROIOffSetX, m_intROIOffSetY, objMarkPackageMarkROI.ref_ROIWidth, objMarkPackageMarkROI.ref_ROIHeight);

#if (Debug_2_12 || Release_2_12)
                                if (m_intCharOpenHalfWidth > 0)
                                    EasyImage.OpenBox(objSubtractCharROI.ref_ROI, objSubtractCharROI.ref_ROI, (uint)m_intCharOpenHalfWidth);
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)

                                if (m_intCharOpenHalfWidth > 0)
                                    EasyImage.OpenBox(objSubtractCharROI.ref_ROI, objSubtractCharROI.ref_ROI, m_intCharOpenHalfWidth);
#endif
                                if (m_objMissingBlobs[m_intTemplateIndex] == null)
                                    m_objMissingBlobs[m_intTemplateIndex] = new EBlobs();
                                else
                                    m_objMissingBlobs[m_intTemplateIndex].CleanAllBlobs();

                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 123");
                                if (blnWantDebug)
                                {
                                    objSubtractCharROI.SaveImage("D:\\TS\\42.objSubtractCharROI.bmp");
                                }

                                //2020-06-17 ZJYEOH : Threshold will invert for white on black
                                int intMissingThreshold = intThresholdValue;
                                if (m_blnWhiteOnBlack)
                                {
                                    // 2022 01 12 - CCENG: since template and sample are using binary image to subtract, so objSubtractCharROI will be binary image also. Mean can use any thresholdd value. 
                                    //intMissingThreshold = 255 - intThresholdValue;
                                }

                                if (ShowLiterationOnly)
                                {
                                    obj_temp.Dispose();
                                    obj_temp = new ImageDrawing();
                                    objSubtractCharROI.CopyToImage(ref obj_temp);
                                }

                                if (BuildObject(m_objMissingBlobs[m_intTemplateIndex], objSubtractCharROI, false, true, intMissingThreshold, 0, objSubtractCharROI.ref_ROIWidth * objSubtractCharROI.ref_ROIHeight + 1, 0x1F)) //255 - intThresholdValue
                                {
                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 124");
                                    int intNoMissingBlobs = m_objMissingBlobs[m_intTemplateIndex].ref_intNumSelectedObject;

                                    // Init blob data
                                    List<int> arrintMatchNo = new List<int>();
                                    m_intMissingBlobResult[m_intTemplateIndex] = new int[intNoMissingBlobs];
                                    for (j = 0; j < intNoMissingBlobs; j++)
                                    {
                                        m_intMissingBlobResult[m_intTemplateIndex][j] = 0;
                                    }

                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 125");

                                    for (int i = 0; i < intNoMissingBlobs; i++)
                                    {
                                        arrintMatchNo.Add(-1);

                                        intArea = m_objMissingBlobs[m_intTemplateIndex].ref_arrArea[i];     // Get subtracted blob area
                                        fCenterX = m_objMissingBlobs[m_intTemplateIndex].ref_arrLimitCenterX[i];
                                        fCenterY = m_objMissingBlobs[m_intTemplateIndex].ref_arrLimitCenterY[i];
                                        fWidth = m_objMissingBlobs[m_intTemplateIndex].ref_arrWidth[i];
                                        fHeight = m_objMissingBlobs[m_intTemplateIndex].ref_arrHeight[i];
                                        bool blnIsInOcvCharArea = false;

                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 126");
                                        int intMatchNo = -1;
                                        for (j = 0; j < arrMarkStartX.Count; j++)
                                        {
                                            // 2020 02 27 - CCENG: Check after loop.
                                            // 06-02-2020 JBTAN : for Bar Pin 1 Mark, skip if the extra/broken mark is at the end of both tip
                                            //if (m_blnWantCheckBarPin1)
                                            //{
                                            //    if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnIsBarPin1[j])
                                            //    {
                                            //        if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrBarPin1Type[j] == 0)
                                            //        {
                                            //            if ((fCenterX > arrExcessStartX[j] && fCenterX < arrExcessEndX[j]) &&
                                            //                (fCenterY < arrExcessStartY[j] || fCenterY > arrExcessEndY[j]))
                                            //                continue;
                                            //        }
                                            //        else
                                            //        {
                                            //            if ((fCenterY > arrExcessStartY[j] && fCenterY < arrExcessEndY[j]) &&
                                            //                (fCenterX < arrExcessStartX[j] || fCenterX > arrExcessEndX[j]))
                                            //                continue;
                                            //        }
                                            //    }
                                            //}

                                            //2022-01-09 ZJYEOH : This Size comparing condition need add m_intCharOpenHalfWidth as tolerance because if whole char is missing the defect after dilate sure will bigger than OCV size
                                            // Broken Mark area should always smaller than ocv mark roi. 
                                            if ((fWidth < (arrMarkEndX[j] - arrMarkStartX[j]) + m_intCharOpenHalfWidth + 2) &&
                                            (fHeight < (arrMarkEndY[j] - arrMarkStartY[j]) + m_intCharOpenHalfWidth + 2))
                                            {
                                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 127");
                                                // Broken Mark center point should always within ocv mark roi area.
                                                if (fCenterX > arrMarkStartX[j] && fCenterX < arrMarkEndX[j] &&
                                                    fCenterY > arrMarkStartY[j] && fCenterY < arrMarkEndY[j])
                                                {
                                                    //2021-07-07 ZJYEOH : No need meet min 2 corner points requirement as now built on black image
                                                    //// 2019 10 14 - CCENG: Broken Mark center point and at least 2 corner points must within ocv mark roi area. - This is because whole mark ROI image are blobs builded sometime outside char area will be build also and considered as broken if size are big. 
                                                    //int intCornerMatchCount = 0;

                                                    //if ((fCenterX - fWidth / 2) > arrMarkStartX[j] && (fCenterX - fWidth / 2) < arrMarkEndX[j] &&
                                                    //    (fCenterY - fHeight / 2) > arrMarkStartY[j] && (fCenterY - fHeight / 2) < arrMarkEndY[j])
                                                    //{
                                                    //    intCornerMatchCount++;
                                                    //}

                                                    //if ((fCenterX + fWidth / 2) > arrMarkStartX[j] && (fCenterX + fWidth / 2) < arrMarkEndX[j] &&
                                                    //    (fCenterY - fHeight / 2) > arrMarkStartY[j] && (fCenterY - fHeight / 2) < arrMarkEndY[j])
                                                    //{
                                                    //    intCornerMatchCount++;
                                                    //}

                                                    //if ((fCenterX + fWidth / 2) > arrMarkStartX[j] && (fCenterX + fWidth / 2) < arrMarkEndX[j] &&
                                                    //    (fCenterY + fHeight / 2) > arrMarkStartY[j] && (fCenterY + fHeight / 2) < arrMarkEndY[j])
                                                    //{
                                                    //    intCornerMatchCount++;
                                                    //}

                                                    //if ((fCenterX - fWidth / 2) > arrMarkStartX[j] && (fCenterX - fWidth / 2) < arrMarkEndX[j] &&
                                                    //    (fCenterY + fHeight / 2) > arrMarkStartY[j] && (fCenterY + fHeight / 2) < arrMarkEndY[j])
                                                    //{
                                                    //    intCornerMatchCount++;
                                                    //}

                                                    //if (intCornerMatchCount >= 2)
                                                    {
                                                        intMatchNo = j;
                                                        blnIsInOcvCharArea = true;
                                                        break;
                                                    }
                                                }
                                            }
                                        }

                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 129");
                                        if (blnIsInOcvCharArea) // 2019 04 13-CCENG: Only blob under Ocv Char Area will recorded.
                                        {
                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 130");
                                            // 2020 02 27 - CCENG: Move this checking to here.
                                            // 06-02-2020 JBTAN : for Bar Pin 1 Mark, skip if the extra/broken mark is at the end of both tip
                                            if (m_blnWantCheckBarPin1)
                                            {
                                                if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnIsBarPin1[j])
                                                {
                                                    if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrBarPin1Type[j] == 0)
                                                    {
                                                        // 2020 02 27 - CCENG: check x only because sometime the excess area will partially inside the bar.
                                                        //if ((fCenterX > arrExcessStartX[j] && fCenterX < arrExcessEndX[j]) &&
                                                        //    (fCenterY < arrExcessStartY[j] || fCenterY > arrExcessEndY[j]))
                                                        if (fCenterX > arrExcessStartX[j] && fCenterX < arrExcessEndX[j])
                                                            continue;
                                                    }
                                                    else
                                                    {
                                                        // 2020 02 27 - CCENG: check y only because sometime the excess area will partially inside the bar.
                                                        //if ((fCenterY > arrExcessStartY[j] && fCenterY < arrExcessEndY[j]) &&
                                                        //    (fCenterX < arrExcessStartX[j] || fCenterX > arrExcessEndX[j]))
                                                        if (fCenterY > arrExcessStartY[j] && fCenterY < arrExcessEndY[j])
                                                            continue;
                                                    }
                                                }
                                            }

                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 131");
                                            if (m_intSmallestMissingMarkArea[m_intTemplateIndex] == 0 || intArea < m_intSmallestMissingMarkArea[m_intTemplateIndex])
                                                m_intSmallestMissingMarkArea[m_intTemplateIndex] = intArea;

                                            if (m_intBiggestMissingMarkArea[m_intTemplateIndex] == 0 || intArea > m_intBiggestMissingMarkArea[m_intTemplateIndex])
                                                m_intBiggestMissingMarkArea[m_intTemplateIndex] = intArea;

                                            m_arrCharBrokenAreaResult[m_intTemplateIndex][intMatchNo] += intArea;

                                            arrintMatchNo[i] = intMatchNo;

                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 132");
                                        }


                                        //// Check whether the blob has been fail
                                        //for (j = 0; j < intNoSelectedBlobs; j++)
                                        //{
                                        //    if (m_intBlobResult[m_intTemplateIndex][j] == 2)
                                        //    {
                                        //        float fMissingCenterX, fMissingCenterY;
                                        //        fMissingCenterX = fMissingCenterY = 0.0f;

                                        //        fCenterX = m_objBlobs[m_intTemplateIndex].ref_arrLimitCenterX[j];
                                        //        fCenterY = m_objBlobs[m_intTemplateIndex].ref_arrLimitCenterY[j];
                                        //        m_objBlobs[m_intTemplateIndex].DisposeElement(j);

                                        //        fMissingCenterX = m_objMissingBlobs[m_intTemplateIndex].ref_arrLimitCenterX[i];
                                        //        fMissingCenterY = m_objMissingBlobs[m_intTemplateIndex].ref_arrLimitCenterY[i];

                                        //        if (fCenterX == fMissingCenterX && fCenterY == fMissingCenterY)
                                        //        {
                                        //            break;
                                        //        }
                                        //    }
                                        //}

                                        // The blob has been fail 
                                        //if (intNoSelectedBlobs != 0 && j != intNoSelectedBlobs)
                                        //{
                                        //    continue;
                                        //}



                                        //intArea = m_objMissingBlobs[m_intTemplateIndex].ref_arrArea[i];     // Get subtracted blob area // Get subtracted blob contour xy first point
                                        //bool blnIsInOcvCharArea = false;
                                        //if (!blnAuto || (blnAuto && (intArea > objTemplateSetting.intMissingMinArea)))  // 2018 10 08 - CCENG: For faster inspection during production test (blnAuto is true), if blob area small than MissingMinArea, then skip checking IsInOcvCharArea  
                                        //if (intArea > objTemplateSetting.intMissingMinArea)
                                        //{
                                        //    intContourX = m_objMissingBlobs[m_intTemplateIndex].ref_arrContourX[i];
                                        //    intContourY = m_objMissingBlobs[m_intTemplateIndex].ref_arrContourY[i];

                                        //    Contour objContour = new Contour();

                                        //    if (objContour.BuildContour(objSubtractCharROI, intContourX, intContourY, intThresholdValue, 4))
                                        //    {
                                        //        int intMatchCharNo = -1;

                                        //        if (objOCV.IsInOcvCharArea(objContour, ref intMatchCharNo))
                                        //        {
                                        //            blnIsInOcvCharArea = true;
                                        //            if (intArea > objTemplateSetting.intMissingMinArea)
                                        //            {
                                        //                m_blnCharResult[m_intTemplateIndex][intMatchCharNo] = false;

                                        //                m_intMissingBlobResult[m_intTemplateIndex][i] = 2;

                                        //                if ((m_intFailResultMask & 0x10) == 0)
                                        //                    m_intFailResultMask |= 0x10;
                                        //            }
                                        //        }
                                        //    }
                                        //}

                                        //if (blnIsInOcvCharArea) // 2019 04 13-CCENG: Only blob under Ocv Char Area will recorded.
                                        //{
                                        //    if (m_intSmallestMissingMarkArea[m_intTemplateIndex] == 0 || intArea < m_intSmallestMissingMarkArea[m_intTemplateIndex])
                                        //        m_intSmallestMissingMarkArea[m_intTemplateIndex] = intArea;

                                        //    if (m_intBiggestMissingMarkArea[m_intTemplateIndex] == 0 || intArea > m_intBiggestMissingMarkArea[m_intTemplateIndex])
                                        //        m_intBiggestMissingMarkArea[m_intTemplateIndex] = intArea;
                                        //}
                                    }

                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 133");

                                    for (int b = 0; b < m_arrCharBrokenAreaResult[m_intTemplateIndex].Length; b++)
                                    {
                                        if (m_arrCharBrokenAreaResult[m_intTemplateIndex][b] == 0 || !m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[b] // 2020-08-11 ZJYEOH : Skip Broken if mark disabled
                                              || m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting[b] == 0) // 2020-08-11 ZJYEOH : Skip Broken if mark score setting = 0
                                        {
                                            // 2020-08-11 ZJYEOH : Set to 0 so that offline page will not display red color
                                            if (m_arrCharBrokenAreaResult[m_intTemplateIndex][b] != 0)
                                                m_arrCharBrokenAreaResult[m_intTemplateIndex][b] = 0;
                                            continue;
                                        }
                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 134");

                                        // Make sure object area is higher than min area and broken min area
                                        //if ((m_arrCharBrokenAreaResult[m_intTemplateIndex][b] < m_intMinArea) ||
                                        //    (m_arrCharBrokenAreaResult[m_intTemplateIndex][b] <= (int)Math.Round(objTemplateSetting.arrMaxBrokenArea[b])))   // 2021 02 23 - CCENG: change from < to <= bcos == mean pass also
                                        if (m_arrCharBrokenAreaResult[m_intTemplateIndex][b] <= (int)Math.Round(objTemplateSetting.arrMaxBrokenArea[b]) || // 2021 02 23 - CCENG: change from < to <= bcos == mean pass also
                                            (intFailOptionMask & 0x10) == 0)   
                                        {
                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 135");
                                            continue;
                                        }
                                        else
                                        {
                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 136");
                                            if (m_intSmallestMissingMarkArea[m_intTemplateIndex] == 0 || m_arrCharBrokenAreaResult[m_intTemplateIndex][b] < m_intSmallestMissingMarkArea[m_intTemplateIndex])
                                                m_intSmallestMissingMarkArea[m_intTemplateIndex] = m_arrCharBrokenAreaResult[m_intTemplateIndex][b];

                                            if (m_intBiggestMissingMarkArea[m_intTemplateIndex] == 0 || m_arrCharBrokenAreaResult[m_intTemplateIndex][b] > m_intBiggestMissingMarkArea[m_intTemplateIndex])
                                                m_intBiggestMissingMarkArea[m_intTemplateIndex] = m_arrCharBrokenAreaResult[m_intTemplateIndex][b];

                                            for (int c = 0; c < arrintMatchNo.Count; c++)
                                            {
                                                if (arrintMatchNo[c] == b)
                                                    m_intMissingBlobResult[m_intTemplateIndex][c] = 2;
                                            }

                                            if ((m_intFailResultMask & 0x10) == 0)
                                                m_intFailResultMask |= 0x10;

                                            if (blnTestHandMade)
                                            {
                                                if ((m_intFailResultMask_ForPreTest & 0x10) == 0)
                                                    m_intFailResultMask_ForPreTest |= 0x10;
                                            }

                                        }
                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 138");
                                    }
                                }
                                objSampleImage_Temp.Dispose();
                                objSampleImage_Temp2.Dispose();
                                objSubtractCharROI.Dispose();

                                if (arrTemplateCharErodeImage != null)
                                {
                                    for (int i = 0; i < arrTemplateCharErodeImage.Count; i++)
                                    {
                                        arrTemplateCharErodeImage[i].Dispose();
                                        arrTemplateCharErodeImage[i] = null;
                                    }

                                    arrTemplateCharErodeImage.Clear();
                                    arrTemplateCharErodeImage = null;
                                }

                            }
                        }
                        objImage_Temp.Dispose();
                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 140");
                        #endregion ---------------------------------------------------------------------------------------------------------

                        if (m_blnWantUseExcessMissingMarkAffectScore)
                        {
                            // Check Char Score
                            int intSetValue;
                            float fSampleScore;
                            intNumChars = objOCV.GetNumChars();
                            for (int i = 0; i < intNumChars; i++)
                            {
                                // Formula 1 - written by Yeoh ///////////////////////////////////////////////////////////////////
                                //float fScore_Excess = Math.Min((float)Convert.ToDouble(m_arrCharExcessAreaResult[m_intTemplateIndex][i]) / m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharDividedLargestArea[i] * 50, 50);
                                //float fScore_Missing = Math.Min((float)Convert.ToDouble(m_arrCharBrokenAreaResult[m_intTemplateIndex][i]) / m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharDividedLargestArea[i] * 50, 50);

                                //float fScore_50Percent = 100 - fScore_Excess - fScore_Missing;

                                //if (fScore_50Percent < 0)
                                //    fScore_50Percent = 0;
                                //else if (fScore_50Percent > 100)
                                //    fScore_50Percent = 100;

                                //fScore_50Percent /= 2;

                                //if (fScore_50Percent < 0)
                                //    fScore_50Percent = 0;

                                // Formula 2 - written by CCENG ///////////////////////////////////////////////////////////////////
                                float fScore_Excess = Math.Min((float)Convert.ToDouble(m_arrCharExcessAreaResult[m_intTemplateIndex][i]) / m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharDividedLargestArea[i] * 100, 50);
                                float fScore_Missing = Math.Min((float)Convert.ToDouble(m_arrCharBrokenAreaResult[m_intTemplateIndex][i]) / m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharDividedLargestArea[i] * 100, 50);

                                float fScore_50Percent = 50 - fScore_Excess - fScore_Missing;

                                if (fScore_50Percent < 0)
                                    fScore_50Percent = 0;
                                else if (fScore_50Percent > 50)
                                    fScore_50Percent = 50;

                                ///////////////////////////////////////////////////////////////////////////////////////////////////

                                objOCV.SetCharScore_ExcessMissingAffectScore(i, fScore_50Percent, m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnIsBarPin1[i] && m_blnWantCheckBarPin1);

                                if (blnByPassUnit)
                                {
                                    intSetValue = intMinMarkScore;
                                }
                                else
                                {
                                    intSetValue = m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting[i];
                                }
                           
                                fSampleScore = objOCV.GetCharScore(i);
                                
                                // Fail if score lower than setting
                                if ((intSetValue > 0 && fSampleScore < intSetValue) && m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i])
                                {
                                    m_blnCharResult[m_intTemplateIndex][i] = false;
                                    if ((m_intFailResultMask & 0x100) == 0)
                                        m_intFailResultMask |= 0x100;

                                    if (blnTestHandMade)
                                    {
                                        if ((m_intFailResultMask_ForPreTest & 0x100) == 0)
                                            m_intFailResultMask_ForPreTest |= 0x100;
                                    }
                                }
                                else
                                {
                                    if (!arrCharFailOtherThanScore[i])
                                        m_blnCharResult[m_intTemplateIndex][i] = true;
                                }
                                
                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 18");
                            }
                        }

                        // Stop to test next template if return pass
                        if (m_intFailResultMask == 0)
                            break;

                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 141");
                        SkipInspection:
                        // Stop to test next template if not inspect all
                        if (!m_blnInspectAllTemplate)
                            break;

                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 142");
                        // Go to next template
                        intTemplateCount++;
                    }

                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 143");
                    timeout.Stop(); // ------------------- checking loop timeout ---------------------------------------------------
                    m_blnLock = false;
                    m_blnLockBlobs = false;

                    if (m_intFailResultMask > 0)
                        return false;
                    else
                        return true;
                }
            }
            catch (Exception ex)
            {
                // 2021 01 05 - CCENG: Need to set FailResultMask in order to fail the unit. 
                if ((m_intFailResultMask & 0x1000) == 0)
                    m_intFailResultMask |= 0x1000;

                if (blnTestHandMade)
                {
                    if ((m_intFailResultMask_ForPreTest & 0x1000) == 0)
                        m_intFailResultMask_ForPreTest |= 0x1000;
                }

                m_blnExtraSaveImageAndRecipeDueToException = true;
                m_blnLock = false;
                m_blnLockBlobs = false;
                //m_objTL.WriteLine("InspectOCVMark ex: " + ex.ToString());
                return false;
            }
        }
        public bool InspectOCVMark_NewMethodForMultiExcessMark_OcvAngleAndPackageAngle_NonRotate(bool blnAuto,
            ref ImageDrawing objImage, ImageDrawing objOcvRotatedImage,
            ROI objMarkOcvSearchROI, int intMarkOcvTrainROIWidth, int intMarkOcvTrainROIHeight,
            ROI objMarkPackageSearchROI, ROI objMarkPackageMarkROI,
            bool blnSkipExtraPadAndTextShiftedChecking, ImageDrawing objWhiteImage, ImageDrawing objBlackImage, bool blnWantCheckNoMark, bool blnContourCheck, bool blnWantCheckBrokenMark,
            PointF pRotatedCenterPoint, SizeF SPackageSize, float fPackageAngle, float fMarkAngle, int intInspectionMethod, int intInspectionAreaGrayValueSensitivity, int intBrightSensitivity,
            bool blnByPassUnit, int intMinMarkScore, List<float> arrDontCareLeadAreaStartX, List<float> arrDontCareLeadAreaStartY, List<float> arrDontCareLeadAreaEndX, List<float> arrDontCareLeadAreaEndY, List<int> arrDontCareLeadDirection,
            int intOrientationAngle, List<ROI> arrMarkDontCareROI, ImageDrawing objBlackWhiteTopImage, ImageDrawing objBlackWhiteRightImage, ImageDrawing objBlackWhiteBottomImage, ImageDrawing objBlackWhiteLeftImage, bool ShowLiterationOnly)
        {
            /*
             *  Reset previous inspection data
             *  Get true threshold
             *  Build objects
             *  OCV/OCR inspection
             *      - Check ref char
             *      - Check recognized char score
             *      - Check recognized char position
             *  Check Text Shifted
             *  Blobs Inspection : Extra Mark(Check Area, Uncheck Area, Group Area), Missing Mark, Broken Mark)
             *  Subtract Inspection : Extra Mark Char Area and Missing Mark
             * 
             * Note: blnSkipExtraPadAndTextShiftedChecking should set to true if WantGauge is false. 
             * The reason is without Gauge to measure unit edge, vision can't know the exact unit location. Without the unit location information, extra pad and text shifted cannot be detected as well. 
             */

            bool blnWantDebug = false;
            if (blnWantDebug)
            {
                objImage.SaveImage("D:\\TS\\objImage.bmp");
                objOcvRotatedImage.SaveImage("D:\\TS\\objOcvRotatedImage.bmp");
                objMarkOcvSearchROI.SaveImage("D:\\TS\\objMarkOcvSearchROI.bmp");
                objMarkPackageSearchROI.SaveImage("D:\\TS\\objMarkPackageSearchROI.bmp");
                objMarkPackageMarkROI.SaveImage("D:\\TS\\objMarkPackageMarkROI.bmp");
            }
            try
            {
                m_blnLock = true;
                m_strResultTrack = "";

                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 1");
                WaitEventDone(ref m_blnLockBlobs, false);
                //lock (m_objLockBlobs)
                {
                    m_blnLockBlobs = true;

                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 2");

                    // Init and reset all inspection data
                    int intNoSelectedBlobs = 0;
                    int intNumChars = 0;
                    int j;

                    ResetInspectionData(blnWantCheckNoMark);

                    for (int i = 0; i < m_arrOCV[m_intGroupIndex].Count; i++)
                        m_arrOCV[m_intGroupIndex][i].DeleteSample();

                    // Check valid image
                    if (objMarkPackageMarkROI.ref_ROI.Width == 0 || objMarkPackageMarkROI.ref_ROI.Height == 0)
                    {
                        if ((m_intFailResultMask & 0x1000) == 0)
                            m_intFailResultMask |= 0x1000;

                        m_strErrorMessage = "Mark ROI size is 0!";
                        m_blnLock = false;
                        m_blnLockBlobs = false;
                        return false;
                    }

                    int intTemplateCount = 0;

                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 3");

                    if (m_blnWantDontCareArea)
                    {
                        //keep test image in m_objDontCareBackupImage before modify with dont care pattern, so that can be reuse by other template dont care pattern
                        objImage.CopyTo(ref m_objDontCareBackupImage);
                    }

                    // ------------------- checking loop timeout ---------------------------------------------------
                    HiPerfTimer timeout = new HiPerfTimer();
                    timeout.Start();

                    // Loop from first template until last to do OCV inspection
                    while (intTemplateCount < m_arrOCV[m_intGroupIndex].Count)
                    {

                        // ------------------- checking loop timeout ---------------------------------------------------
                        if (timeout.Timing > 10000)
                        {
                            STTrackLog.WriteLine(">>>>>>>>>>>>> time out 801");
                            break;
                        }
                        // ---------------------------------------------------------------------------------------------

                        // Get selected template index
                        int intTemplateIndex;
                        if (m_blnInspectAllTemplate)
                        {
                            intTemplateIndex = (int)((m_intTemplatePriority >> (0x04 * intTemplateCount)) & 0x0F) - 1;

                            if ((m_intTemplateMask & (0x01 << intTemplateIndex)) > 0)
                                m_intTemplateIndex = intTemplateIndex;
                            else
                                goto SkipInspection;
                        }

                        // Reset error message and result mask
                        m_strErrorMessage = "";
                        m_intFailResultMask = 0;

                        // Get fix value threshold
                        int intThresholdValue = GetAutoThreshold(objMarkPackageMarkROI);

                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 4");

                        //2020-05-20 ZJYEOH : Use gray value threshold
                        if (intInspectionMethod == 1)
                            intThresholdValue = GetGrayValueThreshold(objMarkPackageMarkROI, intInspectionAreaGrayValueSensitivity, intBrightSensitivity);

                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 5");

                        // Get fail option mask (Each template has own fail option setting)
                        int intFailOptionMask = m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intFailOptionMask;

                        #region ------------- OCV Inspection --------------------------------------------------------------------------------

                        NOCV objOCV = m_arrOCV[m_intGroupIndex][m_intTemplateIndex];
                        TemplateSetting objTemplateSetting = m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex];

                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 6");

                        //for (int a = 0; a < m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrTemplateCharDilateROI.Count; a++)
                        //{
                        //    m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrTemplateCharDilateROI[a]
                        //}
                        float fMinTextOffsetAllowX = 0;
                        float fMinTextOffsetAllowY = 0;

                        for (int i = 0; i < objTemplateSetting.fCharShiftX.Count; i++)
                        {
                            if (i == 0)
                                fMinTextOffsetAllowX = ((int)Math.Round(objTemplateSetting.fCharShiftX[i] + m_fCharROIOffsetX));
                            else
                            {
                                if (fMinTextOffsetAllowX > ((int)Math.Round(objTemplateSetting.fCharShiftX[i] + m_fCharROIOffsetX)))
                                    fMinTextOffsetAllowX = ((int)Math.Round(objTemplateSetting.fCharShiftX[i] + m_fCharROIOffsetX));
                            }

                            if (i == 0)
                                fMinTextOffsetAllowY = ((int)Math.Round(objTemplateSetting.fCharShiftY[i] + m_fCharROIOffsetY));
                            else
                            {
                                if (fMinTextOffsetAllowY > ((int)Math.Round(objTemplateSetting.fCharShiftY[i] + m_fCharROIOffsetY)))
                                    fMinTextOffsetAllowY = ((int)Math.Round(objTemplateSetting.fCharShiftY[i] + m_fCharROIOffsetY));
                            }
                        }

                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 7");

                        //////objOCV.Inspect(m_objTL, objMarkOcvSearchROI, intThresholdValue, objMarkPackageMarkROI.ref_ROIPositionX,
                        //////    objMarkPackageMarkROI.ref_ROIPositionY, fMinTextOffsetAllowX, fMinTextOffsetAllowY, m_blnWantSampleAreaScore);

                        //////// Check Text Score
                        //////int intSetValue;

                        //////// Check Char Score
                        //////float fSampleScore;
                        //////intNumChars = objOCV.GetNumChars();
                        //////m_intHitCharCounter = new int[intNumChars];
                        //////m_blnCharResult[m_intTemplateIndex] = new bool[intNumChars];
                        //////for (int i = 0; i < intNumChars; i++)
                        //////{
                        //////    //// 24-07-2019 ZJYEOH : Skip if the mark is disabled
                        //////    //if (!m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i])
                        //////    //    continue;

                        //////    m_intHitCharCounter[i] = 0;

                        //////    intSetValue = m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting[i];
                        //////    fSampleScore = objOCV.GetCharScore(i);
                        //////    m_strResultTrack += ", CharScore=" + fSampleScore.ToString();

                        //////    // Fail if score lower than setting
                        //////    if ((intSetValue > 0 && fSampleScore < intSetValue) && m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i])
                        //////    {
                        //////        m_blnCharResult[m_intTemplateIndex][i] = false;
                        //////        if ((m_intFailResultMask & 0x100) == 0)
                        //////            m_intFailResultMask |= 0x100;
                        //////    }
                        //////    else
                        //////        m_blnCharResult[m_intTemplateIndex][i] = true;
                        //////}

                        //objMarkOcvSearchROI.SaveImage("D:\\objMarkOcvSearchROI1.bmp");
                        ////2020-06-17 ZJYEOH : Invert if black on white
                        //ImageDrawing objOCVImage = new ImageDrawing(true, objMarkOcvSearchROI.ref_ROI.TopParent.Width, objMarkOcvSearchROI.ref_ROI.TopParent.Height);
                        //if (!m_blnWhiteOnBlack)
                        //{
                        //    EasyImage.Oper(EArithmeticLogicOperation.Copy, objMarkOcvSearchROI.ref_ROI.TopParent, objOCVImage.ref_objMainImage);
                        //    ROI.InvertOperationROI(objMarkOcvSearchROI);
                        //    objMarkOcvSearchROI.ref_ROI.Detach();
                        //    objMarkOcvSearchROI.ref_ROI.Attach(objOCVImage.ref_objMainImage);
                        //    //EasyImage.Oper(EArithmeticLogicOperation.Invert, objMarkOcvSearchROI.ref_ROI, objMarkOcvSearchROI.ref_ROI);
                        //    ROI.InvertOperationROI(objMarkOcvSearchROI);
                        //}
                        //objMarkOcvSearchROI.SaveImage("D:\\objMarkOcvSearchROI2.bmp");

                        int intOCVThresholdValue = intThresholdValue;
                        ////2020-06-17 ZJYEOH : Invert threshold value if black on white
                        //if (!m_blnWhiteOnBlack)
                        //{
                        //    intOCVThresholdValue = 255 - intOCVThresholdValue;
                        //}

                        bool blnIsTextInsideMarkROI = objOCV.Inspect_First2(m_objTL, objMarkOcvSearchROI, objMarkPackageMarkROI, intOCVThresholdValue, objMarkPackageMarkROI.ref_ROIPositionX,
                               objMarkPackageMarkROI.ref_ROIPositionY, fMinTextOffsetAllowX, fMinTextOffsetAllowY, m_blnWantSampleAreaScore, m_intMarkScoreOffset, m_intMarkOriPositionScore,
                               intOrientationAngle + fMarkAngle, m_intMarkScoreMode);

                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 8");

                        bool[] arrCharFailOtherThanScore;

                        if (blnIsTextInsideMarkROI)
                        {
                            // Check Text Score
                            int intSetValue;

                            // 2019 07 16 - CCENG: Not need OCV Text Score Test -----------------------------
                            //int intNumTexts = objOCV.GetNumTexts();
                            //m_blnTextResult[m_intTemplateIndex] = new bool[intNumTexts];
                            //for (int i = 0; i < intNumTexts; i++)
                            //{
                            //    intSetValue = m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intTextMinScore;
                            //    m_arrTestMatchScore[m_intTemplateIndex] = objOCV.GetTextScore(i);

                            //    // Fail if score lower than setting
                            //    if (m_arrTestMatchScore[m_intTemplateIndex] < intSetValue)
                            //    {
                            //        m_blnTextResult[m_intTemplateIndex][i] = false;
                            //        if ((m_intFailResultMask & 0x200) == 0)
                            //            m_intFailResultMask |= 0x200;
                            //    }
                            //    else
                            //        m_blnTextResult[m_intTemplateIndex][i] = true;
                            //}
                            //m_blnTextResult[m_intTemplateIndex][i] = true;

                            // Check Char Score
                            float fSampleScore;
                            intNumChars = objOCV.GetNumChars();
                            m_intHitCharCounter = new int[intNumChars];
                            m_blnCharResult[m_intTemplateIndex] = new bool[intNumChars];
                            arrCharFailOtherThanScore = new bool[intNumChars];
                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 9");
                            for (int i = 0; i < intNumChars; i++)
                            {
                                //// 24-07-2019 ZJYEOH : Skip if the mark is disabled
                                //if (!m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i])
                                //    continue;

                                m_intHitCharCounter[i] = 0;

                                //intSetValue = m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting[i];
                                // 2020 08 01 - CCENG: Goodark customer request to check minimum mark score when press bypass button in IPM
                                if (blnByPassUnit)
                                {
                                    intSetValue = intMinMarkScore;
                                }
                                else
                                {
                                    intSetValue = m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting[i];
                                }

                                if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnIsBarPin1[i] && m_blnWantCheckBarPin1)
                                    objOCV.SetCharScore_BarPin1AffectScore(i);

                                fSampleScore = objOCV.GetCharScore(i);

                                m_strResultTrack += ", CharScore=" + fSampleScore.ToString();

                                // Fail if score lower than setting
                                if ((intSetValue > 0 && fSampleScore < intSetValue) && m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i])
                                {
                                    m_blnCharResult[m_intTemplateIndex][i] = false;
                                    if ((m_intFailResultMask & 0x100) == 0)
                                        m_intFailResultMask |= 0x100;
                                }
                                else
                                    m_blnCharResult[m_intTemplateIndex][i] = true;

                                //// Fail if AGV Percent lower than setting
                                //if (m_blnWantCheckMarkAverageGrayValue && ((intFailOptionMask & 0x200) > 0))
                                //{
                                //    if ((m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fMaxAGVPercent[i] > 0 && Math.Abs(objOCV.GetCharForeAreaSumPercent(i)) > m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fMaxAGVPercent[i]) && m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i])
                                //    {
                                //        arrCharFailOtherThanScore[i] = true;
                                //        if (m_blnCharResult[m_intTemplateIndex][i])
                                //            m_blnCharResult[m_intTemplateIndex][i] = false;
                                //        if ((m_intFailResultMask & 0x4000) == 0)
                                //            m_intFailResultMask |= 0x4000;
                                //    }
                                //}
                            }

                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 10");
                        }
                        else
                        {
                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 11");
                            // 2020 04 25 - CCENG: Sometime search ROI is too big until ocv inspection cannot find the mark even though the mark is there.
                            //              so need to narror the search ROI.
                            //              The narror search roi == mark roi + 10 or 1/4 or mark roi size.
                            ROI objNarrowMarkSearchROI = new ROI();
                            objNarrowMarkSearchROI.AttachImage(objMarkOcvSearchROI);
                            //int intAddXTolerance = Math.Min(10, objMarkPackageMarkROI.ref_ROIWidth / 4);
                            //int intAddYTolerance = Math.Min(10, objMarkPackageMarkROI.ref_ROIHeight / 4);
                            //objNarrowMarkSearchROI.LoadROISetting(objMarkPackageMarkROI.ref_ROIPositionX - intAddXTolerance,
                            //                                      objMarkPackageMarkROI.ref_ROIPositionY - intAddYTolerance,
                            //                                      objMarkPackageMarkROI.ref_ROIWidth + intAddXTolerance * 2,
                            //                                      objMarkPackageMarkROI.ref_ROIHeight + intAddYTolerance * 2);

                            // 2020 06 26   - CCENG: Need to make sure narror roi is bigger than ocv text size.
                            //              - Euresys error will display during ocv inspection if roi size smaller ocv text size 
                            //              - Then why cannot direct use ocv text size for narror roi size. bcos ocv text sometime too small compare to package size.
                            //              - 
                            //
                            int intTextWidth = 0, intTextHeight = 0;
                            int intTextStartX = 0, intTextStartY = 0, intTextEndX = 0, intTextEndY = 0;
                            objOCV.GetTextStartXY(0, ref intTextStartX, ref intTextStartY);
                            objOCV.GetTextEndXY(0, ref intTextEndX, ref intTextEndY);

                            if (intTextStartX != -1 && intTextStartY != -1 && intTextEndX != -1 && intTextEndY != -1)
                            {
                                int intMinX = int.MaxValue;
                                int intMaxX = 0;
                                int intMinY = int.MaxValue;
                                int intMaxY = 0;

                                if (intMinX > intTextStartX)
                                    intMinX = intTextStartX;

                                if (intMinX > intTextEndX)
                                    intMinX = intTextEndX;

                                if (intMaxX < intTextStartX)
                                    intMaxX = intTextStartX;

                                if (intMaxX < intTextEndX)
                                    intMaxX = intTextEndX;

                                if (intMinY > intTextStartY)
                                    intMinY = intTextStartY;

                                if (intMinY > intTextEndY)
                                    intMinY = intTextEndY;

                                if (intMaxY < intTextStartY)
                                    intMaxY = intTextStartY;

                                if (intMaxY < intTextEndY)
                                    intMaxY = intTextEndY;

                                intTextWidth = intMaxX - intMinX;
                                intTextHeight = intMaxY - intMinY;
                            }

                            //objOCV.GetTextSize(0, ref intTextWidth, ref intTextHeight);

                            int intBiggestSizeWidth;
                            int intBiggestSizeHeight;
                            int intAddXTolerance;
                            int intAddYTolerance;

                            if (intMarkOcvTrainROIWidth > objMarkPackageMarkROI.ref_ROIWidth)   // 2020 06 26 - CCENG: use mark train roi size if mark train roi size bigger than package size. (this happen sometime when unit half flip and package size is measured incorrectly.)
                            {
                                intBiggestSizeWidth = intMarkOcvTrainROIWidth;
                                if (intTextWidth > intBiggestSizeWidth)                         // 2020 06 26 - CCENG: use ocv text roi size if ocv text roi size bigger than mark train roi. (this happen when use multi template and user drag mark train roi with different size.
                                {
                                    intBiggestSizeWidth = intTextWidth + 4;
                                }

                                intAddXTolerance = (intBiggestSizeWidth - objMarkPackageMarkROI.ref_ROIWidth) / 2;
                            }
                            else if (intTextWidth > objMarkPackageMarkROI.ref_ROIWidth)         // 2020 06 26 - CCENG: use ocv text roi size if ocv text roi size bigger than mark train roi. (this happen when use multi template and user drag mark train roi with different size.
                            {
                                intBiggestSizeWidth = intTextWidth + 4;

                                intAddXTolerance = (intBiggestSizeWidth - objMarkPackageMarkROI.ref_ROIWidth) / 2;
                            }
                            else
                            {
                                intAddXTolerance = Math.Min(10, objMarkPackageMarkROI.ref_ROIWidth / 4);
                            }

                            if (intMarkOcvTrainROIHeight > objMarkPackageMarkROI.ref_ROIHeight) // 2020 06 26 - CCENG: use mark train roi size if mark train roi size bigger than package size. (this happen sometime when unit half flip and package size is measured incorrectly.)
                            {
                                intBiggestSizeHeight = intMarkOcvTrainROIHeight;
                                if (intTextHeight > intBiggestSizeHeight)                       // 2020 06 26 - CCENG: use ocv text roi size if ocv text roi size bigger than mark train roi. (this happen when use multi template and user drag mark train roi with different size.
                                {
                                    intBiggestSizeHeight = intTextHeight + 4;
                                }

                                intAddYTolerance = (intBiggestSizeHeight - objMarkPackageMarkROI.ref_ROIHeight) / 2;
                            }
                            else if (intTextHeight > objMarkPackageMarkROI.ref_ROIHeight)       // 2020 06 26 - CCENG: use ocv text roi size if ocv text roi size bigger than mark train roi. (this happen when use multi template and user drag mark train roi with different size.
                            {
                                intBiggestSizeHeight = intTextHeight + 4;

                                intAddYTolerance = (intBiggestSizeHeight - objMarkPackageMarkROI.ref_ROIHeight) / 2;
                            }
                            else
                            {
                                intAddYTolerance = Math.Min(10, objMarkPackageMarkROI.ref_ROIHeight / 4);
                            }

                            //2021-04-30 ZJYEOH : Limit to package ROI
                            if (SPackageSize.Width != -1 && SPackageSize.Height != -1 && pRotatedCenterPoint.X != -1 && pRotatedCenterPoint.X != -1)
                            {
                                int intStartX = objMarkPackageMarkROI.ref_ROIPositionX - intAddXTolerance;
                                int intStartY = objMarkPackageMarkROI.ref_ROIPositionY - intAddYTolerance;
                                int intWidth = objMarkPackageMarkROI.ref_ROIWidth + intAddXTolerance * 2;
                                int intHeight = objMarkPackageMarkROI.ref_ROIHeight + intAddYTolerance * 2;

                                int intTotalStartX = objMarkPackageMarkROI.ref_ROITotalX - intAddXTolerance;
                                int intTotalStartY = objMarkPackageMarkROI.ref_ROITotalY - intAddYTolerance;

                                int intOffsetX = 0;
                                int intOffsetY = 0;
                                int intOffsetWidth = 0;
                                int intOffsetHeight = 0;

                                float fPackageStartX = float.MaxValue;
                                float fPackageStartY = float.MaxValue;
                                float fPackageEndX = 0;
                                float fPackageEndY = 0;
                                List<PointF> arrPackagePoints = new List<PointF>();
                                float fnewX = 0, fnewY = 0;

                                fnewX = (float)((pRotatedCenterPoint.X) + (((pRotatedCenterPoint.X - (SPackageSize.Width / 2)) - pRotatedCenterPoint.X) * Math.Cos(fPackageAngle * Math.PI / 180)) - (((pRotatedCenterPoint.Y - (SPackageSize.Height / 2)) - pRotatedCenterPoint.Y) * Math.Sin(fPackageAngle * Math.PI / 180)));

                                fnewY = (float)((pRotatedCenterPoint.Y) + (((pRotatedCenterPoint.X - (SPackageSize.Width / 2)) - pRotatedCenterPoint.X) * Math.Sin(fPackageAngle * Math.PI / 180)) + (((pRotatedCenterPoint.Y - (SPackageSize.Height / 2)) - pRotatedCenterPoint.Y) * Math.Cos(fPackageAngle * Math.PI / 180)));

                                arrPackagePoints.Add(new PointF(fnewX, fnewY));

                                fnewX = (float)((pRotatedCenterPoint.X) + (((pRotatedCenterPoint.X + (SPackageSize.Width / 2)) - pRotatedCenterPoint.X) * Math.Cos(fPackageAngle * Math.PI / 180)) - (((pRotatedCenterPoint.Y - (SPackageSize.Height / 2)) - pRotatedCenterPoint.Y) * Math.Sin(fPackageAngle * Math.PI / 180)));

                                fnewY = (float)((pRotatedCenterPoint.Y) + (((pRotatedCenterPoint.X + (SPackageSize.Width / 2)) - pRotatedCenterPoint.X) * Math.Sin(fPackageAngle * Math.PI / 180)) + (((pRotatedCenterPoint.Y - (SPackageSize.Height / 2)) - pRotatedCenterPoint.Y) * Math.Cos(fPackageAngle * Math.PI / 180)));

                                arrPackagePoints.Add(new PointF(fnewX, fnewY));

                                fnewX = (float)((pRotatedCenterPoint.X) + (((pRotatedCenterPoint.X - (SPackageSize.Width / 2)) - pRotatedCenterPoint.X) * Math.Cos(fPackageAngle * Math.PI / 180)) - (((pRotatedCenterPoint.Y + (SPackageSize.Height / 2)) - pRotatedCenterPoint.Y) * Math.Sin(fPackageAngle * Math.PI / 180)));

                                fnewY = (float)((pRotatedCenterPoint.Y) + (((pRotatedCenterPoint.X - (SPackageSize.Width / 2)) - pRotatedCenterPoint.X) * Math.Sin(fPackageAngle * Math.PI / 180)) + (((pRotatedCenterPoint.Y + (SPackageSize.Height / 2)) - pRotatedCenterPoint.Y) * Math.Cos(fPackageAngle * Math.PI / 180)));

                                arrPackagePoints.Add(new PointF(fnewX, fnewY));

                                fnewX = (float)((pRotatedCenterPoint.X) + (((pRotatedCenterPoint.X + (SPackageSize.Width / 2)) - pRotatedCenterPoint.X) * Math.Cos(fPackageAngle * Math.PI / 180)) - (((pRotatedCenterPoint.Y + (SPackageSize.Height / 2)) - pRotatedCenterPoint.Y) * Math.Sin(fPackageAngle * Math.PI / 180)));

                                fnewY = (float)((pRotatedCenterPoint.Y) + (((pRotatedCenterPoint.X + (SPackageSize.Width / 2)) - pRotatedCenterPoint.X) * Math.Sin(fPackageAngle * Math.PI / 180)) + (((pRotatedCenterPoint.Y + (SPackageSize.Height / 2)) - pRotatedCenterPoint.Y) * Math.Cos(fPackageAngle * Math.PI / 180)));

                                arrPackagePoints.Add(new PointF(fnewX, fnewY));

                                for (int x = 0; x < arrPackagePoints.Count; x++)
                                {
                                    if (fPackageStartX > arrPackagePoints[x].X)
                                        fPackageStartX = arrPackagePoints[x].X;

                                    if (fPackageStartY > arrPackagePoints[x].Y)
                                        fPackageStartY = arrPackagePoints[x].Y;

                                    if (fPackageEndX < arrPackagePoints[x].X)
                                        fPackageEndX = arrPackagePoints[x].X;

                                    if (fPackageEndY < arrPackagePoints[x].Y)
                                        fPackageEndY = arrPackagePoints[x].Y;
                                }

                                if (intTotalStartX < fPackageStartX)
                                {
                                    intOffsetX = (int)Math.Round(fPackageStartX - intTotalStartX);
                                }

                                if (intTotalStartY < fPackageStartY)
                                {
                                    intOffsetY = (int)Math.Round(fPackageStartY - intTotalStartY);
                                }

                                if ((intTotalStartX + intOffsetX + intWidth) > fPackageEndX)
                                {
                                    intOffsetWidth = (int)Math.Round(fPackageEndX - (intTotalStartX + intOffsetX + intWidth));
                                }

                                if ((intTotalStartY + intOffsetY + intHeight) > fPackageEndY)
                                {
                                    intOffsetHeight = (int)Math.Round(fPackageEndY - (intTotalStartY + intOffsetY + intHeight));
                                }

                                objNarrowMarkSearchROI.LoadROISetting(intStartX + intOffsetX,
                                                                   intStartY + intOffsetY,
                                                                   intWidth + intOffsetWidth,
                                                                   intHeight + intOffsetHeight);

                                // 2021 08 18 - CCENG: Incase objNarrowMarkSearchROI size still smaller than OCV text ROI, then need to resetting the objNarrowMarkSearchROI again. (This happen when wrong orientation)
                                if (objNarrowMarkSearchROI.ref_ROIWidth < intTextWidth || objNarrowMarkSearchROI.ref_ROIHeight < intTextHeight)
                                {
                                    int intNewWidth = objNarrowMarkSearchROI.ref_ROIWidth;
                                    if (objNarrowMarkSearchROI.ref_ROIWidth < intTextWidth)
                                    {
                                        intNewWidth = intTextWidth + 4;
                                    }

                                    int intNewHeight = objNarrowMarkSearchROI.ref_ROIHeight;
                                    if (objNarrowMarkSearchROI.ref_ROIHeight < intTextHeight)
                                    {
                                        intNewHeight = intTextHeight + 4;
                                    }

                                    objNarrowMarkSearchROI.LoadROISetting(objNarrowMarkSearchROI.ref_ROIPositionX,
                                                                   objNarrowMarkSearchROI.ref_ROIPositionY,
                                                                   intNewWidth,
                                                                   intNewHeight);
                                }

                                //objNarrowMarkSearchROI.SaveImage("D:\\TS\\objNarrowMarkSearchROI" + m_intTemplateIndex.ToString() + ".bmp");
                                objOCV.Inspect(m_objTL, objNarrowMarkSearchROI, intOCVThresholdValue,//intThresholdValue,
                                    intAddXTolerance - intOffsetX, intAddYTolerance - intOffsetY,
                                    fMinTextOffsetAllowX, fMinTextOffsetAllowY, m_blnWantSampleAreaScore, intOrientationAngle + fMarkAngle);

                            }
                            else
                            {
                                objNarrowMarkSearchROI.LoadROISetting(objMarkPackageMarkROI.ref_ROIPositionX - intAddXTolerance,
                                                                      objMarkPackageMarkROI.ref_ROIPositionY - intAddYTolerance,
                                                                      objMarkPackageMarkROI.ref_ROIWidth + intAddXTolerance * 2,
                                                                      objMarkPackageMarkROI.ref_ROIHeight + intAddYTolerance * 2);

                                // 2021 08 18 - CCENG: Incase objNarrowMarkSearchROI size smaller than OCV text ROI, then need to resetting the objNarrowMarkSearchROI again.(This happen when wrong orientation)
                                if (objNarrowMarkSearchROI.ref_ROIWidth < intTextWidth || objNarrowMarkSearchROI.ref_ROIHeight < intTextHeight)
                                {
                                    int intNewWidth = objNarrowMarkSearchROI.ref_ROIWidth;
                                    if (objNarrowMarkSearchROI.ref_ROIWidth < intTextWidth)
                                    {
                                        intNewWidth = intTextWidth + 4;
                                    }

                                    int intNewHeight = objNarrowMarkSearchROI.ref_ROIHeight;
                                    if (objNarrowMarkSearchROI.ref_ROIHeight < intTextHeight)
                                    {
                                        intNewHeight = intTextHeight + 4;
                                    }

                                    objNarrowMarkSearchROI.LoadROISetting(objNarrowMarkSearchROI.ref_ROIPositionX,
                                                                   objNarrowMarkSearchROI.ref_ROIPositionY,
                                                                   intNewWidth,
                                                                   intNewHeight);
                                }

                                //objNarrowMarkSearchROI.SaveImage("D:\\TS\\objNarrowMarkSearchROI" + m_intTemplateIndex.ToString() + ".bmp");
                                objOCV.Inspect(m_objTL, objNarrowMarkSearchROI, intOCVThresholdValue,//intThresholdValue,
                                    intAddXTolerance, intAddYTolerance,
                                    fMinTextOffsetAllowX, fMinTextOffsetAllowY, m_blnWantSampleAreaScore, intOrientationAngle + fMarkAngle);

                            }
                            
                            objNarrowMarkSearchROI.Dispose();

                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 12");
                            // Check Text Score
                            int intSetValue;

                            // Check Char Score
                            float fSampleScore;
                            intNumChars = objOCV.GetNumChars();
                            m_intHitCharCounter = new int[intNumChars];
                            m_blnCharResult[m_intTemplateIndex] = new bool[intNumChars];
                            arrCharFailOtherThanScore = new bool[intNumChars];
                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 13");
                            for (int i = 0; i < intNumChars; i++)
                            {
                                //// 24-07-2019 ZJYEOH : Skip if the mark is disabled
                                //if (!m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i])
                                //    continue;
                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 14");
                                m_intHitCharCounter[i] = 0;
                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 15");
                                //intSetValue = m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting[i];
                                // 2020 08 01 - CCENG: Goodark customer request to check minimum mark score when press bypass button in IPM
                                if (blnByPassUnit)
                                {
                                    intSetValue = intMinMarkScore;
                                }
                                else
                                {
                                    intSetValue = m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting[i];
                                }

                                if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnIsBarPin1[i] && m_blnWantCheckBarPin1)
                                    objOCV.SetCharScore_BarPin1AffectScore(i);

                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 16");
                                fSampleScore = objOCV.GetCharScore(i);
                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 17");
                                m_strResultTrack += ", CharScore=" + fSampleScore.ToString();

                                // Fail if score lower than setting
                                if ((intSetValue > 0 && fSampleScore < intSetValue) && m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i])
                                {
                                    m_blnCharResult[m_intTemplateIndex][i] = false;
                                    if ((m_intFailResultMask & 0x100) == 0)
                                        m_intFailResultMask |= 0x100;
                                }
                                else
                                    m_blnCharResult[m_intTemplateIndex][i] = true;

                                //// Fail if AGV Percent lower than setting
                                //if (m_blnWantCheckMarkAverageGrayValue && ((intFailOptionMask & 0x200) > 0))
                                //{
                                //    if ((m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fMaxAGVPercent[i] > 0 && Math.Abs(objOCV.GetCharForeAreaSumPercent(i)) > m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fMaxAGVPercent[i]) && m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i])
                                //    {
                                //        arrCharFailOtherThanScore[i] = true;
                                //        if (m_blnCharResult[m_intTemplateIndex][i])
                                //            m_blnCharResult[m_intTemplateIndex][i] = false;
                                //        if ((m_intFailResultMask & 0x4000) == 0)
                                //            m_intFailResultMask |= 0x4000;
                                //    }
                                //}

                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 18");
                            }
                        }

                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 19");

                        //objOCVImage.Dispose();

                        #endregion ----------------------------------------------------------------------------------------------------------
                        if (m_blnWantCheckMarkAverageGrayValue && ((intFailOptionMask & 0x200) > 0))
                        {
                            // Init blob data
                            m_fAveGrayDiffBlobResult[m_intTemplateIndex] = new float[intNumChars];
                            
                            ROI objLineROI1 = new ROI();
                            ROI objLineROI2 = new ROI();
                            ROI objTempROI = new ROI();
                            ImageDrawing objImage_Temp2 = new ImageDrawing(true, objOcvRotatedImage.ref_intImageWidth, objOcvRotatedImage.ref_intImageHeight);
                            objLineROI1.AttachImage(objOcvRotatedImage);
                            //objLineROI2.AttachImage(objWhiteImage);
                            objTempROI.AttachImage(objImage_Temp2);
                            for (int i = 0; i < intNumChars; i++)
                            {
                                Point pStart = objOCV.GetCharStartXY(i);
                                Point pEnd = objOCV.GetCharEndXY(i);

                                float newSX = 0, newSY = 0, newEX = 0, newEY = 0;
                                Math2.GetNewXYAfterRotate_360deg(objMarkPackageMarkROI.ref_ROI.TotalOrgX + (pEnd.X + pStart.X) / 2, objMarkPackageMarkROI.ref_ROI.TotalOrgY + (pEnd.Y + pStart.Y) / 2, objMarkPackageMarkROI.ref_ROI.TotalOrgX + pStart.X, objMarkPackageMarkROI.ref_ROI.TotalOrgY + pStart.Y, -fMarkAngle, ref newSX, ref newSY);

                                Math2.GetNewXYAfterRotate_360deg(objMarkPackageMarkROI.ref_ROI.TotalOrgX + (pEnd.X + pStart.X) / 2, objMarkPackageMarkROI.ref_ROI.TotalOrgY + (pEnd.Y + pStart.Y) / 2, objMarkPackageMarkROI.ref_ROI.TotalOrgX + pEnd.X, objMarkPackageMarkROI.ref_ROI.TotalOrgY + pEnd.Y, -fMarkAngle, ref newEX, ref newEY);
                                pStart = new Point((int)Math.Round(newSX), (int)Math.Round(newSY));
                                pEnd = new Point((int)Math.Round(newEX), (int)Math.Round(newEY));

                                List<PointF> arrPoints = new List<PointF>();
                                arrPoints.Add(pStart);
                                arrPoints.Add(new Point(pStart.X + (pEnd.X - pStart.X), pStart.Y));
                                arrPoints.Add(new Point(pStart.X, pStart.Y + (pEnd.Y - pStart.Y)));
                                arrPoints.Add(pEnd);

                                PointF pTemp = new PointF();
                                Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
                                                                 arrPoints[0],
                                                                 (intOrientationAngle + fMarkAngle),
                                                                 ref pTemp);
                                arrPoints[0] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

                                Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
                                                                 arrPoints[1],
                                                                 (intOrientationAngle + fMarkAngle),
                                                                 ref pTemp);
                                arrPoints[1] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

                                Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
                                                                 arrPoints[2],
                                                                 (intOrientationAngle + fMarkAngle),
                                                                 ref pTemp);
                                arrPoints[2] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

                                Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
                                                                 arrPoints[3],
                                                                 (intOrientationAngle + fMarkAngle),
                                                                 ref pTemp);
                                arrPoints[3] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

                                float fMinX = float.MaxValue;
                                float fMinY = float.MaxValue;
                                float fMaxX = 0;
                                float fMaxY = 0;
                                for (int a = 0; a < arrPoints.Count; a++)
                                {
                                    if (fMinX > arrPoints[a].X)
                                        fMinX = arrPoints[a].X;

                                    if (fMinY > arrPoints[a].Y)
                                        fMinY = arrPoints[a].Y;

                                    if (fMaxX < arrPoints[a].X)
                                        fMaxX = arrPoints[a].X;

                                    if (fMaxY < arrPoints[a].Y)
                                        fMaxY = arrPoints[a].Y;
                                }

                                objLineROI1.LoadROISetting((int)Math.Round(fMinX), (int)Math.Round(fMinY),
                                   (int)Math.Round(fMaxX - fMinX), (int)Math.Round(fMaxY - fMinY));

                                objLineROI2.LoadROISetting((int)Math.Round(fMinX), (int)Math.Round(fMinY),
                                   (int)Math.Round(fMaxX - fMinX), (int)Math.Round(fMaxY - fMinY));

                                objTempROI.LoadROISetting((int)Math.Round(fMinX), (int)Math.Round(fMinY),
                                   (int)Math.Round(fMaxX - fMinX), (int)Math.Round(fMaxY - fMinY));

                                objLineROI2.AttachImage(objBlackImage);
                                objLineROI2.CopyImage(ref objTempROI);

                                if (m_blnWhiteOnBlack)
                                {
                                    DontCareWithoutRotateImage.ProduceImage_WithoutLoopMaxPoints(arrPoints, objTempROI, objImage_Temp2
                                    , objBlackWhiteTopImage, objBlackWhiteRightImage, objBlackWhiteBottomImage, objBlackWhiteLeftImage, true);
                                }
                                else
                                {
                                    DontCareWithoutRotateImage.ProduceImage_WithoutLoopMaxPoints(arrPoints, objTempROI, objImage_Temp2
                                    , objBlackWhiteTopImage, objBlackWhiteRightImage, objBlackWhiteBottomImage, objBlackWhiteLeftImage, false);
                                }

                                if (m_blnWhiteOnBlack)
                                    EasyImage.Oper(EArithmeticLogicOperation.Subtract, objLineROI1.ref_ROI, objTempROI.ref_ROI, objTempROI.ref_ROI);
                                else
                                    EasyImage.Oper(EArithmeticLogicOperation.Add, objLineROI1.ref_ROI, objTempROI.ref_ROI, objTempROI.ref_ROI);

                                if (blnWantDebug)
                                {
                                    objImage_Temp2.SaveImage("D:\\TS\\objImage_Temp2" + i + ".bmp");
                                    objTempROI.SaveImage("D:\\TS\\objTempROI" + i + ".bmp");
                                    objLineROI1.SaveImage("D:\\TS\\objLineROI" + i + ".bmp");
                                }

                                //ImageDrawing objThresholdImage = new ImageDrawing(true, objTempROI.ref_ROIWidth, objTempROI.ref_ROIHeight);
                                //ROI objThresholdROI = new ROI();
                                //objThresholdROI.AttachImage(objThresholdImage);
                                //objThresholdROI.LoadROISetting(0, 0, objTempROI.ref_ROIWidth, objTempROI.ref_ROIHeight);
                                //float fAverageGrayValue = 0;
                                //EasyImage.PixelAverage(objLineROI1.ref_ROI, objTempROI.ref_ROI, out fAverageGrayValue);
                                //EasyImage.Threshold(objTempROI.ref_ROI, objThresholdROI.ref_ROI, (uint)Math.Round(fAverageGrayValue));
                                //if (blnWantDebug)
                                //    objThresholdROI.SaveImage("D:\\TS\\objThresholdROI" + i + ".bmp");
                                //EasyImage.PixelAverage(objTempROI.ref_ROI, objThresholdROI.ref_ROI, out fAverageGrayValue);

                                //objThresholdImage.Dispose();
                                //objThresholdROI.Dispose();

                                //m_fAveGrayDiffBlobResult[m_intTemplateIndex][i] = Math.Abs((float)Math.Round(fAverageGrayValue, 2) - m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fAverageGray[i]);

                                if (m_objAveGrayBlobs[m_intTemplateIndex].BuildObjects_Filter_GetElement(objTempROI, !m_blnWhiteOnBlack, false, 0, intThresholdValue, 0, objTempROI.ref_ROIWidth * objTempROI.ref_ROIHeight + 1, false, 0x800) > 0)
                                {
                                    //m_fAveGrayDiffBlobResult[m_intTemplateIndex][i] = Math.Abs((float)Math.Round(m_objAveGrayBlobs[m_intTemplateIndex].ref_arrAverageGray[0], 2) - m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fAverageGray[i]);
                                    if ((float)Math.Round(m_objAveGrayBlobs[m_intTemplateIndex].ref_arrAverageGray[0], 2) < m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fAverageGray[i])
                                        m_fAveGrayDiffBlobResult[m_intTemplateIndex][i] = Math.Abs((float)Math.Round(m_objAveGrayBlobs[m_intTemplateIndex].ref_arrAverageGray[0], 2) - m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fAverageGray[i]);
                                    else
                                        m_fAveGrayDiffBlobResult[m_intTemplateIndex][i] = 0;
                                }
                                else
                                    m_fAveGrayDiffBlobResult[m_intTemplateIndex][i] = -999;

                                // Fail if AGV Percent lower than setting
                                if (m_fAveGrayDiffBlobResult[m_intTemplateIndex][i] != -999 && (m_fAveGrayDiffBlobResult[m_intTemplateIndex][i] > m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fMaxAGVPercent[i]) && m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i])
                                {
                                    arrCharFailOtherThanScore[i] = true;
                                    if (m_blnCharResult[m_intTemplateIndex][i])
                                        m_blnCharResult[m_intTemplateIndex][i] = false;
                                    if ((m_intFailResultMask & 0x4000) == 0)
                                        m_intFailResultMask |= 0x4000;

                                }
                            }
                            objTempROI.Dispose();
                            objLineROI1.Dispose();
                            objLineROI2.Dispose();
                            objImage_Temp2.Dispose();
                        }
                        #region ----------------------------- Check Text Shifted ------------------------------------------------------------
                        if (!blnSkipExtraPadAndTextShiftedChecking && ((intFailOptionMask & 0x40) > 0))      // Want Gauge
                        {
                            if (!CheckTextShifted(0, 0, objMarkPackageMarkROI.ref_ROIWidth, objMarkPackageMarkROI.ref_ROIHeight))
                            {
                                m_intFailResultMask |= 0x40;
                            }
                        }
                        #endregion ---------------------------------------------------------------------------------------------------------
                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 20");

                        // Subtract dont care area according to template (Each template has own dont care setting)
                        if (m_blnWantDontCareArea)
                        {
                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 21");
                            //m_objDontCareBackupImage.CopyTo(ref objImage);
                            objMarkPackageSearchROI.AttachImage(m_objDontCareBackupImage);//objImage
                            //Point pMarkROIStartPoint = new Point(objMarkPackageMarkROI.ref_ROIPositionX, objMarkPackageMarkROI.ref_ROIPositionY);
                            int intOffsetX = 0;// (int)Math.Round(Math.Abs(objMarkPackageMarkROI.ref_ROIWidth - m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].objLearnDilateImage.ref_intImageWidth) / 2f);
                            int intOffsetY = 0;//(int)Math.Round(Math.Abs(objMarkPackageMarkROI.ref_ROIHeight - m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].objLearnDilateImage.ref_intImageHeight) / 2f);
                            ROI objDontCareROI = new ROI();
                            //objDontCareROI.LoadROISetting(0, 0, objMarkPackageMarkROI.ref_ROIWidth, objMarkPackageMarkROI.ref_ROIHeight);
                            //objDontCareROI.AttachImage(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].objDontCareImage);
                            //objDontCareROI.SaveImage("D:\\objDontCareROI1.bmp");
                            //ImageDrawing objImgDontCare = new ImageDrawing(true, m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].objDontCareImage.ref_intImageWidth, m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].objDontCareImage.ref_intImageHeight);
                            //ROI.Rotate0Degree_Better(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].objDontCareImage, objDontCareROI, -fMarkAngle, 4, ref objImgDontCare);
                            //objDontCareROI.AttachImage(objImgDontCare);
                            //objDontCareROI.SaveImage("D:\\objDontCareROI12.bmp");
                            //objMarkPackageMarkROI.LoadROISetting(objMarkPackageMarkROI.ref_ROIPositionX + intOffsetX, objMarkPackageMarkROI.ref_ROIPositionY + intOffsetY, objMarkPackageMarkROI.ref_ROIWidth, objMarkPackageMarkROI.ref_ROIHeight);
                            ////2020-06-17 ZJYEOH : Subtract or Add depends on white on black or black on white
                            //if (m_blnWhiteOnBlack)
                            //    ROI.SubtractROI(objMarkPackageMarkROI, objDontCareROI);
                            //else
                            //    ROI.LogicOperationAddROI(objMarkPackageMarkROI, objDontCareROI);
                            //objMarkPackageMarkROI.LoadROISetting(objMarkPackageMarkROI.ref_ROIPositionX - intOffsetX, objMarkPackageMarkROI.ref_ROIPositionY - intOffsetY, objMarkPackageMarkROI.ref_ROIWidth, objMarkPackageMarkROI.ref_ROIHeight);

                            ImageDrawing objImgDontCare = new ImageDrawing(true, m_objDontCareBackupImage.ref_intImageWidth, m_objDontCareBackupImage.ref_intImageHeight);
                            ImageDrawing objImgDontCare_Rotated = new ImageDrawing(true, m_objDontCareBackupImage.ref_intImageWidth, m_objDontCareBackupImage.ref_intImageHeight);
                            objBlackImage.CopyTo(ref objImgDontCare);
                            ROI objOriROI = new ROI();
                            for (int i = 0; i < arrMarkDontCareROI.Count; i++)
                            {
                                objOriROI.AttachImage(objImgDontCare);

                                objDontCareROI.AttachImage(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrDontCareImage[i]);// objWhiteImage

                                objOriROI.LoadROISetting(objMarkPackageMarkROI.ref_ROITotalCenterX - arrMarkDontCareROI[i].ref_intStartOffsetX,
                                                         objMarkPackageMarkROI.ref_ROITotalCenterY - arrMarkDontCareROI[i].ref_intStartOffsetY,
                                                         arrMarkDontCareROI[i].ref_ROIWidth, arrMarkDontCareROI[i].ref_ROIHeight);

                                objDontCareROI.LoadROISetting(objMarkPackageMarkROI.ref_ROITotalCenterX - arrMarkDontCareROI[i].ref_intStartOffsetX,
                                                              objMarkPackageMarkROI.ref_ROITotalCenterY - arrMarkDontCareROI[i].ref_intStartOffsetY,
                                                              arrMarkDontCareROI[i].ref_ROIWidth, arrMarkDontCareROI[i].ref_ROIHeight);

                                //if (m_blnWhiteOnBlack)
                                //    ROI.SubtractROI(objOriROI, objDontCareROI);
                                //else
                                ROI.LogicOperationAddROI(objOriROI, objDontCareROI);
                                //objImage.SaveImage("D:\\objImage.bmp");
                                //objMarkPackageMarkROI.SaveImage("D:\\objMarkPackageMarkROI" + i.ToString() + ".bmp");
                                //objImgDontCare.SaveImage("D:\\objImgDontCare" + i.ToString() + ".bmp");
                            }
                            objOriROI.Dispose();

                            objMarkPackageMarkROI.LoadROISetting(objMarkPackageMarkROI.ref_ROIPositionX + intOffsetX, objMarkPackageMarkROI.ref_ROIPositionY + intOffsetY, objMarkPackageMarkROI.ref_ROIWidth, objMarkPackageMarkROI.ref_ROIHeight);
                            objDontCareROI.LoadROISetting(objMarkPackageMarkROI.ref_ROITotalX + intOffsetX, objMarkPackageMarkROI.ref_ROITotalY + intOffsetY, objMarkPackageMarkROI.ref_ROIWidth, objMarkPackageMarkROI.ref_ROIHeight);
                            ROI.Rotate0Degree_Better(objImgDontCare, objDontCareROI, -fMarkAngle, 4, ref objImgDontCare_Rotated);
                            objDontCareROI.AttachImage(objImgDontCare_Rotated);
                            //objImgDontCare_Rotated.SaveImage("D:\\objImgDontCare_Rotated.bmp");
                            //objDontCareROI.SaveImage("D:\\objDontCareROI.bmp");
                            if (m_blnWhiteOnBlack)
                                ROI.SubtractROI(objMarkPackageMarkROI, objDontCareROI);
                            else
                                ROI.LogicOperationAddROI(objMarkPackageMarkROI, objDontCareROI);
                            objMarkPackageMarkROI.LoadROISetting(objMarkPackageMarkROI.ref_ROIPositionX - intOffsetX, objMarkPackageMarkROI.ref_ROIPositionY - intOffsetY, objMarkPackageMarkROI.ref_ROIWidth, objMarkPackageMarkROI.ref_ROIHeight);
                            objImgDontCare_Rotated.Dispose();
                            if (blnWantDebug)
                                objMarkPackageMarkROI.SaveImage("D:\\TS\\objMarkPackageMarkROI.bmp");
                            objDontCareROI.Dispose();
                            objImgDontCare.Dispose();
                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 22");

                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 23");
                            // Define build blob ROI
                            if (blnSkipExtraPadAndTextShiftedChecking) // No Gauge
                                DefineBuildBlobROI_SaveTime(m_objDontCareBackupImage, objMarkPackageMarkROI, true);//objImage
                            else
                                DefineBuildBlobROI_SaveTime(m_objDontCareBackupImage, objMarkPackageMarkROI, (intFailOptionMask & 0x04) > 0);//objImage

                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 24");

                        }
                        else
                        {

                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 23");
                            // Define build blob ROI
                            if (blnSkipExtraPadAndTextShiftedChecking) // No Gauge
                                DefineBuildBlobROI_SaveTime(objImage, objMarkPackageMarkROI, true);
                            else
                                DefineBuildBlobROI_SaveTime(objImage, objMarkPackageMarkROI, (intFailOptionMask & 0x04) > 0);

                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 24");

                        }



                        // Get off set ROI for blob-OCV matching and drawing purpose 
                        m_intROIOffSetX = objMarkPackageMarkROI.ref_ROI.TotalOrgX;
                        m_intROIOffSetY = objMarkPackageMarkROI.ref_ROI.TotalOrgY;
                        m_intBlobOCVOffSetX = m_objBuildObjectROI.ref_ROIPositionX - m_intROIOffSetX;
                        m_intBlobOCVOffSetY = m_objBuildObjectROI.ref_ROIPositionY - m_intROIOffSetY;

                        ImageDrawing objImage_Temp = new ImageDrawing(true, objImage.ref_intImageWidth, objImage.ref_intImageHeight);
                        if (m_intExtraExcessMarkInspectionAreaCutMode == 1)
                        {
                            if (m_blnWantDontCareArea)
                                m_objDontCareBackupImage.CopyTo(ref objImage_Temp);
                            else
                                objImage.CopyTo(ref objImage_Temp);
                            m_objBuildObjectROI.AttachImage(objImage_Temp);
                            ROI objLineROI1 = new ROI();
                            ROI objLineROI2 = new ROI();
                            ROI objTempROI = new ROI();
                            ImageDrawing objImage_Temp2 = new ImageDrawing(true, objImage_Temp.ref_intImageWidth, objImage_Temp.ref_intImageHeight);
                            objLineROI1.AttachImage(objImage_Temp);
                            //objLineROI2.AttachImage(objWhiteImage);
                            objTempROI.AttachImage(objImage_Temp2);
                            for (int i = 0; i < intNumChars; i++)
                            {
                                Point pStart = objOCV.GetCharStartXY(i);
                                Point pEnd = objOCV.GetCharEndXY(i);

                                float newSX = 0, newSY = 0, newEX = 0, newEY = 0;
                                Math2.GetNewXYAfterRotate_360deg(m_intROIOffSetX + (pEnd.X + pStart.X) / 2, m_intROIOffSetY + (pEnd.Y + pStart.Y) / 2, m_intROIOffSetX + pStart.X, m_intROIOffSetY + pStart.Y, -fMarkAngle, ref newSX, ref newSY);

                                Math2.GetNewXYAfterRotate_360deg(m_intROIOffSetX + (pEnd.X + pStart.X) / 2, m_intROIOffSetY + (pEnd.Y + pStart.Y) / 2, m_intROIOffSetX + pEnd.X, m_intROIOffSetY + pEnd.Y, -fMarkAngle, ref newEX, ref newEY);
                                pStart = new Point((int)Math.Round(newSX), (int)Math.Round(newSY));
                                pEnd = new Point((int)Math.Round(newEX), (int)Math.Round(newEY));

                                //List<PointF> arrPoints = new List<PointF>();
                                //float newX = 0, newY = 0;

                                //Math2.GetNewXYAfterRotate_360deg(m_intROIOffSetX + ((pStart.X + pEnd.X) / 2), m_intROIOffSetY + ((pStart.Y + pEnd.Y) / 2), m_intROIOffSetX + pStart.X, m_intROIOffSetY + pStart.Y, (fMarkAngle), ref newX, ref newY);
                                //arrPoints.Add(new PointF(newX, newY));

                                //Math2.GetNewXYAfterRotate_360deg(m_intROIOffSetX + ((pStart.X + pEnd.X) / 2), m_intROIOffSetY + ((pStart.Y + pEnd.Y) / 2), m_intROIOffSetX + pEnd.X, m_intROIOffSetY + pStart.Y, (fMarkAngle), ref newX, ref newY);
                                //arrPoints.Add(new PointF(newX, newY));

                                //Math2.GetNewXYAfterRotate_360deg(m_intROIOffSetX + ((pStart.X + pEnd.X) / 2), m_intROIOffSetY + ((pStart.Y + pEnd.Y) / 2), m_intROIOffSetX + pStart.X, m_intROIOffSetY + pEnd.Y, (fMarkAngle), ref newX, ref newY);
                                //arrPoints.Add(new PointF(newX, newY));

                                //Math2.GetNewXYAfterRotate_360deg(m_intROIOffSetX + ((pStart.X + pEnd.X) / 2), m_intROIOffSetY + ((pStart.Y + pEnd.Y) / 2), m_intROIOffSetX + pEnd.X, m_intROIOffSetY + pEnd.Y, (fMarkAngle), ref newX, ref newY);
                                //arrPoints.Add(new PointF(newX, newY));

                                //if (m_blnWhiteOnBlack)
                                //    DontCareWithoutRotateImage.ProduceImage_Line(arrPoints, objImage_Temp, objWhiteImage, objBlackImage, false);
                                //else
                                //    DontCareWithoutRotateImage.ProduceImage_Line(arrPoints, objImage_Temp, objWhiteImage, objBlackImage, true);

                                List<PointF> arrPoints = new List<PointF>();
                                arrPoints.Add(pStart);
                                arrPoints.Add(new Point(pStart.X + (pEnd.X - pStart.X), pStart.Y));
                                arrPoints.Add(new Point(pStart.X, pStart.Y + (pEnd.Y - pStart.Y)));
                                arrPoints.Add(pEnd);

                                PointF pTemp = new PointF();
                                Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
                                                                 arrPoints[0],
                                                                 (intOrientationAngle + fMarkAngle),
                                                                 ref pTemp);
                                arrPoints[0] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

                                Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
                                                                 arrPoints[1],
                                                                 (intOrientationAngle + fMarkAngle),
                                                                 ref pTemp);
                                arrPoints[1] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

                                Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
                                                                 arrPoints[2],
                                                                 (intOrientationAngle + fMarkAngle),
                                                                 ref pTemp);
                                arrPoints[2] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

                                Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
                                                                 arrPoints[3],
                                                                 (intOrientationAngle + fMarkAngle),
                                                                 ref pTemp);
                                arrPoints[3] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

                                float fMinX = float.MaxValue;
                                float fMinY = float.MaxValue;
                                float fMaxX = 0;
                                float fMaxY = 0;
                                for (int a = 0; a < arrPoints.Count; a++)
                                {
                                    if (fMinX > arrPoints[a].X)
                                        fMinX = arrPoints[a].X;

                                    if (fMinY > arrPoints[a].Y)
                                        fMinY = arrPoints[a].Y;

                                    if (fMaxX < arrPoints[a].X)
                                        fMaxX = arrPoints[a].X;

                                    if (fMaxY < arrPoints[a].Y)
                                        fMaxY = arrPoints[a].Y;
                                }

                                objLineROI1.LoadROISetting((int)Math.Round(fMinX), (int)Math.Round(fMinY),
                                   (int)Math.Round(fMaxX - fMinX), (int)Math.Round(fMaxY - fMinY));

                                objLineROI2.LoadROISetting((int)Math.Round(fMinX), (int)Math.Round(fMinY),
                                   (int)Math.Round(fMaxX - fMinX), (int)Math.Round(fMaxY - fMinY));

                                objTempROI.LoadROISetting((int)Math.Round(fMinX), (int)Math.Round(fMinY),
                                   (int)Math.Round(fMaxX - fMinX), (int)Math.Round(fMaxY - fMinY));

                                ////objLineROI2.AttachImage(objBlackImage);
                                ////objLineROI2.CopyImage(ref objTempROI);

                                ////objLineROI2.LoadROISetting(pStart.X, pStart.Y,
                                ////   pEnd.X - pStart.X, pEnd.Y - pStart.Y);

                                ////objTempROI.LoadROISetting(pStart.X, pStart.Y,
                                ////   pEnd.X - pStart.X, pEnd.Y - pStart.Y);

                                objLineROI2.AttachImage(objWhiteImage);
                                objLineROI2.CopyImage(ref objTempROI);
                                //ROI.Rotate0Degree_ForDontCare(objLineROI2, -(intOrientationAngle + fMarkAngle), 4, objTempROI);

                                ////objLineROI2.LoadROISetting((int)Math.Round(fMinX), (int)Math.Round(fMinY),
                                ////   (int)Math.Round(fMaxX - fMinX), (int)Math.Round(fMaxY - fMinY));

                                ////objTempROI.LoadROISetting((int)Math.Round(fMinX), (int)Math.Round(fMinY),
                                ////   (int)Math.Round(fMaxX - fMinX), (int)Math.Round(fMaxY - fMinY));

                                //if (blnWantDebug)
                                //{
                                //    objLineROI1.SaveImage("D:\\TS\\objLineROIBefore" + i + ".bmp");
                                //}

                                if (m_blnWhiteOnBlack)
                                {
                                    DontCareWithoutRotateImage.ProduceImage_WithoutLoopMaxPoints(arrPoints, objTempROI, objImage_Temp2
                                    , objBlackWhiteTopImage, objBlackWhiteRightImage, objBlackWhiteBottomImage, objBlackWhiteLeftImage, false);
                                }
                                else
                                {
                                    DontCareWithoutRotateImage.ProduceImage_WithoutLoopMaxPoints(arrPoints, objTempROI, objImage_Temp2
                                    , objBlackWhiteTopImage, objBlackWhiteRightImage, objBlackWhiteBottomImage, objBlackWhiteLeftImage, true);
                                }

                                if (m_blnWhiteOnBlack)
                                    EasyImage.Oper(EArithmeticLogicOperation.Subtract, objLineROI1.ref_ROI, objTempROI.ref_ROI, objLineROI1.ref_ROI);
                                else
                                    EasyImage.Oper(EArithmeticLogicOperation.Add, objLineROI1.ref_ROI, objTempROI.ref_ROI, objLineROI1.ref_ROI);

                                if (blnWantDebug)
                                {
                                    objImage_Temp.SaveImage("D:\\TS\\objImage_Temp" + i + ".bmp");
                                    objTempROI.SaveImage("D:\\TS\\objTempROI" + i + ".bmp");
                                    objLineROI1.SaveImage("D:\\TS\\objLineROI" + i + ".bmp");
                                }
                            }
                            objTempROI.Dispose();
                            objLineROI1.Dispose();
                            objLineROI2.Dispose();
                            objImage_Temp2.Dispose();
                        }
                        else if (m_intExtraExcessMarkInspectionAreaCutMode == 2)
                        {
                            if (m_blnWantDontCareArea)
                                m_objDontCareBackupImage.CopyTo(ref objImage_Temp);
                            else
                                objImage.CopyTo(ref objImage_Temp);
                            m_objBuildObjectROI.AttachImage(objImage_Temp);
                            ROI objLineROI1 = new ROI();
                            ROI objLineROI2 = new ROI();
                            ROI objTempROI = new ROI();
                            ImageDrawing objImage_Temp2 = new ImageDrawing(true, objImage_Temp.ref_intImageWidth, objImage_Temp.ref_intImageHeight);
                            objLineROI1.AttachImage(objImage_Temp);
                            //objLineROI2.AttachImage(objWhiteImage);
                            objTempROI.AttachImage(objImage_Temp2);
                            for (int i = 0; i < intNumChars; i++)
                            {
                                Point pStart = objOCV.GetCharStartXY(i);
                                Point pEnd = objOCV.GetCharEndXY(i);

                                float newSX = 0, newSY = 0, newEX = 0, newEY = 0;
                                Math2.GetNewXYAfterRotate_360deg(m_intROIOffSetX + (pEnd.X + pStart.X) / 2, m_intROIOffSetY + (pEnd.Y + pStart.Y) / 2, m_intROIOffSetX + pStart.X, m_intROIOffSetY + pStart.Y, -(intOrientationAngle + fMarkAngle), ref newSX, ref newSY);

                                Math2.GetNewXYAfterRotate_360deg(m_intROIOffSetX + (pEnd.X + pStart.X) / 2, m_intROIOffSetY + (pEnd.Y + pStart.Y) / 2, m_intROIOffSetX + pEnd.X, m_intROIOffSetY + pEnd.Y, -(intOrientationAngle + fMarkAngle), ref newEX, ref newEY);
                                pStart = new Point((int)Math.Round(newSX), (int)Math.Round(newSY));
                                pEnd = new Point((int)Math.Round(newEX), (int)Math.Round(newEY));

                                pStart = new Point(pStart.X - ((int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftX[i] + m_fCharROIOffsetX)),
                                                   pStart.Y - ((int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftY[i] + m_fCharROIOffsetY)));
                                pEnd = new Point(pEnd.X + ((int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftX[i] + m_fCharROIOffsetX)),
                                                 pEnd.Y + ((int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftY[i] + m_fCharROIOffsetY)));

                                //List<PointF> arrPoints = new List<PointF>();
                                //float newX = 0, newY = 0;

                                //Math2.GetNewXYAfterRotate_360deg(m_intROIOffSetX + ((pStart.X + pEnd.X) / 2), m_intROIOffSetY + ((pStart.Y + pEnd.Y) / 2), m_intROIOffSetX + pStart.X, m_intROIOffSetY + pStart.Y, (fMarkAngle), ref newX, ref newY);
                                //arrPoints.Add(new PointF(newX, newY));

                                //Math2.GetNewXYAfterRotate_360deg(m_intROIOffSetX + ((pStart.X + pEnd.X) / 2), m_intROIOffSetY + ((pStart.Y + pEnd.Y) / 2), m_intROIOffSetX + pEnd.X, m_intROIOffSetY + pStart.Y, (fMarkAngle), ref newX, ref newY);
                                //arrPoints.Add(new PointF(newX, newY));

                                //Math2.GetNewXYAfterRotate_360deg(m_intROIOffSetX + ((pStart.X + pEnd.X) / 2), m_intROIOffSetY + ((pStart.Y + pEnd.Y) / 2), m_intROIOffSetX + pStart.X, m_intROIOffSetY + pEnd.Y, (fMarkAngle), ref newX, ref newY);
                                //arrPoints.Add(new PointF(newX, newY));

                                //Math2.GetNewXYAfterRotate_360deg(m_intROIOffSetX + ((pStart.X + pEnd.X) / 2), m_intROIOffSetY + ((pStart.Y + pEnd.Y) / 2), m_intROIOffSetX + pEnd.X, m_intROIOffSetY + pEnd.Y, (fMarkAngle), ref newX, ref newY);
                                //arrPoints.Add(new PointF(newX, newY));

                                //if (m_blnWhiteOnBlack)
                                //    DontCareWithoutRotateImage.ProduceImage_Line(arrPoints, objImage_Temp, objWhiteImage, objBlackImage, false);
                                //else
                                //    DontCareWithoutRotateImage.ProduceImage_Line(arrPoints, objImage_Temp, objWhiteImage, objBlackImage, true);

                                List<PointF> arrPoints = new List<PointF>();
                                arrPoints.Add(pStart);
                                arrPoints.Add(new Point(pStart.X + (pEnd.X - pStart.X), pStart.Y));
                                arrPoints.Add(new Point(pStart.X, pStart.Y + (pEnd.Y - pStart.Y)));
                                arrPoints.Add(pEnd);

                                PointF pTemp = new PointF();
                                Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
                                                                 arrPoints[0],
                                                                 (intOrientationAngle + fMarkAngle),
                                                                 ref pTemp);
                                arrPoints[0] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

                                Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
                                                                 arrPoints[1],
                                                                 (intOrientationAngle + fMarkAngle),
                                                                 ref pTemp);
                                arrPoints[1] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

                                Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
                                                                 arrPoints[2],
                                                                 (intOrientationAngle + fMarkAngle),
                                                                 ref pTemp);
                                arrPoints[2] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

                                Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
                                                                 arrPoints[3],
                                                                 (intOrientationAngle + fMarkAngle),
                                                                 ref pTemp);
                                arrPoints[3] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

                                float fMinX = float.MaxValue;
                                float fMinY = float.MaxValue;
                                float fMaxX = 0;
                                float fMaxY = 0;
                                for (int a = 0; a < arrPoints.Count; a++)
                                {
                                    if (fMinX > arrPoints[a].X)
                                        fMinX = arrPoints[a].X;

                                    if (fMinY > arrPoints[a].Y)
                                        fMinY = arrPoints[a].Y;

                                    if (fMaxX < arrPoints[a].X)
                                        fMaxX = arrPoints[a].X;

                                    if (fMaxY < arrPoints[a].Y)
                                        fMaxY = arrPoints[a].Y;
                                }

                                objLineROI1.LoadROISetting((int)Math.Round(fMinX), (int)Math.Round(fMinY),
                                   (int)Math.Round(fMaxX - fMinX), (int)Math.Round(fMaxY - fMinY));

                                objLineROI2.LoadROISetting((int)Math.Round(fMinX), (int)Math.Round(fMinY),
                                   (int)Math.Round(fMaxX - fMinX), (int)Math.Round(fMaxY - fMinY));

                                objTempROI.LoadROISetting((int)Math.Round(fMinX), (int)Math.Round(fMinY),
                                   (int)Math.Round(fMaxX - fMinX), (int)Math.Round(fMaxY - fMinY));

                                //objLineROI2.AttachImage(objBlackImage);
                                //objLineROI2.CopyImage(ref objTempROI);

                                //objLineROI2.LoadROISetting(pStart.X, pStart.Y,
                                //   pEnd.X - pStart.X, pEnd.Y - pStart.Y);

                                //objTempROI.LoadROISetting(pStart.X, pStart.Y,
                                //   pEnd.X - pStart.X, pEnd.Y - pStart.Y);

                                objLineROI2.AttachImage(objWhiteImage);
                                objLineROI2.CopyImage(ref objTempROI);
                                //ROI.Rotate0Degree_ForDontCare(objLineROI2, -(intOrientationAngle + fMarkAngle), 4, objTempROI);

                                //objLineROI2.LoadROISetting((int)Math.Round(fMinX), (int)Math.Round(fMinY),
                                //   (int)Math.Round(fMaxX - fMinX), (int)Math.Round(fMaxY - fMinY));

                                //objTempROI.LoadROISetting((int)Math.Round(fMinX), (int)Math.Round(fMinY),
                                //   (int)Math.Round(fMaxX - fMinX), (int)Math.Round(fMaxY - fMinY));

                                if (blnWantDebug)
                                {
                                    objLineROI1.SaveImage("D:\\TS\\objLineROIBefore" + i + ".bmp");
                                }

                                if (m_blnWhiteOnBlack)
                                {
                                    DontCareWithoutRotateImage.ProduceImage_WithoutLoopMaxPoints(arrPoints, objTempROI, objImage_Temp2
                                    , objBlackWhiteTopImage, objBlackWhiteRightImage, objBlackWhiteBottomImage, objBlackWhiteLeftImage, false);
                                }
                                else
                                {
                                    DontCareWithoutRotateImage.ProduceImage_WithoutLoopMaxPoints(arrPoints, objTempROI, objImage_Temp2
                                    , objBlackWhiteTopImage, objBlackWhiteRightImage, objBlackWhiteBottomImage, objBlackWhiteLeftImage, true);
                                }

                                if (m_blnWhiteOnBlack)
                                    EasyImage.Oper(EArithmeticLogicOperation.Subtract, objLineROI1.ref_ROI, objTempROI.ref_ROI, objLineROI1.ref_ROI);
                                else
                                    EasyImage.Oper(EArithmeticLogicOperation.Add, objLineROI1.ref_ROI, objTempROI.ref_ROI, objLineROI1.ref_ROI);

                                if (blnWantDebug)
                                {
                                    objImage_Temp.SaveImage("D:\\TS\\objImage_Temp" + i + ".bmp");
                                    objTempROI.SaveImage("D:\\TS\\objTempROI" + i + ".bmp");
                                    objLineROI1.SaveImage("D:\\TS\\objLineROI" + i + ".bmp");
                                }
                            }
                            objTempROI.Dispose();
                            objLineROI1.Dispose();
                            objLineROI2.Dispose();
                            objImage_Temp2.Dispose();
                        }

                        if (blnWantDebug)
                        {
                            m_objBuildObjectROI.SaveImage("D:\\TS\\m_objBuildObjectROI.bmp");
                            m_objBuildObjectROI.ref_ROI.TopParent.Save("D:\\TS\\m_objBuildObjectROI_Parent.bmp");
                        }

                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 25");

                        int intExtraMarkThreshold = intThresholdValue;
                        // 2020-11-03 ZJYEOH: Will Use extra mark threshold if want separate threshold
                        if (m_blnSeparateExtraMarkThreshold)
                            intExtraMarkThreshold = GetAutoThresholdExtraMark(objMarkPackageMarkROI);

                        // 2021-02-11 ZJYEOH : not suitable to use connexity 8 as nearest diagonal pixel will be group together
                        // 2019 08 30 - CCENG: change Connexity 4 to 8. Connexity 8 will link small items into 1 blobs which will make result more stable.
                        if (!BuildObject(m_objBlobs[m_intTemplateIndex], m_objBuildObjectROI, false, false, intExtraMarkThreshold, 0, m_objBuildObjectROI.ref_ROIWidth * m_objBuildObjectROI.ref_ROIHeight + 1, 0x1F))
                        {
                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 26");
                            //m_strErrorMessage = "BuildObjects : No blobs object selected!";
                            //m_blnLock = false;
                            //m_blnLockBlobs = false;
                            //return false;
                        }

                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 27");
                        intNoSelectedBlobs = m_objBlobs[m_intTemplateIndex].ref_intNumSelectedObject;
                        //#region ------------- No Mark Inspection --------------------------------------------------------------------------------
                        if (blnWantCheckNoMark && !ShowLiterationOnly)
                        {
                            m_intTotalBlobArea = 0;
                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 28");
                            ////for (int i = 0; i < intNoSelectedBlobs; i++)
                            //for (int i = 0; i < m_objBlobs[m_intTemplateIndex].ref_arrArea.Count; i++)
                            //{
                            //    m_intTotalBlobArea += m_objBlobs[m_intTemplateIndex].ref_arrArea[i];
                            //}

                            //2021-04-14 ZJYEOH : Use White pixel to find no mark
                            ROI objNoMarkROI = new ROI();
                            objNoMarkROI.AttachImage(objOcvRotatedImage);
                            if (blnWantDebug)
                            {
                                objNoMarkROI.SaveImage("D:\\TS\\objNoMarkROI.bmp");
                            }

                            objNoMarkROI.LoadROISetting(m_objBuildObjectROI.ref_ROIPositionX, m_objBuildObjectROI.ref_ROIPositionY, m_objBuildObjectROI.ref_ROIWidth, m_objBuildObjectROI.ref_ROIHeight);

                            if (m_blnWhiteOnBlack)
                                m_intTotalBlobArea = ROI.GetPixelArea(objNoMarkROI, intThresholdValue, 1);
                            else
                                m_intTotalBlobArea = ROI.GetPixelArea(objNoMarkROI, intThresholdValue, 0);

                            objNoMarkROI.Dispose();

                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 29");

                            if (m_intTotalBlobArea < (int)Math.Round(m_fNoMarkMaximumBlobArea))
                            {
                                if ((m_intFailResultMask & 0x1000) == 0)
                                    m_intFailResultMask |= 0x1000;

                                m_strErrorMessage = "*No Mark! Set = " + GetNoMarkMaximumBlobArea().ToString() + " " + GetDisplayUnitName(m_intDisplayUnitMode, true) + ", " +
                                    "Result = " + GetResultTotalBlobArea().ToString() + " " + GetDisplayUnitName(m_intDisplayUnitMode, true) + ".";

                                objImage_Temp.Dispose();
                                m_blnLock = false;
                                m_blnLockBlobs = false;
                                return false;
                            }
                        }
                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 30");
                        //#endregion ----------------------------------------------------------------------------------------------------------

                        #region ----------------------------- Blobs Inspection ------------------------------------------------------------
                        bool blnGroupExtraMark = false;
                        bool blnGroupExcessMark = false;
                        float fCenterX, fCenterY, fWidth, fHeight, fAngle, fGravityCenterX, fGravityCenterY, fStartX, fStartY, fEndX, fEndY;
                        int intArea = 0, intContourX = 0, intContourY = 0;
                        List<float> arrExcessStartX = new List<float>();
                        List<float> arrExcessStartY = new List<float>();
                        List<float> arrExcessEndX = new List<float>();
                        List<float> arrExcessEndY = new List<float>();
                        List<PointF> arrCharStartPoint_RotateTo0Deg = new List<PointF>();
                        List<PointF> arrCharEndPoint_RotateTo0Deg = new List<PointF>();

                        for (int a = 0; a < intNumChars; a++)
                        {
                            arrExcessStartX.Add(-1);
                            arrExcessStartY.Add(-1);
                            arrExcessEndX.Add(-1);
                            arrExcessEndY.Add(-1);

                            int intStartX, intStartY, intEndX, intEndY;
                            float newSX = 0, newSY = 0, newEX = 0, newEY = 0;

                            //2021-02-11 ZJYEOH: Collect OCV point with 0 degree for matching index use
                            Point pStart = objOCV.GetCharStartXY(a);
                            Point pEnd = objOCV.GetCharEndXY(a);

                            intStartX = m_intROIOffSetX + pStart.X;
                            intStartY = m_intROIOffSetY + pStart.Y;
                            intEndX = m_intROIOffSetX + pEnd.X;
                            intEndY = m_intROIOffSetY + pEnd.Y;

                            Math2.GetNewXYAfterRotate_360deg((intEndX + intStartX) / 2, (intEndY + intStartY) / 2, intStartX, intStartY, -fMarkAngle, ref newSX, ref newSY);

                            Math2.GetNewXYAfterRotate_360deg((intEndX + intStartX) / 2, (intEndY + intStartY) / 2, intEndX, intEndY, -fMarkAngle, ref newEX, ref newEY);
                            arrCharStartPoint_RotateTo0Deg.Add(new PointF(newSX, newSY));
                            arrCharEndPoint_RotateTo0Deg.Add(new PointF(newEX, newEY));

                        }

                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 31");
                        // Init blob data
                        m_intBlobResult[m_intTemplateIndex] = new int[intNoSelectedBlobs];
                        for (j = 0; j < intNoSelectedBlobs; j++)
                        {
                            m_intBlobResult[m_intTemplateIndex][j] = 0;
                        }

                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 32");
                        fCenterX = fCenterY = fWidth = fHeight = fAngle = fGravityCenterX = fGravityCenterY = 0;

                        if ((intFailOptionMask & 0x80) > 0)
                        {
                            if (m_arrCharJointMarkResult[m_intTemplateIndex] == null)
                                m_arrCharJointMarkResult[m_intTemplateIndex] = new bool[intNumChars];

                            if (m_arrCharJointMarkResult[m_intTemplateIndex].Length != intNumChars)
                                m_arrCharJointMarkResult[m_intTemplateIndex] = new bool[intNumChars];

                            for (int a = 0; a < intNumChars; a++)
                            {
                                m_arrCharJointMarkResult[m_intTemplateIndex][a] = true;
                            }

                            if (m_intExtraExcessMarkInspectionAreaCutMode == 0)
                            {
                                for (int i = 0; i < intNoSelectedBlobs; i++)
                                {
                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 33");
                                    fCenterX = m_objBlobs[m_intTemplateIndex].ref_arrLimitCenterX[i];
                                    fCenterY = m_objBlobs[m_intTemplateIndex].ref_arrLimitCenterY[i];
                                    fWidth = m_objBlobs[m_intTemplateIndex].ref_arrWidth[i];
                                    fHeight = m_objBlobs[m_intTemplateIndex].ref_arrHeight[i];
                                    fGravityCenterX = m_objBlobs[m_intTemplateIndex].ref_arrGravityCenterX[i];
                                    fGravityCenterY = m_objBlobs[m_intTemplateIndex].ref_arrGravityCenterY[i];
                                    intArea = m_objBlobs[m_intTemplateIndex].ref_arrArea[i];
                                    intContourX = m_objBlobs[m_intTemplateIndex].ref_arrContourX[i];
                                    intContourY = m_objBlobs[m_intTemplateIndex].ref_arrContourY[i];

                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 34");
                                    // Use m_intMinArea as min area if m_intMinArea < 5, else use 5 as min area
                                    if (m_intMinArea < 5)
                                    {
                                        // skip checking if blob area lower than setting
                                        if (intArea <= m_intMinArea)
                                        {
                                            continue;
                                        }
                                    }
                                    else
                                    {
                                        // skip checking if blob area lower than setting
                                        if (intArea <= 5)
                                        {
                                            continue;
                                        }
                                    }

                                    float fRotateCenterX = fCenterX;
                                    float fRotateCenterY = fCenterY;
                                    //float fRotateRefCenterX = pRotatedCenterPoint.X - m_objBuildObjectROI.ref_ROITotalX;
                                    //float fRotateRefCenterY = pRotatedCenterPoint.Y - m_objBuildObjectROI.ref_ROITotalY;

                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 35");

                                    ////2020-06-23 ZJYEOH : if no check package size, pRotatedCenterPoint will be (-1, -1)
                                    //if (pRotatedCenterPoint != new PointF(-1, -1))
                                    //{
                                    //    Math2.GetNewXYAfterRotate_360deg((float)m_objBuildObjectROI.ref_ROIWidth / 2, (float)m_objBuildObjectROI.ref_ROIHeight / 2,
                                    //                                fCenterX, fCenterY,
                                    //                                fPackageAngle - fMarkAngle,
                                    //                                ref fRotateCenterX, ref fRotateCenterY);
                                    //}

                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 36");

                                    // Get blob start point and end point
                                    fStartX = fRotateCenterX - fWidth / 2 + m_intBlobOCVOffSetX;
                                    fStartY = fRotateCenterY - fHeight / 2 + m_intBlobOCVOffSetY;
                                    fEndX = fRotateCenterX + fWidth / 2 + m_intBlobOCVOffSetX;
                                    fEndY = fRotateCenterY + fHeight / 2 + m_intBlobOCVOffSetY;

                                    // 2020 11 03 - CCENG: igore those blob object on Lead Area.
                                    if (arrDontCareLeadAreaStartX.Count > 0)
                                    {
                                        if (IsInDontCareLeadArea(arrDontCareLeadAreaStartX, arrDontCareLeadAreaStartY, arrDontCareLeadAreaEndX, arrDontCareLeadAreaEndY, arrDontCareLeadDirection,
                                            m_objBuildObjectROI.ref_ROITotalX + (fEndX + fStartX) / 2, m_objBuildObjectROI.ref_ROITotalY + (fEndY + fStartY) / 2))
                                            continue;

                                    }

                                    //2021-01-19 ZJYEOH : Matching area added shift tolerance ao that extra mark inside char area will not consider as extra mark
                                    //2021-02-11 ZJYEOH : Use rotate function to match OCV index
                                    //bool blnContourCheck = false;
                                    List<int> intMatchNumber = new List<int>();
                                    if (m_intExtraExcessMarkInspectionAreaCutMode == 0)
                                    {
                                        intMatchNumber = objOCV.GetMatchCharIndexes_Rotate(fStartX, fStartY, fEndX, fEndY,
                                                                                           fRotateCenterX + m_intBlobOCVOffSetX, fRotateCenterY + m_intBlobOCVOffSetY, fWidth, fHeight, ref blnContourCheck,
                                                                                           m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftX, m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftY,
                                                                                           m_fCharROIOffsetX, m_fCharROIOffsetY, true,
                                                                                           m_intROIOffSetX, m_intROIOffSetY, fMarkAngle, arrCharStartPoint_RotateTo0Deg, arrCharEndPoint_RotateTo0Deg);
                                    }

                                    // 2021 06 27 - This considion will cause escapee bcos the extra mark at mark ROI border will be ignored.
                                    //if (fStartX <= 0 || fStartY <= 0 || (fEndX >= m_objBuildObjectROI.ref_ROIWidth) || (fEndY >= m_objBuildObjectROI.ref_ROIHeight))
                                    //{
                                    //    continue;
                                    //}

                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 37");
                                    // By using contour, double check again the selected OCV Char rectangle box is/are really matched by blobs
                                    if (blnContourCheck && intMatchNumber.Count > 0)
                                    {
                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 38");
                                        for (int e = 0; e < intMatchNumber.Count; e++)
                                        {
                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 39");
                                            // Build contour elements for the selected blob
                                            Contour objContour = new Contour();
                                            objContour.ClearContour();
                                            if (objContour.BuildContour(m_objBuildObjectROI, intContourX, intContourY, intExtraMarkThreshold, 8))//intThresholdValue, 4 //2021-02-10 ZJYEOH : Use connexity 8 because blob is built using connexity 8
                                            {
                                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 40");
                                                // Check is the blob in OCV Char rectangle box
                                                if (!objOCV.IsInOcvCharArea(objContour, intMatchNumber[e], m_intBlobOCVOffSetX, m_intBlobOCVOffSetY))
                                                {
                                                    intMatchNumber.RemoveAt(e);
                                                    e--;
                                                }

                                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 41");
                                            }
                                        }
                                    }

                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 42");

                                    if (intMatchNumber.Count > 1)
                                    {
                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 56");
                                        // Make sure area >= min area
                                        if (intArea < m_intMinArea)
                                        {
                                            continue;
                                        }

                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 57");
                                        //// Set char hit by blob counter
                                        //for (j = 0; j < intMatchNumber.Count; j++)
                                        //{
                                        //    m_intHitCharCounter[intMatchNumber[j]]++;
                                        //}

                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 59");
                                        // Check joint mark (1 blob match to more than 1 char)
                                        //if (intMatchNumber.Count > 1)
                                        {
                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 60");

                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 61");
                                            int intDisabledMarkCounter = 0;
                                            int intEnabledMarkCounter = 0;
                                            for (int q = 0; q < intMatchNumber.Count; q++)
                                            {
                                                if (!m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[intMatchNumber[q]])
                                                    intDisabledMarkCounter++;
                                                else
                                                    intEnabledMarkCounter++;
                                            }

                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 63");

                                            if (intDisabledMarkCounter > 1 && intEnabledMarkCounter < intDisabledMarkCounter || intEnabledMarkCounter <= 1)
                                                goto Skip;

                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 64");
                                            m_intBlobResult[m_intTemplateIndex][i] = 2;

                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 65");

                                            for (int q = 0; q < intMatchNumber.Count; q++)
                                            {
                                                // 2021 11 28 - CCENG:  arrCharFailOtherThanSco index is from intNumChar, 
                                                //                      but this i value is not from inNumChar anymore, 
                                                //                      this i from m_objJointMarkROI object during build blob,
                                                //                      so need to use intMatchNumber[q] which has number char value.
                                                arrCharFailOtherThanScore[intMatchNumber[q]] = true; //arrCharFailOtherThanScore[i] = true; 
                                                m_blnCharResult[m_intTemplateIndex][intMatchNumber[q]] = false;

                                                if (m_arrCharJointMarkResult[m_intTemplateIndex][intMatchNumber[q]])
                                                    m_arrCharJointMarkResult[m_intTemplateIndex][intMatchNumber[q]] = false;

                                            }


                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 66");
                                            if ((m_intFailResultMask & 0x80) == 0)
                                                m_intFailResultMask |= 0x80;
                                        }

                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 67");
                                        Skip: { }

                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 68");

                                    }
                                }
                            }
                            else
                            {

                                if (blnWantDebug)
                                {
                                    m_objJointMarkROI.SaveImage("D:\\TS\\m_objJointMarkROI.bmp");
                                    m_objJointMarkROI.ref_ROI.TopParent.Save("D:\\TS\\m_objJointMarkROI_Parent.bmp");
                                }

                                // 2019 08 30 - CCENG: change Connexity 4 to 8. Connexity 8 will link small items into 1 blobs which will make result more stable.
                                if (!BuildObject(m_objJointMarkBlobs[m_intTemplateIndex], m_objJointMarkROI, false, false, intExtraMarkThreshold, 0, 1000000, 0x1F))
                                {
                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 26");
                                    //m_strErrorMessage = "BuildObjects : No blobs object selected!";
                                    //m_blnLock = false;
                                    //m_blnLockBlobs = false;
                                    //return false;
                                }

                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 27");

                                if (m_intExtraExcessMarkInspectionAreaCutMode != 0)
                                {
                                    m_intJointMarkBlobResult[m_intTemplateIndex] = new int[m_objJointMarkBlobs[m_intTemplateIndex].ref_intNumSelectedObject];
                                    for (j = 0; j < m_objJointMarkBlobs[m_intTemplateIndex].ref_intNumSelectedObject; j++)
                                    {
                                        m_intJointMarkBlobResult[m_intTemplateIndex][j] = 0;
                                    }

                                }

                                for (int i = 0; i < m_objJointMarkBlobs[m_intTemplateIndex].ref_intNumSelectedObject; i++)
                                {
                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 33");
                                    fCenterX = m_objJointMarkBlobs[m_intTemplateIndex].ref_arrLimitCenterX[i];
                                    fCenterY = m_objJointMarkBlobs[m_intTemplateIndex].ref_arrLimitCenterY[i];
                                    fWidth = m_objJointMarkBlobs[m_intTemplateIndex].ref_arrWidth[i];
                                    fHeight = m_objJointMarkBlobs[m_intTemplateIndex].ref_arrHeight[i];
                                    fGravityCenterX = m_objJointMarkBlobs[m_intTemplateIndex].ref_arrGravityCenterX[i];
                                    fGravityCenterY = m_objJointMarkBlobs[m_intTemplateIndex].ref_arrGravityCenterY[i];
                                    intArea = m_objJointMarkBlobs[m_intTemplateIndex].ref_arrArea[i];
                                    intContourX = m_objJointMarkBlobs[m_intTemplateIndex].ref_arrContourX[i];
                                    intContourY = m_objJointMarkBlobs[m_intTemplateIndex].ref_arrContourY[i];

                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 34");
                                    // Use m_intMinArea as min area if m_intMinArea < 5, else use 5 as min area
                                    if (m_intMinArea < 5)
                                    {
                                        // skip checking if blob area lower than setting
                                        if (intArea <= m_intMinArea)
                                        {
                                            continue;
                                        }
                                    }
                                    else
                                    {
                                        // skip checking if blob area lower than setting
                                        if (intArea <= 5)
                                        {
                                            continue;
                                        }
                                    }

                                    float fRotateCenterX = fCenterX;
                                    float fRotateCenterY = fCenterY;
                                    //float fRotateRefCenterX = pRotatedCenterPoint.X - m_objBuildObjectROI.ref_ROITotalX;
                                    //float fRotateRefCenterY = pRotatedCenterPoint.Y - m_objBuildObjectROI.ref_ROITotalY;

                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 35");

                                    //2020-06-23 ZJYEOH : if no check package size, pRotatedCenterPoint will be (-1, -1)
                                    if (pRotatedCenterPoint != new PointF(-1, -1))
                                    {
                                        Math2.GetNewXYAfterRotate_360deg((float)m_objJointMarkROI.ref_ROIWidth / 2, (float)m_objJointMarkROI.ref_ROIHeight / 2,
                                                                    fCenterX, fCenterY,
                                                                    fPackageAngle - fMarkAngle,
                                                                    ref fRotateCenterX, ref fRotateCenterY);
                                    }

                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 36");

                                    // Get blob start point and end point
                                    fStartX = fRotateCenterX - fWidth / 2 + m_intBlobOCVOffSetX;
                                    fStartY = fRotateCenterY - fHeight / 2 + m_intBlobOCVOffSetY;
                                    fEndX = fRotateCenterX + fWidth / 2 + m_intBlobOCVOffSetX;
                                    fEndY = fRotateCenterY + fHeight / 2 + m_intBlobOCVOffSetY;

                                    //2021-01-19 ZJYEOH : Matching area added shift tolerance so that extra mark inside char area will not consider as extra mark
                                    //bool blnContourCheck = false;
                                    List<int> intMatchNumber = new List<int>();
                                    //if (m_intExtraExcessMarkInspectionAreaCutMode == 0)
                                    {
                                        intMatchNumber = objOCV.GetMatchCharIndexes(fStartX, fStartY, fEndX, fEndY,
                                                                                                  fRotateCenterX + m_intBlobOCVOffSetX, fRotateCenterY + m_intBlobOCVOffSetY,
                                                                                                  fWidth, fHeight, ref blnContourCheck
                                                                                                  , m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftX,
                                                                                                  m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftY,
                                                                                                  m_fCharROIOffsetX, m_fCharROIOffsetY
                                                                                                  , true);
                                    }

                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 37");
                                    // By using contour, double check again the selected OCV Char rectangle box is/are really matched by blobs
                                    if (blnContourCheck && intMatchNumber.Count > 0)
                                    {
                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 38");
                                        for (int e = 0; e < intMatchNumber.Count; e++)
                                        {
                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 39");
                                            // Build contour elements for the selected blob
                                            Contour objContour = new Contour();
                                            objContour.ClearContour();
                                            if (objContour.BuildContour(m_objJointMarkROI, intContourX, intContourY, intExtraMarkThreshold, 8))//intThresholdValue, 4 //2021-02-10 ZJYEOH : Use connexity 8 because blob is built using connexity 8
                                            {
                                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 40");
                                                // Check is the blob in OCV Char rectangle box
                                                if (!objOCV.IsInOcvCharArea(objContour, intMatchNumber[e], m_intBlobOCVOffSetX, m_intBlobOCVOffSetY))
                                                {
                                                    intMatchNumber.RemoveAt(e);
                                                    e--;
                                                }

                                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 41");
                                            }
                                        }
                                    }

                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 42");

                                    if (intMatchNumber.Count > 1)
                                    {
                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 56");
                                        // Make sure area >= min area
                                        if (intArea < m_intMinArea)
                                        {
                                            continue;
                                        }

                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 57");
                                        //// Set char hit by blob counter
                                        //for (j = 0; j < intMatchNumber.Count; j++)
                                        //{
                                        //    m_intHitCharCounter[intMatchNumber[j]]++;
                                        //}

                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 59");
                                        // Check joint mark (1 blob match to more than 1 char)
                                        //if (intMatchNumber.Count > 1)
                                        {
                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 60");
                                            //if ((intFailOptionMask & 0x80) > 0)
                                            //{
                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 61");
                                            int intDisabledMarkCounter = 0;
                                            int intEnabledMarkCounter = 0;
                                            for (int q = 0; q < intMatchNumber.Count; q++)
                                            {
                                                if (!m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[intMatchNumber[q]])
                                                    intDisabledMarkCounter++;
                                                else
                                                    intEnabledMarkCounter++;
                                            }

                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 63");

                                            if (intDisabledMarkCounter > 1 && intEnabledMarkCounter < intDisabledMarkCounter || intEnabledMarkCounter <= 1)
                                                goto Skip;

                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 64");
                                            m_intJointMarkBlobResult[m_intTemplateIndex][i] = 2;

                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 65");

                                            for (int q = 0; q < intMatchNumber.Count; q++)
                                            {
                                                // 2021 11 28 - CCENG:  arrCharFailOtherThanSco index is from intNumChar, 
                                                //                      but this i value is not from inNumChar anymore, 
                                                //                      this i from m_objJointMarkROI object during build blob,
                                                //                      so need to use intMatchNumber[q] which has number char value.
                                                arrCharFailOtherThanScore[intMatchNumber[q]] = true; //arrCharFailOtherThanScore[i] = true; 
                                                m_blnCharResult[m_intTemplateIndex][intMatchNumber[q]] = false;

                                                if (m_arrCharJointMarkResult[m_intTemplateIndex][intMatchNumber[q]])
                                                    m_arrCharJointMarkResult[m_intTemplateIndex][intMatchNumber[q]] = false;
                                            }

                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 66");
                                            if ((m_intFailResultMask & 0x80) == 0)
                                                m_intFailResultMask |= 0x80;
                                            //}

                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 67");
                                            Skip: { }

                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 68");
                                        }
                                    }
                                }
                            }
                        }

                        for (int i = 0; i < intNoSelectedBlobs; i++)
                        {
                            if (m_intBlobResult[m_intTemplateIndex][i] == 2) // 2021-02-25 ZJYEOH : If m_intBlobResult == 2 means fail joint mark
                                continue;

                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 33");
                            fCenterX = m_objBlobs[m_intTemplateIndex].ref_arrLimitCenterX[i];
                            fCenterY = m_objBlobs[m_intTemplateIndex].ref_arrLimitCenterY[i];
                            fWidth = m_objBlobs[m_intTemplateIndex].ref_arrWidth[i];
                            fHeight = m_objBlobs[m_intTemplateIndex].ref_arrHeight[i];
                            fGravityCenterX = m_objBlobs[m_intTemplateIndex].ref_arrGravityCenterX[i];
                            fGravityCenterY = m_objBlobs[m_intTemplateIndex].ref_arrGravityCenterY[i];
                            intArea = m_objBlobs[m_intTemplateIndex].ref_arrArea[i];
                            intContourX = m_objBlobs[m_intTemplateIndex].ref_arrContourX[i];
                            intContourY = m_objBlobs[m_intTemplateIndex].ref_arrContourY[i];

                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 34");
                            // Use m_intMinArea as min area if m_intMinArea < 5, else use 5 as min area
                            if (m_intMinArea < 5)
                            {
                                // skip checking if blob area lower than setting
                                if (intArea <= m_intMinArea)
                                {
                                    continue;
                                }
                            }
                            else
                            {
                                // skip checking if blob area lower than setting
                                if (intArea <= 5)
                                {
                                    continue;
                                }
                            }

                            float fRotateCenterX = fCenterX;
                            float fRotateCenterY = fCenterY;
                            //float fRotateRefCenterX = pRotatedCenterPoint.X - m_objBuildObjectROI.ref_ROITotalX;
                            //float fRotateRefCenterY = pRotatedCenterPoint.Y - m_objBuildObjectROI.ref_ROITotalY;

                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 35");

                            ////2020-06-23 ZJYEOH : if no check package size, pRotatedCenterPoint will be (-1, -1)
                            //if (pRotatedCenterPoint != new PointF(-1, -1))
                            //{
                            //    Math2.GetNewXYAfterRotate_360deg((float)m_objBuildObjectROI.ref_ROIWidth / 2, (float)m_objBuildObjectROI.ref_ROIHeight / 2,
                            //                                fCenterX, fCenterY,
                            //                                fPackageAngle - fMarkAngle,
                            //                                ref fRotateCenterX, ref fRotateCenterY);
                            //}

                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 36");

                            // Get blob start point and end point
                            fStartX = fRotateCenterX - fWidth / 2 + m_intBlobOCVOffSetX;
                            fStartY = fRotateCenterY - fHeight / 2 + m_intBlobOCVOffSetY;
                            fEndX = fRotateCenterX + fWidth / 2 + m_intBlobOCVOffSetX;
                            fEndY = fRotateCenterY + fHeight / 2 + m_intBlobOCVOffSetY;

                            // 2020 11 03 - CCENG: igore those blob object on Lead Area.
                            if (arrDontCareLeadAreaStartX.Count > 0)
                            {
                                if (IsInDontCareLeadArea(arrDontCareLeadAreaStartX, arrDontCareLeadAreaStartY, arrDontCareLeadAreaEndX, arrDontCareLeadAreaEndY, arrDontCareLeadDirection,
                                    m_objBuildObjectROI.ref_ROITotalX + (fEndX + fStartX) / 2, m_objBuildObjectROI.ref_ROITotalY + (fEndY + fStartY) / 2))
                                    continue;

                            }

                            //2021-01-19 ZJYEOH : Matching area added shift tolerance ao that extra mark inside char area will not consider as extra mark
                            //2021-02-11 ZJYEOH : Use rotate function to match OCV index
                            //bool blnContourCheck = false;
                            List<int> intMatchNumber = new List<int>();
                            if (m_intExtraExcessMarkInspectionAreaCutMode == 0)
                            {
                                intMatchNumber = objOCV.GetMatchCharIndexes_Rotate(fStartX, fStartY, fEndX, fEndY,
                                                                                   fRotateCenterX + m_intBlobOCVOffSetX, fRotateCenterY + m_intBlobOCVOffSetY, fWidth, fHeight, ref blnContourCheck, 
                                                                                   m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftX, m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftY,
                                                                                   m_fCharROIOffsetX, m_fCharROIOffsetY, m_intExtraExcessMarkInspectionAreaCutMode == 1,
                                                                                   m_intROIOffSetX, m_intROIOffSetY, fMarkAngle, arrCharStartPoint_RotateTo0Deg, arrCharEndPoint_RotateTo0Deg);
                            }

                            // 2021 06 27 - This considion will cause escapee bcos the extra mark at mark ROI border will be ignored.
                            //if (fStartX <= 0 || fStartY <= 0 || (fEndX >= m_objBuildObjectROI.ref_ROIWidth) || (fEndY >= m_objBuildObjectROI.ref_ROIHeight))
                            //{
                            //    continue;
                            //}

                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 37");
                            // By using contour, double check again the selected OCV Char rectangle box is/are really matched by blobs
                            if (blnContourCheck && intMatchNumber.Count > 0)
                            {
                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 38");
                                for (int e = 0; e < intMatchNumber.Count; e++)
                                {
                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 39");
                                    // Build contour elements for the selected blob
                                    Contour objContour = new Contour();
                                    objContour.ClearContour();
                                    if (objContour.BuildContour(m_objBuildObjectROI, intContourX, intContourY, intExtraMarkThreshold, 8))//intThresholdValue, 4 //2021-02-10 ZJYEOH : Use connexity 8 because blob is built using connexity 8
                                    {
                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 40");
                                        // Check is the blob in OCV Char rectangle box
                                        if (!objOCV.IsInOcvCharArea(objContour, intMatchNumber[e], m_intBlobOCVOffSetX, m_intBlobOCVOffSetY))
                                        {
                                            intMatchNumber.RemoveAt(e);
                                            e--;
                                        }

                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 41");
                                    }
                                }
                            }

                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 42");

                            if (intMatchNumber.Count == 0)
                            {
                                //bool blnIgnore = false;
                                //if (fStartX <= 0 || fStartY <= 0 || (fEndX >= m_objBuildObjectROI.ref_ROIWidth) || (fEndY >= m_objBuildObjectROI.ref_ROIHeight))
                                //{
                                //    blnIgnore = true;
                                //}

                                //if (!blnIgnore)
                                {
                                    // Check Group Extra Mark
                                    if (((intFailOptionMask & 0x08) > 0)) //!blnSkipExtraPadAndTextShiftedChecking &&
                                    {
                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 43");
                                        m_intGroupExtraMarkArea[m_intTemplateIndex] += intArea;
                                        m_intBlobResult[m_intTemplateIndex][i] = 1;

                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 44");
                                        if (m_intGroupExtraMarkArea[m_intTemplateIndex] > (int)Math.Round(objTemplateSetting.fGroupExtraMinArea))
                                        {
                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 45");
                                            m_intBlobResult[m_intTemplateIndex][i] = 2;

                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 46");
                                            if (!blnGroupExtraMark)
                                            {
                                                m_intFailResultMask |= 0x08;
                                                blnGroupExtraMark = true;

                                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 47");
                                                // Upgrade result from 1 to 2
                                                for (j = 0; j < intNoSelectedBlobs; j++)
                                                {
                                                    if (m_intBlobResult[m_intTemplateIndex][j] == 1)
                                                        m_intBlobResult[m_intTemplateIndex][j] = 2;
                                                }

                                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 48");
                                            }
                                        }
                                    }

                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 49");

                                    //2020-06-02 ZJYEOH : filter blob with area less than min area
                                    if ((intArea <= m_intMinArea))
                                    {
                                        continue;
                                    }

                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 50");

                                    // 2020 05 22 - CCENG: Move the "record extra mark area" coding to before check ExtraMinArea. This let user know current size of extra area and easier for them to do setting.
                                    if (m_intSmallestExtraMarkArea[m_intTemplateIndex] == 0 || intArea < m_intSmallestExtraMarkArea[m_intTemplateIndex])
                                        m_intSmallestExtraMarkArea[m_intTemplateIndex] = intArea;

                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 51");
                                    if (m_intBiggestExtraMarkArea[m_intTemplateIndex] == 0 || intArea > m_intBiggestExtraMarkArea[m_intTemplateIndex])
                                        m_intBiggestExtraMarkArea[m_intTemplateIndex] = intArea;

                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 52");
                                    // Make sure object area is higher than min area and extra min area
                                    if ((intArea <= (int)Math.Round(objTemplateSetting.fExtraMinArea))) // if ((intArea <= m_intMinArea) || (intArea <= objTemplateSetting.intExtraMinArea))
                                    {
                                        continue;
                                    }

                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 53");
                                    // 2020 05 22 - CCENG: Move the "record extra mark area" coding to before check ExtraMinArea. This let user know current size of extra area and easier for them to do setting.
                                    //if (m_intSmallestExtraMarkArea[m_intTemplateIndex] == 0 || intArea < m_intSmallestExtraMarkArea[m_intTemplateIndex])
                                    //    m_intSmallestExtraMarkArea[m_intTemplateIndex] = intArea;

                                    //if (m_intBiggestExtraMarkArea[m_intTemplateIndex] == 0 || intArea > m_intBiggestExtraMarkArea[m_intTemplateIndex])
                                    //    m_intBiggestExtraMarkArea[m_intTemplateIndex] = intArea;

                                    // Check Extra Mark 
                                    if ((((intFailOptionMask & 0x02) > 0) || (!blnSkipExtraPadAndTextShiftedChecking && ((intFailOptionMask & 0x04) > 0)))) // Want Gauge !blnSkipExtraPadAndTextShiftedChecking &&
                                    {
                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 54");
                                        m_intBlobResult[m_intTemplateIndex][i] = 2;

                                        //if (m_intSmallestExtraMarkArea[m_intTemplateIndex] == 0 || intArea < m_intSmallestExtraMarkArea[m_intTemplateIndex])
                                        //    m_intSmallestExtraMarkArea[m_intTemplateIndex] = intArea;

                                        if ((m_intFailResultMask & 0x02) == 0)
                                            m_intFailResultMask |= 0x02;
                                    }

                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 55");

                                }
                            }
                            else
                            {
                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 56");
                                // Make sure area >= min area
                                if (intArea < m_intMinArea)
                                {
                                    continue;
                                }

                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 57");
                                // Set char hit by blob counter
                                for (j = 0; j < intMatchNumber.Count; j++)
                                {
                                    m_intHitCharCounter[intMatchNumber[j]]++;
                                }
                                float fStartX_Rotated, fStartY_Rotated, fEndX_Rotated, fEndY_Rotated;

                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 58");
                                for (j = 0; j < intMatchNumber.Count; j++)
                                {
                                    //2021-02-11 ZJYEOH : Rotate to 0 degree refer to OCV center point
                                    float newSX = 0, newSY = 0, newEX = 0, newEY = 0;

                                    fStartX_Rotated = m_intROIOffSetX + fStartX;
                                    fEndX_Rotated = m_intROIOffSetX + fEndX;
                                    fStartY_Rotated = m_intROIOffSetY + fStartY;
                                    fEndY_Rotated = m_intROIOffSetY + fEndY;

                                    Math2.GetNewXYAfterRotate_360deg((arrCharEndPoint_RotateTo0Deg[intMatchNumber[j]].X + arrCharStartPoint_RotateTo0Deg[intMatchNumber[j]].X) / 2, (arrCharEndPoint_RotateTo0Deg[intMatchNumber[j]].Y + arrCharStartPoint_RotateTo0Deg[intMatchNumber[j]].Y) / 2, fStartX_Rotated, fStartY_Rotated, -fMarkAngle, ref newSX, ref newSY);

                                    Math2.GetNewXYAfterRotate_360deg((arrCharEndPoint_RotateTo0Deg[intMatchNumber[j]].X + arrCharStartPoint_RotateTo0Deg[intMatchNumber[j]].X) / 2, (arrCharEndPoint_RotateTo0Deg[intMatchNumber[j]].Y + arrCharStartPoint_RotateTo0Deg[intMatchNumber[j]].Y) / 2, fEndX_Rotated, fEndY_Rotated, -fMarkAngle, ref newEX, ref newEY);
                                    //Point pStart = new Point((int)Math.Round(intROIOffSetX + newSX), (int)Math.Round(intROIOffSetY + newSY));
                                    //Point pEnd = new Point((int)Math.Round(intROIOffSetX + newEX), (int)Math.Round(intROIOffSetY + newEY));
                                    fStartX_Rotated = newSX;
                                    fStartY_Rotated = newSY;
                                    fEndX_Rotated = newEX;
                                    fEndY_Rotated = newEY;

                                    if (arrExcessStartX[intMatchNumber[j]] == -1)
                                    {
                                        arrExcessStartX[intMatchNumber[j]] = fStartX_Rotated;
                                    }
                                    else
                                    {
                                        if (arrExcessStartX[intMatchNumber[j]] > fStartX_Rotated)
                                            arrExcessStartX[intMatchNumber[j]] = fStartX_Rotated;
                                    }

                                    if (arrExcessStartY[intMatchNumber[j]] == -1)
                                    {
                                        arrExcessStartY[intMatchNumber[j]] = fStartY_Rotated;
                                    }
                                    else
                                    {
                                        if (arrExcessStartY[intMatchNumber[j]] > fStartY_Rotated)
                                            arrExcessStartY[intMatchNumber[j]] = fStartY_Rotated;
                                    }

                                    if (arrExcessEndX[intMatchNumber[j]] == -1)
                                    {
                                        arrExcessEndX[intMatchNumber[j]] = fEndX_Rotated;
                                    }
                                    else
                                    {
                                        if (arrExcessEndX[intMatchNumber[j]] < fEndX_Rotated)
                                            arrExcessEndX[intMatchNumber[j]] = fEndX_Rotated;
                                    }

                                    if (arrExcessEndY[intMatchNumber[j]] == -1)
                                    {
                                        arrExcessEndY[intMatchNumber[j]] = fEndY_Rotated;
                                    }
                                    else
                                    {
                                        if (arrExcessEndY[intMatchNumber[j]] < fEndY_Rotated)
                                            arrExcessEndY[intMatchNumber[j]] = fEndY_Rotated;
                                    }
                                }

                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 59");
                                // Check joint mark (1 blob match to more than 1 char)
                                if (intMatchNumber.Count > 1)
                                {
                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 60");
                                    //if ((intFailOptionMask & 0x80) > 0)
                                    //{
                                    //    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 61");
                                    //    int intDisabledMarkCounter = 0;
                                    //    int intEnabledMarkCounter = 0;
                                    //    for (int q = 0; q < intMatchNumber.Count; q++)
                                    //    {
                                    //        if (!m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[intMatchNumber[q]])
                                    //            intDisabledMarkCounter++;
                                    //        else
                                    //            intEnabledMarkCounter++;
                                    //    }

                                    //    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 63");

                                    //    if (intDisabledMarkCounter > 1 && intEnabledMarkCounter < intDisabledMarkCounter || intEnabledMarkCounter <= 1)
                                    //        goto Skip;

                                    //    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 64");
                                    //    m_intBlobResult[m_intTemplateIndex][i] = 2;

                                    //    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 65");
                                    //    for (int q = 0; q < intMatchNumber.Count; q++)
                                    //        m_blnCharResult[m_intTemplateIndex][intMatchNumber[q]] = false;

                                    //    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 66");
                                    //    if ((m_intFailResultMask & 0x80) == 0)
                                    //        m_intFailResultMask |= 0x80;
                                    //}

                                    //if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 67");
                                    //Skip: { }

                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 68");
                                }
                                else if (intMatchNumber.Count == 1)
                                {
                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 69");
                                    // 2018 11 27 - CCENG: Use missing mark to check broken mark will be better.
                                    //// Check Broken Mark (based on size)
                                    //int intWidth = 0, intHeight = 0;
                                    //objOCV.GetCharSize(intMatchNumber[0], ref intWidth, ref intHeight);

                                    //if ((intFailOptionMask & 0x20) > 0)
                                    //{
                                    //    if (fWidth < (intWidth - objTemplateSetting.intBrokenSize))
                                    //    {
                                    //        m_fGroupBrokenMarkLength[m_intTemplateIndex] = intWidth - fWidth;
                                    //        m_intBlobResult[m_intTemplateIndex][i] = 2;

                                    //        m_blnCharResult[m_intTemplateIndex][intMatchNumber[0]] = false;

                                    //        if ((m_intFailResultMask & 0x20) == 0)
                                    //            m_intFailResultMask |= 0x20;
                                    //    }
                                    //    else if (fHeight < (intHeight - objTemplateSetting.intBrokenSize))
                                    //    {
                                    //        m_fGroupBrokenMarkLength[m_intTemplateIndex] = intHeight - fHeight;
                                    //        m_intBlobResult[m_intTemplateIndex][i] = 2;

                                    //        m_blnCharResult[m_intTemplateIndex][intMatchNumber[0]] = false;

                                    //        if ((m_intFailResultMask & 0x20) == 0)
                                    //            m_intFailResultMask |= 0x20;
                                    //    }
                                    //}
                                }
                            }
                        }

                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 70");

                        for (int i = 0; i < intNumChars; i++)
                        {
                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 71");

                            // 2019 06 07 - CCENG: Check missing character using subtraction, but not use the m_intHitCharCounter. 
                            //// Check Missing Mark 
                            //if ((intFailOptionMask & 0x10) > 0)
                            //{
                            //    if (m_intHitCharCounter[i] == 0)
                            //    {
                            //        m_blnCharResult[m_intTemplateIndex][i] = false;

                            //        if ((m_intFailResultMask & 0x10) == 0)
                            //            m_intFailResultMask |= 0x10;
                            //    }
                            //}

                            // 2018 11 19 - CCENG: Use missing mark to check broken mark will be better.
                            // Check Broken Mark (Based on quantity blobs in char area)
                            //if ((intFailOptionMask & 0x20) > 0)
                            //{
                            //    if (m_intHitCharCounter[i] > 1)
                            //    {
                            //        m_blnCharResult[m_intTemplateIndex][i] = false;

                            //        if ((m_intFailResultMask & 0x20) == 0)
                            //            m_intFailResultMask |= 0x20;
                            //    }
                            //}
                        }

                        #endregion ----------------------------------------------------------------------------------------------------------

                        //2021-01-02 ZJYEOH : Broken mark use new method
                        if ((intFailOptionMask & 0x20) > 0 && blnWantCheckBrokenMark)
                        {
                            // Copy rotated image to sample image
                            objImage.CopyTo(ref m_objSampleImage);//objOcvRotatedImage
                            ImageDrawing objSampleImage_Temp = new ImageDrawing(true, m_objSampleImage.ref_intImageWidth, m_objSampleImage.ref_intImageHeight);
                            objImage.CopyTo(ref objSampleImage_Temp);//objOcvRotatedImage
                            ImageDrawing objSampleImage_Temp2 = new ImageDrawing(true, m_objSampleImage.ref_intImageWidth, m_objSampleImage.ref_intImageHeight);
                            objImage.CopyTo(ref objSampleImage_Temp2);//objOcvRotatedImage
                            ROI objSubtractCharROI = new ROI();
                            objSubtractCharROI.AttachImage(m_objSampleImage);

                            if (blnWantDebug)
                            {
                                m_objSampleImage.SaveImage("D:\\TS\\20.m_objSampleImage.bmp");

                            }

                            System.Drawing.Point pStart, pEnd;
                            List<ROI> arrTemplateCharErodeROI = new List<ROI>();

                            int intNumChars2 = objOCV.GetNumChars();

                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 111");

                            //List<float> arrMarkStartX = new List<float>();
                            //List<float> arrMarkStartY = new List<float>();
                            //List<float> arrMarkEndX = new List<float>();
                            //List<float> arrMarkEndY = new List<float>();

                            if (m_arrCharBrokenMarkResult[m_intTemplateIndex] == null)
                                m_arrCharBrokenMarkResult[m_intTemplateIndex] = new bool[intNumChars];

                            if (m_arrCharBrokenMarkResult[m_intTemplateIndex].Length != intNumChars)
                                m_arrCharBrokenMarkResult[m_intTemplateIndex] = new bool[intNumChars];

                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 112");
                            for (int a = 0; a < intNumChars; a++)
                            {
                                m_arrCharBrokenMarkResult[m_intTemplateIndex][a] = true;
                            }

                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 113");

                            for (int i = 0; i < intNumChars2; i++)
                            {
                                if (!m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrWantBrokenMark[i])
                                {
                                    // 2021 01 05 - CCENG: need to add into array also to prevent out of index
                                    arrTemplateCharErodeROI.Add(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrTemplateCharErodeROI[i]);
                                    continue;
                                }

                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 114");

                                arrTemplateCharErodeROI.Add(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrTemplateCharErodeROI[i]);
#if (Debug_2_12 || Release_2_12)
                                EasyImage.Threshold(arrTemplateCharErodeROI[i].ref_ROI, arrTemplateCharErodeROI[i].ref_ROI, (uint)intThresholdValue);
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)

                                EasyImage.Threshold(arrTemplateCharErodeROI[i].ref_ROI, arrTemplateCharErodeROI[i].ref_ROI, intThresholdValue);
#endif
                                pStart = objOCV.GetCharStartXY(i);
                                pEnd = objOCV.GetCharEndXY(i);

                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 115");

                                float fMinAddSizeX = (float)(arrTemplateCharErodeROI[i].ref_ROIWidth - (pEnd.X - pStart.X)) / 2;
                                float fMinAddSizeY = (float)(arrTemplateCharErodeROI[i].ref_ROIHeight - (pEnd.Y - pStart.Y)) / 2;

                                int intMinAddSizeStartX, intMinAddSizeStartY, intMinAddSizeEndX, intMinAddSizeEndY;
                                if (fMinAddSizeX == (int)fMinAddSizeX)
                                {
                                    intMinAddSizeStartX = (int)fMinAddSizeX;
                                    intMinAddSizeEndX = (int)fMinAddSizeX;
                                }
                                else
                                {
                                    intMinAddSizeStartX = (int)Math.Ceiling(fMinAddSizeX);
                                    intMinAddSizeEndX = (int)Math.Floor(fMinAddSizeX);
                                }

                                if (fMinAddSizeY == (int)fMinAddSizeY)
                                {
                                    intMinAddSizeStartY = (int)fMinAddSizeY;
                                    intMinAddSizeEndY = (int)fMinAddSizeY;
                                }
                                else
                                {
                                    intMinAddSizeStartY = (int)Math.Ceiling(fMinAddSizeY);
                                    intMinAddSizeEndY = (int)Math.Floor(fMinAddSizeY);
                                }

                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 116");

                                ROI objSampleCharROI = new ROI();

                                if ((m_intROIOffSetX + pStart.X - intMinAddSizeStartX) >= 0) //if ((pStart.X - intMinAddSizeStartX) >= 0)   // 2019 10 11 - CCENG: add m_intROIOffSetXY because objSampleCharROI attach to main Image.
                                    objSampleCharROI.ref_ROIPositionX = m_intROIOffSetX + pStart.X - intMinAddSizeStartX;
                                else
                                    objSampleCharROI.ref_ROIPositionX = m_intROIOffSetX;

                                if ((m_intROIOffSetY + pStart.Y - intMinAddSizeStartY) >= 0)  //if ((pStart.Y - intMinAddSizeStartY) >= 0)  // 2019 10 11 - CCENG: add m_intROIOffSetXY because objSampleCharROI attach to main Image.
                                    objSampleCharROI.ref_ROIPositionY = m_intROIOffSetY + pStart.Y - intMinAddSizeStartY;
                                else
                                    objSampleCharROI.ref_ROIPositionY = m_intROIOffSetY;

                                if ((pEnd.X + intMinAddSizeEndX * 2) < m_intImageWidth)
                                    objSampleCharROI.ref_ROIWidth = pEnd.X - pStart.X + intMinAddSizeStartX + intMinAddSizeEndX;
                                else
                                    continue;
                                if ((pEnd.Y + intMinAddSizeEndY * 2) < m_intImageHeight)
                                    objSampleCharROI.ref_ROIHeight = pEnd.Y - pStart.Y + intMinAddSizeStartY + intMinAddSizeEndY;
                                else
                                    continue;

                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 117");

                                // 2020 03 01 - CCENG: Attached to m_objSampleImage because objSampleCharROI will be Dilated when m_intMissingMarkInspectionMethod is 1. 
                                //                   : Also Dilate and subtract's image source and destination can be same.          
                                //objSampleCharROI.AttachImage(objImage);

                                //2020-06-17 ZJYEOH : objSampleCharROI should attach another image as m_objSampleImage will be image processsed
                                objSampleCharROI.AttachImage(objSampleImage_Temp);//m_objSampleImage

                                objSubtractCharROI.LoadROISetting(objSampleCharROI.ref_ROIPositionX, objSampleCharROI.ref_ROIPositionY,
                                                                    objSampleCharROI.ref_ROIWidth, objSampleCharROI.ref_ROIHeight);

                                if ((objSampleCharROI.ref_ROIWidth != arrTemplateCharErodeROI[i].ref_ROIWidth) ||
                                    (arrTemplateCharErodeROI[i].ref_ROIWidth != objSubtractCharROI.ref_ROIWidth))
                                    continue;

                                if ((objSampleCharROI.ref_ROIHeight != arrTemplateCharErodeROI[i].ref_ROIHeight) ||
                                    (arrTemplateCharErodeROI[i].ref_ROIHeight != objSubtractCharROI.ref_ROIHeight))
                                    continue;

                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 118");

                                //arrMarkStartX.Add(objSubtractCharROI.ref_ROIPositionX - m_intROIOffSetX);
                                //arrMarkStartY.Add(objSubtractCharROI.ref_ROIPositionY - m_intROIOffSetY);
                                //arrMarkEndX.Add(objSubtractCharROI.ref_ROIPositionX + objSubtractCharROI.ref_ROIWidth - m_intROIOffSetX);
                                //arrMarkEndY.Add(objSubtractCharROI.ref_ROIPositionY + objSubtractCharROI.ref_ROIHeight - m_intROIOffSetY);

                                if (!m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i] || !CheckWantInspectBrokenMark(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMarkType[i]))
                                {
                                    EasyImage.Oper(EArithmeticLogicOperation.Subtract, arrTemplateCharErodeROI[i].ref_ROI, arrTemplateCharErodeROI[i].ref_ROI, objSubtractCharROI.ref_ROI);
                                }
                                else
                                {
#if (Debug_2_12 || Release_2_12)
                                    EasyImage.Threshold(objSampleCharROI.ref_ROI, objSampleCharROI.ref_ROI, (uint)intThresholdValue);
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)

                                    EasyImage.Threshold(objSampleCharROI.ref_ROI, objSampleCharROI.ref_ROI, intThresholdValue);
#endif
                                    //2020-06-17 ZJYEOH : Image processing will be different for white on black and black one white

                                    if (m_blnWhiteOnBlack)
                                    {
                                        ROI.InvertOperationROI(arrTemplateCharErodeROI[i]);
                                        EasyImage.Oper(EArithmeticLogicOperation.Subtract, objSampleCharROI.ref_ROI, arrTemplateCharErodeROI[i].ref_ROI, objSubtractCharROI.ref_ROI);
                                        //2020-06-17 ZJYEOH : Invert back so that arrTemplateCharErodeROI[i] will not inverted if it is used again because inverted area may overlap another mark
                                        ROI.InvertOperationROI(arrTemplateCharErodeROI[i]);
                                    }
                                    else
                                    {
                                        //ROI.InvertOperationROI(objSampleCharROI);
                                        EasyImage.Oper(EArithmeticLogicOperation.Add, arrTemplateCharErodeROI[i].ref_ROI, objSampleCharROI.ref_ROI, objSubtractCharROI.ref_ROI);
                                        ////2020-06-17 ZJYEOH : Invert back so that objSampleCharROI will not inverted if it is used again because inverted area may overlap another mark
                                        //ROI.InvertOperationROI(objSampleCharROI);
                                    }

                                }

                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 119");

                                if (blnWantDebug)
                                {
                                    arrTemplateCharErodeROI[i].SaveImage("D:\\TS\\34.arrTemplateCharErodeROI[i]" + i.ToString() + ".bmp");
                                    objSampleCharROI.SaveImage("D:\\TS\\35.objSampleCharROI" + i.ToString() + ".bmp");
                                    objSubtractCharROI.SaveImage("D:\\TS\\36.objSubtractCharROI" + i.ToString() + ".bmp");
                                    m_objSampleImage.SaveImage("D:\\TS\\37.m_objSampleImage" + i.ToString() + ".bmp");
                                }

                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 120");

#if (Debug_2_12 || Release_2_12)
                                if (m_intEnhanceMark_LinkMark_HalfWidth > 0)
                                {
                                    if (m_blnWhiteOnBlack)
                                        EasyImage.CloseBox(objSubtractCharROI.ref_ROI, objSubtractCharROI.ref_ROI, (uint)m_intEnhanceMark_LinkMark_HalfWidth);
                                    else
                                        EasyImage.OpenBox(objSubtractCharROI.ref_ROI, objSubtractCharROI.ref_ROI, (uint)m_intEnhanceMark_LinkMark_HalfWidth);
                                }

                                if (m_intEnhanceMark_ReduceNoise_HalfWidth > 0)
                                {
                                    if (m_blnWhiteOnBlack)
                                        EasyImage.OpenBox(objSubtractCharROI.ref_ROI, objSubtractCharROI.ref_ROI, (uint)m_intEnhanceMark_ReduceNoise_HalfWidth);
                                    else
                                        EasyImage.CloseBox(objSubtractCharROI.ref_ROI, objSubtractCharROI.ref_ROI, (uint)m_intEnhanceMark_ReduceNoise_HalfWidth);
                                }
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                                   if (m_intEnhanceMark_LinkMark_HalfWidth > 0)
                                {
                                    if (m_blnWhiteOnBlack)
                                        EasyImage.CloseBox(objSubtractCharROI.ref_ROI, objSubtractCharROI.ref_ROI, m_intEnhanceMark_LinkMark_HalfWidth);
                                    else
                                        EasyImage.OpenBox(objSubtractCharROI.ref_ROI, objSubtractCharROI.ref_ROI, m_intEnhanceMark_LinkMark_HalfWidth);
                                }

                                if (m_intEnhanceMark_ReduceNoise_HalfWidth > 0)
                                {
                                    if (m_blnWhiteOnBlack)
                                        EasyImage.OpenBox(objSubtractCharROI.ref_ROI, objSubtractCharROI.ref_ROI, m_intEnhanceMark_ReduceNoise_HalfWidth);
                                    else
                                        EasyImage.CloseBox(objSubtractCharROI.ref_ROI, objSubtractCharROI.ref_ROI, m_intEnhanceMark_ReduceNoise_HalfWidth);
                                }
#endif
                                if (m_objBrokenBlobs[m_intTemplateIndex] == null)
                                    m_objBrokenBlobs[m_intTemplateIndex] = new EBlobs();
                                else
                                    m_objBrokenBlobs[m_intTemplateIndex].CleanAllBlobs();

                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 123");
                                if (blnWantDebug)
                                {
                                    objSubtractCharROI.SaveImage("D:\\TS\\42.objSubtractCharROI.bmp");
                                }

                                //2020-06-17 ZJYEOH : Threshold will invert for white on black
                                int intMissingThreshold = intThresholdValue;
                                if (m_blnWhiteOnBlack)
                                {
                                    intMissingThreshold = intThresholdValue;
                                }


                                if (BuildObject(m_objBrokenBlobs[m_intTemplateIndex], objSubtractCharROI, false, true, intMissingThreshold, m_intMinArea, 1000000, 0x1F)) //255 - intThresholdValue
                                {
                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 124");
                                    int intNoBlobs = m_objBrokenBlobs[m_intTemplateIndex].ref_intNumSelectedObject;

                                    if (intNoBlobs > 1)
                                    {
                                        // 2021 01 05 - m_blnCharResult is for score result, not for broken mark
                                        //if (m_blnCharResult[m_intTemplateIndex][i])
                                        //    m_blnCharResult[m_intTemplateIndex][i] = false;

                                        if (m_arrCharBrokenMarkResult[m_intTemplateIndex][i])
                                            m_arrCharBrokenMarkResult[m_intTemplateIndex][i] = false;

                                        if ((m_intFailResultMask & 0x20) == 0)
                                            m_intFailResultMask |= 0x20;
                                    }
                                }

                                objSampleCharROI.Dispose();
                            }

                            objSampleImage_Temp.Dispose();
                            objSampleImage_Temp2.Dispose();
                            objSubtractCharROI.Dispose();
                        }

                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 72");

                        #region ----------- Check Excess mark and Missing Mark in characters area using substract function and grey value ---------------------
                        // If text score does not fail
                        if ((m_intFailResultMask & 0x200) == 0 || m_blnWantUseExcessMissingMarkAffectScore)
                        {
                            //-------------------------------------- Check Excess mark in characters area ---------------------------------------//
                            if (((intFailOptionMask & 0x01) > 0) || (((intFailOptionMask & 0x100) > 0) && m_blnWantCheckTotalExcessMark) || m_blnWantUseExcessMissingMarkAffectScore || ShowLiterationOnly) // Excess Mark Char Area is ON
                            {
                                //if ((m_intFailResultMask & 0x08) == 0)      // 2019 06 28 - Check Excess Mark only if no Group extra mark failure. Because excess inpsection take quite long time and if too many extra makr, it will take too long time for isnpection.
                                {
                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 73");
                                    // Copy rotated image to sample image
                                    //ImageDrawing objSampleImage = new ImageDrawing();
                                    if (blnWantDebug)
                                    {
                                        objOcvRotatedImage.SaveImage("D:\\TS\\10.objOcvRotatedImage.bmp");
                                    }

                                    //objOcvRotatedImage.CopyTo(ref m_objSampleImage);
                                    if (m_blnWantDontCareArea)
                                        m_objDontCareBackupImage.CopyTo(ref m_objSampleImage);
                                    else
                                        objImage.CopyTo(ref m_objSampleImage);

                                    ROI objSubtractCharROI = new ROI();

                                    ImageDrawing objSubtractImage_Temp = new ImageDrawing(true, m_objSampleImage.ref_intImageWidth, m_objSampleImage.ref_intImageHeight);
                                    if (m_intExtraExcessMarkInspectionAreaCutMode != 0)
                                    {
                                        if (m_blnWhiteOnBlack)
                                            objBlackImage.CopyTo(ref objSubtractImage_Temp);
                                        else
                                            objWhiteImage.CopyTo(ref objSubtractImage_Temp);
                                        objSubtractCharROI.AttachImage(objSubtractImage_Temp);
                                    }
                                    else
                                        objSubtractCharROI.AttachImage(m_objSampleImage);

                                    if (m_blnWantDontCareArea)
                                    {
                                        //Point pMarkROIStartPoint = new Point(objMarkPackageMarkROI.ref_ROIPositionX, objMarkPackageMarkROI.ref_ROIPositionY);
                                        int intOffsetX = 0;//(int)Math.Round(Math.Abs(objMarkPackageMarkROI.ref_ROIWidth - m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].objLearnDilateImage.ref_intImageWidth) / 2f);
                                        int intOffsetY = 0;//(int)Math.Round(Math.Abs(objMarkPackageMarkROI.ref_ROIHeight - m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].objLearnDilateImage.ref_intImageHeight) / 2f);
                                        ROI objDontCareROI = new ROI();
                                        //objDontCareROI.LoadROISetting(0, 0, objMarkPackageMarkROI.ref_ROIWidth, objMarkPackageMarkROI.ref_ROIHeight);
                                        //objDontCareROI.AttachImage(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].objDontCareImage);
                                        ////objDontCareROI.SaveImage("D:\\objDontCareROI1.bmp");
                                        //ImageDrawing objImgDontCare = new ImageDrawing(true, m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].objDontCareImage.ref_intImageWidth, m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].objDontCareImage.ref_intImageHeight);
                                        //ROI.Rotate0Degree_Better(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].objDontCareImage, objDontCareROI, -fMarkAngle, 4, ref objImgDontCare);
                                        //objDontCareROI.AttachImage(objImgDontCare);
                                        ////objDontCareROI.SaveImage("D:\\objDontCareROI12.bmp");
                                        //objSubtractCharROI.LoadROISetting(objMarkPackageMarkROI.ref_ROITotalX + intOffsetX, objMarkPackageMarkROI.ref_ROITotalY + intOffsetY, objMarkPackageMarkROI.ref_ROIWidth, objMarkPackageMarkROI.ref_ROIHeight);
                                        ////2020-06-17 ZJYEOH : Subtract or Add depends on white on black or black on white
                                        //if (m_blnWhiteOnBlack)
                                        //    ROI.SubtractROI(objSubtractCharROI, objDontCareROI);
                                        //else
                                        //    ROI.LogicOperationAddROI(objSubtractCharROI, objDontCareROI);
                                        //objSubtractCharROI.LoadROISetting(objMarkPackageMarkROI.ref_ROIPositionX - intOffsetX, objMarkPackageMarkROI.ref_ROIPositionY - intOffsetY, objMarkPackageMarkROI.ref_ROIWidth, objMarkPackageMarkROI.ref_ROIHeight);

                                        ImageDrawing objImgDontCare = new ImageDrawing(true, m_objSampleImage.ref_intImageWidth, m_objSampleImage.ref_intImageHeight);
                                        ImageDrawing objImgDontCare_Rotated = new ImageDrawing(true, m_objSampleImage.ref_intImageWidth, m_objSampleImage.ref_intImageHeight);
                                        objBlackImage.CopyTo(ref objImgDontCare);
                                        ROI objOriROI = new ROI();
                                        for (int i = 0; i < arrMarkDontCareROI.Count; i++)
                                        {
                                            objOriROI.AttachImage(objImgDontCare);

                                            objDontCareROI.AttachImage(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrDontCareImage[i]);// objWhiteImage

                                            objOriROI.LoadROISetting(objMarkPackageMarkROI.ref_ROITotalCenterX - arrMarkDontCareROI[i].ref_intStartOffsetX,
                                                                     objMarkPackageMarkROI.ref_ROITotalCenterY - arrMarkDontCareROI[i].ref_intStartOffsetY,
                                                                     arrMarkDontCareROI[i].ref_ROIWidth, arrMarkDontCareROI[i].ref_ROIHeight);

                                            objDontCareROI.LoadROISetting(objMarkPackageMarkROI.ref_ROITotalCenterX - arrMarkDontCareROI[i].ref_intStartOffsetX,
                                                                          objMarkPackageMarkROI.ref_ROITotalCenterY - arrMarkDontCareROI[i].ref_intStartOffsetY,
                                                                          arrMarkDontCareROI[i].ref_ROIWidth, arrMarkDontCareROI[i].ref_ROIHeight);

                                            //if (m_blnWhiteOnBlack)
                                            //    ROI.SubtractROI(objOriROI, objDontCareROI);
                                            //else
                                            ROI.LogicOperationAddROI(objOriROI, objDontCareROI);
                                            //objImgDontCare.SaveImage("D:\\objImgDontCare" + i.ToString() + ".bmp");
                                        }
                                        objOriROI.Dispose();

                                        objSubtractCharROI.LoadROISetting(objMarkPackageMarkROI.ref_ROITotalX + intOffsetX, objMarkPackageMarkROI.ref_ROITotalY + intOffsetY, objMarkPackageMarkROI.ref_ROIWidth, objMarkPackageMarkROI.ref_ROIHeight);
                                        objDontCareROI.LoadROISetting(objMarkPackageMarkROI.ref_ROITotalX + intOffsetX, objMarkPackageMarkROI.ref_ROITotalY + intOffsetY, objMarkPackageMarkROI.ref_ROIWidth, objMarkPackageMarkROI.ref_ROIHeight);
                                        ROI.Rotate0Degree_Better(objImgDontCare, objDontCareROI, -fMarkAngle, 4, ref objImgDontCare_Rotated);
                                        objDontCareROI.AttachImage(objImgDontCare_Rotated);
                                        //objImgDontCare_Rotated.SaveImage("D:\\objImgDontCare_Rotated.bmp");
                                        //objDontCareROI.SaveImage("D:\\objDontCareROI.bmp");
                                        if (m_blnWhiteOnBlack)
                                            ROI.SubtractROI(objSubtractCharROI, objDontCareROI);
                                        else
                                            ROI.LogicOperationAddROI(objSubtractCharROI, objDontCareROI);
                                        objSubtractCharROI.LoadROISetting(objMarkPackageMarkROI.ref_ROITotalX - intOffsetX, objMarkPackageMarkROI.ref_ROITotalY - intOffsetY, objMarkPackageMarkROI.ref_ROIWidth, objMarkPackageMarkROI.ref_ROIHeight);
                                        objImgDontCare_Rotated.Dispose();
                                        //objSubtractCharROI.SaveImage("D:\\objSubtractCharROI.bmp");
                                        objDontCareROI.Dispose();
                                        objImgDontCare.Dispose();
                                    }

                                    ROI objDilateROI = new ROI();
                                    ImageDrawing objDilateImage = new ImageDrawing(true, m_objSampleImage.ref_intImageWidth, m_objSampleImage.ref_intImageHeight);
                                    objDilateROI.AttachImage(objDilateImage);
                                    System.Drawing.Point pStart, pEnd;
                                    List<ROI> arrTemplateCharDilateROI = new List<ROI>();
                                    List<float> arrTemplateStartX = new List<float>();
                                    List<float> arrTemplateStartY = new List<float>();
                                    List<float> arrTemplateEndX = new List<float>();
                                    List<float> arrTemplateEndY = new List<float>();
                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 74");
                                    for (int i = 0; i < intNumChars; i++)
                                    {

                                        //// 2020-08-11 ZJYEOH : Skip Check Excess if mark is disabled
                                        //if (!m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i])
                                        //    continue;

                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 75");
                                        arrTemplateCharDilateROI.Add(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrTemplateCharDilateROI[i]);
#if (Debug_2_12 || Release_2_12)
                                        EasyImage.Threshold(arrTemplateCharDilateROI[i].ref_ROI, arrTemplateCharDilateROI[i].ref_ROI, (uint)intThresholdValue);
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                                        EasyImage.Threshold(arrTemplateCharDilateROI[i].ref_ROI, arrTemplateCharDilateROI[i].ref_ROI, intThresholdValue);
#endif

                                        pStart = objOCV.GetCharStartXY(i);
                                        pEnd = objOCV.GetCharEndXY(i);
                                        float newSX = 0, newSY = 0, newEX = 0, newEY = 0;
                                        Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2, pStart.X, pStart.Y, -(intOrientationAngle + fMarkAngle), ref newSX, ref newSY);

                                        Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2, pEnd.X, pEnd.Y, -(intOrientationAngle + fMarkAngle), ref newEX, ref newEY);
                                        pStart = new Point((int)Math.Round(newSX), (int)Math.Round(newSY));
                                        pEnd = new Point((int)Math.Round(newEX), (int)Math.Round(newEY));

                                        if (m_intExtraExcessMarkInspectionAreaCutMode == 2)
                                        {
                                            pStart = new Point(pStart.X - ((int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftX[i] + m_fCharROIOffsetX)),
                                                               pStart.Y - ((int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftY[i] + m_fCharROIOffsetY)));
                                            pEnd = new Point(pEnd.X + ((int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftX[i] + m_fCharROIOffsetX)),
                                                             pEnd.Y + ((int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftY[i] + m_fCharROIOffsetY)));
                                        }

                                        List<Point> arrPoints = new List<Point>();
                                        arrPoints.Add(pStart);
                                        arrPoints.Add(new Point(pStart.X + (pEnd.X - pStart.X), pStart.Y));
                                        arrPoints.Add(new Point(pStart.X, pStart.Y + (pEnd.Y - pStart.Y)));
                                        arrPoints.Add(pEnd);

                                        PointF pTemp = new PointF();
                                        Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
                                                                         arrPoints[0],
                                                                         -(intOrientationAngle + fMarkAngle),
                                                                         ref pTemp);
                                        arrPoints[0] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

                                        Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
                                                                         arrPoints[1],
                                                                         -(intOrientationAngle + fMarkAngle),
                                                                         ref pTemp);
                                        arrPoints[1] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

                                        Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
                                                                         arrPoints[2],
                                                                         -(intOrientationAngle + fMarkAngle),
                                                                         ref pTemp);
                                        arrPoints[2] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

                                        Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
                                                                         arrPoints[3],
                                                                         -(intOrientationAngle + fMarkAngle),
                                                                         ref pTemp);
                                        arrPoints[3] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

                                        float fMinX = float.MaxValue;
                                        float fMinY = float.MaxValue;
                                        float fMaxX = 0;
                                        float fMaxY = 0;
                                        for (int a = 0; a < arrPoints.Count; a++)
                                        {
                                            if (fMinX > arrPoints[a].X)
                                                fMinX = arrPoints[a].X;

                                            if (fMinY > arrPoints[a].Y)
                                                fMinY = arrPoints[a].Y;

                                            if (fMaxX < arrPoints[a].X)
                                                fMaxX = arrPoints[a].X;

                                            if (fMaxY < arrPoints[a].Y)
                                                fMaxY = arrPoints[a].Y;
                                        }

                                        //if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 76");
                                        //float fMinAddSizeX = (float)(arrTemplateCharDilateROI[i].ref_ROIWidth - (pEnd.X - pStart.X)) / 2;
                                        //float fMinAddSizeY = (float)(arrTemplateCharDilateROI[i].ref_ROIHeight - (pEnd.Y - pStart.Y)) / 2;

                                        //int intMinAddSizeStartX, intMinAddSizeStartY, intMinAddSizeEndX, intMinAddSizeEndY;
                                        //if (fMinAddSizeX == (int)fMinAddSizeX)
                                        //{
                                        //    intMinAddSizeStartX = (int)fMinAddSizeX;
                                        //    intMinAddSizeEndX = (int)fMinAddSizeX;
                                        //}
                                        //else
                                        //{
                                        //    intMinAddSizeStartX = (int)Math.Ceiling(fMinAddSizeX);
                                        //    intMinAddSizeEndX = (int)Math.Floor(fMinAddSizeX);
                                        //}

                                        //if (fMinAddSizeY == (int)fMinAddSizeY)
                                        //{
                                        //    intMinAddSizeStartY = (int)fMinAddSizeY;
                                        //    intMinAddSizeEndY = (int)fMinAddSizeY;
                                        //}
                                        //else
                                        //{
                                        //    intMinAddSizeStartY = (int)Math.Ceiling(fMinAddSizeY);
                                        //    intMinAddSizeEndY = (int)Math.Floor(fMinAddSizeY);
                                        //}

                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 77");
                                        ROI objSampleCharROI = new ROI();

                                        //if ((m_intROIOffSetX + pStart.X - intMinAddSizeStartX) >= 0) //if ((pStart.X - intMinAddSizeStartX) >= 0)   // 2019 10 11 - CCENG: add m_intROIOffSetXY because objSampleCharROI attach to main Image.
                                        //    objSampleCharROI.ref_ROIPositionX = m_intROIOffSetX + pStart.X - intMinAddSizeStartX;
                                        //else
                                        //    objSampleCharROI.ref_ROIPositionX = m_intROIOffSetX;

                                        //if ((m_intROIOffSetY + pStart.Y - intMinAddSizeStartY) >= 0)  //if ((pStart.Y - intMinAddSizeStartY) >= 0)  // 2019 10 11 - CCENG: add m_intROIOffSetXY because objSampleCharROI attach to main Image.
                                        //    objSampleCharROI.ref_ROIPositionY = m_intROIOffSetY + pStart.Y - intMinAddSizeStartY;
                                        //else
                                        //    objSampleCharROI.ref_ROIPositionY = m_intROIOffSetY;

                                        //if ((pEnd.X + intMinAddSizeEndX * 2) < m_intImageWidth)
                                        //    objSampleCharROI.ref_ROIWidth = pEnd.X - pStart.X + intMinAddSizeStartX + intMinAddSizeEndX;
                                        //else
                                        //    continue;
                                        //if ((pEnd.Y + intMinAddSizeEndY * 2) < m_intImageHeight)
                                        //    objSampleCharROI.ref_ROIHeight = pEnd.Y - pStart.Y + intMinAddSizeStartY + intMinAddSizeEndY;
                                        //else
                                        //    continue;

                                        objSampleCharROI.AttachImage(m_objSampleImage);//objOcvRotatedImage

                                        //objSubtractCharROI.LoadROISetting(objSampleCharROI.ref_ROIPositionX, objSampleCharROI.ref_ROIPositionY,
                                        //                                    objSampleCharROI.ref_ROIWidth, objSampleCharROI.ref_ROIHeight);

                                        objSubtractCharROI.LoadROISetting((int)Math.Round(m_intROIOffSetX + fMinX), (int)Math.Round(m_intROIOffSetY + fMinY),
                                           (int)Math.Round(fMaxX - fMinX), (int)Math.Round(fMaxY - fMinY));

                                        objSampleCharROI.LoadROISetting((int)Math.Round(m_intROIOffSetX + fMinX), (int)Math.Round(m_intROIOffSetY + fMinY),
                                           (int)Math.Round(fMaxX - fMinX), (int)Math.Round(fMaxY - fMinY));

                                        arrTemplateStartX.Add(objSampleCharROI.ref_ROIPositionX - m_intROIOffSetX);
                                        arrTemplateStartY.Add(objSampleCharROI.ref_ROIPositionY - m_intROIOffSetY);
                                        arrTemplateEndX.Add(objSampleCharROI.ref_ROIPositionX + objSampleCharROI.ref_ROIWidth - m_intROIOffSetX);
                                        arrTemplateEndY.Add(objSampleCharROI.ref_ROIPositionY + objSampleCharROI.ref_ROIHeight - m_intROIOffSetY);

                                        //if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 78");
                                        //if ((objSampleCharROI.ref_ROIWidth != arrTemplateCharDilateROI[i].ref_ROIWidth) ||
                                        //    (arrTemplateCharDilateROI[i].ref_ROIWidth != objSubtractCharROI.ref_ROIWidth))
                                        //    continue;

                                        //if ((objSampleCharROI.ref_ROIHeight != arrTemplateCharDilateROI[i].ref_ROIHeight) ||
                                        //    (arrTemplateCharDilateROI[i].ref_ROIHeight != objSubtractCharROI.ref_ROIHeight))
                                        //    continue;

                                        objDilateROI.LoadROISetting((int)Math.Round(m_intROIOffSetX + fMinX), (int)Math.Round(m_intROIOffSetY + fMinY),
                                           (int)Math.Round(fMaxX - fMinX), (int)Math.Round(fMaxY - fMinY));

                                        //objDilateROI.LoadROISetting(arrTemplateCharDilateROI[i].ref_ROITotalX, arrTemplateCharDilateROI[i].ref_ROITotalY, arrTemplateCharDilateROI[i].ref_ROIWidth, arrTemplateCharDilateROI[i].ref_ROIHeight);
                                        //arrTemplateCharDilateROI[i].SaveImage("D:\\arrTemplateCharDilateROI.bmp");
                                        //objDilateROI.SaveImage("D:\\objDilateROI.bmp");
                                        arrTemplateCharDilateROI[i].CopyImage(ref objDilateROI);
                                        ROI.Rotate0Degree_ForDontCare(arrTemplateCharDilateROI[i], -(intOrientationAngle + fMarkAngle), 4, objDilateROI);
                                        //arrTemplateCharDilateROI[i].SaveImage("D:\\arrTemplateCharDilateROI.bmp");
                                        //objDilateROI.SaveImage("D:\\objDilateROI.bmp");

                                        //objDilateROI.LoadROISetting(objSampleCharROI.ref_ROIPositionX, objSampleCharROI.ref_ROIPositionY,
                                        //                                    objSampleCharROI.ref_ROIWidth, objSampleCharROI.ref_ROIHeight);

                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 79");
                                        if (m_intExtraExcessMarkInspectionAreaCutMode != 0)
                                        {
                                            if (!m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i] || !CheckWantInspectExcessMark(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMarkType[i]))
                                            {
                                                //ROI.InvertOperationROI(objSubtractCharROI);
                                                EasyImage.Oper(EArithmeticLogicOperation.Add, objSubtractCharROI.ref_ROI, new EBW8(255), objSubtractCharROI.ref_ROI);
                                            }
                                            else
                                            {
                                                //2020-06-17 ZJYEOH : Image processing will be different for white on black and black one white
                                                if (m_blnWhiteOnBlack)
                                                {
                                                    EasyImage.Oper(EArithmeticLogicOperation.Add, objSubtractCharROI.ref_ROI, objDilateROI.ref_ROI, objSubtractCharROI.ref_ROI);
                                                }
                                                else
                                                {
                                                    //EasyImage.Oper(EArithmeticLogicOperation.Invert, objDilateROI.ref_ROI, objDilateROI.ref_ROI);
                                                    //ROI.InvertOperationROI(objDilateROI);
                                                    EasyImage.Oper(EArithmeticLogicOperation.Subtract, objSubtractCharROI.ref_ROI, objDilateROI.ref_ROI, objSubtractCharROI.ref_ROI);
                                                    //EasyImage.Oper(EArithmeticLogicOperation.Invert, arrTemplateCharDilateROI[i].ref_ROI, arrTemplateCharDilateROI[i].ref_ROI);
                                                }

                                            }
                                        }
                                        else
                                        {
                                            if (!m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i] || !CheckWantInspectExcessMark(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMarkType[i]))
                                            {
                                                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objSampleCharROI.ref_ROI, objSampleCharROI.ref_ROI, objSubtractCharROI.ref_ROI);
                                            }
                                            else
                                            {
                                                //2020-06-17 ZJYEOH : Image processing will be different for white on black and black one white
                                                if (m_blnWhiteOnBlack)
                                                {
                                                    EasyImage.Oper(EArithmeticLogicOperation.Subtract, objSampleCharROI.ref_ROI, objDilateROI.ref_ROI, objSubtractCharROI.ref_ROI);
                                                }
                                                else
                                                {
                                                    //EasyImage.Oper(EArithmeticLogicOperation.Invert, objDilateROI.ref_ROI, objDilateROI.ref_ROI);
                                                    ROI.InvertOperationROI(objDilateROI);
                                                    EasyImage.Oper(EArithmeticLogicOperation.Add, objSampleCharROI.ref_ROI, objDilateROI.ref_ROI, objSubtractCharROI.ref_ROI);
                                                    //EasyImage.Oper(EArithmeticLogicOperation.Invert, arrTemplateCharDilateROI[i].ref_ROI, arrTemplateCharDilateROI[i].ref_ROI);
                                                }

                                            }
                                        }

                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 80");

                                        if (blnWantDebug)
                                        {
                                            objDilateROI.SaveImage("D:\\TS\\13.objDilateROI" + i.ToString() + ".bmp");
                                            objSampleCharROI.SaveImage("D:\\TS\\13.objSampleCharROI" + i.ToString() + ".bmp");
                                            arrTemplateCharDilateROI[i].SaveImage("D:\\TS\\14.arrTemplateCharDilateROI[i]" + i.ToString() + ".bmp");
                                            objSubtractCharROI.SaveImage("D:\\TS\\15.objSubtractCharROI" + i.ToString() + ".bmp");
                                            m_objSampleImage.SaveImage("D:\\TS\\16.m_objSampleImage" + i.ToString() + ".bmp");
                                        }

                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 81");

                                        objSampleCharROI.Dispose();
                                    }
                                    objDilateROI.Dispose();
                                    objDilateImage.Dispose();
                                    //2020-06-23 ZJYEOH : if no check package size, pRotatedCenterPoint will be (-1, -1)
                                    //if (pRotatedCenterPoint != new PointF(-1, -1))
                                    //{
                                    //    m_objLocalTemporary_RotateSearchROI.AttachImage(m_objSampleImage);
                                    //    m_objLocalTemporary_RotateSearchROI.LoadROISetting((int)Math.Round(pRotatedCenterPoint.X - objMarkPackageSearchROI.ref_ROIWidth / 2, 0, MidpointRounding.AwayFromZero),
                                    //                                      (int)Math.Round(pRotatedCenterPoint.Y - objMarkPackageSearchROI.ref_ROIHeight / 2, 0, MidpointRounding.AwayFromZero),
                                    //                                      objMarkPackageSearchROI.ref_ROIWidth, objMarkPackageSearchROI.ref_ROIHeight);

                                    //    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 82");
                                    //    ROI.RotateROI(m_objLocalTemporary_RotateSearchROI, fPackageAngle - fMarkAngle, ref m_objSampleImage);
                                    //}

                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 83");
                                    if (blnWantDebug)
                                    {
                                        m_objSampleImage.SaveImage("D:\\TS\\17m_objSampleImage.bmp");
                                    }

                                    if (m_intExtraExcessMarkInspectionAreaCutMode != 0)
                                        objSubtractCharROI.AttachImage(objSubtractImage_Temp);
                                    else
                                        objSubtractCharROI.AttachImage(m_objSampleImage);

                                    // Reload ROI size and placement to same location and same size as Mark ROI
                                    objSubtractCharROI.LoadROISetting(m_intROIOffSetX, m_intROIOffSetY, objMarkPackageMarkROI.ref_ROIWidth, objMarkPackageMarkROI.ref_ROIHeight);

                                    if (blnWantDebug)
                                    {
                                        objSubtractCharROI.SaveImage("D:\\TS\\18.objSubtractCharROI.bmp");
                                    }

                                    if (m_intExtraExcessMarkInspectionAreaCutMode != 0)
                                    {
                                        ROI objSampleCharROI_Temp = new ROI();
                                        objSampleCharROI_Temp.AttachImage(m_objSampleImage);
                                        objSampleCharROI_Temp.LoadROISetting(m_intROIOffSetX, m_intROIOffSetY, objMarkPackageMarkROI.ref_ROIWidth, objMarkPackageMarkROI.ref_ROIHeight);

                                        if (blnWantDebug)
                                        {
                                            objSampleCharROI_Temp.SaveImage("D:\\TS\\18_0.objSampleCharROI_Temp.bmp");
                                        }

                                        //2020-06-17 ZJYEOH : Image processing will be different for white on black and black one white
                                        if (m_blnWhiteOnBlack)
                                        {
                                            EasyImage.Oper(EArithmeticLogicOperation.Subtract, objSampleCharROI_Temp.ref_ROI, objSubtractCharROI.ref_ROI, objSubtractCharROI.ref_ROI);
                                            objSampleCharROI_Temp.AttachImage(objImage_Temp);
                                            EasyImage.Oper(EArithmeticLogicOperation.Subtract, objSubtractCharROI.ref_ROI, objSampleCharROI_Temp.ref_ROI, objSubtractCharROI.ref_ROI);
                                        }
                                        else
                                        {
                                            //ROI.InvertOperationROI(objSubtractCharROI);
                                            EasyImage.Oper(EArithmeticLogicOperation.Add, objSampleCharROI_Temp.ref_ROI, objSubtractCharROI.ref_ROI, objSubtractCharROI.ref_ROI);
                                            //objSampleCharROI_Temp.AttachImage(objImage_Temp);
                                            //EasyImage.Oper(EArithmeticLogicOperation.Add, objSampleCharROI_Temp.ref_ROI, objSubtractCharROI.ref_ROI, objSubtractCharROI.ref_ROI);
                                        }

                                        if (blnWantDebug)
                                        {
                                            objSampleCharROI_Temp.SaveImage("D:\\TS\\18_1.objSampleCharROI_Temp.bmp");
                                            objSubtractCharROI.SaveImage("D:\\TS\\18_1.objSubtractCharROI.bmp");
                                        }

                                        objSampleCharROI_Temp.Dispose();

                                    }

//////////#if (Debug_2_12 || Release_2_12)
//////////                                    if (m_intCharOpenHalfWidth > 0)
//////////                                        EasyImage.OpenBox(objSubtractCharROI.ref_ROI, objSubtractCharROI.ref_ROI, (uint)m_intCharOpenHalfWidth);
//////////#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)

//////////                                if (m_intCharOpenHalfWidth > 0)
//////////                                    EasyImage.OpenBox(objSubtractCharROI.ref_ROI, objSubtractCharROI.ref_ROI, m_intCharOpenHalfWidth);
//////////#endif

                                    if (m_objExcessBlobs[m_intTemplateIndex] == null)
                                        m_objExcessBlobs[m_intTemplateIndex] = new EBlobs();
                                    else
                                        m_objExcessBlobs[m_intTemplateIndex].CleanAllBlobs();

                                    if (m_arrCharExcessAreaResult[m_intTemplateIndex] == null)
                                        m_arrCharExcessAreaResult[m_intTemplateIndex] = new int[intNumChars];

                                    if (m_arrCharExcessAreaResult[m_intTemplateIndex].Length != intNumChars)
                                        m_arrCharExcessAreaResult[m_intTemplateIndex] = new int[intNumChars];

                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 84");

                                    for (int a = 0; a < intNumChars; a++)
                                    {
                                        m_arrCharExcessAreaResult[m_intTemplateIndex][a] = 0;
                                    }

                                    if (blnWantDebug)
                                    {
                                        objSubtractCharROI.SaveImage("D:\\TS\\19.objSubtractCharROI.bmp");
                                    }

                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 85");

                                    int intExcessThreshold = intThresholdValue; //2021-02-17 ZJYEOH : Use back mark threshold as excess will attach to mark

                                    if (m_blnSeparateExtraMarkThreshold)
                                    {
                                        if (m_blnWantExcessMarkThresholdFollowExtraMarkThreshold)
                                            intExcessThreshold = GetAutoThresholdExtraMark(objMarkPackageMarkROI);
                                    }

                                    if (ShowLiterationOnly)
                                    {
                                        obj_temp2.Dispose();
                                        obj_temp2 = new ImageDrawing();
                                        objSubtractCharROI.CopyToImage(ref obj_temp2);
                                    }

                                    if (BuildObject(m_objExcessBlobs[m_intTemplateIndex], objSubtractCharROI, false, true, intExcessThreshold, m_intMinArea, 1000000, 0x1F)) //intThresholdValue
                                    {
                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 86");

                                        int intNoExcessBlobs = m_objExcessBlobs[m_intTemplateIndex].ref_intNumSelectedObject;

                                        // Init blob data
                                        m_intExcessBlobResult[m_intTemplateIndex] = new int[intNoExcessBlobs];
                                        List<int> arrintMatchNo = new List<int>(intNoExcessBlobs);
                                        for (j = 0; j < intNoExcessBlobs; j++)
                                        {
                                            m_intExcessBlobResult[m_intTemplateIndex][j] = 0;
                                            arrintMatchNo.Add(-1);
                                        }
                                        float fExcessCenterX = 0.0f, fExcessCenterY = 0.0f;

                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 87");
                                        // Scan all subtracted blobs to check whether the blob has been fail in Extra Mark/Group Extra Mark checking above.(For extra mark in check area)
                                        for (int i = 0; i < intNoExcessBlobs; i++)
                                        {
                                            fExcessCenterX = m_objExcessBlobs[m_intTemplateIndex].ref_arrLimitCenterX[i];
                                            fExcessCenterY = m_objExcessBlobs[m_intTemplateIndex].ref_arrLimitCenterY[i];
                                            intArea = m_objExcessBlobs[m_intTemplateIndex].ref_arrArea[i];     // Get subtracted blob area                                                                                                                      // Get subtracted blob contour xy first point
                                            intContourX = m_objExcessBlobs[m_intTemplateIndex].ref_arrContourX[i];
                                            intContourY = m_objExcessBlobs[m_intTemplateIndex].ref_arrContourY[i];
                                            m_objExcessBlobs[m_intTemplateIndex].DisposeElement(i);

                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 88");
                                            // Make sure the subtracted blob pass min area requirement before consider it as excess mark
                                            // Use m_intMinArea as min area if m_intMinArea < 5, else use 5 as min area
                                            if (m_intMinArea < 5)
                                            {
                                                // skip checking if blob area lower than setting
                                                if (intArea <= m_intMinArea)
                                                {
                                                    continue;
                                                }
                                            }
                                            else
                                            {
                                                // skip checking if blob area lower than setting
                                                if (intArea <= 5)
                                                {
                                                    continue;
                                                }
                                            }

                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 89");
                                            // Make sure subtracted blob is in Char area before consider it as excess mark
                                            int intMatchNo = -1;
                                            List<int> arrSingleMatchNo = new List<int>();
                                            bool IsInExcessROIArea = false;
                                            float fExcessCenterX_Rotated, fExcessCenterY_Rotated;
                                            for (j = 0; j < arrExcessStartX.Count; j++)
                                            {
                                                //2021-02-11 ZJYEOH : Rotate to 0 degree refer to OCV center point
                                                float newX = 0, newY = 0;

                                                fExcessCenterX_Rotated = m_intROIOffSetX + fExcessCenterX;
                                                fExcessCenterY_Rotated = m_intROIOffSetY + fExcessCenterY;

                                                Math2.GetNewXYAfterRotate_360deg((arrCharEndPoint_RotateTo0Deg[j].X + arrCharStartPoint_RotateTo0Deg[j].X) / 2, (arrCharEndPoint_RotateTo0Deg[j].Y + arrCharStartPoint_RotateTo0Deg[j].Y) / 2, fExcessCenterX_Rotated, fExcessCenterY_Rotated, -fMarkAngle, ref newX, ref newY);

                                                fExcessCenterX_Rotated = newX;
                                                fExcessCenterY_Rotated = newY;

                                                // 06-02-2020 JBTAN : for Bar Pin 1 Mark, skip if the extra/broken mark is at the end of both tip
                                                if (m_blnWantCheckBarPin1)
                                                {
                                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 90");
                                                    if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnIsBarPin1[j])
                                                    {
                                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 91");
                                                        if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrBarPin1Type[j] == 0)
                                                        {
                                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 92");
                                                            if ((fExcessCenterX_Rotated > (m_intROIOffSetX + arrTemplateStartX[j]) && fExcessCenterX_Rotated < (m_intROIOffSetX + arrTemplateEndX[j])))
                                                                continue;
                                                        }
                                                        else
                                                        {
                                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 93");
                                                            if ((fExcessCenterY_Rotated > (m_intROIOffSetY + arrTemplateStartY[j]) && fExcessCenterY_Rotated < (m_intROIOffSetY + arrTemplateEndY[j])))
                                                                continue;
                                                        }
                                                    }
                                                }

                                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 94");
                                                if (m_intExtraExcessMarkInspectionAreaCutMode == 0)
                                                {
                                                    if (fExcessCenterX_Rotated > arrExcessStartX[j] && fExcessCenterX_Rotated < arrExcessEndX[j] &&
                                                        fExcessCenterY_Rotated > arrExcessStartY[j] && fExcessCenterY_Rotated < arrExcessEndY[j])
                                                    {
                                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 95");
                                                        if (CheckWantInspectExcessMark(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMarkType[j]))
                                                        {
                                                            arrSingleMatchNo.Add(j);
                                                            intMatchNo = j;
                                                        }
                                                        IsInExcessROIArea = true;
                                                    }
                                                }
                                                else
                                                {
                                                    if (m_intExtraExcessMarkInspectionAreaCutMode == 1)
                                                    {
                                                        if (fExcessCenterX_Rotated > arrCharStartPoint_RotateTo0Deg[j].X && fExcessCenterX_Rotated < arrCharEndPoint_RotateTo0Deg[j].X &&
                                                        fExcessCenterY_Rotated > arrCharStartPoint_RotateTo0Deg[j].Y && fExcessCenterY_Rotated < arrCharEndPoint_RotateTo0Deg[j].Y)
                                                        {
                                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 95");
                                                            if (CheckWantInspectExcessMark(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMarkType[j]))
                                                            {
                                                                arrSingleMatchNo.Add(j);
                                                                intMatchNo = j;
                                                            }
                                                            IsInExcessROIArea = true;
                                                        }
                                                    }
                                                    else
                                                    {
                                                        if (fExcessCenterX_Rotated > (arrCharStartPoint_RotateTo0Deg[j].X - ((int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftX[j] + m_fCharROIOffsetX))) &&
                                                            fExcessCenterX_Rotated < (arrCharEndPoint_RotateTo0Deg[j].X + ((int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftX[j] + m_fCharROIOffsetX))) &&
                                                            fExcessCenterY_Rotated > (arrCharStartPoint_RotateTo0Deg[j].Y - ((int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftY[j] + m_fCharROIOffsetY))) &&
                                                            fExcessCenterY_Rotated < (arrCharEndPoint_RotateTo0Deg[j].Y + ((int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftY[j] + m_fCharROIOffsetY))))
                                                        {
                                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 95");
                                                            if (CheckWantInspectExcessMark(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMarkType[j]))
                                                            {
                                                                arrSingleMatchNo.Add(j);
                                                                intMatchNo = j;
                                                            }
                                                            IsInExcessROIArea = true;
                                                        }
                                                    }
                                                }
                                            }

                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 96");
                                            //If is bar pin 1, dont add to excess area
                                            if (!IsInExcessROIArea && (intFailOptionMask & 0x01) > 0)
                                            //if (!objOCV.IsInOcvCharArea(objContour, ref intMatchNo))
                                            {
                                                // 2019 08 01 - CCENG: If no group extra makr or single extra mark fail, mean this object is attached to mark.
                                                if (((intFailOptionMask & 0x0A) == 0) || ((m_intFailResultMask & 0x0A) > 0))
                                                {
                                                    continue;
                                                }

                                                // 31-07-3019 ZJYEOH : Consider as group extra mark if contours cannot hit within the character's area, because if straight skip the inspection and continue next blob, there will be some extra/excess mark undetected
                                                if ((intFailOptionMask & 0x08) > 0) // Check Group Extra Mark 
                                                {
                                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 97");
                                                    bool blnAdd = true;

                                                    //if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting[intMatchNo] == 0)
                                                    //{
                                                    //    blnAdd = false;
                                                    //}


                                                    if (blnAdd)
                                                    {
                                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 98");

                                                        m_intGroupExtraMarkArea[m_intTemplateIndex] += intArea;
                                                        m_intExcessBlobResult[m_intTemplateIndex][i] = 1;

                                                        if (m_intGroupExtraMarkArea[m_intTemplateIndex] > (int)Math.Round(objTemplateSetting.fGroupExtraMinArea))
                                                        {
                                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 99");
                                                            m_intExcessBlobResult[m_intTemplateIndex][i] = 2;

                                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 99b");

                                                            if (!blnGroupExtraMark)
                                                            {
                                                                m_intFailResultMask |= 0x08;
                                                                blnGroupExtraMark = true;

                                                                // Upgrade result from 1 to 2
                                                                for (j = 0; j < intNoExcessBlobs; j++)
                                                                {
                                                                    if (m_intExcessBlobResult[m_intTemplateIndex][j] == 1)
                                                                        m_intExcessBlobResult[m_intTemplateIndex][j] = 2;
                                                                }

                                                                for (j = 0; j < intNoSelectedBlobs; j++)
                                                                {
                                                                    if (m_intBlobResult[m_intTemplateIndex][j] == 1)
                                                                        m_intBlobResult[m_intTemplateIndex][j] = 2;
                                                                }
                                                            }

                                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 100");
                                                        }
                                                    }
                                                }
                                                continue;
                                            }

                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 101");
                                            arrintMatchNo[i] = intMatchNo;
                                            // Check Group Extra Mark
                                            if ((intFailOptionMask & 0x08) > 0 && (intFailOptionMask & 0x01) > 0)
                                            {
                                                bool blnAdd = true;
                                                if (intMatchNo >= 0 && intMatchNo < m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting.Count)
                                                {
                                                    if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting[intMatchNo] == 0)
                                                    {
                                                        blnAdd = false;
                                                    }
                                                }

                                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 102");
                                                if (blnAdd)
                                                {


                                                    m_intGroupExtraMarkArea[m_intTemplateIndex] += intArea;
                                                    m_intExcessBlobResult[m_intTemplateIndex][i] = 1;

                                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 103");

                                                    if (m_intGroupExtraMarkArea[m_intTemplateIndex] > (int)Math.Round(objTemplateSetting.fGroupExtraMinArea))
                                                    {
                                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 104");
                                                        m_intExcessBlobResult[m_intTemplateIndex][i] = 2;

                                                        if (!blnGroupExtraMark)
                                                        {
                                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 105");
                                                            m_intFailResultMask |= 0x08;
                                                            blnGroupExtraMark = true;

                                                            // Upgrade result from 1 to 2
                                                            for (j = 0; j < intNoExcessBlobs; j++)
                                                            {
                                                                if (m_intExcessBlobResult[m_intTemplateIndex][j] == 1)
                                                                    m_intExcessBlobResult[m_intTemplateIndex][j] = 2;
                                                            }

                                                            for (j = 0; j < intNoSelectedBlobs; j++)
                                                            {
                                                                if (m_intBlobResult[m_intTemplateIndex][j] == 1)
                                                                    m_intBlobResult[m_intTemplateIndex][j] = 2;
                                                            }
                                                        }
                                                    }
                                                }
                                            }

                                            // Check Group Excess Mark
                                            if (((intFailOptionMask & 0x100) > 0) && m_blnWantCheckTotalExcessMark && (intFailOptionMask & 0x01) > 0)
                                            {
                                                bool blnAdd = IsInExcessROIArea;
                                                if (intMatchNo >= 0 && intMatchNo < m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting.Count)
                                                {
                                                    blnAdd = true;
                                                    if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting[intMatchNo] == 0)
                                                    {
                                                        blnAdd = false;
                                                    }
                                                }

                                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 102 - b");
                                                if (blnAdd)
                                                {


                                                    m_intGroupExcessMarkArea[m_intTemplateIndex] += intArea;
                                                    m_intExcessBlobResult[m_intTemplateIndex][i] = 1;

                                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 103 - b");

                                                    if (m_intGroupExcessMarkArea[m_intTemplateIndex] > (int)Math.Round(objTemplateSetting.fGroupExcessMinArea))
                                                    {
                                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 104 - b");
                                                        m_intExcessBlobResult[m_intTemplateIndex][i] = 2;

                                                        if (!blnGroupExcessMark)
                                                        {
                                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 105 - b");
                                                            m_intFailResultMask |= 0x2000;
                                                            blnGroupExcessMark = true;

                                                            // Upgrade result from 1 to 2
                                                            for (j = 0; j < intNoExcessBlobs; j++)
                                                            {
                                                                if (m_intExcessBlobResult[m_intTemplateIndex][j] == 1)
                                                                    m_intExcessBlobResult[m_intTemplateIndex][j] = 2;
                                                            }

                                                            for (j = 0; j < intNoSelectedBlobs; j++)
                                                            {
                                                                if (m_intBlobResult[m_intTemplateIndex][j] == 1)
                                                                    m_intBlobResult[m_intTemplateIndex][j] = 2;
                                                            }
                                                        }
                                                    }
                                                }
                                            }

                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 106");
                                            if ((intFailOptionMask & 0x01) > 0 || m_blnWantUseExcessMissingMarkAffectScore)
                                            {
                                                for (j = 0; j < arrSingleMatchNo.Count; j++)
                                                {
                                                    if (!CheckWantInspectExcessMark(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMarkType[arrSingleMatchNo[j]]))
                                                        continue;

                                                    m_arrCharExcessAreaResult[m_intTemplateIndex][arrSingleMatchNo[j]] += intArea;
                                                }
                                            }
                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 107");
                                        }

                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 108");
                                        // 31-07-2019 ZJYEOH : Check Excess here so that the total excess area is correct for each mark
                                        for (int b = 0; b < m_arrCharExcessAreaResult[m_intTemplateIndex].Length; b++)
                                        {
                                            if (m_arrCharExcessAreaResult[m_intTemplateIndex][b] == 0 || !m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[b]  // 2020-08-11 ZJYEOH : Skip Excess if mark disabled
                                                || m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting[b] == 0) // 2020-08-11 ZJYEOH : Skip Excess if mark score setting = 0
                                            {
                                                // 2020-08-11 ZJYEOH : Set to 0 so that offline page will not display red color
                                                if (m_arrCharExcessAreaResult[m_intTemplateIndex][b] != 0)
                                                    m_arrCharExcessAreaResult[m_intTemplateIndex][b] = 0;
                                                continue;
                                            }
                                            // Make sure object area is higher than min area and extra min area
                                            if ((m_arrCharExcessAreaResult[m_intTemplateIndex][b] < m_intMinArea) ||
                                                (m_arrCharExcessAreaResult[m_intTemplateIndex][b] <= (int)Math.Round(objTemplateSetting.arrMaxExcessArea[b])) ||
                                                (intFailOptionMask & 0x01) == 0)
                                            {
                                                continue;
                                            }
                                            else
                                            {

                                                if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting[b] == 0)
                                                {
                                                    continue;
                                                }

                                                for (int c = 0; c < arrintMatchNo.Count; c++)
                                                {
                                                    if (arrintMatchNo[c] == b)
                                                        m_intExcessBlobResult[m_intTemplateIndex][c] = 2;
                                                }

                                                if ((m_intFailResultMask & 0x01) == 0)
                                                    m_intFailResultMask |= 0x01;
                                            }
                                        }

                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 109");
                                    }
                                    objSubtractImage_Temp.Dispose();
                                }
                            }

                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 110");
                            //-------------------------------------- Check miss mark area ---------------------------------------
                            if ((intFailOptionMask & 0x10) > 0 && (m_intFailResultMask & 0x01) == 0 || m_blnWantUseExcessMissingMarkAffectScore || ShowLiterationOnly)
                            {
                                // Copy rotated image to sample image
                                //objOcvRotatedImage.CopyTo(ref m_objSampleImage);
                                if (m_blnWhiteOnBlack)
                                    objBlackImage.CopyTo(ref m_objSampleImage);//objImage //2021-07-06 ZJYEOH : Use Black Image so that background is not included
                                else
                                    objWhiteImage.CopyTo(ref m_objSampleImage);
                                ImageDrawing objSampleImage_Temp = new ImageDrawing(true, m_objSampleImage.ref_intImageWidth, m_objSampleImage.ref_intImageHeight);
                                //objOcvRotatedImage.CopyTo(ref objSampleImage_Temp);
                                objImage.CopyTo(ref objSampleImage_Temp);
                                ImageDrawing objSampleImage_Temp2 = new ImageDrawing(true, m_objSampleImage.ref_intImageWidth, m_objSampleImage.ref_intImageHeight);
                                //objOcvRotatedImage.CopyTo(ref objSampleImage_Temp2);
                                objImage.CopyTo(ref objSampleImage_Temp2);
                                ROI objSubtractCharROI = new ROI();
                                objSubtractCharROI.AttachImage(m_objSampleImage);

                                System.Drawing.Point pStart, pEnd;
                                List<ROI> arrTemplateCharErodeROI = new List<ROI>();

                                int intNumChars2 = objOCV.GetNumChars();

                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 111");

                                if (m_arrCharBrokenAreaResult[m_intTemplateIndex] == null)
                                    m_arrCharBrokenAreaResult[m_intTemplateIndex] = new int[intNumChars];

                                if (m_arrCharBrokenAreaResult[m_intTemplateIndex].Length != intNumChars)
                                    m_arrCharBrokenAreaResult[m_intTemplateIndex] = new int[intNumChars];

                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 112");
                                for (int a = 0; a < intNumChars; a++)
                                {
                                    m_arrCharBrokenAreaResult[m_intTemplateIndex][a] = 0;
                                }

                                List<float> arrMarkStartX = new List<float>();
                                List<float> arrMarkStartY = new List<float>();
                                List<float> arrMarkEndX = new List<float>();
                                List<float> arrMarkEndY = new List<float>();
                                ROI objErodeROI = new ROI();
                                ImageDrawing objErodeImage = new ImageDrawing(true, m_objSampleImage.ref_intImageWidth, m_objSampleImage.ref_intImageHeight);
                                objErodeROI.AttachImage(objErodeImage);
                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 113");

                                for (int i = 0; i < intNumChars2; i++)
                                {
                                    //// 2020-08-11 ZJYEOH : Skip if the mark is disabled
                                    //if (!m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i])
                                    //    continue;

                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 114");

                                    arrTemplateCharErodeROI.Add(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrTemplateCharErodeROI[i]);
#if (Debug_2_12 || Release_2_12)
                                    EasyImage.Threshold(arrTemplateCharErodeROI[i].ref_ROI, arrTemplateCharErodeROI[i].ref_ROI, (uint)intThresholdValue);
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                                    EasyImage.Threshold(arrTemplateCharErodeROI[i].ref_ROI, arrTemplateCharErodeROI[i].ref_ROI, intThresholdValue);
#endif

                                    pStart = objOCV.GetCharStartXY(i);
                                    pEnd = objOCV.GetCharEndXY(i);
                                    float newSX = 0, newSY = 0, newEX = 0, newEY = 0;
                                    Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2, pStart.X, pStart.Y, -(intOrientationAngle + fMarkAngle), ref newSX, ref newSY);

                                    Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2, pEnd.X, pEnd.Y, -(intOrientationAngle + fMarkAngle), ref newEX, ref newEY);
                                    pStart = new Point((int)Math.Round(newSX), (int)Math.Round(newSY));
                                    pEnd = new Point((int)Math.Round(newEX), (int)Math.Round(newEY));

                                    List<Point> arrPoints = new List<Point>();
                                    arrPoints.Add(pStart);
                                    arrPoints.Add(new Point(pStart.X + (pEnd.X - pStart.X), pStart.Y));
                                    arrPoints.Add(new Point(pStart.X, pStart.Y + (pEnd.Y - pStart.Y)));
                                    arrPoints.Add(pEnd);

                                    PointF pTemp = new PointF();
                                    Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
                                                                     arrPoints[0],
                                                                     -(intOrientationAngle + fMarkAngle),
                                                                     ref pTemp);
                                    arrPoints[0] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

                                    Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
                                                                     arrPoints[1],
                                                                     -(intOrientationAngle + fMarkAngle),
                                                                     ref pTemp);
                                    arrPoints[1] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

                                    Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
                                                                     arrPoints[2],
                                                                     -(intOrientationAngle + fMarkAngle),
                                                                     ref pTemp);
                                    arrPoints[2] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

                                    Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
                                                                     arrPoints[3],
                                                                     -(intOrientationAngle + fMarkAngle),
                                                                     ref pTemp);
                                    arrPoints[3] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

                                    float fMinX = float.MaxValue;
                                    float fMinY = float.MaxValue;
                                    float fMaxX = 0;
                                    float fMaxY = 0;
                                    for (int a = 0; a < arrPoints.Count; a++)
                                    {
                                        if (fMinX > arrPoints[a].X)
                                            fMinX = arrPoints[a].X;

                                        if (fMinY > arrPoints[a].Y)
                                            fMinY = arrPoints[a].Y;

                                        if (fMaxX < arrPoints[a].X)
                                            fMaxX = arrPoints[a].X;

                                        if (fMaxY < arrPoints[a].Y)
                                            fMaxY = arrPoints[a].Y;
                                    }

                                    //if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 115");

                                    //float fMinAddSizeX = (float)(arrTemplateCharErodeROI[i].ref_ROIWidth - (pEnd.X - pStart.X)) / 2;
                                    //float fMinAddSizeY = (float)(arrTemplateCharErodeROI[i].ref_ROIHeight - (pEnd.Y - pStart.Y)) / 2;

                                    //int intMinAddSizeStartX, intMinAddSizeStartY, intMinAddSizeEndX, intMinAddSizeEndY;
                                    //if (fMinAddSizeX == (int)fMinAddSizeX)
                                    //{
                                    //    intMinAddSizeStartX = (int)fMinAddSizeX;
                                    //    intMinAddSizeEndX = (int)fMinAddSizeX;
                                    //}
                                    //else
                                    //{
                                    //    intMinAddSizeStartX = (int)Math.Ceiling(fMinAddSizeX);
                                    //    intMinAddSizeEndX = (int)Math.Floor(fMinAddSizeX);
                                    //}

                                    //if (fMinAddSizeY == (int)fMinAddSizeY)
                                    //{
                                    //    intMinAddSizeStartY = (int)fMinAddSizeY;
                                    //    intMinAddSizeEndY = (int)fMinAddSizeY;
                                    //}
                                    //else
                                    //{
                                    //    intMinAddSizeStartY = (int)Math.Ceiling(fMinAddSizeY);
                                    //    intMinAddSizeEndY = (int)Math.Floor(fMinAddSizeY);
                                    //}

                                    //if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 116");

                                    ROI objSampleCharROI = new ROI();

                                    //if ((m_intROIOffSetX + pStart.X - intMinAddSizeStartX) >= 0) //if ((pStart.X - intMinAddSizeStartX) >= 0)   // 2019 10 11 - CCENG: add m_intROIOffSetXY because objSampleCharROI attach to main Image.
                                    //    objSampleCharROI.ref_ROIPositionX = m_intROIOffSetX + pStart.X - intMinAddSizeStartX;
                                    //else
                                    //    objSampleCharROI.ref_ROIPositionX = m_intROIOffSetX;

                                    //if ((m_intROIOffSetY + pStart.Y - intMinAddSizeStartY) >= 0)  //if ((pStart.Y - intMinAddSizeStartY) >= 0)  // 2019 10 11 - CCENG: add m_intROIOffSetXY because objSampleCharROI attach to main Image.
                                    //    objSampleCharROI.ref_ROIPositionY = m_intROIOffSetY + pStart.Y - intMinAddSizeStartY;
                                    //else
                                    //    objSampleCharROI.ref_ROIPositionY = m_intROIOffSetY;

                                    //if ((pEnd.X + intMinAddSizeEndX * 2) < m_intImageWidth)
                                    //    objSampleCharROI.ref_ROIWidth = pEnd.X - pStart.X + intMinAddSizeStartX + intMinAddSizeEndX;
                                    //else
                                    //    continue;
                                    //if ((pEnd.Y + intMinAddSizeEndY * 2) < m_intImageHeight)
                                    //    objSampleCharROI.ref_ROIHeight = pEnd.Y - pStart.Y + intMinAddSizeStartY + intMinAddSizeEndY;
                                    //else
                                    //    continue;

                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 117");

                                    // 2020 03 01 - CCENG: Attached to m_objSampleImage because objSampleCharROI will be Dilated when m_intMissingMarkInspectionMethod is 1. 
                                    //                   : Also Dilate and subtract's image source and destination can be same.          
                                    //objSampleCharROI.AttachImage(objImage);

                                    //2020-06-17 ZJYEOH : objSampleCharROI should attach another image as m_objSampleImage will be image processsed
                                    objSampleCharROI.AttachImage(objSampleImage_Temp);//m_objSampleImage

                                    //objSubtractCharROI.LoadROISetting(objSampleCharROI.ref_ROIPositionX, objSampleCharROI.ref_ROIPositionY,
                                    //                                    objSampleCharROI.ref_ROIWidth, objSampleCharROI.ref_ROIHeight);

                                    objSampleCharROI.LoadROISetting((int)Math.Round(m_intROIOffSetX + fMinX), (int)Math.Round(m_intROIOffSetY + fMinY),
                                (int)Math.Round(fMaxX - fMinX), (int)Math.Round(fMaxY - fMinY));

                                    objSubtractCharROI.LoadROISetting((int)Math.Round(m_intROIOffSetX + fMinX), (int)Math.Round(m_intROIOffSetY + fMinY),
                                (int)Math.Round(fMaxX - fMinX), (int)Math.Round(fMaxY - fMinY));

                                    //if ((objSampleCharROI.ref_ROIWidth != arrTemplateCharErodeROI[i].ref_ROIWidth) ||
                                    //    (arrTemplateCharErodeROI[i].ref_ROIWidth != objSubtractCharROI.ref_ROIWidth))
                                    //    continue;

                                    //if ((objSampleCharROI.ref_ROIHeight != arrTemplateCharErodeROI[i].ref_ROIHeight) ||
                                    //    (arrTemplateCharErodeROI[i].ref_ROIHeight != objSubtractCharROI.ref_ROIHeight))
                                    //    continue;

                                    objErodeROI.LoadROISetting((int)Math.Round(m_intROIOffSetX + fMinX), (int)Math.Round(m_intROIOffSetY + fMinY),
                                (int)Math.Round(fMaxX - fMinX), (int)Math.Round(fMaxY - fMinY));

                                    //objDilateROI.LoadROISetting(arrTemplateCharDilateROI[i].ref_ROITotalX, arrTemplateCharDilateROI[i].ref_ROITotalY, arrTemplateCharDilateROI[i].ref_ROIWidth, arrTemplateCharDilateROI[i].ref_ROIHeight);
                                    //arrTemplateCharErodeROI[i].SaveImage("D:\\arrTemplateCharErodeROI.bmp");
                                    //objErodeROI.SaveImage("D:\\objErodeROI.bmp");
                                    arrTemplateCharErodeROI[i].CopyImage(ref objErodeROI);
                                    ROI.Rotate0Degree_ForDontCare(arrTemplateCharErodeROI[i], -(intOrientationAngle + fMarkAngle), 4, objErodeROI);
                                    //arrTemplateCharErodeROI[i].SaveImage("D:\\arrTemplateCharErodeROI.bmp");
                                    //objErodeROI.SaveImage("D:\\objErodeROI.bmp");

                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 118");

                                    //2020-11-17 ZJYEOH : Cannot minus m_intROIOffSetX and m_intROIOffSetY because later will use different dimension for Build ROI
                                    arrMarkStartX.Add(objSubtractCharROI.ref_ROIPositionX);//- m_intROIOffSetX
                                    arrMarkStartY.Add(objSubtractCharROI.ref_ROIPositionY);//- m_intROIOffSetY
                                    arrMarkEndX.Add(objSubtractCharROI.ref_ROIPositionX + objSubtractCharROI.ref_ROIWidth);//- m_intROIOffSetX
                                    arrMarkEndY.Add(objSubtractCharROI.ref_ROIPositionY + objSubtractCharROI.ref_ROIHeight);//- m_intROIOffSetY

                                    if (!m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i] || !CheckWantInspectMissingMark(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMarkType[i]))
                                    {
                                        //EasyImage.Oper(EArithmeticLogicOperation.Subtract, arrTemplateCharErodeROI[i].ref_ROI, arrTemplateCharErodeROI[i].ref_ROI, objSubtractCharROI.ref_ROI);
                                        //2021-01-14 ZJYEOH : arrTemplateCharErodeROI[i].ref_ROI sometime not same size with objSubtractCharROI.ref_ROI
                                        EasyImage.Oper(EArithmeticLogicOperation.Subtract, objSampleCharROI.ref_ROI, objSampleCharROI.ref_ROI, objSubtractCharROI.ref_ROI);

                                    }
                                    else
                                    {
                                        // 2020 08 30 - CCENG: Fix to use "thick on sample mark" bcos more stable and applicable for thin and thick mark.
                                        //if (m_intMissingMarkInspectionMethod == 0) // 2020 03 01 - CCENG: 0=Thin on Template Mark
                                        //{
                                        //    //2020-06-17 ZJYEOH : Image processing will be different for white on black and black one white
                                        //    if (m_blnWhiteOnBlack)
                                        //    {
                                        //        EasyImage.Oper(EArithmeticLogicOperation.Subtract, arrTemplateCharErodeROI[i].ref_ROI, objSampleCharROI.ref_ROI, objSubtractCharROI.ref_ROI);
                                        //    }
                                        //    else
                                        //    {
                                        //        EasyImage.Oper(EArithmeticLogicOperation.Invert, objSampleCharROI.ref_ROI, objSampleCharROI.ref_ROI);
                                        //        EasyImage.Oper(EArithmeticLogicOperation.Add, arrTemplateCharErodeROI[i].ref_ROI, objSampleCharROI.ref_ROI, objSubtractCharROI.ref_ROI);
                                        //        //2020-06-17 ZJYEOH : Invert back so that objSampleCharROI will not inverted if it is used again because inverted area may overlap another mark
                                        //        EasyImage.Oper(EArithmeticLogicOperation.Invert, objSampleCharROI.ref_ROI, objSampleCharROI.ref_ROI);
                                        //    }
                                        //}
                                        //else
                                        {
                                            // 2020 03 01 - CCENG: m_intMissingMarkInspectionMethod == 0 mean thick on sample mark
#if (Debug_2_12 || Release_2_12)
                                            if (m_intCharErodeHalfWidth > 0)
                                            {
                                                if (m_blnWhiteOnBlack)
                                                    EasyImage.DilateBox(objSampleCharROI.ref_ROI, objSampleCharROI.ref_ROI, (uint)m_intCharErodeHalfWidth);
                                                else
                                                    EasyImage.ErodeBox(objSampleCharROI.ref_ROI, objSampleCharROI.ref_ROI, (uint)m_intCharErodeHalfWidth);
                                            }
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                                            if (m_intCharErodeHalfWidth > 0)
                                            {
                                                if (m_blnWhiteOnBlack)
                                                    EasyImage.DilateBox(objSampleCharROI.ref_ROI, objSampleCharROI.ref_ROI, m_intCharErodeHalfWidth);
                                                else
                                                    EasyImage.ErodeBox(objSampleCharROI.ref_ROI, objSampleCharROI.ref_ROI, m_intCharErodeHalfWidth);
                                            }
#endif

#if (Debug_2_12 || Release_2_12)
                                            EasyImage.Threshold(objSampleCharROI.ref_ROI, objSampleCharROI.ref_ROI, (uint)intThresholdValue);
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                                                EasyImage.Threshold(objSampleCharROI.ref_ROI, objSampleCharROI.ref_ROI, intThresholdValue);
#endif

                                            //2020-06-17 ZJYEOH : Image processing will be different for white on black and black one white
                                            if (m_blnWhiteOnBlack)
                                            {
                                                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objErodeROI.ref_ROI, objSampleCharROI.ref_ROI, objSubtractCharROI.ref_ROI);
                                            }
                                            else
                                            {
                                                //EasyImage.Oper(EArithmeticLogicOperation.Invert, objSampleCharROI.ref_ROI, objSampleCharROI.ref_ROI);
                                                ROI.InvertOperationROI(objSampleCharROI);
                                                EasyImage.Oper(EArithmeticLogicOperation.Add, objErodeROI.ref_ROI, objSampleCharROI.ref_ROI, objSubtractCharROI.ref_ROI);
                                                //2020-06-17 ZJYEOH : Invert back so that objSampleCharROI will not inverted if it is used again because inverted area may overlap another mark
                                                //EasyImage.Oper(EArithmeticLogicOperation.Invert, objSampleCharROI.ref_ROI, objSampleCharROI.ref_ROI);
                                                ROI.InvertOperationROI(objSampleCharROI);
                                            }
                                        }
                                    }

                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 119");

                                    if (blnWantDebug)
                                    {
                                        objErodeROI.SaveImage("D:\\TS\\34.objErodeROI" + i.ToString() + ".bmp");
                                        arrTemplateCharErodeROI[i].SaveImage("D:\\TS\\34.arrTemplateCharErodeROI[i]" + i.ToString() + ".bmp");
                                        objSampleCharROI.SaveImage("D:\\TS\\35.objSampleCharROI" + i.ToString() + ".bmp");
                                        objSubtractCharROI.SaveImage("D:\\TS\\36.objSubtractCharROI" + i.ToString() + ".bmp");
                                        m_objSampleImage.SaveImage("D:\\TS\\37.m_objSampleImage" + i.ToString() + ".bmp");
                                    }

                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 120");

                                    objSampleCharROI.Dispose();
                                }

                                ////2020-06-23 ZJYEOH : if no check package size, pRotatedCenterPoint will be (-1, -1)
                                //if (pRotatedCenterPoint != new PointF(-1, -1))
                                //{
                                //    m_objLocalTemporary_RotateSearchROI.AttachImage(m_objSampleImage);
                                //    m_objLocalTemporary_RotateSearchROI.LoadROISetting((int)Math.Round(pRotatedCenterPoint.X - objMarkPackageSearchROI.ref_ROIWidth / 2, 0, MidpointRounding.AwayFromZero),
                                //                                      (int)Math.Round(pRotatedCenterPoint.Y - objMarkPackageSearchROI.ref_ROIHeight / 2, 0, MidpointRounding.AwayFromZero),
                                //                                      objMarkPackageSearchROI.ref_ROIWidth, objMarkPackageSearchROI.ref_ROIHeight);

                                //    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 121");

                                //    ROI.RotateROI(m_objLocalTemporary_RotateSearchROI, fPackageAngle - fMarkAngle, ref m_objSampleImage);
                                //}

                                if (blnWantDebug)
                                {
                                    m_objSampleImage.SaveImage("D:\\TS\\40m_objSampleImage.bmp");
                                }

                                objSubtractCharROI.AttachImage(m_objSampleImage);

                                if (blnWantDebug)
                                {
                                    objSubtractCharROI.SaveImage("D:\\TS\\41.objSubtractCharROI.bmp");
                                }

                                int intMinX = m_intROIOffSetX;
                                int intMinY = m_intROIOffSetY;
                                int intMaxX = m_intROIOffSetX + objMarkPackageMarkROI.ref_ROIWidth;
                                int intMaxY = m_intROIOffSetY + objMarkPackageMarkROI.ref_ROIHeight;

                                for (int i = 0; i < arrMarkStartX.Count; i++)
                                {
                                    int intStartX = (int)Math.Round(arrMarkStartX[i]);
                                    int intStartY = (int)Math.Round(arrMarkStartY[i]);
                                    int intEndX = (int)Math.Round(arrMarkEndX[i]);
                                    int intEndY = (int)Math.Round(arrMarkEndY[i]);

                                    if (intMinX > intStartX)
                                        intMinX = intStartX;

                                    if (intMinY > intStartY)
                                        intMinY = intStartY;

                                    if (intMaxX < intEndX)
                                        intMaxX = intEndX;

                                    if (intMaxY < intEndY)
                                        intMaxY = intEndY;
                                }

                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 122");
                                // Reload ROI size and placement to same location and same size as Mark ROI
                                //objSubtractCharROI.LoadROISetting(m_intROIOffSetX, m_intROIOffSetY, objMarkPackageMarkROI.ref_ROIWidth, objMarkPackageMarkROI.ref_ROIHeight);
                                objSubtractCharROI.LoadROISetting(intMinX, intMinY, intMaxX - intMinX, intMaxY - intMinY); //2020-11-17 ZJYEOH: Build area included OCV char area so that marking outside unit edge can be detected as broken mark

#if (Debug_2_12 || Release_2_12)
                                if (m_intCharOpenHalfWidth > 0)
                                    EasyImage.OpenBox(objSubtractCharROI.ref_ROI, objSubtractCharROI.ref_ROI, (uint)m_intCharOpenHalfWidth);
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)

                                if (m_intCharOpenHalfWidth > 0)
                                        EasyImage.OpenBox(objSubtractCharROI.ref_ROI, objSubtractCharROI.ref_ROI, m_intCharOpenHalfWidth);
#endif

                                if (m_objMissingBlobs[m_intTemplateIndex] == null)
                                    m_objMissingBlobs[m_intTemplateIndex] = new EBlobs();
                                else
                                    m_objMissingBlobs[m_intTemplateIndex].CleanAllBlobs();

                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 123");
                                if (blnWantDebug)
                                {
                                    objSubtractCharROI.SaveImage("D:\\TS\\42.objSubtractCharROI.bmp");
                                }

                                //2020-06-17 ZJYEOH : Threshold will invert for white on black
                                int intMissingThreshold = intThresholdValue;
                                if (m_blnWhiteOnBlack)
                                {
                                    // 2022 01 12 - CCENG: since template and sample are using binary image to subtract, so objSubtractCharROI will be binary image also. Mean can use any thresholdd value. 
                                    //intMissingThreshold = 255 - intThresholdValue;

                                }

                                if (ShowLiterationOnly)
                                {
                                    obj_temp.Dispose();
                                    obj_temp = new ImageDrawing();
                                    objSubtractCharROI.CopyToImage(ref obj_temp);
                                }

                                if (BuildObject(m_objMissingBlobs[m_intTemplateIndex], objSubtractCharROI, false, true, intMissingThreshold, 0, objSubtractCharROI.ref_ROIWidth * objSubtractCharROI.ref_ROIHeight + 1, 0x1F)) //255 - intThresholdValue
                                {
                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 124");
                                    int intNoMissingBlobs = m_objMissingBlobs[m_intTemplateIndex].ref_intNumSelectedObject;

                                    // Init blob data
                                    List<int> arrintMatchNo = new List<int>();
                                    m_intMissingBlobResult[m_intTemplateIndex] = new int[intNoMissingBlobs];
                                    for (j = 0; j < intNoMissingBlobs; j++)
                                    {
                                        m_intMissingBlobResult[m_intTemplateIndex][j] = 0;
                                    }

                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 125");

                                    for (int i = 0; i < intNoMissingBlobs; i++)
                                    {
                                        arrintMatchNo.Add(-1);

                                        intArea = m_objMissingBlobs[m_intTemplateIndex].ref_arrArea[i];     // Get subtracted blob area
                                        fCenterX = m_objMissingBlobs[m_intTemplateIndex].ref_arrLimitCenterX[i];
                                        fCenterY = m_objMissingBlobs[m_intTemplateIndex].ref_arrLimitCenterY[i];
                                        fWidth = m_objMissingBlobs[m_intTemplateIndex].ref_arrWidth[i];
                                        fHeight = m_objMissingBlobs[m_intTemplateIndex].ref_arrHeight[i];
                                        bool blnIsInOcvCharArea = false;

                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 126");
                                        int intMatchNo = -1;
                                        for (j = 0; j < arrMarkStartX.Count; j++)
                                        {
                                            // 2020 02 27 - CCENG: Check after loop.
                                            // 06-02-2020 JBTAN : for Bar Pin 1 Mark, skip if the extra/broken mark is at the end of both tip
                                            //if (m_blnWantCheckBarPin1)
                                            //{
                                            //    if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnIsBarPin1[j])
                                            //    {
                                            //        if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrBarPin1Type[j] == 0)
                                            //        {
                                            //            if ((fCenterX > arrExcessStartX[j] && fCenterX < arrExcessEndX[j]) &&
                                            //                (fCenterY < arrExcessStartY[j] || fCenterY > arrExcessEndY[j]))
                                            //                continue;
                                            //        }
                                            //        else
                                            //        {
                                            //            if ((fCenterY > arrExcessStartY[j] && fCenterY < arrExcessEndY[j]) &&
                                            //                (fCenterX < arrExcessStartX[j] || fCenterX > arrExcessEndX[j]))
                                            //                continue;
                                            //        }
                                            //    }
                                            //}

                                            //2022-01-09 ZJYEOH : This Size comparing condition need add m_intCharOpenHalfWidth as tolerance because if whole char is missing the defect after dilate sure will bigger than OCV size
                                            // Broken Mark area should always smaller than ocv mark roi. 
                                            if ((fWidth < (arrMarkEndX[j] - arrMarkStartX[j]) + m_intCharOpenHalfWidth + 2) &&
                                            (fHeight < (arrMarkEndY[j] - arrMarkStartY[j]) + m_intCharOpenHalfWidth + 2))
                                            {
                                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 127");
                                                // Broken Mark center point should always within ocv mark roi area.
                                                if ((fCenterX + objSubtractCharROI.ref_ROIPositionX) > arrMarkStartX[j] && (fCenterX + objSubtractCharROI.ref_ROIPositionX) < arrMarkEndX[j] &&
                                                    (fCenterY + objSubtractCharROI.ref_ROIPositionY) > arrMarkStartY[j] && (fCenterY + objSubtractCharROI.ref_ROIPositionY) < arrMarkEndY[j])
                                                {
                                                    //2021-07-07 ZJYEOH : No need meet min 2 corner points requirement as now built on black image
                                                    //// 2019 10 14 - CCENG: Broken Mark center point and at least 2 corner points must within ocv mark roi area. - This is because whole mark ROI image are blobs builded sometime outside char area will be build also and considered as broken if size are big. 
                                                    //int intCornerMatchCount = 0;

                                                    //if ((fCenterX + objSubtractCharROI.ref_ROIPositionX - fWidth / 2) >= arrMarkStartX[j] && (fCenterX + objSubtractCharROI.ref_ROIPositionX - fWidth / 2) <= arrMarkEndX[j] &&
                                                    //    (fCenterY + objSubtractCharROI.ref_ROIPositionY - fHeight / 2) >= arrMarkStartY[j] && (fCenterY + objSubtractCharROI.ref_ROIPositionY - fHeight / 2) <= arrMarkEndY[j])
                                                    //{
                                                    //    intCornerMatchCount++;
                                                    //}

                                                    //if ((fCenterX + objSubtractCharROI.ref_ROIPositionX + fWidth / 2) >= arrMarkStartX[j] && (fCenterX + objSubtractCharROI.ref_ROIPositionX + fWidth / 2) <= arrMarkEndX[j] &&
                                                    //    (fCenterY + objSubtractCharROI.ref_ROIPositionY - fHeight / 2) >= arrMarkStartY[j] && (fCenterY + objSubtractCharROI.ref_ROIPositionY - fHeight / 2) <= arrMarkEndY[j])
                                                    //{
                                                    //    intCornerMatchCount++;
                                                    //}

                                                    //if ((fCenterX + objSubtractCharROI.ref_ROIPositionX + fWidth / 2) >= arrMarkStartX[j] && (fCenterX + objSubtractCharROI.ref_ROIPositionX + fWidth / 2) <= arrMarkEndX[j] &&
                                                    //    (fCenterY + objSubtractCharROI.ref_ROIPositionY + fHeight / 2) >= arrMarkStartY[j] && (fCenterY + objSubtractCharROI.ref_ROIPositionY + fHeight / 2) <= arrMarkEndY[j])
                                                    //{
                                                    //    intCornerMatchCount++;
                                                    //}

                                                    //if ((fCenterX + objSubtractCharROI.ref_ROIPositionX - fWidth / 2) >= arrMarkStartX[j] && (fCenterX + objSubtractCharROI.ref_ROIPositionX - fWidth / 2) <= arrMarkEndX[j] &&
                                                    //    (fCenterY + objSubtractCharROI.ref_ROIPositionY + fHeight / 2) >= arrMarkStartY[j] && (fCenterY + objSubtractCharROI.ref_ROIPositionY + fHeight / 2) <= arrMarkEndY[j])
                                                    //{
                                                    //    intCornerMatchCount++;
                                                    //}

                                                    //if (intCornerMatchCount >= 2)
                                                    {
                                                        intMatchNo = j;
                                                        blnIsInOcvCharArea = true;
                                                        break;
                                                    }
                                                }
                                            }
                                        }

                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 129");
                                        if (blnIsInOcvCharArea) // 2019 04 13-CCENG: Only blob under Ocv Char Area will recorded.
                                        {
                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 130");
                                            // 2020 02 27 - CCENG: Move this checking to here.
                                            // 06-02-2020 JBTAN : for Bar Pin 1 Mark, skip if the extra/broken mark is at the end of both tip
                                            if (m_blnWantCheckBarPin1)
                                            {
                                                if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnIsBarPin1[j])
                                                {
                                                    if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrBarPin1Type[j] == 0)
                                                    {
                                                        // 2020 02 27 - CCENG: check x only because sometime the excess area will partially inside the bar.
                                                        //if ((fCenterX > arrExcessStartX[j] && fCenterX < arrExcessEndX[j]) &&
                                                        //    (fCenterY < arrExcessStartY[j] || fCenterY > arrExcessEndY[j]))
                                                        if (fCenterX > arrExcessStartX[j] && fCenterX < arrExcessEndX[j])
                                                            continue;
                                                    }
                                                    else
                                                    {
                                                        // 2020 02 27 - CCENG: check y only because sometime the excess area will partially inside the bar.
                                                        //if ((fCenterY > arrExcessStartY[j] && fCenterY < arrExcessEndY[j]) &&
                                                        //    (fCenterX < arrExcessStartX[j] || fCenterX > arrExcessEndX[j]))
                                                        if (fCenterY > arrExcessStartY[j] && fCenterY < arrExcessEndY[j])
                                                            continue;
                                                    }
                                                }
                                            }

                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 131");
                                            if (m_intSmallestMissingMarkArea[m_intTemplateIndex] == 0 || intArea < m_intSmallestMissingMarkArea[m_intTemplateIndex])
                                                m_intSmallestMissingMarkArea[m_intTemplateIndex] = intArea;

                                            if (m_intBiggestMissingMarkArea[m_intTemplateIndex] == 0 || intArea > m_intBiggestMissingMarkArea[m_intTemplateIndex])
                                                m_intBiggestMissingMarkArea[m_intTemplateIndex] = intArea;

                                            m_arrCharBrokenAreaResult[m_intTemplateIndex][intMatchNo] += intArea;

                                            arrintMatchNo[i] = intMatchNo;

                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 132");
                                        }


                                        //// Check whether the blob has been fail
                                        //for (j = 0; j < intNoSelectedBlobs; j++)
                                        //{
                                        //    if (m_intBlobResult[m_intTemplateIndex][j] == 2)
                                        //    {
                                        //        float fMissingCenterX, fMissingCenterY;
                                        //        fMissingCenterX = fMissingCenterY = 0.0f;

                                        //        fCenterX = m_objBlobs[m_intTemplateIndex].ref_arrLimitCenterX[j];
                                        //        fCenterY = m_objBlobs[m_intTemplateIndex].ref_arrLimitCenterY[j];
                                        //        m_objBlobs[m_intTemplateIndex].DisposeElement(j);

                                        //        fMissingCenterX = m_objMissingBlobs[m_intTemplateIndex].ref_arrLimitCenterX[i];
                                        //        fMissingCenterY = m_objMissingBlobs[m_intTemplateIndex].ref_arrLimitCenterY[i];

                                        //        if (fCenterX == fMissingCenterX && fCenterY == fMissingCenterY)
                                        //        {
                                        //            break;
                                        //        }
                                        //    }
                                        //}

                                        // The blob has been fail 
                                        //if (intNoSelectedBlobs != 0 && j != intNoSelectedBlobs)
                                        //{
                                        //    continue;
                                        //}



                                        //intArea = m_objMissingBlobs[m_intTemplateIndex].ref_arrArea[i];     // Get subtracted blob area // Get subtracted blob contour xy first point
                                        //bool blnIsInOcvCharArea = false;
                                        //if (!blnAuto || (blnAuto && (intArea > objTemplateSetting.intMissingMinArea)))  // 2018 10 08 - CCENG: For faster inspection during production test (blnAuto is true), if blob area small than MissingMinArea, then skip checking IsInOcvCharArea  
                                        //if (intArea > objTemplateSetting.intMissingMinArea)
                                        //{
                                        //    intContourX = m_objMissingBlobs[m_intTemplateIndex].ref_arrContourX[i];
                                        //    intContourY = m_objMissingBlobs[m_intTemplateIndex].ref_arrContourY[i];

                                        //    Contour objContour = new Contour();

                                        //    if (objContour.BuildContour(objSubtractCharROI, intContourX, intContourY, intThresholdValue, 4))
                                        //    {
                                        //        int intMatchCharNo = -1;

                                        //        if (objOCV.IsInOcvCharArea(objContour, ref intMatchCharNo))
                                        //        {
                                        //            blnIsInOcvCharArea = true;
                                        //            if (intArea > objTemplateSetting.intMissingMinArea)
                                        //            {
                                        //                m_blnCharResult[m_intTemplateIndex][intMatchCharNo] = false;

                                        //                m_intMissingBlobResult[m_intTemplateIndex][i] = 2;

                                        //                if ((m_intFailResultMask & 0x10) == 0)
                                        //                    m_intFailResultMask |= 0x10;
                                        //            }
                                        //        }
                                        //    }
                                        //}

                                        //if (blnIsInOcvCharArea) // 2019 04 13-CCENG: Only blob under Ocv Char Area will recorded.
                                        //{
                                        //    if (m_intSmallestMissingMarkArea[m_intTemplateIndex] == 0 || intArea < m_intSmallestMissingMarkArea[m_intTemplateIndex])
                                        //        m_intSmallestMissingMarkArea[m_intTemplateIndex] = intArea;

                                        //    if (m_intBiggestMissingMarkArea[m_intTemplateIndex] == 0 || intArea > m_intBiggestMissingMarkArea[m_intTemplateIndex])
                                        //        m_intBiggestMissingMarkArea[m_intTemplateIndex] = intArea;
                                        //}
                                    }

                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 133");

                                    for (int b = 0; b < m_arrCharBrokenAreaResult[m_intTemplateIndex].Length; b++)
                                    {
                                        if (m_arrCharBrokenAreaResult[m_intTemplateIndex][b] == 0 || !m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[b] // 2020-08-11 ZJYEOH : Skip Broken if mark disabled
                                              || m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting[b] == 0) // 2020-08-11 ZJYEOH : Skip Broken if mark score setting = 0
                                        {
                                            // 2020-08-11 ZJYEOH : Set to 0 so that offline page will not display red color
                                            if (m_arrCharBrokenAreaResult[m_intTemplateIndex][b] != 0)
                                                m_arrCharBrokenAreaResult[m_intTemplateIndex][b] = 0;
                                            continue;
                                        }
                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 134");

                                        // Make sure object area is higher than min area and broken min area
                                        //if ((m_arrCharBrokenAreaResult[m_intTemplateIndex][b] < m_intMinArea) ||
                                        //    (m_arrCharBrokenAreaResult[m_intTemplateIndex][b] <= (int)Math.Round(objTemplateSetting.arrMaxBrokenArea[b])))   // 2021 02 23 - CCENG: change from < to <= bcos == mean pass also
                                        if (m_arrCharBrokenAreaResult[m_intTemplateIndex][b] <= (int)Math.Round(objTemplateSetting.arrMaxBrokenArea[b]) ||   // 2021 02 23 - CCENG: change from < to <= bcos == mean pass also
                                            (intFailOptionMask & 0x10) == 0)
                                        {
                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 135");
                                            continue;
                                        }
                                        else
                                        {
                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 136");
                                            if (m_intSmallestMissingMarkArea[m_intTemplateIndex] == 0 || m_arrCharBrokenAreaResult[m_intTemplateIndex][b] < m_intSmallestMissingMarkArea[m_intTemplateIndex])
                                                m_intSmallestMissingMarkArea[m_intTemplateIndex] = m_arrCharBrokenAreaResult[m_intTemplateIndex][b];

                                            if (m_intBiggestMissingMarkArea[m_intTemplateIndex] == 0 || m_arrCharBrokenAreaResult[m_intTemplateIndex][b] > m_intBiggestMissingMarkArea[m_intTemplateIndex])
                                                m_intBiggestMissingMarkArea[m_intTemplateIndex] = m_arrCharBrokenAreaResult[m_intTemplateIndex][b];

                                            for (int c = 0; c < arrintMatchNo.Count; c++)
                                            {
                                                if (arrintMatchNo[c] == b)
                                                    m_intMissingBlobResult[m_intTemplateIndex][c] = 2;
                                            }

                                            if ((m_intFailResultMask & 0x10) == 0)
                                                m_intFailResultMask |= 0x10;
                                        }
                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 138");
                                    }
                                }
                                objSampleImage_Temp.Dispose();
                                objSampleImage_Temp2.Dispose();
                                objErodeImage.Dispose();
                                objErodeROI.Dispose();
                                objSubtractCharROI.Dispose();
                            }
                        }
                        objImage_Temp.Dispose();
                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 140");
#endregion ---------------------------------------------------------------------------------------------------------

                        if (m_blnWantUseExcessMissingMarkAffectScore)
                        {
                            // Check Char Score
                            int intSetValue;
                            float fSampleScore;
                            intNumChars = objOCV.GetNumChars();
                            for (int i = 0; i < intNumChars; i++)
                            {
                                // Formula 1 - written by Yeoh ///////////////////////////////////////////////////////////////////
                                //float fScore_Excess = Math.Min((float)Convert.ToDouble(m_arrCharExcessAreaResult[m_intTemplateIndex][i]) / m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharDividedLargestArea[i] * 50, 50);
                                //float fScore_Missing = Math.Min((float)Convert.ToDouble(m_arrCharBrokenAreaResult[m_intTemplateIndex][i]) / m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharDividedLargestArea[i] * 50, 50);

                                //float fScore_50Percent = 100 - fScore_Excess - fScore_Missing;

                                //if (fScore_50Percent < 0)
                                //    fScore_50Percent = 0;
                                //else if (fScore_50Percent > 100)
                                //    fScore_50Percent = 100;

                                //fScore_50Percent /= 2;

                                //if (fScore_50Percent < 0)
                                //    fScore_50Percent = 0;

                                // Formula 2 - written by CCENG ///////////////////////////////////////////////////////////////////
                                float fScore_Excess = Math.Min((float)Convert.ToDouble(m_arrCharExcessAreaResult[m_intTemplateIndex][i]) / m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharDividedLargestArea[i] * 100, 50);
                                float fScore_Missing = Math.Min((float)Convert.ToDouble(m_arrCharBrokenAreaResult[m_intTemplateIndex][i]) / m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharDividedLargestArea[i] * 100, 50);

                                float fScore_50Percent = 50 - fScore_Excess - fScore_Missing;

                                if (fScore_50Percent < 0)
                                    fScore_50Percent = 0;
                                else if (fScore_50Percent > 50)
                                    fScore_50Percent = 50;

                                ///////////////////////////////////////////////////////////////////////////////////////////////////

                                objOCV.SetCharScore_ExcessMissingAffectScore(i, fScore_50Percent, m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnIsBarPin1[i] && m_blnWantCheckBarPin1);

                                if (blnByPassUnit)
                                {
                                    intSetValue = intMinMarkScore;
                                }
                                else
                                {
                                    intSetValue = m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting[i];
                                }

                                fSampleScore = objOCV.GetCharScore(i);

                                // Fail if score lower than setting
                                if ((intSetValue > 0 && fSampleScore < intSetValue) && m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i])
                                {
                                    m_blnCharResult[m_intTemplateIndex][i] = false;
                                    if ((m_intFailResultMask & 0x100) == 0)
                                        m_intFailResultMask |= 0x100;
                                }
                                else
                                {
                                    if (!arrCharFailOtherThanScore[i])
                                        m_blnCharResult[m_intTemplateIndex][i] = true;
                                }

                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 18");
                            }
                        }

                        // Stop to test next template if return pass
                        if (m_intFailResultMask == 0)
                            break;

                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 141");
                        SkipInspection:
                        // Stop to test next template if not inspect all
                        if (!m_blnInspectAllTemplate)
                            break;

                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 142");
                        // Go to next template
                        intTemplateCount++;
                    }
                    //if (m_blnWantDontCareArea)
                    //    m_objDontCareBackupImage.CopyTo(ref objImage); //2020-11-17 ZJYEOH : Copy backup image to objImage as it is being modified
                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 143");
                    timeout.Stop(); // ------------------- checking loop timeout ---------------------------------------------------
                    m_blnLock = false;
                    m_blnLockBlobs = false;

                    if (m_intFailResultMask > 0)
                        return false;
                    else
                        return true;
                }
            }
            catch (Exception ex)
            {
                // 2021 01 05 - CCENG: Need to set FailResultMask in order to fail the unit. 
                if ((m_intFailResultMask & 0x1000) == 0)
                    m_intFailResultMask |= 0x1000;

                m_blnExtraSaveImageAndRecipeDueToException = true;
                m_blnLock = false;
                m_blnLockBlobs = false;
                //m_objTL.WriteLine("InspectOCVMark ex: " + ex.ToString());
                return false;
            }
        }

        // 2021-08-25 : Hide this because no more using Lead base point to offset mark ROI
//        public bool InspectOCVMark_NewMethodForMultiExcessMark_OcvAngleAndPackageAngle_Lead(bool blnAuto,
//           ref ImageDrawing objImage, ImageDrawing objOcvRotatedImage,
//           ROI objMarkOcvSearchROI, int intMarkOcvTrainROIWidth, int intMarkOcvTrainROIHeight,
//           ROI objMarkPackageSearchROI, ROI objMarkPackageMarkROI,
//           bool blnSkipExtraPadAndTextShiftedChecking, ImageDrawing objWhiteImage, ImageDrawing objBlackImage, bool blnWantCheckNoMark, bool blnContourCheck, bool blnWantCheckBrokenMark,
//           PointF pRotatedCenterPoint, SizeF SPackageSize, float fPackageAngle, float fMarkAngle, int intInspectionMethod, int intInspectionAreaGrayValueSensitivity, int intBrightSensitivity,
//           bool blnByPassUnit, int intMinMarkScore, List<ROI> arrMarkDontCareROI, ImageDrawing objBlackWhiteTopImage, ImageDrawing objBlackWhiteRightImage, ImageDrawing objBlackWhiteBottomImage, ImageDrawing objBlackWhiteLeftImage)
//        {
//            /*
//             *  Reset previous inspection data
//             *  Get true threshold
//             *  Build objects
//             *  OCV/OCR inspection
//             *      - Check ref char
//             *      - Check recognized char score
//             *      - Check recognized char position
//             *  Check Text Shifted
//             *  Blobs Inspection : Extra Mark(Check Area, Uncheck Area, Group Area), Missing Mark, Broken Mark)
//             *  Subtract Inspection : Extra Mark Char Area and Missing Mark
//             * 
//             * Note: blnSkipExtraPadAndTextShiftedChecking should set to true if WantGauge is false. 
//             * The reason is without Gauge to measure unit edge, vision can't know the exact unit location. Without the unit location information, extra pad and text shifted cannot be detected as well. 
//             */

//            bool blnWantDebug = false;
//            if (blnWantDebug)
//            {
//                objImage.SaveImage("D:\\TS\\objImage.bmp");
//                objOcvRotatedImage.SaveImage("D:\\TS\\objOcvRotatedImage.bmp");
//                objMarkOcvSearchROI.SaveImage("D:\\TS\\objMarkOcvSearchROI.bmp");
//                objMarkPackageSearchROI.SaveImage("D:\\TS\\objMarkPackageSearchROI.bmp");
//                objMarkPackageMarkROI.SaveImage("D:\\TS\\objMarkPackageMarkROI.bmp");
//            }
//            try
//            {
//                m_blnLock = true;
//                m_strResultTrack = "";

//                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 1");
//                WaitEventDone(ref m_blnLockBlobs, false);
//                //lock (m_objLockBlobs)
//                {
//                    m_blnLockBlobs = true;

//                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 2");

//                    // Init and reset all inspection data
//                    int intNoSelectedBlobs = 0;
//                    int intNumChars = 0;
//                    int j;

//                    ResetInspectionData();

//                    for (int i = 0; i < m_arrOCV[m_intGroupIndex].Count; i++)
//                        m_arrOCV[m_intGroupIndex][i].DeleteSample();

//                    // Check valid image
//                    if (objMarkPackageMarkROI.ref_ROI.Width == 0 || objMarkPackageMarkROI.ref_ROI.Height == 0)
//                    {
//                        if ((m_intFailResultMask & 0x1000) == 0)
//                            m_intFailResultMask |= 0x1000;

//                        m_strErrorMessage = "Mark ROI size is 0!";
//                        m_blnLock = false;
//                        m_blnLockBlobs = false;
//                        return false;
//                    }

//                    int intTemplateCount = 0;

//                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 3");

//                    if (m_blnWantDontCareArea)
//                    {
//                        //keep test image in m_objDontCareBackupImage before modify with dont care pattern, so that can be reuse by other template dont care pattern
//                        //if (m_intExtraExcessMarkInspectionAreaCutMode == 0)
//                        objImage.CopyTo(ref m_objDontCareBackupImage);
//                        //else
//                        //    objOcvRotatedImage.CopyTo(ref m_objDontCareBackupImage);
//                    }

//                    // ------------------- checking loop timeout ---------------------------------------------------
//                    HiPerfTimer timeout = new HiPerfTimer();
//                    timeout.Start();

//                    // Loop from first template until last to do OCV inspection
//                    while (intTemplateCount < m_arrOCV[m_intGroupIndex].Count)
//                    {

//                        // ------------------- checking loop timeout ---------------------------------------------------
//                        if (timeout.Timing > 10000)
//                        {
//                            STTrackLog.WriteLine(">>>>>>>>>>>>> time out 801");
//                            break;
//                        }
//                        // ---------------------------------------------------------------------------------------------

//                        // Get selected template index
//                        int intTemplateIndex;
//                        if (m_blnInspectAllTemplate)
//                        {
//                            intTemplateIndex = (int)((m_intTemplatePriority >> (0x04 * intTemplateCount)) & 0x0F) - 1;

//                            if ((m_intTemplateMask & (0x01 << intTemplateIndex)) > 0)
//                                m_intTemplateIndex = intTemplateIndex;
//                            else
//                                goto SkipInspection;
//                        }

//                        // Reset error message and result mask
//                        m_strErrorMessage = "";
//                        m_intFailResultMask = 0;

//                        // Get fix value threshold
//                        int intThresholdValue = GetAutoThreshold(objMarkPackageMarkROI);

//                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 4");

//                        //2020-05-20 ZJYEOH : Use gray value threshold
//                        if (intInspectionMethod == 1)
//                            intThresholdValue = GetGrayValueThreshold(objMarkPackageMarkROI, intInspectionAreaGrayValueSensitivity, intBrightSensitivity);

//                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 5");

//                        // Get fail option mask (Each template has own fail option setting)
//                        int intFailOptionMask = m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intFailOptionMask;

//                        #region ------------- OCV Inspection --------------------------------------------------------------------------------

//                        NOCV objOCV = m_arrOCV[m_intGroupIndex][m_intTemplateIndex];
//                        TemplateSetting objTemplateSetting = m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex];

//                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 6");

//                        //for (int a = 0; a < m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrTemplateCharDilateROI.Count; a++)
//                        //{
//                        //    m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrTemplateCharDilateROI[a]
//                        //}
//                        float fMinTextOffsetAllowX = 0;
//                        float fMinTextOffsetAllowY = 0;

//                        for (int i = 0; i < objTemplateSetting.fCharShiftX.Count; i++)
//                        {
//                            if (i == 0)
//                                fMinTextOffsetAllowX = ((int)Math.Round(objTemplateSetting.fCharShiftX[i] + m_fCharROIOffsetX));
//                            else
//                            {
//                                if (fMinTextOffsetAllowX > ((int)Math.Round(objTemplateSetting.fCharShiftX[i] + m_fCharROIOffsetX)))
//                                    fMinTextOffsetAllowX = ((int)Math.Round(objTemplateSetting.fCharShiftX[i] + m_fCharROIOffsetX));
//                            }

//                            if (i == 0)
//                                fMinTextOffsetAllowY = ((int)Math.Round(objTemplateSetting.fCharShiftY[i] + m_fCharROIOffsetY));
//                            else
//                            {
//                                if (fMinTextOffsetAllowY > ((int)Math.Round(objTemplateSetting.fCharShiftY[i] + m_fCharROIOffsetY)))
//                                    fMinTextOffsetAllowY = ((int)Math.Round(objTemplateSetting.fCharShiftY[i] + m_fCharROIOffsetY));
//                            }
//                        }

//                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 7");

//                        //////objOCV.Inspect(m_objTL, objMarkOcvSearchROI, intThresholdValue, objMarkPackageMarkROI.ref_ROIPositionX,
//                        //////    objMarkPackageMarkROI.ref_ROIPositionY, fMinTextOffsetAllowX, fMinTextOffsetAllowY, m_blnWantSampleAreaScore);

//                        //////// Check Text Score
//                        //////int intSetValue;

//                        //////// Check Char Score
//                        //////float fSampleScore;
//                        //////intNumChars = objOCV.GetNumChars();
//                        //////m_intHitCharCounter = new int[intNumChars];
//                        //////m_blnCharResult[m_intTemplateIndex] = new bool[intNumChars];
//                        //////for (int i = 0; i < intNumChars; i++)
//                        //////{
//                        //////    //// 24-07-2019 ZJYEOH : Skip if the mark is disabled
//                        //////    //if (!m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i])
//                        //////    //    continue;

//                        //////    m_intHitCharCounter[i] = 0;

//                        //////    intSetValue = m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting[i];
//                        //////    fSampleScore = objOCV.GetCharScore(i);
//                        //////    m_strResultTrack += ", CharScore=" + fSampleScore.ToString();

//                        //////    // Fail if score lower than setting
//                        //////    if ((intSetValue > 0 && fSampleScore < intSetValue) && m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i])
//                        //////    {
//                        //////        m_blnCharResult[m_intTemplateIndex][i] = false;
//                        //////        if ((m_intFailResultMask & 0x100) == 0)
//                        //////            m_intFailResultMask |= 0x100;
//                        //////    }
//                        //////    else
//                        //////        m_blnCharResult[m_intTemplateIndex][i] = true;
//                        //////}

//                        //objMarkOcvSearchROI.SaveImage("D:\\objMarkOcvSearchROI1.bmp");
//                        ////2020-06-17 ZJYEOH : Invert if black on white
//                        //ImageDrawing objOCVImage = new ImageDrawing(true, objMarkOcvSearchROI.ref_ROI.TopParent.Width, objMarkOcvSearchROI.ref_ROI.TopParent.Height);
//                        //if (!m_blnWhiteOnBlack)
//                        //{
//                        //    EasyImage.Oper(EArithmeticLogicOperation.Copy, objMarkOcvSearchROI.ref_ROI.TopParent, objOCVImage.ref_objMainImage);
//                        //    objMarkOcvSearchROI.ref_ROI.Detach();
//                        //    objMarkOcvSearchROI.ref_ROI.Attach(objOCVImage.ref_objMainImage);
//                        //    //EasyImage.Oper(EArithmeticLogicOperation.Invert, objMarkOcvSearchROI.ref_ROI, objMarkOcvSearchROI.ref_ROI);
//                        //    ROI.InvertOperationROI(objMarkOcvSearchROI);
//                        //}
//                        //objMarkOcvSearchROI.SaveImage("D:\\objMarkOcvSearchROI2.bmp");

//                        int intOCVThresholdValue = intThresholdValue;
//                        ////2020-06-17 ZJYEOH : Invert threshold value if black on white
//                        //if (!m_blnWhiteOnBlack)
//                        //{
//                        //    intOCVThresholdValue = 255 - intOCVThresholdValue;
//                        //}

//                        bool blnIsTextInsideMarkROI = objOCV.Inspect_First2(m_objTL, objMarkOcvSearchROI, objMarkPackageMarkROI, intOCVThresholdValue, objMarkPackageMarkROI.ref_ROIPositionX,
//                               objMarkPackageMarkROI.ref_ROIPositionY, fMinTextOffsetAllowX, fMinTextOffsetAllowY, m_blnWantSampleAreaScore, m_intMarkScoreOffset, m_intMarkOriPositionScore);

//                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 8");

//                        if (blnIsTextInsideMarkROI)
//                        {
//                            // Check Text Score
//                            int intSetValue;

//                            // 2019 07 16 - CCENG: Not need OCV Text Score Test -----------------------------
//                            //int intNumTexts = objOCV.GetNumTexts();
//                            //m_blnTextResult[m_intTemplateIndex] = new bool[intNumTexts];
//                            //for (int i = 0; i < intNumTexts; i++)
//                            //{
//                            //    intSetValue = m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intTextMinScore;
//                            //    m_arrTestMatchScore[m_intTemplateIndex] = objOCV.GetTextScore(i);

//                            //    // Fail if score lower than setting
//                            //    if (m_arrTestMatchScore[m_intTemplateIndex] < intSetValue)
//                            //    {
//                            //        m_blnTextResult[m_intTemplateIndex][i] = false;
//                            //        if ((m_intFailResultMask & 0x200) == 0)
//                            //            m_intFailResultMask |= 0x200;
//                            //    }
//                            //    else
//                            //        m_blnTextResult[m_intTemplateIndex][i] = true;
//                            //}
//                            //m_blnTextResult[m_intTemplateIndex][i] = true;

//                            // Check Char Score
//                            float fSampleScore;
//                            intNumChars = objOCV.GetNumChars();
//                            m_intHitCharCounter = new int[intNumChars];
//                            m_blnCharResult[m_intTemplateIndex] = new bool[intNumChars];

//                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 9");
//                            for (int i = 0; i < intNumChars; i++)
//                            {
//                                //// 24-07-2019 ZJYEOH : Skip if the mark is disabled
//                                //if (!m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i])
//                                //    continue;

//                                m_intHitCharCounter[i] = 0;

//                                //intSetValue = m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting[i];
//                                // 2020 08 01 - CCENG: Goodark customer request to check minimum mark score when press bypass button in IPM
//                                if (blnByPassUnit)
//                                {
//                                    intSetValue = intMinMarkScore;
//                                }
//                                else
//                                {
//                                    intSetValue = m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting[i];
//                                }

//                                fSampleScore = objOCV.GetCharScore(i);
//                                m_strResultTrack += ", CharScore=" + fSampleScore.ToString();

//                                // Fail if score lower than setting
//                                if ((intSetValue > 0 && fSampleScore < intSetValue) && m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i])
//                                {
//                                    m_blnCharResult[m_intTemplateIndex][i] = false;
//                                    if ((m_intFailResultMask & 0x100) == 0)
//                                        m_intFailResultMask |= 0x100;
//                                }
//                                else
//                                    m_blnCharResult[m_intTemplateIndex][i] = true;

//                                // Fail if AGV Percent lower than setting
//                                if (m_blnWantCheckMarkAverageGrayValue && ((intFailOptionMask & 0x200) > 0))
//                                {
//                                    if ((m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fMaxAGVPercent[i] > 0 && Math.Abs(objOCV.GetCharForeAreaSumPercent(i)) > m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fMaxAGVPercent[i]) && m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i])
//                                    {
//                                        if (m_blnCharResult[m_intTemplateIndex][i])
//                                            m_blnCharResult[m_intTemplateIndex][i] = false;
//                                        if ((m_intFailResultMask & 0x4000) == 0)
//                                            m_intFailResultMask |= 0x4000;
//                                    }
//                                }
//                            }

//                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 10");
//                        }
//                        else
//                        {
//                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 11");
//                            // 2020 04 25 - CCENG: Sometime search ROI is too big until ocv inspection cannot find the mark even though the mark is there.
//                            //              so need to narror the search ROI.
//                            //              The narror search roi == mark roi + 10 or 1/4 or mark roi size.
//                            ROI objNarrowMarkSearchROI = new ROI();
//                            objNarrowMarkSearchROI.AttachImage(objMarkOcvSearchROI);
//                            //int intAddXTolerance = Math.Min(10, objMarkPackageMarkROI.ref_ROIWidth / 4);
//                            //int intAddYTolerance = Math.Min(10, objMarkPackageMarkROI.ref_ROIHeight / 4);
//                            //objNarrowMarkSearchROI.LoadROISetting(objMarkPackageMarkROI.ref_ROIPositionX - intAddXTolerance,
//                            //                                      objMarkPackageMarkROI.ref_ROIPositionY - intAddYTolerance,
//                            //                                      objMarkPackageMarkROI.ref_ROIWidth + intAddXTolerance * 2,
//                            //                                      objMarkPackageMarkROI.ref_ROIHeight + intAddYTolerance * 2);

//                            // 2020 06 26   - CCENG: Need to make sure narror roi is bigger than ocv text size.
//                            //              - Euresys error will display during ocv inspection if roi size smaller ocv text size 
//                            //              - Then why cannot direct use ocv text size for narror roi size. bcos ocv text sometime too small compare to package size.
//                            //              - 
//                            //
//                            int intTextWidth = 0, intTextHeight = 0;
//                            objOCV.GetTextSize(0, ref intTextWidth, ref intTextHeight);


//                            int intBiggestSizeWidth;
//                            int intBiggestSizeHeight;
//                            int intAddXTolerance;
//                            int intAddYTolerance;

//                            if (intMarkOcvTrainROIWidth > objMarkPackageMarkROI.ref_ROIWidth)   // 2020 06 26 - CCENG: use mark train roi size if mark train roi size bigger than package size. (this happen sometime when unit half flip and package size is measured incorrectly.)
//                            {
//                                intBiggestSizeWidth = intMarkOcvTrainROIWidth;
//                                if (intTextWidth > intBiggestSizeWidth)                         // 2020 06 26 - CCENG: use ocv text roi size if ocv text roi size bigger than mark train roi. (this happen when use multi template and user drag mark train roi with different size.
//                                {
//                                    intBiggestSizeWidth = intTextWidth + 4;
//                                }

//                                intAddXTolerance = (intBiggestSizeWidth - objMarkPackageMarkROI.ref_ROIWidth) / 2;
//                            }
//                            else if (intTextWidth > objMarkPackageMarkROI.ref_ROIWidth)         // 2020 06 26 - CCENG: use ocv text roi size if ocv text roi size bigger than mark train roi. (this happen when use multi template and user drag mark train roi with different size.
//                            {
//                                intBiggestSizeWidth = intTextWidth + 4;

//                                intAddXTolerance = (intBiggestSizeWidth - objMarkPackageMarkROI.ref_ROIWidth) / 2;
//                            }
//                            else
//                            {
//                                intAddXTolerance = Math.Min(10, objMarkPackageMarkROI.ref_ROIWidth / 4);
//                            }

//                            if (intMarkOcvTrainROIHeight > objMarkPackageMarkROI.ref_ROIHeight) // 2020 06 26 - CCENG: use mark train roi size if mark train roi size bigger than package size. (this happen sometime when unit half flip and package size is measured incorrectly.)
//                            {
//                                intBiggestSizeHeight = intMarkOcvTrainROIHeight;
//                                if (intTextHeight > intBiggestSizeHeight)                       // 2020 06 26 - CCENG: use ocv text roi size if ocv text roi size bigger than mark train roi. (this happen when use multi template and user drag mark train roi with different size.
//                                {
//                                    intBiggestSizeHeight = intTextHeight + 4;
//                                }

//                                intAddYTolerance = (intBiggestSizeHeight - objMarkPackageMarkROI.ref_ROIHeight) / 2;
//                            }
//                            else if (intTextHeight > objMarkPackageMarkROI.ref_ROIHeight)       // 2020 06 26 - CCENG: use ocv text roi size if ocv text roi size bigger than mark train roi. (this happen when use multi template and user drag mark train roi with different size.
//                            {
//                                intBiggestSizeHeight = intTextHeight + 4;

//                                intAddYTolerance = (intBiggestSizeHeight - objMarkPackageMarkROI.ref_ROIHeight) / 2;
//                            }
//                            else
//                            {
//                                intAddYTolerance = Math.Min(10, objMarkPackageMarkROI.ref_ROIHeight / 4);
//                            }

//                            //2021-04-30 ZJYEOH : Limit to package ROI
//                            if (SPackageSize.Width != -1 && SPackageSize.Height != -1 && pRotatedCenterPoint.X != -1 && pRotatedCenterPoint.X != -1)
//                            {
//                                int intStartX = objMarkPackageMarkROI.ref_ROIPositionX - intAddXTolerance;
//                                int intStartY = objMarkPackageMarkROI.ref_ROIPositionY - intAddYTolerance;
//                                int intWidth = objMarkPackageMarkROI.ref_ROIWidth + intAddXTolerance * 2;
//                                int intHeight = objMarkPackageMarkROI.ref_ROIHeight + intAddYTolerance * 2;

//                                int intTotalStartX = objMarkPackageMarkROI.ref_ROITotalX - intAddXTolerance;
//                                int intTotalStartY = objMarkPackageMarkROI.ref_ROITotalY - intAddYTolerance;

//                                int intOffsetX = 0;
//                                int intOffsetY = 0;
//                                int intOffsetWidth = 0;
//                                int intOffsetHeight = 0;

//                                if (intTotalStartX < (pRotatedCenterPoint.X - (SPackageSize.Width / 2)))
//                                {
//                                    intOffsetX = (int)Math.Round((pRotatedCenterPoint.X - (SPackageSize.Width / 2)) - intTotalStartX);
//                                }

//                                if (intTotalStartY < (pRotatedCenterPoint.Y - (SPackageSize.Height / 2)))
//                                {
//                                    intOffsetY = (int)Math.Round((pRotatedCenterPoint.Y - (SPackageSize.Height / 2)) - intTotalStartY);
//                                }

//                                if ((intTotalStartX + intOffsetX + intWidth) > (pRotatedCenterPoint.X + (SPackageSize.Width / 2)))
//                                {
//                                    intOffsetWidth = (int)Math.Round((pRotatedCenterPoint.X + (SPackageSize.Width / 2)) - (intTotalStartX + intOffsetX + intWidth));
//                                }

//                                if ((intTotalStartY + intOffsetY + intHeight) > (pRotatedCenterPoint.Y + (SPackageSize.Height / 2)))
//                                {
//                                    intOffsetHeight = (int)Math.Round((pRotatedCenterPoint.Y + (SPackageSize.Height / 2)) - (intTotalStartY + intOffsetY + intHeight));
//                                }

//                                objNarrowMarkSearchROI.LoadROISetting(intStartX + intOffsetX,
//                                                                   intStartY + intOffsetY,
//                                                                   intWidth + intOffsetWidth,
//                                                                   intHeight + intOffsetHeight);

//                                //objNarrowMarkSearchROI.SaveImage("D:\\TS\\objNarrowMarkSearchROI" + m_intTemplateIndex.ToString() + ".bmp");
//                                objOCV.Inspect(m_objTL, objNarrowMarkSearchROI, intOCVThresholdValue,//intThresholdValue,
//                                    intAddXTolerance - intOffsetX, intAddYTolerance - intOffsetY,
//                                    fMinTextOffsetAllowX, fMinTextOffsetAllowY, m_blnWantSampleAreaScore);

//                            }
//                            else
//                            {
//                                objNarrowMarkSearchROI.LoadROISetting(objMarkPackageMarkROI.ref_ROIPositionX - intAddXTolerance,
//                                                                      objMarkPackageMarkROI.ref_ROIPositionY - intAddYTolerance,
//                                                                      objMarkPackageMarkROI.ref_ROIWidth + intAddXTolerance * 2,
//                                                                      objMarkPackageMarkROI.ref_ROIHeight + intAddYTolerance * 2);

//                                //objNarrowMarkSearchROI.SaveImage("D:\\TS\\objNarrowMarkSearchROI" + m_intTemplateIndex.ToString() + ".bmp");
//                                objOCV.Inspect(m_objTL, objNarrowMarkSearchROI, intOCVThresholdValue,//intThresholdValue,
//                                    intAddXTolerance, intAddYTolerance,
//                                    fMinTextOffsetAllowX, fMinTextOffsetAllowY, m_blnWantSampleAreaScore);

//                            }

//                            //objNarrowMarkSearchROI.LoadROISetting(objMarkPackageMarkROI.ref_ROIPositionX - intAddXTolerance,
//                            //                                      objMarkPackageMarkROI.ref_ROIPositionY - intAddYTolerance,
//                            //                                      objMarkPackageMarkROI.ref_ROIWidth + intAddXTolerance * 2,
//                            //                                      objMarkPackageMarkROI.ref_ROIHeight + intAddYTolerance * 2);

//                            ////objNarrowMarkSearchROI.SaveImage("D:\\TS\\objNarrowMarkSearchROI" + m_intTemplateIndex.ToString() + ".bmp");
//                            //objOCV.Inspect(m_objTL, objNarrowMarkSearchROI, intOCVThresholdValue,//intThresholdValue,
//                            //    intAddXTolerance, intAddYTolerance,
//                            //    fMinTextOffsetAllowX, fMinTextOffsetAllowY, m_blnWantSampleAreaScore);

//                            objNarrowMarkSearchROI.Dispose();

//                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 12");
//                            // Check Text Score
//                            int intSetValue;

//                            // Check Char Score
//                            float fSampleScore;
//                            intNumChars = objOCV.GetNumChars();
//                            m_intHitCharCounter = new int[intNumChars];
//                            m_blnCharResult[m_intTemplateIndex] = new bool[intNumChars];
//                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 13");
//                            for (int i = 0; i < intNumChars; i++)
//                            {
//                                //// 24-07-2019 ZJYEOH : Skip if the mark is disabled
//                                //if (!m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i])
//                                //    continue;
//                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 14");
//                                m_intHitCharCounter[i] = 0;
//                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 15");
//                                //intSetValue = m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting[i];
//                                // 2020 08 01 - CCENG: Goodark customer request to check minimum mark score when press bypass button in IPM
//                                if (blnByPassUnit)
//                                {
//                                    intSetValue = intMinMarkScore;
//                                }
//                                else
//                                {
//                                    intSetValue = m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting[i];
//                                }
//                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 16");
//                                fSampleScore = objOCV.GetCharScore(i);
//                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 17");
//                                m_strResultTrack += ", CharScore=" + fSampleScore.ToString();

//                                // Fail if score lower than setting
//                                if ((intSetValue > 0 && fSampleScore < intSetValue) && m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i])
//                                {
//                                    m_blnCharResult[m_intTemplateIndex][i] = false;
//                                    if ((m_intFailResultMask & 0x100) == 0)
//                                        m_intFailResultMask |= 0x100;
//                                }
//                                else
//                                    m_blnCharResult[m_intTemplateIndex][i] = true;

//                                // Fail if AGV Percent lower than setting
//                                if (m_blnWantCheckMarkAverageGrayValue && ((intFailOptionMask & 0x200) > 0))
//                                {
//                                    if ((m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fMaxAGVPercent[i] > 0 && Math.Abs(objOCV.GetCharForeAreaSumPercent(i)) > m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fMaxAGVPercent[i]) && m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i])
//                                    {
//                                        if (m_blnCharResult[m_intTemplateIndex][i])
//                                            m_blnCharResult[m_intTemplateIndex][i] = false;
//                                        if ((m_intFailResultMask & 0x4000) == 0)
//                                            m_intFailResultMask |= 0x4000;
//                                    }
//                                }

//                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 18");
//                            }
//                        }

//                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 19");

//                        //objOCVImage.Dispose();

//                        #endregion ----------------------------------------------------------------------------------------------------------

//                        #region ----------------------------- Check Text Shifted ------------------------------------------------------------
//                        if (!blnSkipExtraPadAndTextShiftedChecking && ((intFailOptionMask & 0x40) > 0))      // Want Gauge
//                        {
//                            if (!CheckTextShifted(0, 0, objMarkPackageMarkROI.ref_ROIWidth, objMarkPackageMarkROI.ref_ROIHeight))
//                            {
//                                m_intFailResultMask |= 0x40;
//                            }
//                        }
//                        #endregion ---------------------------------------------------------------------------------------------------------
//                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 20");

//                        // Subtract dont care area according to template (Each template has own dont care setting)
//                        if (m_blnWantDontCareArea)
//                        {
//                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 21");
//                            //m_objDontCareBackupImage.CopyTo(ref objImage);
//                            objMarkPackageSearchROI.AttachImage(m_objDontCareBackupImage);//objImage

//                            ROI objDontCareROI = new ROI();
//                            //objDontCareROI.LoadROISetting(0, 0, objMarkPackageMarkROI.ref_ROIWidth, objMarkPackageMarkROI.ref_ROIHeight);
//                            //objDontCareROI.AttachImage(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].objDontCareImage);
//                            ////2020-06-17 ZJYEOH : Subtract or Add depends on white on black or black on white
//                            //if (m_blnWhiteOnBlack)
//                            //    ROI.SubtractROI(objMarkPackageMarkROI, objDontCareROI);
//                            //else
//                            //    ROI.LogicOperationAddROI(objMarkPackageMarkROI, objDontCareROI);
//                            ROI objOriROI = new ROI();
//                            for (int i = 0; i < arrMarkDontCareROI.Count; i++)
//                            {
//                                objOriROI.AttachImage(m_objDontCareBackupImage);

//                                objDontCareROI.AttachImage(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrDontCareImage[i]);// objWhiteImage

//                                objOriROI.LoadROISetting(objMarkPackageMarkROI.ref_ROITotalCenterX - arrMarkDontCareROI[i].ref_intStartOffsetX,
//                                                         objMarkPackageMarkROI.ref_ROITotalCenterY - arrMarkDontCareROI[i].ref_intStartOffsetY,
//                                                         arrMarkDontCareROI[i].ref_ROIWidth, arrMarkDontCareROI[i].ref_ROIHeight);

//                                objDontCareROI.LoadROISetting(objMarkPackageMarkROI.ref_ROITotalCenterX - arrMarkDontCareROI[i].ref_intStartOffsetX,
//                                                              objMarkPackageMarkROI.ref_ROITotalCenterY - arrMarkDontCareROI[i].ref_intStartOffsetY,
//                                                              arrMarkDontCareROI[i].ref_ROIWidth, arrMarkDontCareROI[i].ref_ROIHeight);

//                                if (m_blnWhiteOnBlack)
//                                    ROI.SubtractROI(objOriROI, objDontCareROI);
//                                else
//                                    ROI.LogicOperationAddROI(objOriROI, objDontCareROI);
//                                //m_objDontCareBackupImage.SaveImage("D:\\m_objDontCareBackupImage.bmp");
//                                //objMarkPackageMarkROI.SaveImage("D:\\objMarkPackageMarkROI" + i.ToString() + ".bmp");
//                            }
//                            objOriROI.Dispose();
//                            objDontCareROI.Dispose();

//                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 22");

//                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 23");
//                            // Define build blob ROI
//                            if (blnSkipExtraPadAndTextShiftedChecking) // No Gauge
//                                DefineBuildBlobROI_SaveTime(m_objDontCareBackupImage, objMarkPackageMarkROI, true);//objImage
//                            else
//                                DefineBuildBlobROI_SaveTime(m_objDontCareBackupImage, objMarkPackageMarkROI, (intFailOptionMask & 0x04) > 0);//objImage

//                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 24");

//                        }
//                        else
//                        {

//                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 23");
//                            // Define build blob ROI
//                            if (blnSkipExtraPadAndTextShiftedChecking) // No Gauge
//                                DefineBuildBlobROI_SaveTime(objImage, objMarkPackageMarkROI, true);
//                            else
//                                DefineBuildBlobROI_SaveTime(objImage, objMarkPackageMarkROI, (intFailOptionMask & 0x04) > 0);

//                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 24");

//                        }

//                        // Get off set ROI for blob-OCV matching and drawing purpose 
//                        m_intROIOffSetX = objMarkPackageMarkROI.ref_ROI.TotalOrgX;
//                        m_intROIOffSetY = objMarkPackageMarkROI.ref_ROI.TotalOrgY;
//                        m_intBlobOCVOffSetX = m_objBuildObjectROI.ref_ROIPositionX - m_intROIOffSetX;
//                        m_intBlobOCVOffSetY = m_objBuildObjectROI.ref_ROIPositionY - m_intROIOffSetY;

//                        ImageDrawing objImage_Temp = new ImageDrawing(true, objImage.ref_intImageWidth, objImage.ref_intImageHeight);
//                        if (m_intExtraExcessMarkInspectionAreaCutMode == 1)
//                        {
//                            if (m_blnWantDontCareArea)
//                                m_objDontCareBackupImage.CopyTo(ref objImage_Temp);
//                            else
//                                objImage.CopyTo(ref objImage_Temp);//objOcvRotatedImage
//                            m_objBuildObjectROI.AttachImage(objImage_Temp);
//                            ROI objLineROI1 = new ROI();
//                            ROI objLineROI2 = new ROI();
//                            ROI objTempROI = new ROI();
//                            ImageDrawing objImage_Temp2 = new ImageDrawing(true, objImage_Temp.ref_intImageWidth, objImage_Temp.ref_intImageHeight);
//                            objLineROI1.AttachImage(objImage_Temp);
//                            //objLineROI2.AttachImage(objWhiteImage);
//                            objTempROI.AttachImage(objImage_Temp2);
//                            for (int i = 0; i < intNumChars; i++)
//                            {
//                                Point pStart = objOCV.GetCharStartXY(i);
//                                Point pEnd = objOCV.GetCharEndXY(i);

//                                ////pStart = new Point(pStart.X - m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharShiftX[i], pStart.Y - m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharShiftY[i]);
//                                ////pEnd = new Point(pEnd.X + m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharShiftX[i], pEnd.Y + m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharShiftY[i]);

//                                //int intOCVWidth = pEnd.X - pStart.X;
//                                //int intOCVHeight = pEnd.Y - pStart.Y;

//                                //// Top Line
//                                //objLineROI1.LoadROISetting(m_intROIOffSetX + pStart.X, m_intROIOffSetY + pStart.Y, intOCVWidth, 1);
//                                //objLineROI2.LoadROISetting(m_intROIOffSetX + pStart.X, m_intROIOffSetY + pStart.Y, intOCVWidth, 1);
//                                //if (m_blnWhiteOnBlack)
//                                //    ROI.SubtractROI(objLineROI1, objLineROI2);
//                                //else
//                                //    ROI.LogicOperationAddROI(objLineROI1, objLineROI2);

//                                //// Right Line
//                                //objLineROI1.LoadROISetting(m_intROIOffSetX + pStart.X + intOCVWidth - 1, m_intROIOffSetY + pStart.Y, 1, intOCVHeight);
//                                //objLineROI2.LoadROISetting(m_intROIOffSetX + pStart.X + intOCVWidth - 1, m_intROIOffSetY + pStart.Y, 1, intOCVHeight);
//                                //if (m_blnWhiteOnBlack)
//                                //    ROI.SubtractROI(objLineROI1, objLineROI2);
//                                //else
//                                //    ROI.LogicOperationAddROI(objLineROI1, objLineROI2);

//                                //// Bottom Line
//                                //objLineROI1.LoadROISetting(m_intROIOffSetX + pStart.X, m_intROIOffSetY + pStart.Y + intOCVHeight - 1, intOCVWidth, 1);
//                                //objLineROI2.LoadROISetting(m_intROIOffSetX + pStart.X, m_intROIOffSetY + pStart.Y + intOCVHeight - 1, intOCVWidth, 1);
//                                //if (m_blnWhiteOnBlack)
//                                //    ROI.SubtractROI(objLineROI1, objLineROI2);
//                                //else
//                                //    ROI.LogicOperationAddROI(objLineROI1, objLineROI2);

//                                //// Left Line
//                                //objLineROI1.LoadROISetting(m_intROIOffSetX + pStart.X, m_intROIOffSetY + pStart.Y, 1, intOCVHeight);
//                                //objLineROI2.LoadROISetting(m_intROIOffSetX + pStart.X, m_intROIOffSetY + pStart.Y, 1, intOCVHeight);
//                                //if (m_blnWhiteOnBlack)
//                                //    ROI.SubtractROI(objLineROI1, objLineROI2);
//                                //else
//                                //    ROI.LogicOperationAddROI(objLineROI1, objLineROI2);

//                                pStart = new Point(m_intROIOffSetX + pStart.X, m_intROIOffSetY + pStart.Y);
//                                pEnd = new Point(m_intROIOffSetX + pEnd.X, m_intROIOffSetY + pEnd.Y);

//                                List<PointF> arrPoints = new List<PointF>();
//                                arrPoints.Add(pStart);
//                                arrPoints.Add(new Point(pStart.X + (pEnd.X - pStart.X), pStart.Y));
//                                arrPoints.Add(new Point(pStart.X, pStart.Y + (pEnd.Y - pStart.Y)));
//                                arrPoints.Add(pEnd);

//                                //PointF pTemp = new PointF();
//                                //Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
//                                //                                 arrPoints[0],
//                                //                                 (/*intOrientationAngle +*/ fMarkAngle),
//                                //                                 ref pTemp);
//                                //arrPoints[0] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

//                                //Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
//                                //                                 arrPoints[1],
//                                //                                 (/*intOrientationAngle +*/ fMarkAngle),
//                                //                                 ref pTemp);
//                                //arrPoints[1] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

//                                //Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
//                                //                                 arrPoints[2],
//                                //                                 (/*intOrientationAngle +*/ fMarkAngle),
//                                //                                 ref pTemp);
//                                //arrPoints[2] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

//                                //Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
//                                //                                 arrPoints[3],
//                                //                                 (/*intOrientationAngle +*/ fMarkAngle),
//                                //                                 ref pTemp);
//                                //arrPoints[3] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

//                                float fMinX = float.MaxValue;
//                                float fMinY = float.MaxValue;
//                                float fMaxX = 0;
//                                float fMaxY = 0;
//                                for (int a = 0; a < arrPoints.Count; a++)
//                                {
//                                    if (fMinX > arrPoints[a].X)
//                                        fMinX = arrPoints[a].X;

//                                    if (fMinY > arrPoints[a].Y)
//                                        fMinY = arrPoints[a].Y;

//                                    if (fMaxX < arrPoints[a].X)
//                                        fMaxX = arrPoints[a].X;

//                                    if (fMaxY < arrPoints[a].Y)
//                                        fMaxY = arrPoints[a].Y;
//                                }

//                                objLineROI1.LoadROISetting((int)Math.Round(fMinX), (int)Math.Round(fMinY),
//                                   (int)Math.Round(fMaxX - fMinX), (int)Math.Round(fMaxY - fMinY));

//                                objLineROI2.LoadROISetting((int)Math.Round(fMinX), (int)Math.Round(fMinY),
//                                   (int)Math.Round(fMaxX - fMinX), (int)Math.Round(fMaxY - fMinY));

//                                objTempROI.LoadROISetting((int)Math.Round(fMinX), (int)Math.Round(fMinY),
//                                   (int)Math.Round(fMaxX - fMinX), (int)Math.Round(fMaxY - fMinY));

//                                ////objLineROI2.AttachImage(objBlackImage);
//                                ////objLineROI2.CopyImage(ref objTempROI);

//                                ////objLineROI2.LoadROISetting(pStart.X, pStart.Y,
//                                ////   pEnd.X - pStart.X, pEnd.Y - pStart.Y);

//                                ////objTempROI.LoadROISetting(pStart.X, pStart.Y,
//                                ////   pEnd.X - pStart.X, pEnd.Y - pStart.Y);

//                                objLineROI2.AttachImage(objWhiteImage);
//                                objLineROI2.CopyImage(ref objTempROI);
//                                //ROI.Rotate0Degree_ForDontCare(objLineROI2, -(intOrientationAngle + fMarkAngle), 4, objTempROI);

//                                ////objLineROI2.LoadROISetting((int)Math.Round(fMinX), (int)Math.Round(fMinY),
//                                ////   (int)Math.Round(fMaxX - fMinX), (int)Math.Round(fMaxY - fMinY));

//                                ////objTempROI.LoadROISetting((int)Math.Round(fMinX), (int)Math.Round(fMinY),
//                                ////   (int)Math.Round(fMaxX - fMinX), (int)Math.Round(fMaxY - fMinY));

//                                //if (blnWantDebug)
//                                //{
//                                //    objLineROI1.SaveImage("D:\\TS\\objLineROIBefore" + i + ".bmp");
//                                //}

//                                if (m_blnWhiteOnBlack)
//                                {
//                                    DontCareWithoutRotateImage.ProduceImage_WithoutLoopMaxPoints(arrPoints, objTempROI, objImage_Temp2
//                                    , objBlackWhiteTopImage, objBlackWhiteRightImage, objBlackWhiteBottomImage, objBlackWhiteLeftImage, false);
//                                }
//                                else
//                                {
//                                    DontCareWithoutRotateImage.ProduceImage_WithoutLoopMaxPoints(arrPoints, objTempROI, objImage_Temp2
//                                    , objBlackWhiteTopImage, objBlackWhiteRightImage, objBlackWhiteBottomImage, objBlackWhiteLeftImage, true);
//                                }

//                                if (m_blnWhiteOnBlack)
//                                    EasyImage.Oper(EArithmeticLogicOperation.Subtract, objLineROI1.ref_ROI, objTempROI.ref_ROI, objLineROI1.ref_ROI);
//                                else
//                                    EasyImage.Oper(EArithmeticLogicOperation.Add, objLineROI1.ref_ROI, objTempROI.ref_ROI, objLineROI1.ref_ROI);

//                                if (blnWantDebug)
//                                {
//                                    objImage_Temp.SaveImage("D:\\TS\\objImage_Temp" + i + ".bmp");
//                                    objTempROI.SaveImage("D:\\TS\\objTempROI" + i + ".bmp");
//                                    objLineROI1.SaveImage("D:\\TS\\objLineROI" + i + ".bmp");
//                                }
//                            }
//                            objTempROI.Dispose();
//                            objLineROI1.Dispose();
//                            objLineROI2.Dispose();
//                            objImage_Temp2.Dispose();
//                        }
//                        else if (m_intExtraExcessMarkInspectionAreaCutMode == 2)
//                        {
//                            if (m_blnWantDontCareArea)
//                                m_objDontCareBackupImage.CopyTo(ref objImage_Temp);
//                            else
//                                objImage.CopyTo(ref objImage_Temp);//objOcvRotatedImage
//                            m_objBuildObjectROI.AttachImage(objImage_Temp);
//                            ROI objLineROI1 = new ROI();
//                            ROI objLineROI2 = new ROI();
//                            ROI objTempROI = new ROI();
//                            ImageDrawing objImage_Temp2 = new ImageDrawing(true, objImage_Temp.ref_intImageWidth, objImage_Temp.ref_intImageHeight);
//                            objLineROI1.AttachImage(objImage_Temp);
//                            //objLineROI2.AttachImage(objWhiteImage);
//                            objTempROI.AttachImage(objImage_Temp2);
//                            for (int i = 0; i < intNumChars; i++)
//                            {
//                                Point pStart = objOCV.GetCharStartXY(i);
//                                Point pEnd = objOCV.GetCharEndXY(i);

//                                pStart = new Point(pStart.X - ((int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftX[i] + m_fCharROIOffsetX)),
//                                                   pStart.Y - ((int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftY[i] + m_fCharROIOffsetY)));
//                                pEnd = new Point(pEnd.X + ((int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftX[i] + m_fCharROIOffsetX)),
//                                                 pEnd.Y + ((int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftY[i] + m_fCharROIOffsetY)));

//                                //int intOCVWidth = pEnd.X - pStart.X;
//                                //int intOCVHeight = pEnd.Y - pStart.Y;

//                                //// Top Line
//                                //objLineROI1.LoadROISetting(m_intROIOffSetX + pStart.X, m_intROIOffSetY + pStart.Y, intOCVWidth, 1);
//                                //objLineROI2.LoadROISetting(m_intROIOffSetX + pStart.X, m_intROIOffSetY + pStart.Y, intOCVWidth, 1);
//                                //if (m_blnWhiteOnBlack)
//                                //    ROI.SubtractROI(objLineROI1, objLineROI2);
//                                //else
//                                //    ROI.LogicOperationAddROI(objLineROI1, objLineROI2);

//                                //// Right Line
//                                //objLineROI1.LoadROISetting(m_intROIOffSetX + pStart.X + intOCVWidth - 1, m_intROIOffSetY + pStart.Y, 1, intOCVHeight);
//                                //objLineROI2.LoadROISetting(m_intROIOffSetX + pStart.X + intOCVWidth - 1, m_intROIOffSetY + pStart.Y, 1, intOCVHeight);
//                                //if (m_blnWhiteOnBlack)
//                                //    ROI.SubtractROI(objLineROI1, objLineROI2);
//                                //else
//                                //    ROI.LogicOperationAddROI(objLineROI1, objLineROI2);

//                                //// Bottom Line
//                                //objLineROI1.LoadROISetting(m_intROIOffSetX + pStart.X, m_intROIOffSetY + pStart.Y + intOCVHeight - 1, intOCVWidth, 1);
//                                //objLineROI2.LoadROISetting(m_intROIOffSetX + pStart.X, m_intROIOffSetY + pStart.Y + intOCVHeight - 1, intOCVWidth, 1);
//                                //if (m_blnWhiteOnBlack)
//                                //    ROI.SubtractROI(objLineROI1, objLineROI2);
//                                //else
//                                //    ROI.LogicOperationAddROI(objLineROI1, objLineROI2);

//                                //// Left Line
//                                //objLineROI1.LoadROISetting(m_intROIOffSetX + pStart.X, m_intROIOffSetY + pStart.Y, 1, intOCVHeight);
//                                //objLineROI2.LoadROISetting(m_intROIOffSetX + pStart.X, m_intROIOffSetY + pStart.Y, 1, intOCVHeight);
//                                //if (m_blnWhiteOnBlack)
//                                //    ROI.SubtractROI(objLineROI1, objLineROI2);
//                                //else
//                                //    ROI.LogicOperationAddROI(objLineROI1, objLineROI2);

//                                pStart = new Point(m_intROIOffSetX + pStart.X, m_intROIOffSetY + pStart.Y);
//                                pEnd = new Point(m_intROIOffSetX + pEnd.X, m_intROIOffSetY + pEnd.Y);

//                                List<PointF> arrPoints = new List<PointF>();
//                                arrPoints.Add(pStart);
//                                arrPoints.Add(new Point(pStart.X + (pEnd.X - pStart.X), pStart.Y));
//                                arrPoints.Add(new Point(pStart.X, pStart.Y + (pEnd.Y - pStart.Y)));
//                                arrPoints.Add(pEnd);

//                                //PointF pTemp = new PointF();
//                                //Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
//                                //                                 arrPoints[0],
//                                //                                 (/*intOrientationAngle +*/ fMarkAngle),
//                                //                                 ref pTemp);
//                                //arrPoints[0] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

//                                //Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
//                                //                                 arrPoints[1],
//                                //                                 (/*intOrientationAngle +*/ fMarkAngle),
//                                //                                 ref pTemp);
//                                //arrPoints[1] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

//                                //Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
//                                //                                 arrPoints[2],
//                                //                                 (/*intOrientationAngle +*/ fMarkAngle),
//                                //                                 ref pTemp);
//                                //arrPoints[2] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

//                                //Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
//                                //                                 arrPoints[3],
//                                //                                 (/*intOrientationAngle +*/ fMarkAngle),
//                                //                                 ref pTemp);
//                                //arrPoints[3] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

//                                float fMinX = float.MaxValue;
//                                float fMinY = float.MaxValue;
//                                float fMaxX = 0;
//                                float fMaxY = 0;
//                                for (int a = 0; a < arrPoints.Count; a++)
//                                {
//                                    if (fMinX > arrPoints[a].X)
//                                        fMinX = arrPoints[a].X;

//                                    if (fMinY > arrPoints[a].Y)
//                                        fMinY = arrPoints[a].Y;

//                                    if (fMaxX < arrPoints[a].X)
//                                        fMaxX = arrPoints[a].X;

//                                    if (fMaxY < arrPoints[a].Y)
//                                        fMaxY = arrPoints[a].Y;
//                                }

//                                objLineROI1.LoadROISetting((int)Math.Round(fMinX), (int)Math.Round(fMinY),
//                                   (int)Math.Round(fMaxX - fMinX), (int)Math.Round(fMaxY - fMinY));

//                                objLineROI2.LoadROISetting((int)Math.Round(fMinX), (int)Math.Round(fMinY),
//                                   (int)Math.Round(fMaxX - fMinX), (int)Math.Round(fMaxY - fMinY));

//                                objTempROI.LoadROISetting((int)Math.Round(fMinX), (int)Math.Round(fMinY),
//                                   (int)Math.Round(fMaxX - fMinX), (int)Math.Round(fMaxY - fMinY));

//                                ////objLineROI2.AttachImage(objBlackImage);
//                                ////objLineROI2.CopyImage(ref objTempROI);

//                                ////objLineROI2.LoadROISetting(pStart.X, pStart.Y,
//                                ////   pEnd.X - pStart.X, pEnd.Y - pStart.Y);

//                                ////objTempROI.LoadROISetting(pStart.X, pStart.Y,
//                                ////   pEnd.X - pStart.X, pEnd.Y - pStart.Y);

//                                objLineROI2.AttachImage(objWhiteImage);
//                                objLineROI2.CopyImage(ref objTempROI);
//                                //ROI.Rotate0Degree_ForDontCare(objLineROI2, -(intOrientationAngle + fMarkAngle), 4, objTempROI);

//                                ////objLineROI2.LoadROISetting((int)Math.Round(fMinX), (int)Math.Round(fMinY),
//                                ////   (int)Math.Round(fMaxX - fMinX), (int)Math.Round(fMaxY - fMinY));

//                                ////objTempROI.LoadROISetting((int)Math.Round(fMinX), (int)Math.Round(fMinY),
//                                ////   (int)Math.Round(fMaxX - fMinX), (int)Math.Round(fMaxY - fMinY));

//                                //if (blnWantDebug)
//                                //{
//                                //    objLineROI1.SaveImage("D:\\TS\\objLineROIBefore" + i + ".bmp");
//                                //}

//                                if (m_blnWhiteOnBlack)
//                                {
//                                    DontCareWithoutRotateImage.ProduceImage_WithoutLoopMaxPoints(arrPoints, objTempROI, objImage_Temp2
//                                    , objBlackWhiteTopImage, objBlackWhiteRightImage, objBlackWhiteBottomImage, objBlackWhiteLeftImage, false);
//                                }
//                                else
//                                {
//                                    DontCareWithoutRotateImage.ProduceImage_WithoutLoopMaxPoints(arrPoints, objTempROI, objImage_Temp2
//                                    , objBlackWhiteTopImage, objBlackWhiteRightImage, objBlackWhiteBottomImage, objBlackWhiteLeftImage, true);
//                                }

//                                if (m_blnWhiteOnBlack)
//                                    EasyImage.Oper(EArithmeticLogicOperation.Subtract, objLineROI1.ref_ROI, objTempROI.ref_ROI, objLineROI1.ref_ROI);
//                                else
//                                    EasyImage.Oper(EArithmeticLogicOperation.Add, objLineROI1.ref_ROI, objTempROI.ref_ROI, objLineROI1.ref_ROI);

//                                if (blnWantDebug)
//                                {
//                                    objImage_Temp.SaveImage("D:\\TS\\objImage_Temp" + i + ".bmp");
//                                    objTempROI.SaveImage("D:\\TS\\objTempROI" + i + ".bmp");
//                                    objLineROI1.SaveImage("D:\\TS\\objLineROI" + i + ".bmp");
//                                }
//                            }
//                            objTempROI.Dispose();
//                            objLineROI1.Dispose();
//                            objLineROI2.Dispose();
//                            objImage_Temp2.Dispose();
//                        }

//                        if (blnWantDebug)
//                        {
//                            m_objBuildObjectROI.SaveImage("D:\\TS\\m_objBuildObjectROI.bmp");
//                            m_objBuildObjectROI.ref_ROI.TopParent.Save("D:\\TS\\m_objBuildObjectROI_Parent.bmp");
//                        }

//                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 25");

//                        int intExtraMarkThreshold = intThresholdValue;
//                        // 2020-11-03 ZJYEOH: Will Use extra mark threshold if want separate threshold
//                        if (m_blnSeparateExtraMarkThreshold)
//                            intExtraMarkThreshold = GetAutoThresholdExtraMark(objMarkPackageMarkROI);

//                        // 2019 08 30 - CCENG: change Connexity 4 to 8. Connexity 8 will link small items into 1 blobs which will make result more stable.
//                        if (!BuildObject(m_objBlobs[m_intTemplateIndex], m_objBuildObjectROI, false, false, intExtraMarkThreshold, 0, 1000000, 0x1F))
//                        {
//                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 26");
//                            //m_strErrorMessage = "BuildObjects : No blobs object selected!";
//                            //m_blnLock = false;
//                            //m_blnLockBlobs = false;
//                            //return false;
//                        }

//                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 27");
//                        intNoSelectedBlobs = m_objBlobs[m_intTemplateIndex].ref_intNumSelectedObject;
//                        //#region ------------- No Mark Inspection --------------------------------------------------------------------------------
//                        if (blnWantCheckNoMark)
//                        {
//                            m_intTotalBlobArea = 0;
//                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 28");
//                            ////for (int i = 0; i < intNoSelectedBlobs; i++)
//                            //for (int i = 0; i < m_objBlobs[m_intTemplateIndex].ref_arrArea.Count; i++)
//                            //{
//                            //    m_intTotalBlobArea += m_objBlobs[m_intTemplateIndex].ref_arrArea[i];
//                            //}

//                            //2021-04-14 ZJYEOH : Use White pixel to find no mark
//                            ROI objNoMarkROI = new ROI();
//                            objNoMarkROI.AttachImage(objImage); //objOcvRotatedImage
//                            objNoMarkROI.LoadROISetting(m_objBuildObjectROI.ref_ROIPositionX, m_objBuildObjectROI.ref_ROIPositionY, m_objBuildObjectROI.ref_ROIWidth, m_objBuildObjectROI.ref_ROIHeight);
//                            if (m_blnWhiteOnBlack)
//                                m_intTotalBlobArea = ROI.GetPixelArea(objNoMarkROI, intThresholdValue, 1);
//                            else
//                                m_intTotalBlobArea = ROI.GetPixelArea(objNoMarkROI, intThresholdValue, 0);

//                            objNoMarkROI.Dispose();

//                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 29");

//                            if (m_intTotalBlobArea < (int)Math.Round(m_fNoMarkMaximumBlobArea))
//                            {
//                                if ((m_intFailResultMask & 0x1000) == 0)
//                                    m_intFailResultMask |= 0x1000;

//                                m_strErrorMessage = "*No Mark! Set = " + GetNoMarkMaximumBlobArea().ToString() + " " + GetDisplayUnitName(m_intDisplayUnitMode, true) + ", " +
//                                    "Result = " + GetResultTotalBlobArea().ToString() + " " + GetDisplayUnitName(m_intDisplayUnitMode, true) + ".";

//                                objImage_Temp.Dispose();
//                                m_blnLock = false;
//                                m_blnLockBlobs = false;
//                                return false;
//                            }
//                        }
//                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 30");
//                        //#endregion ----------------------------------------------------------------------------------------------------------

//                        #region ----------------------------- Blobs Inspection ------------------------------------------------------------
//                        bool blnGroupExtraMark = false;
//                        bool blnGroupExcessMark = false;
//                        float fCenterX, fCenterY, fWidth, fHeight, fAngle, fGravityCenterX, fGravityCenterY, fStartX, fStartY, fEndX, fEndY;
//                        int intArea = 0, intContourX = 0, intContourY = 0;
//                        List<float> arrExcessStartX = new List<float>();
//                        List<float> arrExcessStartY = new List<float>();
//                        List<float> arrExcessEndX = new List<float>();
//                        List<float> arrExcessEndY = new List<float>();
//                        List<PointF> arrCharStartPoint_RotateTo0Deg = new List<PointF>();
//                        List<PointF> arrCharEndPoint_RotateTo0Deg = new List<PointF>();

//                        for (int a = 0; a < intNumChars; a++)
//                        {
//                            arrExcessStartX.Add(-1);
//                            arrExcessStartY.Add(-1);
//                            arrExcessEndX.Add(-1);
//                            arrExcessEndY.Add(-1);

//                            int intStartX, intStartY, intEndX, intEndY;

//                            //2021-02-11 ZJYEOH: Collect OCV point with 0 degree for matching index use
//                            Point pStart = objOCV.GetCharStartXY(a);
//                            Point pEnd = objOCV.GetCharEndXY(a);

//                            intStartX = m_intROIOffSetX + pStart.X;
//                            intStartY = m_intROIOffSetY + pStart.Y;
//                            intEndX = m_intROIOffSetX + pEnd.X;
//                            intEndY = m_intROIOffSetY + pEnd.Y;

//                            arrCharStartPoint_RotateTo0Deg.Add(new PointF(intStartX, intStartY));
//                            arrCharEndPoint_RotateTo0Deg.Add(new PointF(intEndX, intEndY));
//                        }

//                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 31");
//                        // Init blob data
//                        m_intBlobResult[m_intTemplateIndex] = new int[intNoSelectedBlobs];
//                        for (j = 0; j < intNoSelectedBlobs; j++)
//                        {
//                            m_intBlobResult[m_intTemplateIndex][j] = 0;
//                        }

//                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 32");
//                        fCenterX = fCenterY = fWidth = fHeight = fAngle = fGravityCenterX = fGravityCenterY = 0;
//                        if ((intFailOptionMask & 0x80) > 0)
//                        {
//                            if (m_arrCharJointMarkResult[m_intTemplateIndex] == null)
//                                m_arrCharJointMarkResult[m_intTemplateIndex] = new bool[intNumChars];

//                            if (m_arrCharJointMarkResult[m_intTemplateIndex].Length != intNumChars)
//                                m_arrCharJointMarkResult[m_intTemplateIndex] = new bool[intNumChars];

//                            for (int a = 0; a < intNumChars; a++)
//                            {
//                                m_arrCharJointMarkResult[m_intTemplateIndex][a] = true;
//                            }

//                            if (m_intExtraExcessMarkInspectionAreaCutMode == 0)
//                            {
//                                for (int i = 0; i < intNoSelectedBlobs; i++)
//                                {
//                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 33");
//                                    fCenterX = m_objBlobs[m_intTemplateIndex].ref_arrLimitCenterX[i];
//                                    fCenterY = m_objBlobs[m_intTemplateIndex].ref_arrLimitCenterY[i];
//                                    fWidth = m_objBlobs[m_intTemplateIndex].ref_arrWidth[i];
//                                    fHeight = m_objBlobs[m_intTemplateIndex].ref_arrHeight[i];
//                                    fGravityCenterX = m_objBlobs[m_intTemplateIndex].ref_arrGravityCenterX[i];
//                                    fGravityCenterY = m_objBlobs[m_intTemplateIndex].ref_arrGravityCenterY[i];
//                                    intArea = m_objBlobs[m_intTemplateIndex].ref_arrArea[i];
//                                    intContourX = m_objBlobs[m_intTemplateIndex].ref_arrContourX[i];
//                                    intContourY = m_objBlobs[m_intTemplateIndex].ref_arrContourY[i];

//                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 34");
//                                    // Use m_intMinArea as min area if m_intMinArea < 5, else use 5 as min area
//                                    if (m_intMinArea < 5)
//                                    {
//                                        // skip checking if blob area lower than setting
//                                        if (intArea <= m_intMinArea)
//                                        {
//                                            continue;
//                                        }
//                                    }
//                                    else
//                                    {
//                                        // skip checking if blob area lower than setting
//                                        if (intArea <= 5)
//                                        {
//                                            continue;
//                                        }
//                                    }

//                                    float fRotateCenterX = fCenterX;
//                                    float fRotateCenterY = fCenterY;
//                                    //float fRotateRefCenterX = pRotatedCenterPoint.X - m_objBuildObjectROI.ref_ROITotalX;
//                                    //float fRotateRefCenterY = pRotatedCenterPoint.Y - m_objBuildObjectROI.ref_ROITotalY;

//                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 35");

//                                    //2020-06-23 ZJYEOH : if no check package size, pRotatedCenterPoint will be (-1, -1)
//                                    if (pRotatedCenterPoint != new PointF(-1, -1))
//                                    {
//                                        Math2.GetNewXYAfterRotate_360deg((float)m_objBuildObjectROI.ref_ROIWidth / 2, (float)m_objBuildObjectROI.ref_ROIHeight / 2,
//                                                                    fCenterX, fCenterY,
//                                                                    fPackageAngle - fMarkAngle,
//                                                                    ref fRotateCenterX, ref fRotateCenterY);
//                                    }

//                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 36");

//                                    // Get blob start point and end point
//                                    fStartX = fRotateCenterX - fWidth / 2 + m_intBlobOCVOffSetX;
//                                    fStartY = fRotateCenterY - fHeight / 2 + m_intBlobOCVOffSetY;
//                                    fEndX = fRotateCenterX + fWidth / 2 + m_intBlobOCVOffSetX;
//                                    fEndY = fRotateCenterY + fHeight / 2 + m_intBlobOCVOffSetY;

//                                    //2021-01-19 ZJYEOH : Matching area added shift tolerance ao that extra mark inside char area will not consider as extra mark
//                                    //bool blnContourCheck = false;
//                                    List<int> intMatchNumber = new List<int>();
//                                    if (m_intExtraExcessMarkInspectionAreaCutMode == 0)
//                                    {
//                                        intMatchNumber = objOCV.GetMatchCharIndexes(fStartX, fStartY, fEndX, fEndY,
//                                                                                                                           fRotateCenterX + m_intBlobOCVOffSetX, fRotateCenterY + m_intBlobOCVOffSetY,
//                                                                                                                           fWidth, fHeight, ref blnContourCheck
//                                                                                                                           , m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftX,
//                                                                                                                           m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftY,
//                                                                                                                           m_fCharROIOffsetX, m_fCharROIOffsetY,
//                                                                                                                           true);
//                                    }

//                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 37");
//                                    // By using contour, double check again the selected OCV Char rectangle box is/are really matched by blobs
//                                    if (blnContourCheck && intMatchNumber.Count > 0)
//                                    {
//                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 38");
//                                        for (int e = 0; e < intMatchNumber.Count; e++)
//                                        {
//                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 39");
//                                            // Build contour elements for the selected blob
//                                            Contour objContour = new Contour();
//                                            objContour.ClearContour();
//                                            if (objContour.BuildContour(m_objBuildObjectROI, intContourX, intContourY, intExtraMarkThreshold, 8))//intThresholdValue, 4 //2021-02-10 ZJYEOH : Use connexity 8 because blob is built using connexity 8
//                                            {
//                                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 40");
//                                                // Check is the blob in OCV Char rectangle box
//                                                if (!objOCV.IsInOcvCharArea(objContour, intMatchNumber[e], m_intBlobOCVOffSetX, m_intBlobOCVOffSetY))
//                                                {
//                                                    intMatchNumber.RemoveAt(e);
//                                                    e--;
//                                                }

//                                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 41");
//                                            }
//                                        }
//                                    }

//                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 42");

//                                    if (intMatchNumber.Count > 1)
//                                    {
//                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 56");
//                                        // Make sure area >= min area
//                                        if (intArea < m_intMinArea)
//                                        {
//                                            continue;
//                                        }

//                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 57");
//                                        // Set char hit by blob counter
//                                        //for (j = 0; j < intMatchNumber.Count; j++)
//                                        //{
//                                        //    m_intHitCharCounter[intMatchNumber[j]]++;
//                                        //}

//                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 59");
//                                        // Check joint mark (1 blob match to more than 1 char)
//                                        //if (intMatchNumber.Count > 1)
//                                        {
//                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 60");

//                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 61");
//                                            int intDisabledMarkCounter = 0;
//                                            int intEnabledMarkCounter = 0;
//                                            for (int q = 0; q < intMatchNumber.Count; q++)
//                                            {
//                                                if (!m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[intMatchNumber[q]])
//                                                    intDisabledMarkCounter++;
//                                                else
//                                                    intEnabledMarkCounter++;
//                                            }

//                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 63");

//                                            if (intDisabledMarkCounter > 1 && intEnabledMarkCounter < intDisabledMarkCounter || intEnabledMarkCounter <= 1)
//                                                goto Skip;

//                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 64");
//                                            m_intBlobResult[m_intTemplateIndex][i] = 2;

//                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 65");

//                                            for (int q = 0; q < intMatchNumber.Count; q++)
//                                            {
//                                                m_blnCharResult[m_intTemplateIndex][intMatchNumber[q]] = false;

//                                                if (m_arrCharJointMarkResult[m_intTemplateIndex][intMatchNumber[q]])
//                                                    m_arrCharJointMarkResult[m_intTemplateIndex][intMatchNumber[q]] = false;

//                                            }

//                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 66");
//                                            if ((m_intFailResultMask & 0x80) == 0)
//                                                m_intFailResultMask |= 0x80;
//                                        }

//                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 67");
//                                        Skip: { }

//                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 68");

//                                    }
//                                }
//                            }
//                            else
//                            {

//                                if (blnWantDebug)
//                                {
//                                    m_objJointMarkROI.SaveImage("D:\\TS\\m_objJointMarkROI.bmp");
//                                    m_objJointMarkROI.ref_ROI.TopParent.Save("D:\\TS\\m_objJointMarkROI_Parent.bmp");
//                                }

//                                // 2019 08 30 - CCENG: change Connexity 4 to 8. Connexity 8 will link small items into 1 blobs which will make result more stable.
//                                if (!BuildObject(m_objJointMarkBlobs[m_intTemplateIndex], m_objJointMarkROI, false, false, intExtraMarkThreshold, 0, 1000000, 0x1F))
//                                {
//                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 26");
//                                    //m_strErrorMessage = "BuildObjects : No blobs object selected!";
//                                    //m_blnLock = false;
//                                    //m_blnLockBlobs = false;
//                                    //return false;
//                                }

//                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 27");

//                                if (m_intExtraExcessMarkInspectionAreaCutMode != 0)
//                                {
//                                    m_intJointMarkBlobResult[m_intTemplateIndex] = new int[m_objJointMarkBlobs[m_intTemplateIndex].ref_intNumSelectedObject];
//                                    for (j = 0; j < m_objJointMarkBlobs[m_intTemplateIndex].ref_intNumSelectedObject; j++)
//                                    {
//                                        m_intJointMarkBlobResult[m_intTemplateIndex][j] = 0;
//                                    }

//                                }

//                                for (int i = 0; i < m_objJointMarkBlobs[m_intTemplateIndex].ref_intNumSelectedObject; i++)
//                                {
//                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 33");
//                                    fCenterX = m_objJointMarkBlobs[m_intTemplateIndex].ref_arrLimitCenterX[i];
//                                    fCenterY = m_objJointMarkBlobs[m_intTemplateIndex].ref_arrLimitCenterY[i];
//                                    fWidth = m_objJointMarkBlobs[m_intTemplateIndex].ref_arrWidth[i];
//                                    fHeight = m_objJointMarkBlobs[m_intTemplateIndex].ref_arrHeight[i];
//                                    fGravityCenterX = m_objJointMarkBlobs[m_intTemplateIndex].ref_arrGravityCenterX[i];
//                                    fGravityCenterY = m_objJointMarkBlobs[m_intTemplateIndex].ref_arrGravityCenterY[i];
//                                    intArea = m_objJointMarkBlobs[m_intTemplateIndex].ref_arrArea[i];
//                                    intContourX = m_objJointMarkBlobs[m_intTemplateIndex].ref_arrContourX[i];
//                                    intContourY = m_objJointMarkBlobs[m_intTemplateIndex].ref_arrContourY[i];

//                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 34");
//                                    // Use m_intMinArea as min area if m_intMinArea < 5, else use 5 as min area
//                                    if (m_intMinArea < 5)
//                                    {
//                                        // skip checking if blob area lower than setting
//                                        if (intArea <= m_intMinArea)
//                                        {
//                                            continue;
//                                        }
//                                    }
//                                    else
//                                    {
//                                        // skip checking if blob area lower than setting
//                                        if (intArea <= 5)
//                                        {
//                                            continue;
//                                        }
//                                    }

//                                    float fRotateCenterX = fCenterX;
//                                    float fRotateCenterY = fCenterY;
//                                    //float fRotateRefCenterX = pRotatedCenterPoint.X - m_objBuildObjectROI.ref_ROITotalX;
//                                    //float fRotateRefCenterY = pRotatedCenterPoint.Y - m_objBuildObjectROI.ref_ROITotalY;

//                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 35");

//                                    //2020-06-23 ZJYEOH : if no check package size, pRotatedCenterPoint will be (-1, -1)
//                                    if (pRotatedCenterPoint != new PointF(-1, -1))
//                                    {
//                                        Math2.GetNewXYAfterRotate_360deg((float)m_objJointMarkROI.ref_ROIWidth / 2, (float)m_objJointMarkROI.ref_ROIHeight / 2,
//                                                                    fCenterX, fCenterY,
//                                                                    fPackageAngle - fMarkAngle,
//                                                                    ref fRotateCenterX, ref fRotateCenterY);
//                                    }

//                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 36");

//                                    // Get blob start point and end point
//                                    fStartX = fRotateCenterX - fWidth / 2 + m_intBlobOCVOffSetX;
//                                    fStartY = fRotateCenterY - fHeight / 2 + m_intBlobOCVOffSetY;
//                                    fEndX = fRotateCenterX + fWidth / 2 + m_intBlobOCVOffSetX;
//                                    fEndY = fRotateCenterY + fHeight / 2 + m_intBlobOCVOffSetY;

//                                    //2021-01-19 ZJYEOH : Matching area added shift tolerance so that extra mark inside char area will not consider as extra mark
//                                    //bool blnContourCheck = false;
//                                    List<int> intMatchNumber = new List<int>();
//                                    //if (m_intExtraExcessMarkInspectionAreaCutMode == 0)
//                                    {
//                                        intMatchNumber = objOCV.GetMatchCharIndexes(fStartX, fStartY, fEndX, fEndY,
//                                                                                                  fRotateCenterX + m_intBlobOCVOffSetX, fRotateCenterY + m_intBlobOCVOffSetY,
//                                                                                                  fWidth, fHeight, ref blnContourCheck
//                                                                                                  , m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftX,
//                                                                                                  m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftY,
//                                                                                                  m_fCharROIOffsetX, m_fCharROIOffsetY
//                                                                                                  , true);
//                                    }

//                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 37");
//                                    // By using contour, double check again the selected OCV Char rectangle box is/are really matched by blobs
//                                    if (blnContourCheck && intMatchNumber.Count > 0)
//                                    {
//                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 38");
//                                        for (int e = 0; e < intMatchNumber.Count; e++)
//                                        {
//                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 39");
//                                            // Build contour elements for the selected blob
//                                            Contour objContour = new Contour();
//                                            objContour.ClearContour();
//                                            if (objContour.BuildContour(m_objJointMarkROI, intContourX, intContourY, intExtraMarkThreshold, 8))//intThresholdValue, 4 //2021-02-10 ZJYEOH : Use connexity 8 because blob is built using connexity 8
//                                            {
//                                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 40");
//                                                // Check is the blob in OCV Char rectangle box
//                                                if (!objOCV.IsInOcvCharArea(objContour, intMatchNumber[e], m_intBlobOCVOffSetX, m_intBlobOCVOffSetY))
//                                                {
//                                                    intMatchNumber.RemoveAt(e);
//                                                    e--;
//                                                }

//                                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 41");
//                                            }
//                                        }
//                                    }

//                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 42");

//                                    if (intMatchNumber.Count > 1)
//                                    {
//                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 56");
//                                        // Make sure area >= min area
//                                        if (intArea < m_intMinArea)
//                                        {
//                                            continue;
//                                        }

//                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 57");
//                                        //// Set char hit by blob counter
//                                        //for (j = 0; j < intMatchNumber.Count; j++)
//                                        //{
//                                        //    m_intHitCharCounter[intMatchNumber[j]]++;
//                                        //}

//                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 59");
//                                        // Check joint mark (1 blob match to more than 1 char)
//                                        //if (intMatchNumber.Count > 1)
//                                        {
//                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 60");
//                                            //if ((intFailOptionMask & 0x80) > 0)
//                                            //{
//                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 61");
//                                            int intDisabledMarkCounter = 0;
//                                            int intEnabledMarkCounter = 0;
//                                            for (int q = 0; q < intMatchNumber.Count; q++)
//                                            {
//                                                if (!m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[intMatchNumber[q]])
//                                                    intDisabledMarkCounter++;
//                                                else
//                                                    intEnabledMarkCounter++;
//                                            }

//                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 63");

//                                            if (intDisabledMarkCounter > 1 && intEnabledMarkCounter < intDisabledMarkCounter || intEnabledMarkCounter <= 1)
//                                                goto Skip;

//                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 64");
//                                            m_intJointMarkBlobResult[m_intTemplateIndex][i] = 2;

//                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 65");

//                                            for (int q = 0; q < intMatchNumber.Count; q++)
//                                            {
//                                                m_blnCharResult[m_intTemplateIndex][intMatchNumber[q]] = false;

//                                                if (m_arrCharJointMarkResult[m_intTemplateIndex][intMatchNumber[q]])
//                                                    m_arrCharJointMarkResult[m_intTemplateIndex][intMatchNumber[q]] = false;
//                                            }

//                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 66");
//                                            if ((m_intFailResultMask & 0x80) == 0)
//                                                m_intFailResultMask |= 0x80;
//                                            //}

//                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 67");
//                                            Skip: { }

//                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 68");
//                                        }
//                                    }
//                                }
//                            }
//                        }

//                        for (int i = 0; i < intNoSelectedBlobs; i++)
//                        {
//                            if (m_intBlobResult[m_intTemplateIndex][i] == 2)
//                                continue;

//                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 33");
//                            fCenterX = m_objBlobs[m_intTemplateIndex].ref_arrLimitCenterX[i];
//                            fCenterY = m_objBlobs[m_intTemplateIndex].ref_arrLimitCenterY[i];
//                            fWidth = m_objBlobs[m_intTemplateIndex].ref_arrWidth[i];
//                            fHeight = m_objBlobs[m_intTemplateIndex].ref_arrHeight[i];
//                            fGravityCenterX = m_objBlobs[m_intTemplateIndex].ref_arrGravityCenterX[i];
//                            fGravityCenterY = m_objBlobs[m_intTemplateIndex].ref_arrGravityCenterY[i];
//                            intArea = m_objBlobs[m_intTemplateIndex].ref_arrArea[i];
//                            intContourX = m_objBlobs[m_intTemplateIndex].ref_arrContourX[i];
//                            intContourY = m_objBlobs[m_intTemplateIndex].ref_arrContourY[i];

//                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 34");
//                            // Use m_intMinArea as min area if m_intMinArea < 5, else use 5 as min area
//                            if (m_intMinArea < 5)
//                            {
//                                // skip checking if blob area lower than setting
//                                if (intArea <= m_intMinArea)
//                                {
//                                    continue;
//                                }
//                            }
//                            else
//                            {
//                                // skip checking if blob area lower than setting
//                                if (intArea <= 5)
//                                {
//                                    continue;
//                                }
//                            }

//                            float fRotateCenterX = fCenterX;
//                            float fRotateCenterY = fCenterY;
//                            //float fRotateRefCenterX = pRotatedCenterPoint.X - m_objBuildObjectROI.ref_ROITotalX;
//                            //float fRotateRefCenterY = pRotatedCenterPoint.Y - m_objBuildObjectROI.ref_ROITotalY;

//                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 35");

//                            //2020-06-23 ZJYEOH : if no check package size, pRotatedCenterPoint will be (-1, -1)
//                            if (pRotatedCenterPoint != new PointF(-1, -1))
//                            {
//                                Math2.GetNewXYAfterRotate_360deg((float)m_objBuildObjectROI.ref_ROIWidth / 2, (float)m_objBuildObjectROI.ref_ROIHeight / 2,
//                                                            fCenterX, fCenterY,
//                                                            fPackageAngle - fMarkAngle,
//                                                            ref fRotateCenterX, ref fRotateCenterY);
//                            }

//                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 36");

//                            // Get blob start point and end point
//                            fStartX = fRotateCenterX - fWidth / 2 + m_intBlobOCVOffSetX;
//                            fStartY = fRotateCenterY - fHeight / 2 + m_intBlobOCVOffSetY;
//                            fEndX = fRotateCenterX + fWidth / 2 + m_intBlobOCVOffSetX;
//                            fEndY = fRotateCenterY + fHeight / 2 + m_intBlobOCVOffSetY;

//                            //2021-01-19 ZJYEOH : Matching area added shift tolerance ao that extra mark inside char area will not consider as extra mark
//                            //bool blnContourCheck = false;
//                            List<int> intMatchNumber = new List<int>();
//                            if (m_intExtraExcessMarkInspectionAreaCutMode == 0)
//                            {
//                                intMatchNumber = objOCV.GetMatchCharIndexes(fStartX, fStartY, fEndX, fEndY,
//                                                                                                                   fRotateCenterX + m_intBlobOCVOffSetX, fRotateCenterY + m_intBlobOCVOffSetY,
//                                                                                                                   fWidth, fHeight, ref blnContourCheck
//                                                                                                                   , m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftX,
//                                                                                                                   m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftY,
//                                                                                                                   m_fCharROIOffsetX, m_fCharROIOffsetY,
//                                                                                                                   m_intExtraExcessMarkInspectionAreaCutMode == 1);
//                            }

//                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 37");
//                            // By using contour, double check again the selected OCV Char rectangle box is/are really matched by blobs
//                            if (blnContourCheck && intMatchNumber.Count > 0)
//                            {
//                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 38");
//                                for (int e = 0; e < intMatchNumber.Count; e++)
//                                {
//                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 39");
//                                    // Build contour elements for the selected blob
//                                    Contour objContour = new Contour();
//                                    objContour.ClearContour();
//                                    if (objContour.BuildContour(m_objBuildObjectROI, intContourX, intContourY, intExtraMarkThreshold, 8))//intThresholdValue, 4 //2021-02-10 ZJYEOH : Use connexity 8 because blob is built using connexity 8
//                                    {
//                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 40");
//                                        // Check is the blob in OCV Char rectangle box
//                                        if (!objOCV.IsInOcvCharArea(objContour, intMatchNumber[e], m_intBlobOCVOffSetX, m_intBlobOCVOffSetY))
//                                        {
//                                            intMatchNumber.RemoveAt(e);
//                                            e--;
//                                        }

//                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 41");
//                                    }
//                                }
//                            }

//                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 42");

//                            if (intMatchNumber.Count == 0)
//                            {
//                                // Check Group Extra Mark
//                                if (((intFailOptionMask & 0x08) > 0)) //!blnSkipExtraPadAndTextShiftedChecking &&
//                                {
//                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 43");
//                                    m_intGroupExtraMarkArea[m_intTemplateIndex] += intArea;
//                                    m_intBlobResult[m_intTemplateIndex][i] = 1;

//                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 44");
//                                    if (m_intGroupExtraMarkArea[m_intTemplateIndex] > (int)Math.Round(objTemplateSetting.fGroupExtraMinArea))
//                                    {
//                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 45");
//                                        m_intBlobResult[m_intTemplateIndex][i] = 2;

//                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 46");
//                                        if (!blnGroupExtraMark)
//                                        {
//                                            m_intFailResultMask |= 0x08;
//                                            blnGroupExtraMark = true;

//                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 47");
//                                            // Upgrade result from 1 to 2
//                                            for (j = 0; j < intNoSelectedBlobs; j++)
//                                            {
//                                                if (m_intBlobResult[m_intTemplateIndex][j] == 1)
//                                                    m_intBlobResult[m_intTemplateIndex][j] = 2;
//                                            }

//                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 48");
//                                        }
//                                    }
//                                }

//                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 49");

//                                //2020-06-02 ZJYEOH : filter blob with area less than min area
//                                if ((intArea <= m_intMinArea))
//                                {
//                                    continue;
//                                }

//                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 50");

//                                // 2020 05 22 - CCENG: Move the "record extra mark area" coding to before check ExtraMinArea. This let user know current size of extra area and easier for them to do setting.
//                                if (m_intSmallestExtraMarkArea[m_intTemplateIndex] == 0 || intArea < m_intSmallestExtraMarkArea[m_intTemplateIndex])
//                                    m_intSmallestExtraMarkArea[m_intTemplateIndex] = intArea;

//                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 51");
//                                if (m_intBiggestExtraMarkArea[m_intTemplateIndex] == 0 || intArea > m_intBiggestExtraMarkArea[m_intTemplateIndex])
//                                    m_intBiggestExtraMarkArea[m_intTemplateIndex] = intArea;

//                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 52");
//                                // Make sure object area is higher than min area and extra min area
//                                if ((intArea <= (int)Math.Round(objTemplateSetting.fExtraMinArea))) // if ((intArea <= m_intMinArea) || (intArea <= objTemplateSetting.intExtraMinArea))
//                                {
//                                    continue;
//                                }

//                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 53");
//                                // 2020 05 22 - CCENG: Move the "record extra mark area" coding to before check ExtraMinArea. This let user know current size of extra area and easier for them to do setting.
//                                //if (m_intSmallestExtraMarkArea[m_intTemplateIndex] == 0 || intArea < m_intSmallestExtraMarkArea[m_intTemplateIndex])
//                                //    m_intSmallestExtraMarkArea[m_intTemplateIndex] = intArea;

//                                //if (m_intBiggestExtraMarkArea[m_intTemplateIndex] == 0 || intArea > m_intBiggestExtraMarkArea[m_intTemplateIndex])
//                                //    m_intBiggestExtraMarkArea[m_intTemplateIndex] = intArea;

//                                // Check Extra Mark 
//                                if ((((intFailOptionMask & 0x02) > 0) || (!blnSkipExtraPadAndTextShiftedChecking && ((intFailOptionMask & 0x04) > 0)))) // Want Gauge !blnSkipExtraPadAndTextShiftedChecking &&
//                                {
//                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 54");
//                                    m_intBlobResult[m_intTemplateIndex][i] = 2;

//                                    //if (m_intSmallestExtraMarkArea[m_intTemplateIndex] == 0 || intArea < m_intSmallestExtraMarkArea[m_intTemplateIndex])
//                                    //    m_intSmallestExtraMarkArea[m_intTemplateIndex] = intArea;

//                                    if ((m_intFailResultMask & 0x02) == 0)
//                                        m_intFailResultMask |= 0x02;
//                                }

//                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 55");
//                            }
//                            else
//                            {
//                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 56");
//                                // Make sure area >= min area
//                                if (intArea < m_intMinArea)
//                                {
//                                    continue;
//                                }

//                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 57");
//                                // Set char hit by blob counter
//                                for (j = 0; j < intMatchNumber.Count; j++)
//                                {
//                                    m_intHitCharCounter[intMatchNumber[j]]++;
//                                }

//                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 58");
//                                for (j = 0; j < intMatchNumber.Count; j++)
//                                {
//                                    if (arrExcessStartX[intMatchNumber[j]] == -1)
//                                    {
//                                        arrExcessStartX[intMatchNumber[j]] = fStartX;
//                                    }
//                                    else
//                                    {
//                                        if (arrExcessStartX[intMatchNumber[j]] > fStartX)
//                                            arrExcessStartX[intMatchNumber[j]] = fStartX;
//                                    }

//                                    if (arrExcessStartY[intMatchNumber[j]] == -1)
//                                    {
//                                        arrExcessStartY[intMatchNumber[j]] = fStartY;
//                                    }
//                                    else
//                                    {
//                                        if (arrExcessStartY[intMatchNumber[j]] > fStartY)
//                                            arrExcessStartY[intMatchNumber[j]] = fStartY;
//                                    }

//                                    if (arrExcessEndX[intMatchNumber[j]] == -1)
//                                    {
//                                        arrExcessEndX[intMatchNumber[j]] = fEndX;
//                                    }
//                                    else
//                                    {
//                                        if (arrExcessEndX[intMatchNumber[j]] < fEndX)
//                                            arrExcessEndX[intMatchNumber[j]] = fEndX;
//                                    }

//                                    if (arrExcessEndY[intMatchNumber[j]] == -1)
//                                    {
//                                        arrExcessEndY[intMatchNumber[j]] = fEndY;
//                                    }
//                                    else
//                                    {
//                                        if (arrExcessEndY[intMatchNumber[j]] < fEndY)
//                                            arrExcessEndY[intMatchNumber[j]] = fEndY;
//                                    }
//                                }

//                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 59");
//                                // Check joint mark (1 blob match to more than 1 char)
//                                if (intMatchNumber.Count > 1)
//                                {
//                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 60");
//                                    //if ((intFailOptionMask & 0x80) > 0)
//                                    //{
//                                    //    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 61");
//                                    //    int intDisabledMarkCounter = 0;
//                                    //    int intEnabledMarkCounter = 0;
//                                    //    for (int q = 0; q < intMatchNumber.Count; q++)
//                                    //    {
//                                    //        if (!m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[intMatchNumber[q]])
//                                    //            intDisabledMarkCounter++;
//                                    //        else
//                                    //            intEnabledMarkCounter++;
//                                    //    }

//                                    //    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 63");

//                                    //    if (intDisabledMarkCounter > 1 && intEnabledMarkCounter < intDisabledMarkCounter || intEnabledMarkCounter <= 1)
//                                    //        goto Skip;

//                                    //    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 64");
//                                    //    m_intBlobResult[m_intTemplateIndex][i] = 2;

//                                    //    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 65");
//                                    //    for (int q = 0; q < intMatchNumber.Count; q++)
//                                    //        m_blnCharResult[m_intTemplateIndex][intMatchNumber[q]] = false;

//                                    //    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 66");
//                                    //    if ((m_intFailResultMask & 0x80) == 0)
//                                    //        m_intFailResultMask |= 0x80;
//                                    //}

//                                    //if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 67");
//                                    //Skip: { }

//                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 68");
//                                }
//                                else if (intMatchNumber.Count == 1)
//                                {
//                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 69");
//                                    // 2018 11 27 - CCENG: Use missing mark to check broken mark will be better.
//                                    //// Check Broken Mark (based on size)
//                                    //int intWidth = 0, intHeight = 0;
//                                    //objOCV.GetCharSize(intMatchNumber[0], ref intWidth, ref intHeight);

//                                    //if ((intFailOptionMask & 0x20) > 0)
//                                    //{
//                                    //    if (fWidth < (intWidth - objTemplateSetting.intBrokenSize))
//                                    //    {
//                                    //        m_fGroupBrokenMarkLength[m_intTemplateIndex] = intWidth - fWidth;
//                                    //        m_intBlobResult[m_intTemplateIndex][i] = 2;

//                                    //        m_blnCharResult[m_intTemplateIndex][intMatchNumber[0]] = false;

//                                    //        if ((m_intFailResultMask & 0x20) == 0)
//                                    //            m_intFailResultMask |= 0x20;
//                                    //    }
//                                    //    else if (fHeight < (intHeight - objTemplateSetting.intBrokenSize))
//                                    //    {
//                                    //        m_fGroupBrokenMarkLength[m_intTemplateIndex] = intHeight - fHeight;
//                                    //        m_intBlobResult[m_intTemplateIndex][i] = 2;

//                                    //        m_blnCharResult[m_intTemplateIndex][intMatchNumber[0]] = false;

//                                    //        if ((m_intFailResultMask & 0x20) == 0)
//                                    //            m_intFailResultMask |= 0x20;
//                                    //    }
//                                    //}
//                                }
//                            }
//                        }

//                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 70");

//                        for (int i = 0; i < intNumChars; i++)
//                        {
//                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 71");

//                            // 2019 06 07 - CCENG: Check missing character using subtraction, but not use the m_intHitCharCounter. 
//                            //// Check Missing Mark 
//                            //if ((intFailOptionMask & 0x10) > 0)
//                            //{
//                            //    if (m_intHitCharCounter[i] == 0)
//                            //    {
//                            //        m_blnCharResult[m_intTemplateIndex][i] = false;

//                            //        if ((m_intFailResultMask & 0x10) == 0)
//                            //            m_intFailResultMask |= 0x10;
//                            //    }
//                            //}

//                            // 2018 11 19 - CCENG: Use missing mark to check broken mark will be better.
//                            // Check Broken Mark (Based on quantity blobs in char area)
//                            //if ((intFailOptionMask & 0x20) > 0)
//                            //{
//                            //    if (m_intHitCharCounter[i] > 1)
//                            //    {
//                            //        m_blnCharResult[m_intTemplateIndex][i] = false;

//                            //        if ((m_intFailResultMask & 0x20) == 0)
//                            //            m_intFailResultMask |= 0x20;
//                            //    }
//                            //}
//                        }

//                        #endregion ----------------------------------------------------------------------------------------------------------
//                        //2021-01-02 ZJYEOH : Broken mark use new method
//                        if ((intFailOptionMask & 0x20) > 0 && blnWantCheckBrokenMark)
//                        {
//                            // Copy rotated image to sample image
//                            objImage.CopyTo(ref m_objSampleImage);//objOcvRotatedImage
//                            ImageDrawing objSampleImage_Temp = new ImageDrawing(true, m_objSampleImage.ref_intImageWidth, m_objSampleImage.ref_intImageHeight);
//                            objImage.CopyTo(ref objSampleImage_Temp);//objOcvRotatedImage
//                            ImageDrawing objSampleImage_Temp2 = new ImageDrawing(true, m_objSampleImage.ref_intImageWidth, m_objSampleImage.ref_intImageHeight);
//                            objImage.CopyTo(ref objSampleImage_Temp2);//objOcvRotatedImage
//                            ROI objSubtractCharROI = new ROI();
//                            objSubtractCharROI.AttachImage(m_objSampleImage);

//                            if (blnWantDebug)
//                            {
//                                m_objSampleImage.SaveImage("D:\\TS\\20.m_objSampleImage.bmp");

//                            }

//                            System.Drawing.Point pStart, pEnd;
//                            List<ROI> arrTemplateCharErodeROI = new List<ROI>();

//                            int intNumChars2 = objOCV.GetNumChars();

//                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 111");

//                            //List<float> arrMarkStartX = new List<float>();
//                            //List<float> arrMarkStartY = new List<float>();
//                            //List<float> arrMarkEndX = new List<float>();
//                            //List<float> arrMarkEndY = new List<float>();

//                            if (m_arrCharBrokenMarkResult[m_intTemplateIndex] == null)
//                                m_arrCharBrokenMarkResult[m_intTemplateIndex] = new bool[intNumChars];

//                            if (m_arrCharBrokenMarkResult[m_intTemplateIndex].Length != intNumChars)
//                                m_arrCharBrokenMarkResult[m_intTemplateIndex] = new bool[intNumChars];

//                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 112");
//                            for (int a = 0; a < intNumChars; a++)
//                            {
//                                m_arrCharBrokenMarkResult[m_intTemplateIndex][a] = true;
//                            }

//                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 113");

//                            for (int i = 0; i < intNumChars2; i++)
//                            {
//                                if (!m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrWantBrokenMark[i])
//                                {
//                                    // 2021 01 05 - CCENG: need to add into array also to prevent out of index
//                                    arrTemplateCharErodeROI.Add(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrTemplateCharErodeROI[i]);
//                                    continue;
//                                }

//                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 114");

//                                arrTemplateCharErodeROI.Add(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrTemplateCharErodeROI[i]);
//#if (Debug_2_12 || Release_2_12)
//                                EasyImage.Threshold(arrTemplateCharErodeROI[i].ref_ROI, arrTemplateCharErodeROI[i].ref_ROI, (uint)intThresholdValue);
//#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)

//                                EasyImage.Threshold(arrTemplateCharErodeROI[i].ref_ROI, arrTemplateCharErodeROI[i].ref_ROI, intThresholdValue);
//#endif
//                                pStart = objOCV.GetCharStartXY(i);
//                                pEnd = objOCV.GetCharEndXY(i);

//                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 115");

//                                float fMinAddSizeX = (float)(arrTemplateCharErodeROI[i].ref_ROIWidth - (pEnd.X - pStart.X)) / 2;
//                                float fMinAddSizeY = (float)(arrTemplateCharErodeROI[i].ref_ROIHeight - (pEnd.Y - pStart.Y)) / 2;

//                                int intMinAddSizeStartX, intMinAddSizeStartY, intMinAddSizeEndX, intMinAddSizeEndY;
//                                if (fMinAddSizeX == (int)fMinAddSizeX)
//                                {
//                                    intMinAddSizeStartX = (int)fMinAddSizeX;
//                                    intMinAddSizeEndX = (int)fMinAddSizeX;
//                                }
//                                else
//                                {
//                                    intMinAddSizeStartX = (int)Math.Ceiling(fMinAddSizeX);
//                                    intMinAddSizeEndX = (int)Math.Floor(fMinAddSizeX);
//                                }

//                                if (fMinAddSizeY == (int)fMinAddSizeY)
//                                {
//                                    intMinAddSizeStartY = (int)fMinAddSizeY;
//                                    intMinAddSizeEndY = (int)fMinAddSizeY;
//                                }
//                                else
//                                {
//                                    intMinAddSizeStartY = (int)Math.Ceiling(fMinAddSizeY);
//                                    intMinAddSizeEndY = (int)Math.Floor(fMinAddSizeY);
//                                }

//                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 116");

//                                ROI objSampleCharROI = new ROI();

//                                if ((m_intROIOffSetX + pStart.X - intMinAddSizeStartX) >= 0) //if ((pStart.X - intMinAddSizeStartX) >= 0)   // 2019 10 11 - CCENG: add m_intROIOffSetXY because objSampleCharROI attach to main Image.
//                                    objSampleCharROI.ref_ROIPositionX = m_intROIOffSetX + pStart.X - intMinAddSizeStartX;
//                                else
//                                    objSampleCharROI.ref_ROIPositionX = m_intROIOffSetX;

//                                if ((m_intROIOffSetY + pStart.Y - intMinAddSizeStartY) >= 0)  //if ((pStart.Y - intMinAddSizeStartY) >= 0)  // 2019 10 11 - CCENG: add m_intROIOffSetXY because objSampleCharROI attach to main Image.
//                                    objSampleCharROI.ref_ROIPositionY = m_intROIOffSetY + pStart.Y - intMinAddSizeStartY;
//                                else
//                                    objSampleCharROI.ref_ROIPositionY = m_intROIOffSetY;

//                                if ((pEnd.X + intMinAddSizeEndX * 2) < m_intImageWidth)
//                                    objSampleCharROI.ref_ROIWidth = pEnd.X - pStart.X + intMinAddSizeStartX + intMinAddSizeEndX;
//                                else
//                                    continue;
//                                if ((pEnd.Y + intMinAddSizeEndY * 2) < m_intImageHeight)
//                                    objSampleCharROI.ref_ROIHeight = pEnd.Y - pStart.Y + intMinAddSizeStartY + intMinAddSizeEndY;
//                                else
//                                    continue;

//                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 117");

//                                // 2020 03 01 - CCENG: Attached to m_objSampleImage because objSampleCharROI will be Dilated when m_intMissingMarkInspectionMethod is 1. 
//                                //                   : Also Dilate and subtract's image source and destination can be same.          
//                                //objSampleCharROI.AttachImage(objImage);

//                                //2020-06-17 ZJYEOH : objSampleCharROI should attach another image as m_objSampleImage will be image processsed
//                                objSampleCharROI.AttachImage(objSampleImage_Temp);//m_objSampleImage

//                                objSubtractCharROI.LoadROISetting(objSampleCharROI.ref_ROIPositionX, objSampleCharROI.ref_ROIPositionY,
//                                                                    objSampleCharROI.ref_ROIWidth, objSampleCharROI.ref_ROIHeight);

//                                if ((objSampleCharROI.ref_ROIWidth != arrTemplateCharErodeROI[i].ref_ROIWidth) ||
//                                    (arrTemplateCharErodeROI[i].ref_ROIWidth != objSubtractCharROI.ref_ROIWidth))
//                                    continue;

//                                if ((objSampleCharROI.ref_ROIHeight != arrTemplateCharErodeROI[i].ref_ROIHeight) ||
//                                    (arrTemplateCharErodeROI[i].ref_ROIHeight != objSubtractCharROI.ref_ROIHeight))
//                                    continue;

//                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 118");

//                                //arrMarkStartX.Add(objSubtractCharROI.ref_ROIPositionX - m_intROIOffSetX);
//                                //arrMarkStartY.Add(objSubtractCharROI.ref_ROIPositionY - m_intROIOffSetY);
//                                //arrMarkEndX.Add(objSubtractCharROI.ref_ROIPositionX + objSubtractCharROI.ref_ROIWidth - m_intROIOffSetX);
//                                //arrMarkEndY.Add(objSubtractCharROI.ref_ROIPositionY + objSubtractCharROI.ref_ROIHeight - m_intROIOffSetY);

//                                if (!m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i] || !CheckWantInspectBrokenMark(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMarkType[i]))
//                                {
//                                    EasyImage.Oper(EArithmeticLogicOperation.Subtract, arrTemplateCharErodeROI[i].ref_ROI, arrTemplateCharErodeROI[i].ref_ROI, objSubtractCharROI.ref_ROI);
//                                }
//                                else
//                                {

//#if (Debug_2_12 || Release_2_12)
//                                    EasyImage.Threshold(objSampleCharROI.ref_ROI, objSampleCharROI.ref_ROI, (uint)intThresholdValue);
//#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)

//                                    EasyImage.Threshold(objSampleCharROI.ref_ROI, objSampleCharROI.ref_ROI, intThresholdValue);
//#endif
//                                    //2020-06-17 ZJYEOH : Image processing will be different for white on black and black one white

//                                    if (m_blnWhiteOnBlack)
//                                    {
//                                        ROI.InvertOperationROI(arrTemplateCharErodeROI[i]);
//                                        EasyImage.Oper(EArithmeticLogicOperation.Subtract, objSampleCharROI.ref_ROI, arrTemplateCharErodeROI[i].ref_ROI, objSubtractCharROI.ref_ROI);
//                                        //2020-06-17 ZJYEOH : Invert back so that arrTemplateCharErodeROI[i] will not inverted if it is used again because inverted area may overlap another mark
//                                        ROI.InvertOperationROI(arrTemplateCharErodeROI[i]);
//                                    }
//                                    else
//                                    {
//                                        //ROI.InvertOperationROI(objSampleCharROI);
//                                        EasyImage.Oper(EArithmeticLogicOperation.Add, arrTemplateCharErodeROI[i].ref_ROI, objSampleCharROI.ref_ROI, objSubtractCharROI.ref_ROI);
//                                        ////2020-06-17 ZJYEOH : Invert back so that objSampleCharROI will not inverted if it is used again because inverted area may overlap another mark
//                                        //ROI.InvertOperationROI(objSampleCharROI);
//                                    }

//                                }

//                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 119");

//                                if (blnWantDebug)
//                                {
//                                    arrTemplateCharErodeROI[i].SaveImage("D:\\TS\\34.arrTemplateCharErodeROI[i]" + i.ToString() + ".bmp");
//                                    objSampleCharROI.SaveImage("D:\\TS\\35.objSampleCharROI" + i.ToString() + ".bmp");
//                                    objSubtractCharROI.SaveImage("D:\\TS\\36.objSubtractCharROI" + i.ToString() + ".bmp");
//                                    m_objSampleImage.SaveImage("D:\\TS\\37.m_objSampleImage" + i.ToString() + ".bmp");
//                                }

//                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 120");
//#if (Debug_2_12 || Release_2_12)
//                                if (m_intEnhanceMark_LinkMark_HalfWidth > 0)
//                                {
//                                    if (m_blnWhiteOnBlack)
//                                        EasyImage.CloseBox(objSubtractCharROI.ref_ROI, objSubtractCharROI.ref_ROI, (uint)m_intEnhanceMark_LinkMark_HalfWidth);
//                                    else
//                                        EasyImage.OpenBox(objSubtractCharROI.ref_ROI, objSubtractCharROI.ref_ROI, (uint)m_intEnhanceMark_LinkMark_HalfWidth);
//                                }

//                                if (m_intEnhanceMark_ReduceNoise_HalfWidth > 0)
//                                {
//                                    if (m_blnWhiteOnBlack)
//                                        EasyImage.OpenBox(objSubtractCharROI.ref_ROI, objSubtractCharROI.ref_ROI, (uint)m_intEnhanceMark_ReduceNoise_HalfWidth);
//                                    else
//                                        EasyImage.CloseBox(objSubtractCharROI.ref_ROI, objSubtractCharROI.ref_ROI, (uint)m_intEnhanceMark_ReduceNoise_HalfWidth);
//                                }
//#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
//                                   if (m_intEnhanceMark_LinkMark_HalfWidth > 0)
//                                {
//                                    if (m_blnWhiteOnBlack)
//                                        EasyImage.CloseBox(objSubtractCharROI.ref_ROI, objSubtractCharROI.ref_ROI, m_intEnhanceMark_LinkMark_HalfWidth);
//                                    else
//                                        EasyImage.OpenBox(objSubtractCharROI.ref_ROI, objSubtractCharROI.ref_ROI, m_intEnhanceMark_LinkMark_HalfWidth);
//                                }

//                                if (m_intEnhanceMark_ReduceNoise_HalfWidth > 0)
//                                {
//                                    if (m_blnWhiteOnBlack)
//                                        EasyImage.OpenBox(objSubtractCharROI.ref_ROI, objSubtractCharROI.ref_ROI, m_intEnhanceMark_ReduceNoise_HalfWidth);
//                                    else
//                                        EasyImage.CloseBox(objSubtractCharROI.ref_ROI, objSubtractCharROI.ref_ROI, m_intEnhanceMark_ReduceNoise_HalfWidth);
//                                }
//#endif
//                                if (m_objBrokenBlobs[m_intTemplateIndex] == null)
//                                    m_objBrokenBlobs[m_intTemplateIndex] = new EBlobs();
//                                else
//                                    m_objBrokenBlobs[m_intTemplateIndex].CleanAllBlobs();

//                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 123");
//                                if (blnWantDebug)
//                                {
//                                    objSubtractCharROI.SaveImage("D:\\TS\\42.objSubtractCharROI.bmp");
//                                }

//                                //2020-06-17 ZJYEOH : Threshold will invert for white on black
//                                int intMissingThreshold = intThresholdValue;
//                                if (m_blnWhiteOnBlack)
//                                {
//                                    intMissingThreshold = intThresholdValue;
//                                }


//                                if (BuildObject(m_objBrokenBlobs[m_intTemplateIndex], objSubtractCharROI, false, true, intMissingThreshold, m_intMinArea, 1000000, 0x1F)) //255 - intThresholdValue
//                                {
//                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 124");
//                                    int intNoBlobs = m_objBrokenBlobs[m_intTemplateIndex].ref_intNumSelectedObject;

//                                    if (intNoBlobs > 1)
//                                    {
//                                        // 2021 01 05 - m_blnCharResult is for score result, not for broken mark
//                                        //if (m_blnCharResult[m_intTemplateIndex][i])
//                                        //    m_blnCharResult[m_intTemplateIndex][i] = false;

//                                        if (m_arrCharBrokenMarkResult[m_intTemplateIndex][i])
//                                            m_arrCharBrokenMarkResult[m_intTemplateIndex][i] = false;

//                                        if ((m_intFailResultMask & 0x20) == 0)
//                                            m_intFailResultMask |= 0x20;
//                                    }
//                                }

//                                objSampleCharROI.Dispose();
//                            }

//                            objSampleImage_Temp.Dispose();
//                            objSampleImage_Temp2.Dispose();
//                            objSubtractCharROI.Dispose();
//                        }

//                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 72");

//                        #region ----------- Check Excess mark and Missing Mark in characters area using substract function and grey value ---------------------
//                        // If text score does not fail
//                        if ((m_intFailResultMask & 0x200) == 0)
//                        {
//                            //-------------------------------------- Check Excess mark in characters area ---------------------------------------//
//                            if (((intFailOptionMask & 0x01) > 0) || (((intFailOptionMask & 0x100) > 0) && m_blnWantCheckTotalExcessMark)) // Excess Mark Char Area is ON
//                            {
//                                //if ((m_intFailResultMask & 0x08) == 0)      // 2019 06 28 - Check Excess Mark only if no Group extra mark failure. Because excess inpsection take quite long time and if too many extra makr, it will take too long time for isnpection.
//                                {
//                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 73");
//                                    // Copy rotated image to sample image
//                                    //ImageDrawing objSampleImage = new ImageDrawing();
//                                    if (blnWantDebug)
//                                    {
//                                        objOcvRotatedImage.SaveImage("D:\\TS\\10.objOcvRotatedImage.bmp");
//                                    }

//                                    //objOcvRotatedImage.CopyTo(ref m_objSampleImage);
//                                    if (m_blnWantDontCareArea)
//                                        m_objDontCareBackupImage.CopyTo(ref m_objSampleImage);
//                                    else
//                                        objImage.CopyTo(ref m_objSampleImage);

//                                    ROI objSubtractCharROI = new ROI();

//                                    ImageDrawing objSubtractImage_Temp = new ImageDrawing(true, m_objSampleImage.ref_intImageWidth, m_objSampleImage.ref_intImageHeight);
//                                    if (m_intExtraExcessMarkInspectionAreaCutMode != 0)
//                                    {
//                                        if (m_blnWhiteOnBlack)
//                                            objBlackImage.CopyTo(ref objSubtractImage_Temp);
//                                        else
//                                            objWhiteImage.CopyTo(ref objSubtractImage_Temp);
//                                        objSubtractCharROI.AttachImage(objSubtractImage_Temp);
//                                    }
//                                    else
//                                        objSubtractCharROI.AttachImage(m_objSampleImage);

//                                    if (m_blnWantDontCareArea)
//                                    {
//                                        objSubtractCharROI.LoadROISetting(objMarkPackageMarkROI.ref_ROITotalX, objMarkPackageMarkROI.ref_ROITotalY, objMarkPackageMarkROI.ref_ROIWidth, objMarkPackageMarkROI.ref_ROIHeight);

//                                        ROI objDontCareROI = new ROI();
//                                        //objDontCareROI.LoadROISetting(0, 0, objMarkPackageMarkROI.ref_ROIWidth, objMarkPackageMarkROI.ref_ROIHeight);
//                                        //objDontCareROI.AttachImage(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].objDontCareImage);
//                                        ////2020-06-17 ZJYEOH : Subtract or Add depends on white on black or black on white
//                                        //if (m_blnWhiteOnBlack)
//                                        //    ROI.SubtractROI(objSubtractCharROI, objDontCareROI);
//                                        //else
//                                        //    ROI.LogicOperationAddROI(objSubtractCharROI, objDontCareROI);
//                                        ROI objOriROI = new ROI();
//                                        for (int i = 0; i < arrMarkDontCareROI.Count; i++)
//                                        {
//                                            objOriROI.AttachImage(m_objSampleImage);

//                                            objDontCareROI.AttachImage(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrDontCareImage[i]);// objWhiteImage

//                                            objOriROI.LoadROISetting(objMarkPackageMarkROI.ref_ROITotalCenterX - arrMarkDontCareROI[i].ref_intStartOffsetX,
//                                                                     objMarkPackageMarkROI.ref_ROITotalCenterY - arrMarkDontCareROI[i].ref_intStartOffsetY,
//                                                                     arrMarkDontCareROI[i].ref_ROIWidth, arrMarkDontCareROI[i].ref_ROIHeight);

//                                            objDontCareROI.LoadROISetting(objMarkPackageMarkROI.ref_ROITotalCenterX - arrMarkDontCareROI[i].ref_intStartOffsetX,
//                                                                          objMarkPackageMarkROI.ref_ROITotalCenterY - arrMarkDontCareROI[i].ref_intStartOffsetY,
//                                                                          arrMarkDontCareROI[i].ref_ROIWidth, arrMarkDontCareROI[i].ref_ROIHeight);

//                                            if (m_blnWhiteOnBlack)
//                                                ROI.SubtractROI(objOriROI, objDontCareROI);
//                                            else
//                                                ROI.LogicOperationAddROI(objOriROI, objDontCareROI);
//                                            //m_objSampleImage.SaveImage("D:\\m_objSampleImage.bmp");
//                                            //objSubtractCharROI.SaveImage("D:\\objSubtractCharROI" + i.ToString() + ".bmp");
//                                            //objMarkPackageMarkROI.SaveImage("D:\\objMarkPackageMarkROI" + i.ToString() + ".bmp");
//                                        }
//                                        objOriROI.Dispose();
//                                        objDontCareROI.Dispose();

//                                        if (blnWantDebug)
//                                        {
//                                            m_objSampleImage.SaveImage("D:\\TS\\11.m_objSampleImage_AfterDontCare.bmp");
//                                        }

//                                    }

//                                    System.Drawing.Point pStart, pEnd;
//                                    List<ROI> arrTemplateCharDilateROI = new List<ROI>();
//                                    List<float> arrTemplateStartX = new List<float>();
//                                    List<float> arrTemplateStartY = new List<float>();
//                                    List<float> arrTemplateEndX = new List<float>();
//                                    List<float> arrTemplateEndY = new List<float>();
//                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 74");
//                                    for (int i = 0; i < intNumChars; i++)
//                                    {

//                                        //// 2020-08-11 ZJYEOH : Skip Check Excess if mark is disabled
//                                        //if (!m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i])
//                                        //    continue;

//                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 75");
//                                        arrTemplateCharDilateROI.Add(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrTemplateCharDilateROI[i]);
//#if (Debug_2_12 || Release_2_12)
//                                        EasyImage.Threshold(arrTemplateCharDilateROI[i].ref_ROI, arrTemplateCharDilateROI[i].ref_ROI, (uint)intThresholdValue);
//#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
//                                        EasyImage.Threshold(arrTemplateCharDilateROI[i].ref_ROI, arrTemplateCharDilateROI[i].ref_ROI, intThresholdValue);
//#endif

//                                        pStart = objOCV.GetCharStartXY(i);
//                                        pEnd = objOCV.GetCharEndXY(i);

//                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 76");
//                                        float fMinAddSizeX = (float)(arrTemplateCharDilateROI[i].ref_ROIWidth - (pEnd.X - pStart.X)) / 2;
//                                        float fMinAddSizeY = (float)(arrTemplateCharDilateROI[i].ref_ROIHeight - (pEnd.Y - pStart.Y)) / 2;

//                                        int intMinAddSizeStartX, intMinAddSizeStartY, intMinAddSizeEndX, intMinAddSizeEndY;
//                                        if (fMinAddSizeX == (int)fMinAddSizeX)
//                                        {
//                                            intMinAddSizeStartX = (int)fMinAddSizeX;
//                                            intMinAddSizeEndX = (int)fMinAddSizeX;
//                                        }
//                                        else
//                                        {
//                                            intMinAddSizeStartX = (int)Math.Ceiling(fMinAddSizeX);
//                                            intMinAddSizeEndX = (int)Math.Floor(fMinAddSizeX);
//                                        }

//                                        if (fMinAddSizeY == (int)fMinAddSizeY)
//                                        {
//                                            intMinAddSizeStartY = (int)fMinAddSizeY;
//                                            intMinAddSizeEndY = (int)fMinAddSizeY;
//                                        }
//                                        else
//                                        {
//                                            intMinAddSizeStartY = (int)Math.Ceiling(fMinAddSizeY);
//                                            intMinAddSizeEndY = (int)Math.Floor(fMinAddSizeY);
//                                        }

//                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 77");
//                                        ROI objSampleCharROI = new ROI();

//                                        if (m_blnWantDontCareIgnoredMarkWholeArea && !m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i] || !CheckWantInspectExcessMark(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMarkType[i]))
//                                        {
//                                            //2021-01-18 ZJYEOH : Should use sample position
//                                            Point pStartTemplate = pStart;//new Point(arrTemplateCharDilateROI[i].ref_ROIPositionX, arrTemplateCharDilateROI[i].ref_ROIPositionY);
//                                            Point pEndTemplate = pEnd;//new Point(arrTemplateCharDilateROI[i].ref_ROIPositionX + arrTemplateCharDilateROI[i].ref_ROIWidth, arrTemplateCharDilateROI[i].ref_ROIPositionY + arrTemplateCharDilateROI[i].ref_ROIHeight);

//                                            if ((m_intROIOffSetX + pStartTemplate.X - ((int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftX[i] + m_fCharROIOffsetX))) >= 0)
//                                                objSampleCharROI.ref_ROIPositionX = m_intROIOffSetX + pStartTemplate.X - ((int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftX[i] + m_fCharROIOffsetX));
//                                            else
//                                                objSampleCharROI.ref_ROIPositionX = m_intROIOffSetX;

//                                            if ((m_intROIOffSetY + pStartTemplate.Y - ((int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftY[i] + m_fCharROIOffsetY))) >= 0)
//                                                objSampleCharROI.ref_ROIPositionY = m_intROIOffSetY + pStartTemplate.Y - ((int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftY[i] + m_fCharROIOffsetY));
//                                            else
//                                                objSampleCharROI.ref_ROIPositionY = m_intROIOffSetY;

//                                            if ((m_intROIOffSetX + pEndTemplate.X + ((int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftX[i] + m_fCharROIOffsetX))) < m_intImageWidth)
//                                                objSampleCharROI.ref_ROIWidth = pEndTemplate.X - pStartTemplate.X + ((int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftX[i] + m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftX[i] + m_fCharROIOffsetX + m_fCharROIOffsetX));
//                                            else
//                                                continue;
//                                            if ((m_intROIOffSetY + pEndTemplate.Y + ((int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftY[i] + m_fCharROIOffsetY))) < m_intImageHeight)
//                                                objSampleCharROI.ref_ROIHeight = pEndTemplate.Y - pStartTemplate.Y + ((int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftY[i] + m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftY[i] + m_fCharROIOffsetY + m_fCharROIOffsetY));
//                                            else
//                                                continue;
//                                        }
//                                        else
//                                        {
//                                            if ((m_intROIOffSetX + pStart.X - intMinAddSizeStartX) >= 0) //if ((pStart.X - intMinAddSizeStartX) >= 0)   // 2019 10 11 - CCENG: add m_intROIOffSetXY because objSampleCharROI attach to main Image.
//                                                objSampleCharROI.ref_ROIPositionX = m_intROIOffSetX + pStart.X - intMinAddSizeStartX;
//                                            else
//                                                objSampleCharROI.ref_ROIPositionX = m_intROIOffSetX;

//                                            if ((m_intROIOffSetY + pStart.Y - intMinAddSizeStartY) >= 0)  //if ((pStart.Y - intMinAddSizeStartY) >= 0)  // 2019 10 11 - CCENG: add m_intROIOffSetXY because objSampleCharROI attach to main Image.
//                                                objSampleCharROI.ref_ROIPositionY = m_intROIOffSetY + pStart.Y - intMinAddSizeStartY;
//                                            else
//                                                objSampleCharROI.ref_ROIPositionY = m_intROIOffSetY;

//                                            if ((pEnd.X + intMinAddSizeEndX * 2) < m_intImageWidth)
//                                                objSampleCharROI.ref_ROIWidth = pEnd.X - pStart.X + intMinAddSizeStartX + intMinAddSizeEndX;
//                                            else
//                                                continue;
//                                            if ((pEnd.Y + intMinAddSizeEndY * 2) < m_intImageHeight)
//                                                objSampleCharROI.ref_ROIHeight = pEnd.Y - pStart.Y + intMinAddSizeStartY + intMinAddSizeEndY;
//                                            else
//                                                continue;
//                                        }

//                                        objSampleCharROI.AttachImage(m_objSampleImage);//objOcvRotatedImage

//                                        objSubtractCharROI.LoadROISetting(objSampleCharROI.ref_ROIPositionX, objSampleCharROI.ref_ROIPositionY,
//                                                                            objSampleCharROI.ref_ROIWidth, objSampleCharROI.ref_ROIHeight);

//                                        arrTemplateStartX.Add(objSampleCharROI.ref_ROIPositionX - m_intROIOffSetX);
//                                        arrTemplateStartY.Add(objSampleCharROI.ref_ROIPositionY - m_intROIOffSetY);
//                                        arrTemplateEndX.Add(objSampleCharROI.ref_ROIPositionX + objSampleCharROI.ref_ROIWidth - m_intROIOffSetX);
//                                        arrTemplateEndY.Add(objSampleCharROI.ref_ROIPositionY + objSampleCharROI.ref_ROIHeight - m_intROIOffSetY);

//                                        if (!m_blnWantDontCareIgnoredMarkWholeArea)
//                                        {
//                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 78");
//                                            if ((objSampleCharROI.ref_ROIWidth != arrTemplateCharDilateROI[i].ref_ROIWidth) ||
//                                                (arrTemplateCharDilateROI[i].ref_ROIWidth != objSubtractCharROI.ref_ROIWidth))
//                                                continue;

//                                            if ((objSampleCharROI.ref_ROIHeight != arrTemplateCharDilateROI[i].ref_ROIHeight) ||
//                                                (arrTemplateCharDilateROI[i].ref_ROIHeight != objSubtractCharROI.ref_ROIHeight))
//                                                continue;
//                                        }

//                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 79");
//                                        if (m_intExtraExcessMarkInspectionAreaCutMode != 0)
//                                        {
//                                            if (!m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i] || !CheckWantInspectExcessMark(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMarkType[i]))
//                                            {
//                                                //ROI.InvertOperationROI(objSubtractCharROI);
//                                                EasyImage.Oper(EArithmeticLogicOperation.Add, objSubtractCharROI.ref_ROI, new EBW8(255), objSubtractCharROI.ref_ROI);
//                                            }
//                                            else
//                                            {
//                                                //2020-06-17 ZJYEOH : Image processing will be different for white on black and black one white
//                                                if (m_blnWhiteOnBlack)
//                                                {
//                                                    EasyImage.Oper(EArithmeticLogicOperation.Add, objSubtractCharROI.ref_ROI, arrTemplateCharDilateROI[i].ref_ROI, objSubtractCharROI.ref_ROI);
//                                                }
//                                                else
//                                                {
//                                                    //EasyImage.Oper(EArithmeticLogicOperation.Invert, arrTemplateCharDilateROI[i].ref_ROI, arrTemplateCharDilateROI[i].ref_ROI);
//                                                    //ROI.InvertOperationROI(arrTemplateCharDilateROI[i]);
//                                                    EasyImage.Oper(EArithmeticLogicOperation.Subtract, objSubtractCharROI.ref_ROI, arrTemplateCharDilateROI[i].ref_ROI, objSubtractCharROI.ref_ROI);
//                                                    //EasyImage.Oper(EArithmeticLogicOperation.Invert, arrTemplateCharDilateROI[i].ref_ROI, arrTemplateCharDilateROI[i].ref_ROI);
//                                                    //ROI.InvertOperationROI(arrTemplateCharDilateROI[i]);
//                                                }

//                                            }
//                                        }
//                                        else
//                                        {
//                                            if (!m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i] || !CheckWantInspectExcessMark(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMarkType[i]))
//                                            {
//                                                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objSampleCharROI.ref_ROI, objSampleCharROI.ref_ROI, objSubtractCharROI.ref_ROI);
//                                            }
//                                            else
//                                            {
//                                                //2020-06-17 ZJYEOH : Image processing will be different for white on black and black one white
//                                                if (m_blnWhiteOnBlack)
//                                                {
//                                                    EasyImage.Oper(EArithmeticLogicOperation.Subtract, objSampleCharROI.ref_ROI, arrTemplateCharDilateROI[i].ref_ROI, objSubtractCharROI.ref_ROI);
//                                                }
//                                                else
//                                                {
//                                                    //EasyImage.Oper(EArithmeticLogicOperation.Invert, arrTemplateCharDilateROI[i].ref_ROI, arrTemplateCharDilateROI[i].ref_ROI);
//                                                    ROI.InvertOperationROI(arrTemplateCharDilateROI[i]);
//                                                    EasyImage.Oper(EArithmeticLogicOperation.Add, objSampleCharROI.ref_ROI, arrTemplateCharDilateROI[i].ref_ROI, objSubtractCharROI.ref_ROI);
//                                                    //EasyImage.Oper(EArithmeticLogicOperation.Invert, arrTemplateCharDilateROI[i].ref_ROI, arrTemplateCharDilateROI[i].ref_ROI);
//                                                    ROI.InvertOperationROI(arrTemplateCharDilateROI[i]);
//                                                }

//                                            }
//                                        }

//                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 80");

//                                        if (blnWantDebug)
//                                        {
//                                            objSampleCharROI.SaveImage("D:\\TS\\13.objSampleCharROI" + i.ToString() + ".bmp");
//                                            arrTemplateCharDilateROI[i].SaveImage("D:\\TS\\14.arrTemplateCharDilateROI[i]" + i.ToString() + ".bmp");
//                                            objSubtractCharROI.SaveImage("D:\\TS\\15.objSubtractCharROI" + i.ToString() + ".bmp");
//                                            m_objSampleImage.SaveImage("D:\\TS\\16.m_objSampleImage" + i.ToString() + ".bmp");
//                                        }

//                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 81");

//                                        objSampleCharROI.Dispose();
//                                    }

//                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 83");
//                                    if (blnWantDebug)
//                                    {
//                                        m_objSampleImage.SaveImage("D:\\TS\\17m_objSampleImage.bmp");
//                                    }

//                                    if (m_intExtraExcessMarkInspectionAreaCutMode != 0)
//                                        objSubtractCharROI.AttachImage(objSubtractImage_Temp);
//                                    else
//                                        objSubtractCharROI.AttachImage(m_objSampleImage);

//                                    // Reload ROI size and placement to same location and same size as Mark ROI
//                                    objSubtractCharROI.LoadROISetting(m_intROIOffSetX, m_intROIOffSetY, objMarkPackageMarkROI.ref_ROIWidth, objMarkPackageMarkROI.ref_ROIHeight);

//                                    if (blnWantDebug)
//                                    {
//                                        objSubtractCharROI.SaveImage("D:\\TS\\18.objSubtractCharROI.bmp");
//                                    }

//                                    if (m_intExtraExcessMarkInspectionAreaCutMode != 0)
//                                    {
//                                        ROI objSampleCharROI_Temp = new ROI();
//                                        objSampleCharROI_Temp.AttachImage(m_objSampleImage);//objImage_Temp
//                                        objSampleCharROI_Temp.LoadROISetting(m_intROIOffSetX, m_intROIOffSetY, objMarkPackageMarkROI.ref_ROIWidth, objMarkPackageMarkROI.ref_ROIHeight);

//                                        if (blnWantDebug)
//                                        {
//                                            objSampleCharROI_Temp.SaveImage("D:\\TS\\18_0.objSampleCharROI_Temp.bmp");
//                                        }

//                                        //2020-06-17 ZJYEOH : Image processing will be different for white on black and black one white
//                                        if (m_blnWhiteOnBlack)
//                                        {
//                                            EasyImage.Oper(EArithmeticLogicOperation.Subtract, objSampleCharROI_Temp.ref_ROI, objSubtractCharROI.ref_ROI, objSubtractCharROI.ref_ROI);
//                                            objSampleCharROI_Temp.AttachImage(objImage_Temp);
//                                            EasyImage.Oper(EArithmeticLogicOperation.Subtract, objSubtractCharROI.ref_ROI, objSampleCharROI_Temp.ref_ROI, objSubtractCharROI.ref_ROI);
//                                        }
//                                        else
//                                        {
//                                            //ROI.InvertOperationROI(objSubtractCharROI);
//                                            EasyImage.Oper(EArithmeticLogicOperation.Add, objSampleCharROI_Temp.ref_ROI, objSubtractCharROI.ref_ROI, objSubtractCharROI.ref_ROI);
//                                            //objSampleCharROI_Temp.AttachImage(objImage_Temp);
//                                            //EasyImage.Oper(EArithmeticLogicOperation.Add, objSampleCharROI_Temp.ref_ROI, objSubtractCharROI.ref_ROI, objSubtractCharROI.ref_ROI);
//                                        }

//                                        if (blnWantDebug)
//                                        {
//                                            objSampleCharROI_Temp.SaveImage("D:\\TS\\18_1.objSampleCharROI_Temp.bmp");
//                                            objSubtractCharROI.SaveImage("D:\\TS\\18_1.objSubtractCharROI.bmp");
//                                        }
//                                        objSampleCharROI_Temp.Dispose();

//                                    }

//                                    //2020-06-23 ZJYEOH : if no check package size, pRotatedCenterPoint will be (-1, -1)
//                                    if (pRotatedCenterPoint != new PointF(-1, -1))
//                                    {
//                                        m_objLocalTemporary_RotateSearchROI.AttachImage(m_objSampleImage);
//                                        m_objLocalTemporary_RotateSearchROI.LoadROISetting((int)Math.Round(pRotatedCenterPoint.X - objMarkPackageSearchROI.ref_ROIWidth / 2, 0, MidpointRounding.AwayFromZero),
//                                                                          (int)Math.Round(pRotatedCenterPoint.Y - objMarkPackageSearchROI.ref_ROIHeight / 2, 0, MidpointRounding.AwayFromZero),
//                                                                          objMarkPackageSearchROI.ref_ROIWidth, objMarkPackageSearchROI.ref_ROIHeight);

//                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 82");
//                                        ROI.RotateROI(m_objLocalTemporary_RotateSearchROI, fPackageAngle - fMarkAngle, ref m_objSampleImage, 0);
//                                    }

//                                    if (m_objExcessBlobs[m_intTemplateIndex] == null)
//                                        m_objExcessBlobs[m_intTemplateIndex] = new EBlobs();
//                                    else
//                                        m_objExcessBlobs[m_intTemplateIndex].CleanAllBlobs();

//                                    if (m_arrCharExcessAreaResult[m_intTemplateIndex] == null)
//                                        m_arrCharExcessAreaResult[m_intTemplateIndex] = new int[intNumChars];

//                                    if (m_arrCharExcessAreaResult[m_intTemplateIndex].Length != intNumChars)
//                                        m_arrCharExcessAreaResult[m_intTemplateIndex] = new int[intNumChars];

//                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 84");

//                                    for (int a = 0; a < intNumChars; a++)
//                                    {
//                                        m_arrCharExcessAreaResult[m_intTemplateIndex][a] = 0;
//                                    }

//                                    if (blnWantDebug)
//                                    {
//                                        objSubtractCharROI.SaveImage("D:\\TS\\19.objSubtractCharROI.bmp");
//                                    }

//                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 85");

//                                    int intExcessThreshold = intThresholdValue; //2021-02-17 ZJYEOH : Use back mark threshold as excess will attach to mark

//                                    if (m_blnSeparateExtraMarkThreshold)
//                                    {
//                                        if (m_blnWantExcessMarkThresholdFollowExtraMarkThreshold)
//                                            intExcessThreshold = GetAutoThresholdExtraMark(objMarkPackageMarkROI);
//                                    }

//                                    if (BuildObject(m_objExcessBlobs[m_intTemplateIndex], objSubtractCharROI, false, true, intExcessThreshold, m_intMinArea, 1000000, 0x1F)) //intThresholdValue
//                                    {
//                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 86");

//                                        int intNoExcessBlobs = m_objExcessBlobs[m_intTemplateIndex].ref_intNumSelectedObject;

//                                        // Init blob data
//                                        m_intExcessBlobResult[m_intTemplateIndex] = new int[intNoExcessBlobs];
//                                        List<int> arrintMatchNo = new List<int>(intNoExcessBlobs);
//                                        for (j = 0; j < intNoExcessBlobs; j++)
//                                        {
//                                            m_intExcessBlobResult[m_intTemplateIndex][j] = 0;
//                                            arrintMatchNo.Add(-1);
//                                        }
//                                        float fExcessCenterX = 0.0f, fExcessCenterY = 0.0f;

//                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 87");
//                                        // Scan all subtracted blobs to check whether the blob has been fail in Extra Mark/Group Extra Mark checking above.(For extra mark in check area)
//                                        for (int i = 0; i < intNoExcessBlobs; i++)
//                                        {
//                                            fExcessCenterX = m_objExcessBlobs[m_intTemplateIndex].ref_arrLimitCenterX[i];
//                                            fExcessCenterY = m_objExcessBlobs[m_intTemplateIndex].ref_arrLimitCenterY[i];
//                                            intArea = m_objExcessBlobs[m_intTemplateIndex].ref_arrArea[i];     // Get subtracted blob area                                                                                                                      // Get subtracted blob contour xy first point
//                                            intContourX = m_objExcessBlobs[m_intTemplateIndex].ref_arrContourX[i];
//                                            intContourY = m_objExcessBlobs[m_intTemplateIndex].ref_arrContourY[i];
//                                            m_objExcessBlobs[m_intTemplateIndex].DisposeElement(i);

//                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 88");
//                                            // Make sure the subtracted blob pass min area requirement before consider it as excess mark
//                                            // Use m_intMinArea as min area if m_intMinArea < 5, else use 5 as min area
//                                            if (m_intMinArea < 5)
//                                            {
//                                                // skip checking if blob area lower than setting
//                                                if (intArea <= m_intMinArea)
//                                                {
//                                                    continue;
//                                                }
//                                            }
//                                            else
//                                            {
//                                                // skip checking if blob area lower than setting
//                                                if (intArea <= 5)
//                                                {
//                                                    continue;
//                                                }
//                                            }

//                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 89");
//                                            // Make sure subtracted blob is in Char area before consider it as excess mark
//                                            int intMatchNo = -1;
//                                            List<int> arrSingleMatchNo = new List<int>();
//                                            bool IsInExcessROIArea = false;
//                                            for (j = 0; j < arrExcessStartX.Count; j++)
//                                            {
//                                                // 06-02-2020 JBTAN : for Bar Pin 1 Mark, skip if the extra/broken mark is at the end of both tip
//                                                if (m_blnWantCheckBarPin1)
//                                                {
//                                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 90");
//                                                    if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnIsBarPin1[j])
//                                                    {
//                                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 91");
//                                                        if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrBarPin1Type[j] == 0)
//                                                        {
//                                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 92");
//                                                            if ((fExcessCenterX > arrTemplateStartX[j] && fExcessCenterX < arrTemplateEndX[j]))
//                                                                continue;
//                                                        }
//                                                        else
//                                                        {
//                                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 93");
//                                                            if ((fExcessCenterY > arrTemplateStartY[j] && fExcessCenterY < arrTemplateEndY[j]))
//                                                                continue;
//                                                        }
//                                                    }
//                                                }

//                                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 94");
//                                                if (m_intExtraExcessMarkInspectionAreaCutMode == 0)
//                                                {
//                                                    if (fExcessCenterX > arrExcessStartX[j] && fExcessCenterX < arrExcessEndX[j] &&
//                                                        fExcessCenterY > arrExcessStartY[j] && fExcessCenterY < arrExcessEndY[j])
//                                                    {
//                                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 95");
//                                                        if (CheckWantInspectExcessMark(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMarkType[j]))
//                                                        {
//                                                            arrSingleMatchNo.Add(j);
//                                                            intMatchNo = j;
//                                                        }
//                                                        IsInExcessROIArea = true;
//                                                    }
//                                                }
//                                                else
//                                                {
//                                                    if (m_intExtraExcessMarkInspectionAreaCutMode == 1)
//                                                    {
//                                                        if ((m_intROIOffSetX + fExcessCenterX) > arrCharStartPoint_RotateTo0Deg[j].X && (m_intROIOffSetX + fExcessCenterX) < arrCharEndPoint_RotateTo0Deg[j].X &&
//                                                            (m_intROIOffSetY + fExcessCenterY) > arrCharStartPoint_RotateTo0Deg[j].Y && (m_intROIOffSetY + fExcessCenterY) < arrCharEndPoint_RotateTo0Deg[j].Y)
//                                                        {
//                                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 95");
//                                                            if (CheckWantInspectExcessMark(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMarkType[j]))
//                                                            {
//                                                                arrSingleMatchNo.Add(j);
//                                                                intMatchNo = j;
//                                                            }
//                                                            IsInExcessROIArea = true;
//                                                        }
//                                                    }
//                                                    else
//                                                    {
//                                                        if ((m_intROIOffSetX + fExcessCenterX) > (arrCharStartPoint_RotateTo0Deg[j].X - ((int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftX[j] + m_fCharROIOffsetX))) &&
//                                                            (m_intROIOffSetX + fExcessCenterX) < (arrCharEndPoint_RotateTo0Deg[j].X + ((int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftX[j] + m_fCharROIOffsetX))) &&
//                                                            (m_intROIOffSetY + fExcessCenterY) > (arrCharStartPoint_RotateTo0Deg[j].Y - ((int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftY[j] + m_fCharROIOffsetY))) &&
//                                                            (m_intROIOffSetY + fExcessCenterY) < (arrCharEndPoint_RotateTo0Deg[j].Y + ((int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftY[j] + m_fCharROIOffsetY))))
//                                                        {
//                                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 95");
//                                                            if (CheckWantInspectExcessMark(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMarkType[j]))
//                                                            {
//                                                                arrSingleMatchNo.Add(j);
//                                                                intMatchNo = j;
//                                                            }
//                                                            IsInExcessROIArea = true;
//                                                        }
//                                                    }
//                                                }
//                                            }

//                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 96");
//                                            //If is bar pin 1, dont add to excess area
//                                            if (!IsInExcessROIArea)
//                                            //if (!objOCV.IsInOcvCharArea(objContour, ref intMatchNo))
//                                            {
//                                                // 2019 08 01 - CCENG: If no group extra makr or single extra mark fail, mean this object is attached to mark.
//                                                if (((intFailOptionMask & 0x0A) == 0) || ((m_intFailResultMask & 0x0A) > 0))
//                                                {
//                                                    continue;
//                                                }

//                                                // 31-07-3019 ZJYEOH : Consider as group extra mark if contours cannot hit within the character's area, because if straight skip the inspection and continue next blob, there will be some extra/excess mark undetected
//                                                if ((intFailOptionMask & 0x08) > 0) // Check Group Extra Mark 
//                                                {
//                                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 97");
//                                                    bool blnAdd = true;

//                                                    //if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting[intMatchNo] == 0)
//                                                    //{
//                                                    //    blnAdd = false;
//                                                    //}


//                                                    if (blnAdd)
//                                                    {
//                                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 98");

//                                                        m_intGroupExtraMarkArea[m_intTemplateIndex] += intArea;
//                                                        m_intExcessBlobResult[m_intTemplateIndex][i] = 1;

//                                                        if (m_intGroupExtraMarkArea[m_intTemplateIndex] > (int)Math.Round(objTemplateSetting.fGroupExtraMinArea))
//                                                        {
//                                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 99");
//                                                            m_intExcessBlobResult[m_intTemplateIndex][i] = 2;

//                                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 99b");

//                                                            if (!blnGroupExtraMark)
//                                                            {
//                                                                m_intFailResultMask |= 0x08;
//                                                                blnGroupExtraMark = true;

//                                                                // Upgrade result from 1 to 2
//                                                                for (j = 0; j < intNoExcessBlobs; j++)
//                                                                {
//                                                                    if (m_intExcessBlobResult[m_intTemplateIndex][j] == 1)
//                                                                        m_intExcessBlobResult[m_intTemplateIndex][j] = 2;
//                                                                }

//                                                                for (j = 0; j < intNoSelectedBlobs; j++)
//                                                                {
//                                                                    if (m_intBlobResult[m_intTemplateIndex][j] == 1)
//                                                                        m_intBlobResult[m_intTemplateIndex][j] = 2;
//                                                                }
//                                                            }

//                                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 100");
//                                                        }
//                                                    }
//                                                }
//                                                continue;
//                                            }

//                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 101");
//                                            arrintMatchNo[i] = intMatchNo;
//                                            // Check Group Extra Mark
//                                            if ((intFailOptionMask & 0x08) > 0)
//                                            {
//                                                bool blnAdd = true;
//                                                if (intMatchNo >= 0 && intMatchNo < m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting.Count)
//                                                {
//                                                    if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting[intMatchNo] == 0)
//                                                    {
//                                                        blnAdd = false;
//                                                    }
//                                                }

//                                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 102");
//                                                if (blnAdd)
//                                                {


//                                                    m_intGroupExtraMarkArea[m_intTemplateIndex] += intArea;
//                                                    m_intExcessBlobResult[m_intTemplateIndex][i] = 1;

//                                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 103");

//                                                    if (m_intGroupExtraMarkArea[m_intTemplateIndex] > (int)Math.Round(objTemplateSetting.fGroupExtraMinArea))
//                                                    {
//                                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 104");
//                                                        m_intExcessBlobResult[m_intTemplateIndex][i] = 2;

//                                                        if (!blnGroupExtraMark)
//                                                        {
//                                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 105");
//                                                            m_intFailResultMask |= 0x08;
//                                                            blnGroupExtraMark = true;

//                                                            // Upgrade result from 1 to 2
//                                                            for (j = 0; j < intNoExcessBlobs; j++)
//                                                            {
//                                                                if (m_intExcessBlobResult[m_intTemplateIndex][j] == 1)
//                                                                    m_intExcessBlobResult[m_intTemplateIndex][j] = 2;
//                                                            }

//                                                            for (j = 0; j < intNoSelectedBlobs; j++)
//                                                            {
//                                                                if (m_intBlobResult[m_intTemplateIndex][j] == 1)
//                                                                    m_intBlobResult[m_intTemplateIndex][j] = 2;
//                                                            }
//                                                        }
//                                                    }
//                                                }
//                                            }

//                                            // Check Group Excess Mark
//                                            if (((intFailOptionMask & 0x100) > 0) && m_blnWantCheckTotalExcessMark)
//                                            {
//                                                bool blnAdd = IsInExcessROIArea;
//                                                if (intMatchNo >= 0 && intMatchNo < m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting.Count)
//                                                {
//                                                    blnAdd = true;
//                                                    if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting[intMatchNo] == 0)
//                                                    {
//                                                        blnAdd = false;
//                                                    }
//                                                }

//                                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 102 - b");
//                                                if (blnAdd)
//                                                {
//                                                    m_intGroupExcessMarkArea[m_intTemplateIndex] += intArea;
//                                                    m_intExcessBlobResult[m_intTemplateIndex][i] = 1;

//                                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 103 - b");

//                                                    if (m_intGroupExcessMarkArea[m_intTemplateIndex] > (int)Math.Round(objTemplateSetting.fGroupExcessMinArea))
//                                                    {
//                                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 104 - b");
//                                                        m_intExcessBlobResult[m_intTemplateIndex][i] = 2;

//                                                        if (!blnGroupExcessMark)
//                                                        {
//                                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 105 - b");
//                                                            m_intFailResultMask |= 0x2000;
//                                                            blnGroupExcessMark = true;

//                                                            // Upgrade result from 1 to 2
//                                                            for (j = 0; j < intNoExcessBlobs; j++)
//                                                            {
//                                                                if (m_intExcessBlobResult[m_intTemplateIndex][j] == 1)
//                                                                    m_intExcessBlobResult[m_intTemplateIndex][j] = 2;
//                                                            }

//                                                            for (j = 0; j < intNoSelectedBlobs; j++)
//                                                            {
//                                                                if (m_intBlobResult[m_intTemplateIndex][j] == 1)
//                                                                    m_intBlobResult[m_intTemplateIndex][j] = 2;
//                                                            }
//                                                        }
//                                                    }
//                                                }
//                                            }

//                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 106");
//                                            if ((intFailOptionMask & 0x01) > 0)
//                                            {
//                                                for (j = 0; j < arrSingleMatchNo.Count; j++)
//                                                {
//                                                    if (!CheckWantInspectExcessMark(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMarkType[arrSingleMatchNo[j]]))
//                                                        continue;

//                                                    m_arrCharExcessAreaResult[m_intTemplateIndex][arrSingleMatchNo[j]] += intArea;
//                                                }
//                                            }
//                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 107");
//                                        }

//                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 108");
//                                        // 31-07-2019 ZJYEOH : Check Excess here so that the total excess area is correct for each mark
//                                        for (int b = 0; b < m_arrCharExcessAreaResult[m_intTemplateIndex].Length; b++)
//                                        {
//                                            if (m_arrCharExcessAreaResult[m_intTemplateIndex][b] == 0 || !m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[b]  // 2020-08-11 ZJYEOH : Skip Excess if mark disabled
//                                                || m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting[b] == 0) // 2020-08-11 ZJYEOH : Skip Excess if mark score setting = 0
//                                            {
//                                                // 2020-08-11 ZJYEOH : Set to 0 so that offline page will not display red color
//                                                if (m_arrCharExcessAreaResult[m_intTemplateIndex][b] != 0)
//                                                    m_arrCharExcessAreaResult[m_intTemplateIndex][b] = 0;
//                                                continue;
//                                            }
//                                            // Make sure object area is higher than min area and extra min area
//                                            if ((m_arrCharExcessAreaResult[m_intTemplateIndex][b] < m_intMinArea) ||
//                                                (m_arrCharExcessAreaResult[m_intTemplateIndex][b] <= (int)Math.Round(objTemplateSetting.arrMaxExcessArea[b])))
//                                            {
//                                                continue;
//                                            }
//                                            else
//                                            {

//                                                if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting[b] == 0)
//                                                {
//                                                    continue;
//                                                }

//                                                for (int c = 0; c < arrintMatchNo.Count; c++)
//                                                {
//                                                    if (arrintMatchNo[c] == b)
//                                                        m_intExcessBlobResult[m_intTemplateIndex][c] = 2;
//                                                }

//                                                if ((m_intFailResultMask & 0x01) == 0)
//                                                    m_intFailResultMask |= 0x01;
//                                            }
//                                        }

//                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 109");
//                                    }
//                                    objSubtractImage_Temp.Dispose();
//                                }
//                            }

//                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 110");
//                            //-------------------------------------- Check miss mark area ---------------------------------------
//                            if ((intFailOptionMask & 0x10) > 0 && (m_intFailResultMask & 0x01) == 0)
//                            {
//                                // Copy rotated image to sample image
//                                //objOcvRotatedImage.CopyTo(ref m_objSampleImage);
//                                objBlackImage.CopyTo(ref m_objSampleImage);//objImage //2021-07-06 ZJYEOH : Use Black Image so that background is not included
//                                ImageDrawing objSampleImage_Temp = new ImageDrawing(true, m_objSampleImage.ref_intImageWidth, m_objSampleImage.ref_intImageHeight);
//                                //objOcvRotatedImage.CopyTo(ref objSampleImage_Temp);
//                                objImage.CopyTo(ref objSampleImage_Temp);
//                                ImageDrawing objSampleImage_Temp2 = new ImageDrawing(true, m_objSampleImage.ref_intImageWidth, m_objSampleImage.ref_intImageHeight);
//                                //objOcvRotatedImage.CopyTo(ref objSampleImage_Temp2);
//                                objImage.CopyTo(ref objSampleImage_Temp2);
//                                ROI objSubtractCharROI = new ROI();
//                                objSubtractCharROI.AttachImage(m_objSampleImage);

//                                System.Drawing.Point pStart, pEnd;
//                                List<ROI> arrTemplateCharErodeROI = new List<ROI>();

//                                int intNumChars2 = objOCV.GetNumChars();

//                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 111");

//                                if (m_arrCharBrokenAreaResult[m_intTemplateIndex] == null)
//                                    m_arrCharBrokenAreaResult[m_intTemplateIndex] = new int[intNumChars];

//                                if (m_arrCharBrokenAreaResult[m_intTemplateIndex].Length != intNumChars)
//                                    m_arrCharBrokenAreaResult[m_intTemplateIndex] = new int[intNumChars];

//                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 112");
//                                for (int a = 0; a < intNumChars; a++)
//                                {
//                                    m_arrCharBrokenAreaResult[m_intTemplateIndex][a] = 0;
//                                }

//                                List<float> arrMarkStartX = new List<float>();
//                                List<float> arrMarkStartY = new List<float>();
//                                List<float> arrMarkEndX = new List<float>();
//                                List<float> arrMarkEndY = new List<float>();

//                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 113");

//                                for (int i = 0; i < intNumChars2; i++)
//                                {
//                                    //// 2020-08-11 ZJYEOH : Skip if the mark is disabled
//                                    //if (!m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i])
//                                    //    continue;

//                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 114");

//                                    arrTemplateCharErodeROI.Add(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrTemplateCharErodeROI[i]);
//#if (Debug_2_12 || Release_2_12)
//                                    EasyImage.Threshold(arrTemplateCharErodeROI[i].ref_ROI, arrTemplateCharErodeROI[i].ref_ROI, (uint)intThresholdValue);
//#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
//                                    EasyImage.Threshold(arrTemplateCharErodeROI[i].ref_ROI, arrTemplateCharErodeROI[i].ref_ROI, intThresholdValue);
//#endif

//                                    pStart = objOCV.GetCharStartXY(i);
//                                    pEnd = objOCV.GetCharEndXY(i);

//                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 115");

//                                    float fMinAddSizeX = (float)(arrTemplateCharErodeROI[i].ref_ROIWidth - (pEnd.X - pStart.X)) / 2;
//                                    float fMinAddSizeY = (float)(arrTemplateCharErodeROI[i].ref_ROIHeight - (pEnd.Y - pStart.Y)) / 2;

//                                    int intMinAddSizeStartX, intMinAddSizeStartY, intMinAddSizeEndX, intMinAddSizeEndY;
//                                    if (fMinAddSizeX == (int)fMinAddSizeX)
//                                    {
//                                        intMinAddSizeStartX = (int)fMinAddSizeX;
//                                        intMinAddSizeEndX = (int)fMinAddSizeX;
//                                    }
//                                    else
//                                    {
//                                        intMinAddSizeStartX = (int)Math.Ceiling(fMinAddSizeX);
//                                        intMinAddSizeEndX = (int)Math.Floor(fMinAddSizeX);
//                                    }

//                                    if (fMinAddSizeY == (int)fMinAddSizeY)
//                                    {
//                                        intMinAddSizeStartY = (int)fMinAddSizeY;
//                                        intMinAddSizeEndY = (int)fMinAddSizeY;
//                                    }
//                                    else
//                                    {
//                                        intMinAddSizeStartY = (int)Math.Ceiling(fMinAddSizeY);
//                                        intMinAddSizeEndY = (int)Math.Floor(fMinAddSizeY);
//                                    }

//                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 116");

//                                    ROI objSampleCharROI = new ROI();

//                                    if ((m_intROIOffSetX + pStart.X - intMinAddSizeStartX) >= 0) //if ((pStart.X - intMinAddSizeStartX) >= 0)   // 2019 10 11 - CCENG: add m_intROIOffSetXY because objSampleCharROI attach to main Image.
//                                        objSampleCharROI.ref_ROIPositionX = m_intROIOffSetX + pStart.X - intMinAddSizeStartX;
//                                    else
//                                        objSampleCharROI.ref_ROIPositionX = m_intROIOffSetX;

//                                    if ((m_intROIOffSetY + pStart.Y - intMinAddSizeStartY) >= 0)  //if ((pStart.Y - intMinAddSizeStartY) >= 0)  // 2019 10 11 - CCENG: add m_intROIOffSetXY because objSampleCharROI attach to main Image.
//                                        objSampleCharROI.ref_ROIPositionY = m_intROIOffSetY + pStart.Y - intMinAddSizeStartY;
//                                    else
//                                        objSampleCharROI.ref_ROIPositionY = m_intROIOffSetY;

//                                    if ((pEnd.X + intMinAddSizeEndX * 2) < m_intImageWidth)
//                                        objSampleCharROI.ref_ROIWidth = pEnd.X - pStart.X + intMinAddSizeStartX + intMinAddSizeEndX;
//                                    else
//                                        continue;
//                                    if ((pEnd.Y + intMinAddSizeEndY * 2) < m_intImageHeight)
//                                        objSampleCharROI.ref_ROIHeight = pEnd.Y - pStart.Y + intMinAddSizeStartY + intMinAddSizeEndY;
//                                    else
//                                        continue;

//                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 117");

//                                    // 2020 03 01 - CCENG: Attached to m_objSampleImage because objSampleCharROI will be Dilated when m_intMissingMarkInspectionMethod is 1. 
//                                    //                   : Also Dilate and subtract's image source and destination can be same.          
//                                    //objSampleCharROI.AttachImage(objImage);

//                                    //2020-06-17 ZJYEOH : objSampleCharROI should attach another image as m_objSampleImage will be image processsed
//                                    objSampleCharROI.AttachImage(objSampleImage_Temp);//m_objSampleImage

//                                    objSubtractCharROI.LoadROISetting(objSampleCharROI.ref_ROIPositionX, objSampleCharROI.ref_ROIPositionY,
//                                                                        objSampleCharROI.ref_ROIWidth, objSampleCharROI.ref_ROIHeight);

//                                    if ((objSampleCharROI.ref_ROIWidth != arrTemplateCharErodeROI[i].ref_ROIWidth) ||
//                                        (arrTemplateCharErodeROI[i].ref_ROIWidth != objSubtractCharROI.ref_ROIWidth))
//                                        continue;

//                                    if ((objSampleCharROI.ref_ROIHeight != arrTemplateCharErodeROI[i].ref_ROIHeight) ||
//                                        (arrTemplateCharErodeROI[i].ref_ROIHeight != objSubtractCharROI.ref_ROIHeight))
//                                        continue;

//                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 118");

//                                    arrMarkStartX.Add(objSubtractCharROI.ref_ROIPositionX - m_intROIOffSetX);
//                                    arrMarkStartY.Add(objSubtractCharROI.ref_ROIPositionY - m_intROIOffSetY);
//                                    arrMarkEndX.Add(objSubtractCharROI.ref_ROIPositionX + objSubtractCharROI.ref_ROIWidth - m_intROIOffSetX);
//                                    arrMarkEndY.Add(objSubtractCharROI.ref_ROIPositionY + objSubtractCharROI.ref_ROIHeight - m_intROIOffSetY);

//                                    if (!m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i] || !CheckWantInspectMissingMark(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMarkType[i]))
//                                    {
//                                        EasyImage.Oper(EArithmeticLogicOperation.Subtract, arrTemplateCharErodeROI[i].ref_ROI, arrTemplateCharErodeROI[i].ref_ROI, objSubtractCharROI.ref_ROI);
//                                    }
//                                    else
//                                    {
//                                        //if (m_intMissingMarkInspectionMethod == 0) // 2020 03 01 - CCENG: 0=Thin on Template Mark
//                                        //{
//                                        //    //2020-06-17 ZJYEOH : Image processing will be different for white on black and black one white
//                                        //    if (m_blnWhiteOnBlack)
//                                        //    {
//                                        //        EasyImage.Oper(EArithmeticLogicOperation.Subtract, arrTemplateCharErodeROI[i].ref_ROI, objSampleCharROI.ref_ROI, objSubtractCharROI.ref_ROI);
//                                        //    }
//                                        //    else
//                                        //    {
//                                        //        EasyImage.Oper(EArithmeticLogicOperation.Invert, objSampleCharROI.ref_ROI, objSampleCharROI.ref_ROI);
//                                        //        EasyImage.Oper(EArithmeticLogicOperation.Add, arrTemplateCharErodeROI[i].ref_ROI, objSampleCharROI.ref_ROI, objSubtractCharROI.ref_ROI);
//                                        //        //2020-06-17 ZJYEOH : Invert back so that objSampleCharROI will not inverted if it is used again because inverted area may overlap another mark
//                                        //        EasyImage.Oper(EArithmeticLogicOperation.Invert, objSampleCharROI.ref_ROI, objSampleCharROI.ref_ROI);
//                                        //    }
//                                        //}
//                                        //else
//                                        {
//                                            // 2020 03 01 - CCENG: m_intMissingMarkInspectionMethod == 0 mean thick on sample mark
//#if (Debug_2_12 || Release_2_12)
//                                            if (m_intCharErodeHalfWidth > 0)
//                                            {
//                                                if (m_blnWhiteOnBlack)
//                                                    EasyImage.DilateBox(objSampleCharROI.ref_ROI, objSampleCharROI.ref_ROI, (uint)m_intCharErodeHalfWidth);
//                                                else
//                                                    EasyImage.ErodeBox(objSampleCharROI.ref_ROI, objSampleCharROI.ref_ROI, (uint)m_intCharErodeHalfWidth);
//                                            }
//#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
//                                            if (m_intCharErodeHalfWidth > 0)
//                                            {
//                                                if (m_blnWhiteOnBlack)
//                                                    EasyImage.DilateBox(objSampleCharROI.ref_ROI, objSampleCharROI.ref_ROI, m_intCharErodeHalfWidth);
//                                                else
//                                                    EasyImage.ErodeBox(objSampleCharROI.ref_ROI, objSampleCharROI.ref_ROI, m_intCharErodeHalfWidth);
//                                            }
//#endif

//                                            //2020-06-17 ZJYEOH : Image processing will be different for white on black and black one white
//                                            if (m_blnWhiteOnBlack)
//                                            {
//                                                EasyImage.Oper(EArithmeticLogicOperation.Subtract, arrTemplateCharErodeROI[i].ref_ROI, objSampleCharROI.ref_ROI, objSubtractCharROI.ref_ROI);
//                                            }
//                                            else
//                                            {
//                                                //EasyImage.Oper(EArithmeticLogicOperation.Invert, objSampleCharROI.ref_ROI, objSampleCharROI.ref_ROI);
//                                                ROI.InvertOperationROI(objSampleCharROI);
//                                                EasyImage.Oper(EArithmeticLogicOperation.Add, arrTemplateCharErodeROI[i].ref_ROI, objSampleCharROI.ref_ROI, objSubtractCharROI.ref_ROI);
//                                                //2020-06-17 ZJYEOH : Invert back so that objSampleCharROI will not inverted if it is used again because inverted area may overlap another mark
//                                                //EasyImage.Oper(EArithmeticLogicOperation.Invert, objSampleCharROI.ref_ROI, objSampleCharROI.ref_ROI);
//                                                ROI.InvertOperationROI(objSampleCharROI);
//                                            }
//                                        }
//                                    }

//                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 119");

//                                    if (blnWantDebug)
//                                    {
//                                        arrTemplateCharErodeROI[i].SaveImage("D:\\TS\\34.arrTemplateCharErodeROI[i]" + i.ToString() + ".bmp");
//                                        objSampleCharROI.SaveImage("D:\\TS\\35.objSampleCharROI" + i.ToString() + ".bmp");
//                                        objSubtractCharROI.SaveImage("D:\\TS\\36.objSubtractCharROI" + i.ToString() + ".bmp");
//                                        m_objSampleImage.SaveImage("D:\\TS\\37.m_objSampleImage" + i.ToString() + ".bmp");
//                                    }

//                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 120");

//                                    objSampleCharROI.Dispose();
//                                }

//                                //2020-06-23 ZJYEOH : if no check package size, pRotatedCenterPoint will be (-1, -1)
//                                if (pRotatedCenterPoint != new PointF(-1, -1))
//                                {
//                                    m_objLocalTemporary_RotateSearchROI.AttachImage(m_objSampleImage);
//                                    m_objLocalTemporary_RotateSearchROI.LoadROISetting((int)Math.Round(pRotatedCenterPoint.X - objMarkPackageSearchROI.ref_ROIWidth / 2, 0, MidpointRounding.AwayFromZero),
//                                                                      (int)Math.Round(pRotatedCenterPoint.Y - objMarkPackageSearchROI.ref_ROIHeight / 2, 0, MidpointRounding.AwayFromZero),
//                                                                      objMarkPackageSearchROI.ref_ROIWidth, objMarkPackageSearchROI.ref_ROIHeight);

//                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 121");

//                                    ROI.RotateROI(m_objLocalTemporary_RotateSearchROI, fPackageAngle - fMarkAngle, ref m_objSampleImage, 0);
//                                }

//                                if (blnWantDebug)
//                                {
//                                    m_objSampleImage.SaveImage("D:\\TS\\40m_objSampleImage.bmp");
//                                }

//                                objSubtractCharROI.AttachImage(m_objSampleImage);

//                                if (blnWantDebug)
//                                {
//                                    objSubtractCharROI.SaveImage("D:\\TS\\41.objSubtractCharROI.bmp");
//                                }

//                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 122");
//                                // Reload ROI size and placement to same location and same size as Mark ROI
//                                objSubtractCharROI.LoadROISetting(m_intROIOffSetX, m_intROIOffSetY, objMarkPackageMarkROI.ref_ROIWidth, objMarkPackageMarkROI.ref_ROIHeight);

//#if (Debug_2_12 || Release_2_12)

//                                if (m_intCharOpenHalfWidth > 0)
//                                    EasyImage.OpenBox(objSubtractCharROI.ref_ROI, objSubtractCharROI.ref_ROI, (uint)m_intCharOpenHalfWidth);
//#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)

//                                if (m_intCharOpenHalfWidth > 0)
//                                    EasyImage.OpenBox(objSubtractCharROI.ref_ROI, objSubtractCharROI.ref_ROI, m_intCharOpenHalfWidth);
//#endif

//                                if (m_objMissingBlobs[m_intTemplateIndex] == null)
//                                    m_objMissingBlobs[m_intTemplateIndex] = new EBlobs();
//                                else
//                                    m_objMissingBlobs[m_intTemplateIndex].CleanAllBlobs();

//                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 123");
//                                if (blnWantDebug)
//                                {
//                                    objSubtractCharROI.SaveImage("D:\\TS\\42.objSubtractCharROI.bmp");
//                                }

//                                //2020-06-17 ZJYEOH : Threshold will invert for white on black
//                                int intMissingThreshold = intThresholdValue;
//                                if (m_blnWhiteOnBlack)
//                                {
//                                    intMissingThreshold = 255 - intThresholdValue;
//                                }


//                                if (BuildObject(m_objMissingBlobs[m_intTemplateIndex], objSubtractCharROI, false, true, intMissingThreshold, m_intMinArea, 1000000, 0x1F)) //255 - intThresholdValue
//                                {
//                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 124");
//                                    int intNoMissingBlobs = m_objMissingBlobs[m_intTemplateIndex].ref_intNumSelectedObject;

//                                    // Init blob data
//                                    List<int> arrintMatchNo = new List<int>();
//                                    m_intMissingBlobResult[m_intTemplateIndex] = new int[intNoMissingBlobs];
//                                    for (j = 0; j < intNoMissingBlobs; j++)
//                                    {
//                                        m_intMissingBlobResult[m_intTemplateIndex][j] = 0;
//                                    }

//                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 125");

//                                    for (int i = 0; i < intNoMissingBlobs; i++)
//                                    {
//                                        arrintMatchNo.Add(-1);

//                                        intArea = m_objMissingBlobs[m_intTemplateIndex].ref_arrArea[i];     // Get subtracted blob area
//                                        fCenterX = m_objMissingBlobs[m_intTemplateIndex].ref_arrLimitCenterX[i];
//                                        fCenterY = m_objMissingBlobs[m_intTemplateIndex].ref_arrLimitCenterY[i];
//                                        fWidth = m_objMissingBlobs[m_intTemplateIndex].ref_arrWidth[i];
//                                        fHeight = m_objMissingBlobs[m_intTemplateIndex].ref_arrHeight[i];
//                                        bool blnIsInOcvCharArea = false;

//                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 126");
//                                        int intMatchNo = -1;
//                                        for (j = 0; j < arrMarkStartX.Count; j++)
//                                        {
//                                            // 2020 02 27 - CCENG: Check after loop.
//                                            // 06-02-2020 JBTAN : for Bar Pin 1 Mark, skip if the extra/broken mark is at the end of both tip
//                                            //if (m_blnWantCheckBarPin1)
//                                            //{
//                                            //    if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnIsBarPin1[j])
//                                            //    {
//                                            //        if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrBarPin1Type[j] == 0)
//                                            //        {
//                                            //            if ((fCenterX > arrExcessStartX[j] && fCenterX < arrExcessEndX[j]) &&
//                                            //                (fCenterY < arrExcessStartY[j] || fCenterY > arrExcessEndY[j]))
//                                            //                continue;
//                                            //        }
//                                            //        else
//                                            //        {
//                                            //            if ((fCenterY > arrExcessStartY[j] && fCenterY < arrExcessEndY[j]) &&
//                                            //                (fCenterX < arrExcessStartX[j] || fCenterX > arrExcessEndX[j]))
//                                            //                continue;
//                                            //        }
//                                            //    }
//                                            //}

//                                            // Broken Mark area should always smaller than ocv mark roi. 
//                                            if ((fWidth < (arrMarkEndX[j] - arrMarkStartX[j])) &&
//                                            (fHeight < (arrMarkEndY[j] - arrMarkStartY[j])))
//                                            {
//                                                if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 127");
//                                                // Broken Mark center point should always within ocv mark roi area.
//                                                if (fCenterX > arrMarkStartX[j] && fCenterX < arrMarkEndX[j] &&
//                                                    fCenterY > arrMarkStartY[j] && fCenterY < arrMarkEndY[j])
//                                                {
//                                                    //2021-07-07 ZJYEOH : No need meet min 2 corner points requirement as now built on black image
//                                                    //// 2019 10 14 - CCENG: Broken Mark center point and at least 2 corner points must within ocv mark roi area. - This is because whole mark ROI image are blobs builded sometime outside char area will be build also and considered as broken if size are big. 
//                                                    //int intCornerMatchCount = 0;

//                                                    //if ((fCenterX - fWidth / 2) > arrMarkStartX[j] && (fCenterX - fWidth / 2) < arrMarkEndX[j] &&
//                                                    //    (fCenterY - fHeight / 2) > arrMarkStartY[j] && (fCenterY - fHeight / 2) < arrMarkEndY[j])
//                                                    //{
//                                                    //    intCornerMatchCount++;
//                                                    //}

//                                                    //if ((fCenterX + fWidth / 2) > arrMarkStartX[j] && (fCenterX + fWidth / 2) < arrMarkEndX[j] &&
//                                                    //    (fCenterY - fHeight / 2) > arrMarkStartY[j] && (fCenterY - fHeight / 2) < arrMarkEndY[j])
//                                                    //{
//                                                    //    intCornerMatchCount++;
//                                                    //}

//                                                    //if ((fCenterX + fWidth / 2) > arrMarkStartX[j] && (fCenterX + fWidth / 2) < arrMarkEndX[j] &&
//                                                    //    (fCenterY + fHeight / 2) > arrMarkStartY[j] && (fCenterY + fHeight / 2) < arrMarkEndY[j])
//                                                    //{
//                                                    //    intCornerMatchCount++;
//                                                    //}

//                                                    //if ((fCenterX - fWidth / 2) > arrMarkStartX[j] && (fCenterX - fWidth / 2) < arrMarkEndX[j] &&
//                                                    //    (fCenterY + fHeight / 2) > arrMarkStartY[j] && (fCenterY + fHeight / 2) < arrMarkEndY[j])
//                                                    //{
//                                                    //    intCornerMatchCount++;
//                                                    //}

//                                                    //if (intCornerMatchCount >= 2)
//                                                    {
//                                                        intMatchNo = j;
//                                                        blnIsInOcvCharArea = true;
//                                                        break;
//                                                    }
//                                                }
//                                            }
//                                        }

//                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 129");
//                                        if (blnIsInOcvCharArea) // 2019 04 13-CCENG: Only blob under Ocv Char Area will recorded.
//                                        {
//                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 130");
//                                            // 2020 02 27 - CCENG: Move this checking to here.
//                                            // 06-02-2020 JBTAN : for Bar Pin 1 Mark, skip if the extra/broken mark is at the end of both tip
//                                            if (m_blnWantCheckBarPin1)
//                                            {
//                                                if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnIsBarPin1[j])
//                                                {
//                                                    if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrBarPin1Type[j] == 0)
//                                                    {
//                                                        // 2020 02 27 - CCENG: check x only because sometime the excess area will partially inside the bar.
//                                                        //if ((fCenterX > arrExcessStartX[j] && fCenterX < arrExcessEndX[j]) &&
//                                                        //    (fCenterY < arrExcessStartY[j] || fCenterY > arrExcessEndY[j]))
//                                                        if (fCenterX > arrExcessStartX[j] && fCenterX < arrExcessEndX[j])
//                                                            continue;
//                                                    }
//                                                    else
//                                                    {
//                                                        // 2020 02 27 - CCENG: check y only because sometime the excess area will partially inside the bar.
//                                                        //if ((fCenterY > arrExcessStartY[j] && fCenterY < arrExcessEndY[j]) &&
//                                                        //    (fCenterX < arrExcessStartX[j] || fCenterX > arrExcessEndX[j]))
//                                                        if (fCenterY > arrExcessStartY[j] && fCenterY < arrExcessEndY[j])
//                                                            continue;
//                                                    }
//                                                }
//                                            }

//                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 131");
//                                            if (m_intSmallestMissingMarkArea[m_intTemplateIndex] == 0 || intArea < m_intSmallestMissingMarkArea[m_intTemplateIndex])
//                                                m_intSmallestMissingMarkArea[m_intTemplateIndex] = intArea;

//                                            if (m_intBiggestMissingMarkArea[m_intTemplateIndex] == 0 || intArea > m_intBiggestMissingMarkArea[m_intTemplateIndex])
//                                                m_intBiggestMissingMarkArea[m_intTemplateIndex] = intArea;

//                                            m_arrCharBrokenAreaResult[m_intTemplateIndex][intMatchNo] += intArea;

//                                            arrintMatchNo[i] = intMatchNo;

//                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 132");
//                                        }


//                                        //// Check whether the blob has been fail
//                                        //for (j = 0; j < intNoSelectedBlobs; j++)
//                                        //{
//                                        //    if (m_intBlobResult[m_intTemplateIndex][j] == 2)
//                                        //    {
//                                        //        float fMissingCenterX, fMissingCenterY;
//                                        //        fMissingCenterX = fMissingCenterY = 0.0f;

//                                        //        fCenterX = m_objBlobs[m_intTemplateIndex].ref_arrLimitCenterX[j];
//                                        //        fCenterY = m_objBlobs[m_intTemplateIndex].ref_arrLimitCenterY[j];
//                                        //        m_objBlobs[m_intTemplateIndex].DisposeElement(j);

//                                        //        fMissingCenterX = m_objMissingBlobs[m_intTemplateIndex].ref_arrLimitCenterX[i];
//                                        //        fMissingCenterY = m_objMissingBlobs[m_intTemplateIndex].ref_arrLimitCenterY[i];

//                                        //        if (fCenterX == fMissingCenterX && fCenterY == fMissingCenterY)
//                                        //        {
//                                        //            break;
//                                        //        }
//                                        //    }
//                                        //}

//                                        // The blob has been fail 
//                                        //if (intNoSelectedBlobs != 0 && j != intNoSelectedBlobs)
//                                        //{
//                                        //    continue;
//                                        //}



//                                        //intArea = m_objMissingBlobs[m_intTemplateIndex].ref_arrArea[i];     // Get subtracted blob area // Get subtracted blob contour xy first point
//                                        //bool blnIsInOcvCharArea = false;
//                                        //if (!blnAuto || (blnAuto && (intArea > objTemplateSetting.intMissingMinArea)))  // 2018 10 08 - CCENG: For faster inspection during production test (blnAuto is true), if blob area small than MissingMinArea, then skip checking IsInOcvCharArea  
//                                        //if (intArea > objTemplateSetting.intMissingMinArea)
//                                        //{
//                                        //    intContourX = m_objMissingBlobs[m_intTemplateIndex].ref_arrContourX[i];
//                                        //    intContourY = m_objMissingBlobs[m_intTemplateIndex].ref_arrContourY[i];

//                                        //    Contour objContour = new Contour();

//                                        //    if (objContour.BuildContour(objSubtractCharROI, intContourX, intContourY, intThresholdValue, 4))
//                                        //    {
//                                        //        int intMatchCharNo = -1;

//                                        //        if (objOCV.IsInOcvCharArea(objContour, ref intMatchCharNo))
//                                        //        {
//                                        //            blnIsInOcvCharArea = true;
//                                        //            if (intArea > objTemplateSetting.intMissingMinArea)
//                                        //            {
//                                        //                m_blnCharResult[m_intTemplateIndex][intMatchCharNo] = false;

//                                        //                m_intMissingBlobResult[m_intTemplateIndex][i] = 2;

//                                        //                if ((m_intFailResultMask & 0x10) == 0)
//                                        //                    m_intFailResultMask |= 0x10;
//                                        //            }
//                                        //        }
//                                        //    }
//                                        //}

//                                        //if (blnIsInOcvCharArea) // 2019 04 13-CCENG: Only blob under Ocv Char Area will recorded.
//                                        //{
//                                        //    if (m_intSmallestMissingMarkArea[m_intTemplateIndex] == 0 || intArea < m_intSmallestMissingMarkArea[m_intTemplateIndex])
//                                        //        m_intSmallestMissingMarkArea[m_intTemplateIndex] = intArea;

//                                        //    if (m_intBiggestMissingMarkArea[m_intTemplateIndex] == 0 || intArea > m_intBiggestMissingMarkArea[m_intTemplateIndex])
//                                        //        m_intBiggestMissingMarkArea[m_intTemplateIndex] = intArea;
//                                        //}
//                                    }

//                                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 133");

//                                    for (int b = 0; b < m_arrCharBrokenAreaResult[m_intTemplateIndex].Length; b++)
//                                    {
//                                        if (m_arrCharBrokenAreaResult[m_intTemplateIndex][b] == 0 || !m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[b] // 2020-08-11 ZJYEOH : Skip Broken if mark disabled
//                                              || m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting[b] == 0) // 2020-08-11 ZJYEOH : Skip Broken if mark score setting = 0
//                                        {
//                                            // 2020-08-11 ZJYEOH : Set to 0 so that offline page will not display red color
//                                            if (m_arrCharBrokenAreaResult[m_intTemplateIndex][b] != 0)
//                                                m_arrCharBrokenAreaResult[m_intTemplateIndex][b] = 0;
//                                            continue;
//                                        }
//                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 134");

//                                        // Make sure object area is higher than min area and broken min area
//                                        if ((m_arrCharBrokenAreaResult[m_intTemplateIndex][b] < m_intMinArea) ||
//                                            (m_arrCharBrokenAreaResult[m_intTemplateIndex][b] <= (int)Math.Round(objTemplateSetting.arrMaxBrokenArea[b])))   // 2021 02 23 - CCENG: change from < to <= bcos == mean pass also
//                                        {
//                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 135");
//                                            continue;
//                                        }
//                                        else
//                                        {
//                                            if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 136");
//                                            if (m_intSmallestMissingMarkArea[m_intTemplateIndex] == 0 || m_arrCharBrokenAreaResult[m_intTemplateIndex][b] < m_intSmallestMissingMarkArea[m_intTemplateIndex])
//                                                m_intSmallestMissingMarkArea[m_intTemplateIndex] = m_arrCharBrokenAreaResult[m_intTemplateIndex][b];

//                                            if (m_intBiggestMissingMarkArea[m_intTemplateIndex] == 0 || m_arrCharBrokenAreaResult[m_intTemplateIndex][b] > m_intBiggestMissingMarkArea[m_intTemplateIndex])
//                                                m_intBiggestMissingMarkArea[m_intTemplateIndex] = m_arrCharBrokenAreaResult[m_intTemplateIndex][b];

//                                            for (int c = 0; c < arrintMatchNo.Count; c++)
//                                            {
//                                                if (arrintMatchNo[c] == b)
//                                                    m_intMissingBlobResult[m_intTemplateIndex][c] = 2;
//                                            }

//                                            if ((m_intFailResultMask & 0x10) == 0)
//                                                m_intFailResultMask |= 0x10;
//                                        }
//                                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 138");
//                                    }
//                                }
//                                objSampleImage_Temp.Dispose();
//                                objSampleImage_Temp2.Dispose();
//                                objSubtractCharROI.Dispose();
//                            }
//                        }
//                        objImage_Temp.Dispose();
//                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 140");
//                        #endregion ---------------------------------------------------------------------------------------------------------

//                        // Stop to test next template if return pass
//                        if (m_intFailResultMask == 0)
//                            break;

//                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 141");
//                        SkipInspection:
//                        // Stop to test next template if not inspect all
//                        if (!m_blnInspectAllTemplate)
//                            break;

//                        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 142");
//                        // Go to next template
//                        intTemplateCount++;
//                    }

//                    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OcvMark - 143");
//                    timeout.Stop(); // ------------------- checking loop timeout ---------------------------------------------------
//                    m_blnLock = false;
//                    m_blnLockBlobs = false;

//                    if (m_intFailResultMask > 0)
//                        return false;
//                    else
//                        return true;
//                }
//            }
//            catch (Exception ex)
//            {
//                // 2021 01 05 - CCENG: Need to set FailResultMask in order to fail the unit. 
//                if ((m_intFailResultMask & 0x1000) == 0)
//                    m_intFailResultMask |= 0x1000;

//                m_blnExtraSaveImageAndRecipeDueToException = true;
//                m_blnLock = false;
//                m_blnLockBlobs = false;
//                //m_objTL.WriteLine("InspectOCVMark ex: " + ex.ToString());
//                return false;
//            }
//        }

        public int GetBrokenSize()
        {
            return m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intBrokenSize;
        }

        public int GetBrokenSize(int intGroupIndex, int intTemplateIndex)
        {
            if (intTemplateIndex < 0)
                return 0;

            if (m_arrTemplateSetting.Count <= intGroupIndex)
                return 0;

            if (m_arrTemplateSetting[intGroupIndex].Count <= intTemplateIndex)
                return 0;

            return m_arrTemplateSetting[intGroupIndex][intTemplateIndex].intBrokenSize;
        }

        public bool IsExtraPadOrTextShiftedFailMaskON()
        {
            for (int group = 0; group < m_arrTemplateSetting.Count; group++)
            {
                for (int template = 0; template < m_arrTemplateSetting[group].Count; template++)
                {
                    //if ((m_arrTemplateSetting[group][template].intFailOptionMask & 0x4E) > 0)   //Fail Mask for Text Shifted, Extra Pad Center Area, Extra Pad Side Area and Group Extra Pad
                    if ((m_arrTemplateSetting[group][template].intFailOptionMask & 0x44) > 0)   //Fail Mask for Text Shifted, Extra Pad Side Area 
                        return true;
                }
            }

            return false;
        }

        public int GetCharShiftXY()
        {
            return m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharShiftXY;
        }

        public int GetCharShiftXY(int intGroupIndex, int intTemplateIndex)
        {
            if (intTemplateIndex < 0)
                return 0;

            if (m_arrTemplateSetting.Count <= intGroupIndex)
                return 0;

            if (m_arrTemplateSetting[intGroupIndex].Count <= intTemplateIndex)
                return 0;

            return m_arrTemplateSetting[intGroupIndex][intTemplateIndex].intCharShiftXY;
        }

        public int GetCharSetting(int intCharIndex)
        {
            if (intCharIndex >= m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting.Count)
                return -1;

            return m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting[intCharIndex];
        }

        public bool GetEnableMarkSetting(int intCharIndex)
        {
            if (intCharIndex >= m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable.Count)
                return true;    // 2018 10 16 - Old recipe dun have this parameter, so return true to allow the mark inspection.

            return m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[intCharIndex];
        }
        public int GetTemplateCharShiftX(int intCharIndex)
        {
            if (intCharIndex >= m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftX.Count)
                return (int)Math.Round(m_fCharROIOffsetX);    // 2018 10 16 - Old recipe dun have this parameter, so return true to allow the mark inspection.

            return (int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftX[intCharIndex] + m_fCharROIOffsetX);
        }
        public int GetTemplateCharShiftY(int intCharIndex)
        {
            if (intCharIndex >= m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftY.Count)
                return (int)Math.Round(m_fCharROIOffsetY);    // 2018 10 16 - Old recipe dun have this parameter, so return true to allow the mark inspection.

            return (int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftY[intCharIndex] + m_fCharROIOffsetY);
        }
        public Point GetTemplateCharROIStartPoint(int intCharIndex)
        {
            if (intCharIndex >= m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrTemplateCharDilateROI.Count)
                return new Point(0, 0);    // 2018 10 16 - Old recipe dun have this parameter, so return true to allow the mark inspection.

            return new Point(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrTemplateCharDilateROI[intCharIndex].ref_ROIPositionX, m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrTemplateCharDilateROI[intCharIndex].ref_ROIPositionY);
        }
        public Point GetTemplateCharROIEndPoint(int intCharIndex)
        {
            if (intCharIndex >= m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrTemplateCharDilateROI.Count)
                return new Point(0, 0);    // 2018 10 16 - Old recipe dun have this parameter, so return true to allow the mark inspection.

            return new Point(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrTemplateCharDilateROI[intCharIndex].ref_ROIPositionX + m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrTemplateCharDilateROI[intCharIndex].ref_ROIWidth
                , m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrTemplateCharDilateROI[intCharIndex].ref_ROIPositionY + m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrTemplateCharDilateROI[intCharIndex].ref_ROIHeight);
        }
        public Size GetTemplateCharROISize(int intCharIndex)
        {
            if (intCharIndex >= m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrTemplateCharDilateROI.Count)
                return new Size(0, 0);    // 2018 10 16 - Old recipe dun have this parameter, so return true to allow the mark inspection.

            return new Size(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrTemplateCharDilateROI[intCharIndex].ref_ROIWidth, m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrTemplateCharDilateROI[intCharIndex].ref_ROIHeight);
        }
        public int GetCharSetting(int intCharIndex, int intGroupIndex, int intTemplateIndex)
        {
            if (intCharIndex >= m_arrTemplateSetting[intGroupIndex][intTemplateIndex].intCharSetting.Count)
                return -1;

            return m_arrTemplateSetting[intGroupIndex][intTemplateIndex].intCharSetting[intCharIndex];
        }
        public int GetOCRCharSetting(int intCharIndex)
        {
            if (intCharIndex >= arrOCRCharSetting.Count)
                return -1;

            return arrOCRCharSetting[intCharIndex];
        }

        public float GetMaxAGVPercent(int intCharIndex, int intGroupIndex, int intTemplateIndex)
        {
            if (intCharIndex >= m_arrTemplateSetting[intGroupIndex][intTemplateIndex].fMaxAGVPercent.Count)
                return -1;

            return m_arrTemplateSetting[intGroupIndex][intTemplateIndex].fMaxAGVPercent[intCharIndex];
        }

        public bool GetEnableMarkSetting(int intCharIndex, int intGroupIndex, int intTemplateIndex)
        {
            if (intCharIndex >= m_arrTemplateSetting[intGroupIndex][intTemplateIndex].blnEnable.Count)
                return true;    // 2018 10 16 - Old recipe dun have this parameter, so return true to allow the mark inspection.

            return m_arrTemplateSetting[intGroupIndex][intTemplateIndex].blnEnable[intCharIndex];
        }

        public float GetExtraMinArea()
        {
            switch (m_intDisplayUnitMode)
            {
                case 0: // Pixel
                    return m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fExtraMinArea;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fExtraMinArea * m_fMMPerPixelArea) * m_fMMToUnitValueArea;
                default:
                    return 0;
            }
        }

        public float GetExtraMinArea(int intGroupIndex, int intTemplateIndex)
        {
            if (intTemplateIndex < 0)
                return 0;

            if (m_arrTemplateSetting.Count <= intGroupIndex)
                return 0;

            if (m_arrTemplateSetting[intGroupIndex].Count <= intTemplateIndex)
                return 0;

            switch (m_intDisplayUnitMode)
            {
                case 0: // Pixel
                    return m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fExtraMinArea;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fExtraMinArea * m_fMMPerPixelArea) * m_fMMToUnitValueArea;
                default:
                    return 0;
            }
        }

        public int GetExcessMinArea(int intGroupIndex, int intTemplateIndex)
        {
            if (intTemplateIndex < 0)
                return 0;

            if (m_arrTemplateSetting.Count <= intGroupIndex)
                return 0;

            if (m_arrTemplateSetting[intGroupIndex].Count <= intTemplateIndex)
                return 0;

            return m_arrTemplateSetting[intGroupIndex][intTemplateIndex].intExcessMinArea;
        }

        public int GetFailOptionMask()
        {
            return m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intFailOptionMask;
        }

        public int GetFailOptionMask(int intGroupIndex, int intTemplateIndex)
        {
            if (intTemplateIndex < 0)
            {
                STTrackLog.WriteLine("GetFailOptionMask >>>>>>>>>>>>>>>> intTemplateIndex < 0");
                STTrackLog.WriteLine(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> intTemplateIndex = " + intTemplateIndex.ToString());
                return 0;
            }

            if (m_arrTemplateSetting.Count <= intGroupIndex)
            {
                STTrackLog.WriteLine("GetFailOptionMask >>>>>>>>>>>>>>>> m_arrTemplateSetting.Count <= intGroupIndex");
                STTrackLog.WriteLine(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> m_arrTemplateSetting.Count = " + m_arrTemplateSetting.Count.ToString() + " , intGroupIndex = " + intGroupIndex.ToString());
                return 0;
            }

            if (m_arrTemplateSetting[intGroupIndex].Count <= intTemplateIndex)
            {
                STTrackLog.WriteLine("GetFailOptionMask >>>>>>>>>>>>>>>> m_arrTemplateSetting[intGroupIndex].Count <= intTemplateIndex");
                STTrackLog.WriteLine(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> m_arrTemplateSetting[intGroupIndex].Count = " + m_arrTemplateSetting[intGroupIndex].Count.ToString() + " , intGroupIndex = " + intGroupIndex.ToString() + " , intTemplateIndex = " + intTemplateIndex.ToString());
                return 0;
            }

            return m_arrTemplateSetting[intGroupIndex][intTemplateIndex].intFailOptionMask;
        }


        public int GetGroupCounter()
        {
            return m_arrTemplateSetting.Count;
        }

        public float GetGroupExtraMinArea()
        {
            switch (m_intDisplayUnitMode)
            {
                case 0: // Pixel
                    return m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fGroupExtraMinArea;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fGroupExtraMinArea * m_fMMPerPixelArea) * m_fMMToUnitValueArea;
                default:
                    return 0;
            }
        }

        public float GetGroupExtraMinArea(int intGroupIndex, int intTemplateIndex)
        {
            if (intTemplateIndex < 0)
                return 0;

            if (m_arrTemplateSetting.Count <= intGroupIndex)
                return 0;

            if (m_arrTemplateSetting[intGroupIndex].Count <= intTemplateIndex)
                return 0;

            switch (m_intDisplayUnitMode)
            {
                case 0: // Pixel
                    return m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fGroupExtraMinArea;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fGroupExtraMinArea * m_fMMPerPixelArea) * m_fMMToUnitValueArea;
                default:
                    return 0;
            }
        }
        public float GetGroupExcessMinArea()
        {
            switch (m_intDisplayUnitMode)
            {
                case 0: // Pixel
                    return m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fGroupExcessMinArea;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fGroupExcessMinArea * m_fMMPerPixelArea) * m_fMMToUnitValueArea;
                default:
                    return 0;
            }
        }

        public float GetGroupExcessMinArea(int intGroupIndex, int intTemplateIndex)
        {
            if (intTemplateIndex < 0)
                return 0;

            if (m_arrTemplateSetting.Count <= intGroupIndex)
                return 0;

            if (m_arrTemplateSetting[intGroupIndex].Count <= intTemplateIndex)
                return 0;

            switch (m_intDisplayUnitMode)
            {
                case 0: // Pixel
                    return m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fGroupExcessMinArea;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fGroupExcessMinArea * m_fMMPerPixelArea) * m_fMMToUnitValueArea;
                default:
                    return 0;
            }
        }
        public int GetMissingMinArea()
        {
            return m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intMissingMinArea;
        }

        public int GetMissingMinArea(int intGroupIndex, int intTemplateIndex)
        {
            if (intTemplateIndex < 0)
                return 0;

            if (m_arrTemplateSetting.Count <= intGroupIndex)
                return 0;

            if (m_arrTemplateSetting[intGroupIndex].Count <= intTemplateIndex)
                return 0;

            return m_arrTemplateSetting[intGroupIndex][intTemplateIndex].intMissingMinArea;
        }

        public int GetTextMinScore()
        {
            return m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intTextMinScore;
        }

        public int GetTextMinScore(int intGroupIndex, int intTemplateIndex)
        {
            if (intTemplateIndex < 0)
                return 0;

            if (m_arrTemplateSetting.Count <= intGroupIndex)
                return 0;

            if (m_arrTemplateSetting[intGroupIndex].Count <= intTemplateIndex)
                return 0;

            return m_arrTemplateSetting[intGroupIndex][intTemplateIndex].intTextMinScore;
        }

        public bool GetTextAnalysis(ref float fTempLocationScore, ref int intTempBackgroundArea, ref int intTempForegroundArea, ref float fTempBackgroundSum,
            ref float fTempForegroundSum, ref float fSampLocationScore, ref int intSampBackgroundArea, ref int intSampForegroundArea, ref float fSampBackgroundSum,
            ref float fSampForegroundSum, ref float fSampCorrelation, ref float fToleLocationScore, ref int intToleBackgroundArea, ref int intToleForegroundArea,
            ref float fToleBackgroundSum, ref float fToleForegroundSum, ref float fToleCorrelation, ref float fShiftXTole, ref float fShiftXMeasure, ref float fShiftYTole,
            ref float fShiftYMeasure, int intTextNo)
        {
            if (m_arrOCV[m_intGroupIndex][m_intTemplateIndex].GetTextAnalyisResult(ref fTempLocationScore, ref intTempBackgroundArea, ref intTempForegroundArea,
               ref fTempBackgroundSum, ref fTempForegroundSum, ref fSampLocationScore, ref intSampBackgroundArea, ref intSampForegroundArea, ref fSampBackgroundSum,
               ref fSampForegroundSum, ref fSampCorrelation, ref fToleLocationScore, ref intToleBackgroundArea, ref intToleForegroundArea, ref fToleBackgroundSum,
               ref fToleForegroundSum, ref fToleCorrelation, ref fShiftXTole, ref fShiftXMeasure, ref fShiftYTole, ref fShiftYMeasure, intTextNo))
                return true;
            else
                return false;
        }

        public bool GetCharAnalysis(ref float fTempLocationScore, ref int intTempBackgroundArea, ref int intTempForegroundArea, ref float fTempBackgroundSum,
            ref float fTempForegroundSum, ref float fSampLocationScore, ref int intSampBackgroundArea, ref int intSampForegroundArea, ref float fSampBackgroundSum,
            ref float fSampForegroundSum, ref float fSampCorrelation, ref float fToleLocationScore, ref int intToleBackgroundArea, ref int intToleForegroundArea,
            ref float fToleBackgroundSum, ref float fToleForegroundSum, ref float fToleCorrelation, ref float fShiftXTole, ref float fShiftXMeasure, ref float fShiftYTole,
            ref float fShiftYMeasure, int intCharNo)
        {
            if (m_arrOCV[m_intGroupIndex][m_intTemplateIndex].GetCharAnalyisResult(ref fTempLocationScore, ref intTempBackgroundArea, ref intTempForegroundArea,
                ref fTempBackgroundSum, ref fTempForegroundSum, ref fSampLocationScore, ref intSampBackgroundArea, ref intSampForegroundArea, ref fSampBackgroundSum,
                ref fSampForegroundSum, ref fSampCorrelation, ref fToleLocationScore, ref intToleBackgroundArea, ref intToleForegroundArea, ref fToleBackgroundSum,
                ref fToleForegroundSum, ref fToleCorrelation, ref fShiftXTole, ref fShiftXMeasure, ref fShiftYTole, ref fShiftYMeasure, intCharNo))
                return true;
            else
                return false;
        }

        public int GetThreshold()
        {
            if (m_arrTemplateSetting.Count > 0)
            {
                if (m_arrTemplateSetting[0].Count > 0)
                    return m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intThreshold;
            }

            return 0;
        }

        public int GetThreshold(int intGroupIndex, int intTemplateIndex)
        {
            if (m_arrTemplateSetting.Count > 0)
            {
                if (m_arrTemplateSetting[0].Count > 0)
                    return m_arrTemplateSetting[intGroupIndex][intTemplateIndex].intThreshold;
            }
            return 0;
        }
        public int GetExtraMarkThreshold()
        {
            if (m_arrTemplateSetting.Count > 0)
            {
                if (m_arrTemplateSetting[0].Count > 0)
                    return m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intExtraMarkThreshold;
            }

            return 0;
        }

        public int GetExtraMarkThreshold(int intGroupIndex, int intTemplateIndex)
        {
            if (m_arrTemplateSetting.Count > 0)
            {
                if (m_arrTemplateSetting[0].Count > 0)
                    return m_arrTemplateSetting[intGroupIndex][intTemplateIndex].intExtraMarkThreshold;
            }
            return 0;
        }
        public float GetCharROIOffsetX_InMM(float fValue)
        {
            switch (m_intDisplayUnitMode)
            {
                case 0: // Pixel
                    return (int)Math.Round(fValue);
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return (fValue * m_fMMPerPixelX) * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }
        public float GetCharROIOffsetY_InMM(float fValue)
        {
            switch (m_intDisplayUnitMode)
            {
                case 0: // Pixel
                    return (int)Math.Round(fValue);
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return (fValue * m_fMMPerPixelY) * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }
        public float GetCharROIOffsetX_InPixel(float fValue)
        {
            switch (m_intDisplayUnitMode)
            {
                case 0: // Pixel
                    return fValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return (fValue / m_fMMToUnitValue) / m_fMMPerPixelX;
                default:
                    return 0;
            }
        }
        public float GetCharROIOffsetY_InPixel(float fValue)
        {
            switch (m_intDisplayUnitMode)
            {
                case 0: // Pixel
                    return fValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return (fValue / m_fMMToUnitValue) / m_fMMPerPixelY;
                default:
                    return 0;
            }
        }

        public float GetNoMarkMaximumBlobArea_InMM(float fValue)
        {
            switch (m_intDisplayUnitMode)
            {
                case 0: // Pixel
                    return (int)Math.Round(fValue);
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return (fValue * m_fMMPerPixelArea) * m_fMMToUnitValueArea;
                default:
                    return 0;
            }
        }
        public float GetNoMarkMaximumBlobArea_InPixel(float fValue)
        {
            switch (m_intDisplayUnitMode)
            {
                case 0: // Pixel
                    return fValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return (fValue / m_fMMToUnitValueArea) / m_fMMPerPixelArea;
                default:
                    return 0;
            }
        }
        public float GetNoMarkMaximumBlobArea()
        {
            switch (m_intDisplayUnitMode)
            {
                case 0: // Pixel
                    return (int)Math.Round(m_fNoMarkMaximumBlobArea);
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return (m_fNoMarkMaximumBlobArea * m_fMMPerPixelArea) * m_fMMToUnitValueArea;
                default:
                    return 0;
            }
        }
        public float GetUnCheckAreaBottom()
        {
            switch (m_intDisplayUnitMode)
            {
                case 0: // Pixel
                    return m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fUnCheckAreaBottom;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fUnCheckAreaBottom * m_fMMPerPixelY) * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }

        public float GetUnCheckAreaBottom(int intGroupIndex, int intTemplateIndex)
        {
            if (intTemplateIndex < 0)
                return 0;

            if (m_arrTemplateSetting.Count <= intGroupIndex)
                return 0;

            if (m_arrTemplateSetting[intGroupIndex].Count <= intTemplateIndex)
                return 0;

            switch (m_intDisplayUnitMode)
            {
                case 0: // Pixel
                    return m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fUnCheckAreaBottom;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fUnCheckAreaBottom * m_fMMPerPixelY) * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }

        public float GetUnCheckAreaLeft()
        {
            switch (m_intDisplayUnitMode)
            {
                case 0: // Pixel
                    return m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fUnCheckAreaLeft;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fUnCheckAreaLeft * m_fMMPerPixelX) * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }

        public float GetUnCheckAreaLeft(int intGroupIndex, int intTemplateIndex)
        {
            if (intTemplateIndex < 0)
                return 0;

            if (m_arrTemplateSetting.Count <= intGroupIndex)
                return 0;

            if (m_arrTemplateSetting[intGroupIndex].Count <= intTemplateIndex)
                return 0;

            switch (m_intDisplayUnitMode)
            {
                case 0: // Pixel
                    return m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fUnCheckAreaLeft;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fUnCheckAreaLeft * m_fMMPerPixelX) * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }

        public float GetUnCheckAreaRight()
        {
            switch (m_intDisplayUnitMode)
            {
                case 0: // Pixel
                    return m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fUnCheckAreaRight;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fUnCheckAreaRight * m_fMMPerPixelX) * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }

        public float GetUnCheckAreaRight(int intGroupIndex, int intTemplateIndex)
        {
            if (intTemplateIndex < 0)
                return 0;

            if (m_arrTemplateSetting.Count <= intGroupIndex)
                return 0;

            if (m_arrTemplateSetting[intGroupIndex].Count <= intTemplateIndex)
                return 0;

            switch (m_intDisplayUnitMode)
            {
                case 0: // Pixel
                    return m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fUnCheckAreaRight;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fUnCheckAreaRight * m_fMMPerPixelX) * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }

        public float GetUnCheckAreaTop()
        {
            switch (m_intDisplayUnitMode)
            {
                case 0: // Pixel
                    return m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fUnCheckAreaTop;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fUnCheckAreaTop * m_fMMPerPixelY) * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }

        public float GetUnCheckAreaTop(int intGroupIndex, int intTemplateIndex)
        {
            if (intTemplateIndex < 0)
                return 0;

            if (m_arrTemplateSetting.Count <= intGroupIndex)
                return 0;

            if (m_arrTemplateSetting[intGroupIndex].Count <= intTemplateIndex)
                return 0;

            switch (m_intDisplayUnitMode)
            {
                case 0: // Pixel
                    return m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fUnCheckAreaTop;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fUnCheckAreaTop * m_fMMPerPixelY) * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }
        private string GetDecimalFormat()
        {
            switch (m_intDisplayUnitMode)
            {
                case 0:
                    return string.Empty;
                    break;
                case 1:
                case 2:
                case 3:
                    return ("F" + m_intDecimal);
                    break;
            }

            return string.Empty;
        }
        /// <summary>
        /// Get mark inspection fail message
        /// </summary>
        /// <param name="intUnitNo">Display unit number. Set -1 if does not want to display unit no.</param>
        /// <returns></returns>
        public string GetInspectionMessage(int intUnitNo, bool blnByPassUnit, int intMinMarkScore)
        {
            return GetInspectionMessage(intUnitNo, blnByPassUnit, intMinMarkScore, 1);
        }
        public string GetInspectionMessage(int intUnitNo, bool blnByPassUnit, int intMinMarkScore, int intUnitsOnImage)
        {
            if (m_strErrorMessage.Length != 0)
                return m_strErrorMessage;

            if (intUnitsOnImage == 2)
            {
                if (intUnitNo == 1)
                    m_strErrorMessage += "*Unit " + Convert.ToString(intUnitNo + 1) + "(Retest) :";
                else
                    m_strErrorMessage += "*Unit " + Convert.ToString(intUnitNo + 1) + "(Test) :";
            }

            if ((m_intFailResultMask & 0x400) > 0)
            {
                m_strErrorMessage += "*Sample string [" + m_objOCR.ref_strRecognizeString + "] not match with reference string!";
            }
            //if ((m_intFailResultMask & 0x200) > 0)
            //{
            //    NOCV objOCV = m_arrOCV[m_intGroupIndex][m_intTemplateIndex];
            //    int intNumText = objOCV.GetNumTexts();

            //    for (int i = 0; i < intNumText; i++)
            //    {
            //        if (m_blnTextResult[m_intTemplateIndex][i] == false)
            //        {
            //            int intSetValue = m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intTextMinScore;

            //            m_strErrorMessage += "*Fail Text - Template " + (m_intTemplateIndex + 1)
            //                          + ", Text " + (i + 1) + " : Set="
            //                          + intSetValue.ToString() + "% Score= "
            //                          + objOCV.GetTextScore(i).ToString("F2") + "%";
            //        }
            //    }
            //}
            if ((m_intFailResultMask & 0x100) > 0)
            {
                if (m_intInspectionMode == 0)
                {

                    NOCV objOCV = m_arrOCV[m_intGroupIndex][m_intTemplateIndex];
                    int intNumChars = objOCV.GetNumChars();

                    for (int i = 0; i < intNumChars; i++)
                    {
                        float fSetValue;
                        if (blnByPassUnit)
                        {
                            fSetValue = intMinMarkScore;
                        }
                        else
                        {
                            fSetValue = Convert.ToSingle(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting[i]);
                        }


                        if (objOCV.GetCharScore(i) < fSetValue)
                        {
                            m_strErrorMessage += "*Fail Mark - Template " + (m_intTemplateIndex + 1)
                                          + ", Mark " + (i + 1) + " : Set="
                                          + fSetValue.ToString() + "% Score= "
                                          + objOCV.GetCharScore(i).ToString("F2") + "%";
                        }
                    }
                }
                else
                {
                    int intNumChars = m_objOCR.ref_NumChars;

                    for (int i = 0; i < intNumChars; i++)
                    {
                        float fSetValue = Convert.ToSingle(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting[i]);
                        if (m_objOCR.GetCharScore(i) < fSetValue)
                        {
                            m_strErrorMessage += "*Fail Mark - Template " + (m_intTemplateIndex + 1)
                                          + ", Mark " + (i + 1) + " : Set="
                                          + fSetValue.ToString() + "% Score= "
                                          + m_objOCR.GetCharScore(i).ToString("F2") + "%";
                        }
                    }
                }
            }

            if ((m_intFailResultMask & 0x4000) > 0)
            {
                for (int i = 0; i < m_fAveGrayDiffBlobResult[m_intTemplateIndex].Length; i++)
                {
                    float fSetValue = Convert.ToSingle(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fMaxAGVPercent[i]);

                    if (m_fAveGrayDiffBlobResult[m_intTemplateIndex][i] != -999 && m_fAveGrayDiffBlobResult[m_intTemplateIndex][i] > fSetValue)
                    {
                        m_strErrorMessage += "*Fail Mark Average Gray Value - Template " + (m_intTemplateIndex + 1)
                                      + ", Mark " + (i + 1) + " : Set="
                                      + fSetValue.ToString("F2") + " Result= "
                                      + m_fAveGrayDiffBlobResult[m_intTemplateIndex][i].ToString("F2");
                    }
                }
            }

            if ((m_intFailResultMask & 0x40) > 0)
            {
                if (m_arrTextShiftedTop[m_intTemplateIndex] < (int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fUnCheckAreaTop))
                    m_strErrorMessage += "*Text Shifted Top! Set=" + GetUnCheckAreaTop(m_intGroupIndex, m_intTemplateIndex).ToString(GetDecimalFormat()) + " " + GetDisplayUnitName(m_intDisplayUnitMode, false) + ", Result =" + GetResultTextShiftedTop(m_intTemplateIndex).ToString(GetDecimalFormat()) + " " + GetDisplayUnitName(m_intDisplayUnitMode, false) + ".";
                if (m_arrTextShiftedLeft[m_intTemplateIndex] < (int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fUnCheckAreaLeft))
                    m_strErrorMessage += "*Text Shifted Left! Set=" + GetUnCheckAreaLeft(m_intGroupIndex, m_intTemplateIndex).ToString(GetDecimalFormat()) + " " + GetDisplayUnitName(m_intDisplayUnitMode, false) + ", Result =" + GetResultTextShiftedLeft(m_intTemplateIndex).ToString(GetDecimalFormat()) + " " + GetDisplayUnitName(m_intDisplayUnitMode, false) + ".";
                if (m_arrTextShiftedRight[m_intTemplateIndex] < (int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fUnCheckAreaRight))
                    m_strErrorMessage += "*Text Shifted Right! Set=" + GetUnCheckAreaRight(m_intGroupIndex, m_intTemplateIndex).ToString(GetDecimalFormat()) + " " + GetDisplayUnitName(m_intDisplayUnitMode, false) + ", Result =" + GetResultTextShiftedRight(m_intTemplateIndex).ToString(GetDecimalFormat()) + " " + GetDisplayUnitName(m_intDisplayUnitMode, false) + ".";
                if (m_arrTextShiftedBottom[m_intTemplateIndex] < (int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fUnCheckAreaBottom))
                    m_strErrorMessage += "*Text Shifted Bottom! Set=" + GetUnCheckAreaBottom(m_intGroupIndex, m_intTemplateIndex).ToString(GetDecimalFormat()) + " " + GetDisplayUnitName(m_intDisplayUnitMode, false) + ", Result =" + GetResultTextShiftedBottom(m_intTemplateIndex).ToString(GetDecimalFormat()) + " " + GetDisplayUnitName(m_intDisplayUnitMode, false) + ".";
            }
            if ((m_intFailResultMask & 0x01) > 0)
            {
                for (int i = 0; i < m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMaxExcessArea.Count; i++)
                {
                    if (m_arrCharExcessAreaResult[m_intTemplateIndex][i] > (int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMaxExcessArea[i]))
                    {
                        m_strErrorMessage += "*Excess Mark! Set = " + GetCharMaxExcessAreaSetting(i, m_intGroupIndex, m_intTemplateIndex).ToString(GetDecimalFormat()) +
                                        " " + GetDisplayUnitName(m_intDisplayUnitMode, true) + ", Result = " + GetCharExcessArea(i, m_intGroupIndex, m_intTemplateIndex).ToString(GetDecimalFormat()) + " " + GetDisplayUnitName(m_intDisplayUnitMode, true) + ".";
                    }
                }

                //m_strErrorMessage += "*Excess Mark! Smallest area=" + m_intSmallestExcessMarkArea[m_intTemplateIndex] +
                //                     " pix, Biggest area=" + m_intBiggestExcessMarkArea[m_intTemplateIndex] +
                //                     " pix, Set area=" + m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intExcessMinArea;
            }
            if ((m_intFailResultMask & 0x02) > 0 || (m_intFailResultMask & 0x04) > 0)
            {
                if (m_intSmallestExtraMarkArea[m_intTemplateIndex] == m_intBiggestExtraMarkArea[m_intTemplateIndex])
                {
                    m_strErrorMessage += "*Extra Mark! Set = " + GetExtraMinArea(m_intGroupIndex, m_intTemplateIndex).ToString(GetDecimalFormat()) +
                                         " " + GetDisplayUnitName(m_intDisplayUnitMode, true) + ", Result = " + GetResultBiggestExtraArea(m_intTemplateIndex).ToString(GetDecimalFormat()) + " " + GetDisplayUnitName(m_intDisplayUnitMode, true) + ".";
                }
                else
                {
                    m_strErrorMessage += "*Extra Mark! Set = " + GetExtraMinArea(m_intGroupIndex, m_intTemplateIndex).ToString(GetDecimalFormat()) +
                                         " " + GetDisplayUnitName(m_intDisplayUnitMode, true) + ", Result Range = From " + GetResultSmallestExtraArea(m_intTemplateIndex).ToString(GetDecimalFormat()) +
                                         " to " + GetResultBiggestExtraArea(m_intTemplateIndex).ToString(GetDecimalFormat()) + " " + GetDisplayUnitName(m_intDisplayUnitMode, true) + ".";
                }
            }
            if ((m_intFailResultMask & 0x08) > 0)
            {
                m_strErrorMessage += "*Total Extra Mark! Set=" + GetGroupExtraMinArea(m_intGroupIndex, m_intTemplateIndex).ToString(GetDecimalFormat()) + " " + GetDisplayUnitName(m_intDisplayUnitMode, true) + ", Result =" + GetResultGroupExtraArea(m_intTemplateIndex).ToString(GetDecimalFormat()) + " " + GetDisplayUnitName(m_intDisplayUnitMode, true) + ".";
            }
            if ((m_intFailResultMask & 0x2000) > 0)
            {
                m_strErrorMessage += "*Total Excess Mark! Set=" + GetGroupExcessMinArea(m_intGroupIndex, m_intTemplateIndex).ToString(GetDecimalFormat()) + " " + GetDisplayUnitName(m_intDisplayUnitMode, true) + ", Result =" + GetResultGroupExcessArea(m_intTemplateIndex).ToString(GetDecimalFormat()) + " " + GetDisplayUnitName(m_intDisplayUnitMode, true) + ".";
            }
            if ((m_intFailResultMask & 0x10) > 0)
            {
                if (m_intSmallestMissingMarkArea[m_intTemplateIndex] == int.MaxValue)
                    m_strErrorMessage += "*Missing Mark!"; // 2019-09-26 ZJYEOH : Missing is now changed to Broken
                else
                {
                    for (int i = 0; i < m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMaxBrokenArea.Count; i++)
                    {
                        if (i < m_arrCharBrokenAreaResult[m_intTemplateIndex].Length)  // 2020 06 01 - CCENG: Happen i value bigger than result length.
                        {
                            if (m_arrCharBrokenAreaResult[m_intTemplateIndex][i] > (int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMaxBrokenArea[i]))
                            {
                                // 2019-09-26 ZJYEOH : Missing is now changed to Broken
                                m_strErrorMessage += "*Missing Mark! Set = " + GetCharMaxBrokenAreaSetting(i, m_intGroupIndex, m_intTemplateIndex).ToString(GetDecimalFormat()) +
                                               " " + GetDisplayUnitName(m_intDisplayUnitMode, true) + ", Result = " + GetCharBrokenArea(i, m_intGroupIndex, m_intTemplateIndex).ToString(GetDecimalFormat()) + " " + GetDisplayUnitName(m_intDisplayUnitMode, true) + ".";
                            }
                        }
                    }

                    //if (m_intSmallestMissingMarkArea[m_intTemplateIndex] == m_intBiggestMissingMarkArea[m_intTemplateIndex])
                    //{
                    //    m_strErrorMessage += "*Missing Mark! Result = " + m_intBiggestMissingMarkArea[m_intTemplateIndex] +
                    //                         " pixel, Set = " + m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intMissingMinArea + " pixel.";
                    //}
                    //else
                    //{
                    //    m_strErrorMessage += "*Missing Mark! Result Range = From " + m_intSmallestMissingMarkArea[m_intTemplateIndex] +
                    //                         " to " + m_intBiggestMissingMarkArea[m_intTemplateIndex] +
                    //                         " pixel, Set = " + m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intMissingMinArea + " pixel.";
                    //}
                }
            }

            if ((m_intFailResultMask & 0x20) > 0)
            {
                for (int j = 0; j < m_arrCharBrokenMarkResult[m_intTemplateIndex].Length; j++)
                {
                    if (!m_arrCharBrokenMarkResult[m_intTemplateIndex][j])
                    {
                        m_strErrorMessage += "*Template " + (m_intTemplateIndex + 1) + " Mark " + (j + 1) + " : BrokenMark!";
                    }
                }
                if (m_fGroupBrokenMarkLength[m_intTemplateIndex] != 0)
                    m_strErrorMessage += "*Broken Mark! Set=" + m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intBrokenSize.ToString() + " pixel, Result =" + m_fGroupBrokenMarkLength[m_intTemplateIndex].ToString() + " pixel.";
            }

            if ((m_intFailResultMask & 0x80) > 0)
            {
                m_strErrorMessage += "*Joint Mark!";
            }

            return m_strErrorMessage;
        }

        public string GetRefChars(int intGroupIndex)
        {
            return m_arrRefChars[intGroupIndex];
        }

        public float GetResultSmallestExtraArea(int intTemplateIndex)
        {
            switch (m_intDisplayUnitMode)
            {
                case 0: // Pixel
                    return m_intSmallestExtraMarkArea[intTemplateIndex];
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return (m_intSmallestExtraMarkArea[intTemplateIndex] * m_fMMPerPixelArea) * m_fMMToUnitValueArea;
                default:
                    return 0;
            }
        }

        public float GetResultBiggestExtraArea(int intTemplateIndex)
        {
            switch (m_intDisplayUnitMode)
            {
                case 0: // Pixel
                    return m_intBiggestExtraMarkArea[intTemplateIndex];
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return (m_intBiggestExtraMarkArea[intTemplateIndex] * m_fMMPerPixelArea) * m_fMMToUnitValueArea;
                default:
                    return 0;
            }
        }

        public int GetResultBiggestExcessArea(int intTemplateIndex)
        {
            return m_intBiggestExcessMarkArea[intTemplateIndex];
        }

        public float GetResultGroupExtraArea(int intTemplateIndex)
        {
            switch (m_intDisplayUnitMode)
            {
                case 0: // Pixel
                    return m_intGroupExtraMarkArea[intTemplateIndex];
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return (m_intGroupExtraMarkArea[intTemplateIndex] * m_fMMPerPixelArea) * m_fMMToUnitValueArea;
                default:
                    return 0;
            }
        }
        public float GetResultGroupExcessArea(int intTemplateIndex)
        {
            switch (m_intDisplayUnitMode)
            {
                case 0: // Pixel
                    return m_intGroupExcessMarkArea[intTemplateIndex];
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return (m_intGroupExcessMarkArea[intTemplateIndex] * m_fMMPerPixelArea) * m_fMMToUnitValueArea;
                default:
                    return 0;
            }
        }

        public float GetResultMissingArea(int intTemplateIndex)
        {
            switch (m_intDisplayUnitMode)
            {
                case 0: // Pixel
                    return m_intSmallestMissingMarkArea[intTemplateIndex];
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return (m_intSmallestMissingMarkArea[intTemplateIndex] * m_fMMPerPixelArea) * m_fMMToUnitValueArea;
                default:
                    return 0;
            }
        }

        public int GetResultBiggestMissingArea(int intTemplateIndex)
        {
            return m_intBiggestMissingMarkArea[intTemplateIndex];
        }

        public float GetResultTextMatchScore(int intTemplateIndex)
        {
            return m_arrTestMatchScore[intTemplateIndex];
        }
        public float GetResultTotalBlobArea()
        {
            if (m_intTotalBlobArea != -1)
            {
                switch (m_intDisplayUnitMode)
                {
                    case 0: // Pixel
                        return m_intTotalBlobArea;
                    case 1: // mm
                    case 2: // mil
                    case 3: // micron
                        return (m_intTotalBlobArea * m_fMMPerPixelArea) * m_fMMToUnitValueArea;
                    default:
                        return 0;
                }
            }
            else
                return m_intTotalBlobArea;
        }
        public float GetResultTextShiftedTop(int intTemplateIndex)
        {
            if (m_arrTextShiftedTop[intTemplateIndex] != -999)
            {
                switch (m_intDisplayUnitMode)
                {
                    case 0: // Pixel
                        return m_arrTextShiftedTop[intTemplateIndex];
                    case 1: // mm
                    case 2: // mil
                    case 3: // micron
                        return (m_arrTextShiftedTop[intTemplateIndex] * m_fMMPerPixelY) * m_fMMToUnitValue;
                    default:
                        return 0;
                }
            }
            else
                return m_arrTextShiftedTop[intTemplateIndex];
        }

        public float GetResultTextShiftedBottom(int intTemplateIndex)
        {
            if (m_arrTextShiftedBottom[intTemplateIndex] != -999)
            {
                switch (m_intDisplayUnitMode)
                {
                    case 0: // Pixel
                        return m_arrTextShiftedBottom[intTemplateIndex];
                    case 1: // mm
                    case 2: // mil
                    case 3: // micron
                        return (m_arrTextShiftedBottom[intTemplateIndex] * m_fMMPerPixelY) * m_fMMToUnitValue;
                    default:
                        return 0;
                }
            }
            else
                return m_arrTextShiftedBottom[intTemplateIndex];
        }

        public float GetResultTextShiftedLeft(int intTemplateIndex)
        {
            if (m_arrTextShiftedLeft[intTemplateIndex] != -999)
            {
                switch (m_intDisplayUnitMode)
                {
                    case 0: // Pixel
                        return m_arrTextShiftedLeft[intTemplateIndex];
                    case 1: // mm
                    case 2: // mil
                    case 3: // micron
                        return (m_arrTextShiftedLeft[intTemplateIndex] * m_fMMPerPixelX) * m_fMMToUnitValue;
                    default:
                        return 0;
                }
            }
            else
                return m_arrTextShiftedLeft[intTemplateIndex];
        }

        public float GetResultTextShiftedRight(int intTemplateIndex)
        {
            if (m_arrTextShiftedRight[intTemplateIndex] != -999)
            {
                switch (m_intDisplayUnitMode)
                {
                    case 0: // Pixel
                        return m_arrTextShiftedRight[intTemplateIndex];
                    case 1: // mm
                    case 2: // mil
                    case 3: // micron
                        return (m_arrTextShiftedRight[intTemplateIndex] * m_fMMPerPixelX) * m_fMMToUnitValue;
                    default:
                        return 0;
                }
            }
            else
                return m_arrTextShiftedRight[intTemplateIndex];
        }

        public void AddTemplate(bool blnUseDefaultSetting)
        {
            if (m_intInspectionMode == 0)
                m_arrOCV[m_intGroupIndex].Add(GetNOCVSetting()); //m_arrOCV[m_intGroupIndex].Add(new NOCV(m_intImageWidth, m_intImageHeight));

            TemplateSetting objTemplateSetting = GetTemplateSetting(); //TemplateSetting objTemplateSetting = new TemplateSetting();
            if (blnUseDefaultSetting || m_arrTemplateSetting[m_intGroupIndex].Count == 0)
            {
                objTemplateSetting.intFailOptionMask = 0;
                objTemplateSetting.intBrokenSize = 10;
                objTemplateSetting.intCharShiftXY = 5;
                objTemplateSetting.fExtraMinArea = 20;
                objTemplateSetting.fGroupExtraMinArea = 200;
                objTemplateSetting.fGroupExcessMinArea = 100;
                objTemplateSetting.intExcessMinArea = 20;
                objTemplateSetting.intMissingMinArea = 30;
                objTemplateSetting.intTextMinScore = 50;
                objTemplateSetting.intThreshold = -4;
                objTemplateSetting.intExtraMarkThreshold = -4;
                objTemplateSetting.fUnCheckAreaBottom = 5;
                objTemplateSetting.fUnCheckAreaLeft = 5;
                objTemplateSetting.fUnCheckAreaRight = 5;
                objTemplateSetting.fUnCheckAreaTop = 5;
                objTemplateSetting.fMarkAngleTolerance = 15;
            }
            else
            {
                int intLastTemplateIndex = m_arrTemplateSetting[m_intGroupIndex].Count - 1;
                objTemplateSetting = m_arrTemplateSetting[m_intGroupIndex][intLastTemplateIndex];
            }
            m_arrTemplateSetting[m_intGroupIndex].Add(objTemplateSetting);
        }

        public void GetCharEndXY(int intCharIndex, ref int intEndX, ref int intEndY)
        {
            if (m_intInspectionMode == 0)
            {
                m_arrOCV[m_intGroupIndex][m_intTemplateIndex].GetCharEndXY(intCharIndex, ref intEndX, ref intEndY);
            }
            else
            {
                m_objOCR.GetCharEndPoint(intCharIndex, ref intEndX, ref intEndY);
            }
        }

        public void GetCharStartXY(int intCharIndex, ref int intStartX, ref int intStartY)
        {
            if (m_intInspectionMode == 0)
            {
                m_arrOCV[m_intGroupIndex][m_intTemplateIndex].GetCharStartXY(intCharIndex, ref intStartX, ref intStartY);
            }
            else
            {
                m_objOCR.GetCharStartPoint(intCharIndex, ref intStartX, ref intStartY);
            }
        }

        public void DrawBlobsLearnObjects(Graphics g, float fDrawingScaleX, float fDrawingScaleY)
        {
            lock (m_objLockLearningBlobs)
            {
                m_objLearnBlobs[m_intTemplateIndex].DrawSelectedBlobs(g, fDrawingScaleX, fDrawingScaleY);
            }
        }
        public void DrawBlobsROI(ROI objROI, string strpath)
        {
            lock (m_objLockLearningBlobs)
            {

                m_objLearnBlobs[m_intTemplateIndex].DrawSelectedBlobs(objROI, m_arrBuildOcvSelectStatus, m_arrBuildOcvStartX, m_arrBuildOcvStartY, m_arrBuildOcvEndX, m_arrBuildOcvEndY, strpath, m_arrBuildOcvSelectStatusPrev, m_arrBuildOcvCharShiftX, m_arrBuildOcvCharShiftY);
            }
        }

        public void DrawInspectedChars(Graphics g, bool blnMarkSelecting, int intMarkTextSelectedNo, int intMarkCharSelectedNo, float fDrawingScaleX, float fDrawingScaleY)
        {
            //lock (m_objLockBlobs)
            if (!m_blnLockBlobs)    // not allow to draw when mark inspection is in progress.
            {
                m_blnLockBlobs = true;

                if (m_intInspectionMode == 0)
                {
                    if (m_intGroupIndex < m_arrOCV.Count && m_intTemplateIndex < m_arrOCV[m_intGroupIndex].Count)
                    {
                        NOCV objOCV = m_arrOCV[m_intGroupIndex][m_intTemplateIndex];

                        if (objOCV.GetSampleText() != 0)
                        {

                            int intTextStartX = 0, intTextStartY = 0, intTextWidth = 0, intTextHeight = 0;
                            int intTextStartX_Scaled = 0, intTextStartY_Scaled = 0, intTextWidth_Scaled = 0, intTextHeight_Scaled = 0;
                            int intStartX, intStartY, intWidth, intHeight;
                            intStartX = intStartY = intWidth = intHeight = 0;


                            int intNumTexts = objOCV.GetNumTexts();
                            for (int i = 0; i < intNumTexts; i++)
                            {
                                if (m_blnLock)
                                {
                                    m_blnLockBlobs = false;
                                    return;
                                }

                                objOCV.GetTextStartXY(i, ref intTextStartX, ref intTextStartY);
                                objOCV.GetTextSize(i, ref intTextWidth, ref intTextHeight);

                                //if (i >= m_blnTextResult[m_intTemplateIndex].Length)
                                //    continue;

                                intTextStartX_Scaled = (int)Math.Round((m_intROIOffSetX + intTextStartX) * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                intTextStartY_Scaled = (int)Math.Round((m_intROIOffSetY + intTextStartY) * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                                intTextWidth_Scaled = (int)Math.Round(intTextWidth * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                                intTextHeight_Scaled = (int)Math.Round(intTextHeight * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);

                                //if (blnMarkSelecting)
                                //{
                                //    if (intMarkTextSelectedNo == i)
                                //    {
                                //        g.DrawRectangle(new Pen(Color.Lime), intTextStartX_Scaled, intTextStartY_Scaled, intTextWidth_Scaled, intTextHeight_Scaled);
                                //    }
                                //    else
                                //    {
                                //        g.DrawRectangle(new Pen(Color.Red), intTextStartX_Scaled, intTextStartY_Scaled, intTextWidth_Scaled, intTextHeight_Scaled);
                                //    }
                                //}
                                //else
                                //{
                                //    //if (m_blnTextResult[m_intTemplateIndex][i])
                                //    //{
                                //    g.DrawRectangle(new Pen(Color.Lime), intTextStartX_Scaled, intTextStartY_Scaled, intTextWidth_Scaled, intTextHeight_Scaled);
                                //    //}
                                //    //else
                                //    //{
                                //    //    g.DrawRectangle(new Pen(Color.Red), intTextStartX, intTextStartY, intTextWidth, intTextHeight);
                                //    //}
                                //}
                            }

                            int intNumChars = objOCV.GetNumChars();
                            for (int i = 0; i < intNumChars; i++)
                            {
                                if (m_blnLock)
                                {
                                    m_blnLockBlobs = false;
                                    return;
                                }

                                objOCV.GetCharStartXY(i, ref intStartX, ref intStartY);
                                objOCV.GetCharSize(i, ref intWidth, ref intHeight);

                                if (i >= m_blnCharResult[m_intTemplateIndex].Length)
                                    continue;

                                TemplateSetting objTemplateSetting = m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex];

                                if (i >= objTemplateSetting.intTextCharOffsetX.Count)
                                    continue;

                                if (i >= objTemplateSetting.fCharShiftX.Count)
                                    continue;

                                intStartX = (int)Math.Round((m_intROIOffSetX + intTextStartX + objTemplateSetting.intTextCharOffsetX[i] - (float)intWidth / 2 - ((int)Math.Round(objTemplateSetting.fCharShiftX[i] + m_fCharROIOffsetX))) * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                intStartY = (int)Math.Round((m_intROIOffSetY + intTextStartY + objTemplateSetting.intTextCharOffsetY[i] - (float)intHeight / 2 - ((int)Math.Round(objTemplateSetting.fCharShiftY[i] + m_fCharROIOffsetY))) * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                                intWidth = (int)Math.Round((intWidth + ((int)Math.Round(objTemplateSetting.fCharShiftX[i] + m_fCharROIOffsetX)) * 2) * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                intHeight = (int)Math.Round((intHeight + ((int)Math.Round(objTemplateSetting.fCharShiftY[i] + m_fCharROIOffsetY)) * 2) * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);


                                //intStartX = (int)Math.Round((m_intROIOffSetX + intStartX) * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                //intStartY = (int)Math.Round((m_intROIOffSetY + intStartY) * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                                //intWidth = (int)Math.Round(intWidth * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                                //intHeight = (int)Math.Round(intHeight * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);

                                if (blnMarkSelecting)
                                {
                                    if (intMarkCharSelectedNo == i)
                                    {
                                        g.DrawRectangle(new Pen(Color.Lime), intStartX, intStartY, intWidth, intHeight);
                                    }
                                    else
                                    {
                                        g.DrawRectangle(new Pen(Color.Red), intStartX, intStartY, intWidth, intHeight);
                                    }
                                }
                                else
                                {
                                    bool blnCheckBrokenMarkResult = false;
                                    if (m_arrCharBrokenMarkResult[m_intTemplateIndex] == null)  // if null mean broken mark is not ON, so can draw Green if only char pass.
                                        blnCheckBrokenMarkResult = true;
                                    else if (i >= m_arrCharBrokenMarkResult[m_intTemplateIndex].Length) // if index less mean broken mark is not all ON. So can draw Green if only char pass.
                                        blnCheckBrokenMarkResult = true;
                                    else if (m_arrCharBrokenMarkResult[m_intTemplateIndex][i])
                                        blnCheckBrokenMarkResult = true;

                                    if (m_blnCharResult[m_intTemplateIndex][i] &&
                                        blnCheckBrokenMarkResult)
                                    {
                                        g.DrawRectangle(new Pen(Color.Lime), intStartX, intStartY, intWidth, intHeight);
                                    }
                                    else
                                    {
                                        g.DrawRectangle(new Pen(Color.Red), intStartX, intStartY, intWidth, intHeight);
                                    }
                                }

                                // 01-08-2019 ZJYEOH : Draw "X" on disabled mark
                                if (!m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i])
                                {
                                    g.DrawRectangle(new Pen(Color.Lime), intStartX, intStartY, intWidth, intHeight);
                                    g.DrawLine(new Pen(Color.Lime, 1), intStartX, intStartY, intStartX + intWidth, intStartY + intHeight);
                                    g.DrawLine(new Pen(Color.Lime, 1), intStartX + intWidth, intStartY, intStartX, intStartY + intHeight);
                                }

                                g.DrawString(Convert.ToString(i + 1), m_Font, new SolidBrush(Color.Red),
                                             intStartX, intStartY - 3);
                            }
                        }
                    }
                }
                else
                {
                    int intStartX, intStartY, intWidth, intHeight;
                    intStartX = intStartY = intWidth = intHeight = 0;
                    int intNumChars = m_objOCR.ref_NumChars;
                    for (int i = 0; i < intNumChars; i++)
                    {
                        if (m_blnLock)
                        {
                            m_blnLockBlobs = false;
                            return;
                        }

                        m_objOCR.GetCharStartPoint(i, ref intStartX, ref intStartY);
                        m_objOCR.GetCharSize(i, ref intWidth, ref intHeight);

                        if (i >= m_blnCharResult[m_intTemplateIndex].Length)
                            continue;

                        if (m_blnCharResult[m_intTemplateIndex][i])
                        {
                            g.DrawRectangle(new Pen(Color.Lime), (float)m_intROIOffSetX + intStartX,
                                (float)m_intROIOffSetY + intStartY, intWidth, intHeight);
                        }
                        else
                        {
                            g.DrawRectangle(new Pen(Color.Red), (float)m_intROIOffSetX + intStartX,
                                (float)m_intROIOffSetY + intStartY, intWidth, intHeight);
                        }

                        g.DrawString(Convert.ToString(i + 1), m_Font, new SolidBrush(Color.Red),
                                     m_intROIOffSetX + intStartX, m_intROIOffSetY + intStartY - 3);
                    }
                }

                if (m_intBlobResult[m_intTemplateIndex] != null)
                {
                    //if (m_blnLock)
                    {
                        int intNoBlobs = m_intBlobResult[m_intTemplateIndex].Length;
                        for (int i = 0; i < intNoBlobs; i++)
                        {
                            if (m_intBlobResult[m_intTemplateIndex][i] == 2)
                                m_objBlobs[m_intTemplateIndex].DrawSelectedBlob(g, fDrawingScaleX, fDrawingScaleY, Color.Red, i);
                        }
                    }
                }

                if (m_intJointMarkBlobResult[m_intTemplateIndex] != null)
                {
                    //if (m_blnLock)
                    {
                        int intNoBlobs = m_intJointMarkBlobResult[m_intTemplateIndex].Length;
                        for (int i = 0; i < intNoBlobs; i++)
                        {
                            if (m_intJointMarkBlobResult[m_intTemplateIndex][i] == 2)
                                m_objJointMarkBlobs[m_intTemplateIndex].DrawSelectedBlob(g, fDrawingScaleX, fDrawingScaleY, Color.Red, i);
                        }
                    }
                }

                if (m_intExcessBlobResult[m_intTemplateIndex] != null)
                {
                    int intNoExcessBlobs = m_intExcessBlobResult[m_intTemplateIndex].Length;
                    for (int i = 0; i < intNoExcessBlobs; i++)
                    {
                        //if (m_blnLock)
                        //    return;

                        if (m_intExcessBlobResult[m_intTemplateIndex][i] == 2)
                            m_objExcessBlobs[m_intTemplateIndex].DrawSelectedBlob(g, fDrawingScaleX, fDrawingScaleY, Color.Red, i);

                    }
                }

                if (m_intMissingBlobResult[m_intTemplateIndex] != null)
                {
                    int intNoMissingBlobs = m_intMissingBlobResult[m_intTemplateIndex].Length;
                    for (int i = 0; i < intNoMissingBlobs; i++)
                    {
                        //if (m_blnLock)
                        //    return;

                        if (m_intMissingBlobResult[m_intTemplateIndex][i] == 2)
                            m_objMissingBlobs[m_intTemplateIndex].DrawSelectedBlob(g, fDrawingScaleX, fDrawingScaleY, Color.Red, i);
                    }
                }
            }

            if (m_blnLockBlobs)
                m_blnLockBlobs = false;
        }
        public void DrawInspectedChars_Rotate(Graphics g, bool blnMarkSelecting, int intMarkTextSelectedNo, int intMarkCharSelectedNo, float fDrawingScaleX, float fDrawingScaleY, float fOrientAngle)
        {
            //lock (m_objLockBlobs)
            if (!m_blnLockBlobs)    // not allow to draw when mark inspection is in progress.
            {
                m_blnLockBlobs = true;

                if (m_intInspectionMode == 0)
                {
                    if (m_intGroupIndex < m_arrOCV.Count && m_intTemplateIndex < m_arrOCV[m_intGroupIndex].Count)
                    {
                        NOCV objOCV = m_arrOCV[m_intGroupIndex][m_intTemplateIndex];

                        if (objOCV.GetSampleText() != 0)
                        {

                            int intTextStartX = 0, intTextStartY = 0, intTextWidth = 0, intTextHeight = 0;
                            int intTextStartX_Scaled = 0, intTextStartY_Scaled = 0, intTextWidth_Scaled = 0, intTextHeight_Scaled = 0;
                            int intStartX, intStartY, intWidth, intHeight;
                            intStartX = intStartY = intWidth = intHeight = 0;


                            int intNumTexts = objOCV.GetNumTexts();
                            for (int i = 0; i < intNumTexts; i++)
                            {
                                if (m_blnLock)
                                {
                                    m_blnLockBlobs = false;
                                    return;
                                }

                                objOCV.GetTextStartXY(i, ref intTextStartX, ref intTextStartY);
                                objOCV.GetTextSize(i, ref intTextWidth, ref intTextHeight);

                                //if (i >= m_blnTextResult[m_intTemplateIndex].Length)
                                //    continue;

                                intTextStartX_Scaled = (int)Math.Round((m_intROIOffSetX + intTextStartX) * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                intTextStartY_Scaled = (int)Math.Round((m_intROIOffSetY + intTextStartY) * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                                intTextWidth_Scaled = (int)Math.Round(intTextWidth * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                                intTextHeight_Scaled = (int)Math.Round(intTextHeight * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);

                                //if (blnMarkSelecting)
                                //{
                                //    if (intMarkTextSelectedNo == i)
                                //    {
                                //        g.DrawRectangle(new Pen(Color.Lime), intTextStartX_Scaled, intTextStartY_Scaled, intTextWidth_Scaled, intTextHeight_Scaled);
                                //    }
                                //    else
                                //    {
                                //        g.DrawRectangle(new Pen(Color.Red), intTextStartX_Scaled, intTextStartY_Scaled, intTextWidth_Scaled, intTextHeight_Scaled);
                                //    }
                                //}
                                //else
                                //{
                                //    //if (m_blnTextResult[m_intTemplateIndex][i])
                                //    //{
                                //    g.DrawRectangle(new Pen(Color.Lime), intTextStartX_Scaled, intTextStartY_Scaled, intTextWidth_Scaled, intTextHeight_Scaled);
                                //    //}
                                //    //else
                                //    //{
                                //    //    g.DrawRectangle(new Pen(Color.Red), intTextStartX, intTextStartY, intTextWidth, intTextHeight);
                                //    //}
                                //}
                            }

                            int intNumChars = objOCV.GetNumChars();
                            for (int i = 0; i < intNumChars; i++)
                            {
                                if (m_blnLock)
                                {
                                    m_blnLockBlobs = false;
                                    return;
                                }

                                objOCV.GetCharStartXY(i, ref intStartX, ref intStartY);
                                objOCV.GetCharSize(i, ref intWidth, ref intHeight);
                                Point pStart = objOCV.GetCharStartXY(i);
                                Point pEnd = objOCV.GetCharEndXY(i);
                                if (i >= m_blnCharResult[m_intTemplateIndex].Length)
                                    continue;

                                TemplateSetting objTemplateSetting = m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex];

                                if (i >= objTemplateSetting.intTextCharOffsetX.Count)
                                    continue;

                                if (i >= objTemplateSetting.fCharShiftX.Count)
                                    continue;

                                float newSX = 0, newSY = 0, newEX = 0, newEY = 0;
                                Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2, pStart.X, pStart.Y, -fOrientAngle, ref newSX, ref newSY);

                                Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2, pEnd.X, pEnd.Y, -fOrientAngle, ref newEX, ref newEY);
                                pStart = new Point((int)Math.Round(newSX), (int)Math.Round(newSY));
                                pEnd = new Point((int)Math.Round(newEX), (int)Math.Round(newEY));

                                List<Point> arrPoints = new List<Point>();
                                arrPoints.Add(pStart);
                                arrPoints.Add(new Point(pStart.X + (pEnd.X - pStart.X), pStart.Y));
                                arrPoints.Add(new Point(pStart.X, pStart.Y + (pEnd.Y - pStart.Y)));
                                arrPoints.Add(pEnd);

                                //PointF pTemp = new PointF();
                                //Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
                                //                                 arrPoints[0],
                                //                                 -(fOrientAngle),
                                //                                 ref pTemp);
                                //arrPoints[0] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

                                //Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
                                //                                 arrPoints[1],
                                //                                 -(fOrientAngle),
                                //                                 ref pTemp);
                                //arrPoints[1] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

                                //Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
                                //                                 arrPoints[2],
                                //                                 -(fOrientAngle),
                                //                                 ref pTemp);
                                //arrPoints[2] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

                                //Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
                                //                                 arrPoints[3],
                                //                                 -(fOrientAngle),
                                //                                 ref pTemp);
                                //arrPoints[3] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));
                                PointF pTemp = new PointF();
                                arrPoints[0] = new Point(arrPoints[0].X - ((int)Math.Round(objTemplateSetting.fCharShiftX[i] + m_fCharROIOffsetX)), arrPoints[0].Y - ((int)Math.Round(objTemplateSetting.fCharShiftY[i] + m_fCharROIOffsetY)));
                                arrPoints[1] = new Point(arrPoints[1].X + ((int)Math.Round(objTemplateSetting.fCharShiftX[i] + m_fCharROIOffsetX)), arrPoints[1].Y - ((int)Math.Round(objTemplateSetting.fCharShiftY[i] + m_fCharROIOffsetY)));
                                arrPoints[2] = new Point(arrPoints[2].X - ((int)Math.Round(objTemplateSetting.fCharShiftX[i] + m_fCharROIOffsetX)), arrPoints[2].Y + ((int)Math.Round(objTemplateSetting.fCharShiftY[i] + m_fCharROIOffsetY)));
                                arrPoints[3] = new Point(arrPoints[3].X + ((int)Math.Round(objTemplateSetting.fCharShiftX[i] + m_fCharROIOffsetX)), arrPoints[3].Y + ((int)Math.Round(objTemplateSetting.fCharShiftY[i] + m_fCharROIOffsetY)));

                                Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
                                                                 arrPoints[0],
                                                                 (fOrientAngle),
                                                                 ref pTemp);
                                arrPoints[0] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

                                Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
                                                                 arrPoints[1],
                                                                 (fOrientAngle),
                                                                 ref pTemp);
                                arrPoints[1] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

                                Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
                                                                 arrPoints[2],
                                                                 (fOrientAngle),
                                                                 ref pTemp);
                                arrPoints[2] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

                                Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
                                                                 arrPoints[3],
                                                                 (fOrientAngle),
                                                                 ref pTemp);
                                arrPoints[3] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

                                //intStartX = (int)Math.Round((m_intROIOffSetX + intTextStartX + objTemplateSetting.intTextCharOffsetX[i] - (float)intWidth / 2 - objTemplateSetting.intCharShiftX[i]) * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                //intStartY = (int)Math.Round((m_intROIOffSetY + intTextStartY + objTemplateSetting.intTextCharOffsetY[i] - (float)intHeight / 2 - objTemplateSetting.intCharShiftY[i]) * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                                //intWidth = (int)Math.Round((intWidth + objTemplateSetting.intCharShiftX[i] * 2) * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                //intHeight = (int)Math.Round((intHeight + objTemplateSetting.intCharShiftY[i] * 2) * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);


                                //intStartX = (int)Math.Round((m_intROIOffSetX + intStartX) * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                //intStartY = (int)Math.Round((m_intROIOffSetY + intStartY) * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                                //intWidth = (int)Math.Round(intWidth * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                                //intHeight = (int)Math.Round(intHeight * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);

                                if (blnMarkSelecting)
                                {
                                    if (intMarkCharSelectedNo == i)
                                    {
                                        //g.DrawRectangle(new Pen(Color.Lime), intStartX, intStartY, intWidth, intHeight);
                                        g.DrawLine(new Pen(Color.Lime),
                                            (m_intROIOffSetX + arrPoints[0].X) * fDrawingScaleX,
                                            (m_intROIOffSetY + arrPoints[0].Y) * fDrawingScaleY,
                                            (m_intROIOffSetX + arrPoints[1].X) * fDrawingScaleX,
                                            (m_intROIOffSetY + arrPoints[1].Y) * fDrawingScaleY);
                                        g.DrawLine(new Pen(Color.Lime),
                                           (m_intROIOffSetX + arrPoints[0].X) * fDrawingScaleX,
                                           (m_intROIOffSetY + arrPoints[0].Y) * fDrawingScaleY,
                                           (m_intROIOffSetX + arrPoints[2].X) * fDrawingScaleX,
                                           (m_intROIOffSetY + arrPoints[2].Y) * fDrawingScaleY);
                                        g.DrawLine(new Pen(Color.Lime),
                                           (m_intROIOffSetX + arrPoints[1].X) * fDrawingScaleX,
                                           (m_intROIOffSetY + arrPoints[1].Y) * fDrawingScaleY,
                                           (m_intROIOffSetX + arrPoints[3].X) * fDrawingScaleX,
                                           (m_intROIOffSetY + arrPoints[3].Y) * fDrawingScaleY);
                                        g.DrawLine(new Pen(Color.Lime),
                                           (m_intROIOffSetX + arrPoints[2].X) * fDrawingScaleX,
                                           (m_intROIOffSetY + arrPoints[2].Y) * fDrawingScaleY,
                                           (m_intROIOffSetX + arrPoints[3].X) * fDrawingScaleX,
                                           (m_intROIOffSetY + arrPoints[3].Y) * fDrawingScaleY);
                                    }
                                    else
                                    {
                                        //g.DrawRectangle(new Pen(Color.Red), intStartX, intStartY, intWidth, intHeight);
                                        g.DrawLine(new Pen(Color.Red),
                                        (m_intROIOffSetX + arrPoints[0].X) * fDrawingScaleX,
                                        (m_intROIOffSetY + arrPoints[0].Y) * fDrawingScaleY,
                                        (m_intROIOffSetX + arrPoints[1].X) * fDrawingScaleX,
                                        (m_intROIOffSetY + arrPoints[1].Y) * fDrawingScaleY);
                                        g.DrawLine(new Pen(Color.Red),
                                           (m_intROIOffSetX + arrPoints[0].X) * fDrawingScaleX,
                                           (m_intROIOffSetY + arrPoints[0].Y) * fDrawingScaleY,
                                           (m_intROIOffSetX + arrPoints[2].X) * fDrawingScaleX,
                                           (m_intROIOffSetY + arrPoints[2].Y) * fDrawingScaleY);
                                        g.DrawLine(new Pen(Color.Red),
                                           (m_intROIOffSetX + arrPoints[1].X) * fDrawingScaleX,
                                           (m_intROIOffSetY + arrPoints[1].Y) * fDrawingScaleY,
                                           (m_intROIOffSetX + arrPoints[3].X) * fDrawingScaleX,
                                           (m_intROIOffSetY + arrPoints[3].Y) * fDrawingScaleY);
                                        g.DrawLine(new Pen(Color.Red),
                                           (m_intROIOffSetX + arrPoints[2].X) * fDrawingScaleX,
                                           (m_intROIOffSetY + arrPoints[2].Y) * fDrawingScaleY,
                                           (m_intROIOffSetX + arrPoints[3].X) * fDrawingScaleX,
                                           (m_intROIOffSetY + arrPoints[3].Y) * fDrawingScaleY);
                                    }
                                }
                                else
                                {
                                    bool blnCheckBrokenMarkResult = false;
                                    if (m_arrCharBrokenMarkResult[m_intTemplateIndex] == null)  // if null mean broken mark is not ON, so can draw Green if only char pass.
                                        blnCheckBrokenMarkResult = true;
                                    else if (i >= m_arrCharBrokenMarkResult[m_intTemplateIndex].Length) // if index less mean broken mark is not all ON. So can draw Green if only char pass.
                                        blnCheckBrokenMarkResult = true;
                                    else if (m_arrCharBrokenMarkResult[m_intTemplateIndex][i])
                                        blnCheckBrokenMarkResult = true;

                                    if (m_blnCharResult[m_intTemplateIndex][i] &&
                                        blnCheckBrokenMarkResult)
                                    {
                                        //g.DrawRectangle(new Pen(Color.Lime), intStartX, intStartY, intWidth, intHeight);
                                        g.DrawLine(new Pen(Color.Lime),
                                            (m_intROIOffSetX + arrPoints[0].X) * fDrawingScaleX,
                                            (m_intROIOffSetY + arrPoints[0].Y) * fDrawingScaleY,
                                            (m_intROIOffSetX + arrPoints[1].X) * fDrawingScaleX,
                                            (m_intROIOffSetY + arrPoints[1].Y) * fDrawingScaleY);
                                        g.DrawLine(new Pen(Color.Lime),
                                           (m_intROIOffSetX + arrPoints[0].X) * fDrawingScaleX,
                                           (m_intROIOffSetY + arrPoints[0].Y) * fDrawingScaleY,
                                           (m_intROIOffSetX + arrPoints[2].X) * fDrawingScaleX,
                                           (m_intROIOffSetY + arrPoints[2].Y) * fDrawingScaleY);
                                        g.DrawLine(new Pen(Color.Lime),
                                           (m_intROIOffSetX + arrPoints[1].X) * fDrawingScaleX,
                                           (m_intROIOffSetY + arrPoints[1].Y) * fDrawingScaleY,
                                           (m_intROIOffSetX + arrPoints[3].X) * fDrawingScaleX,
                                           (m_intROIOffSetY + arrPoints[3].Y) * fDrawingScaleY);
                                        g.DrawLine(new Pen(Color.Lime),
                                           (m_intROIOffSetX + arrPoints[2].X) * fDrawingScaleX,
                                           (m_intROIOffSetY + arrPoints[2].Y) * fDrawingScaleY,
                                           (m_intROIOffSetX + arrPoints[3].X) * fDrawingScaleX,
                                           (m_intROIOffSetY + arrPoints[3].Y) * fDrawingScaleY);
                                    }
                                    else
                                    {
                                        //g.DrawRectangle(new Pen(Color.Red), intStartX, intStartY, intWidth, intHeight);
                                        g.DrawLine(new Pen(Color.Red),
                                        (m_intROIOffSetX + arrPoints[0].X) * fDrawingScaleX,
                                        (m_intROIOffSetY + arrPoints[0].Y) * fDrawingScaleY,
                                        (m_intROIOffSetX + arrPoints[1].X) * fDrawingScaleX,
                                        (m_intROIOffSetY + arrPoints[1].Y) * fDrawingScaleY);
                                        g.DrawLine(new Pen(Color.Red),
                                           (m_intROIOffSetX + arrPoints[0].X) * fDrawingScaleX,
                                           (m_intROIOffSetY + arrPoints[0].Y) * fDrawingScaleY,
                                           (m_intROIOffSetX + arrPoints[2].X) * fDrawingScaleX,
                                           (m_intROIOffSetY + arrPoints[2].Y) * fDrawingScaleY);
                                        g.DrawLine(new Pen(Color.Red),
                                           (m_intROIOffSetX + arrPoints[1].X) * fDrawingScaleX,
                                           (m_intROIOffSetY + arrPoints[1].Y) * fDrawingScaleY,
                                           (m_intROIOffSetX + arrPoints[3].X) * fDrawingScaleX,
                                           (m_intROIOffSetY + arrPoints[3].Y) * fDrawingScaleY);
                                        g.DrawLine(new Pen(Color.Red),
                                           (m_intROIOffSetX + arrPoints[2].X) * fDrawingScaleX,
                                           (m_intROIOffSetY + arrPoints[2].Y) * fDrawingScaleY,
                                           (m_intROIOffSetX + arrPoints[3].X) * fDrawingScaleX,
                                           (m_intROIOffSetY + arrPoints[3].Y) * fDrawingScaleY);
                                    }
                                }

                                // 01-08-2019 ZJYEOH : Draw "X" on disabled mark
                                if (!m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i])
                                {
                                    //g.DrawRectangle(new Pen(Color.Lime), intStartX, intStartY, intWidth, intHeight);
                                    //g.DrawLine(new Pen(Color.Lime, 1), intStartX, intStartY, intStartX + intWidth, intStartY + intHeight);
                                    //g.DrawLine(new Pen(Color.Lime, 1), intStartX + intWidth, intStartY, intStartX, intStartY + intHeight);
                                    g.DrawLine(new Pen(Color.Lime),
                                           (m_intROIOffSetX + arrPoints[0].X) * fDrawingScaleX,
                                           (m_intROIOffSetY + arrPoints[0].Y) * fDrawingScaleY,
                                           (m_intROIOffSetX + arrPoints[1].X) * fDrawingScaleX,
                                           (m_intROIOffSetY + arrPoints[1].Y) * fDrawingScaleY);
                                    g.DrawLine(new Pen(Color.Lime),
                                       (m_intROIOffSetX + arrPoints[0].X) * fDrawingScaleX,
                                       (m_intROIOffSetY + arrPoints[0].Y) * fDrawingScaleY,
                                       (m_intROIOffSetX + arrPoints[2].X) * fDrawingScaleX,
                                       (m_intROIOffSetY + arrPoints[2].Y) * fDrawingScaleY);
                                    g.DrawLine(new Pen(Color.Lime),
                                       (m_intROIOffSetX + arrPoints[1].X) * fDrawingScaleX,
                                       (m_intROIOffSetY + arrPoints[1].Y) * fDrawingScaleY,
                                       (m_intROIOffSetX + arrPoints[3].X) * fDrawingScaleX,
                                       (m_intROIOffSetY + arrPoints[3].Y) * fDrawingScaleY);
                                    g.DrawLine(new Pen(Color.Lime),
                                       (m_intROIOffSetX + arrPoints[2].X) * fDrawingScaleX,
                                       (m_intROIOffSetY + arrPoints[2].Y) * fDrawingScaleY,
                                       (m_intROIOffSetX + arrPoints[3].X) * fDrawingScaleX,
                                       (m_intROIOffSetY + arrPoints[3].Y) * fDrawingScaleY);

                                    g.DrawLine(new Pen(Color.Lime),
                                       (m_intROIOffSetX + arrPoints[0].X) * fDrawingScaleX,
                                       (m_intROIOffSetY + arrPoints[0].Y) * fDrawingScaleY,
                                       (m_intROIOffSetX + arrPoints[3].X) * fDrawingScaleX,
                                       (m_intROIOffSetY + arrPoints[3].Y) * fDrawingScaleY);
                                    g.DrawLine(new Pen(Color.Lime),
                                       (m_intROIOffSetX + arrPoints[1].X) * fDrawingScaleX,
                                       (m_intROIOffSetY + arrPoints[1].Y) * fDrawingScaleY,
                                       (m_intROIOffSetX + arrPoints[2].X) * fDrawingScaleX,
                                       (m_intROIOffSetY + arrPoints[2].Y) * fDrawingScaleY);
                                }

                                g.DrawString(Convert.ToString(i + 1), m_Font, new SolidBrush(Color.Red),
                                             (m_intROIOffSetX + arrPoints[0].X) * fDrawingScaleX,
                                           ((m_intROIOffSetY + arrPoints[0].Y) * fDrawingScaleY));
                            }
                        }
                    }
                }
                else
                {
                    int intStartX, intStartY, intWidth, intHeight;
                    intStartX = intStartY = intWidth = intHeight = 0;
                    int intNumChars = m_objOCR.ref_NumChars;
                    for (int i = 0; i < intNumChars; i++)
                    {
                        if (m_blnLock)
                        {
                            m_blnLockBlobs = false;
                            return;
                        }

                        m_objOCR.GetCharStartPoint(i, ref intStartX, ref intStartY);
                        m_objOCR.GetCharSize(i, ref intWidth, ref intHeight);

                        if (i >= m_blnCharResult[m_intTemplateIndex].Length)
                            continue;

                        if (m_blnCharResult[m_intTemplateIndex][i])
                        {
                            g.DrawRectangle(new Pen(Color.Lime), (float)m_intROIOffSetX + intStartX,
                                (float)m_intROIOffSetY + intStartY, intWidth, intHeight);
                        }
                        else
                        {
                            g.DrawRectangle(new Pen(Color.Red), (float)m_intROIOffSetX + intStartX,
                                (float)m_intROIOffSetY + intStartY, intWidth, intHeight);
                        }

                        g.DrawString(Convert.ToString(i + 1), m_Font, new SolidBrush(Color.Red),
                                     m_intROIOffSetX + intStartX, m_intROIOffSetY + intStartY - 3);
                    }
                }

                if (m_intBlobResult[m_intTemplateIndex] != null)
                {
                    //if (m_blnLock)
                    {
                        int intNoBlobs = m_intBlobResult[m_intTemplateIndex].Length;
                        for (int i = 0; i < intNoBlobs; i++)
                        {
                            if (m_intBlobResult[m_intTemplateIndex][i] == 2)
                                m_objBlobs[m_intTemplateIndex].DrawSelectedBlob(g, fDrawingScaleX, fDrawingScaleY, Color.Red, i);
                        }
                    }
                }

                if (m_intJointMarkBlobResult[m_intTemplateIndex] != null)
                {
                    //if (m_blnLock)
                    {
                        int intNoBlobs = m_intJointMarkBlobResult[m_intTemplateIndex].Length;
                        for (int i = 0; i < intNoBlobs; i++)
                        {
                            if (m_intJointMarkBlobResult[m_intTemplateIndex][i] == 2)
                                m_objJointMarkBlobs[m_intTemplateIndex].DrawSelectedBlob(g, fDrawingScaleX, fDrawingScaleY, Color.Red, i);
                        }
                    }
                }

                if (m_intExcessBlobResult[m_intTemplateIndex] != null)
                {
                    int intNoExcessBlobs = m_intExcessBlobResult[m_intTemplateIndex].Length;
                    for (int i = 0; i < intNoExcessBlobs; i++)
                    {
                        //if (m_blnLock)
                        //    return;

                        if (m_intExcessBlobResult[m_intTemplateIndex][i] == 2)
                            m_objExcessBlobs[m_intTemplateIndex].DrawSelectedBlob(g, fDrawingScaleX, fDrawingScaleY, Color.Red, i);

                    }
                }

                if (m_intMissingBlobResult[m_intTemplateIndex] != null)
                {
                    int intNoMissingBlobs = m_intMissingBlobResult[m_intTemplateIndex].Length;
                    for (int i = 0; i < intNoMissingBlobs; i++)
                    {
                        //if (m_blnLock)
                        //    return;

                        if (m_intMissingBlobResult[m_intTemplateIndex][i] == 2)
                            m_objMissingBlobs[m_intTemplateIndex].DrawSelectedBlob(g, fDrawingScaleX, fDrawingScaleY, Color.Red, i);
                    }
                }
            }

            if (m_blnLockBlobs)
                m_blnLockBlobs = false;
        }
        public void DrawInspectedChars_RotateToPackageAngle(Graphics g, bool blnMarkSelecting, int intMarkTextSelectedNo, int intMarkCharSelectedNo, float fDrawingScaleX, float fDrawingScaleY, float fAngle, PointF pCenterPoint)
        {
            //lock (m_objLockBlobs)
            if (!m_blnLockBlobs)    // not allow to draw when mark inspection is in progress.
            {
                m_blnLockBlobs = true;

                if (m_intInspectionMode == 0)
                {
                    if (m_intGroupIndex < m_arrOCV.Count && m_intTemplateIndex < m_arrOCV[m_intGroupIndex].Count)
                    {
                        NOCV objOCV = m_arrOCV[m_intGroupIndex][m_intTemplateIndex];

                        if (objOCV.GetSampleText() != 0)
                        {

                            int intTextStartX = 0, intTextStartY = 0, intTextWidth = 0, intTextHeight = 0;
                            int intTextStartX_Scaled = 0, intTextStartY_Scaled = 0, intTextWidth_Scaled = 0, intTextHeight_Scaled = 0;
                            int intStartX, intStartY, intWidth, intHeight;
                            intStartX = intStartY = intWidth = intHeight = 0;


                            int intNumTexts = objOCV.GetNumTexts();
                            for (int i = 0; i < intNumTexts; i++)
                            {
                                if (m_blnLock)
                                {
                                    m_blnLockBlobs = false;
                                    return;
                                }

                                objOCV.GetTextStartXY(i, ref intTextStartX, ref intTextStartY);
                                objOCV.GetTextSize(i, ref intTextWidth, ref intTextHeight);

                                //if (i >= m_blnTextResult[m_intTemplateIndex].Length)
                                //    continue;

                                intTextStartX_Scaled = (int)Math.Round((m_intROIOffSetX + intTextStartX) * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                intTextStartY_Scaled = (int)Math.Round((m_intROIOffSetY + intTextStartY) * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                                intTextWidth_Scaled = (int)Math.Round(intTextWidth * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                                intTextHeight_Scaled = (int)Math.Round(intTextHeight * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);

                                //if (blnMarkSelecting)
                                //{
                                //    if (intMarkTextSelectedNo == i)
                                //    {
                                //        g.DrawRectangle(new Pen(Color.Lime), intTextStartX_Scaled, intTextStartY_Scaled, intTextWidth_Scaled, intTextHeight_Scaled);
                                //    }
                                //    else
                                //    {
                                //        g.DrawRectangle(new Pen(Color.Red), intTextStartX_Scaled, intTextStartY_Scaled, intTextWidth_Scaled, intTextHeight_Scaled);
                                //    }
                                //}
                                //else
                                //{
                                //    //if (m_blnTextResult[m_intTemplateIndex][i])
                                //    //{
                                //    g.DrawRectangle(new Pen(Color.Lime), intTextStartX_Scaled, intTextStartY_Scaled, intTextWidth_Scaled, intTextHeight_Scaled);
                                //    //}
                                //    //else
                                //    //{
                                //    //    g.DrawRectangle(new Pen(Color.Red), intTextStartX, intTextStartY, intTextWidth, intTextHeight);
                                //    //}
                                //}
                            }

                            int intNumChars = objOCV.GetNumChars();
                            for (int i = 0; i < intNumChars; i++)
                            {
                                if (m_blnLock)
                                {
                                    m_blnLockBlobs = false;
                                    return;
                                }

                                objOCV.GetCharStartXY(i, ref intStartX, ref intStartY);
                                objOCV.GetCharSize(i, ref intWidth, ref intHeight);
                                Point pStart = objOCV.GetCharStartXY(i);
                                Point pEnd = objOCV.GetCharEndXY(i);
                                if (i >= m_blnCharResult[m_intTemplateIndex].Length)
                                    continue;

                                TemplateSetting objTemplateSetting = m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex];

                                if (i >= objTemplateSetting.intTextCharOffsetX.Count)
                                    continue;

                                if (i >= objTemplateSetting.fCharShiftX.Count)
                                    continue;

                                float newSX = 0, newSY = 0, newEX = 0, newEY = 0;
                                //Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2, pStart.X, pStart.Y, -fOrientAngle, ref newSX, ref newSY);

                                //Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2, pEnd.X, pEnd.Y, -fOrientAngle, ref newEX, ref newEY);
                                //pStart = new Point((int)Math.Round(newSX), (int)Math.Round(newSY));
                                //pEnd = new Point((int)Math.Round(newEX), (int)Math.Round(newEY));

                                List<Point> arrPoints = new List<Point>();
                                arrPoints.Add(pStart);
                                arrPoints.Add(new Point(pStart.X + (pEnd.X - pStart.X), pStart.Y));
                                arrPoints.Add(new Point(pStart.X, pStart.Y + (pEnd.Y - pStart.Y)));
                                arrPoints.Add(pEnd);

                                //PointF pTemp = new PointF();
                                //Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
                                //                                 arrPoints[0],
                                //                                 -(fOrientAngle),
                                //                                 ref pTemp);
                                //arrPoints[0] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

                                //Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
                                //                                 arrPoints[1],
                                //                                 -(fOrientAngle),
                                //                                 ref pTemp);
                                //arrPoints[1] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

                                //Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
                                //                                 arrPoints[2],
                                //                                 -(fOrientAngle),
                                //                                 ref pTemp);
                                //arrPoints[2] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

                                //Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
                                //                                 arrPoints[3],
                                //                                 -(fOrientAngle),
                                //                                 ref pTemp);
                                //arrPoints[3] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));
                                PointF pTemp = new PointF();
                                arrPoints[0] = new Point(m_intROIOffSetX + arrPoints[0].X - ((int)Math.Round(objTemplateSetting.fCharShiftX[i] + m_fCharROIOffsetX)), m_intROIOffSetY + arrPoints[0].Y - ((int)Math.Round(objTemplateSetting.fCharShiftY[i] + m_fCharROIOffsetY)));
                                arrPoints[1] = new Point(m_intROIOffSetX + arrPoints[1].X + ((int)Math.Round(objTemplateSetting.fCharShiftX[i] + m_fCharROIOffsetX)), m_intROIOffSetY + arrPoints[1].Y - ((int)Math.Round(objTemplateSetting.fCharShiftY[i] + m_fCharROIOffsetY)));
                                arrPoints[2] = new Point(m_intROIOffSetX + arrPoints[2].X - ((int)Math.Round(objTemplateSetting.fCharShiftX[i] + m_fCharROIOffsetX)), m_intROIOffSetY + arrPoints[2].Y + ((int)Math.Round(objTemplateSetting.fCharShiftY[i] + m_fCharROIOffsetY)));
                                arrPoints[3] = new Point(m_intROIOffSetX + arrPoints[3].X + ((int)Math.Round(objTemplateSetting.fCharShiftX[i] + m_fCharROIOffsetX)), m_intROIOffSetY + arrPoints[3].Y + ((int)Math.Round(objTemplateSetting.fCharShiftY[i] + m_fCharROIOffsetY)));

                                Math2.GetNewXYAfterRotate_360deg(pCenterPoint.X, pCenterPoint.Y,
                                                                 arrPoints[0],
                                                                 (fAngle),
                                                                 ref pTemp);
                                arrPoints[0] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

                                Math2.GetNewXYAfterRotate_360deg(pCenterPoint.X, pCenterPoint.Y,
                                                                 arrPoints[1],
                                                                 (fAngle),
                                                                 ref pTemp);
                                arrPoints[1] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

                                Math2.GetNewXYAfterRotate_360deg(pCenterPoint.X, pCenterPoint.Y,
                                                                 arrPoints[2],
                                                                 (fAngle),
                                                                 ref pTemp);
                                arrPoints[2] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

                                Math2.GetNewXYAfterRotate_360deg(pCenterPoint.X, pCenterPoint.Y,
                                                                 arrPoints[3],
                                                                 (fAngle),
                                                                 ref pTemp);
                                arrPoints[3] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

                                //intStartX = (int)Math.Round((m_intROIOffSetX + intTextStartX + objTemplateSetting.intTextCharOffsetX[i] - (float)intWidth / 2 - objTemplateSetting.intCharShiftX[i]) * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                //intStartY = (int)Math.Round((m_intROIOffSetY + intTextStartY + objTemplateSetting.intTextCharOffsetY[i] - (float)intHeight / 2 - objTemplateSetting.intCharShiftY[i]) * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                                //intWidth = (int)Math.Round((intWidth + objTemplateSetting.intCharShiftX[i] * 2) * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                //intHeight = (int)Math.Round((intHeight + objTemplateSetting.intCharShiftY[i] * 2) * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);


                                //intStartX = (int)Math.Round((m_intROIOffSetX + intStartX) * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                //intStartY = (int)Math.Round((m_intROIOffSetY + intStartY) * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                                //intWidth = (int)Math.Round(intWidth * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                                //intHeight = (int)Math.Round(intHeight * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);

                                if (blnMarkSelecting)
                                {
                                    if (intMarkCharSelectedNo == i)
                                    {
                                        //g.DrawRectangle(new Pen(Color.Lime), intStartX, intStartY, intWidth, intHeight);
                                        g.DrawLine(new Pen(Color.Lime),
                                            (arrPoints[0].X) * fDrawingScaleX,
                                            (arrPoints[0].Y) * fDrawingScaleY,
                                            (arrPoints[1].X) * fDrawingScaleX,
                                            (arrPoints[1].Y) * fDrawingScaleY);
                                        g.DrawLine(new Pen(Color.Lime),
                                           (arrPoints[0].X) * fDrawingScaleX,
                                           (arrPoints[0].Y) * fDrawingScaleY,
                                           (arrPoints[2].X) * fDrawingScaleX,
                                           (arrPoints[2].Y) * fDrawingScaleY);
                                        g.DrawLine(new Pen(Color.Lime),
                                           (arrPoints[1].X) * fDrawingScaleX,
                                           (arrPoints[1].Y) * fDrawingScaleY,
                                           (arrPoints[3].X) * fDrawingScaleX,
                                           (arrPoints[3].Y) * fDrawingScaleY);
                                        g.DrawLine(new Pen(Color.Lime),
                                           (arrPoints[2].X) * fDrawingScaleX,
                                           (arrPoints[2].Y) * fDrawingScaleY,
                                           (arrPoints[3].X) * fDrawingScaleX,
                                           (arrPoints[3].Y) * fDrawingScaleY);
                                    }
                                    else
                                    {
                                        //g.DrawRectangle(new Pen(Color.Red), intStartX, intStartY, intWidth, intHeight);
                                        g.DrawLine(new Pen(Color.Red),
                                        (arrPoints[0].X) * fDrawingScaleX,
                                        (arrPoints[0].Y) * fDrawingScaleY,
                                        (arrPoints[1].X) * fDrawingScaleX,
                                        (arrPoints[1].Y) * fDrawingScaleY);
                                        g.DrawLine(new Pen(Color.Red),
                                           (arrPoints[0].X) * fDrawingScaleX,
                                           (arrPoints[0].Y) * fDrawingScaleY,
                                           (arrPoints[2].X) * fDrawingScaleX,
                                           (arrPoints[2].Y) * fDrawingScaleY);
                                        g.DrawLine(new Pen(Color.Red),
                                           (arrPoints[1].X) * fDrawingScaleX,
                                           (arrPoints[1].Y) * fDrawingScaleY,
                                           (arrPoints[3].X) * fDrawingScaleX,
                                           (arrPoints[3].Y) * fDrawingScaleY);
                                        g.DrawLine(new Pen(Color.Red),
                                           (arrPoints[2].X) * fDrawingScaleX,
                                           (arrPoints[2].Y) * fDrawingScaleY,
                                           (arrPoints[3].X) * fDrawingScaleX,
                                           (arrPoints[3].Y) * fDrawingScaleY);
                                    }
                                }
                                else
                                {
                                    bool blnCheckBrokenMarkResult = false;
                                    if (m_arrCharBrokenMarkResult[m_intTemplateIndex] == null)  // if null mean broken mark is not ON, so can draw Green if only char pass.
                                        blnCheckBrokenMarkResult = true;
                                    else if (i >= m_arrCharBrokenMarkResult[m_intTemplateIndex].Length) // if index less mean broken mark is not all ON. So can draw Green if only char pass.
                                        blnCheckBrokenMarkResult = true;
                                    else if (m_arrCharBrokenMarkResult[m_intTemplateIndex][i])
                                        blnCheckBrokenMarkResult = true;

                                    if (m_blnCharResult[m_intTemplateIndex][i] &&
                                        blnCheckBrokenMarkResult)
                                    {
                                        //g.DrawRectangle(new Pen(Color.Lime), intStartX, intStartY, intWidth, intHeight);
                                        g.DrawLine(new Pen(Color.Lime),
                                            (arrPoints[0].X) * fDrawingScaleX,
                                            (arrPoints[0].Y) * fDrawingScaleY,
                                            (arrPoints[1].X) * fDrawingScaleX,
                                            (arrPoints[1].Y) * fDrawingScaleY);
                                        g.DrawLine(new Pen(Color.Lime),
                                           (arrPoints[0].X) * fDrawingScaleX,
                                           (arrPoints[0].Y) * fDrawingScaleY,
                                           (arrPoints[2].X) * fDrawingScaleX,
                                           (arrPoints[2].Y) * fDrawingScaleY);
                                        g.DrawLine(new Pen(Color.Lime),
                                           (arrPoints[1].X) * fDrawingScaleX,
                                           (arrPoints[1].Y) * fDrawingScaleY,
                                           (arrPoints[3].X) * fDrawingScaleX,
                                           (arrPoints[3].Y) * fDrawingScaleY);
                                        g.DrawLine(new Pen(Color.Lime),
                                           (arrPoints[2].X) * fDrawingScaleX,
                                           (arrPoints[2].Y) * fDrawingScaleY,
                                           (arrPoints[3].X) * fDrawingScaleX,
                                           (arrPoints[3].Y) * fDrawingScaleY);
                                    }
                                    else
                                    {
                                        //g.DrawRectangle(new Pen(Color.Red), intStartX, intStartY, intWidth, intHeight);
                                        g.DrawLine(new Pen(Color.Red),
                                        (arrPoints[0].X) * fDrawingScaleX,
                                        (arrPoints[0].Y) * fDrawingScaleY,
                                        (arrPoints[1].X) * fDrawingScaleX,
                                        (arrPoints[1].Y) * fDrawingScaleY);
                                        g.DrawLine(new Pen(Color.Red),
                                           (arrPoints[0].X) * fDrawingScaleX,
                                           (arrPoints[0].Y) * fDrawingScaleY,
                                           (arrPoints[2].X) * fDrawingScaleX,
                                           (arrPoints[2].Y) * fDrawingScaleY);
                                        g.DrawLine(new Pen(Color.Red),
                                           (arrPoints[1].X) * fDrawingScaleX,
                                           (arrPoints[1].Y) * fDrawingScaleY,
                                           (arrPoints[3].X) * fDrawingScaleX,
                                           (arrPoints[3].Y) * fDrawingScaleY);
                                        g.DrawLine(new Pen(Color.Red),
                                           (arrPoints[2].X) * fDrawingScaleX,
                                           (arrPoints[2].Y) * fDrawingScaleY,
                                           (arrPoints[3].X) * fDrawingScaleX,
                                           (arrPoints[3].Y) * fDrawingScaleY);
                                    }
                                }

                                // 01-08-2019 ZJYEOH : Draw "X" on disabled mark
                                if (!m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i])
                                {
                                    //g.DrawRectangle(new Pen(Color.Lime), intStartX, intStartY, intWidth, intHeight);
                                    //g.DrawLine(new Pen(Color.Lime, 1), intStartX, intStartY, intStartX + intWidth, intStartY + intHeight);
                                    //g.DrawLine(new Pen(Color.Lime, 1), intStartX + intWidth, intStartY, intStartX, intStartY + intHeight);
                                    g.DrawLine(new Pen(Color.Lime),
                                           (arrPoints[0].X) * fDrawingScaleX,
                                           (arrPoints[0].Y) * fDrawingScaleY,
                                           (arrPoints[1].X) * fDrawingScaleX,
                                           (arrPoints[1].Y) * fDrawingScaleY);
                                    g.DrawLine(new Pen(Color.Lime),
                                       (arrPoints[0].X) * fDrawingScaleX,
                                       (arrPoints[0].Y) * fDrawingScaleY,
                                       (arrPoints[2].X) * fDrawingScaleX,
                                       (arrPoints[2].Y) * fDrawingScaleY);
                                    g.DrawLine(new Pen(Color.Lime),
                                       (arrPoints[1].X) * fDrawingScaleX,
                                       (arrPoints[1].Y) * fDrawingScaleY,
                                       (arrPoints[3].X) * fDrawingScaleX,
                                       (arrPoints[3].Y) * fDrawingScaleY);
                                    g.DrawLine(new Pen(Color.Lime),
                                       (arrPoints[2].X) * fDrawingScaleX,
                                       (arrPoints[2].Y) * fDrawingScaleY,
                                       (arrPoints[3].X) * fDrawingScaleX,
                                       (arrPoints[3].Y) * fDrawingScaleY);

                                    g.DrawLine(new Pen(Color.Lime),
                                       (arrPoints[0].X) * fDrawingScaleX,
                                       (arrPoints[0].Y) * fDrawingScaleY,
                                       (arrPoints[3].X) * fDrawingScaleX,
                                       (arrPoints[3].Y) * fDrawingScaleY);
                                    g.DrawLine(new Pen(Color.Lime),
                                       (arrPoints[1].X) * fDrawingScaleX,
                                       (arrPoints[1].Y) * fDrawingScaleY,
                                       (arrPoints[2].X) * fDrawingScaleX,
                                       (arrPoints[2].Y) * fDrawingScaleY);
                                }

                                g.DrawString(Convert.ToString(i + 1), m_Font, new SolidBrush(Color.Red),
                                             (arrPoints[0].X) * fDrawingScaleX,
                                           ((arrPoints[0].Y) * fDrawingScaleY));
                            }
                        }
                    }
                }
                else
                {
                    int intStartX, intStartY, intWidth, intHeight;
                    intStartX = intStartY = intWidth = intHeight = 0;
                    int intNumChars = m_objOCR.ref_NumChars;
                    for (int i = 0; i < intNumChars; i++)
                    {
                        if (m_blnLock)
                        {
                            m_blnLockBlobs = false;
                            return;
                        }

                        m_objOCR.GetCharStartPoint(i, ref intStartX, ref intStartY);
                        m_objOCR.GetCharSize(i, ref intWidth, ref intHeight);

                        if (i >= m_blnCharResult[m_intTemplateIndex].Length)
                            continue;

                        if (m_blnCharResult[m_intTemplateIndex][i])
                        {
                            g.DrawRectangle(new Pen(Color.Lime), (float)m_intROIOffSetX + intStartX,
                                (float)m_intROIOffSetY + intStartY, intWidth, intHeight);
                        }
                        else
                        {
                            g.DrawRectangle(new Pen(Color.Red), (float)m_intROIOffSetX + intStartX,
                                (float)m_intROIOffSetY + intStartY, intWidth, intHeight);
                        }

                        g.DrawString(Convert.ToString(i + 1), m_Font, new SolidBrush(Color.Red),
                                     m_intROIOffSetX + intStartX, m_intROIOffSetY + intStartY - 3);
                    }
                }

                if (m_intBlobResult[m_intTemplateIndex] != null)
                {
                    //if (m_blnLock)
                    {
                        int intNoBlobs = m_intBlobResult[m_intTemplateIndex].Length;
                        for (int i = 0; i < intNoBlobs; i++)
                        {
                            if (m_intBlobResult[m_intTemplateIndex][i] == 2)
                                m_objBlobs[m_intTemplateIndex].DrawSelectedBlob(g, fDrawingScaleX, fDrawingScaleY, Color.Red, i);
                        }
                    }
                }

                if (m_intJointMarkBlobResult[m_intTemplateIndex] != null)
                {
                    //if (m_blnLock)
                    {
                        int intNoBlobs = m_intJointMarkBlobResult[m_intTemplateIndex].Length;
                        for (int i = 0; i < intNoBlobs; i++)
                        {
                            if (m_intJointMarkBlobResult[m_intTemplateIndex][i] == 2)
                                m_objJointMarkBlobs[m_intTemplateIndex].DrawSelectedBlob(g, fDrawingScaleX, fDrawingScaleY, Color.Red, i);
                        }
                    }
                }

                if (m_intExcessBlobResult[m_intTemplateIndex] != null)
                {
                    int intNoExcessBlobs = m_intExcessBlobResult[m_intTemplateIndex].Length;
                    for (int i = 0; i < intNoExcessBlobs; i++)
                    {
                        //if (m_blnLock)
                        //    return;

                        if (m_intExcessBlobResult[m_intTemplateIndex][i] == 2)
                            m_objExcessBlobs[m_intTemplateIndex].DrawSelectedBlob(g, fDrawingScaleX, fDrawingScaleY, Color.Red, i);

                    }
                }

                if (m_intMissingBlobResult[m_intTemplateIndex] != null)
                {
                    int intNoMissingBlobs = m_intMissingBlobResult[m_intTemplateIndex].Length;
                    for (int i = 0; i < intNoMissingBlobs; i++)
                    {
                        //if (m_blnLock)
                        //    return;

                        if (m_intMissingBlobResult[m_intTemplateIndex][i] == 2)
                            m_objMissingBlobs[m_intTemplateIndex].DrawSelectedBlob(g, fDrawingScaleX, fDrawingScaleY, Color.Red, i);
                    }
                }
            }

            if (m_blnLockBlobs)
                m_blnLockBlobs = false;
        }
        public void DrawTemplateNo(Graphics g, int intStartX, int intStartY, float fScale, int intZoomImageEdgeX, int intZoomImageEdgeY)
        {
            g.DrawString("Template " + Convert.ToString(m_intTemplateIndex + 1), m_Font, new SolidBrush(Color.Red), intStartX, intStartY);
        }

        private int GetTemplateNumberWithMostCharNum(string strFolderPath, int intSelectedTemplate)
        {
            int intMostCharNumTemplate = 0;
            int intMostCharNum = 0;
            XmlParser objFile = new XmlParser(strFolderPath + "Template.xml");

            for (int i = 0; i < m_intGroupNum; i++)
            {
                objFile.GetFirstSection("Group" + i);

                int intTemplateNum = objFile.GetValueAsInt("TemplateNum", 0);

                for (int j = 0; j < intTemplateNum; j++)
                {
                    if (intSelectedTemplate == j)
                        continue;

                    objFile.GetSecondSection("Template" + j);

                    int intCharNum = objFile.GetValueAsInt("CharNum", 0, 2);

                    if (intMostCharNum < intCharNum)
                    {
                        intMostCharNum = intCharNum;
                        intMostCharNumTemplate = j;
                    }
                }
            }
            return intMostCharNumTemplate;
        }
        private int GetTemplateNumberWithMostCharNum(string strFolderPath)
        {
            int intMostCharNumTemplate = 0;
            int intMostCharNum = 0;
            XmlParser objFile = new XmlParser(strFolderPath + "Template.xml");

            for (int i = 0; i < m_intGroupNum; i++)
            {
                objFile.GetFirstSection("Group" + i);

                int intTemplateNum = objFile.GetValueAsInt("TemplateNum", 0);

                for (int j = 0; j < intTemplateNum; j++)
                {
                    objFile.GetSecondSection("Template" + j);

                    int intCharNum = objFile.GetValueAsInt("CharNum", 0, 2);

                    if (intMostCharNum < intCharNum)
                    {
                        intMostCharNum = intCharNum;
                        intMostCharNumTemplate = j;
                    }
                }
            }
            return intMostCharNumTemplate;
        }
        public void SetPreviousTemplateSetingToOtherTemplate(string strFolderPath, List<List<ROI>> arrROIList, int intSelectedTemplate, int intDontCareROICount, ImageDrawing objWhiteImage)
        {
            XmlParser objFile = new XmlParser(strFolderPath + "Template.xml");
            objFile.GetFirstSection("MarkSettings");
            m_blnCheckMark = objFile.GetValueAsBoolean("CheckMark", true);
            m_intFailOptionMask = objFile.GetValueAsInt("FailOptionMask", 0);
            m_intFailOptionMask_ForPreTest = objFile.GetValueAsInt("FailOptionMask_ForPreTest", 0);
            m_intMinArea = objFile.GetValueAsInt("MinArea", 20);
            //m_intMarkROIOffsetTop = objFile.GetValueAsInt("MarkROIOffsetTop", 0);
            //m_intMarkROIOffsetRight = objFile.GetValueAsInt("MarkROIOffsetRight", 0);
            //m_intMarkROIOffsetBottom = objFile.GetValueAsInt("MarkROIOffsetBottom", 0);
            //m_intMarkROIOffsetLeft = objFile.GetValueAsInt("MarkROIOffsetLeft", 0);
            m_intLeadDontCareInwardTolerance_Top = objFile.GetValueAsInt("LeadDontCareInwardTolerance_Top", 0);
            m_intLeadDontCareInwardTolerance_Right = objFile.GetValueAsInt("LeadDontCareInwardTolerance_Right", 0);
            m_intLeadDontCareInwardTolerance_Bottom = objFile.GetValueAsInt("LeadDontCareInwardTolerance_Bottom", 0);
            m_intLeadDontCareInwardTolerance_Left = objFile.GetValueAsInt("LeadDontCareInwardTolerance_Left", 0);
            m_intMaxArea = objFile.GetValueAsInt("MaxArea", 100000);
            m_intCharErodeHalfWidth = objFile.GetValueAsInt("CharErodeHalfWidth", 1);
            m_intCharOpenHalfWidth = objFile.GetValueAsInt("CharOpenHalfWidth", 0);
            m_intCharDilateHalfWidth = objFile.GetValueAsInt("CharDilateHalfWidth", 1);
            m_intEnhanceMark_LinkMark_HalfWidth = objFile.GetValueAsInt("EnhanceMark_LinkMark_HalfWidth", 0);
            m_intEnhanceMark_ReduceNoise_HalfWidth = objFile.GetValueAsInt("EnhanceMark_ReduceNoise_HalfWidth", 0);
            m_intLearnMinArea = objFile.GetValueAsInt("LearnMinArea", 20);
            m_intTemplateMask = objFile.GetValueAsInt("TemplateMask", 0);
            m_intTemplatePriority = objFile.GetValueAsLong("TemplatePriority", 0);
            m_blnWhiteOnBlack = objFile.GetValueAsBoolean("WhiteOnBlack", true);

            for (int i = 0; i < m_intGroupNum; i++)
            {
                objFile.GetFirstSection("Group" + i);

                if (m_intInspectionMode == 0)
                {
                    //// Temporary hide it first as it will throw exception for m_BinaOcv when relearn mark image.
                    //for (int m = 0; m < m_arrOCV.Count; m++)
                    //{
                    //    for (int n = 0; n < m_arrOCV[m].Count; n++)
                    //    {
                    //        if (m_arrOCV[m][n] != null)
                    //        {
                    //            m_arrOCV[m][n].Dispose();
                    //            m_arrOCV[m][n] = null;
                    //        }

                    //    }
                    //}

                    ClearNOCVSettingArray(i, true);// m_arrOCV[i].Clear();
                }
                else
                    m_arrRefChars[i] = objFile.GetValueAsString("RefChar", "");

                int intTemplateNum = objFile.GetValueAsInt("TemplateNum", 0);

                //for (int m = 0; m < m_arrTemplateSetting.Count; m++)
                //{
                //    for (int n = 0; n < m_arrTemplateSetting[i].Count; n++)
                //    {
                //        m_arrTemplateSetting[m][n].objTemplateImage.Dispose();
                //        m_arrTemplateSetting[m][n].objLearnDilateImage.Dispose();
                //        m_arrTemplateSetting[m][n].objLearnErodeImage.Dispose();
                //        m_arrTemplateSetting[m][n].objDontCareImage.Dispose();

                //        for (int k = 0; k < m_arrTemplateSetting[m][n].arrTemplateTextROI.Count; k++)
                //        {
                //            if (m_arrTemplateSetting[m][n].arrTemplateTextROI[k] != null)
                //                m_arrTemplateSetting[m][n].arrTemplateTextROI[k].Dispose();
                //        }

                //        for (int k = 0; k < m_arrTemplateSetting[m][n].arrTemplateCharErodeROI.Count; k++)
                //        {
                //            if (m_arrTemplateSetting[m][n].arrTemplateCharErodeROI[k] != null)
                //                m_arrTemplateSetting[m][n].arrTemplateCharErodeROI[k].Dispose();
                //        }

                //        for (int k = 0; k < m_arrTemplateSetting[m][n].arrTemplateCharDilateROI.Count; k++)
                //        {
                //            if (m_arrTemplateSetting[m][n].arrTemplateCharDilateROI[k] != null)
                //                m_arrTemplateSetting[m][n].arrTemplateCharDilateROI[k].Dispose();
                //        }
                //    }
                //}

                ClearTemplateSettingArray(); // m_arrTemplateSetting[i].Clear();

                for (int j = 0; j < Math.Max(1, intTemplateNum); j++)
                {
                    if (j > 0 && j == intSelectedTemplate)//2021-12-26 ZJYEOH : Add j > 0 in the condition
                        objFile.GetSecondSection("Template" + (intSelectedTemplate - 1)); //j //2020-05-08 ZJYEOH : load previous template setting to set to other template
                    else
                        objFile.GetSecondSection("Template" + j);

                    XmlParser objOtherTemplateFile = new XmlParser(strFolderPath + "Template.xml");
                    objOtherTemplateFile.GetFirstSection("Group" + i);
                    objOtherTemplateFile.GetSecondSection("Template" + j);

                    TemplateSetting objTemplateSetting = GetTemplateSetting();  //TemplateSetting objTemplateSetting = new TemplateSetting();

                    objTemplateSetting.intFailOptionMask = objFile.GetValueAsInt("FailOptionMask", 0, 2);
                    objTemplateSetting.intBrokenSize = objFile.GetValueAsInt("BrokenSize", 10, 2);
                    objTemplateSetting.intCharShiftXY = objFile.GetValueAsInt("CharShiftXY", 5, 2);
                    objTemplateSetting.fExtraMinArea = objFile.GetValueAsFloat("ExtraMinArea", 20, 2);
                    objTemplateSetting.fGroupExtraMinArea = objFile.GetValueAsFloat("GroupExtraMinArea", 200, 2);
                    objTemplateSetting.fGroupExcessMinArea = objFile.GetValueAsFloat("GroupExcessMinArea", 100, 2);
                    objTemplateSetting.intExcessMinArea = objFile.GetValueAsInt("ExcessMinArea", 20, 2);
                    objTemplateSetting.intMissingMinArea = objFile.GetValueAsInt("MissingMinArea", 30, 2);
                    objTemplateSetting.intTextMinScore = objFile.GetValueAsInt("TextMinScore", 50, 2);

                    objTemplateSetting.intThreshold = objOtherTemplateFile.GetValueAsInt("Threshold", -4, 2); //objFile

                    objTemplateSetting.intExtraMarkThreshold = objOtherTemplateFile.GetValueAsInt("ExtraMarkThreshold", -4, 2); //objFile

                    objTemplateSetting.fUnCheckAreaBottom = objFile.GetValueAsFloat("UnCheckAreaBottom", 5, 2);
                    objTemplateSetting.fUnCheckAreaLeft = objFile.GetValueAsFloat("UnCheckAreaLeft", 5, 2);
                    objTemplateSetting.fUnCheckAreaRight = objFile.GetValueAsFloat("UnCheckAreaRight", 5, 2);
                    objTemplateSetting.fUnCheckAreaTop = objFile.GetValueAsFloat("UnCheckAreaTop", 5, 2);
                    objTemplateSetting.fMarkAngleTolerance = objFile.GetValueAsFloat("MarkAngleTolerance", 15, 2);



                    int intCharNum = objOtherTemplateFile.GetValueAsInt("CharNum", 0, 2); //objFile
                    int intCharNumTemplate1 = objFile.GetValueAsInt("CharNum", 0, 2);

                    objFile.GetThirdSection("CharSetting");
                    for (int k = 0; k < intCharNum; k++)
                    {
                        if (k < intCharNumTemplate1)
                            objTemplateSetting.intCharSetting.Add(objFile.GetValueAsInt("CharSetting" + k, m_intDefaultCharSetting, 3));
                        else
                            objTemplateSetting.intCharSetting.Add(objFile.GetValueAsInt("CharSetting" + (intCharNumTemplate1 - 1), m_intDefaultCharSetting, 3));
                    }

                    //2021-12-26 ZJYEOH : Use Own template Child node to load as CharDividedLargestArea are different for every template
                    objOtherTemplateFile.GetThirdSection("CharDividedLargestArea");
                    for (int k = 0; k < intCharNum; k++)
                    {
                        if (k < intCharNumTemplate1)
                            objTemplateSetting.intCharDividedLargestArea.Add(objOtherTemplateFile.GetValueAsInt("CharDividedLargestArea" + k, 0, 3));
                        else
                            objTemplateSetting.intCharDividedLargestArea.Add(objOtherTemplateFile.GetValueAsInt("CharDividedLargestArea" + (intCharNumTemplate1 - 1), 0, 3));
                    }

                    //2021-12-26 ZJYEOH : Use Own template Child node to load as AverageGray are different for every template
                    objOtherTemplateFile.GetThirdSection("AverageGray");
                    for (int k = 0; k < intCharNum; k++)
                    {
                        if (k < intCharNumTemplate1)
                            objTemplateSetting.fAverageGray.Add(objOtherTemplateFile.GetValueAsFloat("AverageGray" + k, 0, 3));
                        else
                            objTemplateSetting.fAverageGray.Add(objOtherTemplateFile.GetValueAsFloat("AverageGray" + (intCharNumTemplate1 - 1), 0, 3));
                    }

                    objFile.GetThirdSection("MaxAGVPercent");
                    for (int k = 0; k < intCharNum; k++)
                    {
                        if (k < intCharNumTemplate1)
                            objTemplateSetting.fMaxAGVPercent.Add(objFile.GetValueAsFloat("MaxAGVPercent" + k, 20, 3));
                        else
                            objTemplateSetting.fMaxAGVPercent.Add(objFile.GetValueAsFloat("MaxAGVPercent" + (intCharNumTemplate1 - 1), 20, 3));
                    }

                    objFile.GetThirdSection("MaxExcessArea");
                    for (int k = 0; k < intCharNum; k++)
                    {
                        if (k < intCharNumTemplate1)
                            objTemplateSetting.arrMaxExcessArea.Add(objFile.GetValueAsFloat("MaxExcessArea" + k, 50, 3));
                        else
                            objTemplateSetting.arrMaxExcessArea.Add(objFile.GetValueAsFloat("MaxExcessArea" + (intCharNumTemplate1 - 1), 50, 3));
                    }

                    objFile.GetThirdSection("MaxBrokenArea");
                    for (int k = 0; k < intCharNum; k++)
                    {
                        if (k < intCharNumTemplate1)
                            objTemplateSetting.arrMaxBrokenArea.Add(objFile.GetValueAsFloat("MaxBrokenArea" + k, 50, 3));
                        else
                            objTemplateSetting.arrMaxBrokenArea.Add(objFile.GetValueAsFloat("MaxBrokenArea" + (intCharNumTemplate1 - 1), 50, 3));
                    }

                    objFile.GetThirdSection("WantBrokenMark");
                    for (int k = 0; k < intCharNum; k++)
                    {
                        if (k < intCharNumTemplate1)
                            objTemplateSetting.arrWantBrokenMark.Add(objFile.GetValueAsBoolean("WantBrokenMark" + k, false, 3));
                        else
                            objTemplateSetting.arrWantBrokenMark.Add(objFile.GetValueAsBoolean("WantBrokenMark" + (intCharNumTemplate1 - 1), false, 3));
                    }

                    objFile.GetThirdSection("MarkType");
                    for (int k = 0; k < intCharNum; k++)
                    {
                        objTemplateSetting.arrMarkType.Add(objFile.GetValueAsInt("MarkType" + k, 0, 3));
                    }

                    objFile.GetThirdSection("CharShiftX");
                    objOtherTemplateFile.GetThirdSection("CharShiftX");
                    for (int k = 0; k < intCharNum; k++)
                    {
                        //// if current template setting not equal to default value, means user modify the value so need to keep the modified value
                        //if ((j == intSelectedTemplate) && (objOtherTemplateFile.GetValueAsInt("CharShiftX" + k, 5, 3) != 5))
                        //{
                        if (k < intCharNumTemplate1)
                            objTemplateSetting.fCharShiftX.Add(objOtherTemplateFile.GetValueAsFloat("CharShiftX" + k, 5, 3));
                        else
                            objTemplateSetting.fCharShiftX.Add(objOtherTemplateFile.GetValueAsFloat("CharShiftX" + (intCharNumTemplate1 - 1), 5, 3));
                        //}
                        //else
                        //{
                        //    if (k < intCharNumTemplate1)
                        //        objTemplateSetting.intCharShiftX.Add(objFile.GetValueAsInt("CharShiftX" + k, 5, 3));
                        //    else
                        //        objTemplateSetting.intCharShiftX.Add(objFile.GetValueAsInt("CharShiftX" + (intCharNumTemplate1 - 1), 5, 3));
                        //}
                    }

                    objFile.GetThirdSection("CharShiftY");
                    objOtherTemplateFile.GetThirdSection("CharShiftY");
                    for (int k = 0; k < intCharNum; k++)
                    {
                        //// if current template setting not equal to default value, means user modify the value so need to keep the modified value
                        //if ((j == intSelectedTemplate) && (objOtherTemplateFile.GetValueAsInt("CharShiftY" + k, 5, 3) != 5))
                        //{
                        if (k < intCharNumTemplate1)
                            objTemplateSetting.fCharShiftY.Add(objOtherTemplateFile.GetValueAsFloat("CharShiftY" + k, 5, 3));
                        else
                            objTemplateSetting.fCharShiftY.Add(objOtherTemplateFile.GetValueAsFloat("CharShiftY" + (intCharNumTemplate1 - 1), 5, 3));
                        //}
                        //else
                        //{
                        //    if (k < intCharNumTemplate1)
                        //        objTemplateSetting.intCharShiftY.Add(objFile.GetValueAsInt("CharShiftY" + k, 5, 3));
                        //    else
                        //        objTemplateSetting.intCharShiftY.Add(objFile.GetValueAsInt("CharShiftY" + (intCharNumTemplate1 - 1), 5, 3));
                        //}
                    }

                    //2020-05-08 ZJYEOH : reset back to current template because finish set to tolerance setting
                    objFile.GetSecondSection("Template" + j);

                    objFile.GetThirdSection("TextCharOffsetX");
                    for (int k = 0; k < intCharNum; k++)
                    {
                        objTemplateSetting.intTextCharOffsetX.Add(objFile.GetValueAsInt("TextCharOffsetX" + k, 0, 3));
                    }

                    objFile.GetThirdSection("TextCharOffsetY");
                    for (int k = 0; k < intCharNum; k++)
                    {
                        objTemplateSetting.intTextCharOffsetY.Add(objFile.GetValueAsInt("TextCharOffsetY" + k, 0, 3));
                    }

                    objFile.GetThirdSection("EnableMark");
                    for (int k = 0; k < intCharNum; k++)    // 2018 10 16 - CCENG: Use intCharNum to make sure blnEnable array count tally with intCharSetting array count. Not tally case will happen when use old recipe.
                    {
                        objTemplateSetting.blnEnable.Add(objFile.GetValueAsBoolean("EnableMark" + k, true, 3)); // 2018 10 16 - CCENG: Default is true because old recipe dun have this parameter. When load from oldd recipe, the mark must auto set to true.
                    }

                    objFile.GetThirdSection("IsBarPin1");
                    for (int k = 0; k < intCharNum; k++)
                    {
                        objTemplateSetting.blnIsBarPin1.Add(objFile.GetValueAsBoolean("IsBarPin1" + k, false, 3));
                    }

                    objFile.GetThirdSection("BarPin1Type");
                    for (int k = 0; k < intCharNum; k++)
                    {
                        objTemplateSetting.arrBarPin1Type.Add(objFile.GetValueAsInt("BarPin1Type" + k, 0, 3));
                    }

                    if (m_intInspectionMode == 0)
                    {
                        if (i < intTemplateNum)
                        {
                            m_arrOCV[i].Add(GetNOCVSetting());//m_arrOCV[i].Add(new NOCV(m_intImageWidth, m_intImageHeight));

                            objFile.GetThirdSection("CharNo");
                            for (int k = 0; k < intCharNum; k++)
                            {
                                m_arrOCV[i][j].SetCharNo(k, objFile.GetValueAsInt("CharNo" + k, k, 3));
                            }
                        }

                        objTemplateSetting.objTemplateImage.LoadImage(strFolderPath + "OriTemplate" + i + "_" + j + ".bmp");
                        objTemplateSetting.objDontCareImage.LoadImage(strFolderPath + "DontCareImage" + i + "_" + j + ".bmp");

                        //2021-05-01 ZJYEOH : dont care image will have individual image
                        for (int z = 0; z < intDontCareROICount; z++)
                        {
                            if (objTemplateSetting.arrDontCareImage.Count <= z)
                                objTemplateSetting.arrDontCareImage.Add(new ImageDrawing(true));

                            if (File.Exists(strFolderPath + "DontCareImage" + i + "_" + j + "_" + z + ".bmp"))
                                objTemplateSetting.arrDontCareImage[z].LoadImage(strFolderPath + "DontCareImage" + i + "_" + 0 + "_" + z + ".bmp"); //2021-05-01 ZJYEOH : Ori Index is i j z, but temporary fix j to 0 as now apply dont care to all template
                            else
                            {
                                objWhiteImage.CopyTo(ref objTemplateSetting.arrDontCareImage, z);
                            }
                        }

                        int intNumTexts = objFile.GetValueAsInt("TextNum", 0, 2);
                        objFile.GetThirdSection("TextROI");
                        for (int tx = 0; tx < intNumTexts; tx++)
                        {
                            objTemplateSetting.arrTemplateTextROI.Add(new ROI());
                            objTemplateSetting.arrTemplateTextROI[tx].LoadROISetting(
                                objFile.GetValueAsInt("TextROIStartX" + tx, 0, 3),
                                objFile.GetValueAsInt("TextROIStartY" + tx, 0, 3),
                                objFile.GetValueAsInt("TextROIWidth" + tx, 0, 3),
                                objFile.GetValueAsInt("TextROIHeight" + tx, 0, 3));

                            objTemplateSetting.arrTemplateTextROI[tx].AttachImage(objTemplateSetting.objTemplateImage);
                        }
                    }
                    else
                    {
                        m_objOCR.ClearTemplateChars();
                        objFile.GetThirdSection("TemplateCharOffSet");
                        int intTemplateCharNum = objFile.GetValueAsInt("TemplateCharOffSetNum", 0, 3);
                        for (int t = 0; t < intTemplateCharNum; t++)
                        {
                            m_objOCR.SetTemplateCharOffSetXY(t,
                                objFile.GetValueAsInt("CharOffSetX" + t, 0, 3),
                                objFile.GetValueAsInt("CharOffSetY" + t, 0, 3));

                            m_objOCR.SetTemplateCharStartPoint(t,
                                objFile.GetValueAsInt("CharStartX" + t, 0, 3),
                                objFile.GetValueAsInt("CharStartY" + t, 0, 3));

                            m_objOCR.SetTemplateCharEndPoint(t,
                                objFile.GetValueAsInt("CharEndX" + t, 0, 3),
                                objFile.GetValueAsInt("CharEndY" + t, 0, 3));

                            m_objOCR.SetTemplateCharSize(t,
                                objFile.GetValueAsInt("CharWidth" + t, 0, 3),
                                objFile.GetValueAsInt("CharHeight" + t, 0, 3));
                        }
                    }

                    m_arrTemplateSetting[i].Add(objTemplateSetting);
                }
            }

            if (m_arrTemplateSetting[m_intGroupIndex].Count > 0)
            {
                m_intTemplateIndex = 0;

                if ((m_intTemplateMask & 0x01) == 0)
                {
                    if ((m_intTemplateMask & 0x02) > 0)
                        m_intTemplateIndex = 1;
                    else if ((m_intTemplateMask & 0x04) > 0)
                        m_intTemplateIndex = 2;
                    else if ((m_intTemplateMask & 0x08) > 0)
                        m_intTemplateIndex = 3;
                    else if ((m_intTemplateMask & 0x10) > 0)
                        m_intTemplateIndex = 4;
                    else if ((m_intTemplateMask & 0x20) > 0)
                        m_intTemplateIndex = 5;
                    else if ((m_intTemplateMask & 0x40) > 0)
                        m_intTemplateIndex = 6;
                    else if ((m_intTemplateMask & 0x80) > 0)
                        m_intTemplateIndex = 7;
                }
            }
            else
                m_intTemplateIndex = -1;

            if (m_intInspectionMode == 0)
            {
                // Load OCV objects
                for (int i = 0; i < m_intGroupNum; i++)
                {
                    for (int j = 0; j < m_arrOCV[i].Count; j++)
                    {
                        if (File.Exists(strFolderPath + "Template" + i + "_" + j + ".ocv"))
                            m_arrOCV[i][j].LoadOCVFile(strFolderPath + "Template" + i + "_" + j + ".ocv");

                        ImageDrawing objMarkImage = new ImageDrawing();
                        if (File.Exists(strFolderPath + "Template" + i + "_" + j + ".bmp"))
                            objMarkImage.ref_objMainImage.Load(strFolderPath + "Template" + i + "_" + j + ".bmp");
                        //2021-01-03 ZJYEOH : Load Individual Blob Image
                        List<ImageDrawing> arrOCVImage = new List<ImageDrawing>();
                        int intOCVNum = m_arrTemplateSetting[i][j].intCharSetting.Count;
                        for (int k = 0; k < intOCVNum; k++)
                        {
                            arrOCVImage.Add(new ImageDrawing(true));
                            if (File.Exists(strFolderPath + "OCVTemplate" + i + "_" + j + "_" + k + ".bmp"))
                                arrOCVImage[k].ref_objMainImage.Load(strFolderPath + "OCVTemplate" + i + "_" + j + "_" + k + ".bmp");
                            else
                            {
                                if (File.Exists(strFolderPath + "Template" + i + "_" + j + ".bmp"))
                                    arrOCVImage[k].ref_objMainImage.Load(strFolderPath + "Template" + i + "_" + j + ".bmp");
                            }
                        }
                        ROI objMarkROI = new ROI();
                        objMarkROI.LoadROISetting(0, 0, objMarkImage.ref_intImageWidth, objMarkImage.ref_intImageHeight);
                        objMarkROI.AttachImage(objMarkImage);
                        ImageDrawing objOriTemplateImage = new ImageDrawing();
                        if (File.Exists(strFolderPath + "OriTemplate" + i + "_" + j + ".bmp"))
                            objOriTemplateImage.ref_objMainImage.Load(strFolderPath + "OriTemplate" + i + "_" + j + ".bmp");
                        SetErodeDilateSettings(objOriTemplateImage, objMarkImage, arrOCVImage, m_arrTemplateSetting[i][j], m_arrOCV[i][j], objMarkROI);

                        for (int k = 0; k < arrOCVImage.Count; k++)
                            arrOCVImage[k].Dispose();
                        objMarkImage.Dispose();
                        objOriTemplateImage.Dispose();
                        objMarkROI.Dispose();

                    }
                }
            }
            else
            {
                // Load OCR objects
                m_objOCR.Load(strFolderPath);

                if (m_intGroupNum == 1)
                    m_objOCR.SetRefCharCounter(m_arrRefChars[0]);
            }

        }
        public void SetCurrentTemplateSetingForExtraCharLearnt(string strFolderPath, List<List<ROI>> arrROIList, int intDontCareROICount, ImageDrawing objWhiteImage)
        {
            XmlParser objFile = new XmlParser(strFolderPath + "Template.xml");
            objFile.GetFirstSection("MarkSettings");
            m_blnCheckMark = objFile.GetValueAsBoolean("CheckMark", true);
            m_intFailOptionMask = objFile.GetValueAsInt("FailOptionMask", 0);
            m_intFailOptionMask_ForPreTest = objFile.GetValueAsInt("FailOptionMask_ForPreTest", 0);
            m_intMinArea = objFile.GetValueAsInt("MinArea", 20);
            //m_intMarkROIOffsetTop = objFile.GetValueAsInt("MarkROIOffsetTop", 0);
            //m_intMarkROIOffsetRight = objFile.GetValueAsInt("MarkROIOffsetRight", 0);
            //m_intMarkROIOffsetBottom = objFile.GetValueAsInt("MarkROIOffsetBottom", 0);
            //m_intMarkROIOffsetLeft = objFile.GetValueAsInt("MarkROIOffsetLeft", 0);
            m_intLeadDontCareInwardTolerance_Top = objFile.GetValueAsInt("LeadDontCareInwardTolerance_Top", 0);
            m_intLeadDontCareInwardTolerance_Right = objFile.GetValueAsInt("LeadDontCareInwardTolerance_Right", 0);
            m_intLeadDontCareInwardTolerance_Bottom = objFile.GetValueAsInt("LeadDontCareInwardTolerance_Bottom", 0);
            m_intLeadDontCareInwardTolerance_Left = objFile.GetValueAsInt("LeadDontCareInwardTolerance_Left", 0);
            m_intMaxArea = objFile.GetValueAsInt("MaxArea", 100000);
            m_intCharErodeHalfWidth = objFile.GetValueAsInt("CharErodeHalfWidth", 1);
            m_intCharOpenHalfWidth = objFile.GetValueAsInt("CharOpenHalfWidth", 0);
            m_intCharDilateHalfWidth = objFile.GetValueAsInt("CharDilateHalfWidth", 1);
            m_intEnhanceMark_LinkMark_HalfWidth = objFile.GetValueAsInt("EnhanceMark_LinkMark_HalfWidth", 0);
            m_intEnhanceMark_ReduceNoise_HalfWidth = objFile.GetValueAsInt("EnhanceMark_ReduceNoise_HalfWidth", 0);
            m_intLearnMinArea = objFile.GetValueAsInt("LearnMinArea", 20);
            m_intTemplateMask = objFile.GetValueAsInt("TemplateMask", 0);
            m_intTemplatePriority = objFile.GetValueAsLong("TemplatePriority", 0);
            m_blnWhiteOnBlack = objFile.GetValueAsBoolean("WhiteOnBlack", true);

            for (int i = 0; i < m_intGroupNum; i++)
            {
                objFile.GetFirstSection("Group" + i);

                if (m_intInspectionMode == 0)
                {
                    //// Temporary hide it first as it will throw exception for m_BinaOcv when relearn mark image.
                    //for (int m = 0; m < m_arrOCV.Count; m++)
                    //{
                    //    for (int n = 0; n < m_arrOCV[m].Count; n++)
                    //    {
                    //        if (m_arrOCV[m][n] != null)
                    //        {
                    //            m_arrOCV[m][n].Dispose();
                    //            m_arrOCV[m][n] = null;
                    //        }

                    //    }
                    //}

                    ClearNOCVSettingArray(i, true);//m_arrOCV[i].Clear();
                }
                else
                    m_arrRefChars[i] = objFile.GetValueAsString("RefChar", "");

                int intTemplateNum = objFile.GetValueAsInt("TemplateNum", 0);

                //for (int m = 0; m < m_arrTemplateSetting.Count; m++)
                //{
                //    for (int n = 0; n < m_arrTemplateSetting[i].Count; n++)
                //    {
                //        m_arrTemplateSetting[m][n].objTemplateImage.Dispose();
                //        m_arrTemplateSetting[m][n].objLearnDilateImage.Dispose();
                //        m_arrTemplateSetting[m][n].objLearnErodeImage.Dispose();
                //        m_arrTemplateSetting[m][n].objDontCareImage.Dispose();

                //        for (int k = 0; k < m_arrTemplateSetting[m][n].arrTemplateTextROI.Count; k++)
                //        {
                //            if (m_arrTemplateSetting[m][n].arrTemplateTextROI[k] != null)
                //                m_arrTemplateSetting[m][n].arrTemplateTextROI[k].Dispose();
                //        }

                //        for (int k = 0; k < m_arrTemplateSetting[m][n].arrTemplateCharErodeROI.Count; k++)
                //        {
                //            if (m_arrTemplateSetting[m][n].arrTemplateCharErodeROI[k] != null)
                //                m_arrTemplateSetting[m][n].arrTemplateCharErodeROI[k].Dispose();
                //        }

                //        for (int k = 0; k < m_arrTemplateSetting[m][n].arrTemplateCharDilateROI.Count; k++)
                //        {
                //            if (m_arrTemplateSetting[m][n].arrTemplateCharDilateROI[k] != null)
                //                m_arrTemplateSetting[m][n].arrTemplateCharDilateROI[k].Dispose();
                //        }
                //    }
                //}

                ClearTemplateSettingArray(); //m_arrTemplateSetting[i].Clear();

                for (int j = 0; j < Math.Max(1, intTemplateNum); j++)
                {
                    objFile.GetSecondSection("Template" + j); //j //2020-05-08 ZJYEOH : Always load Higest Char Number template setting to set to other template

                    //XmlParser objOtherTemplateFile = new XmlParser(strFolderPath + "Template.xml");
                    //objOtherTemplateFile.GetFirstSection("Group" + i);
                    //objOtherTemplateFile.GetSecondSection("Template" + j);

                    TemplateSetting objTemplateSetting = GetTemplateSetting(); //TemplateSetting objTemplateSetting = new TemplateSetting();
                    objTemplateSetting.intFailOptionMask = objFile.GetValueAsInt("FailOptionMask", 0, 2);
                    objTemplateSetting.intBrokenSize = objFile.GetValueAsInt("BrokenSize", 10, 2);
                    objTemplateSetting.intCharShiftXY = objFile.GetValueAsInt("CharShiftXY", 5, 2);
                    objTemplateSetting.fExtraMinArea = objFile.GetValueAsFloat("ExtraMinArea", 20, 2);
                    objTemplateSetting.fGroupExtraMinArea = objFile.GetValueAsFloat("GroupExtraMinArea", 200, 2);
                    objTemplateSetting.fGroupExcessMinArea = objFile.GetValueAsFloat("GroupExcessMinArea", 100, 2);
                    objTemplateSetting.intExcessMinArea = objFile.GetValueAsInt("ExcessMinArea", 20, 2);
                    objTemplateSetting.intMissingMinArea = objFile.GetValueAsInt("MissingMinArea", 30, 2);
                    objTemplateSetting.intTextMinScore = objFile.GetValueAsInt("TextMinScore", 50, 2);

                    objTemplateSetting.intThreshold = objFile.GetValueAsInt("Threshold", -4, 2); //objFile

                    objTemplateSetting.intExtraMarkThreshold = objFile.GetValueAsInt("ExtraMarkThreshold", -4, 2); //objFile

                    objTemplateSetting.fUnCheckAreaBottom = objFile.GetValueAsFloat("UnCheckAreaBottom", 5, 2);
                    objTemplateSetting.fUnCheckAreaLeft = objFile.GetValueAsFloat("UnCheckAreaLeft", 5, 2);
                    objTemplateSetting.fUnCheckAreaRight = objFile.GetValueAsFloat("UnCheckAreaRight", 5, 2);
                    objTemplateSetting.fUnCheckAreaTop = objFile.GetValueAsFloat("UnCheckAreaTop", 5, 2);
                    objTemplateSetting.fMarkAngleTolerance = objFile.GetValueAsFloat("MarkAngleTolerance", 15, 2);



                    int intCharNum = objFile.GetValueAsInt("CharNum", 0, 2); //objFile
                    int intCharNumTemplate1 = objFile.GetValueAsInt("CharNum", 0, 2);

                    objFile.GetThirdSection("CharSetting");
                    intCharNumTemplate1 = objFile.GetFourthSectionCount();
                    for (int k = 0; k < intCharNum; k++)
                    {
                        if (k < intCharNumTemplate1)
                            objTemplateSetting.intCharSetting.Add(objFile.GetValueAsInt("CharSetting" + k, m_intDefaultCharSetting, 3));
                        else
                            objTemplateSetting.intCharSetting.Add(objFile.GetValueAsInt("CharSetting" + (intCharNumTemplate1 - 1), m_intDefaultCharSetting, 3));
                    }

                    objFile.GetThirdSection("CharDividedLargestArea");
                    intCharNumTemplate1 = objFile.GetFourthSectionCount();
                    for (int k = 0; k < intCharNum; k++)
                    {
                        if (k < intCharNumTemplate1)
                            objTemplateSetting.intCharDividedLargestArea.Add(objFile.GetValueAsInt("CharDividedLargestArea" + k, 0, 3));
                        else
                            objTemplateSetting.intCharDividedLargestArea.Add(objFile.GetValueAsInt("CharDividedLargestArea" + (intCharNumTemplate1 - 1), 0, 3));
                    }

                    objFile.GetThirdSection("AverageGray");
                    for (int k = 0; k < intCharNum; k++)
                    {
                        if (k < intCharNumTemplate1)
                            objTemplateSetting.fAverageGray.Add(objFile.GetValueAsFloat("AverageGray" + k, 0, 3));
                        else
                            objTemplateSetting.fAverageGray.Add(objFile.GetValueAsFloat("AverageGray" + (intCharNumTemplate1 - 1), 0, 3));
                    }

                    objFile.GetThirdSection("MaxAGVPercent");
                    for (int k = 0; k < intCharNum; k++)
                    {
                        if (k < intCharNumTemplate1)
                            objTemplateSetting.fMaxAGVPercent.Add(objFile.GetValueAsFloat("MaxAGVPercent" + k, 20, 3));
                        else
                            objTemplateSetting.fMaxAGVPercent.Add(objFile.GetValueAsFloat("MaxAGVPercent" + (intCharNumTemplate1 - 1), 20, 3));
                    }

                    objFile.GetThirdSection("MaxExcessArea");
                    intCharNumTemplate1 = objFile.GetFourthSectionCount();
                    for (int k = 0; k < intCharNum; k++)
                    {
                        if (k < intCharNumTemplate1)
                            objTemplateSetting.arrMaxExcessArea.Add(objFile.GetValueAsFloat("MaxExcessArea" + k, 50, 3));
                        else
                            objTemplateSetting.arrMaxExcessArea.Add(objFile.GetValueAsFloat("MaxExcessArea" + (intCharNumTemplate1 - 1), 50, 3));
                    }

                    objFile.GetThirdSection("MaxBrokenArea");
                    intCharNumTemplate1 = objFile.GetFourthSectionCount();
                    for (int k = 0; k < intCharNum; k++)
                    {
                        if (k < intCharNumTemplate1)
                            objTemplateSetting.arrMaxBrokenArea.Add(objFile.GetValueAsFloat("MaxBrokenArea" + k, 50, 3));
                        else
                            objTemplateSetting.arrMaxBrokenArea.Add(objFile.GetValueAsFloat("MaxBrokenArea" + (intCharNumTemplate1 - 1), 50, 3));
                    }

                    objFile.GetThirdSection("WantBrokenMark");
                    intCharNumTemplate1 = objFile.GetFourthSectionCount();
                    for (int k = 0; k < intCharNum; k++)
                    {
                        if (k < intCharNumTemplate1)
                            objTemplateSetting.arrWantBrokenMark.Add(objFile.GetValueAsBoolean("WantBrokenMark" + k, false, 3));
                        else
                            objTemplateSetting.arrWantBrokenMark.Add(objFile.GetValueAsBoolean("WantBrokenMark" + (intCharNumTemplate1 - 1), false, 3));
                    }

                    objFile.GetThirdSection("MarkType");
                    intCharNumTemplate1 = objFile.GetFourthSectionCount();
                    for (int k = 0; k < intCharNum; k++)
                    {
                        if (k < intCharNumTemplate1)
                            objTemplateSetting.arrMarkType.Add(objFile.GetValueAsInt("MarkType" + k, 0, 3));
                        else
                            objTemplateSetting.arrMarkType.Add(objFile.GetValueAsInt("MarkType" + (intCharNumTemplate1 - 1), 0, 3));
                    }


                    objFile.GetThirdSection("CharShiftX");
                    intCharNumTemplate1 = objFile.GetFourthSectionCount();
                    for (int k = 0; k < intCharNum; k++)
                    {
                        if (k < intCharNumTemplate1)
                            objTemplateSetting.fCharShiftX.Add(objFile.GetValueAsFloat("CharShiftX" + k, 5, 3));
                        else
                            objTemplateSetting.fCharShiftX.Add(objFile.GetValueAsFloat("CharShiftX" + (intCharNumTemplate1 - 1), 5, 3));
                    }

                    objFile.GetThirdSection("CharShiftY");
                    intCharNumTemplate1 = objFile.GetFourthSectionCount();
                    for (int k = 0; k < intCharNum; k++)
                    {
                        if (k < intCharNumTemplate1)
                            objTemplateSetting.fCharShiftY.Add(objFile.GetValueAsFloat("CharShiftY" + k, 5, 3));
                        else
                            objTemplateSetting.fCharShiftY.Add(objFile.GetValueAsFloat("CharShiftY" + (intCharNumTemplate1 - 1), 5, 3));
                    }

                    //2020-05-08 ZJYEOH : reset back to current template because finish set to tolerance setting
                    objFile.GetSecondSection("Template" + j);

                    objFile.GetThirdSection("TextCharOffsetX");
                    for (int k = 0; k < intCharNum; k++)
                    {
                        objTemplateSetting.intTextCharOffsetX.Add(objFile.GetValueAsInt("TextCharOffsetX" + k, 0, 3));
                    }

                    objFile.GetThirdSection("TextCharOffsetY");
                    for (int k = 0; k < intCharNum; k++)
                    {
                        objTemplateSetting.intTextCharOffsetY.Add(objFile.GetValueAsInt("TextCharOffsetY" + k, 0, 3));
                    }

                    objFile.GetThirdSection("EnableMark");
                    for (int k = 0; k < intCharNum; k++)    // 2018 10 16 - CCENG: Use intCharNum to make sure blnEnable array count tally with intCharSetting array count. Not tally case will happen when use old recipe.
                    {
                        objTemplateSetting.blnEnable.Add(objFile.GetValueAsBoolean("EnableMark" + k, true, 3)); // 2018 10 16 - CCENG: Default is true because old recipe dun have this parameter. When load from oldd recipe, the mark must auto set to true.
                    }

                    objFile.GetThirdSection("IsBarPin1");
                    for (int k = 0; k < intCharNum; k++)
                    {
                        objTemplateSetting.blnIsBarPin1.Add(objFile.GetValueAsBoolean("IsBarPin1" + k, false, 3));
                    }

                    objFile.GetThirdSection("BarPin1Type");
                    for (int k = 0; k < intCharNum; k++)
                    {
                        objTemplateSetting.arrBarPin1Type.Add(objFile.GetValueAsInt("BarPin1Type" + k, 0, 3));
                    }

                    if (m_intInspectionMode == 0)
                    {
                        if (i < intTemplateNum)
                        {
                            m_arrOCV[i].Add(GetNOCVSetting());//m_arrOCV[i].Add(new NOCV(m_intImageWidth, m_intImageHeight));

                            objFile.GetThirdSection("CharNo");
                            for (int k = 0; k < intCharNum; k++)
                            {
                                m_arrOCV[i][j].SetCharNo(k, objFile.GetValueAsInt("CharNo" + k, k, 3));
                            }
                        }

                        objTemplateSetting.objTemplateImage.LoadImage(strFolderPath + "OriTemplate" + i + "_" + j + ".bmp");
                        objTemplateSetting.objDontCareImage.LoadImage(strFolderPath + "DontCareImage" + i + "_" + j + ".bmp");

                        //2021-05-01 ZJYEOH : dont care image will have individual image
                        for (int z = 0; z < intDontCareROICount; z++)
                        {
                            if (objTemplateSetting.arrDontCareImage.Count <= z)
                                objTemplateSetting.arrDontCareImage.Add(new ImageDrawing(true));

                            if (File.Exists(strFolderPath + "DontCareImage" + i + "_" + j + "_" + z + ".bmp"))
                                objTemplateSetting.arrDontCareImage[z].LoadImage(strFolderPath + "DontCareImage" + i + "_" + 0 + "_" + z + ".bmp"); //2021-05-01 ZJYEOH : Ori Index is i j z, but temporary fix j to 0 as now apply dont care to all template
                            else
                            {
                                objWhiteImage.CopyTo(ref objTemplateSetting.arrDontCareImage, z);
                            }
                        }

                        int intNumTexts = objFile.GetValueAsInt("TextNum", 0, 2);
                        objFile.GetThirdSection("TextROI");
                        for (int tx = 0; tx < intNumTexts; tx++)
                        {
                            objTemplateSetting.arrTemplateTextROI.Add(new ROI());
                            objTemplateSetting.arrTemplateTextROI[tx].LoadROISetting(
                                objFile.GetValueAsInt("TextROIStartX" + tx, 0, 3),
                                objFile.GetValueAsInt("TextROIStartY" + tx, 0, 3),
                                objFile.GetValueAsInt("TextROIWidth" + tx, 0, 3),
                                objFile.GetValueAsInt("TextROIHeight" + tx, 0, 3));

                            objTemplateSetting.arrTemplateTextROI[tx].AttachImage(objTemplateSetting.objTemplateImage);
                        }
                    }
                    else
                    {
                        m_objOCR.ClearTemplateChars();
                        objFile.GetThirdSection("TemplateCharOffSet");
                        int intTemplateCharNum = objFile.GetValueAsInt("TemplateCharOffSetNum", 0, 3);
                        for (int t = 0; t < intTemplateCharNum; t++)
                        {
                            m_objOCR.SetTemplateCharOffSetXY(t,
                                objFile.GetValueAsInt("CharOffSetX" + t, 0, 3),
                                objFile.GetValueAsInt("CharOffSetY" + t, 0, 3));

                            m_objOCR.SetTemplateCharStartPoint(t,
                                objFile.GetValueAsInt("CharStartX" + t, 0, 3),
                                objFile.GetValueAsInt("CharStartY" + t, 0, 3));

                            m_objOCR.SetTemplateCharEndPoint(t,
                                objFile.GetValueAsInt("CharEndX" + t, 0, 3),
                                objFile.GetValueAsInt("CharEndY" + t, 0, 3));

                            m_objOCR.SetTemplateCharSize(t,
                                objFile.GetValueAsInt("CharWidth" + t, 0, 3),
                                objFile.GetValueAsInt("CharHeight" + t, 0, 3));
                        }
                    }

                    m_arrTemplateSetting[i].Add(objTemplateSetting);
                }
            }

            if (m_arrTemplateSetting[m_intGroupIndex].Count > 0)
            {
                m_intTemplateIndex = 0;

                if ((m_intTemplateMask & 0x01) == 0)
                {
                    if ((m_intTemplateMask & 0x02) > 0)
                        m_intTemplateIndex = 1;
                    else if ((m_intTemplateMask & 0x04) > 0)
                        m_intTemplateIndex = 2;
                    else if ((m_intTemplateMask & 0x08) > 0)
                        m_intTemplateIndex = 3;
                    else if ((m_intTemplateMask & 0x10) > 0)
                        m_intTemplateIndex = 4;
                    else if ((m_intTemplateMask & 0x20) > 0)
                        m_intTemplateIndex = 5;
                    else if ((m_intTemplateMask & 0x40) > 0)
                        m_intTemplateIndex = 6;
                    else if ((m_intTemplateMask & 0x80) > 0)
                        m_intTemplateIndex = 7;
                }
            }
            else
                m_intTemplateIndex = -1;

            if (m_intInspectionMode == 0)
            {
                // Load OCV objects
                for (int i = 0; i < m_intGroupNum; i++)
                {
                    for (int j = 0; j < m_arrOCV[i].Count; j++)
                    {
                        if (File.Exists(strFolderPath + "Template" + i + "_" + j + ".ocv"))
                            m_arrOCV[i][j].LoadOCVFile(strFolderPath + "Template" + i + "_" + j + ".ocv");

                        ImageDrawing objMarkImage = new ImageDrawing();
                        if (File.Exists(strFolderPath + "Template" + i + "_" + j + ".bmp"))
                            objMarkImage.ref_objMainImage.Load(strFolderPath + "Template" + i + "_" + j + ".bmp");
                        //2021-01-03 ZJYEOH : Load Individual Blob Image
                        List<ImageDrawing> arrOCVImage = new List<ImageDrawing>();
                        int intOCVNum = m_arrTemplateSetting[i][j].intCharSetting.Count;
                        for (int k = 0; k < intOCVNum; k++)
                        {
                            arrOCVImage.Add(new ImageDrawing(true));
                            if (File.Exists(strFolderPath + "OCVTemplate" + i + "_" + j + "_" + k + ".bmp"))
                                arrOCVImage[k].ref_objMainImage.Load(strFolderPath + "OCVTemplate" + i + "_" + j + "_" + k + ".bmp");
                            else
                            {
                                if (File.Exists(strFolderPath + "Template" + i + "_" + j + ".bmp"))
                                    arrOCVImage[k].ref_objMainImage.Load(strFolderPath + "Template" + i + "_" + j + ".bmp");
                            }
                        }
                        ROI objMarkROI = new ROI();
                        objMarkROI.LoadROISetting(0, 0, objMarkImage.ref_intImageWidth, objMarkImage.ref_intImageHeight);
                        objMarkROI.AttachImage(objMarkImage);
                        ImageDrawing objOriTemplateImage = new ImageDrawing();
                        if (File.Exists(strFolderPath + "OriTemplate" + i + "_" + j + ".bmp"))
                            objOriTemplateImage.ref_objMainImage.Load(strFolderPath + "OriTemplate" + i + "_" + j + ".bmp");
                        SetErodeDilateSettings(objOriTemplateImage, objMarkImage, arrOCVImage, m_arrTemplateSetting[i][j], m_arrOCV[i][j], objMarkROI);

                        for (int k = 0; k < arrOCVImage.Count; k++)
                            arrOCVImage[k].Dispose();
                        objMarkImage.Dispose();
                        objOriTemplateImage.Dispose();
                        objMarkROI.Dispose();
                    }
                }
            }
            else
            {
                // Load OCR objects
                m_objOCR.Load(strFolderPath);

                if (m_intGroupNum == 1)
                    m_objOCR.SetRefCharCounter(m_arrRefChars[0]);
            }

        }
        public void SetTemplate1SetingToOtherTemplate(string strFolderPath, List<List<ROI>> arrROIList, int intSelectedTemplate, int intDontCareROICount, ImageDrawing objWhiteImage)
        {
            XmlParser objFile = new XmlParser(strFolderPath + "Template.xml");
            objFile.GetFirstSection("MarkSettings");
            m_blnCheckMark = objFile.GetValueAsBoolean("CheckMark", true);
            m_intFailOptionMask = objFile.GetValueAsInt("FailOptionMask", 0);
            m_intFailOptionMask_ForPreTest = objFile.GetValueAsInt("FailOptionMask_ForPreTest", 0);
            m_intMinArea = objFile.GetValueAsInt("MinArea", 20);
            //m_intMarkROIOffsetTop = objFile.GetValueAsInt("MarkROIOffsetTop", 0);
            //m_intMarkROIOffsetRight = objFile.GetValueAsInt("MarkROIOffsetRight", 0);
            //m_intMarkROIOffsetBottom = objFile.GetValueAsInt("MarkROIOffsetBottom", 0);
            //m_intMarkROIOffsetLeft = objFile.GetValueAsInt("MarkROIOffsetLeft", 0);
            m_intLeadDontCareInwardTolerance_Top = objFile.GetValueAsInt("LeadDontCareInwardTolerance_Top", 0);
            m_intLeadDontCareInwardTolerance_Right = objFile.GetValueAsInt("LeadDontCareInwardTolerance_Right", 0);
            m_intLeadDontCareInwardTolerance_Bottom = objFile.GetValueAsInt("LeadDontCareInwardTolerance_Bottom", 0);
            m_intLeadDontCareInwardTolerance_Left = objFile.GetValueAsInt("LeadDontCareInwardTolerance_Left", 0);
            m_intMaxArea = objFile.GetValueAsInt("MaxArea", 100000);
            m_intCharErodeHalfWidth = objFile.GetValueAsInt("CharErodeHalfWidth", 1);
            m_intCharOpenHalfWidth = objFile.GetValueAsInt("CharOpenHalfWidth", 0);
            m_intCharDilateHalfWidth = objFile.GetValueAsInt("CharDilateHalfWidth", 1);
            m_intEnhanceMark_LinkMark_HalfWidth = objFile.GetValueAsInt("EnhanceMark_LinkMark_HalfWidth", 0);
            m_intEnhanceMark_ReduceNoise_HalfWidth = objFile.GetValueAsInt("EnhanceMark_ReduceNoise_HalfWidth", 0);
            m_intLearnMinArea = objFile.GetValueAsInt("LearnMinArea", 20);
            m_intTemplateMask = objFile.GetValueAsInt("TemplateMask", 0);
            m_intTemplatePriority = objFile.GetValueAsLong("TemplatePriority", 0);
            m_blnWhiteOnBlack = objFile.GetValueAsBoolean("WhiteOnBlack", true);

            for (int i = 0; i < m_intGroupNum; i++)
            {
                objFile.GetFirstSection("Group" + i);

                if (m_intInspectionMode == 0)
                {
                    //// Temporary hide it first as it will throw exception for m_BinaOcv when relearn mark image.
                    //for (int m = 0; m < m_arrOCV.Count; m++)
                    //{
                    //    for (int n = 0; n < m_arrOCV[m].Count; n++)
                    //    {
                    //        if (m_arrOCV[m][n] != null)
                    //        {
                    //            m_arrOCV[m][n].Dispose();
                    //            m_arrOCV[m][n] = null;
                    //        }

                    //    }
                    //}

                    ClearNOCVSettingArray(i, true);//m_arrOCV[i].Clear();
                }
                else
                    m_arrRefChars[i] = objFile.GetValueAsString("RefChar", "");

                int intTemplateNum = objFile.GetValueAsInt("TemplateNum", 0);

                //for (int m = 0; m < m_arrTemplateSetting.Count; m++)
                //{
                //    for (int n = 0; n < m_arrTemplateSetting[i].Count; n++)
                //    {
                //        m_arrTemplateSetting[m][n].objTemplateImage.Dispose();
                //        m_arrTemplateSetting[m][n].objLearnDilateImage.Dispose();
                //        m_arrTemplateSetting[m][n].objLearnErodeImage.Dispose();
                //        m_arrTemplateSetting[m][n].objDontCareImage.Dispose();

                //        for (int k = 0; k < m_arrTemplateSetting[m][n].arrTemplateTextROI.Count; k++)
                //        {
                //            if (m_arrTemplateSetting[m][n].arrTemplateTextROI[k] != null)
                //                m_arrTemplateSetting[m][n].arrTemplateTextROI[k].Dispose();
                //        }

                //        for (int k = 0; k < m_arrTemplateSetting[m][n].arrTemplateCharErodeROI.Count; k++)
                //        {
                //            if (m_arrTemplateSetting[m][n].arrTemplateCharErodeROI[k] != null)
                //                m_arrTemplateSetting[m][n].arrTemplateCharErodeROI[k].Dispose();
                //        }

                //        for (int k = 0; k < m_arrTemplateSetting[m][n].arrTemplateCharDilateROI.Count; k++)
                //        {
                //            if (m_arrTemplateSetting[m][n].arrTemplateCharDilateROI[k] != null)
                //                m_arrTemplateSetting[m][n].arrTemplateCharDilateROI[k].Dispose();
                //        }
                //    }
                //}

                ClearTemplateSettingArray();  //m_arrTemplateSetting[i].Clear();

                for (int j = 0; j < intTemplateNum; j++)
                {
                    objFile.GetSecondSection("Template" + GetTemplateNumberWithMostCharNum(strFolderPath, intSelectedTemplate)); //j //2020-05-08 ZJYEOH : Always load Higest Char Number template setting to set to other template

                    XmlParser objOtherTemplateFile = new XmlParser(strFolderPath + "Template.xml");
                    objOtherTemplateFile.GetFirstSection("Group" + i);
                    objOtherTemplateFile.GetSecondSection("Template" + j);

                    TemplateSetting objTemplateSetting = GetTemplateSetting(); //TemplateSetting objTemplateSetting = new TemplateSetting();
                    objTemplateSetting.intFailOptionMask = objFile.GetValueAsInt("FailOptionMask", 0, 2);
                    objTemplateSetting.intBrokenSize = objFile.GetValueAsInt("BrokenSize", 10, 2);
                    objTemplateSetting.intCharShiftXY = objFile.GetValueAsInt("CharShiftXY", 5, 2);
                    objTemplateSetting.fExtraMinArea = objFile.GetValueAsFloat("ExtraMinArea", 20, 2);
                    objTemplateSetting.fGroupExtraMinArea = objFile.GetValueAsFloat("GroupExtraMinArea", 200, 2);
                    objTemplateSetting.fGroupExcessMinArea = objFile.GetValueAsFloat("GroupExcessMinArea", 100, 2);
                    objTemplateSetting.intExcessMinArea = objFile.GetValueAsInt("ExcessMinArea", 20, 2);
                    objTemplateSetting.intMissingMinArea = objFile.GetValueAsInt("MissingMinArea", 30, 2);
                    objTemplateSetting.intTextMinScore = objFile.GetValueAsInt("TextMinScore", 50, 2);

                    objTemplateSetting.intThreshold = objOtherTemplateFile.GetValueAsInt("Threshold", -4, 2); //objFile

                    objTemplateSetting.intExtraMarkThreshold = objOtherTemplateFile.GetValueAsInt("ExtraMarkThreshold", -4, 2); //objFile

                    objTemplateSetting.fUnCheckAreaBottom = objFile.GetValueAsFloat("UnCheckAreaBottom", 5, 2);
                    objTemplateSetting.fUnCheckAreaLeft = objFile.GetValueAsFloat("UnCheckAreaLeft", 5, 2);
                    objTemplateSetting.fUnCheckAreaRight = objFile.GetValueAsFloat("UnCheckAreaRight", 5, 2);
                    objTemplateSetting.fUnCheckAreaTop = objFile.GetValueAsFloat("UnCheckAreaTop", 5, 2);
                    objTemplateSetting.fMarkAngleTolerance = objFile.GetValueAsFloat("MarkAngleTolerance", 15, 2);



                    int intCharNum = objOtherTemplateFile.GetValueAsInt("CharNum", 0, 2); //objFile
                    int intCharNumTemplate1 = objFile.GetValueAsInt("CharNum", 0, 2);

                    objFile.GetThirdSection("CharSetting");
                    for (int k = 0; k < intCharNum; k++)
                    {
                        if (k < intCharNumTemplate1)
                            objTemplateSetting.intCharSetting.Add(objFile.GetValueAsInt("CharSetting" + k, m_intDefaultCharSetting, 3));
                        else
                            objTemplateSetting.intCharSetting.Add(objFile.GetValueAsInt("CharSetting" + (intCharNumTemplate1 - 1), m_intDefaultCharSetting, 3));
                    }

                    //2021-12-26 ZJYEOH : Use Own template Child node to load as CharDividedLargestArea are different for every template
                    objOtherTemplateFile.GetThirdSection("CharDividedLargestArea");
                    for (int k = 0; k < intCharNum; k++)
                    {
                        if (k < intCharNumTemplate1)
                            objTemplateSetting.intCharDividedLargestArea.Add(objOtherTemplateFile.GetValueAsInt("CharDividedLargestArea" + k, 0, 3));
                        else
                            objTemplateSetting.intCharDividedLargestArea.Add(objOtherTemplateFile.GetValueAsInt("CharDividedLargestArea" + (intCharNumTemplate1 - 1), 0, 3));
                    }

                    //2021-12-26 ZJYEOH : Use Own template Child node to load as AverageGray are different for every template
                    objOtherTemplateFile.GetThirdSection("AverageGray");
                    for (int k = 0; k < intCharNum; k++)
                    {
                        if (k < intCharNumTemplate1)
                            objTemplateSetting.fAverageGray.Add(objOtherTemplateFile.GetValueAsFloat("AverageGray" + k, 0, 3));
                        else
                            objTemplateSetting.fAverageGray.Add(objOtherTemplateFile.GetValueAsFloat("AverageGray" + (intCharNumTemplate1 - 1), 0, 3));
                    }

                    objFile.GetThirdSection("MaxAGVPercent");
                    for (int k = 0; k < intCharNum; k++)
                    {
                        if (k < intCharNumTemplate1)
                            objTemplateSetting.fMaxAGVPercent.Add(objFile.GetValueAsFloat("MaxAGVPercent" + k, 20, 3));
                        else
                            objTemplateSetting.fMaxAGVPercent.Add(objFile.GetValueAsFloat("MaxAGVPercent" + (intCharNumTemplate1 - 1), 20, 3));
                    }

                    objFile.GetThirdSection("MaxExcessArea");
                    intCharNumTemplate1 = objFile.GetFourthSectionCount();
                    for (int k = 0; k < intCharNum; k++)
                    {
                        if (k < intCharNumTemplate1)
                            objTemplateSetting.arrMaxExcessArea.Add(objFile.GetValueAsFloat("MaxExcessArea" + k, 50, 3));
                        else
                            objTemplateSetting.arrMaxExcessArea.Add(objFile.GetValueAsFloat("MaxExcessArea" + (intCharNumTemplate1 - 1), 50, 3));
                    }

                    objFile.GetThirdSection("MaxBrokenArea");
                    intCharNumTemplate1 = objFile.GetFourthSectionCount();
                    for (int k = 0; k < intCharNum; k++)
                    {
                        if (k < intCharNumTemplate1)
                            objTemplateSetting.arrMaxBrokenArea.Add(objFile.GetValueAsFloat("MaxBrokenArea" + k, 50, 3));
                        else
                            objTemplateSetting.arrMaxBrokenArea.Add(objFile.GetValueAsFloat("MaxBrokenArea" + (intCharNumTemplate1 - 1), 50, 3));
                    }

                    objFile.GetThirdSection("WantBrokenMark");
                    intCharNumTemplate1 = objFile.GetFourthSectionCount();
                    for (int k = 0; k < intCharNum; k++)
                    {
                        if (k < intCharNumTemplate1)
                            objTemplateSetting.arrWantBrokenMark.Add(objFile.GetValueAsBoolean("WantBrokenMark" + k, false, 3));
                        else
                            objTemplateSetting.arrWantBrokenMark.Add(objFile.GetValueAsBoolean("WantBrokenMark" + (intCharNumTemplate1 - 1), false, 3));
                    }

                    objFile.GetThirdSection("MarkType");
                    intCharNumTemplate1 = objFile.GetFourthSectionCount();
                    for (int k = 0; k < intCharNum; k++)
                    {
                        if (k < intCharNumTemplate1)
                            objTemplateSetting.arrMarkType.Add(objFile.GetValueAsInt("MarkType" + k, 0, 3));
                        else
                            objTemplateSetting.arrMarkType.Add(objFile.GetValueAsInt("MarkType" + (intCharNumTemplate1 - 1), 0, 3));
                    }

                    //2020-05-08 ZJYEOH : reset back to current template because finish set to tolerance setting
                    objFile.GetSecondSection("Template" + j);

                    objFile.GetThirdSection("CharShiftX");
                    //intCharNumTemplate1 = objFile.GetFourthSectionCount();
                    for (int k = 0; k < intCharNum; k++)
                    {
                        //if (k < intCharNumTemplate1)
                        objTemplateSetting.fCharShiftX.Add(objFile.GetValueAsFloat("CharShiftX" + k, 5, 3));
                        //else
                        //    objTemplateSetting.intCharShiftX.Add(objFile.GetValueAsInt("CharShiftX" + (intCharNumTemplate1 - 1), 5, 3));
                    }

                    objFile.GetThirdSection("CharShiftY");
                    //intCharNumTemplate1 = objFile.GetFourthSectionCount();
                    for (int k = 0; k < intCharNum; k++)
                    {
                        //if (k < intCharNumTemplate1)
                        objTemplateSetting.fCharShiftY.Add(objFile.GetValueAsFloat("CharShiftY" + k, 5, 3));
                        //else
                        //    objTemplateSetting.intCharShiftY.Add(objFile.GetValueAsInt("CharShiftY" + (intCharNumTemplate1 - 1), 5, 3));
                    }

                    objFile.GetThirdSection("TextCharOffsetX");
                    for (int k = 0; k < intCharNum; k++)
                    {
                        objTemplateSetting.intTextCharOffsetX.Add(objFile.GetValueAsInt("TextCharOffsetX" + k, 0, 3));
                    }

                    objFile.GetThirdSection("TextCharOffsetY");
                    for (int k = 0; k < intCharNum; k++)
                    {
                        objTemplateSetting.intTextCharOffsetY.Add(objFile.GetValueAsInt("TextCharOffsetY" + k, 0, 3));
                    }

                    objFile.GetThirdSection("EnableMark");
                    for (int k = 0; k < intCharNum; k++)    // 2018 10 16 - CCENG: Use intCharNum to make sure blnEnable array count tally with intCharSetting array count. Not tally case will happen when use old recipe.
                    {
                        objTemplateSetting.blnEnable.Add(objFile.GetValueAsBoolean("EnableMark" + k, true, 3)); // 2018 10 16 - CCENG: Default is true because old recipe dun have this parameter. When load from oldd recipe, the mark must auto set to true.
                    }

                    objFile.GetThirdSection("IsBarPin1");
                    for (int k = 0; k < intCharNum; k++)
                    {
                        objTemplateSetting.blnIsBarPin1.Add(objFile.GetValueAsBoolean("IsBarPin1" + k, false, 3));
                    }

                    objFile.GetThirdSection("BarPin1Type");
                    for (int k = 0; k < intCharNum; k++)
                    {
                        objTemplateSetting.arrBarPin1Type.Add(objFile.GetValueAsInt("BarPin1Type" + k, 0, 3));
                    }

                    if (m_intInspectionMode == 0)
                    {
                        if (i < intTemplateNum)
                        {
                            m_arrOCV[i].Add(GetNOCVSetting());//m_arrOCV[i].Add(new NOCV(m_intImageWidth, m_intImageHeight));

                            objFile.GetThirdSection("CharNo");
                            for (int k = 0; k < intCharNum; k++)
                            {
                                m_arrOCV[i][j].SetCharNo(k, objFile.GetValueAsInt("CharNo" + k, k, 3));
                            }
                        }

                        objTemplateSetting.objTemplateImage.LoadImage(strFolderPath + "OriTemplate" + i + "_" + j + ".bmp");
                        objTemplateSetting.objDontCareImage.LoadImage(strFolderPath + "DontCareImage" + i + "_" + j + ".bmp");

                        //2021-05-01 ZJYEOH : dont care image will have individual image
                        for (int z = 0; z < intDontCareROICount; z++)
                        {
                            if (objTemplateSetting.arrDontCareImage.Count <= z)
                                objTemplateSetting.arrDontCareImage.Add(new ImageDrawing(true));

                            if (File.Exists(strFolderPath + "DontCareImage" + i + "_" + j + "_" + z + ".bmp"))
                                objTemplateSetting.arrDontCareImage[z].LoadImage(strFolderPath + "DontCareImage" + i + "_" + 0 + "_" + z + ".bmp"); //2021-05-01 ZJYEOH : Ori Index is i j z, but temporary fix j to 0 as now apply dont care to all template
                            else
                            {
                                objWhiteImage.CopyTo(ref objTemplateSetting.arrDontCareImage, z);
                            }
                        }

                        int intNumTexts = objFile.GetValueAsInt("TextNum", 0, 2);
                        objFile.GetThirdSection("TextROI");
                        for (int tx = 0; tx < intNumTexts; tx++)
                        {
                            objTemplateSetting.arrTemplateTextROI.Add(new ROI());
                            objTemplateSetting.arrTemplateTextROI[tx].LoadROISetting(
                                objFile.GetValueAsInt("TextROIStartX" + tx, 0, 3),
                                objFile.GetValueAsInt("TextROIStartY" + tx, 0, 3),
                                objFile.GetValueAsInt("TextROIWidth" + tx, 0, 3),
                                objFile.GetValueAsInt("TextROIHeight" + tx, 0, 3));

                            objTemplateSetting.arrTemplateTextROI[tx].AttachImage(objTemplateSetting.objTemplateImage);
                        }
                    }
                    else
                    {
                        m_objOCR.ClearTemplateChars();
                        objFile.GetThirdSection("TemplateCharOffSet");
                        int intTemplateCharNum = objFile.GetValueAsInt("TemplateCharOffSetNum", 0, 3);
                        for (int t = 0; t < intTemplateCharNum; t++)
                        {
                            m_objOCR.SetTemplateCharOffSetXY(t,
                                objFile.GetValueAsInt("CharOffSetX" + t, 0, 3),
                                objFile.GetValueAsInt("CharOffSetY" + t, 0, 3));

                            m_objOCR.SetTemplateCharStartPoint(t,
                                objFile.GetValueAsInt("CharStartX" + t, 0, 3),
                                objFile.GetValueAsInt("CharStartY" + t, 0, 3));

                            m_objOCR.SetTemplateCharEndPoint(t,
                                objFile.GetValueAsInt("CharEndX" + t, 0, 3),
                                objFile.GetValueAsInt("CharEndY" + t, 0, 3));

                            m_objOCR.SetTemplateCharSize(t,
                                objFile.GetValueAsInt("CharWidth" + t, 0, 3),
                                objFile.GetValueAsInt("CharHeight" + t, 0, 3));
                        }
                    }

                    m_arrTemplateSetting[i].Add(objTemplateSetting);
                }
            }

            if (m_arrTemplateSetting[m_intGroupIndex].Count > 0)
            {
                m_intTemplateIndex = 0;

                if ((m_intTemplateMask & 0x01) == 0)
                {
                    if ((m_intTemplateMask & 0x02) > 0)
                        m_intTemplateIndex = 1;
                    else if ((m_intTemplateMask & 0x04) > 0)
                        m_intTemplateIndex = 2;
                    else if ((m_intTemplateMask & 0x08) > 0)
                        m_intTemplateIndex = 3;
                    else if ((m_intTemplateMask & 0x10) > 0)
                        m_intTemplateIndex = 4;
                    else if ((m_intTemplateMask & 0x20) > 0)
                        m_intTemplateIndex = 5;
                    else if ((m_intTemplateMask & 0x40) > 0)
                        m_intTemplateIndex = 6;
                    else if ((m_intTemplateMask & 0x80) > 0)
                        m_intTemplateIndex = 7;
                }
            }
            else
                m_intTemplateIndex = -1;

            if (m_intInspectionMode == 0)
            {
                // Load OCV objects
                for (int i = 0; i < m_intGroupNum; i++)
                {
                    for (int j = 0; j < m_arrOCV[i].Count; j++)
                    {
                        if (File.Exists(strFolderPath + "Template" + i + "_" + j + ".ocv"))
                            m_arrOCV[i][j].LoadOCVFile(strFolderPath + "Template" + i + "_" + j + ".ocv");

                        ImageDrawing objMarkImage = new ImageDrawing();
                        if (File.Exists(strFolderPath + "Template" + i + "_" + j + ".bmp"))
                            objMarkImage.ref_objMainImage.Load(strFolderPath + "Template" + i + "_" + j + ".bmp");
                        //2021-01-03 ZJYEOH : Load Individual Blob Image
                        List<ImageDrawing> arrOCVImage = new List<ImageDrawing>();
                        int intOCVNum = m_arrTemplateSetting[i][j].intCharSetting.Count;
                        for (int k = 0; k < intOCVNum; k++)
                        {
                            arrOCVImage.Add(new ImageDrawing(true));
                            if (File.Exists(strFolderPath + "OCVTemplate" + i + "_" + j + "_" + k + ".bmp"))
                                arrOCVImage[k].ref_objMainImage.Load(strFolderPath + "OCVTemplate" + i + "_" + j + "_" + k + ".bmp");
                            else
                            {
                                if (File.Exists(strFolderPath + "Template" + i + "_" + j + ".bmp"))
                                    arrOCVImage[k].ref_objMainImage.Load(strFolderPath + "Template" + i + "_" + j + ".bmp");
                            }
                        }
                        ROI objMarkROI = new ROI();
                        objMarkROI.LoadROISetting(0, 0, objMarkImage.ref_intImageWidth, objMarkImage.ref_intImageHeight);
                        objMarkROI.AttachImage(objMarkImage);
                        ImageDrawing objOriTemplateImage = new ImageDrawing();
                        if (File.Exists(strFolderPath + "OriTemplate" + i + "_" + j + ".bmp"))
                            objOriTemplateImage.ref_objMainImage.Load(strFolderPath + "OriTemplate" + i + "_" + j + ".bmp");
                        SetErodeDilateSettings(objOriTemplateImage, objMarkImage, arrOCVImage, m_arrTemplateSetting[i][j], m_arrOCV[i][j], objMarkROI);

                        for (int k = 0; k < arrOCVImage.Count; k++)
                            arrOCVImage[k].Dispose();
                        objMarkImage.Dispose();
                        objOriTemplateImage.Dispose();
                        objMarkROI.Dispose();
                    }
                }
            }
            else
            {
                // Load OCR objects
                m_objOCR.Load(strFolderPath);

                if (m_intGroupNum == 1)
                    m_objOCR.SetRefCharCounter(m_arrRefChars[0]);
            }

        }
        public void SetTemplate1SetingToOtherTemplate(string strFolderPath, List<List<ROI>> arrROIList, int intDontCareROICount, ImageDrawing objWhiteImage)
        {
            XmlParser objFile = new XmlParser(strFolderPath + "Template.xml");
            objFile.GetFirstSection("MarkSettings");
            m_blnCheckMark = objFile.GetValueAsBoolean("CheckMark", true);
            m_intFailOptionMask = objFile.GetValueAsInt("FailOptionMask", 0);
            m_intFailOptionMask_ForPreTest = objFile.GetValueAsInt("FailOptionMask_ForPreTest", 0);
            m_intMinArea = objFile.GetValueAsInt("MinArea", 20);
            //m_intMarkROIOffsetTop = objFile.GetValueAsInt("MarkROIOffsetTop", 0);
            //m_intMarkROIOffsetRight = objFile.GetValueAsInt("MarkROIOffsetRight", 0);
            //m_intMarkROIOffsetBottom = objFile.GetValueAsInt("MarkROIOffsetBottom", 0);
            //m_intMarkROIOffsetLeft = objFile.GetValueAsInt("MarkROIOffsetLeft", 0);
            m_intLeadDontCareInwardTolerance_Top = objFile.GetValueAsInt("LeadDontCareInwardTolerance_Top", 0);
            m_intLeadDontCareInwardTolerance_Right = objFile.GetValueAsInt("LeadDontCareInwardTolerance_Right", 0);
            m_intLeadDontCareInwardTolerance_Bottom = objFile.GetValueAsInt("LeadDontCareInwardTolerance_Bottom", 0);
            m_intLeadDontCareInwardTolerance_Left = objFile.GetValueAsInt("LeadDontCareInwardTolerance_Left", 0);
            m_intMaxArea = objFile.GetValueAsInt("MaxArea", 100000);
            m_intCharErodeHalfWidth = objFile.GetValueAsInt("CharErodeHalfWidth", 1);
            m_intCharOpenHalfWidth = objFile.GetValueAsInt("CharOpenHalfWidth", 0);
            m_intCharDilateHalfWidth = objFile.GetValueAsInt("CharDilateHalfWidth", 1);
            m_intEnhanceMark_LinkMark_HalfWidth = objFile.GetValueAsInt("EnhanceMark_LinkMark_HalfWidth", 0);
            m_intEnhanceMark_ReduceNoise_HalfWidth = objFile.GetValueAsInt("EnhanceMark_ReduceNoise_HalfWidth", 0);
            m_intLearnMinArea = objFile.GetValueAsInt("LearnMinArea", 20);
            m_intTemplateMask = objFile.GetValueAsInt("TemplateMask", 0);
            m_intTemplatePriority = objFile.GetValueAsLong("TemplatePriority", 0);
            m_blnWhiteOnBlack = objFile.GetValueAsBoolean("WhiteOnBlack", true);

            for (int i = 0; i < m_intGroupNum; i++)
            {
                objFile.GetFirstSection("Group" + i);

                if (m_intInspectionMode == 0)
                {
                    //// Temporary hide it first as it will throw exception for m_BinaOcv when relearn mark image.
                    //for (int m = 0; m < m_arrOCV.Count; m++)
                    //{
                    //    for (int n = 0; n < m_arrOCV[m].Count; n++)
                    //    {
                    //        if (m_arrOCV[m][n] != null)
                    //        {
                    //            m_arrOCV[m][n].Dispose();
                    //            m_arrOCV[m][n] = null;
                    //        }

                    //    }
                    //}

                    ClearNOCVSettingArray(i, true);//m_arrOCV[i].Clear();
                }
                else
                    m_arrRefChars[i] = objFile.GetValueAsString("RefChar", "");

                int intTemplateNum = objFile.GetValueAsInt("TemplateNum", 0);

                //for (int m = 0; m < m_arrTemplateSetting.Count; m++)
                //{
                //    for (int n = 0; n < m_arrTemplateSetting[i].Count; n++)
                //    {
                //        m_arrTemplateSetting[m][n].objTemplateImage.Dispose();
                //        m_arrTemplateSetting[m][n].objLearnDilateImage.Dispose();
                //        m_arrTemplateSetting[m][n].objLearnErodeImage.Dispose();
                //        m_arrTemplateSetting[m][n].objDontCareImage.Dispose();

                //        for (int k = 0; k < m_arrTemplateSetting[m][n].arrTemplateTextROI.Count; k++)
                //        {
                //            if (m_arrTemplateSetting[m][n].arrTemplateTextROI[k] != null)
                //                m_arrTemplateSetting[m][n].arrTemplateTextROI[k].Dispose();
                //        }

                //        for (int k = 0; k < m_arrTemplateSetting[m][n].arrTemplateCharErodeROI.Count; k++)
                //        {
                //            if (m_arrTemplateSetting[m][n].arrTemplateCharErodeROI[k] != null)
                //                m_arrTemplateSetting[m][n].arrTemplateCharErodeROI[k].Dispose();
                //        }

                //        for (int k = 0; k < m_arrTemplateSetting[m][n].arrTemplateCharDilateROI.Count; k++)
                //        {
                //            if (m_arrTemplateSetting[m][n].arrTemplateCharDilateROI[k] != null)
                //                m_arrTemplateSetting[m][n].arrTemplateCharDilateROI[k].Dispose();
                //        }
                //    }
                //}

                ClearTemplateSettingArray(); //m_arrTemplateSetting[i].Clear();

                for (int j = 0; j < Math.Max(1, intTemplateNum); j++)
                {
                    objFile.GetSecondSection("Template" + GetTemplateNumberWithMostCharNum(strFolderPath)); //j //2020-05-08 ZJYEOH : Always load Higest Char Number template setting to set to other template

                    XmlParser objOtherTemplateFile = new XmlParser(strFolderPath + "Template.xml");
                    objOtherTemplateFile.GetFirstSection("Group" + i);
                    objOtherTemplateFile.GetSecondSection("Template" + j);

                    TemplateSetting objTemplateSetting = GetTemplateSetting(); //TemplateSetting objTemplateSetting = new TemplateSetting();
                    objTemplateSetting.intFailOptionMask = objFile.GetValueAsInt("FailOptionMask", 0, 2);
                    objTemplateSetting.intBrokenSize = objFile.GetValueAsInt("BrokenSize", 10, 2);
                    objTemplateSetting.intCharShiftXY = objFile.GetValueAsInt("CharShiftXY", 5, 2);
                    objTemplateSetting.fExtraMinArea = objFile.GetValueAsFloat("ExtraMinArea", 20, 2);
                    objTemplateSetting.fGroupExtraMinArea = objFile.GetValueAsFloat("GroupExtraMinArea", 200, 2);
                    objTemplateSetting.fGroupExcessMinArea = objFile.GetValueAsFloat("GroupExcessMinArea", 100, 2);
                    objTemplateSetting.intExcessMinArea = objFile.GetValueAsInt("ExcessMinArea", 20, 2);
                    objTemplateSetting.intMissingMinArea = objFile.GetValueAsInt("MissingMinArea", 30, 2);
                    objTemplateSetting.intTextMinScore = objFile.GetValueAsInt("TextMinScore", 50, 2);

                    objTemplateSetting.intThreshold = objOtherTemplateFile.GetValueAsInt("Threshold", -4, 2); //objFile

                    objTemplateSetting.intExtraMarkThreshold = objOtherTemplateFile.GetValueAsInt("ExtraMarkThreshold", -4, 2); //objFile

                    objTemplateSetting.fUnCheckAreaBottom = objFile.GetValueAsFloat("UnCheckAreaBottom", 5, 2);
                    objTemplateSetting.fUnCheckAreaLeft = objFile.GetValueAsFloat("UnCheckAreaLeft", 5, 2);
                    objTemplateSetting.fUnCheckAreaRight = objFile.GetValueAsFloat("UnCheckAreaRight", 5, 2);
                    objTemplateSetting.fUnCheckAreaTop = objFile.GetValueAsFloat("UnCheckAreaTop", 5, 2);
                    objTemplateSetting.fMarkAngleTolerance = objFile.GetValueAsFloat("MarkAngleTolerance", 15, 2);



                    int intCharNum = objOtherTemplateFile.GetValueAsInt("CharNum", 0, 2); //objFile
                    int intCharNumTemplate1 = objFile.GetValueAsInt("CharNum", 0, 2);

                    objFile.GetThirdSection("CharSetting");
                    for (int k = 0; k < intCharNum; k++)
                    {
                        if (k < intCharNumTemplate1)
                            objTemplateSetting.intCharSetting.Add(objFile.GetValueAsInt("CharSetting" + k, m_intDefaultCharSetting, 3));
                        else
                            objTemplateSetting.intCharSetting.Add(objFile.GetValueAsInt("CharSetting" + (intCharNumTemplate1 - 1), m_intDefaultCharSetting, 3));
                    }

                    //2021-12-26 ZJYEOH : Use Own template Child node to load as CharDividedLargestArea are different for every template
                    objOtherTemplateFile.GetThirdSection("CharDividedLargestArea");
                    for (int k = 0; k < intCharNum; k++)
                    {
                        if (k < intCharNumTemplate1)
                            objTemplateSetting.intCharDividedLargestArea.Add(objOtherTemplateFile.GetValueAsInt("CharDividedLargestArea" + k, 0, 3));
                        else
                            objTemplateSetting.intCharDividedLargestArea.Add(objOtherTemplateFile.GetValueAsInt("CharDividedLargestArea" + (intCharNumTemplate1 - 1), 0, 3));
                    }

                    //2021-12-26 ZJYEOH : Use Own template Child node to load as AverageGray are different for every template
                    objOtherTemplateFile.GetThirdSection("AverageGray");
                    for (int k = 0; k < intCharNum; k++)
                    {
                        if (k < intCharNumTemplate1)
                            objTemplateSetting.fAverageGray.Add(objOtherTemplateFile.GetValueAsFloat("AverageGray" + k, 0, 3));
                        else
                            objTemplateSetting.fAverageGray.Add(objOtherTemplateFile.GetValueAsFloat("AverageGray" + (intCharNumTemplate1 - 1), 0, 3));
                    }

                    objFile.GetThirdSection("MaxAGVPercent");
                    for (int k = 0; k < intCharNum; k++)
                    {
                        if (k < intCharNumTemplate1)
                            objTemplateSetting.fMaxAGVPercent.Add(objFile.GetValueAsFloat("MaxAGVPercent" + k, 20, 3));
                        else
                            objTemplateSetting.fMaxAGVPercent.Add(objFile.GetValueAsFloat("MaxAGVPercent" + (intCharNumTemplate1 - 1), 20, 3));
                    }

                    objFile.GetThirdSection("MaxExcessArea");
                    for (int k = 0; k < intCharNum; k++)
                    {
                        if (k < intCharNumTemplate1)
                            objTemplateSetting.arrMaxExcessArea.Add(objFile.GetValueAsFloat("MaxExcessArea" + k, 50, 3));
                        else
                            objTemplateSetting.arrMaxExcessArea.Add(objFile.GetValueAsFloat("MaxExcessArea" + (intCharNumTemplate1 - 1), 50, 3));
                    }

                    objFile.GetThirdSection("MaxBrokenArea");
                    for (int k = 0; k < intCharNum; k++)
                    {
                        if (k < intCharNumTemplate1)
                            objTemplateSetting.arrMaxBrokenArea.Add(objFile.GetValueAsFloat("MaxBrokenArea" + k, 50, 3));
                        else
                            objTemplateSetting.arrMaxBrokenArea.Add(objFile.GetValueAsFloat("MaxBrokenArea" + (intCharNumTemplate1 - 1), 50, 3));
                    }

                    objFile.GetThirdSection("WantBrokenMark");
                    for (int k = 0; k < intCharNum; k++)
                    {
                        if (k < intCharNumTemplate1)
                            objTemplateSetting.arrWantBrokenMark.Add(objFile.GetValueAsBoolean("WantBrokenMark" + k, false, 3));
                        else
                            objTemplateSetting.arrWantBrokenMark.Add(objFile.GetValueAsBoolean("WantBrokenMark" + (intCharNumTemplate1 - 1), false, 3));
                    }

                    objFile.GetThirdSection("MarkType");
                    intCharNumTemplate1 = objFile.GetFourthSectionCount();
                    for (int k = 0; k < intCharNum; k++)
                    {
                        if (k < intCharNumTemplate1)
                            objTemplateSetting.arrMarkType.Add(objFile.GetValueAsInt("MarkType" + k, 0, 3));
                        else
                            objTemplateSetting.arrMarkType.Add(objFile.GetValueAsInt("MarkType" + (intCharNumTemplate1 - 1), 0, 3));
                    }

                    objFile.GetThirdSection("CharShiftX");
                    for (int k = 0; k < intCharNum; k++)
                    {
                        if (k < intCharNumTemplate1)
                            objTemplateSetting.fCharShiftX.Add(objFile.GetValueAsFloat("CharShiftX" + k, 5, 3));
                        else
                            objTemplateSetting.fCharShiftX.Add(objFile.GetValueAsFloat("CharShiftX" + (intCharNumTemplate1 - 1), 5, 3));
                    }

                    objFile.GetThirdSection("CharShiftY");
                    for (int k = 0; k < intCharNum; k++)
                    {
                        if (k < intCharNumTemplate1)
                            objTemplateSetting.fCharShiftY.Add(objFile.GetValueAsFloat("CharShiftY" + k, 5, 3));
                        else
                            objTemplateSetting.fCharShiftY.Add(objFile.GetValueAsFloat("CharShiftY" + (intCharNumTemplate1 - 1), 5, 3));
                    }

                    //2020-05-08 ZJYEOH : reset back to current template because finish set to tolerance setting
                    objFile.GetSecondSection("Template" + j);

                    objFile.GetThirdSection("TextCharOffsetX");
                    for (int k = 0; k < intCharNum; k++)
                    {
                        objTemplateSetting.intTextCharOffsetX.Add(objFile.GetValueAsInt("TextCharOffsetX" + k, 0, 3));
                    }

                    objFile.GetThirdSection("TextCharOffsetY");
                    for (int k = 0; k < intCharNum; k++)
                    {
                        objTemplateSetting.intTextCharOffsetY.Add(objFile.GetValueAsInt("TextCharOffsetY" + k, 0, 3));
                    }

                    objFile.GetThirdSection("EnableMark");
                    for (int k = 0; k < intCharNum; k++)    // 2018 10 16 - CCENG: Use intCharNum to make sure blnEnable array count tally with intCharSetting array count. Not tally case will happen when use old recipe.
                    {
                        objTemplateSetting.blnEnable.Add(objFile.GetValueAsBoolean("EnableMark" + k, true, 3)); // 2018 10 16 - CCENG: Default is true because old recipe dun have this parameter. When load from oldd recipe, the mark must auto set to true.
                    }

                    objFile.GetThirdSection("IsBarPin1");
                    for (int k = 0; k < intCharNum; k++)
                    {
                        objTemplateSetting.blnIsBarPin1.Add(objFile.GetValueAsBoolean("IsBarPin1" + k, false, 3));
                    }

                    objFile.GetThirdSection("BarPin1Type");
                    for (int k = 0; k < intCharNum; k++)
                    {
                        objTemplateSetting.arrBarPin1Type.Add(objFile.GetValueAsInt("BarPin1Type" + k, 0, 3));
                    }

                    if (m_intInspectionMode == 0)
                    {
                        if (i < intTemplateNum)
                        {
                            m_arrOCV[i].Add(GetNOCVSetting());//m_arrOCV[i].Add(new NOCV(m_intImageWidth, m_intImageHeight));

                            objFile.GetThirdSection("CharNo");
                            for (int k = 0; k < intCharNum; k++)
                            {
                                m_arrOCV[i][j].SetCharNo(k, objFile.GetValueAsInt("CharNo" + k, k, 3));
                            }
                        }

                        objTemplateSetting.objTemplateImage.LoadImage(strFolderPath + "OriTemplate" + i + "_" + j + ".bmp");
                        objTemplateSetting.objDontCareImage.LoadImage(strFolderPath + "DontCareImage" + i + "_" + j + ".bmp");

                        //2021-05-01 ZJYEOH : dont care image will have individual image
                        for (int z = 0; z < intDontCareROICount; z++)
                        {
                            if (objTemplateSetting.arrDontCareImage.Count <= z)
                                objTemplateSetting.arrDontCareImage.Add(new ImageDrawing(true));

                            if (File.Exists(strFolderPath + "DontCareImage" + i + "_" + j + "_" + z + ".bmp"))
                                objTemplateSetting.arrDontCareImage[z].LoadImage(strFolderPath + "DontCareImage" + i + "_" + 0 + "_" + z + ".bmp"); //2021-05-01 ZJYEOH : Ori Index is i j z, but temporary fix j to 0 as now apply dont care to all template
                            else
                            {
                                objWhiteImage.CopyTo(ref objTemplateSetting.arrDontCareImage, z);
                            }
                        }

                        int intNumTexts = objFile.GetValueAsInt("TextNum", 0, 2);
                        objFile.GetThirdSection("TextROI");
                        for (int tx = 0; tx < intNumTexts; tx++)
                        {
                            objTemplateSetting.arrTemplateTextROI.Add(new ROI());
                            objTemplateSetting.arrTemplateTextROI[tx].LoadROISetting(
                                objFile.GetValueAsInt("TextROIStartX" + tx, 0, 3),
                                objFile.GetValueAsInt("TextROIStartY" + tx, 0, 3),
                                objFile.GetValueAsInt("TextROIWidth" + tx, 0, 3),
                                objFile.GetValueAsInt("TextROIHeight" + tx, 0, 3));

                            objTemplateSetting.arrTemplateTextROI[tx].AttachImage(objTemplateSetting.objTemplateImage);
                        }
                    }
                    else
                    {
                        m_objOCR.ClearTemplateChars();
                        objFile.GetThirdSection("TemplateCharOffSet");
                        int intTemplateCharNum = objFile.GetValueAsInt("TemplateCharOffSetNum", 0, 3);
                        for (int t = 0; t < intTemplateCharNum; t++)
                        {
                            m_objOCR.SetTemplateCharOffSetXY(t,
                                objFile.GetValueAsInt("CharOffSetX" + t, 0, 3),
                                objFile.GetValueAsInt("CharOffSetY" + t, 0, 3));

                            m_objOCR.SetTemplateCharStartPoint(t,
                                objFile.GetValueAsInt("CharStartX" + t, 0, 3),
                                objFile.GetValueAsInt("CharStartY" + t, 0, 3));

                            m_objOCR.SetTemplateCharEndPoint(t,
                                objFile.GetValueAsInt("CharEndX" + t, 0, 3),
                                objFile.GetValueAsInt("CharEndY" + t, 0, 3));

                            m_objOCR.SetTemplateCharSize(t,
                                objFile.GetValueAsInt("CharWidth" + t, 0, 3),
                                objFile.GetValueAsInt("CharHeight" + t, 0, 3));
                        }
                    }

                    m_arrTemplateSetting[i].Add(objTemplateSetting);
                }
            }

            if (m_arrTemplateSetting[m_intGroupIndex].Count > 0)
            {
                m_intTemplateIndex = 0;

                if ((m_intTemplateMask & 0x01) == 0)
                {
                    if ((m_intTemplateMask & 0x02) > 0)
                        m_intTemplateIndex = 1;
                    else if ((m_intTemplateMask & 0x04) > 0)
                        m_intTemplateIndex = 2;
                    else if ((m_intTemplateMask & 0x08) > 0)
                        m_intTemplateIndex = 3;
                    else if ((m_intTemplateMask & 0x10) > 0)
                        m_intTemplateIndex = 4;
                    else if ((m_intTemplateMask & 0x20) > 0)
                        m_intTemplateIndex = 5;
                    else if ((m_intTemplateMask & 0x40) > 0)
                        m_intTemplateIndex = 6;
                    else if ((m_intTemplateMask & 0x80) > 0)
                        m_intTemplateIndex = 7;
                }
            }
            else
                m_intTemplateIndex = -1;

            if (m_intInspectionMode == 0)
            {
                // Load OCV objects
                for (int i = 0; i < m_intGroupNum; i++)
                {
                    for (int j = 0; j < m_arrOCV[i].Count; j++)
                    {
                        if (File.Exists(strFolderPath + "Template" + i + "_" + j + ".ocv"))
                            m_arrOCV[i][j].LoadOCVFile(strFolderPath + "Template" + i + "_" + j + ".ocv");

                        ImageDrawing objMarkImage = new ImageDrawing();
                        if (File.Exists(strFolderPath + "Template" + i + "_" + j + ".bmp"))
                            objMarkImage.ref_objMainImage.Load(strFolderPath + "Template" + i + "_" + j + ".bmp");
                        //2021-01-03 ZJYEOH : Load Individual Blob Image
                        List<ImageDrawing> arrOCVImage = new List<ImageDrawing>();
                        int intOCVNum = m_arrTemplateSetting[i][j].intCharSetting.Count;
                        for (int k = 0; k < intOCVNum; k++)
                        {
                            arrOCVImage.Add(new ImageDrawing(true));
                            if (File.Exists(strFolderPath + "OCVTemplate" + i + "_" + j + "_" + k + ".bmp"))
                                arrOCVImage[k].ref_objMainImage.Load(strFolderPath + "OCVTemplate" + i + "_" + j + "_" + k + ".bmp");
                            else
                            {
                                if (File.Exists(strFolderPath + "Template" + i + "_" + j + ".bmp"))
                                    arrOCVImage[k].ref_objMainImage.Load(strFolderPath + "Template" + i + "_" + j + ".bmp");
                            }
                        }
                        ROI objMarkROI = new ROI();
                        objMarkROI.LoadROISetting(0, 0, objMarkImage.ref_intImageWidth, objMarkImage.ref_intImageHeight);
                        objMarkROI.AttachImage(objMarkImage);
                        ImageDrawing objOriTemplateImage = new ImageDrawing();
                        if (File.Exists(strFolderPath + "OriTemplate" + i + "_" + j + ".bmp"))
                            objOriTemplateImage.ref_objMainImage.Load(strFolderPath + "OriTemplate" + i + "_" + j + ".bmp");
                        SetErodeDilateSettings(objOriTemplateImage, objMarkImage, arrOCVImage, m_arrTemplateSetting[i][j], m_arrOCV[i][j], objMarkROI);

                        for (int k = 0; k < arrOCVImage.Count; k++)
                            arrOCVImage[k].Dispose();
                        objMarkImage.Dispose();
                        objOriTemplateImage.Dispose();
                        objMarkROI.Dispose();
                    }
                }
            }
            else
            {
                // Load OCR objects
                m_objOCR.Load(strFolderPath);

                if (m_intGroupNum == 1)
                    m_objOCR.SetRefCharCounter(m_arrRefChars[0]);
            }

        }
        public void LoadTemplate(string strFolderPath, List<List<ROI>> arrROIList, int intDontCareROICount, ImageDrawing objWhiteImage)
        {
            string[] Split = strFolderPath.Split('\\');
            string strVision = Split[Split.Length - 5] + " - (" + Split[Split.Length - 4] + ") -->";
            XmlParser objFile = new XmlParser(strFolderPath + "Template.xml");
            objFile.GetFirstSection("MarkSettings");
            m_blnCheckMark = objFile.GetValueAsBoolean("CheckMark", true);
            m_intFailOptionMask = objFile.GetValueAsInt("FailOptionMask", 0);
            m_intFailOptionMask_ForPreTest = objFile.GetValueAsInt("FailOptionMask_ForPreTest", 0);
            m_intMinArea = objFile.GetValueAsInt("MinArea", 20);
            //m_intMarkROIOffsetTop = objFile.GetValueAsInt("MarkROIOffsetTop", 0);
            //m_intMarkROIOffsetRight = objFile.GetValueAsInt("MarkROIOffsetRight", 0);
            //m_intMarkROIOffsetBottom = objFile.GetValueAsInt("MarkROIOffsetBottom", 0);
            //m_intMarkROIOffsetLeft = objFile.GetValueAsInt("MarkROIOffsetLeft", 0);
            m_intLeadDontCareInwardTolerance_Top = objFile.GetValueAsInt("LeadDontCareInwardTolerance_Top", 0);
            m_intLeadDontCareInwardTolerance_Right = objFile.GetValueAsInt("LeadDontCareInwardTolerance_Right", 0);
            m_intLeadDontCareInwardTolerance_Bottom = objFile.GetValueAsInt("LeadDontCareInwardTolerance_Bottom", 0);
            m_intLeadDontCareInwardTolerance_Left = objFile.GetValueAsInt("LeadDontCareInwardTolerance_Left", 0);
            m_intMaxArea = objFile.GetValueAsInt("MaxArea", 100000);
            m_intCharErodeHalfWidth = objFile.GetValueAsInt("CharErodeHalfWidth", 1);
            m_intCharOpenHalfWidth = objFile.GetValueAsInt("CharOpenHalfWidth", 0);
            m_intCharDilateHalfWidth = objFile.GetValueAsInt("CharDilateHalfWidth", 1);
            m_intEnhanceMark_LinkMark_HalfWidth = objFile.GetValueAsInt("EnhanceMark_LinkMark_HalfWidth", 0);
            m_intEnhanceMark_ReduceNoise_HalfWidth = objFile.GetValueAsInt("EnhanceMark_ReduceNoise_HalfWidth", 0);
            m_intLearnMinArea = objFile.GetValueAsInt("LearnMinArea", 20);
            m_intTemplateMask = objFile.GetValueAsInt("TemplateMask", 0);
            m_intTemplatePriority = objFile.GetValueAsLong("TemplatePriority", 0);
            m_blnWhiteOnBlack = objFile.GetValueAsBoolean("WhiteOnBlack", true);

            int intTemplateNum = 0;

            for (int i = 0; i < m_intGroupNum; i++)
            {
                objFile.GetFirstSection("Group" + i);

                if (m_intInspectionMode == 0)
                {
                    //// Temporary hide it first as it will throw exception for m_BinaOcv when relearn mark image.
                    //for (int m = 0; m < m_arrOCV.Count; m++)
                    //{
                    //    for (int n = 0; n < m_arrOCV[m].Count; n++)
                    //    {
                    //        if (m_arrOCV[m][n] != null)
                    //        {
                    //            m_arrOCV[m][n].Dispose();
                    //            m_arrOCV[m][n] = null;
                    //        }

                    //    }
                    //}

                    ClearNOCVSettingArray(i, true);//m_arrOCV[i].Clear();
                }
                else
                    m_arrRefChars[i] = objFile.GetValueAsString("RefChar", "");

                intTemplateNum = objFile.GetValueAsInt("TemplateNum", 0);

                //for (int m = 0; m < m_arrTemplateSetting.Count; m++)
                //{
                //    for (int n = 0; n < m_arrTemplateSetting[i].Count; n++)
                //    {
                //        m_arrTemplateSetting[m][n].objTemplateImage.Dispose();
                //        m_arrTemplateSetting[m][n].objLearnDilateImage.Dispose();
                //        m_arrTemplateSetting[m][n].objLearnErodeImage.Dispose();
                //        m_arrTemplateSetting[m][n].objDontCareImage.Dispose();

                //        for (int k = 0; k < m_arrTemplateSetting[m][n].arrTemplateTextROI.Count; k++)
                //        {
                //            if (m_arrTemplateSetting[m][n].arrTemplateTextROI[k] != null)
                //                m_arrTemplateSetting[m][n].arrTemplateTextROI[k].Dispose();
                //        }

                //        for (int k = 0; k < m_arrTemplateSetting[m][n].arrTemplateCharErodeROI.Count; k++)
                //        {
                //            if (m_arrTemplateSetting[m][n].arrTemplateCharErodeROI[k] != null)
                //                m_arrTemplateSetting[m][n].arrTemplateCharErodeROI[k].Dispose();
                //        }

                //        for (int k = 0; k < m_arrTemplateSetting[m][n].arrTemplateCharDilateROI.Count; k++)
                //        {
                //            if (m_arrTemplateSetting[m][n].arrTemplateCharDilateROI[k] != null)
                //                m_arrTemplateSetting[m][n].arrTemplateCharDilateROI[k].Dispose();
                //        }
                //    }
                //}

                ClearTemplateSettingArray(); //m_arrTemplateSetting[i].Clear();

                for (int j = 0; j < Math.Max(1, intTemplateNum); j++)
                {
                    objFile.GetSecondSection("Template" + j);
                    TemplateSetting objTemplateSetting = GetTemplateSetting(); //TemplateSetting objTemplateSetting = new TemplateSetting();
                    objTemplateSetting.intFailOptionMask = objFile.GetValueAsInt("FailOptionMask", 0, 2);
                    STTrackLog.WriteLine(strVision + " Template " + (i + 1).ToString() + " Load Mark Fail Option : " + objTemplateSetting.intFailOptionMask.ToString());
                    objTemplateSetting.intBrokenSize = objFile.GetValueAsInt("BrokenSize", 10, 2);
                    objTemplateSetting.intCharShiftXY = objFile.GetValueAsInt("CharShiftXY", 5, 2);
                    objTemplateSetting.fExtraMinArea = objFile.GetValueAsFloat("ExtraMinArea", 20, 2);
                    objTemplateSetting.fGroupExtraMinArea = objFile.GetValueAsFloat("GroupExtraMinArea", 200, 2);
                    objTemplateSetting.fGroupExcessMinArea = objFile.GetValueAsFloat("GroupExcessMinArea", 100, 2);
                    objTemplateSetting.intExcessMinArea = objFile.GetValueAsInt("ExcessMinArea", 20, 2);
                    objTemplateSetting.intMissingMinArea = objFile.GetValueAsInt("MissingMinArea", 30, 2);
                    objTemplateSetting.intTextMinScore = objFile.GetValueAsInt("TextMinScore", 50, 2);
                    objTemplateSetting.intThreshold = objFile.GetValueAsInt("Threshold", -4, 2);
                    objTemplateSetting.intExtraMarkThreshold = objFile.GetValueAsInt("ExtraMarkThreshold", -4, 2); //objFile
                    objTemplateSetting.fUnCheckAreaBottom = objFile.GetValueAsFloat("UnCheckAreaBottom", 5, 2);
                    objTemplateSetting.fUnCheckAreaLeft = objFile.GetValueAsFloat("UnCheckAreaLeft", 5, 2);
                    objTemplateSetting.fUnCheckAreaRight = objFile.GetValueAsFloat("UnCheckAreaRight", 5, 2);
                    objTemplateSetting.fUnCheckAreaTop = objFile.GetValueAsFloat("UnCheckAreaTop", 5, 2);
                    objTemplateSetting.fMarkAngleTolerance = objFile.GetValueAsFloat("MarkAngleTolerance", 15, 2);
                    objTemplateSetting.fTextShiftX = objFile.GetValueAsFloat("TextShiftX", 0, 2);
                    objTemplateSetting.fTextShiftY = objFile.GetValueAsFloat("TextShiftY", 0, 2);

                    int intCharNum = objFile.GetValueAsInt("CharNum", 0, 2);
                    objFile.GetThirdSection("CharSetting");
                    for (int k = 0; k < intCharNum; k++)
                    {
                        objTemplateSetting.intCharSetting.Add(objFile.GetValueAsInt("CharSetting" + k, m_intDefaultCharSetting, 3));
                    }

                    objFile.GetThirdSection("CharDividedLargestArea");
                    for (int k = 0; k < intCharNum; k++)
                    {
                        objTemplateSetting.intCharDividedLargestArea.Add(objFile.GetValueAsInt("CharDividedLargestArea" + k, 0, 3));
                    }

                    objFile.GetThirdSection("AverageGray");
                    for (int k = 0; k < intCharNum; k++)
                    {
                        objTemplateSetting.fAverageGray.Add(objFile.GetValueAsFloat("AverageGray" + k, 0, 3));
                    }

                    objFile.GetThirdSection("MaxAGVPercent");
                    for (int k = 0; k < intCharNum; k++)
                    {
                        objTemplateSetting.fMaxAGVPercent.Add(objFile.GetValueAsFloat("MaxAGVPercent" + k, 20, 3));
                    }

                    objFile.GetThirdSection("MaxExcessArea");
                    for (int k = 0; k < intCharNum; k++)
                    {
                        objTemplateSetting.arrMaxExcessArea.Add(objFile.GetValueAsFloat("MaxExcessArea" + k, 50, 3));
                    }

                    objFile.GetThirdSection("MaxBrokenArea");
                    for (int k = 0; k < intCharNum; k++)
                    {
                        objTemplateSetting.arrMaxBrokenArea.Add(objFile.GetValueAsFloat("MaxBrokenArea" + k, 50, 3));
                    }

                    objFile.GetThirdSection("WantBrokenMark");
                    for (int k = 0; k < intCharNum; k++)
                    {
                        objTemplateSetting.arrWantBrokenMark.Add(objFile.GetValueAsBoolean("WantBrokenMark" + k, false, 3));
                    }

                    objFile.GetThirdSection("MarkType");
                    for (int k = 0; k < intCharNum; k++)
                    {
                        objTemplateSetting.arrMarkType.Add(objFile.GetValueAsInt("MarkType" + k, 0, 3));
                    }

                    objFile.GetThirdSection("CharShiftX");
                    for (int k = 0; k < intCharNum; k++)
                    {
                        objTemplateSetting.fCharShiftX.Add(objFile.GetValueAsFloat("CharShiftX" + k, 5, 3));
                    }

                    objFile.GetThirdSection("CharShiftY");
                    for (int k = 0; k < intCharNum; k++)
                    {
                        objTemplateSetting.fCharShiftY.Add(objFile.GetValueAsFloat("CharShiftY" + k, 5, 3));
                    }

                    objFile.GetThirdSection("TextCharOffsetX");
                    for (int k = 0; k < intCharNum; k++)
                    {
                        objTemplateSetting.intTextCharOffsetX.Add(objFile.GetValueAsInt("TextCharOffsetX" + k, 0, 3));
                    }

                    objFile.GetThirdSection("TextCharOffsetY");
                    for (int k = 0; k < intCharNum; k++)
                    {
                        objTemplateSetting.intTextCharOffsetY.Add(objFile.GetValueAsInt("TextCharOffsetY" + k, 0, 3));
                    }

                    objFile.GetThirdSection("EnableMark");
                    for (int k = 0; k < intCharNum; k++)    // 2018 10 16 - CCENG: Use intCharNum to make sure blnEnable array count tally with intCharSetting array count. Not tally case will happen when use old recipe.
                    {
                        objTemplateSetting.blnEnable.Add(objFile.GetValueAsBoolean("EnableMark" + k, true, 3)); // 2018 10 16 - CCENG: Default is true because old recipe dun have this parameter. When load from oldd recipe, the mark must auto set to true.
                    }

                    objFile.GetThirdSection("IsBarPin1");
                    for (int k = 0; k < intCharNum; k++)
                    {
                        objTemplateSetting.blnIsBarPin1.Add(objFile.GetValueAsBoolean("IsBarPin1" + k, false, 3));
                    }

                    objFile.GetThirdSection("BarPin1Type");
                    for (int k = 0; k < intCharNum; k++)
                    {
                        objTemplateSetting.arrBarPin1Type.Add(objFile.GetValueAsInt("BarPin1Type" + k, 0, 3));
                    }

                    if (m_intInspectionMode == 0)
                    {
                        if (i < intTemplateNum)
                        {
                            m_arrOCV[i].Add(GetNOCVSetting());//m_arrOCV[i].Add(new NOCV(m_intImageWidth, m_intImageHeight));

                            objFile.GetThirdSection("CharNo");
                            for (int k = 0; k < intCharNum; k++)
                            {
                                m_arrOCV[i][j].SetCharNo(k, objFile.GetValueAsInt("CharNo" + k, k, 3));
                            }

                        }

                        objTemplateSetting.objTemplateImage.LoadImage(strFolderPath + "OriTemplate" + i + "_" + j + ".bmp");
                        objTemplateSetting.objDontCareImage.LoadImage(strFolderPath + "DontCareImage" + i + "_" + j + ".bmp");

                        //2021-05-01 ZJYEOH : dont care image will have individual image
                        for (int z = 0; z < intDontCareROICount; z++)
                        {
                            if (objTemplateSetting.arrDontCareImage.Count <= z)
                                objTemplateSetting.arrDontCareImage.Add(new ImageDrawing(true));

                            if (File.Exists(strFolderPath + "DontCareImage" + i + "_" + j + "_" + z + ".bmp"))
                                objTemplateSetting.arrDontCareImage[z].LoadImage(strFolderPath + "DontCareImage" + i + "_" + 0 + "_" + z + ".bmp"); //2021-05-01 ZJYEOH : Ori Index is i j z, but temporary fix j to 0 as now apply dont care to all template
                            else
                            {
                                objWhiteImage.CopyTo(ref objTemplateSetting.arrDontCareImage, z);
                            }
                        }

                        int intNumTexts = objFile.GetValueAsInt("TextNum", 0, 2);
                        objFile.GetThirdSection("TextROI");
                        for (int tx = 0; tx < intNumTexts; tx++)
                        {
                            objTemplateSetting.arrTemplateTextROI.Add(new ROI());
                            objTemplateSetting.arrTemplateTextROI[tx].LoadROISetting(
                                objFile.GetValueAsInt("TextROIStartX" + tx, 0, 3),
                                objFile.GetValueAsInt("TextROIStartY" + tx, 0, 3),
                                objFile.GetValueAsInt("TextROIWidth" + tx, 0, 3),
                                objFile.GetValueAsInt("TextROIHeight" + tx, 0, 3));

                            objTemplateSetting.arrTemplateTextROI[tx].AttachImage(objTemplateSetting.objTemplateImage);
                        }
                    }
                    else
                    {
                        m_objOCR.ClearTemplateChars();
                        objFile.GetThirdSection("TemplateCharOffSet");
                        int intTemplateCharNum = objFile.GetValueAsInt("TemplateCharOffSetNum", 0, 3);
                        for (int t = 0; t < intTemplateCharNum; t++)
                        {
                            m_objOCR.SetTemplateCharOffSetXY(t,
                                objFile.GetValueAsInt("CharOffSetX" + t, 0, 3),
                                objFile.GetValueAsInt("CharOffSetY" + t, 0, 3));

                            m_objOCR.SetTemplateCharStartPoint(t,
                                objFile.GetValueAsInt("CharStartX" + t, 0, 3),
                                objFile.GetValueAsInt("CharStartY" + t, 0, 3));

                            m_objOCR.SetTemplateCharEndPoint(t,
                                objFile.GetValueAsInt("CharEndX" + t, 0, 3),
                                objFile.GetValueAsInt("CharEndY" + t, 0, 3));

                            m_objOCR.SetTemplateCharSize(t,
                                objFile.GetValueAsInt("CharWidth" + t, 0, 3),
                                objFile.GetValueAsInt("CharHeight" + t, 0, 3));
                        }
                    }

                    m_arrTemplateSetting[i].Add(objTemplateSetting);
                }
            }

            if (m_arrTemplateSetting[m_intGroupIndex].Count > 0)
            {
                m_intTemplateIndex = 0;

                if ((m_intTemplateMask & 0x01) == 0)
                {
                    if ((m_intTemplateMask & 0x02) > 0)
                        m_intTemplateIndex = 1;
                    else if ((m_intTemplateMask & 0x04) > 0)
                        m_intTemplateIndex = 2;
                    else if ((m_intTemplateMask & 0x08) > 0)
                        m_intTemplateIndex = 3;
                    else if ((m_intTemplateMask & 0x10) > 0)
                        m_intTemplateIndex = 4;
                    else if ((m_intTemplateMask & 0x20) > 0)
                        m_intTemplateIndex = 5;
                    else if ((m_intTemplateMask & 0x40) > 0)
                        m_intTemplateIndex = 6;
                    else if ((m_intTemplateMask & 0x80) > 0)
                        m_intTemplateIndex = 7;
                }
            }
            else
                m_intTemplateIndex = -1;

            if (m_intInspectionMode == 0)
            {
                // Load OCV objects
                for (int i = 0; i < m_intGroupNum; i++)
                {
                    for (int j = 0; j < intTemplateNum; j++) //m_arrOCV[i].Count //2020-05-11 ZJYEOH: Need use intTemplateNum because m_arrOCV[i].Count will have value when there ione template setting saved when new lot clear all template
                    {
                        if (File.Exists(strFolderPath + "Template" + i + "_" + j + ".ocv"))
                            m_arrOCV[i][j].LoadOCVFile(strFolderPath + "Template" + i + "_" + j + ".ocv");

                        ImageDrawing objMarkImage = new ImageDrawing();
                        if (File.Exists(strFolderPath + "Template" + i + "_" + j + ".bmp"))
                            objMarkImage.ref_objMainImage.Load(strFolderPath + "Template" + i + "_" + j + ".bmp");
                        //2021-01-03 ZJYEOH : Load Individual Blob Image
                        List<ImageDrawing> arrOCVImage = new List<ImageDrawing>();
                        int intOCVNum = m_arrTemplateSetting[i][j].intCharSetting.Count;
                        for (int k = 0; k < intOCVNum; k++)
                        {
                            arrOCVImage.Add(new ImageDrawing(true));
                            if (File.Exists(strFolderPath + "OCVTemplate" + i + "_" + j + "_" + k + ".bmp"))
                                arrOCVImage[k].ref_objMainImage.Load(strFolderPath + "OCVTemplate" + i + "_" + j + "_" + k + ".bmp");
                            else
                            {
                                if (File.Exists(strFolderPath + "Template" + i + "_" + j + ".bmp"))
                                    arrOCVImage[k].ref_objMainImage.Load(strFolderPath + "Template" + i + "_" + j + ".bmp");
                            }
                        }
                        ROI objMarkROI = new ROI();
                        objMarkROI.LoadROISetting(0, 0, objMarkImage.ref_intImageWidth, objMarkImage.ref_intImageHeight);
                        objMarkROI.AttachImage(objMarkImage);
                        ImageDrawing objOriTemplateImage = new ImageDrawing();
                        if (File.Exists(strFolderPath + "OriTemplate" + i + "_" + j + ".bmp"))
                            objOriTemplateImage.ref_objMainImage.Load(strFolderPath + "OriTemplate" + i + "_" + j + ".bmp");
                        SetErodeDilateSettings(objOriTemplateImage, objMarkImage, arrOCVImage, m_arrTemplateSetting[i][j], m_arrOCV[i][j], objMarkROI);

                        for (int k = 0; k < arrOCVImage.Count; k++)
                            arrOCVImage[k].Dispose();
                        objMarkImage.Dispose();
                        objOriTemplateImage.Dispose();
                        objMarkROI.Dispose();
                    }
                }
            }
            else
            {
                // Load OCR objects
                m_objOCR.Load(strFolderPath);

                if (m_intGroupNum == 1)
                    m_objOCR.SetRefCharCounter(m_arrRefChars[0]);
            }

        }
        public void LoadFirstTemplateSettingOnly(string strFolderPath, bool blnDeleteAllTemplate)
        {
            string[] Split = strFolderPath.Split('\\');
            string strVision = Split[Split.Length - 5] + " - (" + Split[Split.Length - 4] + ") -->";
            XmlParser objFile = new XmlParser(strFolderPath + "Template.xml");
            objFile.GetFirstSection("MarkSettings");

            for (int i = 0; i < m_intGroupNum; i++)
            {
                objFile.GetFirstSection("Group" + i);

                int intTemplateNum = objFile.GetValueAsInt("TemplateNum", 0);

                if (intTemplateNum != 0)
                    return;
                else
                    intTemplateNum = 1;
                //m_arrTemplateSetting[i].Clear();

                for (int j = 0; j < intTemplateNum; j++)
                {
                    if (j < m_arrTemplateSetting[i].Count)
                    {
                        objFile.GetSecondSection("Template" + j);
                        TemplateSetting objTemplateSetting = (TemplateSetting)m_arrTemplateSetting[i][j];
                        objTemplateSetting.intFailOptionMask = objFile.GetValueAsInt("FailOptionMask", 0, 2);
                        STTrackLog.WriteLine(strVision + " Template " + (i + 1).ToString() + " Load Mark Fail Option : " + objTemplateSetting.intFailOptionMask.ToString());
                        objTemplateSetting.intBrokenSize = objFile.GetValueAsInt("BrokenSize", 10, 2);
                        objTemplateSetting.intCharShiftXY = objFile.GetValueAsInt("CharShiftXY", 5, 2);
                        objTemplateSetting.fExtraMinArea = objFile.GetValueAsFloat("ExtraMinArea", 20, 2);
                        objTemplateSetting.fGroupExtraMinArea = objFile.GetValueAsFloat("GroupExtraMinArea", 200, 2);
                        objTemplateSetting.fGroupExcessMinArea = objFile.GetValueAsFloat("GroupExcessMinArea", 100, 2);
                        objTemplateSetting.intExcessMinArea = objFile.GetValueAsInt("ExcessMinArea", 20, 2);
                        objTemplateSetting.intMissingMinArea = objFile.GetValueAsInt("MissingMinArea", 30, 2);
                        objTemplateSetting.intTextMinScore = objFile.GetValueAsInt("TextMinScore", 50, 2);
                        objTemplateSetting.fUnCheckAreaBottom = objFile.GetValueAsFloat("UnCheckAreaBottom", 5, 2);
                        objTemplateSetting.fUnCheckAreaLeft = objFile.GetValueAsFloat("UnCheckAreaLeft", 5, 2);
                        objTemplateSetting.fUnCheckAreaRight = objFile.GetValueAsFloat("UnCheckAreaRight", 5, 2);
                        objTemplateSetting.fUnCheckAreaTop = objFile.GetValueAsFloat("UnCheckAreaTop", 5, 2);
                        objTemplateSetting.fMarkAngleTolerance = objFile.GetValueAsFloat("MarkAngleTolerance", 15, 2);
                        objTemplateSetting.fTextShiftX = objFile.GetValueAsFloat("TextShiftX", 0, 2);
                        objTemplateSetting.fTextShiftY = objFile.GetValueAsFloat("TextShiftY", 0, 2);

                        int intCharNum = objFile.GetValueAsInt("CharNum", 0, 2);
                        int intOriCharNum = objTemplateSetting.intCharSetting.Count;

                        objFile.GetThirdSection("CharSetting");
                        objTemplateSetting.intCharSetting.Clear();
                        //if (intOriCharNum < intCharNum)
                        //    intOriCharNum = intCharNum;
                        for (int k = 0; k < intOriCharNum; k++)
                        {
                            if (k >= intCharNum)
                                objTemplateSetting.intCharSetting.Add(objFile.GetValueAsInt("CharSetting" + (intCharNum - 1), m_intDefaultCharSetting, 3));
                            else
                                objTemplateSetting.intCharSetting.Add(objFile.GetValueAsInt("CharSetting" + k, m_intDefaultCharSetting, 3));
                        }

                        //objFile.GetThirdSection("CharDividedLargestArea");
                        //objTemplateSetting.intCharDividedLargestArea.Clear();
                        ////if (intOriCharNum < intCharNum)
                        ////    intOriCharNum = intCharNum;
                        //for (int k = 0; k < intOriCharNum; k++)
                        //{
                        //    if (k >= intCharNum)
                        //        objTemplateSetting.intCharDividedLargestArea.Add(objFile.GetValueAsInt("CharDividedLargestArea" + (intCharNum - 1), 0, 3));
                        //    else
                        //        objTemplateSetting.intCharDividedLargestArea.Add(objFile.GetValueAsInt("CharDividedLargestArea" + k, 0, 3));
                        //}

                        //objFile.GetThirdSection("AverageGray");
                        //objTemplateSetting.fAverageGray.Clear();
                        ////if (intOriCharNum < intCharNum)
                        ////    intOriCharNum = intCharNum;
                        //for (int k = 0; k < intOriCharNum; k++)
                        //{
                        //    if (k >= intCharNum)
                        //        objTemplateSetting.fAverageGray.Add(objFile.GetValueAsFloat("AverageGray" + (intCharNum - 1), 0, 3));
                        //    else
                        //        objTemplateSetting.fAverageGray.Add(objFile.GetValueAsFloat("AverageGray" + k, 0, 3));
                        //}

                        objFile.GetThirdSection("MaxAGVPercent");
                        objTemplateSetting.fMaxAGVPercent.Clear();
                        //if (intOriCharNum < intCharNum)
                        //    intOriCharNum = intCharNum;
                        for (int k = 0; k < intOriCharNum; k++)
                        {
                            if (k >= intCharNum)
                                objTemplateSetting.fMaxAGVPercent.Add(objFile.GetValueAsFloat("MaxAGVPercent" + (intCharNum - 1), 20, 3));
                            else
                                objTemplateSetting.fMaxAGVPercent.Add(objFile.GetValueAsFloat("MaxAGVPercent" + k, 20, 3));
                        }

                        //intOriCharNum = objTemplateSetting.arrMaxExcessArea.Count;
                        objFile.GetThirdSection("MaxExcessArea");
                        objTemplateSetting.arrMaxExcessArea.Clear();
                        //if (intOriCharNum < intCharNum)
                        //    intOriCharNum = intCharNum;
                        for (int k = 0; k < intOriCharNum; k++)
                        {
                            if (k >= intCharNum)
                                objTemplateSetting.arrMaxExcessArea.Add(objFile.GetValueAsFloat("MaxExcessArea" + (intCharNum - 1), 50, 3));
                            else
                                objTemplateSetting.arrMaxExcessArea.Add(objFile.GetValueAsFloat("MaxExcessArea" + k, 50, 3));
                        }

                        //intOriCharNum = objTemplateSetting.arrMaxBrokenArea.Count;
                        objFile.GetThirdSection("MaxBrokenArea");
                        objTemplateSetting.arrMaxBrokenArea.Clear();
                        //if (intOriCharNum < intCharNum)
                        //    intOriCharNum = intCharNum;
                        for (int k = 0; k < intOriCharNum; k++)
                        {
                            if (k >= intCharNum)
                                objTemplateSetting.arrMaxBrokenArea.Add(objFile.GetValueAsFloat("MaxBrokenArea" + (intCharNum - 1), 50, 3));
                            else
                                objTemplateSetting.arrMaxBrokenArea.Add(objFile.GetValueAsFloat("MaxBrokenArea" + k, 50, 3));
                        }

                        objFile.GetThirdSection("WantBrokenMark");
                        objTemplateSetting.arrWantBrokenMark.Clear();
                        //if (intOriCharNum < intCharNum)
                        //    intOriCharNum = intCharNum;
                        for (int k = 0; k < intOriCharNum; k++)
                        {
                            if (k >= intCharNum)
                                objTemplateSetting.arrWantBrokenMark.Add(objFile.GetValueAsBoolean("WantBrokenMark" + (intCharNum - 1), false, 3));
                            else
                                objTemplateSetting.arrWantBrokenMark.Add(objFile.GetValueAsBoolean("WantBrokenMark" + k, false, 3));
                        }

                        objFile.GetThirdSection("MarkType");
                        objTemplateSetting.arrMarkType.Clear();
                        //if (intOriCharNum < intCharNum)
                        //    intOriCharNum = intCharNum;
                        for (int k = 0; k < intOriCharNum; k++)
                        {
                            if (k >= intCharNum)
                            {
                                objTemplateSetting.arrMarkType.Add(objFile.GetValueAsInt("MarkType" + (intCharNum - 1), 0, 3));
                                m_arrBuildOcvType[k] = objFile.GetValueAsInt("MarkType" + (intCharNum - 1), 0, 3);
                            }
                            else
                            {
                                objTemplateSetting.arrMarkType.Add(objFile.GetValueAsInt("MarkType" + k, 0, 3));
                                m_arrBuildOcvType[k] = objFile.GetValueAsInt("MarkType" + k, 0, 3);
                            }
                        }

                        //intOriCharNum = objTemplateSetting.intCharShiftX.Count;
                        objFile.GetThirdSection("CharShiftX");
                        objTemplateSetting.fCharShiftX.Clear();
                        //if (intOriCharNum < intCharNum)
                        //    intOriCharNum = intCharNum;
                        for (int k = 0; k < intOriCharNum; k++)
                        {
                            if (k >= intCharNum)
                            {
                                if (!blnDeleteAllTemplate)//2021-09-14 ZJYEOH : Only Load Char Shift setting if not delete all template
                                {
                                    objTemplateSetting.fCharShiftX.Add(objFile.GetValueAsFloat("CharShiftX" + (intCharNum - 1), 5, 3));
                                    m_arrBuildOcvCharShiftX[k] = objFile.GetValueAsFloat("CharShiftX" + (intCharNum - 1), 5, 3);
                                }
                                else
                                {
                                    objTemplateSetting.fCharShiftX.Add(0);
                                    m_arrBuildOcvCharShiftX[k] = 0;
                                }
                            }
                            else
                            {
                                if (!blnDeleteAllTemplate)//2021-09-14 ZJYEOH : Only Load Char Shift setting if not delete all template
                                {
                                    objTemplateSetting.fCharShiftX.Add(objFile.GetValueAsFloat("CharShiftX" + k, 5, 3));
                                    m_arrBuildOcvCharShiftX[k] = objFile.GetValueAsFloat("CharShiftX" + k, 5, 3);
                                }
                                else
                                {
                                    objTemplateSetting.fCharShiftX.Add(0);
                                    m_arrBuildOcvCharShiftX[k] = 0;
                                }
                            }
                        }

                        //intOriCharNum = objTemplateSetting.intCharShiftY.Count;
                        objFile.GetThirdSection("CharShiftY");
                        objTemplateSetting.fCharShiftY.Clear();
                        //if (intOriCharNum < intCharNum)
                        //    intOriCharNum = intCharNum;
                        for (int k = 0; k < intOriCharNum; k++)
                        {
                            if (k >= intCharNum)
                            {
                                if (!blnDeleteAllTemplate)//2021-09-14 ZJYEOH : Only Load Char Shift setting if not delete all template
                                {
                                    objTemplateSetting.fCharShiftY.Add(objFile.GetValueAsFloat("CharShiftY" + (intCharNum - 1), 5, 3));
                                    m_arrBuildOcvCharShiftY[k] = objFile.GetValueAsFloat("CharShiftY" + (intCharNum - 1), 5, 3);
                                }
                                else
                                {
                                    objTemplateSetting.fCharShiftY.Add(0);
                                    m_arrBuildOcvCharShiftY[k] = 0;
                                }
                            }
                            else
                            {
                                if (!blnDeleteAllTemplate)//2021-09-14 ZJYEOH : Only Load Char Shift setting if not delete all template
                                {
                                    objTemplateSetting.fCharShiftY.Add(objFile.GetValueAsFloat("CharShiftY" + k, 5, 3));
                                    m_arrBuildOcvCharShiftY[k] = objFile.GetValueAsFloat("CharShiftY" + k, 5, 3);
                                }
                                else
                                {
                                    objTemplateSetting.fCharShiftY.Add(0);
                                    m_arrBuildOcvCharShiftY[k] = 0;
                                }
                            }
                        }

                        ////intOriCharNum = objTemplateSetting.intTextCharOffsetX.Count;
                        //objFile.GetThirdSection("TextCharOffsetX");
                        //objTemplateSetting.intTextCharOffsetX.Clear();
                        ////if (intOriCharNum < intCharNum)
                        ////    intOriCharNum = intCharNum;
                        //for (int k = 0; k < intOriCharNum; k++)
                        //{
                        //    if (k >= intCharNum)
                        //        objTemplateSetting.intTextCharOffsetX.Add(objFile.GetValueAsInt("TextCharOffsetX" + (intCharNum - 1), 0, 3));
                        //    else
                        //        objTemplateSetting.intTextCharOffsetX.Add(objFile.GetValueAsInt("TextCharOffsetX" + k, 0, 3));
                        //}

                        ////intOriCharNum = objTemplateSetting.intTextCharOffsetY.Count;
                        //objFile.GetThirdSection("TextCharOffsetY");
                        //objTemplateSetting.intTextCharOffsetY.Clear();
                        ////if (intOriCharNum < intCharNum)
                        ////    intOriCharNum = intCharNum;
                        //for (int k = 0; k < intOriCharNum; k++)
                        //{
                        //    if (k >= intCharNum)
                        //        objTemplateSetting.intTextCharOffsetY.Add(objFile.GetValueAsInt("TextCharOffsetY" + (intCharNum - 1), 0, 3));
                        //    else
                        //        objTemplateSetting.intTextCharOffsetY.Add(objFile.GetValueAsInt("TextCharOffsetY" + k, 0, 3));
                        //}

                        m_arrTemplateSetting[i].RemoveAt(j);
                        m_arrTemplateSetting[i].Insert(j, objTemplateSetting);
                    }
                    else
                    {
                        objFile.GetSecondSection("Template" + j);
                        TemplateSetting objTemplateSetting = GetTemplateSetting(); //TemplateSetting objTemplateSetting = new TemplateSetting();
                        objTemplateSetting.intFailOptionMask = objFile.GetValueAsInt("FailOptionMask", 0, 2);
                        objTemplateSetting.intBrokenSize = objFile.GetValueAsInt("BrokenSize", 10, 2);
                        objTemplateSetting.intCharShiftXY = objFile.GetValueAsInt("CharShiftXY", 5, 2);
                        objTemplateSetting.fExtraMinArea = objFile.GetValueAsFloat("ExtraMinArea", 20, 2);
                        objTemplateSetting.fGroupExtraMinArea = objFile.GetValueAsFloat("GroupExtraMinArea", 200, 2);
                        objTemplateSetting.fGroupExcessMinArea = objFile.GetValueAsFloat("GroupExcessMinArea", 100, 2);
                        objTemplateSetting.intExcessMinArea = objFile.GetValueAsInt("ExcessMinArea", 20, 2);
                        objTemplateSetting.intMissingMinArea = objFile.GetValueAsInt("MissingMinArea", 30, 2);
                        objTemplateSetting.intTextMinScore = objFile.GetValueAsInt("TextMinScore", 50, 2);
                        objTemplateSetting.fUnCheckAreaBottom = objFile.GetValueAsFloat("UnCheckAreaBottom", 5, 2);
                        objTemplateSetting.fUnCheckAreaLeft = objFile.GetValueAsFloat("UnCheckAreaLeft", 5, 2);
                        objTemplateSetting.fUnCheckAreaRight = objFile.GetValueAsFloat("UnCheckAreaRight", 5, 2);
                        objTemplateSetting.fUnCheckAreaTop = objFile.GetValueAsFloat("UnCheckAreaTop", 5, 2);
                        objTemplateSetting.fMarkAngleTolerance = objFile.GetValueAsFloat("MarkAngleTolerance", 15, 2);

                        int intCharNum = objFile.GetValueAsInt("CharNum", 0, 2);
                        objFile.GetThirdSection("CharSetting");
                        for (int k = 0; k < intCharNum; k++)
                        {
                            objTemplateSetting.intCharSetting.Add(objFile.GetValueAsInt("CharSetting" + k, m_intDefaultCharSetting, 3));
                        }

                        //objFile.GetThirdSection("CharDividedLargestArea");
                        //for (int k = 0; k < intCharNum; k++)
                        //{
                        //    objTemplateSetting.intCharDividedLargestArea.Add(objFile.GetValueAsInt("CharDividedLargestArea" + k, 0, 3));
                        //}

                        //objFile.GetThirdSection("AverageGray");
                        //for (int k = 0; k < intCharNum; k++)
                        //{
                        //    objTemplateSetting.fAverageGray.Add(objFile.GetValueAsFloat("AverageGray" + k, 0, 3));
                        //}

                        objFile.GetThirdSection("MaxAGVPercent");
                        for (int k = 0; k < intCharNum; k++)
                        {
                            objTemplateSetting.fMaxAGVPercent.Add(objFile.GetValueAsFloat("MaxAGVPercent" + k, 20, 3));
                        }

                        objFile.GetThirdSection("MaxExcessArea");
                        for (int k = 0; k < intCharNum; k++)
                        {
                            objTemplateSetting.arrMaxExcessArea.Add(objFile.GetValueAsFloat("MaxExcessArea" + k, 50, 3));
                        }

                        objFile.GetThirdSection("MaxBrokenArea");
                        for (int k = 0; k < intCharNum; k++)
                        {
                            objTemplateSetting.arrMaxBrokenArea.Add(objFile.GetValueAsFloat("MaxBrokenArea" + k, 50, 3));
                        }

                        objFile.GetThirdSection("WantBrokenMark");
                        for (int k = 0; k < intCharNum; k++)
                        {
                            objTemplateSetting.arrWantBrokenMark.Add(objFile.GetValueAsBoolean("WantBrokenMark" + k, false, 3));
                        }

                        objFile.GetThirdSection("MarkType");
                        for (int k = 0; k < intCharNum; k++)
                        {
                            objTemplateSetting.arrMarkType.Add(objFile.GetValueAsInt("MarkType" + k, 0, 3));
                        }


                        objFile.GetThirdSection("CharShiftX");
                        for (int k = 0; k < intCharNum; k++)
                        {
                            if (!blnDeleteAllTemplate)//2021-09-14 ZJYEOH : Only Load Char Shift setting if not delete all template
                            {
                                objTemplateSetting.fCharShiftX.Add(objFile.GetValueAsFloat("CharShiftX" + k, 5, 3));
                            }
                            else
                            {
                                objTemplateSetting.fCharShiftX.Add(0);
                            }
                        }

                        objFile.GetThirdSection("CharShiftY");
                        for (int k = 0; k < intCharNum; k++)
                        {
                            if (!blnDeleteAllTemplate)//2021-09-14 ZJYEOH : Only Load Char Shift setting if not delete all template
                            {
                                objTemplateSetting.fCharShiftY.Add(objFile.GetValueAsFloat("CharShiftY" + k, 5, 3));
                            }
                            else
                            {
                                objTemplateSetting.fCharShiftY.Add(0);
                            }
                        }

                        objFile.GetThirdSection("TextCharOffsetX");
                        for (int k = 0; k < intCharNum; k++)
                        {
                            objTemplateSetting.intTextCharOffsetX.Add(objFile.GetValueAsInt("TextCharOffsetX" + k, 0, 3));
                        }

                        objFile.GetThirdSection("TextCharOffsetY");
                        for (int k = 0; k < intCharNum; k++)
                        {
                            objTemplateSetting.intTextCharOffsetY.Add(objFile.GetValueAsInt("TextCharOffsetY" + k, 0, 3));
                        }

                        m_arrTemplateSetting[i].Add(objTemplateSetting);
                    }
                }
            }
        }
        public void LoadTemplateToleranceOnly(string strFolderPath)
        {
            XmlParser objFile = new XmlParser(strFolderPath + "Template.xml");
            objFile.GetFirstSection("MarkSettings");

            for (int i = 0; i < m_intGroupNum; i++)
            {
                objFile.GetFirstSection("Group" + i);

                int intTemplateNum = objFile.GetValueAsInt("TemplateNum", 0);

                //m_arrTemplateSetting[i].Clear();

                for (int j = 0; j < intTemplateNum; j++)
                {
                    if (j < m_arrTemplateSetting[i].Count)
                    {
                        objFile.GetSecondSection("Template" + j);
                        TemplateSetting objTemplateSetting = (TemplateSetting)m_arrTemplateSetting[i][j];
                        objTemplateSetting.intBrokenSize = objFile.GetValueAsInt("BrokenSize", 10, 2);
                        objTemplateSetting.intCharShiftXY = objFile.GetValueAsInt("CharShiftXY", 5, 2);
                        objTemplateSetting.fExtraMinArea = objFile.GetValueAsFloat("ExtraMinArea", 20, 2);
                        objTemplateSetting.fGroupExtraMinArea = objFile.GetValueAsFloat("GroupExtraMinArea", 200, 2);
                        objTemplateSetting.fGroupExcessMinArea = objFile.GetValueAsFloat("GroupExcessMinArea", 100, 2);
                        objTemplateSetting.intExcessMinArea = objFile.GetValueAsInt("ExcessMinArea", 20, 2);
                        objTemplateSetting.intMissingMinArea = objFile.GetValueAsInt("MissingMinArea", 30, 2);
                        objTemplateSetting.intTextMinScore = objFile.GetValueAsInt("TextMinScore", 50, 2);
                        objTemplateSetting.fUnCheckAreaBottom = objFile.GetValueAsFloat("UnCheckAreaBottom", 5, 2);
                        objTemplateSetting.fUnCheckAreaLeft = objFile.GetValueAsFloat("UnCheckAreaLeft", 5, 2);
                        objTemplateSetting.fUnCheckAreaRight = objFile.GetValueAsFloat("UnCheckAreaRight", 5, 2);
                        objTemplateSetting.fUnCheckAreaTop = objFile.GetValueAsFloat("UnCheckAreaTop", 5, 2);
                        objTemplateSetting.fMarkAngleTolerance = objFile.GetValueAsFloat("MarkAngleTolerance", 15, 2);
                        objTemplateSetting.fTextShiftX = objFile.GetValueAsFloat("TextShiftX", 0, 2);
                        objTemplateSetting.fTextShiftY = objFile.GetValueAsFloat("TextShiftY", 0, 2);

                        int intCharNum = objFile.GetValueAsInt("CharNum", 0, 2);
                        objFile.GetThirdSection("CharSetting");
                        objTemplateSetting.intCharSetting.Clear();
                        for (int k = 0; k < intCharNum; k++)
                        {
                            objTemplateSetting.intCharSetting.Add(objFile.GetValueAsInt("CharSetting" + k, m_intDefaultCharSetting, 3));
                        }

                        //objFile.GetThirdSection("CharDividedLargestArea");
                        //objTemplateSetting.intCharDividedLargestArea.Clear();
                        //for (int k = 0; k < intCharNum; k++)
                        //{
                        //    objTemplateSetting.intCharDividedLargestArea.Add(objFile.GetValueAsInt("CharDividedLargestArea" + k, 0, 3));
                        //}

                        //objFile.GetThirdSection("AverageGray");
                        //objTemplateSetting.fAverageGray.Clear();
                        //for (int k = 0; k < intCharNum; k++)
                        //{
                        //    objTemplateSetting.fAverageGray.Add(objFile.GetValueAsFloat("AverageGray" + k, 0, 3));
                        //}

                        objFile.GetThirdSection("MaxAGVPercent");
                        objTemplateSetting.fMaxAGVPercent.Clear();
                        for (int k = 0; k < intCharNum; k++)
                        {
                            objTemplateSetting.fMaxAGVPercent.Add(objFile.GetValueAsFloat("MaxAGVPercent" + k, 20, 3));
                        }

                        objFile.GetThirdSection("MaxExcessArea");
                        objTemplateSetting.arrMaxExcessArea.Clear();
                        for (int k = 0; k < intCharNum; k++)
                        {
                            objTemplateSetting.arrMaxExcessArea.Add(objFile.GetValueAsFloat("MaxExcessArea" + k, 50, 3));
                        }

                        objFile.GetThirdSection("MaxBrokenArea");
                        objTemplateSetting.arrMaxBrokenArea.Clear();
                        for (int k = 0; k < intCharNum; k++)
                        {
                            objTemplateSetting.arrMaxBrokenArea.Add(objFile.GetValueAsFloat("MaxBrokenArea" + k, 50, 3));
                        }

                        objFile.GetThirdSection("WantBrokenMark");
                        objTemplateSetting.arrWantBrokenMark.Clear();
                        for (int k = 0; k < intCharNum; k++)
                        {
                            objTemplateSetting.arrWantBrokenMark.Add(objFile.GetValueAsBoolean("WantBrokenMark" + k, false, 3));
                        }

                        objFile.GetThirdSection("MarkType");
                        objTemplateSetting.arrMarkType.Clear();
                        for (int k = 0; k < intCharNum; k++)
                        {
                            objTemplateSetting.arrMarkType.Add(objFile.GetValueAsInt("MarkType" + k, 0, 3));
                        }

                        objFile.GetThirdSection("CharShiftX");
                        objTemplateSetting.fCharShiftX.Clear();
                        for (int k = 0; k < intCharNum; k++)
                        {
                            objTemplateSetting.fCharShiftX.Add(objFile.GetValueAsFloat("CharShiftX" + k, 5, 3));
                        }

                        objFile.GetThirdSection("CharShiftY");
                        objTemplateSetting.fCharShiftY.Clear();
                        for (int k = 0; k < intCharNum; k++)
                        {
                            objTemplateSetting.fCharShiftY.Add(objFile.GetValueAsFloat("CharShiftY" + k, 5, 3));
                        }

                        objFile.GetThirdSection("TextCharOffsetX");
                        objTemplateSetting.intTextCharOffsetX.Clear();
                        for (int k = 0; k < intCharNum; k++)
                        {
                            objTemplateSetting.intTextCharOffsetX.Add(objFile.GetValueAsInt("TextCharOffsetX" + k, 0, 3));
                        }

                        objFile.GetThirdSection("TextCharOffsetY");
                        objTemplateSetting.intTextCharOffsetY.Clear();
                        for (int k = 0; k < intCharNum; k++)
                        {
                            objTemplateSetting.intTextCharOffsetY.Add(objFile.GetValueAsInt("TextCharOffsetY" + k, 0, 3));
                        }

                        m_arrTemplateSetting[i].RemoveAt(j);
                        m_arrTemplateSetting[i].Insert(j, objTemplateSetting);
                    }
                    else
                    {
                        objFile.GetSecondSection("Template" + j);
                        TemplateSetting objTemplateSetting = GetTemplateSetting(); //TemplateSetting objTemplateSetting = new TemplateSetting();
                        objTemplateSetting.intBrokenSize = objFile.GetValueAsInt("BrokenSize", 10, 2);
                        objTemplateSetting.intCharShiftXY = objFile.GetValueAsInt("CharShiftXY", 5, 2);
                        objTemplateSetting.fExtraMinArea = objFile.GetValueAsFloat("ExtraMinArea", 20, 2);
                        objTemplateSetting.fGroupExtraMinArea = objFile.GetValueAsFloat("GroupExtraMinArea", 200, 2);
                        objTemplateSetting.fGroupExcessMinArea = objFile.GetValueAsFloat("GroupExcessMinArea", 100, 2);
                        objTemplateSetting.intExcessMinArea = objFile.GetValueAsInt("ExcessMinArea", 20, 2);
                        objTemplateSetting.intMissingMinArea = objFile.GetValueAsInt("MissingMinArea", 30, 2);
                        objTemplateSetting.intTextMinScore = objFile.GetValueAsInt("TextMinScore", 50, 2);
                        objTemplateSetting.fUnCheckAreaBottom = objFile.GetValueAsFloat("UnCheckAreaBottom", 5, 2);
                        objTemplateSetting.fUnCheckAreaLeft = objFile.GetValueAsFloat("UnCheckAreaLeft", 5, 2);
                        objTemplateSetting.fUnCheckAreaRight = objFile.GetValueAsFloat("UnCheckAreaRight", 5, 2);
                        objTemplateSetting.fUnCheckAreaTop = objFile.GetValueAsFloat("UnCheckAreaTop", 5, 2);
                        objTemplateSetting.fMarkAngleTolerance = objFile.GetValueAsFloat("MarkAngleTolerance", 15, 2);
                        objTemplateSetting.fTextShiftX = objFile.GetValueAsFloat("TextShiftX", 0, 2);
                        objTemplateSetting.fTextShiftY = objFile.GetValueAsFloat("TextShiftY", 0, 2);

                        int intCharNum = objFile.GetValueAsInt("CharNum", 0, 2);
                        objFile.GetThirdSection("CharSetting");
                        for (int k = 0; k < intCharNum; k++)
                        {
                            objTemplateSetting.intCharSetting.Add(objFile.GetValueAsInt("CharSetting" + k, m_intDefaultCharSetting, 3));
                        }

                        //objFile.GetThirdSection("CharDividedLargestArea");
                        //for (int k = 0; k < intCharNum; k++)
                        //{
                        //    objTemplateSetting.intCharDividedLargestArea.Add(objFile.GetValueAsInt("CharDividedLargestArea" + k, 0, 3));
                        //}

                        //objFile.GetThirdSection("AverageGray");
                        //for (int k = 0; k < intCharNum; k++)
                        //{
                        //    objTemplateSetting.fAverageGray.Add(objFile.GetValueAsFloat("AverageGray" + k, 0, 3));
                        //}

                        objFile.GetThirdSection("MaxAGVPercent");
                        for (int k = 0; k < intCharNum; k++)
                        {
                            objTemplateSetting.fMaxAGVPercent.Add(objFile.GetValueAsFloat("MaxAGVPercent" + k, 20, 3));
                        }

                        objFile.GetThirdSection("MaxExcessArea");
                        for (int k = 0; k < intCharNum; k++)
                        {
                            objTemplateSetting.arrMaxExcessArea.Add(objFile.GetValueAsFloat("MaxExcessArea" + k, 50, 3));
                        }

                        objFile.GetThirdSection("MaxBrokenArea");
                        for (int k = 0; k < intCharNum; k++)
                        {
                            objTemplateSetting.arrMaxBrokenArea.Add(objFile.GetValueAsFloat("MaxBrokenArea" + k, 50, 3));
                        }

                        objFile.GetThirdSection("WantBrokenMark");
                        for (int k = 0; k < intCharNum; k++)
                        {
                            objTemplateSetting.arrWantBrokenMark.Add(objFile.GetValueAsBoolean("WantBrokenMark" + k, false, 3));
                        }

                        objFile.GetThirdSection("MarkType");
                        for (int k = 0; k < intCharNum; k++)
                        {
                            objTemplateSetting.arrMarkType.Add(objFile.GetValueAsInt("MarkType" + k, 0, 3));
                        }

                        objFile.GetThirdSection("CharShiftX");
                        for (int k = 0; k < intCharNum; k++)
                        {
                            objTemplateSetting.fCharShiftX.Add(objFile.GetValueAsFloat("CharShiftX" + k, 5, 3));
                        }

                        objFile.GetThirdSection("CharShiftY");
                        for (int k = 0; k < intCharNum; k++)
                        {
                            objTemplateSetting.fCharShiftY.Add(objFile.GetValueAsFloat("CharShiftY" + k, 5, 3));
                        }

                        objFile.GetThirdSection("TextCharOffsetX");
                        for (int k = 0; k < intCharNum; k++)
                        {
                            objTemplateSetting.intTextCharOffsetX.Add(objFile.GetValueAsInt("TextCharOffsetX" + k, 0, 3));
                        }

                        objFile.GetThirdSection("TextCharOffsetY");
                        for (int k = 0; k < intCharNum; k++)
                        {
                            objTemplateSetting.intTextCharOffsetY.Add(objFile.GetValueAsInt("TextCharOffsetY" + k, 0, 3));
                        }

                        m_arrTemplateSetting[i].Add(objTemplateSetting);
                    }
                }
            }

        }
        public void SaveSingleTemplate(string strFolderPath, bool blnWantSaveTemplateCharImage, bool blnDeleteAllMarkTemplate_Learn)
        {
            string[] Split = strFolderPath.Split('\\');
            string strVision = Split[Split.Length - 5] + " - (" + Split[Split.Length - 4] + ") -->";
            // Save mark settings
            XmlParser objFile = new XmlParser(strFolderPath + "Template.xml");
            objFile.WriteSectionElement("MarkSettings");
            objFile.WriteElement1Value("CheckMark", m_blnCheckMark);
            objFile.WriteElement1Value("FailOptionMask", m_intFailOptionMask);
            objFile.WriteElement1Value("FailOptionMask_ForPreTest", m_intFailOptionMask_ForPreTest);
            objFile.WriteElement1Value("MinArea", m_intMinArea);
            //objFile.WriteElement1Value("MarkROIOffsetTop", m_intMarkROIOffsetTop);
            //objFile.WriteElement1Value("MarkROIOffsetRight", m_intMarkROIOffsetRight);
            //objFile.WriteElement1Value("MarkROIOffsetBottom", m_intMarkROIOffsetBottom);
            //objFile.WriteElement1Value("MarkROIOffsetLeft", m_intMarkROIOffsetLeft);
            objFile.WriteElement1Value("LeadDontCareInwardTolerance_Top", m_intLeadDontCareInwardTolerance_Top);
            objFile.WriteElement1Value("LeadDontCareInwardTolerance_Right", m_intLeadDontCareInwardTolerance_Right);
            objFile.WriteElement1Value("LeadDontCareInwardTolerance_Bottom", m_intLeadDontCareInwardTolerance_Bottom);
            objFile.WriteElement1Value("LeadDontCareInwardTolerance_Left", m_intLeadDontCareInwardTolerance_Left);
            objFile.WriteElement1Value("MaxArea", m_intMaxArea);
            objFile.WriteElement1Value("CharDilateHalfWidth", m_intCharDilateHalfWidth);
            objFile.WriteElement1Value("CharOpenHalfWidth", m_intCharOpenHalfWidth);
            objFile.WriteElement1Value("CharErodeHalfWidth", m_intCharErodeHalfWidth);
            objFile.WriteElement1Value("EnhanceMark_LinkMark_HalfWidth", m_intEnhanceMark_LinkMark_HalfWidth);
            objFile.WriteElement1Value("EnhanceMark_ReduceNoise_HalfWidth", m_intEnhanceMark_ReduceNoise_HalfWidth);
            objFile.WriteElement1Value("LearnMinArea", m_intLearnMinArea);
            objFile.WriteElement1Value("TemplateMask", m_intTemplateMask);
            objFile.WriteElement1Value("TemplatePriority", m_intTemplatePriority);
            objFile.WriteElement1Value("WhiteOnBlack", m_blnWhiteOnBlack);

            int intTemplateNum = 0;

            for (int i = 0; i < m_intGroupNum; i++)
            {
                objFile.WriteSectionElement("Group" + i);

                if (m_intInspectionMode == 0)
                {
                    //if (m_arrOCV[i].Count == 0)
                    //    return;
                    // Get total template
                    intTemplateNum = m_arrOCV[i].Count; // 2020-05-11 ZJYEOH : Save first template only

                }
                else
                {
                    intTemplateNum = 1;
                    objFile.WriteElement1Value("RefChar", m_arrRefChars[i]);
                }

                // Save total template
                objFile.WriteElement1Value("TemplateNum", 0); //intTemplateNum

                // Save each template setting
                for (int j = 0; j < Math.Max(1, intTemplateNum); j++)
                {
                    // Save tolerance settting
                    objFile.WriteElement1Value("Template" + j, "");
                    objFile.WriteElement2Value("FailOptionMask", m_arrTemplateSetting[i][j].intFailOptionMask, "Group " + (i + 1).ToString() + " Template " + (j + 1).ToString(), true);
                    STTrackLog.WriteLine(strVision + " Template " + (i + 1).ToString() + "Blob " + (j + 1).ToString() + " Save Mark Fail Option : " + m_arrTemplateSetting[i][j].intFailOptionMask.ToString());
                    objFile.WriteElement2Value("BrokenSize", m_arrTemplateSetting[i][j].intBrokenSize, "Group " + (i + 1).ToString() + " Template " + (j + 1).ToString(), true);
                    objFile.WriteElement2Value("CharShiftXY", m_arrTemplateSetting[i][j].intCharShiftXY, "Group " + (i + 1).ToString() + " Template " + (j + 1).ToString(), true);
                    objFile.WriteElement2Value("ExtraMinArea", m_arrTemplateSetting[i][j].fExtraMinArea, "Group " + (i + 1).ToString() + " Template " + (j + 1).ToString(), true);
                    objFile.WriteElement2Value("GroupExtraMinArea", m_arrTemplateSetting[i][j].fGroupExtraMinArea, "Group " + (i + 1).ToString() + " Template " + (j + 1).ToString(), true);
                    objFile.WriteElement2Value("GroupExcessMinArea", m_arrTemplateSetting[i][j].fGroupExcessMinArea, "Group " + (i + 1).ToString() + " Template " + (j + 1).ToString(), true);
                    objFile.WriteElement2Value("ExcessMinArea", m_arrTemplateSetting[i][j].intExcessMinArea, "Group " + (i + 1).ToString() + " Template " + (j + 1).ToString(), true);
                    objFile.WriteElement2Value("MissingMinArea", m_arrTemplateSetting[i][j].intMissingMinArea, "Group " + (i + 1).ToString() + " Template " + (j + 1).ToString(), true);
                    objFile.WriteElement2Value("TextMinScore", m_arrTemplateSetting[i][j].intTextMinScore, "Group " + (i + 1).ToString() + " Template " + (j + 1).ToString(), true);
                    objFile.WriteElement2Value("Threshold", m_arrTemplateSetting[i][j].intThreshold, "Group " + (i + 1).ToString() + " Template " + (j + 1).ToString(), true);

                    objFile.WriteElement2Value("ExtraMarkThreshold", m_arrTemplateSetting[i][j].intExtraMarkThreshold, "Group " + (i + 1).ToString() + " Template " + (j + 1).ToString(), true);

                    objFile.WriteElement2Value("UnCheckAreaBottom", m_arrTemplateSetting[i][j].fUnCheckAreaBottom, "Group " + (i + 1).ToString() + " Template " + (j + 1).ToString(), true);
                    objFile.WriteElement2Value("UnCheckAreaLeft", m_arrTemplateSetting[i][j].fUnCheckAreaLeft, "Group " + (i + 1).ToString() + " Template " + (j + 1).ToString(), true);
                    objFile.WriteElement2Value("UnCheckAreaRight", m_arrTemplateSetting[i][j].fUnCheckAreaRight, "Group " + (i + 1).ToString() + " Template " + (j + 1).ToString(), true);
                    objFile.WriteElement2Value("UnCheckAreaTop", m_arrTemplateSetting[i][j].fUnCheckAreaTop, "Group " + (i + 1).ToString() + " Template " + (j + 1).ToString(), true);
                    objFile.WriteElement2Value("MarkAngleTolerance", m_arrTemplateSetting[i][j].fMarkAngleTolerance, "Group " + (i + 1).ToString() + " Template " + (j + 1).ToString(), true);
                    objFile.WriteElement2Value("CharNum", m_arrTemplateSetting[i][j].intCharSetting.Count, "Group " + (i + 1).ToString() + " Template " + (j + 1).ToString(), true);
                    objFile.WriteElement2Value("TextShiftX", m_arrTemplateSetting[i][j].fTextShiftX, "Group " + (i + 1).ToString() + " Template " + (j + 1).ToString(), true);
                    objFile.WriteElement2Value("TextShiftY", m_arrTemplateSetting[i][j].fTextShiftY, "Group " + (i + 1).ToString() + " Template " + (j + 1).ToString(), true);

                    // Save Char Score Setting
                    objFile.WriteElement2Value("CharSetting", "");
                    for (int k = 0; k < m_arrTemplateSetting[i][j].intCharSetting.Count; k++)
                    {
                        //2021-08-03 ZJYEOH : Save first template mark score using default mark score if user delete all mark templates during learn mark
                        //2020-12-31 ZJYEOH Save first template mark score using default mark score if user want use default mark score after new lot clear template
                        if (m_blnUseDefaultSettingMarkAfterClearTemplate || (m_blnUseDefaultSettingMarkAfterClearTemplate && blnDeleteAllMarkTemplate_Learn))
                            objFile.WriteElement3Value("CharSetting" + k, m_intDefaultCharSetting, "Group" + (i + 1).ToString() + " Template" + (j + 1).ToString() + " Char" + (k + 1).ToString(), true);
                        else
                            objFile.WriteElement3Value("CharSetting" + k, m_arrTemplateSetting[i][j].intCharSetting[k], "Group" + (i + 1).ToString() + " Template" + (j + 1).ToString() + " Char" + (k + 1).ToString(), true);
                    }

                    objFile.WriteElement2Value("CharDividedLargestArea", "");
                    for (int k = 0; k < m_arrTemplateSetting[i][j].intCharDividedLargestArea.Count; k++)
                    {
                        objFile.WriteElement3Value("CharDividedLargestArea" + k, m_arrTemplateSetting[i][j].intCharDividedLargestArea[k], "Group" + (i + 1).ToString() + " Template" + (j + 1).ToString() + " Char" + (k + 1).ToString(), true);
                    }

                    objFile.WriteElement2Value("AverageGray", "");
                    for (int k = 0; k < m_arrTemplateSetting[i][j].fAverageGray.Count; k++)
                    {
                        objFile.WriteElement3Value("AverageGray" + k, m_arrTemplateSetting[i][j].fAverageGray[k], "Group" + (i + 1).ToString() + " Template" + (j + 1).ToString() + " Char" + (k + 1).ToString(), true);
                    }

                    objFile.WriteElement2Value("MaxAGVPercent", "");
                    for (int k = 0; k < m_arrTemplateSetting[i][j].fMaxAGVPercent.Count; k++)
                    {
                        objFile.WriteElement3Value("MaxAGVPercent" + k, m_arrTemplateSetting[i][j].fMaxAGVPercent[k], "Group" + (i + 1).ToString() + " Template" + (j + 1).ToString() + " Char" + (k + 1).ToString(), true);
                    }

                    objFile.WriteElement2Value("MaxExcessArea", "");
                    for (int k = 0; k < m_arrTemplateSetting[i][j].arrMaxExcessArea.Count; k++)
                    {
                        objFile.WriteElement3Value("MaxExcessArea" + k, m_arrTemplateSetting[i][j].arrMaxExcessArea[k], "Group" + (i + 1).ToString() + " Template" + (j + 1).ToString() + " Char" + (k + 1).ToString(), true);
                    }

                    objFile.WriteElement2Value("MaxBrokenArea", "");
                    for (int k = 0; k < m_arrTemplateSetting[i][j].arrMaxBrokenArea.Count; k++)
                    {
                        objFile.WriteElement3Value("MaxBrokenArea" + k, m_arrTemplateSetting[i][j].arrMaxBrokenArea[k], "Group" + (i + 1).ToString() + " Template" + (j + 1).ToString() + " Char" + (k + 1).ToString(), true);
                    }

                    objFile.WriteElement2Value("WantBrokenMark", "");
                    for (int k = 0; k < m_arrTemplateSetting[i][j].arrWantBrokenMark.Count; k++)
                    {
                        objFile.WriteElement3Value("WantBrokenMark" + k, m_arrTemplateSetting[i][j].arrWantBrokenMark[k]);
                    }

                    objFile.WriteElement2Value("MarkType", "");
                    for (int k = 0; k < m_arrTemplateSetting[i][j].arrMarkType.Count; k++)
                    {
                        objFile.WriteElement3Value("MarkType" + k, m_arrTemplateSetting[i][j].arrMarkType[k]);
                    }

                    objFile.WriteElement2Value("CharShiftX", "");
                    for (int k = 0; k < m_arrTemplateSetting[i][j].fCharShiftX.Count; k++)
                    {
                        objFile.WriteElement3Value("CharShiftX" + k, m_arrTemplateSetting[i][j].fCharShiftX[k], "Group" + (i + 1).ToString() + " Template" + (j + 1).ToString() + " Char" + (k + 1).ToString(), true);
                    }

                    objFile.WriteElement2Value("CharShiftY", "");
                    for (int k = 0; k < m_arrTemplateSetting[i][j].fCharShiftY.Count; k++)
                    {
                        objFile.WriteElement3Value("CharShiftY" + k, m_arrTemplateSetting[i][j].fCharShiftY[k], "Group" + (i + 1).ToString() + " Template" + (j + 1).ToString() + " Char" + (k + 1).ToString(), true);
                    }

                    objFile.WriteElement2Value("TextCharOffsetX", "");
                    for (int k = 0; k < m_arrTemplateSetting[i][j].intTextCharOffsetX.Count; k++)
                    {
                        objFile.WriteElement3Value("TextCharOffsetX" + k, m_arrTemplateSetting[i][j].intTextCharOffsetX[k], "Group" + (i + 1).ToString() + " Template" + (j + 1).ToString() + " Char" + (k + 1).ToString(), true);
                    }

                    objFile.WriteElement2Value("TextCharOffsetY", "");
                    for (int k = 0; k < m_arrTemplateSetting[i][j].intTextCharOffsetY.Count; k++)
                    {
                        objFile.WriteElement3Value("TextCharOffsetY" + k, m_arrTemplateSetting[i][j].intTextCharOffsetY[k], "Group" + (i + 1).ToString() + " Template" + (j + 1).ToString() + " Char" + (k + 1).ToString(), true);
                    }

                    objFile.WriteElement2Value("EnableMark", "");
                    for (int k = 0; k < m_arrTemplateSetting[i][j].blnEnable.Count; k++)
                    {
                        objFile.WriteElement3Value("EnableMark" + k, m_arrTemplateSetting[i][j].blnEnable[k], "Group" + (i + 1).ToString() + " Template" + (j + 1).ToString() + " Char" + (k + 1).ToString(), true);
                    }

                    objFile.WriteElement2Value("IsBarPin1", "");
                    for (int k = 0; k < m_arrTemplateSetting[i][j].blnIsBarPin1.Count; k++)
                    {
                        objFile.WriteElement3Value("IsBarPin1" + k, m_arrTemplateSetting[i][j].blnIsBarPin1[k], "Group" + (i + 1).ToString() + " Template" + (j + 1).ToString() + " Char" + (k + 1).ToString(), true);
                    }

                    objFile.WriteElement2Value("BarPin1Type", "");
                    for (int k = 0; k < m_arrTemplateSetting[i][j].arrBarPin1Type.Count; k++)
                    {
                        objFile.WriteElement3Value("BarPin1Type" + k, m_arrTemplateSetting[i][j].arrBarPin1Type[k], "Group" + (i + 1).ToString() + " Template" + (j + 1).ToString() + " Char" + (k + 1).ToString(), true);
                    }

                    if (m_intInspectionMode == 0)
                    {
                        if (i < intTemplateNum)
                        {
                            // Save Char Represent Number
                            objFile.WriteElement2Value("CharNo", "");
                            for (int k = 0; k < m_arrTemplateSetting[i][j].intCharSetting.Count; k++)
                            {
                                objFile.WriteElement3Value("CharNo" + k, m_arrOCV[i][j].GetCharNo(k));
                            }
                        }

                        //// Save Each Char Start Point and Size (Based on template image)
                        //objFile.WriteElement2Value("CharROI", "");
                        //for (int k = 0; k < m_arrTemplateSetting[i][j].intCharSetting.Count; k++)
                        //{
                        //    objFile.WriteElement3Value("CharROIStartX" + k, m_arrTemplateSetting[i][j].arrTemplateCharDilateROI[k].ref_ROIPositionX);
                        //    objFile.WriteElement3Value("CharROIStartY" + k, m_arrTemplateSetting[i][j].arrTemplateCharDilateROI[k].ref_ROIPositionY);
                        //    objFile.WriteElement3Value("CharROIWidth" + k, m_arrTemplateSetting[i][j].arrTemplateCharDilateROI[k].ref_ROIWidth);
                        //    objFile.WriteElement3Value("CharROIHeight" + k, m_arrTemplateSetting[i][j].arrTemplateCharDilateROI[k].ref_ROIHeight);                           
                        //}

                        int intNumTexts = m_arrTemplateSetting[i][j].arrTemplateTextROI.Count;
                        objFile.WriteElement2Value("TextNum", intNumTexts);
                        objFile.WriteElement2Value("TextROI", "");
                        for (int tx = 0; tx < intNumTexts; tx++)
                        {
                            objFile.WriteElement3Value("TextROIStartX" + tx, m_arrTemplateSetting[i][j].arrTemplateTextROI[tx].ref_ROIPositionX, "Group" + (i + 1).ToString() + " Template" + (j + 1).ToString() + " Text" + (tx + 1).ToString(), true);
                            objFile.WriteElement3Value("TextROIStartY" + tx, m_arrTemplateSetting[i][j].arrTemplateTextROI[tx].ref_ROIPositionY, "Group" + (i + 1).ToString() + " Template" + (j + 1).ToString() + " Char" + (tx + 1).ToString(), true);
                            objFile.WriteElement3Value("TextROIWidth" + tx, m_arrTemplateSetting[i][j].arrTemplateTextROI[tx].ref_ROIWidth, "Group" + (i + 1).ToString() + " Template" + (j + 1).ToString() + " Char" + (tx + 1).ToString(), true);
                            objFile.WriteElement3Value("TextROIHeight" + tx, m_arrTemplateSetting[i][j].arrTemplateTextROI[tx].ref_ROIHeight, "Group" + (i + 1).ToString() + " Template" + (j + 1).ToString() + " Char" + (tx + 1).ToString(), true);

                            //Save Char Image
                            if (blnWantSaveTemplateCharImage)
                                m_arrTemplateSetting[i][j].arrTemplateTextROI[tx].SaveImage(strFolderPath + "OriTemplate" + i + "_" + j + "_Char" + tx + ".bmp");
                        }
                    }
                    else
                    {
                        // Save char off set to text vaue
                        objFile.WriteElement2Value("TemplateCharOffSet", "");
                        objFile.WriteElement3Value("TemplateCharOffSetNum", m_objOCR.ref_NumTemplateChars);
                        int intX = 0, intY = 0;
                        for (int k = 0; k < m_objOCR.ref_NumTemplateChars; k++)
                        {
                            m_objOCR.GetTemplateCharOffSet(k, ref intX, ref intY);
                            objFile.WriteElement3Value("CharOffSetX" + k, intX);
                            objFile.WriteElement3Value("CharOffSetY" + k, intY);

                            m_objOCR.GetTemplateCharStartPoint(k, ref intX, ref intY);
                            objFile.WriteElement3Value("CharStartX" + k, intX);
                            objFile.WriteElement3Value("CharStartY" + k, intY);

                            m_objOCR.GetTemplateCharEndPoint(k, ref intX, ref intY);
                            objFile.WriteElement3Value("CharEndX" + k, intX);
                            objFile.WriteElement3Value("CharEndY" + k, intY);

                            m_objOCR.GetTemplateCharSize(k, ref intX, ref intY);
                            objFile.WriteElement3Value("CharWidth" + k, intX);
                            objFile.WriteElement3Value("CharHeight" + k, intY);
                        }
                    }
                }
            }

            objFile.WriteEndElement();

            if (m_intInspectionMode == 0)
            {
                // Save OCV objects
                for (int i = 0; i < m_intGroupNum; i++)
                    for (int j = 0; j < intTemplateNum; j++)
                        m_arrOCV[i][j].SaveOCV(strFolderPath + "Template" + i + "_" + j + ".ocv");
            }
            else
            {
                // Save OCR objects
                m_objOCR.Save(strFolderPath);
            }
        }
        public void SaveTemplate(string strFolderPath, bool blnWantSaveTemplateCharImage)
        {
            string[] Split = strFolderPath.Split('\\');
            string strVision = Split[Split.Length - 5] + " - (" + Split[Split.Length - 4] + ") -->";
            // Save mark settings
            XmlParser objFile = new XmlParser(strFolderPath + "Template.xml");
            objFile.WriteSectionElement("MarkSettings");
            objFile.WriteElement1Value("CheckMark", m_blnCheckMark);
            objFile.WriteElement1Value("FailOptionMask", m_intFailOptionMask);
            objFile.WriteElement1Value("FailOptionMask_ForPreTest", m_intFailOptionMask_ForPreTest);
            objFile.WriteElement1Value("MinArea", m_intMinArea);
            //objFile.WriteElement1Value("MarkROIOffsetTop", m_intMarkROIOffsetTop);
            //objFile.WriteElement1Value("MarkROIOffsetRight", m_intMarkROIOffsetRight);
            //objFile.WriteElement1Value("MarkROIOffsetBottom", m_intMarkROIOffsetBottom);
            //objFile.WriteElement1Value("MarkROIOffsetLeft", m_intMarkROIOffsetLeft);
            objFile.WriteElement1Value("LeadDontCareInwardTolerance_Top", m_intLeadDontCareInwardTolerance_Top);
            objFile.WriteElement1Value("LeadDontCareInwardTolerance_Right", m_intLeadDontCareInwardTolerance_Right);
            objFile.WriteElement1Value("LeadDontCareInwardTolerance_Bottom", m_intLeadDontCareInwardTolerance_Bottom);
            objFile.WriteElement1Value("LeadDontCareInwardTolerance_Left", m_intLeadDontCareInwardTolerance_Left);
            objFile.WriteElement1Value("MaxArea", m_intMaxArea);
            objFile.WriteElement1Value("CharDilateHalfWidth", m_intCharDilateHalfWidth);
            objFile.WriteElement1Value("CharOpenHalfWidth", m_intCharOpenHalfWidth);
            objFile.WriteElement1Value("CharErodeHalfWidth", m_intCharErodeHalfWidth);
            objFile.WriteElement1Value("EnhanceMark_LinkMark_HalfWidth", m_intEnhanceMark_LinkMark_HalfWidth);
            objFile.WriteElement1Value("EnhanceMark_ReduceNoise_HalfWidth", m_intEnhanceMark_ReduceNoise_HalfWidth);
            objFile.WriteElement1Value("LearnMinArea", m_intLearnMinArea);
            objFile.WriteElement1Value("TemplateMask", m_intTemplateMask);
            objFile.WriteElement1Value("TemplatePriority", m_intTemplatePriority);
            objFile.WriteElement1Value("WhiteOnBlack", m_blnWhiteOnBlack);

            int intTemplateNum = 0;

            for (int i = 0; i < m_intGroupNum; i++)
            {
                objFile.WriteSectionElement("Group" + i);

                if (m_intInspectionMode == 0)
                {
                    // Get total template
                    intTemplateNum = m_arrOCV[i].Count;
                }
                else
                {
                    intTemplateNum = 1;
                    objFile.WriteElement1Value("RefChar", m_arrRefChars[i]);
                }

                // Save total template
                objFile.WriteElement1Value("TemplateNum", intTemplateNum);

                // Save each template setting
                for (int j = 0; j < Math.Max(1, intTemplateNum); j++)
                {
                    // Save tolerance settting
                    objFile.WriteElement1Value("Template" + j, "");
                    objFile.WriteElement2Value("FailOptionMask", m_arrTemplateSetting[i][j].intFailOptionMask, "Group" + (i + 1).ToString() + " Template" + (j + 1).ToString(), true);
                    STTrackLog.WriteLine(strVision + " Template " + (i + 1).ToString() + "Blob " + (j + 1).ToString() + " Save Mark Fail Option : " + m_arrTemplateSetting[i][j].intFailOptionMask.ToString());
                    objFile.WriteElement2Value("BrokenSize", m_arrTemplateSetting[i][j].intBrokenSize, "Group" + (i + 1).ToString() + " Template" + (j + 1).ToString(), true);
                    objFile.WriteElement2Value("CharShiftXY", m_arrTemplateSetting[i][j].intCharShiftXY, "Group" + (i + 1).ToString() + " Template" + (j + 1).ToString(), true);
                    objFile.WriteElement2Value("ExtraMinArea", m_arrTemplateSetting[i][j].fExtraMinArea, "Group" + (i + 1).ToString() + " Template" + (j + 1).ToString(), true);
                    objFile.WriteElement2Value("GroupExtraMinArea", m_arrTemplateSetting[i][j].fGroupExtraMinArea, "Group" + (i + 1).ToString() + " Template" + (j + 1).ToString(), true);
                    objFile.WriteElement2Value("GroupExcessMinArea", m_arrTemplateSetting[i][j].fGroupExcessMinArea, "Group" + (i + 1).ToString() + " Template" + (j + 1).ToString(), true);
                    objFile.WriteElement2Value("ExcessMinArea", m_arrTemplateSetting[i][j].intExcessMinArea, "Group" + (i + 1).ToString() + " Template" + (j + 1).ToString(), true);
                    objFile.WriteElement2Value("MissingMinArea", m_arrTemplateSetting[i][j].intMissingMinArea, "Group" + (i + 1).ToString() + " Template" + (j + 1).ToString(), true);
                    objFile.WriteElement2Value("TextMinScore", m_arrTemplateSetting[i][j].intTextMinScore, "Group" + (i + 1).ToString() + " Template" + (j + 1).ToString(), true);
                    objFile.WriteElement2Value("Threshold", m_arrTemplateSetting[i][j].intThreshold, "Group" + (i + 1).ToString() + " Template" + (j + 1).ToString(), true);

                    objFile.WriteElement2Value("ExtraMarkThreshold", m_arrTemplateSetting[i][j].intExtraMarkThreshold, "Group" + (i + 1).ToString() + " Template" + (j + 1).ToString(), true);

                    objFile.WriteElement2Value("UnCheckAreaBottom", m_arrTemplateSetting[i][j].fUnCheckAreaBottom, "Group" + (i + 1).ToString() + " Template" + (j + 1).ToString(), true);
                    objFile.WriteElement2Value("UnCheckAreaLeft", m_arrTemplateSetting[i][j].fUnCheckAreaLeft, "Group" + (i + 1).ToString() + " Template" + (j + 1).ToString(), true);
                    objFile.WriteElement2Value("UnCheckAreaRight", m_arrTemplateSetting[i][j].fUnCheckAreaRight, "Group" + (i + 1).ToString() + " Template" + (j + 1).ToString(), true);
                    objFile.WriteElement2Value("UnCheckAreaTop", m_arrTemplateSetting[i][j].fUnCheckAreaTop, "Group" + (i + 1).ToString() + " Template" + (j + 1).ToString(), true);
                    objFile.WriteElement2Value("MarkAngleTolerance", m_arrTemplateSetting[i][j].fMarkAngleTolerance, "Group" + (i + 1).ToString() + " Template" + (j + 1).ToString(), true);
                    objFile.WriteElement2Value("CharNum", m_arrTemplateSetting[i][j].intCharSetting.Count, "Group" + (i + 1).ToString() + " Template" + (j + 1).ToString(), true);
                    objFile.WriteElement2Value("TextShiftX", m_arrTemplateSetting[i][j].fTextShiftX, "Group" + (i + 1).ToString() + " Template" + (j + 1).ToString(), true);
                    objFile.WriteElement2Value("TextShiftY", m_arrTemplateSetting[i][j].fTextShiftY, "Group" + (i + 1).ToString() + " Template" + (j + 1).ToString(), true);

                    // Save Char Score Setting
                    objFile.WriteElement2Value("CharSetting", "");
                    for (int k = 0; k < m_arrTemplateSetting[i][j].intCharSetting.Count; k++)
                    {
                        objFile.WriteElement3Value("CharSetting" + k, m_arrTemplateSetting[i][j].intCharSetting[k], "Group" + (i + 1).ToString() + " Template" + (j + 1).ToString() + " Char" + (k + 1).ToString(), true);
                    }

                    objFile.WriteElement2Value("CharDividedLargestArea", "");
                    for (int k = 0; k < m_arrTemplateSetting[i][j].intCharDividedLargestArea.Count; k++)
                    {
                        objFile.WriteElement3Value("CharDividedLargestArea" + k, m_arrTemplateSetting[i][j].intCharDividedLargestArea[k], "Group" + (i + 1).ToString() + " Template" + (j + 1).ToString() + " Char" + (k + 1).ToString(), true);
                    }

                    objFile.WriteElement2Value("AverageGray", "");
                    for (int k = 0; k < m_arrTemplateSetting[i][j].fAverageGray.Count; k++)
                    {
                        objFile.WriteElement3Value("AverageGray" + k, m_arrTemplateSetting[i][j].fAverageGray[k], "Group" + (i + 1).ToString() + " Template" + (j + 1).ToString() + " Char" + (k + 1).ToString(), true);
                    }

                    objFile.WriteElement2Value("MaxAGVPercent", "");
                    for (int k = 0; k < m_arrTemplateSetting[i][j].fMaxAGVPercent.Count; k++)
                    {
                        objFile.WriteElement3Value("MaxAGVPercent" + k, m_arrTemplateSetting[i][j].fMaxAGVPercent[k], "Group" + (i + 1).ToString() + " Template" + (j + 1).ToString() + " Char" + (k + 1).ToString(), true);
                    }

                    objFile.WriteElement2Value("MaxExcessArea", "");
                    for (int k = 0; k < m_arrTemplateSetting[i][j].arrMaxExcessArea.Count; k++)
                    {
                        objFile.WriteElement3Value("MaxExcessArea" + k, m_arrTemplateSetting[i][j].arrMaxExcessArea[k], "Group" + (i + 1).ToString() + " Template" + (j + 1).ToString() + " Char" + (k + 1).ToString(), true);
                    }

                    objFile.WriteElement2Value("MaxBrokenArea", "");
                    for (int k = 0; k < m_arrTemplateSetting[i][j].arrMaxBrokenArea.Count; k++)
                    {
                        objFile.WriteElement3Value("MaxBrokenArea" + k, m_arrTemplateSetting[i][j].arrMaxBrokenArea[k], "Group" + (i + 1).ToString() + " Template" + (j + 1).ToString() + " Char" + (k + 1).ToString(), true);
                    }

                    objFile.WriteElement2Value("WantBrokenMark", "");
                    for (int k = 0; k < m_arrTemplateSetting[i][j].arrWantBrokenMark.Count; k++)
                    {
                        objFile.WriteElement3Value("WantBrokenMark" + k, m_arrTemplateSetting[i][j].arrWantBrokenMark[k]);
                    }

                    objFile.WriteElement2Value("MarkType", "");
                    for (int k = 0; k < m_arrTemplateSetting[i][j].arrMarkType.Count; k++)
                    {
                        objFile.WriteElement3Value("MarkType" + k, m_arrTemplateSetting[i][j].arrMarkType[k]);
                    }

                    objFile.WriteElement2Value("CharShiftX", "");
                    for (int k = 0; k < m_arrTemplateSetting[i][j].fCharShiftX.Count; k++)
                    {
                        objFile.WriteElement3Value("CharShiftX" + k, m_arrTemplateSetting[i][j].fCharShiftX[k], "Group" + (i + 1).ToString() + " Template" + (j + 1).ToString() + " Char" + (k + 1).ToString(), true);
                    }

                    objFile.WriteElement2Value("CharShiftY", "");
                    for (int k = 0; k < m_arrTemplateSetting[i][j].fCharShiftY.Count; k++)
                    {
                        objFile.WriteElement3Value("CharShiftY" + k, m_arrTemplateSetting[i][j].fCharShiftY[k], "Group" + (i + 1).ToString() + " Template" + (j + 1).ToString() + " Char" + (k + 1).ToString(), true);
                    }

                    objFile.WriteElement2Value("TextCharOffsetX", "");
                    for (int k = 0; k < m_arrTemplateSetting[i][j].intTextCharOffsetX.Count; k++)
                    {
                        objFile.WriteElement3Value("TextCharOffsetX" + k, m_arrTemplateSetting[i][j].intTextCharOffsetX[k], "Group" + (i + 1).ToString() + " Template" + (j + 1).ToString() + " Char" + (k + 1).ToString(), true);
                    }

                    objFile.WriteElement2Value("TextCharOffsetY", "");
                    for (int k = 0; k < m_arrTemplateSetting[i][j].intTextCharOffsetY.Count; k++)
                    {
                        objFile.WriteElement3Value("TextCharOffsetY" + k, m_arrTemplateSetting[i][j].intTextCharOffsetY[k], "Group" + (i + 1).ToString() + " Template" + (j + 1).ToString() + " Char" + (k + 1).ToString(), true);
                    }

                    objFile.WriteElement2Value("EnableMark", "");
                    for (int k = 0; k < m_arrTemplateSetting[i][j].blnEnable.Count; k++)
                    {
                        objFile.WriteElement3Value("EnableMark" + k, m_arrTemplateSetting[i][j].blnEnable[k], "Group" + (i + 1).ToString() + " Template" + (j + 1).ToString() + " Char" + (k + 1).ToString(), true);
                    }

                    objFile.WriteElement2Value("IsBarPin1", "");
                    for (int k = 0; k < m_arrTemplateSetting[i][j].blnIsBarPin1.Count; k++)
                    {
                        objFile.WriteElement3Value("IsBarPin1" + k, m_arrTemplateSetting[i][j].blnIsBarPin1[k], "Group" + (i + 1).ToString() + " Template" + (j + 1).ToString() + " Char" + (k + 1).ToString(), true);
                    }

                    objFile.WriteElement2Value("BarPin1Type", "");
                    for (int k = 0; k < m_arrTemplateSetting[i][j].arrBarPin1Type.Count; k++)
                    {
                        objFile.WriteElement3Value("BarPin1Type" + k, m_arrTemplateSetting[i][j].arrBarPin1Type[k], "Group" + (i + 1).ToString() + " Template" + (j + 1).ToString() + " Char" + (k + 1).ToString(), true);
                    }

                    if (m_intInspectionMode == 0)
                    {
                        if (j < m_arrOCV[i].Count)
                        {
                            // Save Char Represent Number
                            objFile.WriteElement2Value("CharNo", "");
                            for (int k = 0; k < m_arrTemplateSetting[i][j].intCharSetting.Count; k++)
                            {
                                objFile.WriteElement3Value("CharNo" + k, m_arrOCV[i][j].GetCharNo(k));
                            }
                        }

                        //// Save Each Char Start Point and Size (Based on template image)
                        //objFile.WriteElement2Value("CharROI", "");
                        //for (int k = 0; k < m_arrTemplateSetting[i][j].intCharSetting.Count; k++)
                        //{
                        //    objFile.WriteElement3Value("CharROIStartX" + k, m_arrTemplateSetting[i][j].arrTemplateCharDilateROI[k].ref_ROIPositionX);
                        //    objFile.WriteElement3Value("CharROIStartY" + k, m_arrTemplateSetting[i][j].arrTemplateCharDilateROI[k].ref_ROIPositionY);
                        //    objFile.WriteElement3Value("CharROIWidth" + k, m_arrTemplateSetting[i][j].arrTemplateCharDilateROI[k].ref_ROIWidth);
                        //    objFile.WriteElement3Value("CharROIHeight" + k, m_arrTemplateSetting[i][j].arrTemplateCharDilateROI[k].ref_ROIHeight);                           
                        //}

                        int intNumTexts = m_arrTemplateSetting[i][j].arrTemplateTextROI.Count;
                        objFile.WriteElement2Value("TextNum", intNumTexts);
                        objFile.WriteElement2Value("TextROI", "");
                        for (int tx = 0; tx < intNumTexts; tx++)
                        {
                            objFile.WriteElement3Value("TextROIStartX" + tx, m_arrTemplateSetting[i][j].arrTemplateTextROI[tx].ref_ROIPositionX, "Group" + (i + 1).ToString() + " Template" + (j + 1).ToString() + " Char" + (tx + 1).ToString(), true);
                            objFile.WriteElement3Value("TextROIStartY" + tx, m_arrTemplateSetting[i][j].arrTemplateTextROI[tx].ref_ROIPositionY, "Group" + (i + 1).ToString() + " Template" + (j + 1).ToString() + " Char" + (tx + 1).ToString(), true);
                            objFile.WriteElement3Value("TextROIWidth" + tx, m_arrTemplateSetting[i][j].arrTemplateTextROI[tx].ref_ROIWidth, "Group" + (i + 1).ToString() + " Template" + (j + 1).ToString() + " Char" + (tx + 1).ToString(), true);
                            objFile.WriteElement3Value("TextROIHeight" + tx, m_arrTemplateSetting[i][j].arrTemplateTextROI[tx].ref_ROIHeight, "Group" + (i + 1).ToString() + " Template" + (j + 1).ToString() + " Char" + (tx + 1).ToString(), true);

                            //Save Char Image
                            if (blnWantSaveTemplateCharImage)
                                m_arrTemplateSetting[i][j].arrTemplateTextROI[tx].SaveImage(strFolderPath + "OriTemplate" + i + "_" + j + "_Char" + tx + ".bmp");
                        }
                    }
                    else
                    {
                        // Save char off set to text vaue
                        objFile.WriteElement2Value("TemplateCharOffSet", "");
                        objFile.WriteElement3Value("TemplateCharOffSetNum", m_objOCR.ref_NumTemplateChars);
                        int intX = 0, intY = 0;
                        for (int k = 0; k < m_objOCR.ref_NumTemplateChars; k++)
                        {
                            m_objOCR.GetTemplateCharOffSet(k, ref intX, ref intY);
                            objFile.WriteElement3Value("CharOffSetX" + k, intX);
                            objFile.WriteElement3Value("CharOffSetY" + k, intY);

                            m_objOCR.GetTemplateCharStartPoint(k, ref intX, ref intY);
                            objFile.WriteElement3Value("CharStartX" + k, intX);
                            objFile.WriteElement3Value("CharStartY" + k, intY);

                            m_objOCR.GetTemplateCharEndPoint(k, ref intX, ref intY);
                            objFile.WriteElement3Value("CharEndX" + k, intX);
                            objFile.WriteElement3Value("CharEndY" + k, intY);

                            m_objOCR.GetTemplateCharSize(k, ref intX, ref intY);
                            objFile.WriteElement3Value("CharWidth" + k, intX);
                            objFile.WriteElement3Value("CharHeight" + k, intY);
                        }
                    }
                }
            }

            objFile.WriteEndElement();

            if (m_intInspectionMode == 0)
            {
                // Save OCV objects
                for (int i = 0; i < m_intGroupNum; i++)
                    for (int j = 0; j < intTemplateNum; j++)
                    {
                        //2020-11-09 ZJYEOH : set angle tolerance to zero because template always zero degree
                        m_arrOCV[i][j].SetTextsSkewTolerance(0);

                        m_arrOCV[i][j].SaveOCV(strFolderPath + "Template" + i + "_" + j + ".ocv");
                    }
            }
            else
            {
                // Save OCR objects
                m_objOCR.Save(strFolderPath);
            }
        }

        public void SaveTemplate_SECSGEM(string strPath, string strSectionName, string strVisionName, bool blnSECSGEMFileExist)
        {
            XmlParser objFile = new XmlParser(strPath, "SECSGEMData");
            objFile.WriteRootElement("SECSGEMData");

            objFile.WriteElementValue(strVisionName + strSectionName + "_CheckMark", m_blnCheckMark);
            objFile.WriteElementValue(strVisionName + strSectionName + "_FailOptionMask", m_intFailOptionMask);
            objFile.WriteElementValue(strVisionName + strSectionName + "_FailOptionMask_ForPreTest", m_intFailOptionMask_ForPreTest);
            objFile.WriteElementValue(strVisionName + strSectionName + "_MinArea", m_intMinArea);
            //objFile.WriteElementValue(strVisionName + strSectionName + "_MarkROIOffsetTop", m_intMarkROIOffsetTop);
            //objFile.WriteElementValue(strVisionName + strSectionName + "_MarkROIOffsetRight", m_intMarkROIOffsetRight);
            //objFile.WriteElementValue(strVisionName + strSectionName + "_MarkROIOffsetBottom", m_intMarkROIOffsetBottom);
            //objFile.WriteElementValue(strVisionName + strSectionName + "_MarkROIOffsetLeft", m_intMarkROIOffsetLeft);
            objFile.WriteElementValue(strVisionName + strSectionName + "LeadDontCareInwardTolerance_Top", m_intLeadDontCareInwardTolerance_Top);
            objFile.WriteElementValue(strVisionName + strSectionName + "LeadDontCareInwardTolerance_Right", m_intLeadDontCareInwardTolerance_Right);
            objFile.WriteElementValue(strVisionName + strSectionName + "LeadDontCareInwardTolerance_Bottom", m_intLeadDontCareInwardTolerance_Bottom);
            objFile.WriteElementValue(strVisionName + strSectionName + "LeadDontCareInwardTolerance_Left", m_intLeadDontCareInwardTolerance_Left);
            objFile.WriteElementValue(strVisionName + strSectionName + "_MaxArea", m_intMaxArea);
            objFile.WriteElementValue(strVisionName + strSectionName + "_CharDilateHalfWidth", m_intCharDilateHalfWidth);
            objFile.WriteElementValue(strVisionName + strSectionName + "_CharOpenHalfWidth", m_intCharOpenHalfWidth);
            objFile.WriteElementValue(strVisionName + strSectionName + "_CharErodeHalfWidth", m_intCharErodeHalfWidth);
            objFile.WriteElementValue(strVisionName + strSectionName + "_EnhanceMark_LinkMark_HalfWidth", m_intEnhanceMark_LinkMark_HalfWidth);
            objFile.WriteElementValue(strVisionName + strSectionName + "_EnhanceMark_ReduceNoise_HalfWidth", m_intEnhanceMark_ReduceNoise_HalfWidth);
            objFile.WriteElementValue(strVisionName + strSectionName + "_LearnMinArea", m_intLearnMinArea);
            objFile.WriteElementValue(strVisionName + strSectionName + "_TemplateMask", m_intTemplateMask);
            objFile.WriteElementValue(strVisionName + strSectionName + "_TemplatePriority", m_intTemplatePriority);
            objFile.WriteElementValue(strVisionName + strSectionName + "_MissingMarkInspectionMethod", m_intMissingMarkInspectionMethod);
            objFile.WriteElementValue(strVisionName + strSectionName + "_WhiteOnBlack", m_blnWhiteOnBlack);

            int intTemplateNum = 0;

            for (int i = 0; i < m_intGroupNum; i++)
            {
                //objFile.WriteSectionElement("Group" + i);

                if (m_intInspectionMode == 0)
                {
                    // Get total template
                    intTemplateNum = m_arrOCV[i].Count;
                }
                else
                {
                    intTemplateNum = 1;
                    objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_RefChar", m_arrRefChars[i]);
                }

                // Save total template
                objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_TemplateNum", intTemplateNum);

                // Max no of template is 8
                for (int j = 0; j < 8; j++)
                {
                    if (m_arrTemplateSetting[i].Count > j)
                    {
                        // Save tolerance settting
                        //objFile.WriteElementValue(strVisionName + "_Template" + j, "");
                        objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_FailOptionMask", m_arrTemplateSetting[i][j].intFailOptionMask);
                        objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_BrokenSize", m_arrTemplateSetting[i][j].intBrokenSize);
                        objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_CharShiftXY", m_arrTemplateSetting[i][j].intCharShiftXY);
                        objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_ExtraMinArea", m_arrTemplateSetting[i][j].fExtraMinArea);
                        objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_GroupExtraMinArea", m_arrTemplateSetting[i][j].fGroupExtraMinArea);
                        objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_GroupExcessMinArea", m_arrTemplateSetting[i][j].fGroupExcessMinArea);
                        objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_ExcessMinArea", m_arrTemplateSetting[i][j].intExcessMinArea);
                        objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_MissingMinArea", m_arrTemplateSetting[i][j].intMissingMinArea);
                        objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_TextMinScore", m_arrTemplateSetting[i][j].intTextMinScore);
                        objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_Threshold", m_arrTemplateSetting[i][j].intThreshold);

                        objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_ExtraMarkThreshold", m_arrTemplateSetting[i][j].intExtraMarkThreshold);

                        objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_UnCheckAreaBottom", m_arrTemplateSetting[i][j].fUnCheckAreaBottom);
                        objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_UnCheckAreaLeft", m_arrTemplateSetting[i][j].fUnCheckAreaLeft);
                        objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_UnCheckAreaRight", m_arrTemplateSetting[i][j].fUnCheckAreaRight);
                        objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_UnCheckAreaTop", m_arrTemplateSetting[i][j].fUnCheckAreaTop);
                        objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_MarkAngleTolerance", m_arrTemplateSetting[i][j].fMarkAngleTolerance);
                        objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_CharNum", m_arrTemplateSetting[i][j].intCharSetting.Count);
                        objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_TextShiftX", m_arrTemplateSetting[i][j].fTextShiftX);
                        objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_TextShiftY", m_arrTemplateSetting[i][j].fTextShiftY);

                        // Save Char Score Setting
                        //Prepare at least 10 character to save in secsgem, if less than 10 will save as "NA"
                        int intCharNo = Math.Max(m_arrTemplateSetting[i][j].intCharSetting.Count, 10);
                        for (int k = 0; k < intCharNo; k++)
                        {
                            if (m_arrTemplateSetting[i][j].intCharSetting.Count > k)
                                objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_CharSetting" + k, m_arrTemplateSetting[i][j].intCharSetting[k]);
                            else
                            {
                                if (!blnSECSGEMFileExist)
                                {
                                    objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_CharSetting" + k, "NA");
                                }
                            }
                        }

                        for (int k = 0; k < intCharNo; k++)
                        {
                            if (m_arrTemplateSetting[i][j].intCharDividedLargestArea.Count > k)
                                objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_CharDividedLargestArea" + k, m_arrTemplateSetting[i][j].intCharDividedLargestArea[k]);
                            else
                            {
                                if (!blnSECSGEMFileExist)
                                {
                                    objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_CharDividedLargestArea" + k, "NA");
                                }
                            }
                        }

                        for (int k = 0; k < intCharNo; k++)
                        {
                            if (m_arrTemplateSetting[i][j].fAverageGray.Count > k)
                                objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_AverageGray" + k, m_arrTemplateSetting[i][j].fAverageGray[k]);
                            else
                            {
                                if (!blnSECSGEMFileExist)
                                {
                                    objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_AverageGray" + k, "NA");
                                }
                            }
                        }

                        //objFile.WriteElement2Value(strVisionName + "_MaxExcessArea", "");

                        for (int k = 0; k < intCharNo; k++)
                        {
                            if (m_arrTemplateSetting[i][j].arrMaxExcessArea.Count > k)
                                objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_MaxExcessArea" + k, m_arrTemplateSetting[i][j].arrMaxExcessArea[k]);
                            else
                            {
                                if (!blnSECSGEMFileExist)
                                {
                                    objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_MaxExcessArea" + k, "NA");
                                }
                            }
                        }

                        //objFile.WriteElement2Value(strVisionName + "_MaxBrokenArea", "");
                        for (int k = 0; k < intCharNo; k++)
                        {
                            if (m_arrTemplateSetting[i][j].arrMaxBrokenArea.Count > k)
                                objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_MaxBrokenArea" + k, m_arrTemplateSetting[i][j].arrMaxBrokenArea[k]);
                            else
                            {
                                if (!blnSECSGEMFileExist)
                                {
                                    objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_MaxBrokenArea" + k, "NA");
                                }
                            }
                        }

                        for (int k = 0; k < intCharNo; k++)
                        {
                            if (m_arrTemplateSetting[i][j].arrWantBrokenMark.Count > k)
                                objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_WantBrokenMark" + k, m_arrTemplateSetting[i][j].arrWantBrokenMark[k]);
                            else
                            {
                                if (!blnSECSGEMFileExist)
                                {
                                    objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_WantBrokenMark" + k, "NA");
                                }
                            }
                        }

                        for (int k = 0; k < intCharNo; k++)
                        {
                            if (m_arrTemplateSetting[i][j].arrMarkType.Count > k)
                                objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_MarkType" + k, m_arrTemplateSetting[i][j].arrMarkType[k]);
                            else
                            {
                                if (!blnSECSGEMFileExist)
                                {
                                    objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_MarkType" + k, "NA");
                                }
                            }
                        }

                        //objFile.WriteElement2Value(strVisionName + "_CharShiftX", "");
                        for (int k = 0; k < intCharNo; k++)
                        {
                            if (m_arrTemplateSetting[i][j].fCharShiftX.Count > k)
                                objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_CharShiftX" + k, m_arrTemplateSetting[i][j].fCharShiftX[k]);
                            else
                            {
                                if (!blnSECSGEMFileExist)
                                {
                                    objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_CharShiftX" + k, "NA");
                                }
                            }
                        }

                        //objFile.WriteElement2Value(strVisionName + "_CharShiftY", "");
                        for (int k = 0; k < intCharNo; k++)
                        {
                            if (m_arrTemplateSetting[i][j].fCharShiftY.Count > k)
                                objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_CharShiftY" + k, m_arrTemplateSetting[i][j].fCharShiftY[k]);
                            else
                            {
                                if (!blnSECSGEMFileExist)
                                {
                                    objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_CharShiftY" + k, "NA");
                                }
                            }
                        }

                        //objFile.WriteElement2Value(strVisionName + "_TextCharOffsetX", "");
                        for (int k = 0; k < intCharNo; k++)
                        {
                            if (m_arrTemplateSetting[i][j].intTextCharOffsetX.Count > k)
                                objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_TextCharOffsetX" + k, m_arrTemplateSetting[i][j].intTextCharOffsetX[k]);
                            else
                            {
                                if (!blnSECSGEMFileExist)
                                {
                                    objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_TextCharOffsetX" + k, "NA");
                                }
                            }
                        }

                        //objFile.WriteElement2Value(strVisionName + "_TextCharOffsetY", "");
                        for (int k = 0; k < intCharNo; k++)
                        {
                            if (m_arrTemplateSetting[i][j].intTextCharOffsetY.Count > k)
                                objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_TextCharOffsetY" + k, m_arrTemplateSetting[i][j].intTextCharOffsetY[k]);
                            else
                            {
                                if (!blnSECSGEMFileExist)
                                {
                                    objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_TextCharOffsetY" + k, "NA");
                                }
                            }
                        }

                        //objFile.WriteElement2Value(strVisionName + "_EnableMark", "");
                        for (int k = 0; k < intCharNo; k++)
                        {
                            if (m_arrTemplateSetting[i][j].blnEnable.Count > k)
                                objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_EnableMark" + k, m_arrTemplateSetting[i][j].blnEnable[k]);
                            else
                            {
                                if (!blnSECSGEMFileExist)
                                {
                                    objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_EnableMark" + k, "NA");
                                }
                            }
                        }

                        if (m_intInspectionMode == 0)
                        {
                            //// Save Char Represent Number
                            ////objFile.WriteElement2Value(strVisionName + "_CharNo", "");
                            //intCharNo = Math.Max(m_arrTemplateSetting[i][j].intCharSetting.Count, 10);
                            //for (int k = 0; k < intCharNo; k++)
                            //{
                            //    if (m_arrTemplateSetting[i][j].intCharSetting.Count > k)
                            //        objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_CharNo" + k, m_arrOCV[i][j].GetCharNo(k));
                            //    else
                            //        objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_CharNo" + k, "NA");
                            //}

                            //int intNumTexts = m_arrTemplateSetting[i][j].arrTemplateTextROI.Count;
                            //objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_TextNum", intNumTexts);

                            //objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_TemplateCharOffSetNum", "NA");

                            //for (int k = 0; k < intCharNo; k++)
                            //{
                            //    objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_CharOffSetX" + k, "NA");
                            //    objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_CharOffSetY" + k, "NA");

                            //    objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_CharStartX" + k, "NA");
                            //    objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_CharStartY" + k, "NA");

                            //    objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_CharEndX" + k, "NA");
                            //    objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_CharEndY" + k, "NA");

                            //    objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_CharWidth" + k, "NA");
                            //    objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_CharHeight" + k, "NA");
                            //}

                            //objFile.WriteElementValue(strVisionName + "_Group" + i + "_Template" + j + "_TextROI", "");
                            //for (int tx = 0; tx < intNumTexts; tx++)
                            //{
                            //    objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_TextROIStartX" + tx, m_arrTemplateSetting[i][j].arrTemplateTextROI[tx].ref_ROIPositionX);
                            //    objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_TextROIStartY" + tx, m_arrTemplateSetting[i][j].arrTemplateTextROI[tx].ref_ROIPositionY);
                            //    objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_TextROIWidth" + tx, m_arrTemplateSetting[i][j].arrTemplateTextROI[tx].ref_ROIWidth);
                            //    objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_TextROIHeight" + tx, m_arrTemplateSetting[i][j].arrTemplateTextROI[tx].ref_ROIHeight);
                            //}
                        }
                        else
                        {
                            //// Save char off set to text vaue
                            ////objFile.WriteElement2Value(strVisionName + "_Group" + i + "_Template" + j + "_TemplateCharOffSet", "");
                            //intCharNo = Math.Max(m_arrTemplateSetting[i][j].intCharSetting.Count, 10);
                            //for (int k = 0; k < intCharNo; k++)
                            //{
                            //    objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_CharNo" + k, "NA");
                            //}
                            //objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_TextNum", "NA");

                            //objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_TemplateCharOffSetNum", m_objOCR.ref_NumTemplateChars);
                            //int intX = 0, intY = 0;
                            //intCharNo = Math.Max(m_objOCR.ref_NumTemplateChars, 10);
                            //for (int k = 0; k < intCharNo; k++)
                            //{
                            //    if (m_objOCR.ref_NumTemplateChars > k)
                            //    {
                            //        m_objOCR.GetTemplateCharOffSet(k, ref intX, ref intY);
                            //        objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_CharOffSetX" + k, intX);
                            //        objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_CharOffSetY" + k, intY);

                            //        m_objOCR.GetTemplateCharStartPoint(k, ref intX, ref intY);
                            //        objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_CharStartX" + k, intX);
                            //        objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_CharStartY" + k, intY);

                            //        m_objOCR.GetTemplateCharEndPoint(k, ref intX, ref intY);
                            //        objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_CharEndX" + k, intX);
                            //        objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_CharEndY" + k, intY);

                            //        m_objOCR.GetTemplateCharSize(k, ref intX, ref intY);
                            //        objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_CharWidth" + k, intX);
                            //        objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_CharHeight" + k, intY);
                            //    }
                            //    else
                            //    {
                            //        objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_CharOffSetX" + k, "NA");
                            //        objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_CharOffSetY" + k, "NA");

                            //        objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_CharStartX" + k, "NA");
                            //        objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_CharStartY" + k, "NA");

                            //        objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_CharEndX" + k, "NA");
                            //        objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_CharEndY" + k, "NA");

                            //        objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_CharWidth" + k, "NA");
                            //        objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_CharHeight" + k, "NA");
                            //    }
                            //}
                        }
                    }
                    else
                    {
                        if (!blnSECSGEMFileExist)
                        {
                            // Save tolerance settting
                            //objFile.WriteElementValue(strVisionName + "_Template" + j, "");
                            objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_FailOptionMask", "NA");
                            objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_BrokenSize", "NA");
                            objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_CharShiftXY", "NA");
                            objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_ExtraMinArea", "NA");
                            objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_GroupExtraMinArea", "NA");
                            objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_ExcessMinArea", "NA");
                            objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_MissingMinArea", "NA");
                            objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_TextMinScore", "NA");
                            objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_Threshold", "NA");
                            objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_UnCheckAreaBottom", "NA");
                            objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_UnCheckAreaLeft", "NA");
                            objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_UnCheckAreaRight", "NA");
                            objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_UnCheckAreaTop", "NA");
                            objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_CharNum", "NA");
                            objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_TextShiftX", "NA");
                            objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_TextShiftY", "NA");

                            // Save Char Score Setting
                            //Prepare at least 100 character to save in secsgem, if less than 100 will save as "NA"
                            int intCharNo = 100;
                            for (int k = 0; k < intCharNo; k++)
                            {
                                objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_CharSetting" + k, "NA");
                            }

                            //objFile.WriteElement2Value(strVisionName + "_MaxExcessArea", "");

                            for (int k = 0; k < intCharNo; k++)
                            {
                                objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_MaxExcessArea" + k, "NA");
                            }

                            //objFile.WriteElement2Value(strVisionName + "_MaxBrokenArea", "");
                            for (int k = 0; k < intCharNo; k++)
                            {
                                objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_MaxBrokenArea" + k, "NA");
                            }

                            //objFile.WriteElement2Value(strVisionName + "_CharShiftX", "");
                            for (int k = 0; k < intCharNo; k++)
                            {
                                objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_CharShiftX" + k, "NA");
                            }

                            //objFile.WriteElement2Value(strVisionName + "_CharShiftY", "");
                            for (int k = 0; k < intCharNo; k++)
                            {
                                objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_CharShiftY" + k, "NA");
                            }

                            //objFile.WriteElement2Value(strVisionName + "_TextCharOffsetX", "");
                            for (int k = 0; k < intCharNo; k++)
                            {
                                objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_TextCharOffsetX" + k, "NA");
                            }

                            //objFile.WriteElement2Value(strVisionName + "_TextCharOffsetY", "");
                            for (int k = 0; k < intCharNo; k++)
                            {
                                objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_TextCharOffsetY" + k, "NA");
                            }

                            //objFile.WriteElement2Value(strVisionName + "_EnableMark", "");
                            for (int k = 0; k < intCharNo; k++)
                            {
                                objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_EnableMark" + k, "NA");
                            }


                            //// Save Char Represent Number
                            ////objFile.WriteElement2Value(strVisionName + "_CharNo", "");
                            //for (int k = 0; k < intCharNo; k++)
                            //{
                            //    objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_CharNo" + k, "NA");
                            //}

                            //objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_TextNum", "NA");

                            //objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_TemplateCharOffSetNum", "NA");

                            //for (int k = 0; k < intCharNo; k++)
                            //{
                            //    objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_CharOffSetX" + k, "NA");
                            //    objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_CharOffSetY" + k, "NA");

                            //    objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_CharStartX" + k, "NA");
                            //    objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_CharStartY" + k, "NA");

                            //    objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_CharEndX" + k, "NA");
                            //    objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_CharEndY" + k, "NA");

                            //    objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_CharWidth" + k, "NA");
                            //    objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_CharHeight" + k, "NA");
                            //}

                            //objFile.WriteElementValue(strVisionName + "_Group" + i + "_Template" + j + "_TextROI", "");
                            //for (int tx = 0; tx < intNumTexts; tx++)
                            //{
                            //    objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_TextROIStartX" + tx, m_arrTemplateSetting[i][j].arrTemplateTextROI[tx].ref_ROIPositionX);
                            //    objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_TextROIStartY" + tx, m_arrTemplateSetting[i][j].arrTemplateTextROI[tx].ref_ROIPositionY);
                            //    objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_TextROIWidth" + tx, m_arrTemplateSetting[i][j].arrTemplateTextROI[tx].ref_ROIWidth);
                            //    objFile.WriteElementValue(strVisionName + strSectionName + "_Group" + i + "_Template" + j + "_TextROIHeight" + tx, m_arrTemplateSetting[i][j].arrTemplateTextROI[tx].ref_ROIHeight);
                            //}
                        }
                    }
                }
            }

            objFile.WriteEndElement();
        }

        public void DeleteAllPreviousTemplate(string strFolderPath)
        {
            if (m_intInspectionMode == 0)
            {
                // Delete whole template folder
                if (Directory.Exists(strFolderPath + "Template"))
                {
                    try
                    {
                        Directory.Delete(strFolderPath + "Template", true);
                    }
                    catch (Exception ex)
                    {
                        STTrackLog.WriteLine("Mark.cs > DeleteAllPreviousTemplate > " + ex.ToString());
                    }
                    System.Threading.Thread.Sleep(300); // 2019 10 10 - CCENG: Delay to make sure the path is deleted completely. Sometime the Directory.Exists will stil return true if too fast to check after delete the folder.
                }

                // Delete ocv objects from index 1 to last
                //if (m_arrOCV[m_intGroupIndex].Count > 0)
                RemoveRangeNOCVSettingArray();// m_arrOCV[m_intGroupIndex].RemoveRange(1, m_arrOCV[m_intGroupIndex].Count - 1);

                //if (m_arrTemplateSetting[m_intGroupIndex].Count > 0)
                RemoveRangeTemplateSettingArray(1); //    m_arrTemplateSetting[m_intGroupIndex].RemoveRange(1, m_arrTemplateSetting[m_intGroupIndex].Count - 1);

                m_intTemplateMask = 0;
                m_intTemplatePriority = 0;
            }
            else
            {
            }
        }

        public void ClearTemplateSetting()
        {
            //m_arrOCV[m_intGroupIndex].Clear();  // 2019 09 02 - Clear 
            //RemoveRangeNOCVSettingArray(); //ClearNOCVSettingArray(m_intGroupIndex, false);
            ClearNOCVSettingArray(m_intGroupIndex, false);

            //if (m_arrTemplateSetting[m_intGroupIndex].Count > 0)
            RemoveRangeTemplateSettingArray(1); //    m_arrTemplateSetting[m_intGroupIndex].RemoveRange(1, m_arrTemplateSetting[m_intGroupIndex].Count - 1);

            //m_arrOCV[m_intGroupIndex].Clear();  // 2019 09 02 - Clear 
            //m_arrTemplateSetting[m_intGroupIndex].Clear();
        }

        public void SetBrokenSize(int intBrokenSize, bool blnSetToAllTemplate)
        {
            if (blnSetToAllTemplate)
            {
                for (int i = 0; i < m_arrTemplateSetting[m_intGroupIndex].Count; i++)
                    m_arrTemplateSetting[m_intGroupIndex][i].intBrokenSize = intBrokenSize;
            }
            else
            {
                if (m_intTemplateIndex < m_arrTemplateSetting[m_intGroupIndex].Count)
                    m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intBrokenSize = intBrokenSize;
            }
        }

        public void SetBrokenSize(int intBrokenSize, int intGroupIndex, int intTemplateIndex)
        {
            m_arrTemplateSetting[intGroupIndex][intTemplateIndex].intBrokenSize = intBrokenSize;
        }

        public void SetCharShiftXY(int intCharShiftXY, bool blnSetToAllTemplate)
        {
            if (blnSetToAllTemplate)
            {
                for (int i = 0; i < m_arrTemplateSetting[m_intGroupIndex].Count; i++)
                {
                    m_arrTemplateSetting[m_intGroupIndex][i].intCharShiftXY = intCharShiftXY;

                    //Shift XY tolerance value need to save in ocv object
                    if (m_intInspectionMode == 0)
                    {
                        m_arrOCV[m_intGroupIndex][i].SetCharsShiftXY(intCharShiftXY, intCharShiftXY);
                    }
                }
            }
            else
            {
                if (m_intTemplateIndex < m_arrTemplateSetting[m_intGroupIndex].Count)
                {
                    m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharShiftXY = intCharShiftXY;

                    if (m_intInspectionMode == 0)
                    {
                        m_arrOCV[m_intGroupIndex][m_intTemplateIndex].SetCharsShiftXY(intCharShiftXY, intCharShiftXY);
                    }
                }
            }
        }
        public void ResetCharShiftXY(float fCharShiftX, float fCharShiftY)
        {
            for (int x = 0; x < m_arrOCV.Count; x++)
            {
                for (int y = 0; y < m_arrOCV[x].Count; y++)
                {
                    float[] arrXToleranceChars = m_arrOCV[x][y].GetCharsShiftX();
                    float[] arrYToleranceChars = m_arrOCV[x][y].GetCharsShiftY();

                    for (int i = 0; i < arrXToleranceChars.Length; i++)
                    {
                        if ((arrXToleranceChars[i] - m_fCharROIOffsetX) >= 0)
                            arrXToleranceChars[i] = arrXToleranceChars[i] - m_fCharROIOffsetX;
                    }

                    for (int i = 0; i < arrYToleranceChars.Length; i++)
                    {
                        if ((arrYToleranceChars[i] - m_fCharROIOffsetY) >= 0)
                            arrYToleranceChars[i] = arrYToleranceChars[i] - m_fCharROIOffsetY;
                    }

                    if (arrXToleranceChars.Length > 0 && arrYToleranceChars.Length > 0)
                        m_arrOCV[x][y].SetCharsShiftXY(arrXToleranceChars, arrYToleranceChars, fCharShiftX, fCharShiftY);
                }
            }
        }
        public void SetCharShiftXY(int intCharShiftXY, int intGroupIndex, int intTemplateIndex)
        {
            m_arrTemplateSetting[intGroupIndex][intTemplateIndex].intCharShiftXY = intCharShiftXY;
        }

        //public void SetCharSetting(int intCharIndex, int intSetValue)
        //{
        //    m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting[intCharIndex] = intSetValue;
        //}

        public void SetCharSetting(int intCharIndex, int intSetValue, int intGroupIndex, int intTemplateIndex)
        {
            m_arrTemplateSetting[intGroupIndex][intTemplateIndex].intCharSetting[intCharIndex] = intSetValue;
        }
        public void SetCharSetting(int intSetValue)
        {
            for (int i = 0; i < m_arrTemplateSetting[m_intGroupIndex].Count; i++)
            {
                for (int j = 0; j < m_arrTemplateSetting[m_intGroupIndex][i].intCharSetting.Count; j++)
                    m_arrTemplateSetting[m_intGroupIndex][i].intCharSetting[j] = intSetValue;
            }
        }
        public void SetOCRCharSetting(int intSetValue)
        {
            for (int j = 0; j < arrOCRCharSetting.Count; j++)
                arrOCRCharSetting[j] = intSetValue;
        }

        public void SetOCRCharSetting(int intCharIndex, int intSetValue)
        {
            if (intCharIndex < arrOCRCharSetting.Count)
                arrOCRCharSetting[intCharIndex] = intSetValue;
        }

        public void SetCharSetting(int intCharIndex, int intSetValue)
        {
            if (intCharIndex < m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting.Count)
                m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting[intCharIndex] = intSetValue;
        }

        public void SetOCRCharSetting(int intCharIndex, int intSetValue, bool blnSetToAllTemplate)
        {
            for (int i = 0; i < m_arrTemplateSetting[m_intGroupIndex].Count; i++)
            {
                if (intCharIndex < arrOCRCharSetting.Count)
                    arrOCRCharSetting[intCharIndex] = intSetValue;
            }
        }

        public void SetCharSetting(int intCharIndex, int intSetValue, bool blnSetToAllTemplate)
        {
            if (blnSetToAllTemplate)
            {
                for (int i = 0; i < m_arrTemplateSetting[m_intGroupIndex].Count; i++)
                {
                    if (intCharIndex < m_arrTemplateSetting[m_intGroupIndex][i].intCharSetting.Count)
                        m_arrTemplateSetting[m_intGroupIndex][i].intCharSetting[intCharIndex] = intSetValue;
                }
            }
            else
            {
                if (m_intTemplateIndex < m_arrTemplateSetting[m_intGroupIndex].Count)
                {
                    if (intCharIndex < m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting.Count)
                        m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting[intCharIndex] = intSetValue;
                }
            }
        }

        public void SetCharSetting(int intCharIndex, int intSetValue, bool blnEnable, bool blnSetToAllTemplate)
        {
            if (blnSetToAllTemplate)
            {
                for (int i = 0; i < m_arrTemplateSetting[m_intGroupIndex].Count; i++)
                {
                    if (intCharIndex < m_arrTemplateSetting[m_intGroupIndex][i].intCharSetting.Count)
                    {
                        m_arrTemplateSetting[m_intGroupIndex][i].intCharSetting[intCharIndex] = intSetValue;
                        m_arrTemplateSetting[m_intGroupIndex][i].blnEnable[intCharIndex] = blnEnable;
                    }
                }
            }
            else
            {
                if (m_intTemplateIndex < m_arrTemplateSetting[m_intGroupIndex].Count)
                {
                    if (intCharIndex < m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting.Count)
                    {
                        m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting[intCharIndex] = intSetValue;
                        m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[intCharIndex] = blnEnable;
                    }
                }
            }
        }
        public void SetMaxAGVPercent(float fSetValue)
        {
            for (int i = 0; i < m_arrTemplateSetting[m_intGroupIndex].Count; i++)
            {
                for (int j = 0; j < m_arrTemplateSetting[m_intGroupIndex][i].fMaxAGVPercent.Count; j++)
                    m_arrTemplateSetting[m_intGroupIndex][i].fMaxAGVPercent[j] = fSetValue;
            }
        }
        public void SetMaxAGVPercent(int intCharIndex, float fSetValue)
        {
            if (intCharIndex < m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fMaxAGVPercent.Count)
                m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fMaxAGVPercent[intCharIndex] = fSetValue;
        }

        public void SetMaxAGVPercent(int intCharIndex, float fSetValue, bool blnSetToAllTemplate)
        {
            if (blnSetToAllTemplate)
            {
                for (int i = 0; i < m_arrTemplateSetting[m_intGroupIndex].Count; i++)
                {
                    if (intCharIndex < m_arrTemplateSetting[m_intGroupIndex][i].fMaxAGVPercent.Count)
                        m_arrTemplateSetting[m_intGroupIndex][i].fMaxAGVPercent[intCharIndex] = fSetValue;
                }
            }
            else
            {
                if (m_intTemplateIndex < m_arrTemplateSetting[m_intGroupIndex].Count)
                {
                    if (intCharIndex < m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fMaxAGVPercent.Count)
                        m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fMaxAGVPercent[intCharIndex] = fSetValue;
                }
            }
        }

        public void SetMaxAGVPercent(int intCharIndex, float fSetValue, bool blnEnable, bool blnSetToAllTemplate)
        {
            if (blnSetToAllTemplate)
            {
                for (int i = 0; i < m_arrTemplateSetting[m_intGroupIndex].Count; i++)
                {
                    if (intCharIndex < m_arrTemplateSetting[m_intGroupIndex][i].fMaxAGVPercent.Count)
                    {
                        m_arrTemplateSetting[m_intGroupIndex][i].fMaxAGVPercent[intCharIndex] = fSetValue;
                        m_arrTemplateSetting[m_intGroupIndex][i].blnEnable[intCharIndex] = blnEnable;
                    }
                }
            }
            else
            {
                if (m_intTemplateIndex < m_arrTemplateSetting[m_intGroupIndex].Count)
                {
                    if (intCharIndex < m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fMaxAGVPercent.Count)
                    {
                        m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fMaxAGVPercent[intCharIndex] = fSetValue;
                        m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[intCharIndex] = blnEnable;
                    }
                }
            }
        }

        public void SetExtraMinArea(float fExtraMinArea, bool blnSetToAllTemplate)
        {
            switch (m_intDisplayUnitMode)
            {
                case 0: // Pixel

                    if (blnSetToAllTemplate)
                    {
                        for (int i = 0; i < m_arrTemplateSetting[m_intGroupIndex].Count; i++)
                            m_arrTemplateSetting[m_intGroupIndex][i].fExtraMinArea = fExtraMinArea;
                    }
                    else
                        m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fExtraMinArea = fExtraMinArea;
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron

                    if (blnSetToAllTemplate)
                    {
                        for (int i = 0; i < m_arrTemplateSetting[m_intGroupIndex].Count; i++)
                            m_arrTemplateSetting[m_intGroupIndex][i].fExtraMinArea = (fExtraMinArea / m_fMMToUnitValueArea) / m_fMMPerPixelArea;
                    }
                    else
                        m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fExtraMinArea = (fExtraMinArea / m_fMMToUnitValueArea) / m_fMMPerPixelArea;
                    break;
            }

        }

        public void SetExcessMinArea(int intExcessMinArea, bool blnSetToAllTemplate)
        {
            if (blnSetToAllTemplate)
            {
                for (int i = 0; i < m_arrTemplateSetting[m_intGroupIndex].Count; i++)
                    m_arrTemplateSetting[m_intGroupIndex][i].intExcessMinArea = intExcessMinArea;
            }
            else
            {
                if (m_intTemplateIndex < m_arrTemplateSetting[m_intGroupIndex].Count)
                    m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intExcessMinArea = intExcessMinArea;
            }
        }

        public void SetExtraMinArea(float fExtraMinArea, int intGroupIndex, int intTemplateIndex)
        {
            switch (m_intDisplayUnitMode)
            {
                case 0: // Pixel
                    m_arrTemplateSetting[intGroupIndex][intTemplateIndex].fExtraMinArea = fExtraMinArea;
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    m_arrTemplateSetting[intGroupIndex][intTemplateIndex].fExtraMinArea = (fExtraMinArea / m_fMMToUnitValueArea) / m_fMMPerPixelArea;
                    break;
            }
        }

        public void SetFailOptionMask(int intFailOptionMask, bool blnSetToAllTemplate)
        {
            if (blnSetToAllTemplate)
            {
                for (int i = 0; i < m_arrTemplateSetting[m_intGroupIndex].Count; i++)
                    m_arrTemplateSetting[m_intGroupIndex][i].intFailOptionMask = intFailOptionMask;
            }
            else
            {
                if (m_intTemplateIndex < m_arrTemplateSetting[m_intGroupIndex].Count)
                    m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intFailOptionMask = intFailOptionMask;
            }
        }

        public void AddLogicFailOptionMask(int intAddLogicOptionMask, bool blnSetToAllTemplate)
        {
            if (blnSetToAllTemplate)
            {
                for (int i = 0; i < m_arrTemplateSetting[m_intGroupIndex].Count; i++)
                    m_arrTemplateSetting[m_intGroupIndex][i].intFailOptionMask |= intAddLogicOptionMask;
            }
            else
            {
                if (m_intTemplateIndex < m_arrTemplateSetting[m_intGroupIndex].Count)
                    m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intFailOptionMask |= intAddLogicOptionMask;
            }
        }

        public void RemoveLogicFailOptionMask(int intRemoveLogicOptionMask, bool blnSetToAllTemplate)
        {
            if (blnSetToAllTemplate)
            {
                for (int i = 0; i < m_arrTemplateSetting[m_intGroupIndex].Count; i++)
                    m_arrTemplateSetting[m_intGroupIndex][i].intFailOptionMask &= ~intRemoveLogicOptionMask;
            }
            else
            {
                if (m_intTemplateIndex < m_arrTemplateSetting[m_intGroupIndex].Count)
                    m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intFailOptionMask &= ~intRemoveLogicOptionMask;
            }
        }

        public void SetFailOptionMask(int intFailOptionMask, int intGroupIndex, int intTemplateIndex)
        {
            m_arrTemplateSetting[intGroupIndex][intTemplateIndex].intFailOptionMask = intFailOptionMask;
        }

        public void SetGroupExtraMinArea(float fGroupExtraMinArea, bool blnSetToAllTemplate)
        {
            switch (m_intDisplayUnitMode)
            {
                case 0: // Pixel
                    if (blnSetToAllTemplate)
                    {
                        for (int i = 0; i < m_arrTemplateSetting[m_intGroupIndex].Count; i++)
                            m_arrTemplateSetting[m_intGroupIndex][i].fGroupExtraMinArea = fGroupExtraMinArea;
                    }
                    else
                    {
                        if (m_intTemplateIndex < m_arrTemplateSetting[m_intGroupIndex].Count)
                            m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fGroupExtraMinArea = fGroupExtraMinArea;
                    }
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    if (blnSetToAllTemplate)
                    {
                        for (int i = 0; i < m_arrTemplateSetting[m_intGroupIndex].Count; i++)
                            m_arrTemplateSetting[m_intGroupIndex][i].fGroupExtraMinArea = (fGroupExtraMinArea / m_fMMToUnitValueArea) / m_fMMPerPixelArea;
                    }
                    else
                    {
                        if (m_intTemplateIndex < m_arrTemplateSetting[m_intGroupIndex].Count)
                            m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fGroupExtraMinArea = (fGroupExtraMinArea / m_fMMToUnitValueArea) / m_fMMPerPixelArea;
                    }
                    break;
            }
        }

        public void SetGroupExtraMinArea(float fGroupExtraMinArea, int intGroupIndex, int intTemplateIndex)
        {
            switch (m_intDisplayUnitMode)
            {
                case 0: // Pixel
                    m_arrTemplateSetting[intGroupIndex][intTemplateIndex].fGroupExtraMinArea = fGroupExtraMinArea;
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    m_arrTemplateSetting[intGroupIndex][intTemplateIndex].fGroupExtraMinArea = (fGroupExtraMinArea / m_fMMToUnitValueArea) / m_fMMPerPixelArea;
                    break;
            }
        }

        public void SetGroupExcessMinArea(float fGroupExcessMinArea, bool blnSetToAllTemplate)
        {
            switch (m_intDisplayUnitMode)
            {
                case 0: // Pixel
                    if (blnSetToAllTemplate)
                    {
                        for (int i = 0; i < m_arrTemplateSetting[m_intGroupIndex].Count; i++)
                            m_arrTemplateSetting[m_intGroupIndex][i].fGroupExcessMinArea = fGroupExcessMinArea;
                    }
                    else
                    {
                        if (m_intTemplateIndex < m_arrTemplateSetting[m_intGroupIndex].Count)
                            m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fGroupExcessMinArea = fGroupExcessMinArea;
                    }
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    if (blnSetToAllTemplate)
                    {
                        for (int i = 0; i < m_arrTemplateSetting[m_intGroupIndex].Count; i++)
                            m_arrTemplateSetting[m_intGroupIndex][i].fGroupExcessMinArea = (fGroupExcessMinArea / m_fMMToUnitValueArea) / m_fMMPerPixelArea;
                    }
                    else
                    {
                        if (m_intTemplateIndex < m_arrTemplateSetting[m_intGroupIndex].Count)
                            m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fGroupExcessMinArea = (fGroupExcessMinArea / m_fMMToUnitValueArea) / m_fMMPerPixelArea;
                    }
                    break;
            }
        }

        public void SetGroupExcessMinArea(float fGroupExcessMinArea, int intGroupIndex, int intTemplateIndex)
        {
            switch (m_intDisplayUnitMode)
            {
                case 0: // Pixel
                    m_arrTemplateSetting[intGroupIndex][intTemplateIndex].fGroupExcessMinArea = fGroupExcessMinArea;
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    m_arrTemplateSetting[intGroupIndex][intTemplateIndex].fGroupExcessMinArea = (fGroupExcessMinArea / m_fMMToUnitValueArea) / m_fMMPerPixelArea;
                    break;
            }
        }

        public void SetMissingMinArea(int intMissingMinArea, bool blnSetToAllTemplate)
        {
            if (blnSetToAllTemplate)
            {
                for (int i = 0; i < m_arrTemplateSetting[m_intGroupIndex].Count; i++)
                    m_arrTemplateSetting[m_intGroupIndex][i].intMissingMinArea = intMissingMinArea;
            }
            else
            {
                if (m_intTemplateIndex < m_arrTemplateSetting[m_intGroupIndex].Count)
                    m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intMissingMinArea = intMissingMinArea;
            }
        }

        public void SetMissingMinArea(int intMissingMinArea, int intGroupIndex, int intTemplateIndex)
        {
            m_arrTemplateSetting[intGroupIndex][intTemplateIndex].intMissingMinArea = intMissingMinArea;
        }

        public void SetRefChars(string strRefChars)
        {
            // Check is first char a space
            for (int i = 0; i < strRefChars.Length; i++)
            {
                if (strRefChars[i] == ' ')
                {
                    strRefChars = strRefChars.Substring(i + 1);
                    i--;
                }
                else
                    break;
            }

            // Check is last char a space
            for (int i = strRefChars.Length - 1; i >= 0; i--)
            {
                if (strRefChars[i] == ' ')
                {
                    strRefChars = strRefChars.Substring(0, strRefChars.Length - 1); ;
                }
                else
                    break;
            }

            m_arrRefChars[m_intGroupIndex] = strRefChars;
            m_objOCR.SetRefCharCounter(strRefChars);
        }

        public void SetTextMinScore(int intTextMinScore, bool blnSetToAllTemplate)
        {
            if (blnSetToAllTemplate)
            {
                for (int i = 0; i < m_arrTemplateSetting[m_intGroupIndex].Count; i++)
                    m_arrTemplateSetting[m_intGroupIndex][i].intTextMinScore = intTextMinScore;
            }
            else
            {
                if (m_intTemplateIndex < m_arrTemplateSetting[m_intGroupIndex].Count)
                    m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intTextMinScore = intTextMinScore;
            }
        }

        public void SetTextMinScore(int intTextMinScore, int intGroupIndex, int intTemplateIndex)
        {
            m_arrTemplateSetting[intGroupIndex][intTemplateIndex].intTextMinScore = intTextMinScore;
        }

        public void SetThreshold(int intThreshold)
        {
            m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intThreshold = intThreshold;
        }

        public void SetThreshold(int intThreshold, int intGroupIndex, int intTemplateIndex)
        {
            m_arrTemplateSetting[intGroupIndex][intTemplateIndex].intThreshold = intThreshold;
        }

        public void SetExtraMarkThreshold(int intThreshold)
        {
            m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intExtraMarkThreshold = intThreshold;
        }

        public void SetExtraMarkThreshold(int intThreshold, int intGroupIndex, int intTemplateIndex)
        {
            m_arrTemplateSetting[intGroupIndex][intTemplateIndex].intExtraMarkThreshold = intThreshold;
        }
        public void SetNoMarkMaximumBlobArea(float fNoMarkMaximumBlobArea)
        {
            switch (m_intDisplayUnitMode)
            {
                case 0: // Pixel
                    m_fNoMarkMaximumBlobArea = fNoMarkMaximumBlobArea;
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    m_fNoMarkMaximumBlobArea = (fNoMarkMaximumBlobArea / m_fMMToUnitValueArea) / m_fMMPerPixelArea;
                    break;
            }
        }
        public void SetUnCheckAreaBottom(float fUnCheckAreaBottom, bool blnSetToAllTemplate)
        {
            switch (m_intDisplayUnitMode)
            {
                case 0: // Pixel
                    if (blnSetToAllTemplate)
                    {
                        for (int i = 0; i < m_arrTemplateSetting[m_intGroupIndex].Count; i++)
                            m_arrTemplateSetting[m_intGroupIndex][i].fUnCheckAreaBottom = fUnCheckAreaBottom;
                    }
                    else
                    {
                        m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fUnCheckAreaBottom = fUnCheckAreaBottom;
                    }
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    if (blnSetToAllTemplate)
                    {
                        for (int i = 0; i < m_arrTemplateSetting[m_intGroupIndex].Count; i++)
                            m_arrTemplateSetting[m_intGroupIndex][i].fUnCheckAreaBottom = (fUnCheckAreaBottom / m_fMMToUnitValue) / m_fMMPerPixelY;
                    }
                    else
                    {
                        m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fUnCheckAreaBottom = (fUnCheckAreaBottom / m_fMMToUnitValue) / m_fMMPerPixelY;
                    }
                    break;
            }

        }

        public void SetUnCheckAreaBottom(float fUnCheckAreaBottom, int intGroupIndex, int intTemplateIndex)
        {
            switch (m_intDisplayUnitMode)
            {
                case 0: // Pixel
                    m_arrTemplateSetting[intGroupIndex][intTemplateIndex].fUnCheckAreaBottom = fUnCheckAreaBottom;
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    m_arrTemplateSetting[intGroupIndex][intTemplateIndex].fUnCheckAreaBottom = (fUnCheckAreaBottom / m_fMMToUnitValue) / m_fMMPerPixelY;
                    break;
            }

        }

        public void SetUnCheckAreaLeft(float fUnCheckAreaLeft, bool blnSetToAllTemplate)
        {
            int intUnCheckAreaLeft = 0;
            switch (m_intDisplayUnitMode)
            {
                case 0: // Pixel
                    if (blnSetToAllTemplate)
                    {
                        for (int i = 0; i < m_arrTemplateSetting[m_intGroupIndex].Count; i++)
                            m_arrTemplateSetting[m_intGroupIndex][i].fUnCheckAreaLeft = fUnCheckAreaLeft;
                    }
                    else
                    {
                        m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fUnCheckAreaLeft = fUnCheckAreaLeft;
                    }
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    if (blnSetToAllTemplate)
                    {
                        for (int i = 0; i < m_arrTemplateSetting[m_intGroupIndex].Count; i++)
                            m_arrTemplateSetting[m_intGroupIndex][i].fUnCheckAreaLeft = (fUnCheckAreaLeft / m_fMMToUnitValue) / m_fMMPerPixelX;
                    }
                    else
                    {
                        m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fUnCheckAreaLeft = (fUnCheckAreaLeft / m_fMMToUnitValue) / m_fMMPerPixelX;
                    }
                    break;
            }

        }

        public void SetUnCheckAreaLeft(float fUnCheckAreaLeft, int intGroupIndex, int intTemplateIndex)
        {
            switch (m_intDisplayUnitMode)
            {
                case 0: // Pixel
                    m_arrTemplateSetting[intGroupIndex][intTemplateIndex].fUnCheckAreaLeft = fUnCheckAreaLeft;
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    m_arrTemplateSetting[intGroupIndex][intTemplateIndex].fUnCheckAreaLeft = (fUnCheckAreaLeft / m_fMMToUnitValue) / m_fMMPerPixelX;
                    break;
            }
        }

        public void SetUnCheckAreaRight(float fUnCheckAreaRight, bool blnSetToAllTemplate)
        {
            switch (m_intDisplayUnitMode)
            {
                case 0: // Pixel
                    if (blnSetToAllTemplate)
                    {
                        for (int i = 0; i < m_arrTemplateSetting[m_intGroupIndex].Count; i++)
                            m_arrTemplateSetting[m_intGroupIndex][i].fUnCheckAreaRight = fUnCheckAreaRight;
                    }
                    else
                    {
                        if (m_intTemplateIndex < m_arrTemplateSetting[m_intGroupIndex].Count)
                            m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fUnCheckAreaRight = fUnCheckAreaRight;
                    }
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    if (blnSetToAllTemplate)
                    {
                        for (int i = 0; i < m_arrTemplateSetting[m_intGroupIndex].Count; i++)
                            m_arrTemplateSetting[m_intGroupIndex][i].fUnCheckAreaRight = (fUnCheckAreaRight / m_fMMToUnitValue) / m_fMMPerPixelX;
                    }
                    else
                    {
                        if (m_intTemplateIndex < m_arrTemplateSetting[m_intGroupIndex].Count)
                            m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fUnCheckAreaRight = (fUnCheckAreaRight / m_fMMToUnitValue) / m_fMMPerPixelX;
                    }
                    break;
            }
        }

        public void SetUnCheckAreaRight(float fUnCheckAreaRight, int intGroupIndex, int intTemplateIndex)
        {
            switch (m_intDisplayUnitMode)
            {
                case 0: // Pixel
                    m_arrTemplateSetting[intGroupIndex][intTemplateIndex].fUnCheckAreaRight = fUnCheckAreaRight;
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    m_arrTemplateSetting[intGroupIndex][intTemplateIndex].fUnCheckAreaRight = (fUnCheckAreaRight / m_fMMToUnitValue) / m_fMMPerPixelX;
                    break;
            }
        }

        public void SetUnCheckAreaTop(float fUnCheckAreaTop, bool blnSetToAllTemplate)
        {
            switch (m_intDisplayUnitMode)
            {
                case 0: // Pixel
                    if (blnSetToAllTemplate)
                    {
                        for (int i = 0; i < m_arrTemplateSetting[m_intGroupIndex].Count; i++)
                            m_arrTemplateSetting[m_intGroupIndex][i].fUnCheckAreaTop = fUnCheckAreaTop;
                    }
                    else
                    {
                        m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fUnCheckAreaTop = fUnCheckAreaTop;
                    }
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    if (blnSetToAllTemplate)
                    {
                        for (int i = 0; i < m_arrTemplateSetting[m_intGroupIndex].Count; i++)
                            m_arrTemplateSetting[m_intGroupIndex][i].fUnCheckAreaTop = (fUnCheckAreaTop / m_fMMToUnitValue) / m_fMMPerPixelY;
                    }
                    else
                    {
                        m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fUnCheckAreaTop = (fUnCheckAreaTop / m_fMMToUnitValue) / m_fMMPerPixelY;
                    }
                    break;
            }

        }

        public void SetUnCheckAreaTop(float fUnCheckAreaTop, int intGroupIndex, int intTemplateIndex)
        {
            switch (m_intDisplayUnitMode)
            {
                case 0: // Pixel
                    m_arrTemplateSetting[intGroupIndex][intTemplateIndex].fUnCheckAreaTop = fUnCheckAreaTop;
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    m_arrTemplateSetting[intGroupIndex][intTemplateIndex].fUnCheckAreaTop = (fUnCheckAreaTop / m_fMMToUnitValue) / m_fMMPerPixelY;
                    break;
            }
        }


        // --------- OCV function -------------------------------------------

        public int GetNumTemplates()
        {
            return m_arrOCV[m_intGroupIndex].Count;
            //return m_arrTemplateSetting[m_intGroupIndex].Count;
        }

        public int GetNumTexts()
        {
            return m_objOCV.GetNumTexts();
        }

        public void BuildOCVChars(int intCreationMode)
        {
            m_objOCV.BuildChars(m_objLearnBlobs[m_intTemplateIndex], intCreationMode);
        }

        public void BuildOCVAndGetInformation(ROI objParentLearnROI, ROI objLearnROI, int intCreationMode)
        {
            // Get shft
            float[] arrXToleranceChars = m_arrOCV[m_intGroupIndex][m_intTemplateIndex].GetCharsShiftX();
            float[] arrYToleranceChars = m_arrOCV[m_intGroupIndex][m_intTemplateIndex].GetCharsShiftY();

            for (int i = 0; i < arrXToleranceChars.Length; i++)
            {
                if ((arrXToleranceChars[i] - m_fCharROIOffsetX) >= 0)
                    arrXToleranceChars[i] = arrXToleranceChars[i] - m_fCharROIOffsetX;
            }

            for (int i = 0; i < arrYToleranceChars.Length; i++)
            {
                if ((arrYToleranceChars[i] - m_fCharROIOffsetY) >= 0)
                    arrYToleranceChars[i] = arrYToleranceChars[i] - m_fCharROIOffsetY;
            }

            m_objOCV.BuildChars(m_objLearnBlobs[m_intTemplateIndex], intCreationMode);

            m_objOCV.BuildTexts();

            ROI objLocalROI = new ROI();
            objLocalROI.ref_ROI.Attach(objLearnROI.ref_ROI.TopParent);
            objLocalROI.LoadROISetting(objLearnROI.ref_ROITotalX, objLearnROI.ref_ROITotalY, objLearnROI.ref_ROIWidth, objLearnROI.ref_ROIHeight);
            ROI objTopROI = new ROI();
            objTopROI.ref_ROI.Attach(objLearnROI.ref_ROI.TopParent);
            objTopROI.LoadROISetting(0, 0, objLearnROI.ref_ROI.TopParent.Width, objLearnROI.ref_ROI.TopParent.Height);

            ////2020-06-17 ZJYEOH : Invert if black on white
            //ImageDrawing objImage = new ImageDrawing(true, objLearnROI.ref_ROI.TopParent.Width, objLearnROI.ref_ROI.TopParent.Height);
            //if (!m_blnWhiteOnBlack)
            //{
            //    objLocalROI.ref_ROI.Detach();
            //    EasyImage.Oper(EArithmeticLogicOperation.Copy, objLearnROI.ref_ROI.TopParent, objImage.ref_objMainImage);
            //    objLocalROI.ref_ROI.Attach(objImage.ref_objMainImage);
            //    //EasyImage.Oper(EArithmeticLogicOperation.Invert, objLocalROI.ref_ROI, objLocalROI.ref_ROI);
            //    ROI.InvertOperationROI(objLocalROI);
            //}

            m_objOCV.SetTemplateImage(objTopROI, objLocalROI.ref_ROIPositionX, objLocalROI.ref_ROIPositionY, objLocalROI.ref_ROIWidth, objLocalROI.ref_ROIHeight);
            m_objOCV.Learn(objLocalROI, m_blnWhiteOnBlack);

            //2020-06-01 ZJYEOH : threshold value will depend on inspection method
            int intThresholdValue = m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intThreshold;

            if (m_blnWantUseGrayValue)
                intThresholdValue = GetGrayValueThreshold(objLocalROI, m_intMarkInspectionAreaGrayValueSensitivity, m_intMarkBrightSensitivity);

            ////2020-06-17 ZJYEOH : Invert threshold value if black on white
            //if (!m_blnWhiteOnBlack)
            //{
            //    intThresholdValue = 255 - intThresholdValue;
            //}
            // 2020 04 15 - CCENG: Use binarized location mode during learn bcos binaried result always have same position with learn position.
            //m_objOCV.InspectForOCVInformation(objLocalROI, m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intThreshold);
            m_objOCV.InspectForOCVInformation_ForLearning(objLocalROI, intThresholdValue, arrXToleranceChars, arrYToleranceChars, m_fCharROIOffsetX, m_fCharROIOffsetY); //m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intThreshold

            int intOcvTextStartX = 0;
            int intOcvTextStartY = 0;
            m_objOCV.GetOCVTextStartXY(0, ref intOcvTextStartX, ref intOcvTextStartY);

            m_objOCV.GetBuildOCVPosition(ref m_arrBuildOcvStartX, ref m_arrBuildOcvStartY, ref m_arrBuildOcvEndX, ref m_arrBuildOcvEndY);

            List<int> arrSkip = new List<int>();
            for (int i = 0; i < m_arrBuildOcvStartX.Count; i++)
            {
                if (arrSkip.Contains(i))
                    continue;

                int intStartX = m_arrBuildOcvStartX[i];
                int intStartY = m_arrBuildOcvStartY[i];
                int intEndX = m_arrBuildOcvEndX[i];
                int intEndY = m_arrBuildOcvEndY[i];
                bool blnFound = false;
                for (int j = 0; j < m_arrBuildOcvStartX.Count; j++)//2021-11-24 ZJYEOH : Changed int j = i to int j = 0
                {
                    if (i == j || arrSkip.Contains(j))
                        continue;

                    int intCenterX = (m_arrBuildOcvStartX[i] + m_arrBuildOcvEndX[i]) / 2;
                    int intCenterY = (m_arrBuildOcvStartY[i] + m_arrBuildOcvEndY[i]) / 2;

                    if ((intCenterX >= m_arrBuildOcvStartX[j]) &&
                        (intCenterX <= m_arrBuildOcvEndX[j]) &&
                        (intCenterY >= m_arrBuildOcvStartY[j]) &&
                        (intCenterY <= m_arrBuildOcvEndY[j]))
                    {
                        blnFound = true;

                        intStartX = Math.Min(intStartX, m_arrBuildOcvStartX[j]);
                        intStartY = Math.Min(intStartY, m_arrBuildOcvStartY[j]);
                        intEndX = Math.Max(intEndX, m_arrBuildOcvEndX[j]);
                        intEndY = Math.Max(intEndY, m_arrBuildOcvEndY[j]);

                        arrSkip.Add(j);

                        //2021-11-24 ZJYEOH : Hide this, will use arrSkip to remove mateched char later
                        //m_arrBuildOcvStartX.RemoveAt(j);
                        //m_arrBuildOcvStartY.RemoveAt(j);
                        //m_arrBuildOcvEndX.RemoveAt(j);
                        //m_arrBuildOcvEndY.RemoveAt(j);
                        //j--;
                    }
                }

                if (blnFound)
                {
                    m_arrBuildOcvStartX[i] = intStartX;
                    m_arrBuildOcvStartY[i] = intStartY;
                    m_arrBuildOcvEndX[i] = intEndX;
                    m_arrBuildOcvEndY[i] = intEndY;

                }
                
            }

            //2021-11-24 ZJYEOH :Remove matched char here
            for (int i = m_arrBuildOcvStartX.Count - 1; i >= 0; i--)
            {
                if (arrSkip.Contains(i))
                {
                    m_arrBuildOcvStartX.RemoveAt(i);
                    m_arrBuildOcvStartY.RemoveAt(i);
                    m_arrBuildOcvEndX.RemoveAt(i);
                    m_arrBuildOcvEndY.RemoveAt(i);
                }
            }

            m_arrBuildOcvTextCharOffsetX.Clear();
            m_arrBuildOcvTextCharOffsetY.Clear();
            for (int i = 0; i < m_arrBuildOcvStartX.Count; i++)
            {
                m_arrBuildOcvTextCharOffsetX.Add((((float)(m_arrBuildOcvStartX[i] + m_arrBuildOcvEndX[i])) / 2) - intOcvTextStartX);
                m_arrBuildOcvTextCharOffsetY.Add((((float)(m_arrBuildOcvStartY[i] + m_arrBuildOcvEndY[i])) / 2) - intOcvTextStartY);
            }

            // Resorting blobs from left to right
            SortBlobsFromleftToRight();
            List<int> arrBuildOcvStartX = new List<int>();
            List<int> arrBuildOcvStartY = new List<int>();
            List<int> arrBuildOcvEndX = new List<int>();
            List<int> arrBuildOcvEndY = new List<int>();
            for (int i = 0; i < m_arrBuildOcvStartX.Count; i++)
            {
                arrBuildOcvStartX.Add(m_arrBuildOcvStartX[i]);
                arrBuildOcvStartY.Add(m_arrBuildOcvStartY[i]);
                arrBuildOcvEndX.Add(m_arrBuildOcvEndX[i]);
                arrBuildOcvEndY.Add(m_arrBuildOcvEndY[i]);
            }
            m_arrBuildOcvStartX.Clear();
            m_arrBuildOcvStartY.Clear();
            m_arrBuildOcvEndX.Clear();
            m_arrBuildOcvEndY.Clear();
            for (int i = 0; i < arrBuildOcvStartX.Count; i++)
            {
                m_arrBuildOcvStartX.Add(arrBuildOcvStartX[m_arrBuildOcvBlobNo[i]]);
                m_arrBuildOcvStartY.Add(arrBuildOcvStartY[m_arrBuildOcvBlobNo[i]]);
                m_arrBuildOcvEndX.Add(arrBuildOcvEndX[m_arrBuildOcvBlobNo[i]]);
                m_arrBuildOcvEndY.Add(arrBuildOcvEndY[m_arrBuildOcvBlobNo[i]]);
            }

            //// Get shft
            //int[] arrXToleranceChars = m_arrOCV[m_intGroupIndex][m_intTemplateIndex].GetCharsShiftX();
            //int[] arrYToleranceChars = m_arrOCV[m_intGroupIndex][m_intTemplateIndex].GetCharsShiftY();

            int[] arrMarkType = new int[m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMarkType.Count];
            arrMarkType = m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMarkType.ToArray();
            m_arrBuildOcvStartXOri.Clear();
            m_arrBuildOcvStartYOri.Clear();
            m_arrBuildOcvEndXOri.Clear();
            m_arrBuildOcvEndYOri.Clear();
            m_arrBuildOcvCharShiftX.Clear();
            m_arrBuildOcvCharShiftY.Clear();
            m_arrBuildOcvTextCharOffsetX.Clear();
            m_arrBuildOcvTextCharOffsetY.Clear();
            m_arrBuildOcvEnableStatus.Clear();
            m_arrBuildOcvType.Clear();
            m_arrBuildOcvTypeOri.Clear();
            m_arrBuildOcvSelectStatus.Clear();
            m_arrBuildOcvSelectStatusOri.Clear();
            m_arrBuildOcvSelectStatusPrev.Clear();
            m_arrBuildOcvNo.Clear();
            for (int i = 0; i < m_arrBuildOcvStartX.Count; i++)
            {
                m_arrBuildOcvStartXOri.Add(m_arrBuildOcvStartX[i]);
                m_arrBuildOcvStartYOri.Add(m_arrBuildOcvStartY[i]);
                m_arrBuildOcvEndXOri.Add(m_arrBuildOcvEndX[i]);
                m_arrBuildOcvEndYOri.Add(m_arrBuildOcvEndY[i]);

                // 2020 02 28 - FSE request to reset to 0 since software have add new feature Char ROI tolerance size at advance setting
                //if (arrXToleranceChars.Length == 0)
                //    m_arrBuildOcvCharShiftX.Add(5);
                //else if (i < arrXToleranceChars.Length)
                //    m_arrBuildOcvCharShiftX.Add(arrXToleranceChars[i]);
                //else
                //    m_arrBuildOcvCharShiftX.Add(arrXToleranceChars[arrXToleranceChars.Length - 1]);

                //if (arrYToleranceChars.Length == 0)
                //    m_arrBuildOcvCharShiftY.Add(5);
                //else if (i < arrYToleranceChars.Length)
                //    m_arrBuildOcvCharShiftY.Add(arrYToleranceChars[i]);
                //else
                //    m_arrBuildOcvCharShiftY.Add(arrYToleranceChars[arrYToleranceChars.Length - 1]);
                m_arrBuildOcvCharShiftX.Add(0);
                m_arrBuildOcvCharShiftY.Add(0);

                m_arrBuildOcvEnableStatus.Add(true);
                if (i < arrMarkType.Length)
                    m_arrBuildOcvType.Add(arrMarkType[i]);
                else
                    m_arrBuildOcvType.Add(0);
                if (i < arrMarkType.Length)
                    m_arrBuildOcvTypeOri.Add(arrMarkType[i]);
                else
                    m_arrBuildOcvTypeOri.Add(0);
                m_arrBuildOcvSelectStatus.Add(1);
                m_arrBuildOcvSelectStatusOri.Add(1);
                m_arrBuildOcvSelectStatusPrev.Add(1);
                m_arrBuildOcvNo.Add(i);
            }
            //objImage.Dispose();
        }

        public void SortBlobsFromleftToRight()
        {
            m_arrBuildOcvBlobNo.Clear();
            List<PointF> arrCenterPoints = new List<PointF>();

            float fCenterX, fCenterY;
            for (int h = 0; h < m_arrBuildOcvStartX.Count; h++)
            {
                fCenterX = (float)(m_arrBuildOcvStartX[h] + m_arrBuildOcvEndX[h]) / 2;
                fCenterY = (float)(m_arrBuildOcvStartY[h] + m_arrBuildOcvEndY[h]) / 2;

                int intSelectedIndex = 0;
                for (int i = 0; i < arrCenterPoints.Count; i++)
                {
                    // same row
                    if ((fCenterY < (arrCenterPoints[i].Y + 10)) &&
                        (fCenterY > (arrCenterPoints[i].Y - 10)))
                    {
                        if (fCenterX > arrCenterPoints[i].X)
                            intSelectedIndex++;
                    }
                    // different row
                    else
                    {
                        if (fCenterY > (arrCenterPoints[i].Y - 10))
                            intSelectedIndex++;
                    }
                }

                if (intSelectedIndex == m_arrBuildOcvBlobNo.Count)
                    arrCenterPoints.Add(new PointF(fCenterX, fCenterY));
                else
                    arrCenterPoints.Insert(intSelectedIndex, new PointF(fCenterX, fCenterY));

                for (int i = 0; i < m_arrBuildOcvBlobNo.Count; i++)
                {
                    if ((int)m_arrBuildOcvBlobNo[i] >= intSelectedIndex)
                        m_arrBuildOcvBlobNo[i] = (int)m_arrBuildOcvBlobNo[i] + 1;
                }

                m_arrBuildOcvBlobNo.Add(intSelectedIndex);
            }

        }

        public void DrawBuildOCV(Graphics g, float fDrawingScaleX, float fDrawingScaleY, Color[] arrColor)
        {
            //Pen objPenLime = new Pen(Color.Lime);
            //Pen objPenRed = new Pen(Color.Red);
            //Pen objPenYellow = new Pen(Color.Yellow);
            //Pen objPenPurple = new Pen(Color.Purple, 2.0f);

            for (int i = 0; i < m_arrBuildOcvSelectStatus.Count; i++)
            {
                float fCharShiftX = (int)Math.Round(m_arrBuildOcvCharShiftX[i] + m_fCharROIOffsetX);
                float fCharShiftY = (int)Math.Round(m_arrBuildOcvCharShiftY[i] + m_fCharROIOffsetY);
                string strType = "Char";
                if (m_arrBuildOcvType[i] == 1)
                    strType = "Logo";
                else if (m_arrBuildOcvType[i] == 2)
                    strType = "Symbol 1";
                else if (m_arrBuildOcvType[i] == 2)
                    strType = "Symbol 2";

                if (m_arrBuildOcvSelectStatus[i] == 1)
                {

                    g.DrawRectangle(new Pen(arrColor[0]),
                      (m_arrBuildOcvStartX[i] - fCharShiftX) * fDrawingScaleX,
                      (m_arrBuildOcvStartY[i] - fCharShiftY) * fDrawingScaleY,
                      ((m_arrBuildOcvEndX[i] - m_arrBuildOcvStartX[i]) + fCharShiftX * 2) * fDrawingScaleX,
                      ((m_arrBuildOcvEndY[i] - m_arrBuildOcvStartY[i]) + fCharShiftY * 2) * fDrawingScaleY);

                    if (m_blnWantUseMarkTypeInspectionSetting)
                        g.DrawString(strType, m_Font, new SolidBrush(Color.Lime),
                                     (m_arrBuildOcvStartX[i] - fCharShiftX) * fDrawingScaleX,
                                     (m_arrBuildOcvStartY[i] - fCharShiftY - m_Font.Height) * fDrawingScaleY);


                }
                else if (m_arrBuildOcvSelectStatus[i] == 2)
                {
                    g.DrawRectangle(new Pen(arrColor[1]),//objPenYellow,
                       (m_arrBuildOcvStartX[i] - fCharShiftX) * fDrawingScaleX,
                      (m_arrBuildOcvStartY[i] - fCharShiftY) * fDrawingScaleY,
                      ((m_arrBuildOcvEndX[i] - m_arrBuildOcvStartX[i]) + fCharShiftX * 2) * fDrawingScaleX,
                      ((m_arrBuildOcvEndY[i] - m_arrBuildOcvStartY[i]) + fCharShiftY * 2) * fDrawingScaleY);

                    if (m_blnWantUseMarkTypeInspectionSetting)
                        g.DrawString(strType, m_Font, new SolidBrush(Color.Blue),//new SolidBrush(Color.Yellow),
                                        (m_arrBuildOcvStartX[i] - fCharShiftX) * fDrawingScaleX,
                                        (m_arrBuildOcvStartY[i] - fCharShiftY - m_Font.Height) * fDrawingScaleY);
                }
                else
                {
                    g.DrawRectangle(new Pen(arrColor[3]),
                       (m_arrBuildOcvStartX[i] - fCharShiftX) * fDrawingScaleX,
                      (m_arrBuildOcvStartY[i] - fCharShiftY) * fDrawingScaleY,
                      ((m_arrBuildOcvEndX[i] - m_arrBuildOcvStartX[i]) + fCharShiftX * 2) * fDrawingScaleX,
                      ((m_arrBuildOcvEndY[i] - m_arrBuildOcvStartY[i]) + fCharShiftY * 2) * fDrawingScaleY);
                }

                if (m_arrBuildOcvEnableStatus[i] == false)
                {
                    g.DrawLine(new Pen(arrColor[2]),
                 (m_arrBuildOcvStartX[i] - fCharShiftX) * fDrawingScaleX,
                 (m_arrBuildOcvStartY[i] - fCharShiftY) * fDrawingScaleY,
                 (m_arrBuildOcvEndX[i] + fCharShiftX) * fDrawingScaleX,
                 (m_arrBuildOcvEndY[i] + fCharShiftY) * fDrawingScaleY);

                    g.DrawLine(new Pen(arrColor[2]),
                 (m_arrBuildOcvEndX[i] + fCharShiftX) * fDrawingScaleX,
                 (m_arrBuildOcvStartY[i] - fCharShiftY) * fDrawingScaleY,
                 (m_arrBuildOcvStartX[i] - fCharShiftX) * fDrawingScaleX,
                 (m_arrBuildOcvEndY[i] + fCharShiftY) * fDrawingScaleY);
                }
            }

            if (m_blnIsSplitLineDisplaying)
                m_objSplitMarkLine.DrawLine(g, fDrawingScaleX, fDrawingScaleY, arrColor[4]);
        }

        public void SetTemplateImage(ROI objROI, int intOriX, int intOriY, int intWidth, int intHeight)
        {
            m_objOCV.SetTemplateImage(objROI, intOriX, intOriY, intWidth, intHeight);
        }

        public void DrawOCVChars(Graphics g, ROI objROI, int intOriX, int intOriY, int intWidth, int intHeight, float fDrawingScaleX, float fDrawingScaleY)
        {
            //m_objOCV.SetTemplateImage(objROI, intOriX, intOriY, intWidth, intHeight);
            m_objOCV.DrawTemplateChars(g, fDrawingScaleX, fDrawingScaleY);
        }

        public void DrawOCVTexts(Graphics g, ROI objROI, int intOriX, int intOriY, int intWidth, int intHeight, float fDrawingScaleX, float fDrawingScaleY)
        {
            m_objOCV.SetTemplateImage(objROI, intOriX, intOriY, intWidth, intHeight);
            m_objOCV.DrawTemplateTexts(g, fDrawingScaleX, fDrawingScaleY);
        }

        public void LearnOCVTemplate(ImageDrawing objTemplateImage, /*ImageDrawing objOCVTemplateImage,*/ ROI objSearchROI, ROI objLearnROI, bool blnUsePreviousSetting, bool blnSetShiftTextToleranceToSearchROI, int intDefaultMarkScore,
                                     string strOCVTemplateImagePath, int intSelectedTemplate)
        {
            /*
             * Variables Involved:
             * 1. m_objOCV
             *      - arrBuildOcvCenterX etc
             * 2. 
             * 
             */

            // ----------------------- Cut character box ----------------------------------------------------------
            if ((objLearnROI.ref_ROI.TopParent.Width != m_objSampleImage.ref_objMainImage.Width) && (objLearnROI.ref_ROI.TopParent.Height != m_objSampleImage.ref_objMainImage.Height))
            {
                m_objSampleImage.ref_objMainImage.SetSize(objLearnROI.ref_ROI.TopParent.Width, objLearnROI.ref_ROI.TopParent.Height);
            }
            EasyImage.Copy(objLearnROI.ref_ROI.TopParent, m_objSampleImage.ref_objMainImage);
            EBW8 px = new EBW8();

            // 2020-06-17 ZJYEOH : if Black on White, need set pixel value to 255 as we will build black object
            if (m_blnWhiteOnBlack)
                px.Value = 0;
            else
                px.Value = 255;

            //for (int i = 0; i < m_arrBuildOcvSelectStatus.Count; i++)
            //{
            //    for (int x = m_arrBuildOcvStartX[i] - 1; x <= m_arrBuildOcvEndX[i] + 1; x++)
            //        m_objSampleImage.ref_objMainImage.SetPixel(px, x, m_arrBuildOcvStartY[i] - 1);

            //    for (int x = m_arrBuildOcvStartX[i] - 1; x <= m_arrBuildOcvEndX[i] + 1; x++)
            //        m_objSampleImage.ref_objMainImage.SetPixel(px, x, m_arrBuildOcvEndY[i] + 1);

            //    for (int y = m_arrBuildOcvStartY[i] - 1; y <= m_arrBuildOcvEndY[i] + 1; y++)
            //        m_objSampleImage.ref_objMainImage.SetPixel(px, m_arrBuildOcvStartX[i] - 1, y);

            //    for (int y = m_arrBuildOcvStartY[i] - 1; y <= m_arrBuildOcvEndY[i] + 1; y++)
            //        m_objSampleImage.ref_objMainImage.SetPixel(px, m_arrBuildOcvEndX[i] + 1, y);
            //}

            //2021-09-21 ZJYEOH : Draw using collected split points
            Line objLine = new Line();
            for (int i = 0; i < m_arrBuildOcvSplitStart.Count; i++)
            {
                objLine.CalculateLGStraightLine(m_arrBuildOcvSplitStart[i], m_arrBuildOcvSplitEnd[i]);

                if (objLine.ref_dSlope == 0)
                {
                    for (int x = m_arrBuildOcvSplitStart[i].X - 1; x <= m_arrBuildOcvSplitEnd[i].X + 1; x++)
                        m_objSampleImage.ref_objMainImage.SetPixel(px, x, m_arrBuildOcvSplitStart[i].Y - 1);
                }
                else
                {
                    for (int y = m_arrBuildOcvSplitStart[i].Y - 1; y <= m_arrBuildOcvSplitEnd[i].Y + 1; y++)
                        m_objSampleImage.ref_objMainImage.SetPixel(px, m_arrBuildOcvSplitStart[i].X - 1, y);
                }
            }
            //m_objSampleImage.ref_objMainImage.Save("D:\\TS\\m_objSampleImage.bmp");

            // ----------------------- Build blobs ----------------------- 
            ROI objLocalROI = new ROI();
            objLocalROI.AttachImage(m_objSampleImage);
            objLocalROI.LoadROISetting(objLearnROI.ref_ROITotalX, objLearnROI.ref_ROITotalY, objLearnROI.ref_ROIWidth, objLearnROI.ref_ROIHeight);

            //2020-06-01 ZJYEOH : threshold value will depend on inspection method
            int intThresholdValue = m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intThreshold;
            if (m_blnWantUseGrayValue)
            {
                BuildLearnObject_UsingGrayValue(objLocalROI, false, true, m_intMarkInspectionAreaGrayValueSensitivity, m_intMarkBrightSensitivity);
                intThresholdValue = GetGrayValueThreshold(objLocalROI, m_intMarkInspectionAreaGrayValueSensitivity, m_intMarkBrightSensitivity);
            }
            else
                BuildLearnObject(objLocalROI, false, true);


            //2020-11-19 ZJYEOH : Save another image that contain only blob that wanted to save as OCV Template image, this is to prevent subtract extra area that cause by small noise(become larger after dilate)
            DrawBlobsROI(objLocalROI, strOCVTemplateImagePath + "OCVTemplate0_" + intSelectedTemplate + ".bmp");
            ImageDrawing objOCVImage = new ImageDrawing(true);// 2020-11-19 ZJYEOH : OVC Image that contain clean OCV Char without noise
            if (File.Exists(strOCVTemplateImagePath + "OCVTemplate0_" + intSelectedTemplate + ".bmp"))
                objOCVImage.LoadImage(strOCVTemplateImagePath + "OCVTemplate0_" + intSelectedTemplate + ".bmp");
            else
            {
                if (File.Exists(strOCVTemplateImagePath + "Template0_" + intSelectedTemplate + ".bmp"))
                    objOCVImage.LoadImage(strOCVTemplateImagePath + "Template0_" + intSelectedTemplate + ".bmp");
            }


            //objLocalROI.SaveImage("D:\\objLocalROI1.bmp");
            ////2020-06-17 ZJYEOH : Invert if black on white
            //ImageDrawing objImage = new ImageDrawing(true, objLearnROI.ref_ROI.TopParent.Width, objLearnROI.ref_ROI.TopParent.Height);
            //if (!m_blnWhiteOnBlack)
            //{
            //    EasyImage.Oper(EArithmeticLogicOperation.Copy, objLocalROI.ref_ROI.TopParent, objImage.ref_objMainImage);
            //    objLocalROI.ref_ROI.Detach();
            //    objLocalROI.ref_ROI.Attach(objImage.ref_objMainImage);
            //    //EasyImage.Oper(EArithmeticLogicOperation.Invert, objLocalROI.ref_ROI, objLocalROI.ref_ROI);
            //    ROI.InvertOperationROI(objLocalROI);
            //}
            //objLocalROI.SaveImage("D:\\objLocalROI2.bmp");

            ////2020-06-17 ZJYEOH : Invert threshold value if black on white
            //if (!m_blnWhiteOnBlack)
            //{
            //    intThresholdValue = 255 - intThresholdValue;
            //}

            // ----------------------- Build ocv to get char position and size for image after trim character border ----------------------- 
            m_objOCV.BuildChars(m_objLearnBlobs[m_intTemplateIndex], 1);
            m_objOCV.BuildTexts();
            ROI objTopParentROI = new ROI();
            objTopParentROI.AttachImage(m_objSampleImage);
            objTopParentROI.LoadROISetting(0, 0, m_objSampleImage.ref_intImageWidth, m_objSampleImage.ref_intImageHeight);
            m_objOCV.SetTemplateImage(objTopParentROI, objLocalROI.ref_ROIPositionX, objLocalROI.ref_ROIPositionY, objLocalROI.ref_ROIWidth, objLocalROI.ref_ROIHeight);
            m_objOCV.Learn(objLocalROI, m_blnWhiteOnBlack);

            // 2020 04 15 - CCENG: Use binarized location mode during learn bcos binaried result always have same position with learn position.
            //m_objOCV.InspectForOCVInformation(objLocalROI, m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intThreshold);
            m_objOCV.InspectForOCVInformation_ForLearning(objLocalROI, intThresholdValue, m_arrBuildOcvCharShiftX.ToArray(), m_arrBuildOcvCharShiftY.ToArray(), m_fCharROIOffsetX, m_fCharROIOffsetY);

            List<int> arrBuildOcvCenterX = new List<int>();
            List<int> arrBuildOcvCenterY = new List<int>();
            List<int> arrBuildOcvStartX = new List<int>();
            List<int> arrBuildOcvStartY = new List<int>();
            List<int> arrBuildOcvEndX = new List<int>();
            List<int> arrBuildOcvEndY = new List<int>();
            m_objOCV.GetBuildOCVPosition(ref arrBuildOcvStartX, ref arrBuildOcvStartY, ref arrBuildOcvEndX, ref arrBuildOcvEndY, ref arrBuildOcvCenterX, ref arrBuildOcvCenterY);


            // ----------------------- Match the (local) arrBuildOcvCenterX, Y to m_arrBuildOcvCenterX, Y (edited by user) and build singe char roi if have---------------------------------------------- 
            m_objOCV.BuildChars(m_objLearnBlobs[m_intTemplateIndex], 1);

            for (int i = 0; i < m_arrBuildOcvSelectStatus.Count; i++)
            {
                List<int> arrMatchList = new List<int>();
                for (int h = 0; h < arrBuildOcvCenterX.Count; h++)
                {
                    if ((arrBuildOcvCenterX[h] >= m_arrBuildOcvStartX[i]) &&
                        (arrBuildOcvCenterX[h] <= m_arrBuildOcvEndX[i]) &&
                        (arrBuildOcvCenterY[h] >= m_arrBuildOcvStartY[i]) &&
                        (arrBuildOcvCenterY[h] <= m_arrBuildOcvEndY[i]))
                    {
                        arrMatchList.Add(h);
                    }
                }
                m_objOCV.ResetPreviousSelectedChars();

                if (arrMatchList.Count > 1)
                {
                }
                for (int k = 0; k < arrMatchList.Count; k++)
                {
                    m_objOCV.SetTemplateImage(objLocalROI);

                    System.Drawing.Point p = new System.Drawing.Point(arrBuildOcvCenterX[arrMatchList[k]], arrBuildOcvCenterY[arrMatchList[k]]);

                    if (m_arrBuildOcvSelectStatus[i] == 0)
                        m_objOCV.SelectTemplateChars_AlwaysFalse(p, p);
                    else
                        m_objOCV.SelectTemplateChars_AlwaysTrue(p, p);
                }

                m_objOCV.FormSingleSelectedChars();
            }

            // ----------------------- Unselect all char ROI ---------------------------------------------- 
            m_objOCV.ResetPreviousSelectedChars();


            // ----------------------- Select all char ROI ------------------------------------------------
            for (int i = 0; i < m_arrBuildOcvSelectStatus.Count; i++)
            {
                m_objOCV.SetTemplateImage(objLocalROI);

                System.Drawing.Point p = new System.Drawing.Point((m_arrBuildOcvStartX[i] + m_arrBuildOcvEndX[i]) / 2,
                                                                  (m_arrBuildOcvStartY[i] + m_arrBuildOcvEndY[i]) / 2);

                if (m_arrBuildOcvSelectStatus[i] == 0)
                    m_objOCV.SelectTemplateChars_AlwaysFalse(p, p);
                else
                    m_objOCV.SelectTemplateChars_AlwaysTrue(p, p);
            }

            // ----------------------- Build Text ---------------------------------------------- 
            m_objOCV.BuildTexts();


            // ----------------------- Learn OCV again according to latest char ROI edited by user ---------------------------------------------- 
            m_objOCV.SetTemplateImage(objTopParentROI, objLocalROI.ref_ROIPositionX, objLocalROI.ref_ROIPositionY, objLocalROI.ref_ROIWidth, objLocalROI.ref_ROIHeight);
            m_objOCV.Learn(objLocalROI, m_blnWhiteOnBlack);

            // ----------------------- Get ocv char position according to latest char ROI edited by user ---------------------------------------------- 
            m_objOCV.GetBuildOCVPosition(ref arrBuildOcvCenterX, ref arrBuildOcvCenterY);


            // ----------------------- Resorting chars in OCV start from top left ---------------------------------------------- 
            m_objOCV.SortTemplateCharsByCenterPoint();
            List<int> CharNo = m_objOCV.GetCharNo();


            // ----------------------- Transfer char setting (EnableStatus, CharShiftedX, Y) from m_arrBuildOcvEnableStatus(edited by user) to template ocv char. ----------------------- 
            // ----------------------- 
            int intNumChars = m_objOCV.GetNumChars();
            int diff = (intNumChars - m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable.Count);
            if (diff > 0)
            {
                for (int i = 0; i < diff; i++)
                {
                    m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable.Add(m_arrBuildOcvEnableStatus[i]);
                    m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMarkType.Add(m_arrBuildOcvType[i]);
                    m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftX.Add(m_arrBuildOcvCharShiftX[i]);
                    m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftY.Add(m_arrBuildOcvCharShiftY[i]);
                }
            }

            bool bln_skip = false;
            bool bln_end = false;
            int index = 0;

            //cxlim 2020-12-11 : added to solve the learn mark issue which after filter certain mark, if user click ignore mark
            //                   will cause the ignore mark occur in other mark 
            for (int i = 0; i < intNumChars; i++)
            {
                if (i >= intNumChars - 1)
                {
                    if (m_arrBuildOcvSelectStatus[i + index] == 0) //last char fail
                        continue;
                }
                else
                {
                    if (bln_skip)
                    {
                        if (m_arrBuildOcvSelectStatus[i + index] != 0)
                            m_arrBuildOcvEnableStatus[i] = m_arrBuildOcvEnableStatus[i + index];
                        else
                        {
                            bln_end = false;
                            while (m_arrBuildOcvSelectStatus[i + index] == 0)
                            {
                                index++;
                                if (i + index > m_arrBuildOcvSelectStatus.Count - 1)
                                    bln_end = true;
                            }

                            if (!bln_end)
                            {
                                m_arrBuildOcvEnableStatus[i] = m_arrBuildOcvEnableStatus[i + index];
                            }
                        }
                    }
                    else
                    {
                        if (m_arrBuildOcvSelectStatus[i] == 0)
                        {
                            index++;
                            if (m_arrBuildOcvSelectStatus[i + index] != 0)
                                m_arrBuildOcvEnableStatus[i] = m_arrBuildOcvEnableStatus[i + index];
                            else
                            {
                                bln_end = false;
                                while (m_arrBuildOcvSelectStatus[i + index] == 0)
                                {
                                    index++;
                                    if (i + index > m_arrBuildOcvSelectStatus.Count - 1)
                                        bln_end = true;
                                }

                                if (!bln_end)
                                {
                                    m_arrBuildOcvEnableStatus[i] = m_arrBuildOcvEnableStatus[i + index];
                                }
                            }
                            bln_skip = true;
                        }
                    }
                }
                m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[CharNo[i]] = m_arrBuildOcvEnableStatus[i];
                m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftX[CharNo[i]] = m_arrBuildOcvCharShiftX[i];
                m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMarkType[CharNo[i]] = m_arrBuildOcvType[i];
                m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharShiftY[CharNo[i]] = m_arrBuildOcvCharShiftY[i];
            }

            //------------------------------------Check is it Bar Pin 1------------------------------------------------------------
            // 2020 02 27 - CCENG: hide bcos will use new condition
            //Condition 1, ratio of shorter length to longer length is more than 3:1
            //Condition 2, one side of tip is touching the side of the unit]
            //if (m_blnWantCheckBarPin1)
            //{
            //    for (int i = 0; i < intNumChars; i++)
            //    {
            //        int intBuildOcvWidth = m_arrBuildOcvEndX[i] - m_arrBuildOcvStartX[i];
            //        int intBuildOcvHeight = m_arrBuildOcvEndY[i] - m_arrBuildOcvStartY[i];
            //        if (intBuildOcvWidth < intBuildOcvHeight && (float)intBuildOcvHeight / (float)intBuildOcvWidth > 3 &&
            //            (m_arrBuildOcvStartY[i] - objLocalROI.ref_ROITotalY <= 5 || m_arrBuildOcvEndY[i] >= objLocalROI.ref_ROIPositionY + objLocalROI.ref_ROIHeight - 5))
            //        {
            //            if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnIsBarPin1.Count <= i)
            //            {
            //                m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnIsBarPin1.Add(true);
            //                m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrBarPin1Type.Add(0);
            //            }
            //            else
            //            {
            //                m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnIsBarPin1[i] = true;
            //                m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrBarPin1Type[i] = 0;
            //            }
            //        }
            //        else if (intBuildOcvHeight < intBuildOcvWidth && (float)intBuildOcvWidth / (float)intBuildOcvHeight > 3 &&
            //            (m_arrBuildOcvStartX[i] - objLocalROI.ref_ROITotalX <= 5 || m_arrBuildOcvEndX[i] >= objLocalROI.ref_ROIPositionX + objLocalROI.ref_ROIWidth - 5))
            //        {
            //            if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnIsBarPin1.Count <= i)
            //            {
            //                m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnIsBarPin1.Add(true);
            //                m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrBarPin1Type.Add(1);
            //            }
            //            else
            //            {
            //                m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnIsBarPin1[i] = true;
            //                m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrBarPin1Type[i] = 1;
            //            }
            //        }
            //        else
            //        {
            //            if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnIsBarPin1.Count <= i)
            //            {
            //                m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnIsBarPin1.Add(false);
            //                m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrBarPin1Type.Add(-1);
            //            }
            //            else
            //            {
            //                m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnIsBarPin1[i] = false;
            //                m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrBarPin1Type[i] = -1;
            //            }
            //        }
            //    }
            //}

            // 2022 01 10 - CCENG: Will relearn the bar pin 1 information even though m_blnWantCheckBarPin1 is false. 
            //              This will easier for customer turn ON this feature and direct inspect without relearn the mark.
            // 2020 02 27 - CCENG: New condition
            //Condition 1, ratio of shorter length to longer length is more than 3:1
            //Condition 2, char size + char tolerance must >= ROI size either width or height.
            //if (m_blnWantCheckBarPin1)
            {
                for (int i = 0; i < intNumChars; i++)
                {
                    int intBuildOcvWidth = m_arrBuildOcvEndX[i] - m_arrBuildOcvStartX[i];
                    int intBuildOcvHeight = m_arrBuildOcvEndY[i] - m_arrBuildOcvStartY[i];
                    if (intBuildOcvWidth < intBuildOcvHeight && (float)intBuildOcvHeight / (float)intBuildOcvWidth > 3)
                    //&& ((intBuildOcvHeight + m_arrBuildOcvCharShiftY[i] * 2) >= objLocalROI.ref_ROIHeight)) //2020-05-28 ZJYEOH : Removed this as user might drag larger Mark ROI
                    //(((m_arrBuildOcvStartY[i] - m_arrBuildOcvCharShiftY[i]) - objLocalROI.ref_ROITotalY) <= 0 || 
                    // (m_arrBuildOcvEndY[i] + m_arrBuildOcvCharShiftY[i])>= (objLocalROI.ref_ROIPositionY + objLocalROI.ref_ROIHeight)))
                    {
                        if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnIsBarPin1.Count <= i)
                        {
                            m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnIsBarPin1.Add(true);
                            m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrBarPin1Type.Add(0);
                        }
                        else
                        {
                            m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnIsBarPin1[i] = true;
                            m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrBarPin1Type[i] = 0;
                        }
                    }
                    else if (intBuildOcvHeight < intBuildOcvWidth && (float)intBuildOcvWidth / (float)intBuildOcvHeight > 3)
                    //&& ((intBuildOcvWidth + m_arrBuildOcvCharShiftX[i] * 2) >= objLocalROI.ref_ROIWidth)) //2020-05-28 ZJYEOH : Removed this as user might drag larger Mark ROI
                    //(((m_arrBuildOcvStartX[i] - m_arrBuildOcvCharShiftX[i]) - objLocalROI.ref_ROITotalX) <= 0 &&
                    // (m_arrBuildOcvEndX[i] + m_arrBuildOcvCharShiftX[i]) >= (objLocalROI.ref_ROIPositionX + objLocalROI.ref_ROIWidth)))
                    {
                        if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnIsBarPin1.Count <= i)
                        {
                            m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnIsBarPin1.Add(true);
                            m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrBarPin1Type.Add(1);
                        }
                        else
                        {
                            m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnIsBarPin1[i] = true;
                            m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrBarPin1Type[i] = 1;
                        }
                    }
                    else
                    {
                        if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnIsBarPin1.Count <= i)
                        {
                            m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnIsBarPin1.Add(false);
                            m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrBarPin1Type.Add(-1);
                        }
                        else
                        {
                            m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnIsBarPin1[i] = false;
                            m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrBarPin1Type[i] = -1;
                        }
                    }
                }
            }
            //else
            //{
            //    // 2020 02 25 - CCENG: Must reset all char's BarPin1 to false if adv setting m_blnWantCheckBarPin1 is false.
            //    for (int i = 0; i < intNumChars; i++)
            //    {
            //        if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnIsBarPin1.Count <= i)
            //        {
            //            m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnIsBarPin1.Add(false);
            //            m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrBarPin1Type.Add(-1);
            //        }
            //        else
            //        {
            //            m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnIsBarPin1[i] = false;
            //            m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrBarPin1Type[i] = -1;
            //        }
            //    }
            //}

            // Set shift text tolerence for OcvText
            if (blnSetShiftTextToleranceToSearchROI)
            {
                // Set Shift Text Tolerance to SearchROI (when WantGauge is false. Without gauge, correct unit position cannot be find, so bigger tolerance is needed.)
                m_objOCV.SetTextsShiftXY(objSearchROI.ref_ROIPositionX, objSearchROI.ref_ROIPositionY,
             objSearchROI.ref_ROIPositionX + objSearchROI.ref_ROIWidth,
             objSearchROI.ref_ROIPositionY + objSearchROI.ref_ROIHeight,
             m_intMarkTextShiftMethod, (int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fTextShiftX), (int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fTextShiftX));
            }
            else
            {   // Set ShiftTextTolerance to MarkROI (when WantGauge is true)
                m_objOCV.SetTextsShiftXY(objSearchROI.ref_ROIPositionX + objLearnROI.ref_ROIPositionX, objSearchROI.ref_ROIPositionY + objLearnROI.ref_ROIPositionY,
             objSearchROI.ref_ROIPositionX + objLearnROI.ref_ROIPositionX + objLearnROI.ref_ROIWidth,
             objSearchROI.ref_ROIPositionY + objLearnROI.ref_ROIPositionY + objLearnROI.ref_ROIHeight,
             m_intMarkTextShiftMethod, (int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fTextShiftX), (int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fTextShiftX));
            }

            // Remove extra ocv object (Happen when not new template is learnt
            if ((m_arrOCV[m_intGroupIndex].Count - 1) > m_intTemplateIndex)
                m_arrOCV[m_intGroupIndex].RemoveAt(m_arrOCV[m_intGroupIndex].Count - 1);

            blnUsePreviousSetting = false; //2020-05-13 ZJYEOH : set to false because already set previous template setting to new template setting during learn step

            // Set shift char tolerance to OcvChar
            if (blnUsePreviousSetting && m_arrOCV.Count != 0)
            {
                // New template
                if (m_arrOCV[m_intGroupIndex][m_intTemplateIndex].GetNumChars() == 0)
                {
                    // Use last template set to current learn template
                    if (m_intTemplateIndex > 0)
                    {
                        /// ??? Need InspectForOCVInformation or not
                        float[] arrXToleranceChars = m_arrOCV[m_intGroupIndex][m_intTemplateIndex - 1].GetCharsShiftX();
                        float[] arrYToleranceChars = m_arrOCV[m_intGroupIndex][m_intTemplateIndex - 1].GetCharsShiftY();

                        if (arrXToleranceChars.Length > 0 && arrYToleranceChars.Length > 0)
                            m_objOCV.SetCharsShiftXY(arrXToleranceChars, arrYToleranceChars, 0, 0);
                    }
                    else //Set value 5 as default to shift XY
                        m_objOCV.SetCharsShiftXY(5 + m_fCharROIOffsetX, 5 + m_fCharROIOffsetX);
                }
                else
                {
                    // Replace previous template
                    //m_arrOCV[m_intGroupIndex][m_intTemplateIndex].InspectForOCVInformation(objLearnROI, m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intThreshold);
                    //int[] arrXToleranceChars = m_arrOCV[m_intGroupIndex][m_intTemplateIndex].GetCharsShiftX();
                    //int[] arrYToleranceChars = m_arrOCV[m_intGroupIndex][m_intTemplateIndex].GetCharsShiftY();
                    //int[] arrXToleranceChars = new int[m_arrBuildOcvCharShiftX.Count];
                    //int[] arrYToleranceChars = new int[m_arrBuildOcvCharShiftY.Count];
                    //for (int i = 0; i < m_arrBuildOcvCharShiftX.Count; i++)
                    //{
                    //    arrXToleranceChars[CharNo[i]] = m_arrBuildOcvCharShiftX[i];
                    //    arrYToleranceChars[CharNo[i]] = m_arrBuildOcvCharShiftY[i];
                    //}

                    float[] arrXToleranceChars = m_arrBuildOcvCharShiftX.ToArray();
                    float[] arrYToleranceChars = m_arrBuildOcvCharShiftY.ToArray();

                    if (arrXToleranceChars.Length > 0 && arrYToleranceChars.Length > 0)
                        m_objOCV.SetCharsShiftXY(arrXToleranceChars, arrYToleranceChars, m_fCharROIOffsetX, m_fCharROIOffsetY);

                    //m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharShiftX.Clear();
                    //m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharShiftY.Clear();
                    //for (int i  = 0; i < arrXToleranceChars.Length; i++)
                    //{
                    //    m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharShiftX.Add(arrXToleranceChars[i]);
                    //    m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharShiftY.Add(arrYToleranceChars[i]);
                    //}
                }
            }
            else
            {
                //m_objOCV.SetCharsShiftXY(5, 5);

                // 2020-05-13 ZJYEOH : save user set value 
                float[] arrXToleranceChars = m_arrBuildOcvCharShiftX.ToArray();
                float[] arrYToleranceChars = m_arrBuildOcvCharShiftY.ToArray();

                if (arrXToleranceChars.Length > 0 && arrYToleranceChars.Length > 0)
                    m_objOCV.SetCharsShiftXY(arrXToleranceChars, arrYToleranceChars, m_fCharROIOffsetX, m_fCharROIOffsetY);
            }
            // Set chars score setting
            int intNewNumChars = m_objOCV.GetNumChars();
            int intPreNumChars = m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting.Count;
            if (intPreNumChars == 0)
            {
                for (int i = intPreNumChars; i < intNewNumChars; i++)
                {
                    m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting.Add(intDefaultMarkScore);
                    //  m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable.Add(true);
                }
            }
            else if (intPreNumChars > intNewNumChars)
            {
                m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting.RemoveRange(intNewNumChars, intPreNumChars - intNewNumChars);

                // 2021 02 28 - CCENG: sett all to default score when no use previous setting
                if (!blnUsePreviousSetting)
                {
                    for (int i = 0; i < intNewNumChars; i++)
                    {
                        m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting[i] = intDefaultMarkScore;
                    }
                }
                //m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable.RemoveRange(intNewNumChars, intPreNumChars - intNewNumChars);
            }
            else if (intPreNumChars < intNewNumChars)
            {
                if (blnUsePreviousSetting)
                {
                    int intLastCharSetting = m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting[intPreNumChars - 1];

                    for (int i = intPreNumChars; i < intNewNumChars; i++)
                    {
                        m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting.Add(intLastCharSetting);
                        // m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable.Add(true);
                    }
                }
                else
                {
                    // 2021 02 28 - CCENG: sett all to default score when no use previous setting
                    for (int i = 0; i < intNewNumChars; i++)
                    {
                        if (i < intPreNumChars)
                        {
                            m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting[i] = intDefaultMarkScore;
                        }
                        else
                        {
                            m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting.Add(intDefaultMarkScore);
                        }
                    }

                }
            }
            else
            {
                //2021-08-03 ZJYEOH : Hide this, should always use back previous setting if same char count
                //// 2021 02 28 - CCENG: sett all to default score when no use previous setting
                //if (!blnUsePreviousSetting)
                //{
                //    for (int i = 0; i < intNewNumChars; i++)
                //    {
                //        m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharSetting[i] = intDefaultMarkScore;
                //    }
                //}
            }
            
            intPreNumChars = m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharDividedLargestArea.Count;
            if (intPreNumChars == 0)
            {
                for (int i = intPreNumChars; i < intNewNumChars; i++)
                {
                    m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharDividedLargestArea.Add(0);
                    //  m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable.Add(true);
                }
            }
            else if (intPreNumChars > intNewNumChars)
            {
                m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharDividedLargestArea.RemoveRange(intNewNumChars, intPreNumChars - intNewNumChars);

                // 2021 02 28 - CCENG: sett all to default score when no use previous setting
                if (!blnUsePreviousSetting)
                {
                    for (int i = 0; i < intNewNumChars; i++)
                    {
                        m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharDividedLargestArea[i] = 0;
                    }
                }
                //m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable.RemoveRange(intNewNumChars, intPreNumChars - intNewNumChars);
            }
            else if (intPreNumChars < intNewNumChars)
            {
                if (blnUsePreviousSetting)
                {
                    int intLastCharSetting = m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharDividedLargestArea[intPreNumChars - 1];

                    for (int i = intPreNumChars; i < intNewNumChars; i++)
                    {
                        m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharDividedLargestArea.Add(intLastCharSetting);
                        // m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable.Add(true);
                    }
                }
                else
                {
                    // 2021 02 28 - CCENG: sett all to default score when no use previous setting
                    for (int i = 0; i < intNewNumChars; i++)
                    {
                        if (i < intPreNumChars)
                        {
                            m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharDividedLargestArea[i] = 0;
                        }
                        else
                        {
                            m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharDividedLargestArea.Add(0);
                        }
                    }

                }
            }
            else
            {
                //2021-08-03 ZJYEOH : Hide this, should always use back previous setting if same char count
                //// 2021 02 28 - CCENG: sett all to default score when no use previous setting
                //if (!blnUsePreviousSetting)
                //{
                //    for (int i = 0; i < intNewNumChars; i++)
                //    {
                //        m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharDividedLargestArea[i] = intDefaultMarkScore;
                //    }
                //}
            }

            intPreNumChars = m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fAverageGray.Count;
            if (intPreNumChars == 0)
            {
                for (int i = intPreNumChars; i < intNewNumChars; i++)
                {
                    m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fAverageGray.Add(0);
                    //  m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable.Add(true);
                }
            }
            else if (intPreNumChars > intNewNumChars)
            {
                m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fAverageGray.RemoveRange(intNewNumChars, intPreNumChars - intNewNumChars);

                // 2021 02 28 - CCENG: sett all to default score when no use previous setting
                if (!blnUsePreviousSetting)
                {
                    for (int i = 0; i < intNewNumChars; i++)
                    {
                        m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fAverageGray[i] = 0;
                    }
                }
                //m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable.RemoveRange(intNewNumChars, intPreNumChars - intNewNumChars);
            }
            else if (intPreNumChars < intNewNumChars)
            {
                if (blnUsePreviousSetting)
                {
                    for (int i = intPreNumChars; i < intNewNumChars; i++)
                    {
                        m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fAverageGray.Add(0);
                        // m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable.Add(true);
                    }
                }
                else
                {
                    // 2021 02 28 - CCENG: sett all to default score when no use previous setting
                    for (int i = 0; i < intNewNumChars; i++)
                    {
                        if (i < intPreNumChars)
                        {
                            m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fAverageGray[i] = 0;
                        }
                        else
                        {
                            m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fAverageGray.Add(0);
                        }
                    }

                }
            }
            else
            {
                //2021-08-03 ZJYEOH : Hide this, should always use back previous setting if same char count
                //// 2021 02 28 - CCENG: sett all to default score when no use previous setting
                //if (!blnUsePreviousSetting)
                //{
                //    for (int i = 0; i < intNewNumChars; i++)
                //    {
                //        m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fAverageGray[i] = intDefaultMarkScore;
                //    }
                //}
            }

            //// ---Mark Grid Data-------------
            //int intPartitionX = 5;
            //int intPartitionY = 3;

            //m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharPartitionArea.Clear();
            //m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharPartitionPercent.Clear();
            //m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharLink_Top.Clear();
            //m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharLink_Right.Clear();
            //m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharLink_Bottom.Clear();
            //m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharLink_Left.Clear();
            //m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMarkGrid.Clear();
            //m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrCharInfo.Clear();
            //for (int i = 0; i < intNewNumChars; i++)
            //{
            //    m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharPartitionArea.Add(new List<List<float>>());
            //    m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharPartitionPercent.Add(new List<List<float>>());
            //    m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharLink_Top.Add(new List<List<int>>());
            //    m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharLink_Right.Add(new List<List<int>>());
            //    m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharLink_Bottom.Add(new List<List<int>>());
            //    m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharLink_Left.Add(new List<List<int>>());
            //    m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMarkGrid.Add(new List<List<MarkGrid>>());

            //    for (int x = 0; x < intPartitionX; x++)
            //    {
            //        m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharPartitionArea[i].Add(new List<float>());
            //        m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharPartitionPercent[i].Add(new List<float>());
            //        m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharLink_Top[i].Add(new List<int>());
            //        m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharLink_Right[i].Add(new List<int>());
            //        m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharLink_Bottom[i].Add(new List<int>());
            //        m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharLink_Left[i].Add(new List<int>());
            //        m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMarkGrid[i].Add(new List<MarkGrid>());
            //        for (int y = 0; y < intPartitionY; y++)
            //        {
            //            m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharPartitionArea[i][x].Add(0);
            //            m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharPartitionPercent[i][x].Add(0);
            //            m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharLink_Top[i][x].Add(0);
            //            m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharLink_Right[i][x].Add(0);
            //            m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharLink_Bottom[i][x].Add(0);
            //            m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharLink_Left[i][x].Add(0);
            //            m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMarkGrid[i][x].Add(MarkGrid.Empty);
            //        }
            //    }
            //}

            ////// ================

            // Set template configuration setting
            m_intTemplateMask |= (0x01 << m_intTemplateIndex);
            if ((m_intTemplatePriority & (0x0F << (0x04 * m_intTemplateIndex))) == 0)
                m_intTemplatePriority |= ((long)(m_intTemplateIndex + 1) << (0x04 * m_intTemplateIndex));

            // Keep template image
            objTemplateImage.CopyTo(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].objTemplateImage);    // 2019 02 12 - CCENG: Use CopyTo to prevent both image object share to same image memory point.
                                                                                                                    //m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].objTemplateImage = objTemplateImage;

            //2021-04-14 ZJYEOH : change InspectForOCVInformation to InspectForOCVInformation_ForLearning, InspectForOCVInformation_ForLearning will set shift tolerance to zero
            if (m_blnWhiteOnBlack)
                m_objOCV.InspectForOCVInformation_ForLearning(objLearnROI, intThresholdValue, m_arrBuildOcvCharShiftX.ToArray(), m_arrBuildOcvCharShiftY.ToArray(), m_fCharROIOffsetX, m_fCharROIOffsetY); //m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intThreshold
            else
                m_objOCV.InspectForOCVInformation_ForLearning(objLocalROI, intThresholdValue, m_arrBuildOcvCharShiftX.ToArray(), m_arrBuildOcvCharShiftY.ToArray(), m_fCharROIOffsetX, m_fCharROIOffsetY);


            m_objOCV.GetBuildOCVPosition(ref arrBuildOcvStartX, ref arrBuildOcvStartY, ref arrBuildOcvEndX, ref arrBuildOcvEndY, ref arrBuildOcvCenterX, ref arrBuildOcvCenterY);

            // 2021 02 28 - CCENG: Delete all OCVTemplate#_#_#.bmp file before save new one.
            string[] strFileList = Directory.GetFiles(strOCVTemplateImagePath, "*.bmp");
            foreach (string strFile in strFileList)
            {
                if (strFile.IndexOf("OCVTemplate0_" + intSelectedTemplate + "_", 0) > 0)
                {
                    File.Delete(strFile);
                }
            }
            
            List<ImageDrawing> arrOCVImage = new List<ImageDrawing>();
            for (int i = 0; i < intNumChars; i++)
            {
                arrOCVImage.Add(new ImageDrawing(true));
            }

            for (int i = 0; i < intNumChars; i++)
            {
                List<int> arrID = m_objOCV.GetCharNo();
                //2021-01-03 ZJYEOH : Save separate image that contain individual blob
                lock (m_objLockLearningBlobs)
                {
                    m_objLearnBlobs[m_intTemplateIndex].SaveLearnIndividualBlobsImage(objLocalROI, arrBuildOcvStartX[i], arrBuildOcvStartY[i], arrBuildOcvEndX[i], arrBuildOcvEndY[i],
                        strOCVTemplateImagePath + "OCVTemplate0_" + intSelectedTemplate + "_" + arrID[i] + ".bmp",
                        m_arrBuildOcvStartXOri, m_arrBuildOcvStartYOri, m_arrBuildOcvEndXOri, m_arrBuildOcvEndYOri);
                }

                //2021-01-03 ZJYEOH : Load Individual Blob Image
                //arrOCVImage.Add(new ImageDrawing(true));
                if (File.Exists(strOCVTemplateImagePath + "OCVTemplate0_" + intSelectedTemplate + "_" + arrID[i] + ".bmp"))
                    arrOCVImage[arrID[i]].LoadImage(strOCVTemplateImagePath + "OCVTemplate0_" + intSelectedTemplate + "_" + arrID[i] + ".bmp");
                else
                {
                    if (File.Exists(strOCVTemplateImagePath + "Template0_" + intSelectedTemplate + ".bmp"))
                        arrOCVImage[arrID[i]].LoadImage(strOCVTemplateImagePath + "Template0_" + intSelectedTemplate + ".bmp");
                }

                ROI objCharROI = new ROI();
                objCharROI.LoadROISetting(arrBuildOcvStartX[i] - objLocalROI.ref_ROITotalX, arrBuildOcvStartY[i] - objLocalROI.ref_ROITotalY, arrBuildOcvEndX[i] - arrBuildOcvStartX[i], arrBuildOcvEndY[i] - arrBuildOcvStartY[i]);
                objCharROI.AttachImage(arrOCVImage[arrID[i]]);
                //objCharROI.SaveImage("D:\\TS\\objCharROI" + i + ".bmp");

                ROI objBlobROI = new ROI();
                int intWidth = objCharROI.ref_ROIWidth / 3;
                int intHeight = objCharROI.ref_ROIHeight / 3;
                EBlobs objEBlob = new EBlobs();
          
                objBlobROI.AttachImage(objCharROI);
                int intArea = 0;
                for (int j = 0; j < 3; j++)
                {
                    for (int k = 0; k < 3; k++)
                    {
                        objBlobROI.LoadROISetting(j * intWidth, k * intHeight, intWidth, intHeight);
                        //objBlobROI.SaveImage("D:\\TS\\objBlobROI" + j + k + ".bmp");
                        objEBlob.BuildObjects_Filter_GetElement(objBlobROI, !m_blnWhiteOnBlack, true, 0, 125, 0, objBlobROI.ref_ROIWidth * objBlobROI.ref_ROIHeight + 1, false, 0x01);
                        if (objEBlob.ref_intNumSelectedObject > 0 && intArea < objEBlob.ref_arrArea[0])
                            intArea = objEBlob.ref_arrArea[0];
                    }
                }

                objEBlob.CleanAllBlobs();

                m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharDividedLargestArea[arrID[i]] = intArea;

                // Collect each character sub partition information
                //intWidth = objCharROI.ref_ROIWidth / 5;
                //intHeight = objCharROI.ref_ROIHeight / 3;
                //int intStartX = 0;
                //int intStartY = 0;
                //int intEndX = 0;
                //int intEndY = 0;

                //objBlobROI.AttachImage(objCharROI);
                //ROI objBlobSubROI = new ROI();
                //for (int j = 0; j < 5; j++)
                //{
                //    for (int k = 0; k < 3; k++)
                //    {
                //        intStartX = (int)Math.Floor((float)objCharROI.ref_ROIWidth / 5 * j);
                //        intStartY = (int)Math.Floor((float)objCharROI.ref_ROIHeight / 3 * k);
                //        if (j < 4)
                //            intEndX = (int)Math.Floor((float)objCharROI.ref_ROIWidth / 5 * (j + 1));
                //        else
                //            intEndX = objCharROI.ref_ROIWidth;
                //        if (k < 2)
                //            intEndY = (int)Math.Floor((float)objCharROI.ref_ROIHeight / 3 * (k + 1));
                //        else
                //            intEndY = objCharROI.ref_ROIHeight;

                //        intWidth = intEndX - intStartX;
                //        intHeight = intEndY - intStartY;
                //        objBlobROI.LoadROISetting(intStartX, intStartY, intWidth, intHeight);
                //        objBlobROI.SaveImage("D:\\TS\\objBlobROI" + j + k + ".bmp");
                //        objEBlob.BuildObjects_Filter_GetElement(objBlobROI, !m_blnWhiteOnBlack, true, 0, 125, 0, objBlobROI.ref_ROIWidth * objBlobROI.ref_ROIHeight + 1, false, 0x01);
                //        if (objEBlob.ref_intNumSelectedObject > 0)
                //        {
                //            m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharPartitionArea[arrID[i]][j][k] = objEBlob.ref_arrArea[0];
                //            m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharPartitionPercent[arrID[i]][j][k] = (float)objEBlob.ref_arrArea[0] / (intWidth * intHeight);

                //        }
                //        else
                //        {
                //            m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharPartitionArea[arrID[i]][j][k] = 0;
                //            m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fCharPartitionPercent[arrID[i]][j][k] = 0;
                //        }

                //        objBlobSubROI.AttachImage(objBlobROI);
                //        int intSubStartX = (int)objBlobROI.ref_ROIWidth / 3;
                //        int intSubStartY = (int)objBlobROI.ref_ROIHeight / 3;
                //        int intSubEndX = (int)objBlobROI.ref_ROIWidth / 3 * 2;
                //        int intSubEndY = (int)objBlobROI.ref_ROIHeight / 3 * 2;

                //        //////////////// Check border edge ////////////////////////////////////////////////
                //        // Check top link
                //        objBlobSubROI.LoadROISetting(intSubStartX, 0, intSubEndX - intSubStartX, intSubStartY);
                //        objBlobSubROI.SaveImage("D:\\TS\\objBlobSubROI_Top_" + j + k + ".bmp");
                //        objEBlob.BuildObjects_Filter_GetElement(objBlobSubROI, !m_blnWhiteOnBlack, true, 0, 125, 0, objBlobSubROI.ref_ROIWidth * objBlobSubROI.ref_ROIHeight + 1, false, 0x0F);
                //        if (objEBlob.ref_intNumSelectedObject > 0)
                //        {
                //            int intObjectStartY = (int)Math.Floor(objEBlob.ref_arrLimitCenterY[0] - objEBlob.ref_arrHeight[0] / 2);
                //            if (intObjectStartY <= 0)
                //                m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharLink_Top[arrID[i]][j][k] |= 0x01;
                //        }

                //        // check right link
                //        objBlobSubROI.LoadROISetting(intSubEndX, intSubStartY, objBlobROI.ref_ROIWidth - intSubEndX, intSubEndY - intSubStartY);
                //        objBlobSubROI.SaveImage("D:\\TS\\objBlobSubROI_Right_" + j + k + ".bmp");
                //        objEBlob.BuildObjects_Filter_GetElement(objBlobSubROI, !m_blnWhiteOnBlack, true, 0, 125, 0, objBlobSubROI.ref_ROIWidth * objBlobSubROI.ref_ROIHeight + 1, false, 0x0F);
                //        if (objEBlob.ref_intNumSelectedObject > 0)
                //        {
                //            int intObjectEndX = (int)Math.Ceiling(objEBlob.ref_arrLimitCenterX[0] + objEBlob.ref_arrWidth[0] / 2);
                //            if (intObjectEndX >= objBlobSubROI.ref_ROIWidth)
                //                m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharLink_Right[arrID[i]][j][k] |= 0x01;
                //        }

                //        // check bottom link
                //        objBlobSubROI.LoadROISetting(intSubStartX, intSubEndY, intSubEndX - intSubStartX, objBlobROI.ref_ROIHeight - intSubEndY);
                //        objBlobSubROI.SaveImage("D:\\TS\\objBlobSubROI_Btm_" + j + k + ".bmp");
                //        objEBlob.BuildObjects_Filter_GetElement(objBlobSubROI, !m_blnWhiteOnBlack, true, 0, 125, 0, objBlobSubROI.ref_ROIWidth * objBlobSubROI.ref_ROIHeight + 1, false, 0x0F);
                //        if (objEBlob.ref_intNumSelectedObject > 0)
                //        {
                //            int intObjectEndY = (int)Math.Ceiling(objEBlob.ref_arrLimitCenterY[0] + objEBlob.ref_arrHeight[0] / 2);
                //            if (intObjectEndY >= objBlobSubROI.ref_ROIHeight)
                //                m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharLink_Bottom[arrID[i]][j][k] |= 0x01;
                //        }

                //        // check Left link
                //        objBlobSubROI.LoadROISetting(0, intSubStartY, intSubStartX, intSubEndY - intSubStartY);
                //        objBlobSubROI.SaveImage("D:\\TS\\objBlobSubROI_Left_" + j + k + ".bmp");
                //        objEBlob.BuildObjects_Filter_GetElement(objBlobSubROI, !m_blnWhiteOnBlack, true, 0, 125, 0, objBlobSubROI.ref_ROIWidth * objBlobSubROI.ref_ROIHeight + 1, false, 0x0F);
                //        if (objEBlob.ref_intNumSelectedObject > 0)
                //        {
                //            int intObjectStartX = (int)Math.Floor(objEBlob.ref_arrLimitCenterX[0] - objEBlob.ref_arrWidth[0] / 2);
                //            if (intObjectStartX <= 0)
                //                m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharLink_Left[arrID[i]][j][k] |= 0x01;
                //        }

                //        //////////////// Check coerner edge ////////////////////////////////////////////////

                //        // Check top Left link
                //        objBlobSubROI.LoadROISetting(0, 0, intSubStartX, intSubStartY);
                //        objBlobSubROI.SaveImage("D:\\TS\\objBlobSubROI_TopLeft_" + j + k + ".bmp");
                //        objEBlob.BuildObjects_Filter_GetElement(objBlobSubROI, !m_blnWhiteOnBlack, true, 0, 125, 0, objBlobSubROI.ref_ROIWidth * objBlobSubROI.ref_ROIHeight + 1, false, 0x0F);
                //        if (objEBlob.ref_intNumSelectedObject > 0)
                //        {
                //            int intObjectStartX = (int)Math.Floor(objEBlob.ref_arrLimitCenterX[0] - objEBlob.ref_arrWidth[0] / 2);
                //            int intObjectStartY = (int)Math.Floor(objEBlob.ref_arrLimitCenterY[0] - objEBlob.ref_arrHeight[0] / 2);
                //            if (intObjectStartX <= 0 && intObjectStartY <= 0)
                //                m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharLink_Top[arrID[i]][j][k] |= 0x10;
                //        }

                //        // Check top Right link
                //        objBlobSubROI.LoadROISetting(intSubEndX, 0, objBlobROI.ref_ROIWidth - intSubEndX, intSubStartY);
                //        objBlobSubROI.SaveImage("D:\\TS\\objBlobSubROI_TopRight_" + j + k + ".bmp");
                //        objEBlob.BuildObjects_Filter_GetElement(objBlobSubROI, !m_blnWhiteOnBlack, true, 0, 125, 0, objBlobSubROI.ref_ROIWidth * objBlobSubROI.ref_ROIHeight + 1, false, 0x0F);
                //        if (objEBlob.ref_intNumSelectedObject > 0)
                //        {
                //            int intObjectEndX = (int)Math.Ceiling(objEBlob.ref_arrLimitCenterX[0] + objEBlob.ref_arrWidth[0] / 2);
                //            int intObjectStartY = (int)Math.Floor(objEBlob.ref_arrLimitCenterY[0] - objEBlob.ref_arrHeight[0] / 2);
                //            if (intObjectEndX >= objBlobSubROI.ref_ROIWidth && intObjectStartY <= 0)
                //                m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharLink_Right[arrID[i]][j][k] |= 0x10;
                //        }

                //        // Check bottom Right link
                //        objBlobSubROI.LoadROISetting(intSubEndX, intSubEndY, objBlobROI.ref_ROIWidth - intSubEndX, objBlobROI.ref_ROIHeight - intSubEndY);
                //        objBlobSubROI.SaveImage("D:\\TS\\objBlobSubROI_BtmRight_" + j + k + ".bmp");
                //        objEBlob.BuildObjects_Filter_GetElement(objBlobSubROI, !m_blnWhiteOnBlack, true, 0, 125, 0, objBlobSubROI.ref_ROIWidth * objBlobSubROI.ref_ROIHeight + 1, false, 0x0F);
                //        if (objEBlob.ref_intNumSelectedObject > 0)
                //        {
                //            int intObjectEndX = (int)Math.Ceiling(objEBlob.ref_arrLimitCenterX[0] + objEBlob.ref_arrWidth[0] / 2);
                //            int intObjectEndY = (int)Math.Ceiling(objEBlob.ref_arrLimitCenterY[0] + objEBlob.ref_arrHeight[0] / 2);
                //            if (intObjectEndX >= objBlobSubROI.ref_ROIWidth && intObjectEndY >= objBlobSubROI.ref_ROIHeight)
                //                m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharLink_Bottom[arrID[i]][j][k] |= 0x10;
                //        }

                //        // Check bottom Left link
                //        objBlobSubROI.LoadROISetting(0, intSubEndY, intSubStartX, objBlobROI.ref_ROIHeight - intSubEndY);
                //        objBlobSubROI.SaveImage("D:\\TS\\objBlobSubROI_BtmLeft_" + j + k + ".bmp");
                //        objEBlob.BuildObjects_Filter_GetElement(objBlobSubROI, !m_blnWhiteOnBlack, true, 0, 125, 0, objBlobSubROI.ref_ROIWidth * objBlobSubROI.ref_ROIHeight + 1, false, 0x0F);
                //        if (objEBlob.ref_intNumSelectedObject > 0)
                //        {
                //            int intObjectStartX = (int)Math.Floor(objEBlob.ref_arrLimitCenterX[0] - objEBlob.ref_arrWidth[0] / 2);
                //            int intObjectEndY = (int)Math.Ceiling(objEBlob.ref_arrLimitCenterY[0] + objEBlob.ref_arrHeight[0] / 2);
                //            if (intObjectStartX <= 0 && intObjectEndY >= objBlobSubROI.ref_ROIHeight)
                //                m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharLink_Left[arrID[i]][j][k] |= 0x10;
                //        }

                //        //////////////// Check center ////////////////////////////////////////////////

                //        // Check center
                //        objBlobSubROI.LoadROISetting(intSubStartX, intSubStartY, intSubEndX - intSubStartX, intSubEndY - intSubStartY);
                //        objBlobSubROI.SaveImage("D:\\TS\\objBlobSubROI_Top_" + j + k + ".bmp");
                //        objEBlob.BuildObjects_Filter_GetElement(objBlobSubROI, !m_blnWhiteOnBlack, true, 0, 125, 0, objBlobSubROI.ref_ROIWidth * objBlobSubROI.ref_ROIHeight + 1, false, 0x0F);
                //        if (objEBlob.ref_intNumSelectedObject > 0)
                //        {
                //            int intObjectStartX = (int)Math.Floor(objEBlob.ref_arrLimitCenterX[0] - objEBlob.ref_arrWidth[0] / 2);
                //            int intObjectStartY = (int)Math.Floor(objEBlob.ref_arrLimitCenterY[0] - objEBlob.ref_arrHeight[0] / 2);
                //            int intObjectEndX = (int)Math.Ceiling(objEBlob.ref_arrLimitCenterX[0] + objEBlob.ref_arrWidth[0] / 2);
                //            int intObjectEndY = (int)Math.Ceiling(objEBlob.ref_arrLimitCenterY[0] + objEBlob.ref_arrHeight[0] / 2);
                //            if (intObjectStartX <= 0 && intObjectStartY <= 0 && intObjectEndX >= objBlobSubROI.ref_ROIWidth && intObjectEndY >= objBlobSubROI.ref_ROIHeight)
                //            {
                //                m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharLink_Top[arrID[i]][j][k] |= 0x100;
                //                m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharLink_Right[arrID[i]][j][k] |= 0x100;
                //                m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharLink_Bottom[arrID[i]][j][k] |= 0x100;
                //                m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharLink_Left[arrID[i]][j][k] |= 0x100;
                //            }
                //        }

                //        STTrackLog.WriteLine("Char" + arrID[i] + "_" + j.ToString() + "_" + k.ToString() + "=" +
                //                             m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharLink_Top[arrID[i]][j][k].ToString() + "," +
                //                             m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharLink_Right[arrID[i]][j][k].ToString() + "," +
                //                             m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharLink_Bottom[arrID[i]][j][k].ToString() + "," +
                //                             m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intCharLink_Left[arrID[i]][j][k].ToString());
                //    }
                //}

                //AnalysisMarkGrid(m_intGroupIndex, m_intTemplateIndex, i);

                //////////////////////////////////////////////////////////////////

                objCharROI.AttachImage(objLocalROI);
                //objCharROI.SaveImage("D:\\TS\\objCharROI_Learn" + arrID[i] + ".bmp");
                if (objEBlob.BuildObjects_Filter_GetElement(objCharROI, !m_blnWhiteOnBlack, false, 0, intThresholdValue, 0, objCharROI.ref_ROIWidth * objCharROI.ref_ROIHeight + 1, false, 0x800) > 0)
                {
                    m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fAverageGray[arrID[i]] = (float)Math.Round(objEBlob.ref_arrAverageGray[0], 2);
                }
                else
                    m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fAverageGray[arrID[i]] = 0;

                objEBlob.CleanAllBlobs();

                //ImageDrawing objThresholdImage = new ImageDrawing(true, objCharROI.ref_ROIWidth, objCharROI.ref_ROIHeight);
                //ROI objThresholdROI = new ROI();
                //objThresholdROI.AttachImage(objThresholdImage);
                //objThresholdROI.LoadROISetting(0, 0, objCharROI.ref_ROIWidth, objCharROI.ref_ROIHeight);
                //float fAverageGrayValue = 0;
                //EasyImage.PixelAverage(objCharROI.ref_ROI, out fAverageGrayValue);
                //EasyImage.Threshold(objCharROI.ref_ROI, objThresholdROI.ref_ROI, (uint)Math.Round(fAverageGrayValue));
                ////objThresholdROI.SaveImage("D:\\TS\\objThresholdROI_Learn" + arrID[i] + ".bmp");
                //EasyImage.PixelAverage(objCharROI.ref_ROI, objThresholdROI.ref_ROI, out fAverageGrayValue);
                //m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fAverageGray[arrID[i]] = (float)Math.Round(fAverageGrayValue, 2);
                //objThresholdImage.Dispose();
                //objThresholdROI.Dispose();

                objEBlob.Dispose();
                objEBlob = null;
                
                objBlobROI.Dispose();
                objCharROI.Dispose();

            }
            
            //int intNumTexts = m_objOCV.GetNumTexts();
            //m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrTemplateTextROI.Clear();
            //int intTextStartX = 0, intTextStartY = 0, intTextWidth = 0, intTextHeight = 0;
            //for (int tx = 0; tx < intNumTexts; tx++)
            //{
            //    m_objOCV.GetOCVTextStartXY(tx, ref intTextStartX, ref intTextStartY);
            //    m_objOCV.GetOCVTextSize(tx, ref intTextWidth, ref intTextHeight);
            //    ROI objTextROI = new ROI();
            //    objTextROI.AttachImage(objTemplateImage);
            //    objTextROI.LoadROISetting(intTextStartX, intTextStartY, intTextWidth, intTextHeight);
            //    m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrTemplateTextROI.Add(objTextROI);
            //}

            // 2020 05 21 - CCENG: Dispose ROI object before clear.
            for (int i = 0; i < m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrTemplateTextROI.Count; i++)
            {
                m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrTemplateTextROI[i].Dispose();
                m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrTemplateTextROI[i] = null;
            }

            m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrTemplateTextROI.Clear();
            for (int tx = 0; tx < intNumChars; tx++)
            {
                System.Drawing.Point pStart = m_objOCV.GetTemplateCharStartXY(tx);
                System.Drawing.Point pEnd = m_objOCV.GetTemplateCharEndXY(tx);
                ROI objTextROI = new ROI();
                objTextROI.AttachImage(objTemplateImage);

                objTextROI.LoadROISetting(pStart.X, pStart.Y, pEnd.X - pStart.X, pEnd.Y - pStart.Y);
                m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrTemplateTextROI.Add(objTextROI);
            }

            // 2020 12 04 - Should send objMarkIamge for second parameter. objMarkImage is image with size same as Mark ROI size.
            ImageDrawing objMarkImage = new ImageDrawing(true);
            objLearnROI.CopyToImage(ref objMarkImage);

            ROI objMarkROI = new ROI();
            objMarkROI.LoadROISetting(0, 0, objMarkImage.ref_intImageWidth, objMarkImage.ref_intImageHeight);
            objMarkROI.AttachImage(objMarkImage);

            //SetErodeDilateSettings(objTemplateImage, m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex], m_objOCV, objLearnROI);
            //SetErodeDilateSettings(objTemplateImage, objTemplateImage, objOCVTemplateImage, m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex], m_objOCV, objLearnROI);
            SetErodeDilateSettings(objTemplateImage, objMarkImage, arrOCVImage, m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex], m_objOCV, objMarkROI);

            // ------------ Get offset between text and char ----------------------------------------------
            int[] arrCharsCenterX = m_objOCV.GetCharsCenterX();
            int[] arrCharsCenterY = m_objOCV.GetCharsCenterY();
            m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intTextCharOffsetX.Clear();
            m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intTextCharOffsetY.Clear();
            for (int i = 0; i < arrCharsCenterX.Length; i++)
            {
                m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intTextCharOffsetX.Add(arrCharsCenterX[i]);
                m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intTextCharOffsetY.Add(arrCharsCenterY[i]);
            }
            // ----------------

            m_arrOCV[m_intGroupIndex][m_intTemplateIndex] = m_objOCV;
            for (int i = 0; i < arrOCVImage.Count; i++)
                arrOCVImage[i].Dispose();
            objLocalROI.Dispose();
            objTopParentROI.Dispose();
            //objImage.Dispose();
            objMarkROI.Dispose();
            objMarkImage.Dispose();
        }

        private void SetErodeDilateSettings(ImageDrawing objOriTemplateImage, ImageDrawing objTemplateImage, List<ImageDrawing> arrOCVTemplateImage, TemplateSetting templateSetting, NOCV objOCV, ROI objLearnROI)
        {
            if (objTemplateImage.ref_intImageWidth == 0 || objTemplateImage.ref_intImageHeight == 0)
                return;
            //objOriTemplateImage.SaveImage("D:\\objOriTemplateImage.bmp");
            //objTemplateImage.SaveImage("D:\\objTemplateImage.bmp");
            //objLearnROI.SaveImage("D:\\objLearnROI.bmp");

            // Set Erode and Dilate image same as template image
            /*     if (templateSetting.objLearnErodeImage == null)
                     templateSetting.objLearnErodeImage = new ImageDrawing();

                 if (templateSetting.objLearnDilateImage == null)
                     templateSetting.objLearnDilateImage = new ImageDrawing();

                 ImageDrawing imgErode = templateSetting.objLearnErodeImage;
                 ImageDrawing imgDilate = templateSetting.objLearnDilateImage;
                 objTemplateImage.CopyTo(ref imgErode);
                 objOCVTemplateImage.CopyTo(ref imgDilate);*/

            //objTemplateImage.SaveImage("D:\\TS\\1.objTemplateImage.bmp");
            //objOCVTemplateImage.SaveImage("D:\\TS\\2.objOCVTemplateImage.bmp");
            //imgErode.SaveImage("D:\\TS\\3.imgeErodde.bmp");
            //imgDilate.SaveImage("D:\\TS\\4.imageDilate.bmp");
            // Attach template ROI to Erode image first
            bool blnDebugImage = false;
            ROI objTemplateROI = new ROI();
            objTemplateROI.LoadROISetting(objLearnROI.ref_ROI.TotalOrgX, objLearnROI.ref_ROI.TotalOrgY, objLearnROI.ref_ROIWidth, objLearnROI.ref_ROIHeight);
            objTemplateROI.AttachImage(objTemplateImage);

            //objTemplateROI.SaveImage("D:\\TS\\5.objTemplateROI.bmp");

            //2020-06-01 ZJYEOH : threshold value will depend on inspection method
            int intThresholdValue = templateSetting.intThreshold;
            if (m_blnWantUseGrayValue)
                intThresholdValue = GetGrayValueThreshold(objTemplateROI, m_intMarkInspectionAreaGrayValueSensitivity, m_intMarkBrightSensitivity);

            float[] arrXToleranceChars = templateSetting.fCharShiftX.ToArray();
            float[] arrYToleranceChars = templateSetting.fCharShiftY.ToArray();


            // OCV inspect on Erode image to get ocv inspection information
            objOCV.InspectForOCVInformation(objTemplateROI, intThresholdValue, arrXToleranceChars, arrYToleranceChars, m_fCharROIOffsetX, m_fCharROIOffsetY);

            // 2020 12 04 - CCENG: make sure tempate char ROI is empty before add new
            if (templateSetting.arrTemplateCharErodeROI != null)
            {
                for (int i = 0; i < templateSetting.arrTemplateCharErodeROI.Count; i++)
                {
                    templateSetting.arrTemplateCharErodeROI[i].Dispose();
                }
            }

            if (templateSetting.arrTemplateCharDilateROI != null)
            {
                for (int i = 0; i < templateSetting.arrTemplateCharDilateROI.Count; i++)
                {
                    templateSetting.arrTemplateCharDilateROI[i].Dispose();
                }
            }
            templateSetting.arrTemplateCharErodeROI.Clear();
            templateSetting.arrTemplateCharDilateROI.Clear();

            // Loop each ocv chars
            for (int ch = 0; ch < objOCV.GetNumChars(); ch++)
            {
                if (templateSetting.arrLearnDilateImage.Count <= ch)
                    templateSetting.arrLearnDilateImage.Add(new ImageDrawing(true));

                if (templateSetting.arrLearnDilateImage[ch] == null)
                    templateSetting.arrLearnDilateImage[ch] = new ImageDrawing(true);
                ImageDrawing imgDilate = templateSetting.arrLearnDilateImage[ch];
                if (arrOCVTemplateImage.Count > ch) //2021-11-30 ZJYEOH: Happen in TRS where arrOCVTemplateImage.Count is 0 but objOCV.GetNumChars() > 0
                    arrOCVTemplateImage[ch].CopyTo(ref imgDilate);

                if (templateSetting.arrLearnErodeImage.Count <= ch)
                    templateSetting.arrLearnErodeImage.Add(new ImageDrawing(true));

                if (templateSetting.arrLearnErodeImage[ch] == null)
                    templateSetting.arrLearnErodeImage[ch] = new ImageDrawing(true);
                ImageDrawing imgErode = templateSetting.arrLearnErodeImage[ch];
                if (arrOCVTemplateImage.Count > ch) //2021-11-30 ZJYEOH: Happen in TRS where arrOCVTemplateImage.Count is 0 but objOCV.GetNumChars() > 0
                    arrOCVTemplateImage[ch].CopyTo(ref imgErode);

                // Get char start point and end point
                System.Drawing.Point pStart = objOCV.GetTemplateCharStartXY(ch);
                System.Drawing.Point pEnd = objOCV.GetTemplateCharEndXY(ch);

                // Create char roi for Erode image and Dilate image
                ROI objErodeROI = new ROI();
                ROI objDilateROI = new ROI();

                int intAddX = 0, intAddY = 0;
                // Set char roi placement
                if ((pStart.X - 3) >= 0)
                {
                    objTemplateROI.ref_ROIPositionX = pStart.X - 3;
                    objErodeROI.ref_ROIPositionX = pStart.X - 3;
                    objDilateROI.ref_ROIPositionX = pStart.X - 3;
                    intAddX = 3;
                }
                else
                {
                    objTemplateROI.ref_ROIPositionX = 0;
                    objErodeROI.ref_ROIPositionX = 0;
                    objDilateROI.ref_ROIPositionX = 0;
                    intAddX = pStart.X;
                }

                if ((pStart.Y - 3) >= 0)
                {
                    objTemplateROI.ref_ROIPositionY = pStart.Y - 3;
                    objErodeROI.ref_ROIPositionY = pStart.Y - 3;
                    objDilateROI.ref_ROIPositionY = pStart.Y - 3;
                    intAddY = 3;
                }
                else
                {
                    objTemplateROI.ref_ROIPositionY = 0;
                    objErodeROI.ref_ROIPositionY = 0;
                    objDilateROI.ref_ROIPositionY = 0;
                    intAddY = pStart.Y;
                }

                //if ((pEnd.X + intAddX) < 640)
                if ((pEnd.X + intAddX) < objOriTemplateImage.ref_intImageWidth)
                {
                    objTemplateROI.ref_ROIWidth = pEnd.X - pStart.X + intAddX * 2;
                    objErodeROI.ref_ROIWidth = pEnd.X - pStart.X + intAddX * 2;
                    objDilateROI.ref_ROIWidth = pEnd.X - pStart.X + intAddX * 2;
                }
                else
                {
                    //int intMinAddSize = 639 - pEnd.X;
                    int intMinAddSize = objOriTemplateImage.ref_intImageWidth - 1 - pEnd.X;
                    objTemplateROI.ref_ROIPositionX = pStart.X + intAddX - intMinAddSize;
                    objErodeROI.ref_ROIPositionX = pStart.X + intAddX - intMinAddSize;
                    objDilateROI.ref_ROIPositionX = pStart.X + intAddX - intMinAddSize;
                    objTemplateROI.ref_ROIWidth = pEnd.X - pStart.X + intMinAddSize * 2;
                    objErodeROI.ref_ROIWidth = pEnd.X - pStart.X + intMinAddSize * 2;
                    objDilateROI.ref_ROIWidth = pEnd.X - pStart.X + intMinAddSize * 2;

                }

                if ((pEnd.Y + intAddY) < objOriTemplateImage.ref_intImageHeight)
                {
                    objTemplateROI.ref_ROIHeight = pEnd.Y - pStart.Y + intAddY * 2;
                    objErodeROI.ref_ROIHeight = pEnd.Y - pStart.Y + intAddY * 2;
                    objDilateROI.ref_ROIHeight = pEnd.Y - pStart.Y + intAddY * 2;
                }
                else
                {
                    int intMinAddSize = objOriTemplateImage.ref_intImageHeight - 1 - pEnd.Y;
                    objTemplateROI.ref_ROIPositionY = pStart.Y + intAddY - intMinAddSize;
                    objErodeROI.ref_ROIPositionY = pStart.Y + intAddY - intMinAddSize;
                    objDilateROI.ref_ROIPositionY = pStart.Y + intAddY - intMinAddSize;
                    objTemplateROI.ref_ROIHeight = pEnd.Y - pStart.Y + intMinAddSize * 2;
                    objErodeROI.ref_ROIHeight = pEnd.Y - pStart.Y + intMinAddSize * 2;
                    objDilateROI.ref_ROIHeight = pEnd.Y - pStart.Y + intMinAddSize * 2;
                }

                // why still need to load?
                objTemplateROI.LoadROISetting(objTemplateROI.ref_ROIPositionX, objTemplateROI.ref_ROIPositionY, objTemplateROI.ref_ROIWidth, objTemplateROI.ref_ROIHeight);
                objErodeROI.LoadROISetting(objErodeROI.ref_ROIPositionX, objErodeROI.ref_ROIPositionY, objErodeROI.ref_ROIWidth, objErodeROI.ref_ROIHeight);
                objDilateROI.LoadROISetting(objDilateROI.ref_ROIPositionX, objDilateROI.ref_ROIPositionY, objDilateROI.ref_ROIWidth, objDilateROI.ref_ROIHeight);

                // Attach char roi to image
                objErodeROI.AttachImage(imgErode);
                // 2020 08 30 - CCENG: Fix to use "thick on sample mark" bcos more stable and applicable for thin and thick mark.
                //if (m_intMissingMarkInspectionMethod == 0) // 2020 03 01 - CCENG: Missing Mark Inspection Method. 0 = Thin on template mark.
                // EasyImage.ErodeBox(objErodeROI.ref_ROI, objErodeROI.ref_ROI, m_intCharErodeHalfWidth);
                objDilateROI.AttachImage(imgDilate);
#if (Debug_2_12 || Release_2_12)
                if (blnDebugImage)
                {
                    objErodeROI.SaveImage("D:\\TS\\1.objErodeROI_" + ch.ToString() + ".bmp");
                    objDilateROI.SaveImage("D:\\TS\\1.objDilateROI_" + ch.ToString() + ".bmp");
                }
                EasyImage.DilateBox(objDilateROI.ref_ROI, objDilateROI.ref_ROI, (uint)m_intCharDilateHalfWidth);
                if (blnDebugImage)
                {
                    objErodeROI.SaveImage("D:\\TS\\2.objErodeROI_" + ch.ToString() + ".bmp");
                    objDilateROI.SaveImage("D:\\TS\\2.objDilateROI_" + ch.ToString() + ".bmp");
                }
                //2020-11-19 ZJYEOH : Added below three lines for new mark template dilate function
                ROI.InvertOperationROI(objDilateROI);
                ROI.InvertOperationROI(objErodeROI);
                if (blnDebugImage)
                {
                    objErodeROI.SaveImage("D:\\TS\\3.objErodeROI_" + ch.ToString() + ".bmp");
                    objDilateROI.SaveImage("D:\\TS\\3.objDilateROI_" + ch.ToString() + ".bmp");
                }
                if (m_blnWhiteOnBlack)
                {
                    ROI.SubtractROI2(objTemplateROI, objDilateROI);
                    ROI.SubtractROI2(objTemplateROI, objErodeROI);
                }
                else
                {
                    ROI.LogicOperationAddROI2(objTemplateROI, objDilateROI);
                    ROI.LogicOperationAddROI2(objTemplateROI, objErodeROI);
                }
                if (blnDebugImage)
                {
                    objErodeROI.SaveImage("D:\\TS\\4.objErodeROI_" + ch.ToString() + ".bmp");
                    objDilateROI.SaveImage("D:\\TS\\4.objDilateROI_" + ch.ToString() + ".bmp");
                }
                if (m_blnWhiteOnBlack)
                    EasyImage.DilateBox(objDilateROI.ref_ROI, objDilateROI.ref_ROI, (uint)m_intCharDilateHalfWidth);
                else
                    EasyImage.ErodeBox(objDilateROI.ref_ROI, objDilateROI.ref_ROI, (uint)m_intCharDilateHalfWidth);//2021-08-09 ZJYEOH : Need to use erode if black on white
                if (blnDebugImage)
                {
                    objErodeROI.SaveImage("D:\\TS\\5.objErodeROI_" + ch.ToString() + ".bmp");
                    objDilateROI.SaveImage("D:\\TS\\5.objDilateROI_" + ch.ToString() + ".bmp");
                }
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                EasyImage.DilateBox(objDilateROI.ref_ROI, objDilateROI.ref_ROI, m_intCharDilateHalfWidth);
                //2020-11-19 ZJYEOH : Added below three lines for new mark template dilate function
                ROI.InvertOperationROI(objDilateROI);
                ROI.InvertOperationROI(objErodeROI);
               if (m_blnWhiteOnBlack)
                {
                    ROI.SubtractROI2(objTemplateROI, objDilateROI);
                    ROI.SubtractROI2(objTemplateROI, objErodeROI);
                }
                else
                {
                    ROI.LogicOperationAddROI2(objTemplateROI, objDilateROI);
                    ROI.LogicOperationAddROI2(objTemplateROI, objErodeROI);
                }
                if(m_blnWhiteOnBlack)
                    EasyImage.DilateBox(objDilateROI.ref_ROI, objDilateROI.ref_ROI, m_intCharDilateHalfWidth);
                else
                    EasyImage.ErodeBox(objDilateROI.ref_ROI, objDilateROI.ref_ROI, m_intCharDilateHalfWidth); //2021-08-09 ZJYEOH : Need to use erode if black on white
#endif

                templateSetting.arrTemplateCharErodeROI.Add(objErodeROI);
                templateSetting.arrTemplateCharDilateROI.Add(objDilateROI);
                if (blnDebugImage)
                {
                    templateSetting.arrTemplateCharErodeROI[ch].SaveImage("D:\\TS\\6.arrTemplateCharErodeROI_" + ch.ToString() + ".bmp");
                    templateSetting.arrTemplateCharDilateROI[ch].SaveImage("D:\\TS\\6.arrTemplateCharDilateROI_" + ch.ToString() + ".bmp");
                    objTemplateROI.SaveImage("D:\\TS\\7.objTemplateROI_" + ch.ToString() + ".bmp");
                    if (arrOCVTemplateImage.Count > ch) //2021-11-30 ZJYEOH: Happen in TRS where arrOCVTemplateImage.Count is 0 but objOCV.GetNumChars() > 0
                        arrOCVTemplateImage[ch].SaveImage("D:\\TS\\8.arrOCVTemplateImage_" + ch.ToString() + ".bmp");
                }
                templateSetting.arrLearnDilateImage[ch] = imgDilate;
                templateSetting.arrLearnErodeImage[ch] = imgErode;
            }

            // templateSetting.objLearnErodeImage = imgErode;
            // templateSetting.objLearnDilateImage = imgDilate;

            //templateSetting.objLearnErodeImage.SaveImage("D:\\TS\\objLearnErodeImage.bmp");
            //templateSetting.objLearnDilateImage.SaveImage("D:\\TS\\objLearnDilateImage.bmp");
        }

        public void UndoTemplateChars()
        {
            m_objOCV.DeleteTemplateChars();
        }

        public void UndoTemplateTexts()
        {
            m_objOCV.DeleteTemplateTexts();
        }

        public void FormMultiSelectedChars()
        {
            m_objOCV.FormMultiSelectedChars();
        }

        public void FormSingleSelectedChars()
        {
            m_objOCV.FormSingleSelectedChars();
        }

        public void FormSelectedTexts()
        {
            m_objOCV.BuildTexts();
        }

        public void SelectTemplateChars(ROI objROI, bool blnResetPreviousChars, System.Drawing.Point pStartPoint, System.Drawing.Point pEndPoint)
        {
            if (blnResetPreviousChars)
                m_objOCV.ResetPreviousSelectedChars();

            m_objOCV.SetTemplateImage(objROI);

            m_objOCV.SelectTemplateChars(pStartPoint, pEndPoint);
        }

        public void SelectTemplateChars(ROI objROI, int intOriX, int intOriY, int intWidth, int intHeight, bool blnResetPreviousChars, System.Drawing.Point pStartPoint, System.Drawing.Point pEndPoint)
        {
            if (blnResetPreviousChars)
                m_objOCV.ResetPreviousSelectedChars();

            //m_objOCV.SetTemplateImage(objROI, intOriX, intOriY, intWidth, intHeight);

            m_objOCV.SelectTemplateChars(pStartPoint, pEndPoint);
        }

        public void SelectTextAndChar(int intX, int intY)
        {
            m_intHitCharIndex = m_arrOCV[m_intGroupIndex][m_intTemplateIndex].HitChar(intX, intY);
            m_intHitTextIndex = m_arrOCV[m_intGroupIndex][m_intTemplateIndex].HitText(intX, intY);
        }
        public void SelectBuildOcvCharForAction(System.Drawing.Point p1, System.Drawing.Point p2, int intROIX, int intROIY, bool ClearAllBeforeSelect, bool blnMouseLeft, bool bln_drag, ref int intSelectedType)
        {
            bool blnClearAllBeforeSelect = ClearAllBeforeSelect;
            if (blnClearAllBeforeSelect)
            {
                for (int i = 0; i < m_arrBuildOcvSelectStatus.Count; i++)
                {
                    m_arrBuildOcvSelectStatus[i] = m_arrBuildOcvSelectStatusPrev[i];
                }
            }


            int intOrgX, intOrgY, intWidth, intHeight;

            if (p1.X < p2.X)
            {
                intOrgX = p1.X;
                intWidth = p2.X - p1.X;
            }
            else
            {
                intOrgX = p2.X;
                intWidth = p1.X - p2.X;
            }
            if (p1.Y < p2.Y)
            {
                intOrgY = p1.Y;
                intHeight = p2.Y - p1.Y;
            }
            else
            {
                intOrgY = p2.Y;
                intHeight = p1.Y - p2.Y;
            }

            intOrgX -= intROIX;
            intOrgY -= intROIY;

            // new method
            p1 = new System.Drawing.Point(p1.X - intROIX, p1.Y - intROIY);
            p2 = new System.Drawing.Point(p2.X - intROIX, p2.Y - intROIY);

            int PointX = 0;
            int PointX2 = 0;
            int PointY = 0;
            int PointY2 = 0;

            if (bln_drag) //cxlim 2020/12/11 : added so can drag from below
            {
                PointX = Math.Min(p1.X, p2.X);
                PointX2 = Math.Max(p1.X, p2.X);
                PointY = Math.Min(p1.Y, p2.Y);
                PointY2 = Math.Max(p1.Y, p2.Y);
            }
            else // if click
            {
                PointX = p1.X;
                PointX2 = p2.X;
                PointY = p1.Y;
                PointY2 = p2.Y;
            }

            List<int> arrSelectedIndex = new List<int>();
            for (int i = 0; i < m_arrBuildOcvSelectStatus.Count; i++)
            {
                bool blnFound = false;
                for (int x = PointX; x <= PointX2; x++)
                {
                    for (int y = PointY; y <= PointY2; y++)
                    {
                        //if ((x >= m_arrBuildOcvStartX[i]) &&
                        //       (x <= m_arrBuildOcvEndX[i]) &&
                        //       (y >= m_arrBuildOcvStartY[i]) &&
                        //       (y <= m_arrBuildOcvEndY[i]))
                        if ((x >= m_arrBuildOcvStartX[i] - ((int)Math.Round(m_arrBuildOcvCharShiftX[i] + m_fCharROIOffsetX))) &&
                              (x <= m_arrBuildOcvEndX[i] + ((int)Math.Round(m_arrBuildOcvCharShiftX[i] + m_fCharROIOffsetX))) &&
                              (y >= m_arrBuildOcvStartY[i] - ((int)Math.Round(m_arrBuildOcvCharShiftY[i] + m_fCharROIOffsetY))) &&
                              (y <= m_arrBuildOcvEndY[i] + ((int)Math.Round(m_arrBuildOcvCharShiftY[i] + m_fCharROIOffsetY))))
                        {
                            if (blnMouseLeft)
                            {
                                if (m_arrBuildOcvSelectStatus[i] == 1)
                                {
                                    intSelectedType = m_arrBuildOcvType[i];
                                    m_arrBuildOcvSelectStatus[i] = 2;
                                    //m_arrBuildOcvSelectStatusPrev[i] = 2;
                                }
                                else if (m_arrBuildOcvSelectStatus[i] == 2 && m_arrBuildOcvSelectStatusPrev[i] != 0)
                                {
                                    intSelectedType = m_arrBuildOcvType[i];
                                    m_arrBuildOcvSelectStatus[i] = 1;
                                    //m_arrBuildOcvSelectStatusPrev[i] = 1;
                                }
                                else if (m_arrBuildOcvSelectStatus[i] == 0 && m_arrBuildOcvSelectStatusPrev[i] == 0)
                                {
                                    intSelectedType = m_arrBuildOcvType[i];
                                    m_arrBuildOcvSelectStatus[i] = 2;
                                    //m_arrBuildOcvSelectStatusPrev[i] = 1;
                                }
                                else if (m_arrBuildOcvSelectStatus[i] == 2 && m_arrBuildOcvSelectStatusPrev[i] == 0)
                                {
                                    intSelectedType = m_arrBuildOcvType[i];
                                    m_arrBuildOcvSelectStatus[i] = 0;
                                    //m_arrBuildOcvSelectStatusPrev[i] = 1;
                                }
                                else
                                {
                                    intSelectedType = m_arrBuildOcvType[i];
                                }

                            }
                            else // Right click
                            {
                                if (m_arrBuildOcvSelectStatus[i] == 1)
                                {
                                    intSelectedType = m_arrBuildOcvType[i];
                                    m_arrBuildOcvSelectStatus[i] = 2;
                                    //m_arrBuildOcvSelectStatusPrev[i] = 2;
                                }
                                else if (m_arrBuildOcvSelectStatus[i] == 0 && m_arrBuildOcvSelectStatusPrev[i] == 0)
                                {
                                    intSelectedType = m_arrBuildOcvType[i];
                                    m_arrBuildOcvSelectStatus[i] = 2;
                                    //m_arrBuildOcvSelectStatusPrev[i] = 1;
                                }
                                else
                                {
                                    intSelectedType = m_arrBuildOcvType[i];
                                }
                            }
                            blnFound = true;
                            break;
                        }
                    }

                    if (blnFound)
                        break;
                }

                if (blnFound)
                    arrSelectedIndex.Add(i);
            }

            for (int i = 0; i < arrSelectedIndex.Count; i++)
            {
                bool blnOverlap = false;
                bool blnSmall = false;
                for (int j = 0; j < arrSelectedIndex.Count; j++)
                {
                    if (i == j)
                        continue;

                    // check is blob overlap with other blobs (using 4 corner points matching methodology)?
                    //if ((((m_arrBuildOcvStartX[arrSelectedIndex[i]] > m_arrBuildOcvStartX[arrSelectedIndex[j]]) &&
                    //    (m_arrBuildOcvStartX[arrSelectedIndex[i]] < m_arrBuildOcvEndX[arrSelectedIndex[j]]) &&
                    //    (m_arrBuildOcvStartY[arrSelectedIndex[i]] > m_arrBuildOcvStartY[arrSelectedIndex[j]]) &&
                    //    (m_arrBuildOcvStartY[arrSelectedIndex[i]] < m_arrBuildOcvEndY[arrSelectedIndex[j]])) ||

                    //    ((m_arrBuildOcvStartX[arrSelectedIndex[i]] > m_arrBuildOcvStartX[arrSelectedIndex[j]]) &&
                    //    (m_arrBuildOcvStartX[arrSelectedIndex[i]] < m_arrBuildOcvEndX[arrSelectedIndex[j]]) &&
                    //    (m_arrBuildOcvEndY[arrSelectedIndex[i]] > m_arrBuildOcvStartY[arrSelectedIndex[j]]) &&
                    //    (m_arrBuildOcvEndY[arrSelectedIndex[i]] < m_arrBuildOcvEndY[arrSelectedIndex[j]])) ||

                    //    ((m_arrBuildOcvEndX[arrSelectedIndex[i]] > m_arrBuildOcvStartX[arrSelectedIndex[j]]) &&
                    //    (m_arrBuildOcvEndX[arrSelectedIndex[i]] < m_arrBuildOcvEndX[arrSelectedIndex[j]]) &&
                    //    (m_arrBuildOcvStartY[arrSelectedIndex[i]] > m_arrBuildOcvStartY[arrSelectedIndex[j]]) &&
                    //    (m_arrBuildOcvStartY[arrSelectedIndex[i]] < m_arrBuildOcvEndY[arrSelectedIndex[j]])) ||

                    //    ((m_arrBuildOcvEndX[arrSelectedIndex[i]] > m_arrBuildOcvStartX[arrSelectedIndex[j]]) &&
                    //    (m_arrBuildOcvEndX[arrSelectedIndex[i]] < m_arrBuildOcvEndX[arrSelectedIndex[j]]) &&
                    //    (m_arrBuildOcvEndY[arrSelectedIndex[i]] > m_arrBuildOcvStartY[arrSelectedIndex[j]]) &&
                    //    (m_arrBuildOcvEndY[arrSelectedIndex[i]] < m_arrBuildOcvEndY[arrSelectedIndex[j]]))) ||

                    //    (((m_arrBuildOcvStartX[arrSelectedIndex[j]] > m_arrBuildOcvStartX[arrSelectedIndex[i]]) &&
                    //    (m_arrBuildOcvStartX[arrSelectedIndex[j]] < m_arrBuildOcvEndX[arrSelectedIndex[i]]) &&
                    //    (m_arrBuildOcvStartY[arrSelectedIndex[j]] > m_arrBuildOcvStartY[arrSelectedIndex[i]]) &&
                    //    (m_arrBuildOcvStartY[arrSelectedIndex[j]] < m_arrBuildOcvEndY[arrSelectedIndex[i]])) ||

                    //    ((m_arrBuildOcvStartX[arrSelectedIndex[j]] > m_arrBuildOcvStartX[arrSelectedIndex[i]]) &&
                    //    (m_arrBuildOcvStartX[arrSelectedIndex[j]] < m_arrBuildOcvEndX[arrSelectedIndex[i]]) &&
                    //    (m_arrBuildOcvEndY[arrSelectedIndex[j]] > m_arrBuildOcvStartY[arrSelectedIndex[i]]) &&
                    //    (m_arrBuildOcvEndY[arrSelectedIndex[j]] < m_arrBuildOcvEndY[arrSelectedIndex[i]])) ||

                    //    ((m_arrBuildOcvEndX[arrSelectedIndex[j]] > m_arrBuildOcvStartX[arrSelectedIndex[i]]) &&
                    //    (m_arrBuildOcvEndX[arrSelectedIndex[j]] < m_arrBuildOcvEndX[arrSelectedIndex[i]]) &&
                    //    (m_arrBuildOcvStartY[arrSelectedIndex[j]] > m_arrBuildOcvStartY[arrSelectedIndex[i]]) &&
                    //    (m_arrBuildOcvStartY[arrSelectedIndex[j]] < m_arrBuildOcvEndY[arrSelectedIndex[i]])) ||

                    //    ((m_arrBuildOcvEndX[arrSelectedIndex[j]] > m_arrBuildOcvStartX[arrSelectedIndex[i]]) &&
                    //    (m_arrBuildOcvEndX[arrSelectedIndex[j]] < m_arrBuildOcvEndX[arrSelectedIndex[i]]) &&
                    //    (m_arrBuildOcvEndY[arrSelectedIndex[j]] > m_arrBuildOcvStartY[arrSelectedIndex[i]]) &&
                    //    (m_arrBuildOcvEndY[arrSelectedIndex[j]] < m_arrBuildOcvEndY[arrSelectedIndex[i]]))))
                    if (((((m_arrBuildOcvStartX[arrSelectedIndex[i]] - ((int)Math.Round(m_arrBuildOcvCharShiftX[arrSelectedIndex[i]] + m_fCharROIOffsetX))) > (m_arrBuildOcvStartX[arrSelectedIndex[j]] - ((int)Math.Round(m_arrBuildOcvCharShiftX[arrSelectedIndex[j]] + m_fCharROIOffsetX)))) &&
                      ((m_arrBuildOcvStartX[arrSelectedIndex[i]] - ((int)Math.Round(m_arrBuildOcvCharShiftX[arrSelectedIndex[i]] + m_fCharROIOffsetX))) < (m_arrBuildOcvEndX[arrSelectedIndex[j]] + ((int)Math.Round(m_arrBuildOcvCharShiftX[arrSelectedIndex[j]] + m_fCharROIOffsetX)))) &&
                      ((m_arrBuildOcvStartY[arrSelectedIndex[i]] - ((int)Math.Round(m_arrBuildOcvCharShiftY[arrSelectedIndex[i]] + m_fCharROIOffsetY))) > (m_arrBuildOcvStartY[arrSelectedIndex[j]] - ((int)Math.Round(m_arrBuildOcvCharShiftY[arrSelectedIndex[j]] + m_fCharROIOffsetY)))) &&
                      ((m_arrBuildOcvStartY[arrSelectedIndex[i]] - ((int)Math.Round(m_arrBuildOcvCharShiftY[arrSelectedIndex[i]] + m_fCharROIOffsetY))) < (m_arrBuildOcvEndY[arrSelectedIndex[j]] + ((int)Math.Round(m_arrBuildOcvCharShiftY[arrSelectedIndex[j]] + m_fCharROIOffsetY))))) ||

                      (((m_arrBuildOcvStartX[arrSelectedIndex[i]] - ((int)Math.Round(m_arrBuildOcvCharShiftX[arrSelectedIndex[i]] + m_fCharROIOffsetX))) > (m_arrBuildOcvStartX[arrSelectedIndex[i]] - ((int)Math.Round(m_arrBuildOcvCharShiftX[arrSelectedIndex[i]] + m_fCharROIOffsetX)))) &&
                      ((m_arrBuildOcvStartX[arrSelectedIndex[i]] - ((int)Math.Round(m_arrBuildOcvCharShiftX[arrSelectedIndex[i]] + m_fCharROIOffsetX))) < (m_arrBuildOcvEndX[arrSelectedIndex[j]] + ((int)Math.Round(m_arrBuildOcvCharShiftX[arrSelectedIndex[j]] + m_fCharROIOffsetX)))) &&
                      ((m_arrBuildOcvEndY[arrSelectedIndex[i]] + ((int)Math.Round(m_arrBuildOcvCharShiftY[arrSelectedIndex[i]] + m_fCharROIOffsetY))) > (m_arrBuildOcvStartY[arrSelectedIndex[j]] - ((int)Math.Round(m_arrBuildOcvCharShiftY[arrSelectedIndex[j]] + m_fCharROIOffsetY)))) &&
                      ((m_arrBuildOcvEndY[arrSelectedIndex[i]] + ((int)Math.Round(m_arrBuildOcvCharShiftY[arrSelectedIndex[i]] + m_fCharROIOffsetY))) < (m_arrBuildOcvEndY[arrSelectedIndex[j]] + ((int)Math.Round(m_arrBuildOcvCharShiftY[arrSelectedIndex[j]] + m_fCharROIOffsetY))))) ||

                      (((m_arrBuildOcvEndX[arrSelectedIndex[i]] + ((int)Math.Round(m_arrBuildOcvCharShiftX[arrSelectedIndex[i]] + m_fCharROIOffsetX))) > (m_arrBuildOcvStartX[arrSelectedIndex[j]] - ((int)Math.Round(m_arrBuildOcvCharShiftX[arrSelectedIndex[j]] + m_fCharROIOffsetX)))) &&
                      ((m_arrBuildOcvEndX[arrSelectedIndex[i]] + ((int)Math.Round(m_arrBuildOcvCharShiftX[arrSelectedIndex[i]] + m_fCharROIOffsetX))) < (m_arrBuildOcvEndX[arrSelectedIndex[j]] + ((int)Math.Round(m_arrBuildOcvCharShiftX[arrSelectedIndex[j]] + m_fCharROIOffsetX)))) &&
                      ((m_arrBuildOcvStartY[arrSelectedIndex[i]] - ((int)Math.Round(m_arrBuildOcvCharShiftY[arrSelectedIndex[i]] + m_fCharROIOffsetY))) > (m_arrBuildOcvStartY[arrSelectedIndex[j]] - ((int)Math.Round(m_arrBuildOcvCharShiftY[arrSelectedIndex[j]] + m_fCharROIOffsetY)))) &&
                      ((m_arrBuildOcvStartY[arrSelectedIndex[i]] - ((int)Math.Round(m_arrBuildOcvCharShiftY[arrSelectedIndex[i]] + m_fCharROIOffsetY))) < (m_arrBuildOcvEndY[arrSelectedIndex[j]] + ((int)Math.Round(m_arrBuildOcvCharShiftY[arrSelectedIndex[j]] + m_fCharROIOffsetY))))) ||

                      (((m_arrBuildOcvEndX[arrSelectedIndex[i]] + ((int)Math.Round(m_arrBuildOcvCharShiftX[arrSelectedIndex[i]] + m_fCharROIOffsetX))) > (m_arrBuildOcvStartX[arrSelectedIndex[j]] - ((int)Math.Round(m_arrBuildOcvCharShiftX[arrSelectedIndex[j]] + m_fCharROIOffsetX)))) &&
                      ((m_arrBuildOcvEndX[arrSelectedIndex[i]] + ((int)Math.Round(m_arrBuildOcvCharShiftX[arrSelectedIndex[i]] + m_fCharROIOffsetX))) < (m_arrBuildOcvEndX[arrSelectedIndex[j]] + ((int)Math.Round(m_arrBuildOcvCharShiftX[arrSelectedIndex[j]] + m_fCharROIOffsetX)))) &&
                      ((m_arrBuildOcvEndY[arrSelectedIndex[i]] + ((int)Math.Round(m_arrBuildOcvCharShiftY[arrSelectedIndex[i]] + m_fCharROIOffsetY))) > (m_arrBuildOcvStartY[arrSelectedIndex[j]] - ((int)Math.Round(m_arrBuildOcvCharShiftY[arrSelectedIndex[j]] + m_fCharROIOffsetY)))) &&
                      ((m_arrBuildOcvEndY[arrSelectedIndex[i]] + ((int)Math.Round(m_arrBuildOcvCharShiftY[arrSelectedIndex[i]] + m_fCharROIOffsetY))) < (m_arrBuildOcvEndY[arrSelectedIndex[j]] + ((int)Math.Round(m_arrBuildOcvCharShiftY[arrSelectedIndex[j]] + m_fCharROIOffsetY)))))) ||

                      ((((m_arrBuildOcvStartX[arrSelectedIndex[j]] - ((int)Math.Round(m_arrBuildOcvCharShiftX[arrSelectedIndex[j]] + m_fCharROIOffsetX))) > (m_arrBuildOcvStartX[arrSelectedIndex[i]] - ((int)Math.Round(m_arrBuildOcvCharShiftX[arrSelectedIndex[i]] + m_fCharROIOffsetX)))) &&
                      ((m_arrBuildOcvStartX[arrSelectedIndex[j]] - ((int)Math.Round(m_arrBuildOcvCharShiftX[arrSelectedIndex[j]] + m_fCharROIOffsetX))) < (m_arrBuildOcvEndX[arrSelectedIndex[i]] + ((int)Math.Round(m_arrBuildOcvCharShiftX[arrSelectedIndex[i]] + m_fCharROIOffsetX)))) &&
                      ((m_arrBuildOcvStartY[arrSelectedIndex[j]] - ((int)Math.Round(m_arrBuildOcvCharShiftY[arrSelectedIndex[j]] + m_fCharROIOffsetY))) > (m_arrBuildOcvStartY[arrSelectedIndex[i]] - ((int)Math.Round(m_arrBuildOcvCharShiftY[arrSelectedIndex[i]] + m_fCharROIOffsetY)))) &&
                      ((m_arrBuildOcvStartY[arrSelectedIndex[j]] - ((int)Math.Round(m_arrBuildOcvCharShiftY[arrSelectedIndex[j]] + m_fCharROIOffsetY))) < (m_arrBuildOcvEndY[arrSelectedIndex[i]] + ((int)Math.Round(m_arrBuildOcvCharShiftY[arrSelectedIndex[i]] + m_fCharROIOffsetY))))) ||

                      (((m_arrBuildOcvStartX[arrSelectedIndex[j]] - ((int)Math.Round(m_arrBuildOcvCharShiftX[arrSelectedIndex[j]] + m_fCharROIOffsetX))) > (m_arrBuildOcvStartX[arrSelectedIndex[i]] - ((int)Math.Round(m_arrBuildOcvCharShiftX[arrSelectedIndex[i]] + m_fCharROIOffsetX)))) &&
                      ((m_arrBuildOcvStartX[arrSelectedIndex[j]] - ((int)Math.Round(m_arrBuildOcvCharShiftX[arrSelectedIndex[j]] + m_fCharROIOffsetX))) < (m_arrBuildOcvEndX[arrSelectedIndex[i]] + ((int)Math.Round(m_arrBuildOcvCharShiftX[arrSelectedIndex[i]] + m_fCharROIOffsetX)))) &&
                      ((m_arrBuildOcvEndY[arrSelectedIndex[j]] + ((int)Math.Round(m_arrBuildOcvCharShiftY[arrSelectedIndex[j]] + m_fCharROIOffsetY))) > (m_arrBuildOcvStartY[arrSelectedIndex[i]] - ((int)Math.Round(m_arrBuildOcvCharShiftY[arrSelectedIndex[i]] + m_fCharROIOffsetY)))) &&
                      ((m_arrBuildOcvEndY[arrSelectedIndex[j]] + ((int)Math.Round(m_arrBuildOcvCharShiftY[arrSelectedIndex[j]] + m_fCharROIOffsetY))) < (m_arrBuildOcvEndY[arrSelectedIndex[i]] + ((int)Math.Round(m_arrBuildOcvCharShiftY[arrSelectedIndex[i]] + m_fCharROIOffsetY))))) ||

                      (((m_arrBuildOcvEndX[arrSelectedIndex[j]] + ((int)Math.Round(m_arrBuildOcvCharShiftX[arrSelectedIndex[j]] + m_fCharROIOffsetX))) > (m_arrBuildOcvStartX[arrSelectedIndex[i]] - ((int)Math.Round(m_arrBuildOcvCharShiftX[arrSelectedIndex[i]] + m_fCharROIOffsetX)))) &&
                      ((m_arrBuildOcvEndX[arrSelectedIndex[j]] + ((int)Math.Round(m_arrBuildOcvCharShiftX[arrSelectedIndex[j]] + m_fCharROIOffsetX))) < (m_arrBuildOcvEndX[arrSelectedIndex[i]] + ((int)Math.Round(m_arrBuildOcvCharShiftX[arrSelectedIndex[i]] + m_fCharROIOffsetX)))) &&
                      ((m_arrBuildOcvStartY[arrSelectedIndex[j]] - ((int)Math.Round(m_arrBuildOcvCharShiftY[arrSelectedIndex[j]] + m_fCharROIOffsetY))) > (m_arrBuildOcvStartY[arrSelectedIndex[i]] - ((int)Math.Round(m_arrBuildOcvCharShiftY[arrSelectedIndex[i]] + m_fCharROIOffsetY)))) &&
                      ((m_arrBuildOcvStartY[arrSelectedIndex[j]] - ((int)Math.Round(m_arrBuildOcvCharShiftY[arrSelectedIndex[j]] + m_fCharROIOffsetY))) < (m_arrBuildOcvEndY[arrSelectedIndex[i]] + ((int)Math.Round(m_arrBuildOcvCharShiftY[arrSelectedIndex[i]] + m_fCharROIOffsetY))))) ||

                      (((m_arrBuildOcvEndX[arrSelectedIndex[j]] + ((int)Math.Round(m_arrBuildOcvCharShiftX[arrSelectedIndex[j]] + m_fCharROIOffsetX))) > (m_arrBuildOcvStartX[arrSelectedIndex[i]] - ((int)Math.Round(m_arrBuildOcvCharShiftX[arrSelectedIndex[i]] + m_fCharROIOffsetX)))) &&
                      ((m_arrBuildOcvEndX[arrSelectedIndex[j]] + ((int)Math.Round(m_arrBuildOcvCharShiftX[arrSelectedIndex[j]] + m_fCharROIOffsetX))) < (m_arrBuildOcvEndX[arrSelectedIndex[i]] + ((int)Math.Round(m_arrBuildOcvCharShiftX[arrSelectedIndex[i]] + m_fCharROIOffsetX)))) &&
                      ((m_arrBuildOcvEndY[arrSelectedIndex[j]] + ((int)Math.Round(m_arrBuildOcvCharShiftY[arrSelectedIndex[j]] + m_fCharROIOffsetY))) > (m_arrBuildOcvStartY[arrSelectedIndex[i]] - ((int)Math.Round(m_arrBuildOcvCharShiftY[arrSelectedIndex[i]] + m_fCharROIOffsetY)))) &&
                      ((m_arrBuildOcvEndY[arrSelectedIndex[j]] + ((int)Math.Round(m_arrBuildOcvCharShiftY[arrSelectedIndex[j]] + m_fCharROIOffsetY))) < (m_arrBuildOcvEndY[arrSelectedIndex[i]] + ((int)Math.Round(m_arrBuildOcvCharShiftY[arrSelectedIndex[i]] + m_fCharROIOffsetY)))))))
                    {
                        // check is blob1 size smaller than blob2
                        //if (((m_arrBuildOcvEndX[arrSelectedIndex[i]] - m_arrBuildOcvStartX[arrSelectedIndex[i]]) * (m_arrBuildOcvEndY[arrSelectedIndex[i]] - m_arrBuildOcvStartY[arrSelectedIndex[i]])) >
                        //    ((m_arrBuildOcvEndX[arrSelectedIndex[j]] - m_arrBuildOcvStartX[arrSelectedIndex[j]]) * (m_arrBuildOcvEndY[arrSelectedIndex[j]] - m_arrBuildOcvStartY[arrSelectedIndex[j]])))
                        if ((((m_arrBuildOcvEndX[arrSelectedIndex[i]] + ((int)Math.Round(m_arrBuildOcvCharShiftX[arrSelectedIndex[i]] + m_fCharROIOffsetX))) - (m_arrBuildOcvStartX[arrSelectedIndex[i]] - ((int)Math.Round(m_arrBuildOcvCharShiftX[arrSelectedIndex[i]] + m_fCharROIOffsetX)))) *
                            ((m_arrBuildOcvEndY[arrSelectedIndex[i]] + ((int)Math.Round(m_arrBuildOcvCharShiftY[arrSelectedIndex[i]] + m_fCharROIOffsetX))) - (m_arrBuildOcvStartY[arrSelectedIndex[i]] - ((int)Math.Round(m_arrBuildOcvCharShiftY[arrSelectedIndex[i]] + m_fCharROIOffsetX))))) >
                          (((m_arrBuildOcvEndX[arrSelectedIndex[j]] + ((int)Math.Round(m_arrBuildOcvCharShiftX[arrSelectedIndex[j]] + m_fCharROIOffsetY))) - (m_arrBuildOcvStartX[arrSelectedIndex[j]] - ((int)Math.Round(m_arrBuildOcvCharShiftX[arrSelectedIndex[j]] + m_fCharROIOffsetY)))) *
                          ((m_arrBuildOcvEndY[arrSelectedIndex[j]] + ((int)Math.Round(m_arrBuildOcvCharShiftY[arrSelectedIndex[j]] + m_fCharROIOffsetY))) - (m_arrBuildOcvStartY[arrSelectedIndex[j]] - ((int)Math.Round(m_arrBuildOcvCharShiftY[arrSelectedIndex[j]] + m_fCharROIOffsetY))))))
                        {
                            blnOverlap = true;  // no select
                            break;
                        }
                    }
                }

                if (blnOverlap) //cxlim 2020/12/11 : turn off cause when drag, overlap char will not be selected
                {
                    //if (m_arrBuildOcvSelectStatus[arrSelectedIndex[i]] == 1)
                    //{
                    //    m_arrBuildOcvSelectStatus[arrSelectedIndex[i]] = 2;
                    //    //m_arrBuildOcvSelectStatusPrev[i] = 2;
                    //}
                    //else if (m_arrBuildOcvSelectStatus[arrSelectedIndex[i]] == 2 && m_arrBuildOcvSelectStatusPrev[arrSelectedIndex[i]] != 0)
                    //{
                    //    m_arrBuildOcvSelectStatus[arrSelectedIndex[i]] = 1;
                    //    //m_arrBuildOcvSelectStatusPrev[i] = 1;
                    //}
                    //else if (m_arrBuildOcvSelectStatus[arrSelectedIndex[i]] == 0 && m_arrBuildOcvSelectStatusPrev[arrSelectedIndex[i]] == 0)
                    //{
                    //    m_arrBuildOcvSelectStatus[arrSelectedIndex[i]] = 2;
                    //    //m_arrBuildOcvSelectStatusPrev[i] = 1;
                    //}
                    //else if (m_arrBuildOcvSelectStatus[arrSelectedIndex[i]] == 2 && m_arrBuildOcvSelectStatusPrev[arrSelectedIndex[i]] == 0)
                    //{
                    //    m_arrBuildOcvSelectStatus[arrSelectedIndex[i]] = 0;
                    //    //m_arrBuildOcvSelectStatusPrev[i] = 1;
                    //}
                }
            }
        }
        public void SelectBuildOcvCharForAction(System.Drawing.Point p1, System.Drawing.Point p2, int intROIX, int intROIY)
        {
            bool blnClearAllBeforeSelect = true;
            if (blnClearAllBeforeSelect)
            {
                for (int i = 0; i < m_arrBuildOcvSelectStatus.Count; i++)
                {
                    m_arrBuildOcvSelectStatus[i] = m_arrBuildOcvSelectStatusPrev[i];
                }
            }


            int intOrgX, intOrgY, intWidth, intHeight;

            if (p1.X < p2.X)
            {
                intOrgX = p1.X;
                intWidth = p2.X - p1.X;
            }
            else
            {
                intOrgX = p2.X;
                intWidth = p1.X - p2.X;
            }
            if (p1.Y < p2.Y)
            {
                intOrgY = p1.Y;
                intHeight = p2.Y - p1.Y;
            }
            else
            {
                intOrgY = p2.Y;
                intHeight = p1.Y - p2.Y;
            }

            intOrgX -= intROIX;
            intOrgY -= intROIY;

            // new method
            p1 = new System.Drawing.Point(p1.X - intROIX, p1.Y - intROIY);
            p2 = new System.Drawing.Point(p2.X - intROIX, p2.Y - intROIY);

            List<int> arrSelectedIndex = new List<int>();
            for (int i = 0; i < m_arrBuildOcvSelectStatus.Count; i++)
            {
                bool blnFound = false;
                for (int x = p1.X; x <= p2.X; x++)
                {
                    for (int y = p1.Y; y <= p2.Y; y++)
                    {
                        if ((x >= m_arrBuildOcvStartX[i]) &&
                               (x <= m_arrBuildOcvEndX[i]) &&
                               (y >= m_arrBuildOcvStartY[i]) &&
                               (y <= m_arrBuildOcvEndY[i]))
                        {
                            m_arrBuildOcvSelectStatus[i] = 2;
                            blnFound = true;
                            break;
                        }
                    }

                    if (blnFound)
                        break;
                }

                if (blnFound)
                    arrSelectedIndex.Add(i);
            }

            for (int i = 0; i < arrSelectedIndex.Count; i++)
            {
                bool blnOverlap = false;
                bool blnSmall = false;
                for (int j = 0; j < arrSelectedIndex.Count; j++)
                {
                    if (i == j)
                        continue;

                    // check is blob overlap with other blobs (using 4 corner points matching methodology)?
                    if ((((m_arrBuildOcvStartX[arrSelectedIndex[i]] > m_arrBuildOcvStartX[arrSelectedIndex[j]]) &&
                        (m_arrBuildOcvStartX[arrSelectedIndex[i]] < m_arrBuildOcvEndX[arrSelectedIndex[j]]) &&
                        (m_arrBuildOcvStartY[arrSelectedIndex[i]] > m_arrBuildOcvStartY[arrSelectedIndex[j]]) &&
                        (m_arrBuildOcvStartY[arrSelectedIndex[i]] < m_arrBuildOcvEndY[arrSelectedIndex[j]])) ||

                        ((m_arrBuildOcvStartX[arrSelectedIndex[i]] > m_arrBuildOcvStartX[arrSelectedIndex[j]]) &&
                        (m_arrBuildOcvStartX[arrSelectedIndex[i]] < m_arrBuildOcvEndX[arrSelectedIndex[j]]) &&
                        (m_arrBuildOcvEndY[arrSelectedIndex[i]] > m_arrBuildOcvStartY[arrSelectedIndex[j]]) &&
                        (m_arrBuildOcvEndY[arrSelectedIndex[i]] < m_arrBuildOcvEndY[arrSelectedIndex[j]])) ||

                        ((m_arrBuildOcvEndX[arrSelectedIndex[i]] > m_arrBuildOcvStartX[arrSelectedIndex[j]]) &&
                        (m_arrBuildOcvEndX[arrSelectedIndex[i]] < m_arrBuildOcvEndX[arrSelectedIndex[j]]) &&
                        (m_arrBuildOcvStartY[arrSelectedIndex[i]] > m_arrBuildOcvStartY[arrSelectedIndex[j]]) &&
                        (m_arrBuildOcvStartY[arrSelectedIndex[i]] < m_arrBuildOcvEndY[arrSelectedIndex[j]])) ||

                        ((m_arrBuildOcvEndX[arrSelectedIndex[i]] > m_arrBuildOcvStartX[arrSelectedIndex[j]]) &&
                        (m_arrBuildOcvEndX[arrSelectedIndex[i]] < m_arrBuildOcvEndX[arrSelectedIndex[j]]) &&
                        (m_arrBuildOcvEndY[arrSelectedIndex[i]] > m_arrBuildOcvStartY[arrSelectedIndex[j]]) &&
                        (m_arrBuildOcvEndY[arrSelectedIndex[i]] < m_arrBuildOcvEndY[arrSelectedIndex[j]]))) ||

                        (((m_arrBuildOcvStartX[arrSelectedIndex[j]] > m_arrBuildOcvStartX[arrSelectedIndex[i]]) &&
                        (m_arrBuildOcvStartX[arrSelectedIndex[j]] < m_arrBuildOcvEndX[arrSelectedIndex[i]]) &&
                        (m_arrBuildOcvStartY[arrSelectedIndex[j]] > m_arrBuildOcvStartY[arrSelectedIndex[i]]) &&
                        (m_arrBuildOcvStartY[arrSelectedIndex[j]] < m_arrBuildOcvEndY[arrSelectedIndex[i]])) ||

                        ((m_arrBuildOcvStartX[arrSelectedIndex[j]] > m_arrBuildOcvStartX[arrSelectedIndex[i]]) &&
                        (m_arrBuildOcvStartX[arrSelectedIndex[j]] < m_arrBuildOcvEndX[arrSelectedIndex[i]]) &&
                        (m_arrBuildOcvEndY[arrSelectedIndex[j]] > m_arrBuildOcvStartY[arrSelectedIndex[i]]) &&
                        (m_arrBuildOcvEndY[arrSelectedIndex[j]] < m_arrBuildOcvEndY[arrSelectedIndex[i]])) ||

                        ((m_arrBuildOcvEndX[arrSelectedIndex[j]] > m_arrBuildOcvStartX[arrSelectedIndex[i]]) &&
                        (m_arrBuildOcvEndX[arrSelectedIndex[j]] < m_arrBuildOcvEndX[arrSelectedIndex[i]]) &&
                        (m_arrBuildOcvStartY[arrSelectedIndex[j]] > m_arrBuildOcvStartY[arrSelectedIndex[i]]) &&
                        (m_arrBuildOcvStartY[arrSelectedIndex[j]] < m_arrBuildOcvEndY[arrSelectedIndex[i]])) ||

                        ((m_arrBuildOcvEndX[arrSelectedIndex[j]] > m_arrBuildOcvStartX[arrSelectedIndex[i]]) &&
                        (m_arrBuildOcvEndX[arrSelectedIndex[j]] < m_arrBuildOcvEndX[arrSelectedIndex[i]]) &&
                        (m_arrBuildOcvEndY[arrSelectedIndex[j]] > m_arrBuildOcvStartY[arrSelectedIndex[i]]) &&
                        (m_arrBuildOcvEndY[arrSelectedIndex[j]] < m_arrBuildOcvEndY[arrSelectedIndex[i]]))))
                    {
                        // check is blob1 size smaller than blob2
                        if (((m_arrBuildOcvEndX[arrSelectedIndex[i]] - m_arrBuildOcvStartX[arrSelectedIndex[i]]) * (m_arrBuildOcvEndY[arrSelectedIndex[i]] - m_arrBuildOcvStartY[arrSelectedIndex[i]])) >
                            ((m_arrBuildOcvEndX[arrSelectedIndex[j]] - m_arrBuildOcvStartX[arrSelectedIndex[j]]) * (m_arrBuildOcvEndY[arrSelectedIndex[j]] - m_arrBuildOcvStartY[arrSelectedIndex[j]])))
                        {
                            blnOverlap = true;  // no select
                            break;
                        }
                    }
                }

                if (!blnOverlap)
                {
                    m_arrBuildOcvSelectStatus[arrSelectedIndex[i]] = 2;
                }
            }
        }

        // --------- OCR function -------------------------------------------

        public bool BuildOCRChars(ImageDrawing objImage, ROI objROI)
        {
            // Get off set ROI for drawing purpose
            m_intROIOffSetX = objROI.ref_ROI.Parent.OrgX + objROI.ref_ROI.OrgX;
            m_intROIOffSetY = objROI.ref_ROI.Parent.OrgY + objROI.ref_ROI.OrgY;

            int intNumSelectedObject = m_objBlobs[m_intTemplateIndex].ref_intNumSelectedObject;

            m_intHitCharIndex = -1;

            m_objOCR.SetSegmentationParameters(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intThreshold,
                            m_blnWhiteOnBlack, false, m_intMinArea);

            if (!m_objOCR.BuildBlobChars(objROI, true, m_blnWhiteOnBlack, true,
                        m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intThreshold,
                        m_intMinArea, m_intMaxArea))
                return false;

            return true;
        }

        public char GetChar(int intCharIndex)
        {
            return m_objOCR.GetFirstLevelChar(intCharIndex);
        }

        public char GetPattern(int intPatternIndex)
        {
            return m_objOCR.GetPattern(intPatternIndex);
        }

        public float GetCharScore(int intCharIndex)
        {
            if (m_intInspectionMode == 0)
                return m_arrOCV[m_intGroupIndex][m_intTemplateIndex].GetCharScore(intCharIndex);
            else
                return m_objOCR.GetCharScore(intCharIndex);
        }

        public float GetCharScore(int intCharIndex, int intGroupIndex, int intTemplateIndex)
        {
            if (m_intInspectionMode == 0)
                return m_arrOCV[intGroupIndex][intTemplateIndex].GetCharScore(intCharIndex);
            else
                return m_objOCR.GetCharScore(intCharIndex);
        }

        public float GetCharAGVPercent(int intCharIndex, int intGroupIndex, int intTemplateIndex)
        {
            return m_arrOCV[intGroupIndex][intTemplateIndex].GetCharForeAreaSumPercent(intCharIndex);
        }
        public float GetCharAverageGrayDiff(int intCharIndex, int intTemplateIndex)
        {
            if (m_fAveGrayDiffBlobResult.Length > intTemplateIndex && m_fAveGrayDiffBlobResult[intTemplateIndex].Length > intCharIndex)
                return m_fAveGrayDiffBlobResult[intTemplateIndex][intCharIndex];
            else
                return -999;
        }
        public int GetNumChars(int intGroupIndex, int intTemplateIndex)
        {
            if (m_intInspectionMode == 0)
            {
                if (intTemplateIndex == -1)
                    return 0;

                if (m_arrOCV.Count <= intGroupIndex)
                    return 0;

                if (m_arrOCV[intGroupIndex].Count <= intTemplateIndex)
                    return 0;

                return m_arrOCV[intGroupIndex][intTemplateIndex].GetNumChars();
            }
            else
                return m_objOCR.ref_NumChars;
        }

        public int GetNumChars()
        {
            if (m_intInspectionMode == 0)
            {
                if (m_intTemplateIndex == -1)
                    return 0;

                if (m_arrOCV.Count <= m_intGroupIndex)
                    return 0;

                if (m_arrOCV[m_intGroupIndex].Count <= m_intTemplateIndex)
                    return 0;

                return m_arrOCV[m_intGroupIndex][m_intTemplateIndex].GetNumChars();
            }
            else
                return m_objOCR.ref_NumChars;
        }

        public int GetNumPatterns()
        {
            return m_objOCR.ref_NumPatterns;
        }

        public int GetPatternClass(int intPatternIndex)
        {
            return m_objOCR.GetPatternClass(intPatternIndex);
        }

        public Image GetPatternImage(int intPatternIndex)
        {
            return m_objOCR.GetPatternImage(intPatternIndex);
        }

        public string GetOCRRecognizeResult(ImageDrawing objImage, ROI objROI)
        {
            // Get max position for pattern matching
            int intNoSelectedBlobs = m_objBlobs[m_intTemplateIndex].ref_intNumSelectedObject;
            int intPatternMinArea = m_objOCR.ref_patternSmallestSize.Width * m_objOCR.ref_patternSmallestSize.Height;
            float fBlobWidth = 0, fBlobHeight = 0;
            m_objOCR.ref_intMaxPosition = 0;
            for (int i = 0; i < intNoSelectedBlobs; i++)
            {
                fBlobWidth = m_objBlobs[m_intTemplateIndex].ref_arrWidth[i];
                fBlobHeight = m_objBlobs[m_intTemplateIndex].ref_arrHeight[i];

                m_objOCR.ref_intMaxPosition += (int)Math.Round((fBlobWidth * fBlobHeight) / (float)intPatternMinArea, 0, MidpointRounding.AwayFromZero);
            }

            return m_objOCR.RecognizeCharsTextArea(objImage, objROI, true);
        }

        public void AddOCRPattern(ImageDrawing objImage, ROI objROI, char cPatternChar, int intClass)
        {
            m_objOCR.SetOCRPattern(objImage, objROI, m_intHitCharIndex, cPatternChar, intClass);

            int intCharSetting;
            if (m_arrTemplateSetting[0][0].intCharSetting.Count > 0)
            {
                int intLastIndex = m_arrTemplateSetting[0][0].intCharSetting.Count - 1;
                intCharSetting = m_arrTemplateSetting[0][0].intCharSetting[intLastIndex];
            }
            else
                intCharSetting = m_intDefaultCharSetting;
            m_arrTemplateSetting[0][0].intCharSetting.Add(intCharSetting);
        }

        public void DrawOCRBuildedChars(Graphics g)
        {
            int intStartX, intStartY, intWidth, intHeight;
            intStartX = intStartY = intWidth = intHeight = 0;
            int intNumChars = m_objOCR.ref_NumTemplateChars;
            for (int i = 0; i < intNumChars; i++)
            {
                m_objOCR.GetTemplateCharStartPoint(i, ref intStartX, ref intStartY);
                m_objOCR.GetTemplateCharSize(i, ref intWidth, ref intHeight);

                if (i == m_intHitCharIndex)
                {
                    g.DrawRectangle(new Pen(Color.Yellow), (float)m_intROIOffSetX + intStartX,
                        (float)m_intROIOffSetY + intStartY, intWidth, intHeight);
                }
                else
                {
                    g.DrawRectangle(new Pen(Color.Lime), (float)m_intROIOffSetX + intStartX,
                        (float)m_intROIOffSetY + intStartY, intWidth, intHeight);
                }

                //g.DrawString(Convert.ToString(i + 1), m_Font, new SolidBrush(Color.Red),
                //             m_intROIOffSetX + intStartX, m_intROIOffSetY + intStartY - 3); 
            }
        }

        public void HitChars(int intX, int intY)
        {
            m_intHitCharIndex = m_objOCR.HitChars(intX - m_intROIOffSetX, intY - m_intROIOffSetY);
        }

        public int HitOCVChars(int intX, int intY)
        {
            return m_arrOCV[m_intGroupIndex][m_intTemplateIndex].GetSelectedChar(intX - m_intROIOffSetX, intY - m_intROIOffSetY);
        }

        public int HitOCVText(int intX, int intY)
        {
            return m_arrOCV[m_intGroupIndex][m_intTemplateIndex].GetSelectedText(intX - m_intROIOffSetX, intY - m_intROIOffSetY);
        }

        public void RemoveOCRPattern(int intPatternIndex)
        {
            m_objOCR.RemoveOCRPattern(intPatternIndex);
            m_arrTemplateSetting[0][0].intCharSetting.RemoveAt(intPatternIndex);
        }


        // ------------ Private ------------------------------------------------------

        private bool CheckIsInUncheckArea(ROI objROI, float fX, float fY)
        {
            TemplateSetting objTemplateSetting = m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex];

            // Check Top ROI Uncheck Area
            if ((fX >= 0) &&
                (fX <= (objROI.ref_ROIWidth)) &&
                (fY >= 0) &&
                (fY < (int)Math.Round(objTemplateSetting.fUnCheckAreaTop)))
            {
                return true;
            }

            // Check Bottom ROI Uncheck Area
            if ((fX >= 0) &&
                (fX <= (objROI.ref_ROIWidth)) &&
                (fY > objROI.ref_ROIHeight - (int)Math.Round(objTemplateSetting.fUnCheckAreaBottom)) &&
                (fY <= (objROI.ref_ROIHeight)))
            {
                return true;
            }

            // Check Left ROI Uncheck Area
            if ((fX >= 0) &&
                (fX < (int)Math.Round(objTemplateSetting.fUnCheckAreaLeft)) &&
                (fY >= 0) &&
                (fY <= (objROI.ref_ROIHeight)))
            {
                return true;
            }

            // Check Right ROI Uncheck Area
            if ((fX > objROI.ref_ROIWidth - (int)Math.Round(objTemplateSetting.fUnCheckAreaRight)) &&
                (fX <= (objROI.ref_ROIWidth)) &&
                (fY >= 0) &&
                (fY <= (objROI.ref_ROIHeight)))
            {
                return true;
            }

            return false;
        }

        //Use when want use mark gauge to obtain unit edge, ROIStartX and intROIStartY is 0
        private bool CheckTextShifted(int intROIStartX, int intROIStartY, int intROIEndX, int intROIEndY)
        {
            if (m_intInspectionMode == 0)   // OCV
            {
                //System.Drawing.Point pStartPoint = m_arrOCV[m_intGroupIndex][m_intTemplateIndex].GetTextStartXY();
                //System.Drawing.Point pEndPoint = m_arrOCV[m_intGroupIndex][m_intTemplateIndex].GetTextEndXY();

                System.Drawing.Point pCharStart, pCharEnd;
                float fTemplateCharStartX = 0;
                float fTemplateCharStartY = 0;
                float fTemplateCharWidth = 0;
                float fTemplateCharHeight = 0;
                System.Drawing.Point pStartPoint = new Point(int.MaxValue, int.MaxValue);
                System.Drawing.Point pEndPoint = new Point(0, 0);
                int intNumChars = m_arrOCV[m_intGroupIndex][m_intTemplateIndex].GetNumChars();
                for (int i = 0; i < intNumChars; i++)
                {
                    pCharStart = m_arrOCV[m_intGroupIndex][m_intTemplateIndex].GetCharStartXY(i);
                    pCharEnd = m_arrOCV[m_intGroupIndex][m_intTemplateIndex].GetCharEndXY(i);

                    float fMinAddSizeX = (float)(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrTemplateCharDilateROI[i].ref_ROIWidth - (pCharEnd.X - pCharStart.X)) / 2;
                    float fMinAddSizeY = (float)(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrTemplateCharDilateROI[i].ref_ROIHeight - (pCharEnd.Y - pCharStart.Y)) / 2;

                    int intMinAddSizeStartX, intMinAddSizeStartY, intMinAddSizeEndX, intMinAddSizeEndY;
                    if (fMinAddSizeX == (int)fMinAddSizeX)
                    {
                        intMinAddSizeStartX = (int)fMinAddSizeX;
                        intMinAddSizeEndX = (int)fMinAddSizeX;
                    }
                    else
                    {
                        intMinAddSizeStartX = (int)Math.Ceiling(fMinAddSizeX);
                        intMinAddSizeEndX = (int)Math.Floor(fMinAddSizeX);
                    }

                    if (fMinAddSizeY == (int)fMinAddSizeY)
                    {
                        intMinAddSizeStartY = (int)fMinAddSizeY;
                        intMinAddSizeEndY = (int)fMinAddSizeY;
                    }
                    else
                    {
                        intMinAddSizeStartY = (int)Math.Ceiling(fMinAddSizeY);
                        intMinAddSizeEndY = (int)Math.Floor(fMinAddSizeY);
                    }

                    if ((m_intROIOffSetX + pCharStart.X - intMinAddSizeStartX) >= 0)
                        fTemplateCharStartX = m_intROIOffSetX + pCharStart.X - intMinAddSizeStartX;
                    else
                        fTemplateCharStartX = m_intROIOffSetX;

                    if ((m_intROIOffSetY + pCharStart.Y - intMinAddSizeStartY) >= 0)
                        fTemplateCharStartY = m_intROIOffSetY + pCharStart.Y - intMinAddSizeStartY;
                    else
                        fTemplateCharStartY = m_intROIOffSetY;

                    if ((pCharEnd.X + intMinAddSizeEndX * 2) < m_intImageWidth)
                        fTemplateCharWidth = pCharEnd.X - pCharStart.X + intMinAddSizeStartX + intMinAddSizeEndX;
                    else
                        continue;
                    if ((pCharEnd.Y + intMinAddSizeEndY * 2) < m_intImageHeight)
                        fTemplateCharHeight = pCharEnd.Y - pCharStart.Y + intMinAddSizeStartY + intMinAddSizeEndY;
                    else
                        continue;

                    if (pStartPoint.X > fTemplateCharStartX - m_intROIOffSetX)
                        pStartPoint.X = Convert.ToInt32(fTemplateCharStartX - m_intROIOffSetX);

                    if (pStartPoint.Y > fTemplateCharStartY - m_intROIOffSetY)
                        pStartPoint.Y = Convert.ToInt32(fTemplateCharStartY - m_intROIOffSetY);

                    if (pEndPoint.X < fTemplateCharStartX + fTemplateCharWidth - m_intROIOffSetX)
                        pEndPoint.X = Convert.ToInt32(fTemplateCharStartX + fTemplateCharWidth - m_intROIOffSetX);

                    if (pEndPoint.Y < fTemplateCharStartY + fTemplateCharHeight - m_intROIOffSetY)
                        pEndPoint.Y = Convert.ToInt32(fTemplateCharStartY + fTemplateCharHeight - m_intROIOffSetY);
                }

                // Make sure sample marks are not shifted out of Shift Limit
                TemplateSetting objTemplateSetting = m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex];

                m_arrTextShiftedTop[m_intTemplateIndex] = pStartPoint.Y;
                m_arrTextShiftedLeft[m_intTemplateIndex] = pStartPoint.X;
                m_arrTextShiftedBottom[m_intTemplateIndex] = intROIEndY - pEndPoint.Y;
                m_arrTextShiftedRight[m_intTemplateIndex] = intROIEndX - pEndPoint.X;

                if ((pStartPoint.X < (intROIStartX + (int)Math.Round(objTemplateSetting.fUnCheckAreaLeft))) ||
                    (pStartPoint.Y < (intROIStartY + (int)Math.Round(objTemplateSetting.fUnCheckAreaTop))) ||
                    (pEndPoint.X > (intROIEndX - (int)Math.Round(objTemplateSetting.fUnCheckAreaRight))) ||
                    (pEndPoint.Y > (intROIEndY - (int)Math.Round(objTemplateSetting.fUnCheckAreaBottom))))
                {
                    //m_arrTextShiftedTop[m_intTemplateIndex] = (intROIStartY + objTemplateSetting.intUnCheckAreaTop) - pStartPoint.Y;
                    //m_arrTextShiftedLeft[m_intTemplateIndex] = (intROIStartX + objTemplateSetting.intUnCheckAreaLeft) - pStartPoint.X;
                    //m_arrTextShiftedBottom[m_intTemplateIndex] = pEndPoint.Y - (intROIEndY - objTemplateSetting.intUnCheckAreaBottom);
                    //m_arrTextShiftedRight[m_intTemplateIndex] = pEndPoint.X - (intROIEndX - objTemplateSetting.intUnCheckAreaRight);

                    return false;
                }
            }
            else    // OCR
            {
                // Get Start and End Point of chars area
                int intStartX, intStartY, intEndX, intEndY;
                intStartX = intStartY = intEndX = intEndY = 0;
                int intNumChars = m_objOCR.ref_NumChars;
                for (int i = 0; i < intNumChars; i++)
                {
                    m_objOCR.GetCharStartPoint(i, ref intStartX, ref intStartY);
                    m_objOCR.GetCharEndPoint(i, ref intEndX, ref intEndY);
                }

                // Make sure sample marks are not shifted out of Shift Limit
                TemplateSetting objTemplateSetting = m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex];

                m_arrTextShiftedTop[m_intTemplateIndex] = intStartY;
                m_arrTextShiftedLeft[m_intTemplateIndex] = intStartX;
                m_arrTextShiftedBottom[m_intTemplateIndex] = intROIEndY - intEndY;
                m_arrTextShiftedRight[m_intTemplateIndex] = intROIEndX - intEndX;

                if ((intStartX < (intROIStartX + (int)Math.Round(objTemplateSetting.fUnCheckAreaLeft))) ||
                    (intStartY < (intROIStartY + (int)Math.Round(objTemplateSetting.fUnCheckAreaTop))) ||
                    (intEndX > (intROIEndX - (int)Math.Round(objTemplateSetting.fUnCheckAreaRight))) ||
                    (intEndY > (intROIEndY - (int)Math.Round(objTemplateSetting.fUnCheckAreaBottom))))
                {
                    //m_arrTextShiftedTop[m_intTemplateIndex] = (intROIStartY + objTemplateSetting.intUnCheckAreaTop) - intStartY;
                    //m_arrTextShiftedLeft[m_intTemplateIndex] = (intROIStartX + objTemplateSetting.intUnCheckAreaLeft) - intStartX;
                    //m_arrTextShiftedBottom[m_intTemplateIndex] = intEndY - (intROIEndY - objTemplateSetting.intUnCheckAreaBottom);
                    //m_arrTextShiftedRight[m_intTemplateIndex] = intEndX - (intROIEndX - objTemplateSetting.intUnCheckAreaRight);

                    return false;
                }
            }

            return true;
        }

        //Use when package size inspection is checked (package gauge measured unit edge) and no use mark gauge, ROIStartX and intROIStartY is not 0
        public bool CheckTextShifted2(int intROIStartX, int intROIStartY, int intROIEndX, int intROIEndY)
        {
            if (m_intInspectionMode == 0)   // OCV
            {
                //System.Drawing.Point pStartPoint = m_arrOCV[m_intGroupIndex][m_intTemplateIndex].GetTextStartXY();
                //System.Drawing.Point pEndPoint = m_arrOCV[m_intGroupIndex][m_intTemplateIndex].GetTextEndXY();

                System.Drawing.Point pCharStart, pCharEnd;
                float fTemplateCharStartX = 0;
                float fTemplateCharStartY = 0;
                float fTemplateCharWidth = 0;
                float fTemplateCharHeight = 0;
                System.Drawing.Point pStartPoint = new Point(int.MaxValue, int.MaxValue);
                System.Drawing.Point pEndPoint = new Point(0, 0);
                int intNumChars = m_arrOCV[m_intGroupIndex][m_intTemplateIndex].GetNumChars();
                for (int i = 0; i < intNumChars; i++)
                {
                    pCharStart = m_arrOCV[m_intGroupIndex][m_intTemplateIndex].GetCharStartXY(i);
                    pCharEnd = m_arrOCV[m_intGroupIndex][m_intTemplateIndex].GetCharEndXY(i);

                    float fMinAddSizeX = (float)(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrTemplateCharDilateROI[i].ref_ROIWidth - (pCharEnd.X - pCharStart.X)) / 2;
                    float fMinAddSizeY = (float)(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrTemplateCharDilateROI[i].ref_ROIHeight - (pCharEnd.Y - pCharStart.Y)) / 2;

                    int intMinAddSizeStartX, intMinAddSizeStartY, intMinAddSizeEndX, intMinAddSizeEndY;
                    if (fMinAddSizeX == (int)fMinAddSizeX)
                    {
                        intMinAddSizeStartX = (int)fMinAddSizeX;
                        intMinAddSizeEndX = (int)fMinAddSizeX;
                    }
                    else
                    {
                        intMinAddSizeStartX = (int)Math.Ceiling(fMinAddSizeX);
                        intMinAddSizeEndX = (int)Math.Floor(fMinAddSizeX);
                    }

                    if (fMinAddSizeY == (int)fMinAddSizeY)
                    {
                        intMinAddSizeStartY = (int)fMinAddSizeY;
                        intMinAddSizeEndY = (int)fMinAddSizeY;
                    }
                    else
                    {
                        intMinAddSizeStartY = (int)Math.Ceiling(fMinAddSizeY);
                        intMinAddSizeEndY = (int)Math.Floor(fMinAddSizeY);
                    }

                    if ((m_intROIOffSetX + pCharStart.X - intMinAddSizeStartX) >= 0)
                        fTemplateCharStartX = m_intROIOffSetX + pCharStart.X - intMinAddSizeStartX;
                    else
                        fTemplateCharStartX = m_intROIOffSetX;

                    if ((m_intROIOffSetY + pCharStart.Y - intMinAddSizeStartY) >= 0)
                        fTemplateCharStartY = m_intROIOffSetY + pCharStart.Y - intMinAddSizeStartY;
                    else
                        fTemplateCharStartY = m_intROIOffSetY;

                    if ((pCharEnd.X + intMinAddSizeEndX * 2) < m_intImageWidth)
                        fTemplateCharWidth = pCharEnd.X - pCharStart.X + intMinAddSizeStartX + intMinAddSizeEndX;
                    else
                        continue;
                    if ((pCharEnd.Y + intMinAddSizeEndY * 2) < m_intImageHeight)
                        fTemplateCharHeight = pCharEnd.Y - pCharStart.Y + intMinAddSizeStartY + intMinAddSizeEndY;
                    else
                        continue;

                    if (pStartPoint.X > fTemplateCharStartX - m_intROIOffSetX)
                        pStartPoint.X = Convert.ToInt32(fTemplateCharStartX - m_intROIOffSetX);

                    if (pStartPoint.Y > fTemplateCharStartY - m_intROIOffSetY)
                        pStartPoint.Y = Convert.ToInt32(fTemplateCharStartY - m_intROIOffSetY);

                    if (pEndPoint.X < fTemplateCharStartX + fTemplateCharWidth - m_intROIOffSetX)
                        pEndPoint.X = Convert.ToInt32(fTemplateCharStartX + fTemplateCharWidth - m_intROIOffSetX);

                    if (pEndPoint.Y < fTemplateCharStartY + fTemplateCharHeight - m_intROIOffSetY)
                        pEndPoint.Y = Convert.ToInt32(fTemplateCharStartY + fTemplateCharHeight - m_intROIOffSetY);
                }

                pStartPoint.X += m_intROIOffSetX;
                pStartPoint.Y += m_intROIOffSetY;
                pEndPoint.X += m_intROIOffSetX;
                pEndPoint.Y += m_intROIOffSetY;

                // Make sure sample marks are not shifted out of Shift Limit
                TemplateSetting objTemplateSetting = m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex];

                m_arrTextShiftedTop[m_intTemplateIndex] = pStartPoint.Y - intROIStartY;
                m_arrTextShiftedLeft[m_intTemplateIndex] = pStartPoint.X - intROIStartX;
                m_arrTextShiftedBottom[m_intTemplateIndex] = intROIEndY - pEndPoint.Y;
                m_arrTextShiftedRight[m_intTemplateIndex] = intROIEndX - pEndPoint.X;

                if ((pStartPoint.X < (intROIStartX + (int)Math.Round(objTemplateSetting.fUnCheckAreaLeft))) ||
                    (pStartPoint.Y < (intROIStartY + (int)Math.Round(objTemplateSetting.fUnCheckAreaTop))) ||
                    (pEndPoint.X > (intROIEndX - (int)Math.Round(objTemplateSetting.fUnCheckAreaRight))) ||
                    (pEndPoint.Y > (intROIEndY - (int)Math.Round(objTemplateSetting.fUnCheckAreaBottom))))
                {
                    //m_arrTextShiftedTop[m_intTemplateIndex] = (intROIStartY + objTemplateSetting.intUnCheckAreaTop) - pStartPoint.Y;
                    //m_arrTextShiftedLeft[m_intTemplateIndex] = (intROIStartX + objTemplateSetting.intUnCheckAreaLeft) - pStartPoint.X;
                    //m_arrTextShiftedBottom[m_intTemplateIndex] = pEndPoint.Y - (intROIEndY - objTemplateSetting.intUnCheckAreaBottom);
                    //m_arrTextShiftedRight[m_intTemplateIndex] = pEndPoint.X - (intROIEndX - objTemplateSetting.intUnCheckAreaRight);

                    return false;
                }
            }
            else    // OCR
            {
                // Get Start and End Point of chars area
                int intStartX, intStartY, intEndX, intEndY;
                intStartX = intStartY = intEndX = intEndY = 0;
                int intNumChars = m_objOCR.ref_NumChars;
                for (int i = 0; i < intNumChars; i++)
                {
                    m_objOCR.GetCharStartPoint(i, ref intStartX, ref intStartY);
                    m_objOCR.GetCharEndPoint(i, ref intEndX, ref intEndY);
                }

                // Make sure sample marks are not shifted out of Shift Limit
                TemplateSetting objTemplateSetting = m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex];

                m_arrTextShiftedTop[m_intTemplateIndex] = intStartY;
                m_arrTextShiftedLeft[m_intTemplateIndex] = intStartX;
                m_arrTextShiftedBottom[m_intTemplateIndex] = intROIEndY - intEndY;
                m_arrTextShiftedRight[m_intTemplateIndex] = intROIEndX - intEndX;

                if ((intStartX < (intROIStartX + (int)Math.Round(objTemplateSetting.fUnCheckAreaLeft))) ||
                    (intStartY < (intROIStartY + (int)Math.Round(objTemplateSetting.fUnCheckAreaTop))) ||
                    (intEndX > (intROIEndX - (int)Math.Round(objTemplateSetting.fUnCheckAreaRight))) ||
                    (intEndY > (intROIEndY - (int)Math.Round(objTemplateSetting.fUnCheckAreaBottom))))
                {
                    return false;
                }
            }

            return true;
        }

        public bool WantCheckMarkTextShifted()
        {
            if (m_arrTemplateSetting[m_intGroupIndex].Count > 0)
            {
                if ((m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intFailOptionMask & 0x40) > 0)
                    return true;
                else
                    return false;
            }
            else
                return false;
        }
        /// <summary>
        /// Return auto threshold value if Min Residue mode selected, else return manual select threshold value
        /// </summary>
        /// <param name="objROI">ROI for thresholding</param>
        /// <returns></returns>
        private int GetAutoThreshold(ROI objROI)
        {
            if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intThreshold == -4)
                return ROI.GetAutoThresholdValue(objROI, 3);
            else
                return m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intThreshold;
        }
        private int GetAutoThresholdExtraMark(ROI objROI)
        {
            if (m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intExtraMarkThreshold == -4)
                return ROI.GetAutoThresholdValue(objROI, 3);
            else
                return m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intExtraMarkThreshold;
        }

        private PointF GetReferPoint()
        {
            PointF pReferPoint = new PointF();

            return pReferPoint;
        }

        /// <summary>
        /// Define ROI to build blobs
        /// </summary>
        /// <param name="objImage">Sample Image</param>
        /// <param name="objROI">Mark Train ROI </param>
        /// <param name="blnIncludeUncheckArea">Build blobs include uncheck area?</param>
        /// <returns></returns>
        private ROI DefineBuildBlobROI(ImageDrawing objImage, ROI objROI, bool blnIncludeUncheckArea)
        {
            // Check is in uncheck area
            ROI objBuildObjectROI = new ROI();
            objBuildObjectROI.AttachImage(objImage);

            if (blnIncludeUncheckArea)
                objBuildObjectROI.LoadROISetting(
                    objROI.ref_ROI.TotalOrgX,
                    objROI.ref_ROI.TotalOrgY,
                    objROI.ref_ROI.Width,
                    objROI.ref_ROI.Height);
            else
                objBuildObjectROI.LoadROISetting(
                    objROI.ref_ROI.TotalOrgX + (int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fUnCheckAreaLeft),
                    objROI.ref_ROI.TotalOrgY + (int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fUnCheckAreaTop),
                    objROI.ref_ROI.Width - (int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fUnCheckAreaLeft) - (int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fUnCheckAreaRight),
                    objROI.ref_ROI.Height - (int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fUnCheckAreaTop) - (int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fUnCheckAreaBottom));

            return objBuildObjectROI;
        }

        private void DefineBuildBlobROI_SaveTime(ImageDrawing objImage, ROI objROI, bool blnIncludeUncheckArea)
        {
            // Check is in uncheck area
            if (m_blnWantDontCareArea)
                m_objBuildObjectROI.AttachImage(m_objDontCareBackupImage);
            else
                m_objBuildObjectROI.AttachImage(objImage);

            if (blnIncludeUncheckArea)
                m_objBuildObjectROI.LoadROISetting(
                    objROI.ref_ROI.TotalOrgX,
                    objROI.ref_ROI.TotalOrgY,
                    objROI.ref_ROI.Width,
                    objROI.ref_ROI.Height);
            else
                m_objBuildObjectROI.LoadROISetting(
                    objROI.ref_ROI.TotalOrgX + (int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fUnCheckAreaLeft),
                    objROI.ref_ROI.TotalOrgY + (int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fUnCheckAreaTop),
                    objROI.ref_ROI.Width - (int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fUnCheckAreaLeft) - (int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fUnCheckAreaRight),
                    objROI.ref_ROI.Height - (int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fUnCheckAreaTop) - (int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fUnCheckAreaBottom));

            if (m_intExtraExcessMarkInspectionAreaCutMode != 0)
            {
                if (m_blnWantDontCareArea)
                    m_objJointMarkROI.AttachImage(m_objDontCareBackupImage);
                else
                    m_objJointMarkROI.AttachImage(objImage);

                if (blnIncludeUncheckArea)
                    m_objJointMarkROI.LoadROISetting(
                        objROI.ref_ROI.TotalOrgX,
                        objROI.ref_ROI.TotalOrgY,
                        objROI.ref_ROI.Width,
                        objROI.ref_ROI.Height);
                else
                    m_objJointMarkROI.LoadROISetting(
                        objROI.ref_ROI.TotalOrgX + (int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fUnCheckAreaLeft),
                        objROI.ref_ROI.TotalOrgY + (int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fUnCheckAreaTop),
                        objROI.ref_ROI.Width - (int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fUnCheckAreaLeft) - (int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fUnCheckAreaRight),
                        objROI.ref_ROI.Height - (int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fUnCheckAreaTop) - (int)Math.Round(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fUnCheckAreaBottom));

            }
        }


        private string FillterRecogStringRow(string strRefChars, string strRecogString)
        {
            string[] arrRefChars = strRefChars.ToString().Split(' ');
            string[] arrRecogString = strRecogString.ToString().Split(' ');
            List<string> arrFinalRecogString = new List<string>();

            // Not need to filter if row are same
            if (arrRefChars.Length > arrRecogString.Length)
                return strRecogString;
            else
            {
                string strSelectedChars = "";
                int intCurrentIndex = 0;
                for (int i = 0; i < arrRefChars.Length; i++)
                {
                    for (int j = 0; j < arrRecogString.Length; j++)
                    {
                        strSelectedChars = "";
                        for (int m = 0; m < arrRefChars[i].Length; m++)
                        {
                            for (int n = 0; n < arrRecogString[j].Length; n++)
                            {
                                if (arrRefChars[i][m] == arrRecogString[j][n])
                                {
                                    strSelectedChars += arrRecogString[j][n];
                                    break;
                                }
                            }
                        }

                        if (strSelectedChars.Length > 0)
                        {
                            if (arrFinalRecogString.Count <= intCurrentIndex)
                                arrFinalRecogString.Add(strSelectedChars);
                            else
                            {
                                if (arrFinalRecogString[intCurrentIndex].Length <= strSelectedChars.Length)
                                {
                                    arrFinalRecogString.RemoveAt(intCurrentIndex);
                                    arrFinalRecogString.Insert(intCurrentIndex, strSelectedChars);
                                }

                            }
                        }
                    }
                    intCurrentIndex++;
                }

                for (int i = 0; i < arrRecogString.Length; i++)
                {
                    for (int j = 0; j < arrRefChars.Length; j++)
                    {
                        //Get highest same characters counter and same order



                        //If 2 cases are same, get same order

                        //If 2 cases are same, get same length, higher length is chosen.

                        //If 2 cases are same, then both are chosen.
                    }
                }
            }

            return "";
        }

        /// <summary>
        /// Reset all previous inspection data
        /// </summary>
        public void ResetInspectionData(bool blnCheckNoMark)
        {
            for (int i = 0; i < 8; i++)
            {
                m_blnCharResult[i] = new bool[0];
                m_blnOCRCharResult[i] = new bool[0];
                m_blnTextResult[i] = new bool[0];
                m_intBlobResult[i] = new int[0];
                m_intJointMarkBlobResult[i] = new int[0];
                m_intExcessBlobResult[i] = new int[0];
                m_fAveGrayDiffBlobResult[i] = new float[0];
                m_intMissingBlobResult[i] = new int[0];
                m_intSmallestExtraMarkArea[i] = 0;
                m_intSmallestExcessMarkArea[i] = 0;
                m_intSmallestMissingMarkArea[i] = 0;
                m_intBiggestExtraMarkArea[i] = 0;
                m_intBiggestExcessMarkArea[i] = 0;
                m_intBiggestMissingMarkArea[i] = 0;
                m_intGroupExtraMarkArea[i] = 0;
                m_intGroupExcessMarkArea[i] = 0;
                m_fGroupBrokenMarkLength[i] = 0;
                m_arrTextShiftedTop[i] = -999;
                m_arrTextShiftedBottom[i] = -999;
                m_arrTextShiftedLeft[i] = -999;
                m_arrTextShiftedRight[i] = -999;
                m_arrTestMatchScore[i] = 0;

                if (m_objBlobs[i] == null)
                    m_objBlobs[i] = new EBlobs();
                //else
                //    m_objBlobs[i].CleanAllBlobs();

                if (m_objAveGrayBlobs[i] == null)
                    m_objAveGrayBlobs[i] = new EBlobs();
                //else
                //    m_objAveGrayBlobs[i].CleanAllBlobs();

                if (m_objJointMarkBlobs[i] == null)
                    m_objJointMarkBlobs[i] = new EBlobs();
                //else
                //    m_objJointMarkBlobs[i].CleanAllBlobs();

                if (m_objExcessBlobs[i] == null)
                    m_objExcessBlobs[i] = new EBlobs();
                //else
                //    m_objExcessBlobs[i].CleanAllBlobs();

                if (m_objMissingBlobs[i] == null)
                    m_objMissingBlobs[i] = new EBlobs();
                //else
                //    m_objMissingBlobs[i].CleanAllBlobs();

                if (m_objBrokenBlobs[i] == null)
                    m_objBrokenBlobs[i] = new EBlobs();

                if (m_arrCharExcessAreaResult[i] != null)
                {
                    for (int j = 0; j < m_arrCharExcessAreaResult[i].Length; j++)
                    {
                        m_arrCharExcessAreaResult[i][j] = 0;
                    }
                }

                if (m_arrCharBrokenAreaResult[i] != null)
                {
                    for (int j = 0; j < m_arrCharBrokenAreaResult[i].Length; j++)
                    {
                        m_arrCharBrokenAreaResult[i][j] = 0;
                    }
                }

                if (blnCheckNoMark)
                    m_intTotalBlobArea = -1;    // 2020 11 07 - CCENG: set to -1 to indicate "no tested yet"
                if (m_arrCharBrokenMarkResult[i] != null)
                {
                    for (int j = 0; j < m_arrCharBrokenMarkResult[i].Length; j++)
                    {
                        m_arrCharBrokenMarkResult[i][j] = true;
                    }
                }

                if (m_arrCharJointMarkResult[i] != null)
                {
                    for (int j = 0; j < m_arrCharJointMarkResult[i].Length; j++)
                    {
                        m_arrCharJointMarkResult[i][j] = true;
                    }
                }

                if (m_arrCharWantBrokenMarkResult[i] != null)
                {
                    for (int j = 0; j < m_arrCharWantBrokenMarkResult[i].Length; j++)
                    {
                        m_arrCharWantBrokenMarkResult[i][j] = false;
                    }
                }
            }
        }

        public void MergeBuildOcvChar()
        {
            int intMergeID = -1;
            int intStartX = -1, intStartY = -1, intEndX = -1, intEndY = -1;
            int intMarkType = 0;
            float fMinCharShiftedX = -1, fMinCharShiftedY = -1;
            for (int i = 0; i < m_arrBuildOcvSelectStatus.Count; i++)
            {
                if (m_arrBuildOcvSelectStatus[i] == 2)
                {
                    if (intMergeID == -1)
                    {
                        intStartX = m_arrBuildOcvStartX[i];
                        intStartY = m_arrBuildOcvStartY[i];
                        intEndX = m_arrBuildOcvEndX[i];
                        intEndY = m_arrBuildOcvEndY[i];
                        intMergeID = m_arrBuildOcvNo[i];
                        fMinCharShiftedX = m_arrBuildOcvCharShiftX[i];
                        fMinCharShiftedY = m_arrBuildOcvCharShiftY[i];
                        intMarkType = m_arrBuildOcvType[i];
                        RemoveBuildOcvChar(i);
                    }
                    else
                    {
                        intStartX = Math.Min(intStartX, m_arrBuildOcvStartX[i]);
                        intStartY = Math.Min(intStartY, m_arrBuildOcvStartY[i]);
                        intEndX = Math.Max(intEndX, m_arrBuildOcvEndX[i]);
                        intEndY = Math.Max(intEndY, m_arrBuildOcvEndY[i]);
                        fMinCharShiftedX = Math.Min(fMinCharShiftedX, m_arrBuildOcvCharShiftX[i]);
                        fMinCharShiftedY = Math.Min(fMinCharShiftedY, m_arrBuildOcvCharShiftY[i]);
                        intMarkType = m_arrBuildOcvType[i];
                        RemoveBuildOcvChar(i);
                    }
                    i--;
                }
            }

            //2021-09-21 ZJYEOH : Join all char within the Merge Area
            for (int i = 0; i < m_arrBuildOcvSelectStatus.Count; i++)
            {
                float fCenterX = (m_arrBuildOcvStartX[i] + m_arrBuildOcvEndX[i]) / 2;
                float fCenterY = (m_arrBuildOcvStartY[i] + m_arrBuildOcvEndY[i]) / 2;

                if (fCenterX >= intStartX &&
                    fCenterX <= intEndX &&
                    fCenterY >= intStartY &&
                    fCenterY <= intEndY)
                {
                    intStartX = Math.Min(intStartX, m_arrBuildOcvStartX[i]);
                    intStartY = Math.Min(intStartY, m_arrBuildOcvStartY[i]);
                    intEndX = Math.Max(intEndX, m_arrBuildOcvEndX[i]);
                    intEndY = Math.Max(intEndY, m_arrBuildOcvEndY[i]);
                    fMinCharShiftedX = Math.Min(fMinCharShiftedX, m_arrBuildOcvCharShiftX[i]);
                    fMinCharShiftedY = Math.Min(fMinCharShiftedY, m_arrBuildOcvCharShiftY[i]);
                    intMarkType = m_arrBuildOcvType[i];
                    RemoveBuildOcvChar(i);

                    i--;
                }
            }

            if (intMergeID >= 0)
            {
                m_arrBuildOcvStartX.Add(intStartX);
                m_arrBuildOcvStartY.Add(intStartY);
                m_arrBuildOcvEndX.Add(intEndX);
                m_arrBuildOcvEndY.Add(intEndY);
                m_arrBuildOcvEnableStatus.Add(true);
                m_arrBuildOcvType.Add(intMarkType);
                m_arrBuildOcvSelectStatus.Add(1);
                m_arrBuildOcvSelectStatusPrev.Add(1);
                m_arrBuildOcvNo.Add(intMergeID);
                m_arrBuildOcvCharShiftX.Add(fMinCharShiftedX);
                m_arrBuildOcvCharShiftY.Add(fMinCharShiftedY);

                ////2021-09-21 ZJYEOH : Remove split points if located within the merged char
                //for (int i = 0; i < m_arrBuildOcvSplitStart.Count; i++)
                //{
                //    if (m_arrBuildOcvSplitStart[i].X >= intStartX && m_arrBuildOcvSplitStart[i].X <= intEndX &&
                //        m_arrBuildOcvSplitEnd[i].X >= intStartX && m_arrBuildOcvSplitEnd[i].X <= intEndX &&
                //        m_arrBuildOcvSplitStart[i].Y >= intStartY && m_arrBuildOcvSplitStart[i].Y <= intEndY &&
                //        m_arrBuildOcvSplitEnd[i].Y >= intStartY && m_arrBuildOcvSplitEnd[i].Y <= intEndY
                //        )
                //    {
                //        m_arrBuildOcvSplitStart.RemoveAt(i);
                //        m_arrBuildOcvSplitEnd.RemoveAt(i);
                //        i--;
                //    }
                //}
            }

            //ReassignOcvID(); //2019-11-08 ZJYEOH: Commented this function as it cause other filtered mark become not filtered
        }

        public void DisableOcvChar()
        {
            for (int i = 0; i < m_arrBuildOcvSelectStatus.Count; i++)
            {
                if (m_arrBuildOcvSelectStatus[i] == 2)
                {
                    m_arrBuildOcvEnableStatus[i] = false;
                }
            }
        }

        public void EnableOcvChar()
        {
            for (int i = 0; i < m_arrBuildOcvSelectStatus.Count; i++)
            {
                if (m_arrBuildOcvSelectStatus[i] == 2)
                {
                    m_arrBuildOcvEnableStatus[i] = true;
                }
            }
        }
        public void SetOcvType(int intType)
        {
            for (int i = 0; i < m_arrBuildOcvType.Count; i++)
            {
                if (m_arrBuildOcvSelectStatus[i] == 2)
                {
                    m_arrBuildOcvType[i] = intType;
                }
            }
        }
        public void SelectBuildOcvChar()
        {
            int intMergeID = -1;
            int intStartX = -1, intStartY = -1, intEndX = -1, intEndY = -1;
            for (int i = 0; i < m_arrBuildOcvSelectStatus.Count; i++)
            {
                if (m_arrBuildOcvSelectStatus[i] == 2)
                {
                    m_arrBuildOcvSelectStatus[i] = 1;
                    m_arrBuildOcvSelectStatusPrev[i] = 1;
                }
            }
        }

        public void DeselectBuildOcvChar()
        {
            int intMergeID = -1;
            int intStartX = -1, intStartY = -1, intEndX = -1, intEndY = -1;
            for (int i = 0; i < m_arrBuildOcvSelectStatus.Count; i++)
            {
                if (m_arrBuildOcvSelectStatus[i] == 2)
                {
                    m_arrBuildOcvSelectStatus[i] = 0;
                    m_arrBuildOcvSelectStatusPrev[i] = 0;
                }
            }
        }


        public int GetBuildOcvCharSelectedCount()
        {
            int intSelectedCount = 0;
            for (int i = 0; i < m_arrBuildOcvSelectStatus.Count; i++)
            {
                if (m_arrBuildOcvSelectStatus[i] == 2)
                    intSelectedCount++;
            }

            return intSelectedCount;
        }

        private void RemoveBuildOcvChar(int intIndex)
        {
            m_arrBuildOcvStartX.RemoveAt(intIndex);
            m_arrBuildOcvStartY.RemoveAt(intIndex);
            m_arrBuildOcvEndX.RemoveAt(intIndex);
            m_arrBuildOcvEndY.RemoveAt(intIndex);
            m_arrBuildOcvEnableStatus.RemoveAt(intIndex);
            m_arrBuildOcvType.RemoveAt(intIndex);
            m_arrBuildOcvSelectStatus.RemoveAt(intIndex);
            m_arrBuildOcvSelectStatusPrev.RemoveAt(intIndex);
            m_arrBuildOcvNo.RemoveAt(intIndex);
            m_arrBuildOcvCharShiftX.RemoveAt(intIndex);
            m_arrBuildOcvCharShiftY.RemoveAt(intIndex);
        }

        private void ReassignOcvID()
        {
            int intNewOcvID = 0;
            int intInsertIndex = 0;
            for (int i = 0; i < m_arrBuildOcvSelectStatus.Count; i++)
            {
                // Scan smallest Ocv ID
                int intSmallestOcvID = int.MaxValue;
                int intSelectedIndex = -1;
                List<int> arrSameOcvIDList = new List<int>();

                for (int h = i; h < m_arrBuildOcvSelectStatus.Count; h++)
                {
                    if (intSmallestOcvID > m_arrBuildOcvNo[h])
                    {
                        intSmallestOcvID = m_arrBuildOcvNo[h];
                        intSelectedIndex = h;
                        arrSameOcvIDList.Clear();
                        arrSameOcvIDList.Add(h);
                    }
                    else if (intSmallestOcvID == m_arrBuildOcvNo[h])
                    {
                        arrSameOcvIDList.Add(h);
                    }
                }

                if (arrSameOcvIDList.Count > 0)
                {
                    for (int k = 0; k < arrSameOcvIDList.Count; k++)
                    {
                        m_arrBuildOcvStartX.Insert(intInsertIndex, m_arrBuildOcvStartX[arrSameOcvIDList[k]]);
                        m_arrBuildOcvStartY.Insert(intInsertIndex, m_arrBuildOcvStartY[arrSameOcvIDList[k]]);
                        m_arrBuildOcvEndX.Insert(intInsertIndex, m_arrBuildOcvEndX[arrSameOcvIDList[k]]);
                        m_arrBuildOcvEndY.Insert(intInsertIndex, m_arrBuildOcvEndY[arrSameOcvIDList[k]]);
                        m_arrBuildOcvEnableStatus.Insert(intInsertIndex, true);
                        m_arrBuildOcvType.Insert(intInsertIndex, 0);
                        m_arrBuildOcvSelectStatus.Insert(intInsertIndex, 1);
                        m_arrBuildOcvSelectStatusPrev.Insert(intInsertIndex, 1);
                        m_arrBuildOcvNo.Insert(intInsertIndex, intNewOcvID);
                        intInsertIndex++;

                        m_arrBuildOcvStartX.RemoveAt(arrSameOcvIDList[k] + 1);
                        m_arrBuildOcvStartY.RemoveAt(arrSameOcvIDList[k] + 1);
                        m_arrBuildOcvEndX.RemoveAt(arrSameOcvIDList[k] + 1);
                        m_arrBuildOcvEndY.RemoveAt(arrSameOcvIDList[k] + 1);
                        m_arrBuildOcvEnableStatus.RemoveAt(arrSameOcvIDList[k] + 1);
                        m_arrBuildOcvType.RemoveAt(arrSameOcvIDList[k] + 1);
                        m_arrBuildOcvSelectStatus.RemoveAt(arrSameOcvIDList[k] + 1);
                        m_arrBuildOcvSelectStatusPrev.RemoveAt(arrSameOcvIDList[k] + 1);
                        m_arrBuildOcvNo.RemoveAt(arrSameOcvIDList[k] + 1);
                    }

                    intNewOcvID++;
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="blnWantSplitHorizontal"></param>
        /// <returns>False=Need confirmation. True=Split done.</returns>
        public bool SplitBuildOcvChar(bool blnWantSplitHorizontal)
        {
            m_blnSplitHorizontal = blnWantSplitHorizontal;

            for (int i = 0; i < m_arrBuildOcvSelectStatus.Count; i++)
            {
                if (m_arrBuildOcvSelectStatus[i] == 2)
                {
                    // Check Is origin char has multi characters or not
                    int intMatchCount = 0;
                    List<int> arrMatchIndex = new List<int>();
                    for (int j = 0; j < m_arrBuildOcvSelectStatusOri.Count; j++)
                    {
                        int intCenterX = (m_arrBuildOcvStartXOri[j] + m_arrBuildOcvEndXOri[j]) / 2;
                        int intCenterY = (m_arrBuildOcvStartYOri[j] + m_arrBuildOcvEndYOri[j]) / 2;

                        if (intCenterX > m_arrBuildOcvStartX[i] && intCenterX < m_arrBuildOcvEndX[i] &&
                            intCenterY > m_arrBuildOcvStartY[i] && intCenterY < m_arrBuildOcvEndY[i])
                        {
                            intMatchCount++;
                            arrMatchIndex.Add(j);
                        }
                    }

                    if (intMatchCount > 1)
                    {
                        // Define split center line
                        if (blnWantSplitHorizontal)
                        {
                            float fMinY = int.MaxValue;
                            float fMaxY = int.MinValue;
                            for (int k = 0; k < arrMatchIndex.Count; k++)
                            {
                                fMinY = Math.Min(fMinY, m_arrBuildOcvStartYOri[arrMatchIndex[k]]);
                                fMaxY = Math.Max(fMaxY, m_arrBuildOcvEndYOri[arrMatchIndex[k]]);
                            }

                            float fSplitY = (fMaxY + fMinY) / 2;

                            int intStartX1 = int.MaxValue, intStartY1 = int.MaxValue, intEndX1 = int.MinValue, intEndY1 = int.MinValue;
                            int intStartX2 = int.MaxValue, intStartY2 = int.MaxValue, intEndX2 = int.MinValue, intEndY2 = int.MinValue;
                            int intMarkType = 0;

                            for (int k = 0; k < arrMatchIndex.Count; k++)
                            {
                                if (((m_arrBuildOcvStartYOri[arrMatchIndex[k]] + m_arrBuildOcvEndYOri[arrMatchIndex[k]]) / 2) < fSplitY)
                                {
                                    intStartX1 = Math.Min(intStartX1, m_arrBuildOcvStartXOri[arrMatchIndex[k]]);
                                    intStartY1 = Math.Min(intStartY1, m_arrBuildOcvStartYOri[arrMatchIndex[k]]);
                                    intEndX1 = Math.Max(intEndX1, m_arrBuildOcvEndXOri[arrMatchIndex[k]]);
                                    intEndY1 = Math.Max(intEndY1, m_arrBuildOcvEndYOri[arrMatchIndex[k]]);
                                }
                                else
                                {
                                    intStartX2 = Math.Min(intStartX2, m_arrBuildOcvStartXOri[arrMatchIndex[k]]);
                                    intStartY2 = Math.Min(intStartY2, m_arrBuildOcvStartYOri[arrMatchIndex[k]]);
                                    intEndX2 = Math.Max(intEndX2, m_arrBuildOcvEndXOri[arrMatchIndex[k]]);
                                    intEndY2 = Math.Max(intEndY2, m_arrBuildOcvEndYOri[arrMatchIndex[k]]);
                                }
                                m_arrBuildOcvCharShiftX.Add(m_arrBuildOcvCharShiftX[m_arrBuildOcvCharShiftX.Count - 1]);
                                m_arrBuildOcvCharShiftY.Add(m_arrBuildOcvCharShiftY[m_arrBuildOcvCharShiftY.Count - 1]);
                                intMarkType = m_arrBuildOcvTypeOri[arrMatchIndex[k]];
                            }

                            if (intStartX1 != int.MaxValue)
                            {
                                m_arrBuildOcvNo.Add(m_arrBuildOcvNo[m_arrBuildOcvSelectStatus.Count - 1] + 1);
                                m_arrBuildOcvStartX.Add(intStartX1);
                                m_arrBuildOcvStartY.Add(intStartY1);
                                m_arrBuildOcvEndX.Add(intEndX1);
                                m_arrBuildOcvEndY.Add(intEndY1);
                                m_arrBuildOcvEnableStatus.Add(true);
                                m_arrBuildOcvType.Add(intMarkType);
                                m_arrBuildOcvSelectStatus.Add(1);
                                m_arrBuildOcvSelectStatusPrev.Add(1);
                            }

                            if (intStartX2 != int.MaxValue)
                            {
                                m_arrBuildOcvNo.Add(m_arrBuildOcvNo[m_arrBuildOcvSelectStatus.Count - 1] + 1);
                                m_arrBuildOcvStartX.Add(intStartX2);
                                m_arrBuildOcvStartY.Add(intStartY2);
                                m_arrBuildOcvEndX.Add(intEndX2);
                                m_arrBuildOcvEndY.Add(intEndY2);
                                m_arrBuildOcvEnableStatus.Add(true);
                                m_arrBuildOcvType.Add(intMarkType);
                                m_arrBuildOcvSelectStatus.Add(1);
                                m_arrBuildOcvSelectStatusPrev.Add(1);
                            }
                        }
                        else
                        {
                            float fMinX = int.MaxValue;
                            float fMaxX = int.MinValue;
                            for (int k = 0; k < arrMatchIndex.Count; k++)
                            {
                                fMinX = Math.Min(fMinX, m_arrBuildOcvStartXOri[arrMatchIndex[k]]);
                                fMaxX = Math.Max(fMaxX, m_arrBuildOcvEndXOri[arrMatchIndex[k]]);
                            }

                            float fSplitX = (fMaxX + fMinX) / 2;

                            int intStartX1 = int.MaxValue, intStartY1 = int.MaxValue, intEndX1 = int.MinValue, intEndY1 = int.MinValue;
                            int intStartX2 = int.MaxValue, intStartY2 = int.MaxValue, intEndX2 = int.MinValue, intEndY2 = int.MinValue;
                            int intMarkType = 0;

                            for (int k = 0; k < arrMatchIndex.Count; k++)
                            {
                                if (((m_arrBuildOcvStartXOri[arrMatchIndex[k]] + m_arrBuildOcvEndXOri[arrMatchIndex[k]]) / 2) < fSplitX)
                                {
                                    intStartX1 = Math.Min(intStartX1, m_arrBuildOcvStartXOri[arrMatchIndex[k]]);
                                    intStartY1 = Math.Min(intStartY1, m_arrBuildOcvStartYOri[arrMatchIndex[k]]);
                                    intEndX1 = Math.Max(intEndX1, m_arrBuildOcvEndXOri[arrMatchIndex[k]]);
                                    intEndY1 = Math.Max(intEndY1, m_arrBuildOcvEndYOri[arrMatchIndex[k]]);
                                }
                                else
                                {
                                    intStartX2 = Math.Min(intStartX2, m_arrBuildOcvStartXOri[arrMatchIndex[k]]);
                                    intStartY2 = Math.Min(intStartY2, m_arrBuildOcvStartYOri[arrMatchIndex[k]]);
                                    intEndX2 = Math.Max(intEndX2, m_arrBuildOcvEndXOri[arrMatchIndex[k]]);
                                    intEndY2 = Math.Max(intEndY2, m_arrBuildOcvEndYOri[arrMatchIndex[k]]);
                                }
                                m_arrBuildOcvCharShiftX.Add(m_arrBuildOcvCharShiftX[m_arrBuildOcvCharShiftX.Count - 1]);
                                m_arrBuildOcvCharShiftY.Add(m_arrBuildOcvCharShiftY[m_arrBuildOcvCharShiftY.Count - 1]);
                                intMarkType = m_arrBuildOcvTypeOri[arrMatchIndex[k]];
                            }

                            if (intStartX1 != int.MaxValue)
                            {
                                m_arrBuildOcvNo.Add(m_arrBuildOcvNo[m_arrBuildOcvSelectStatus.Count - 1] + 1);
                                m_arrBuildOcvStartX.Add(intStartX1);
                                m_arrBuildOcvStartY.Add(intStartY1);
                                m_arrBuildOcvEndX.Add(intEndX1);
                                m_arrBuildOcvEndY.Add(intEndY1);
                                m_arrBuildOcvEnableStatus.Add(true);
                                m_arrBuildOcvType.Add(intMarkType);
                                m_arrBuildOcvSelectStatus.Add(1);
                                m_arrBuildOcvSelectStatusPrev.Add(1);
                            }

                            if (intStartX2 != int.MaxValue)
                            {
                                m_arrBuildOcvNo.Add(m_arrBuildOcvNo[m_arrBuildOcvSelectStatus.Count - 1] + 1);
                                m_arrBuildOcvStartX.Add(intStartX2);
                                m_arrBuildOcvStartY.Add(intStartY2);
                                m_arrBuildOcvEndX.Add(intEndX2);
                                m_arrBuildOcvEndY.Add(intEndY2);
                                m_arrBuildOcvEnableStatus.Add(true);
                                m_arrBuildOcvType.Add(intMarkType);
                                m_arrBuildOcvSelectStatus.Add(1);
                                m_arrBuildOcvSelectStatusPrev.Add(1);
                            }
                        }

                        //int intMergeID = m_arrBuildOcvNo[m_arrBuildOcvSelectStatus.Count - 1] + 1;

                        //m_arrBuildOcvStartX.Add(m_arrBuildOcvStartXOri[arrMatchIndex[0]]);
                        //m_arrBuildOcvStartY.Add(m_arrBuildOcvStartYOri[arrMatchIndex[0]]);
                        //m_arrBuildOcvEndX.Add(m_arrBuildOcvEndXOri[arrMatchIndex[0]]);
                        //m_arrBuildOcvEndY.Add(m_arrBuildOcvEndYOri[arrMatchIndex[0]]);
                        //m_arrBuildOcvSelectStatus.Add(1);
                        //m_arrBuildOcvSelectStatusPrev.Add(1);
                        //m_arrBuildOcvNo.Add(intMergeID);

                        //intMergeID = m_arrBuildOcvNo[m_arrBuildOcvSelectStatus.Count - 1] + 1;

                        //int intStartX = -1, intStartY = -1, intEndX = -1, intEndY = -1;
                        //for (int k = 1; k < arrMatchIndex.Count; k++)
                        //{
                        //    if (k == 1)
                        //    {
                        //        intStartX = m_arrBuildOcvStartXOri[arrMatchIndex[k]];
                        //        intStartY = m_arrBuildOcvStartYOri[arrMatchIndex[k]];
                        //        intEndX = m_arrBuildOcvEndXOri[arrMatchIndex[k]];
                        //        intEndY = m_arrBuildOcvEndYOri[arrMatchIndex[k]];
                        //    }
                        //    else
                        //    {
                        //        intStartX = Math.Min(intStartX, m_arrBuildOcvStartXOri[arrMatchIndex[k]]);
                        //        intStartY = Math.Min(intStartY, m_arrBuildOcvStartYOri[arrMatchIndex[k]]);
                        //        intEndX = Math.Max(intEndX, m_arrBuildOcvEndXOri[arrMatchIndex[k]]);
                        //        intEndY = Math.Max(intEndY, m_arrBuildOcvEndYOri[arrMatchIndex[k]]);
                        //    }
                        //}

                        //m_arrBuildOcvStartX.Add(intStartX);
                        //m_arrBuildOcvStartY.Add(intStartY);
                        //m_arrBuildOcvEndX.Add(intEndX);
                        //m_arrBuildOcvEndY.Add(intEndY);
                        //m_arrBuildOcvSelectStatus.Add(1);
                        //m_arrBuildOcvSelectStatusPrev.Add(1);
                        //m_arrBuildOcvNo.Add(intMergeID);

                        RemoveBuildOcvChar(i);

                        return true;
                    }
                    else if (intMatchCount <= 1)
                    {
                        PointF pStartPoint, pEndPoint;
                        // Find cut point
                        if (blnWantSplitHorizontal)
                        {
                            pStartPoint = new PointF(m_arrBuildOcvStartX[i],
                                                    (float)Math.Round(((float)m_arrBuildOcvStartY[i] + (float)m_arrBuildOcvEndY[i]) / 2, 0, MidpointRounding.AwayFromZero));

                            pEndPoint = new PointF(m_arrBuildOcvEndX[i],
                                                    (float)Math.Round(((float)m_arrBuildOcvStartY[i] + (float)m_arrBuildOcvEndY[i]) / 2, 0, MidpointRounding.AwayFromZero));

                            m_arrBuildOcvCutLineStartPoint.Add(pStartPoint);
                            m_arrBuildOcvCutLineEndPoint.Add(pEndPoint);

                            m_objSplitMarkLine.SetROIPlacement(pStartPoint.X, pStartPoint.Y, pEndPoint.X, pEndPoint.Y);

                            m_intSelectedBuildOcvForSplitLine = i;

                            m_blnIsSplitLineDisplaying = true;
                        }
                        else
                        {

                            pStartPoint = new PointF((float)Math.Round(((float)m_arrBuildOcvStartX[i] + (float)m_arrBuildOcvEndX[i]) / 2, 0, MidpointRounding.AwayFromZero),
                                                            m_arrBuildOcvStartY[i]);

                            pEndPoint = new PointF((float)Math.Round(((float)m_arrBuildOcvStartX[i] + (float)m_arrBuildOcvEndX[i]) / 2, 0, MidpointRounding.AwayFromZero),
                                                            m_arrBuildOcvEndY[i]);

                            m_arrBuildOcvCutLineStartPoint.Add(pStartPoint);
                            m_arrBuildOcvCutLineEndPoint.Add(pEndPoint);

                            m_objSplitMarkLine.SetROIPlacement(pStartPoint.X, pStartPoint.Y, pEndPoint.X, pEndPoint.Y);

                            m_intSelectedBuildOcvForSplitLine = i;

                            m_blnIsSplitLineDisplaying = true;
                        }

                        return false;
                    }
                    else
                    {
                    }

                    break;
                }
            }

            return true;
        }

        public bool SplitBuildOcvChar2(bool blnWantSplitHorizontal)
        {
            for (int i = 0; i < m_arrBuildOcvSelectStatus.Count; i++)
            {
                if (m_arrBuildOcvSelectStatus[i] == 2)
                {
                    // Check Is origin char has multi characters or not
                    int intMatchCount = 0;
                    List<int> arrMatchIndex = new List<int>();
                    for (int j = 0; j < m_arrBuildOcvSelectStatusOri.Count; j++)
                    {
                        int intCenterX = (m_arrBuildOcvStartXOri[j] + m_arrBuildOcvEndXOri[j]) / 2;
                        int intCenterY = (m_arrBuildOcvStartYOri[j] + m_arrBuildOcvEndYOri[j]) / 2;

                        if (intCenterX > m_arrBuildOcvStartX[i] && intCenterX < m_arrBuildOcvEndX[i] &&
                            intCenterY > m_arrBuildOcvStartY[i] && intCenterY < m_arrBuildOcvEndY[i])
                        {
                            intMatchCount++;
                            arrMatchIndex.Add(j);
                        }
                    }

                    if (intMatchCount > 1)
                    {
                        int intMergeID = m_arrBuildOcvNo[m_arrBuildOcvSelectStatus.Count - 1] + 1;

                        m_arrBuildOcvStartX.Add(m_arrBuildOcvStartXOri[arrMatchIndex[0]]);
                        m_arrBuildOcvStartY.Add(m_arrBuildOcvStartYOri[arrMatchIndex[0]]);
                        m_arrBuildOcvEndX.Add(m_arrBuildOcvEndXOri[arrMatchIndex[0]]);
                        m_arrBuildOcvEndY.Add(m_arrBuildOcvEndYOri[arrMatchIndex[0]]);
                        m_arrBuildOcvEnableStatus.Add(true);
                        m_arrBuildOcvType.Add(m_arrBuildOcvTypeOri[arrMatchIndex[0]]);
                        m_arrBuildOcvSelectStatus.Add(1);
                        m_arrBuildOcvSelectStatusPrev.Add(1);
                        m_arrBuildOcvNo.Add(intMergeID);

                        intMergeID = m_arrBuildOcvNo[m_arrBuildOcvSelectStatus.Count - 1] + 1;

                        int intStartX = -1, intStartY = -1, intEndX = -1, intEndY = -1;
                        for (int k = 1; k < arrMatchIndex.Count; k++)
                        {
                            if (k == 1)
                            {
                                intStartX = m_arrBuildOcvStartXOri[arrMatchIndex[k]];
                                intStartY = m_arrBuildOcvStartYOri[arrMatchIndex[k]];
                                intEndX = m_arrBuildOcvEndXOri[arrMatchIndex[k]];
                                intEndY = m_arrBuildOcvEndYOri[arrMatchIndex[k]];
                            }
                            else
                            {
                                intStartX = Math.Min(intStartX, m_arrBuildOcvStartXOri[arrMatchIndex[k]]);
                                intStartY = Math.Min(intStartY, m_arrBuildOcvStartYOri[arrMatchIndex[k]]);
                                intEndX = Math.Max(intEndX, m_arrBuildOcvEndXOri[arrMatchIndex[k]]);
                                intEndY = Math.Max(intEndY, m_arrBuildOcvEndYOri[arrMatchIndex[k]]);
                            }
                        }

                        m_arrBuildOcvStartX.Add(intStartX);
                        m_arrBuildOcvStartY.Add(intStartY);
                        m_arrBuildOcvEndX.Add(intEndX);
                        m_arrBuildOcvEndY.Add(intEndY);
                        m_arrBuildOcvEnableStatus.Add(true);
                        m_arrBuildOcvType.Add(m_arrBuildOcvTypeOri[arrMatchIndex[0]]);
                        m_arrBuildOcvSelectStatus.Add(1);
                        m_arrBuildOcvSelectStatusPrev.Add(1);
                        m_arrBuildOcvNo.Add(intMergeID);

                        RemoveBuildOcvChar(i);

                        return true;
                    }
                    else if (intMatchCount == 1)
                    {
                        PointF pStartPoint, pEndPoint;
                        // Find cut point
                        if (blnWantSplitHorizontal)
                        {
                            pStartPoint = new PointF(m_arrBuildOcvStartX[i],
                                                    (float)Math.Round(((float)m_arrBuildOcvStartY[i] + (float)m_arrBuildOcvEndY[i]) / 2, 0, MidpointRounding.AwayFromZero));

                            pEndPoint = new PointF(m_arrBuildOcvEndX[arrMatchIndex[0]],
                                                    (float)Math.Round(((float)m_arrBuildOcvStartY[i] + (float)m_arrBuildOcvEndY[i]) / 2, 0, MidpointRounding.AwayFromZero));

                            m_arrBuildOcvCutLineStartPoint.Add(pStartPoint);
                            m_arrBuildOcvCutLineEndPoint.Add(pEndPoint);

                            m_objSplitMarkLine.SetROIPlacement(pStartPoint.X, pStartPoint.Y, pEndPoint.X, pEndPoint.Y);

                            m_intSelectedBuildOcvForSplitLine = i;

                            m_blnIsSplitLineDisplaying = true;
                        }
                        else
                        {

                            pStartPoint = new PointF((float)Math.Round(((float)m_arrBuildOcvStartX[i] + (float)m_arrBuildOcvEndX[i]) / 2, 0, MidpointRounding.AwayFromZero),
                                                            m_arrBuildOcvStartY[i]);

                            pEndPoint = new PointF((float)Math.Round(((float)m_arrBuildOcvStartX[i] + (float)m_arrBuildOcvEndX[i]) / 2, 0, MidpointRounding.AwayFromZero),
                                                            m_arrBuildOcvEndY[i]);
                        }

                        return false;
                    }

                    break;
                }
            }

            return true;
        }

        public void ClearBuildOcvSplitPoints()
        {
            m_arrBuildOcvSplitStart = new List<Point>();
            m_arrBuildOcvSplitEnd = new List<Point>();
        }

        public void SetSplitLineDone()
        {
            m_blnIsSplitLineDisplaying = false;

            int i = m_intSelectedBuildOcvForSplitLine;

            int intStartX = m_arrBuildOcvStartX[i];
            int intStartY = m_arrBuildOcvStartY[i];
            int intEndX = m_arrBuildOcvEndX[i];
            int intEndY = m_arrBuildOcvEndY[i];

            if (m_blnSplitHorizontal)
            {
                m_arrBuildOcvNo.Add(m_arrBuildOcvNo[m_arrBuildOcvSelectStatus.Count - 1] + 1);
                m_arrBuildOcvStartX.Add(intStartX);
                m_arrBuildOcvStartY.Add(intStartY);
                m_arrBuildOcvEndX.Add(intEndX);
                m_arrBuildOcvEndY.Add((int)Math.Round(m_objSplitMarkLine.ref_pStartPoint.Y - 1, 0, MidpointRounding.AwayFromZero));
                m_arrBuildOcvEnableStatus.Add(true);
                m_arrBuildOcvType.Add(m_arrBuildOcvType[i]);
                m_arrBuildOcvSelectStatus.Add(1);
                m_arrBuildOcvSelectStatusPrev.Add(1);
                m_arrBuildOcvCharShiftX.Add(m_arrBuildOcvCharShiftX[i]);
                m_arrBuildOcvCharShiftY.Add(m_arrBuildOcvCharShiftY[i]);

                m_arrBuildOcvNo.Add(m_arrBuildOcvNo[m_arrBuildOcvSelectStatus.Count - 1] + 1);
                m_arrBuildOcvStartX.Add(intStartX);
                m_arrBuildOcvStartY.Add((int)Math.Round(m_objSplitMarkLine.ref_pStartPoint.Y + 1, 0, MidpointRounding.AwayFromZero));
                m_arrBuildOcvEndX.Add(intEndX);
                m_arrBuildOcvEndY.Add(intEndY);
                m_arrBuildOcvEnableStatus.Add(true);
                m_arrBuildOcvType.Add(m_arrBuildOcvType[i]);
                m_arrBuildOcvSelectStatus.Add(1);
                m_arrBuildOcvSelectStatusPrev.Add(1);
                m_arrBuildOcvCharShiftX.Add(m_arrBuildOcvCharShiftX[i]);
                m_arrBuildOcvCharShiftY.Add(m_arrBuildOcvCharShiftY[i]);

                //2021-09-21 ZJYEOH : Collect Split Points
                m_arrBuildOcvSplitStart.Add(new Point(intStartX, (int)Math.Round(m_objSplitMarkLine.ref_pStartPoint.Y - 1, 0, MidpointRounding.AwayFromZero)));
                m_arrBuildOcvSplitEnd.Add(new Point(intEndX, (int)Math.Round(m_objSplitMarkLine.ref_pStartPoint.Y - 1, 0, MidpointRounding.AwayFromZero)));
                m_arrBuildOcvSplitStart.Add(new Point(intStartX, (int)Math.Round(m_objSplitMarkLine.ref_pStartPoint.Y + 1, 0, MidpointRounding.AwayFromZero)));
                m_arrBuildOcvSplitEnd.Add(new Point(intEndX, (int)Math.Round(m_objSplitMarkLine.ref_pStartPoint.Y + 1, 0, MidpointRounding.AwayFromZero)));

            }
            else
            {
                m_arrBuildOcvNo.Add(m_arrBuildOcvNo[m_arrBuildOcvSelectStatus.Count - 1] + 1);
                m_arrBuildOcvStartX.Add(intStartX);
                m_arrBuildOcvStartY.Add(intStartY);
                m_arrBuildOcvEndX.Add((int)Math.Round(m_objSplitMarkLine.ref_pStartPoint.X - 1, 0, MidpointRounding.AwayFromZero));
                m_arrBuildOcvEndY.Add(intEndY);
                m_arrBuildOcvEnableStatus.Add(true);
                m_arrBuildOcvType.Add(m_arrBuildOcvType[i]);
                m_arrBuildOcvSelectStatus.Add(1);
                m_arrBuildOcvSelectStatusPrev.Add(1);
                m_arrBuildOcvCharShiftX.Add(m_arrBuildOcvCharShiftX[i]);
                m_arrBuildOcvCharShiftY.Add(m_arrBuildOcvCharShiftY[i]);

                m_arrBuildOcvNo.Add(m_arrBuildOcvNo[m_arrBuildOcvSelectStatus.Count - 1] + 1);
                m_arrBuildOcvStartX.Add((int)Math.Round(m_objSplitMarkLine.ref_pStartPoint.X + 1, 0, MidpointRounding.AwayFromZero));
                m_arrBuildOcvStartY.Add(intStartY);
                m_arrBuildOcvEndX.Add(intEndX);
                m_arrBuildOcvEndY.Add(intEndY);
                m_arrBuildOcvEnableStatus.Add(true);
                m_arrBuildOcvType.Add(m_arrBuildOcvType[i]);
                m_arrBuildOcvSelectStatus.Add(1);
                m_arrBuildOcvSelectStatusPrev.Add(1);
                m_arrBuildOcvCharShiftX.Add(m_arrBuildOcvCharShiftX[i]);
                m_arrBuildOcvCharShiftY.Add(m_arrBuildOcvCharShiftY[i]);

                //2021-09-21 ZJYEOH : Collect Split Points
                m_arrBuildOcvSplitStart.Add(new Point((int)Math.Round(m_objSplitMarkLine.ref_pStartPoint.X - 1, 0, MidpointRounding.AwayFromZero), intStartY));
                m_arrBuildOcvSplitEnd.Add(new Point((int)Math.Round(m_objSplitMarkLine.ref_pStartPoint.X - 1, 0, MidpointRounding.AwayFromZero), intEndY));
                m_arrBuildOcvSplitStart.Add(new Point((int)Math.Round(m_objSplitMarkLine.ref_pStartPoint.X + 1, 0, MidpointRounding.AwayFromZero), intStartY));
                m_arrBuildOcvSplitEnd.Add(new Point((int)Math.Round(m_objSplitMarkLine.ref_pStartPoint.X + 1, 0, MidpointRounding.AwayFromZero), intEndY));

            }

            RemoveBuildOcvChar(i);
        }

        public void SetSplitLineCancel()
        {
            m_blnIsSplitLineDisplaying = false;
        }

        public bool IsSplitLineDisplaying()
        {
            return m_blnIsSplitLineDisplaying;
        }

        public bool SplitLineHitTest(int intPositionX, int intPositionY)
        {
            if (m_blnIsSplitLineDisplaying)
            {
                return m_objSplitMarkLine.HitTest(intPositionX, intPositionY);
            }

            return false;
        }

        public void DragSplitLine(int intPositionX, int intPositionY)
        {
            if (m_blnIsSplitLineDisplaying)
            {
                int i = m_intSelectedBuildOcvForSplitLine;

                int intStartX = m_arrBuildOcvStartX[i];
                int intStartY = m_arrBuildOcvStartY[i];
                int intEndX = m_arrBuildOcvEndX[i];
                int intEndY = m_arrBuildOcvEndY[i];

                ROI objROI = new ROI();
                objROI.LoadROISetting(intStartX, intStartY, intEndX - intStartX, intEndY - intStartY);
                if (m_blnSplitHorizontal)
                    m_objSplitMarkLine.DragY(intStartY, intEndY, intPositionY);
                else
                    m_objSplitMarkLine.DragX(intStartX, intEndX, intPositionX);
                objROI.Dispose();
            }
        }

        public void ClearSplitLineDragHandler()
        {
            m_objSplitMarkLine.ClearDragHandler();
        }

        public void DisposeLearnBlob()
        {
            // 2020 06 29 - CCENG: Learn Blob not going to dispose after learn bcos will repeat using the same learn blob object everytime learning mark.
            //lock (m_objLockLearningBlobs)
            //{
            //    for (int i = 0; i < m_objLearnBlobs.Length; i++)
            //    {
            //        if (m_objLearnBlobs[i] != null)
            //        {
            //            m_objLearnBlobs[i].Dispose();
            //            m_objLearnBlobs[i] = null;
            //        }
            //    }
            //}
        }

        public void Dispose()
        {
            if (m_objSplitMarkLine != null)
            {

            }

            if (m_objBuildObjectROI != null)
                m_objBuildObjectROI.Dispose();

            if (m_objJointMarkROI != null)
                m_objJointMarkROI.Dispose();

            for (int i = 0; i < m_objLearnBlobs.Length; i++)
            {
                m_objLearnBlobs[i].Dispose();
            }

            for (int i = 0; i < m_objBlobs.Length; i++)
            {
                m_objBlobs[i].Dispose();
            }

            for (int i = 0; i < m_objAveGrayBlobs.Length; i++)
            {
                m_objAveGrayBlobs[i].Dispose();
            }
            
            for (int i = 0; i < m_objJointMarkBlobs.Length; i++)
            {
                m_objJointMarkBlobs[i].Dispose();
            }

            for (int i = 0; i < m_objExcessBlobs.Length; i++)
            {
                m_objExcessBlobs[i].Dispose();
            }

            for (int i = 0; i < m_objMissingBlobs.Length; i++)
            {
                m_objMissingBlobs[i].Dispose();
            }

            for (int i = 0; i < m_objBrokenBlobs.Length; i++)
            {
                m_objBrokenBlobs[i].Dispose();
            }

            for (int i = 0; i < m_arrOCV.Count; i++)
            {
                for (int j = 0; j < m_arrOCV.Count; i++)

                    m_arrOCV[i][j].Dispose();
            }

            for (int i = 0; i < m_arrTemplateSetting.Count; i++)
            {
                for (int j = 0; j < m_arrTemplateSetting.Count; i++)
                {
                    m_arrTemplateSetting[i][j].objTemplateImage.Dispose();
                    //    m_arrTemplateSetting[i][j].objLearnDilateImage.Dispose();
                    //     m_arrTemplateSetting[i][j].objLearnErodeImage.Dispose();

                    for (int k = 0; k < m_arrTemplateSetting[i][j].arrLearnDilateImage.Count; k++)
                    {
                        m_arrTemplateSetting[i][j].arrLearnDilateImage[k].Dispose();
                    }

                    for (int k = 0; k < m_arrTemplateSetting[i][j].arrLearnErodeImage.Count; k++)
                    {
                        m_arrTemplateSetting[i][j].arrLearnErodeImage[k].Dispose();
                    }

                    for (int k = 0; k < m_arrTemplateSetting[i][j].arrTemplateTextROI.Count; k++)
                    {
                        if (m_arrTemplateSetting[i][j].arrTemplateTextROI[k] != null)
                            m_arrTemplateSetting[i][j].arrTemplateTextROI[k].Dispose();
                    }

                    for (int k = 0; k < m_arrTemplateSetting[i][j].arrTemplateCharErodeROI.Count; k++)
                    {
                        if (m_arrTemplateSetting[i][j].arrTemplateCharErodeROI[k] != null)
                            m_arrTemplateSetting[i][j].arrTemplateCharErodeROI[k].Dispose();
                    }

                    for (int k = 0; k < m_arrTemplateSetting[i][j].arrTemplateCharDilateROI.Count; k++)
                    {
                        if (m_arrTemplateSetting[i][j].arrTemplateCharDilateROI[k] != null)
                            m_arrTemplateSetting[i][j].arrTemplateCharDilateROI[k].Dispose();
                    }
                }
            }

        }

        public void SetCharShiftedSeting(float fShiftedXSetValue, float fShiftedYSetValue)
        {
            switch (m_intDisplayUnitMode)
            {
                case 0: // Pixel
                    for (int i = 0; i < m_arrBuildOcvSelectStatus.Count; i++)
                    {
                        if (m_arrBuildOcvSelectStatus[i] == 2)
                        {
                            if (fShiftedXSetValue >= 0)
                                m_arrBuildOcvCharShiftX[i] = fShiftedXSetValue;

                            if (fShiftedYSetValue >= 0)
                                m_arrBuildOcvCharShiftY[i] = fShiftedYSetValue;
                        }
                    }
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    for (int i = 0; i < m_arrBuildOcvSelectStatus.Count; i++)
                    {
                        if (m_arrBuildOcvSelectStatus[i] == 2)
                        {
                            if (fShiftedXSetValue >= 0)
                                m_arrBuildOcvCharShiftX[i] = (fShiftedXSetValue / m_fMMToUnitValue) / m_fMMPerPixelX;

                            if (fShiftedYSetValue >= 0)
                                m_arrBuildOcvCharShiftY[i] = (fShiftedYSetValue / m_fMMToUnitValue) / m_fMMPerPixelY;
                        }
                    }
                    break;
            }
        }
        public void SetTextShiftedSeting(float fShiftedXSetValue, float fShiftedYSetValue, int intSelectedUnit, int intSelectedTemplate)
        {
            switch (m_intDisplayUnitMode)
            {
                case 0: // Pixel
                    if (m_arrTemplateSetting.Count > intSelectedUnit)
                    {
                        if (m_arrTemplateSetting[intSelectedUnit].Count > intSelectedTemplate)
                        {
                            if (fShiftedXSetValue >= 0)
                                m_arrTemplateSetting[intSelectedUnit][intSelectedTemplate].fTextShiftX = fShiftedXSetValue;

                            if (fShiftedYSetValue >= 0)
                                m_arrTemplateSetting[intSelectedUnit][intSelectedTemplate].fTextShiftY = fShiftedYSetValue;
                        }
                    }
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    if (m_arrTemplateSetting.Count > intSelectedUnit)
                    {
                        if (m_arrTemplateSetting[intSelectedUnit].Count > intSelectedTemplate)
                        {
                            if (fShiftedXSetValue >= 0)
                                m_arrTemplateSetting[intSelectedUnit][intSelectedTemplate].fTextShiftX = (fShiftedXSetValue / m_fMMToUnitValue) / m_fMMPerPixelX;

                            if (fShiftedYSetValue >= 0)
                                m_arrTemplateSetting[intSelectedUnit][intSelectedTemplate].fTextShiftY = (fShiftedYSetValue / m_fMMToUnitValue) / m_fMMPerPixelY;
                        }
                    }
                    break;
            }


        }
        public string SetSelectedTextShiftedXSetting(int intSelectedUnit, int intSelectedTemplate)
        {
            if (m_arrTemplateSetting.Count > intSelectedUnit)
            {
                if (m_arrTemplateSetting[intSelectedUnit].Count > intSelectedTemplate)
                    return m_arrTemplateSetting[intSelectedUnit][intSelectedTemplate].fTextShiftX.ToString();
                else
                    return "";
            }
            else
                return "";
        }
        public string GetSelectedTextShiftedXSetting(int intSelectedUnit, int intSelectedTemplate)
        {
            if (m_arrTemplateSetting.Count > intSelectedUnit)
            {
                if (m_arrTemplateSetting[intSelectedUnit].Count > intSelectedTemplate)
                {
                    switch (m_intDisplayUnitMode)
                    {
                        case 0: // Pixel
                            return m_arrTemplateSetting[intSelectedUnit][intSelectedTemplate].fTextShiftX.ToString();
                        case 1: // mm
                        case 2: // mil
                        case 3: // micron
                            return ((m_arrTemplateSetting[intSelectedUnit][intSelectedTemplate].fTextShiftX * m_fMMPerPixelX) * m_fMMToUnitValue).ToString(GetDecimalFormat());
                        default:
                            return "";
                    }

                }
                else
                    return "";
            }
            else
                return "";
        }
        public string GetSelectedTextShiftedYSetting(int intSelectedUnit, int intSelectedTemplate)
        {
            if (m_arrTemplateSetting.Count > intSelectedUnit)
            {
                if (m_arrTemplateSetting[intSelectedUnit].Count > intSelectedTemplate)
                {
                    switch (m_intDisplayUnitMode)
                    {
                        case 0: // Pixel
                            return m_arrTemplateSetting[intSelectedUnit][intSelectedTemplate].fTextShiftY.ToString();
                        case 1: // mm
                        case 2: // mil
                        case 3: // micron
                            return ((m_arrTemplateSetting[intSelectedUnit][intSelectedTemplate].fTextShiftY * m_fMMPerPixelY) * m_fMMToUnitValue).ToString(GetDecimalFormat());
                        default:
                            return "";
                    }
                }
                else
                    return "";
            }
            else
                return "";
        }
        public string GetSelectedCharShiftedXSetting()
        {
            bool blnAreAllSelectedCharHasSameShiftedValue = true;

            float fFirstShifted = -1;
            for (int i = 0; i < m_arrBuildOcvSelectStatus.Count; i++)
            {
                if (m_arrBuildOcvSelectStatus[i] == 2)
                {
                    if (fFirstShifted == -1)
                        fFirstShifted = m_arrBuildOcvCharShiftX[i];

                    if (fFirstShifted != m_arrBuildOcvCharShiftX[i])
                        blnAreAllSelectedCharHasSameShiftedValue = false;
                }
            }

            if (blnAreAllSelectedCharHasSameShiftedValue)
            {
                switch (m_intDisplayUnitMode)
                {
                    case 0: // Pixel
                        return fFirstShifted.ToString(GetDecimalFormat());
                    case 1: // mm
                    case 2: // mil
                    case 3: // micron
                        return ((fFirstShifted * m_fMMPerPixelX) * m_fMMToUnitValue).ToString(GetDecimalFormat());
                    default:
                        return "";
                }
            }
            else
                return "";
        }

        public string GetSelectedCharShiftedYSetting()
        {
            bool blnAreAllSelectedCharHasSameShiftedValue = true;

            float fFirstShifted = -1;
            for (int i = 0; i < m_arrBuildOcvSelectStatus.Count; i++)
            {
                if (m_arrBuildOcvSelectStatus[i] == 2)
                {
                    if (fFirstShifted == -1)
                        fFirstShifted = m_arrBuildOcvCharShiftY[i];

                    if (fFirstShifted != m_arrBuildOcvCharShiftY[i])
                        blnAreAllSelectedCharHasSameShiftedValue = false;
                }
            }

            if (blnAreAllSelectedCharHasSameShiftedValue)
            {
                switch (m_intDisplayUnitMode)
                {
                    case 0: // Pixel
                        return fFirstShifted.ToString(GetDecimalFormat());
                    case 1: // mm
                    case 2: // mil
                    case 3: // micron
                        return ((fFirstShifted * m_fMMPerPixelY) * m_fMMToUnitValue).ToString(GetDecimalFormat());
                    default:
                        return "";
                }
            }
            else
                return "";
        }

        public float GetCharMaxExcessAreaSetting(int intCharIndex, int intGroupIndex, int intTemplateIndex)
        {
            if (intCharIndex >= m_arrTemplateSetting[intGroupIndex][intTemplateIndex].arrMaxExcessArea.Count)
                return -1;

            switch (m_intDisplayUnitMode)
            {
                case 0: // Pixel
                    return m_arrTemplateSetting[intGroupIndex][intTemplateIndex].arrMaxExcessArea[intCharIndex];
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return (m_arrTemplateSetting[intGroupIndex][intTemplateIndex].arrMaxExcessArea[intCharIndex] * m_fMMPerPixelArea) * m_fMMToUnitValueArea;
                default:
                    return 0;
            }
        }

        public float GetCharMaxBrokenAreaSetting(int intCharIndex, int intGroupIndex, int intTemplateIndex)
        {
            if (intCharIndex >= m_arrTemplateSetting[intGroupIndex][intTemplateIndex].arrMaxBrokenArea.Count)
                return -1;

            switch (m_intDisplayUnitMode)
            {
                case 0: // Pixel
                    return m_arrTemplateSetting[intGroupIndex][intTemplateIndex].arrMaxBrokenArea[intCharIndex];
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return (m_arrTemplateSetting[intGroupIndex][intTemplateIndex].arrMaxBrokenArea[intCharIndex] * m_fMMPerPixelArea) * m_fMMToUnitValueArea;
                default:
                    return 0;
            }
        }
        public bool GetCharWantBrokenMarkSetting(int intCharIndex, int intGroupIndex, int intTemplateIndex)
        {
            if (intCharIndex >= m_arrTemplateSetting[intGroupIndex][intTemplateIndex].arrWantBrokenMark.Count)
                return false;

            return m_arrTemplateSetting[intGroupIndex][intTemplateIndex].arrWantBrokenMark[intCharIndex];
        }
        public int GetMarktype(int intCharIndex, int intGroupIndex, int intTemplateIndex)
        {
            if (!m_blnWantUseMarkTypeInspectionSetting)
                return 0;

            if (intCharIndex >= m_arrTemplateSetting[intGroupIndex][intTemplateIndex].arrMarkType.Count)
                return 0;

            return m_arrTemplateSetting[intGroupIndex][intTemplateIndex].arrMarkType[intCharIndex];
        }
        public void SetCharEnable(bool blnEnable)
        {
            for (int i = 0; i < m_arrTemplateSetting[m_intGroupIndex].Count; i++)
            {
                for (int j = 0; j < m_arrTemplateSetting[m_intGroupIndex][i].blnEnable.Count; j++)
                {
                    m_arrTemplateSetting[m_intGroupIndex][i].blnEnable[j] = blnEnable;
                }
            }
        }
        public void SetCharEnable(int intCharIndex, bool blnEnable)
        {
            if (intCharIndex < m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable.Count)
            {
                m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[intCharIndex] = blnEnable;
            }
        }

        public void SetCharEnable(int intCharIndex, bool blnEnable, bool blnSetToAllTemplate)
        {
            if (blnSetToAllTemplate)
            {
                for (int i = 0; i < m_arrTemplateSetting[m_intGroupIndex].Count; i++)
                {
                    if (intCharIndex < m_arrTemplateSetting[m_intGroupIndex][i].blnEnable.Count)
                    {
                        m_arrTemplateSetting[m_intGroupIndex][i].blnEnable[intCharIndex] = blnEnable;
                    }
                }
            }
            else
            {
                if (m_intTemplateIndex < m_arrTemplateSetting[m_intGroupIndex].Count)
                {
                    if (intCharIndex < m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable.Count)
                    {
                        m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[intCharIndex] = blnEnable;
                    }
                }
            }
        }
        public void SetCharMaxExcessAreaSetting(float fSetValue)
        {
            switch (m_intDisplayUnitMode)
            {
                case 0: // Pixel
                    for (int i = 0; i < m_arrTemplateSetting[m_intGroupIndex].Count; i++)
                    {
                        for (int j = 0; j < m_arrTemplateSetting[m_intGroupIndex][i].arrMaxExcessArea.Count; j++)
                        {
                            if (!CheckWantInspectExcessMark(m_arrTemplateSetting[m_intGroupIndex][i].arrMarkType[j]))
                                continue;

                            m_arrTemplateSetting[m_intGroupIndex][i].arrMaxExcessArea[j] = fSetValue;
                        }
                    }
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    for (int i = 0; i < m_arrTemplateSetting[m_intGroupIndex].Count; i++)
                    {
                        for (int j = 0; j < m_arrTemplateSetting[m_intGroupIndex][i].arrMaxExcessArea.Count; j++)
                        {
                            if (!CheckWantInspectExcessMark(m_arrTemplateSetting[m_intGroupIndex][i].arrMarkType[j]))
                                continue;

                            m_arrTemplateSetting[m_intGroupIndex][i].arrMaxExcessArea[j] = (fSetValue / m_fMMToUnitValueArea) / m_fMMPerPixelArea;
                        }
                    }
                    break;
            }

        }
        public void SetCharMaxExcessAreaSetting(int intCharIndex, float fSetValue)
        {
            switch (m_intDisplayUnitMode)
            {
                case 0: // Pixel
                    if (intCharIndex < m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMaxExcessArea.Count)
                    {
                        if (CheckWantInspectExcessMark(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMarkType[intCharIndex]))
                            m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMaxExcessArea[intCharIndex] = fSetValue;

                    }
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    if (intCharIndex < m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMaxExcessArea.Count)
                    {
                        if (CheckWantInspectExcessMark(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMarkType[intCharIndex]))
                            m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMaxExcessArea[intCharIndex] = (fSetValue / m_fMMToUnitValueArea) / m_fMMPerPixelArea;

                    }
                    break;
            }
        }

        public void SetCharMaxExcessAreaSetting(int intCharIndex, float fSetValue, bool blnSetToAllTemplate)
        {
            switch (m_intDisplayUnitMode)
            {
                case 0: // Pixel
                    if (blnSetToAllTemplate)
                    {
                        for (int i = 0; i < m_arrTemplateSetting[m_intGroupIndex].Count; i++)
                        {
                            if (intCharIndex < m_arrTemplateSetting[m_intGroupIndex][i].arrMaxExcessArea.Count)
                            {
                                if (!CheckWantInspectExcessMark(m_arrTemplateSetting[m_intGroupIndex][i].arrMarkType[intCharIndex]))
                                    continue;

                                m_arrTemplateSetting[m_intGroupIndex][i].arrMaxExcessArea[intCharIndex] = fSetValue;
                            }
                        }
                    }
                    else
                    {
                        if (m_intTemplateIndex < m_arrTemplateSetting[m_intGroupIndex].Count)
                        {
                            if (intCharIndex < m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMaxExcessArea.Count)
                            {
                                if (CheckWantInspectExcessMark(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMarkType[intCharIndex]))
                                    m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMaxExcessArea[intCharIndex] = fSetValue;
                            }
                        }
                    }
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    if (blnSetToAllTemplate)
                    {
                        for (int i = 0; i < m_arrTemplateSetting[m_intGroupIndex].Count; i++)
                        {
                            if (intCharIndex < m_arrTemplateSetting[m_intGroupIndex][i].arrMaxExcessArea.Count)
                            {
                                if (!CheckWantInspectExcessMark(m_arrTemplateSetting[m_intGroupIndex][i].arrMarkType[intCharIndex]))
                                    continue;

                                m_arrTemplateSetting[m_intGroupIndex][i].arrMaxExcessArea[intCharIndex] = (fSetValue / m_fMMToUnitValueArea) / m_fMMPerPixelArea;
                            }
                        }
                    }
                    else
                    {
                        if (m_intTemplateIndex < m_arrTemplateSetting[m_intGroupIndex].Count)
                        {
                            if (intCharIndex < m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMaxExcessArea.Count)
                            {
                                if (CheckWantInspectExcessMark(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMarkType[intCharIndex]))
                                    m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMaxExcessArea[intCharIndex] = (fSetValue / m_fMMToUnitValueArea) / m_fMMPerPixelArea;
                            }
                        }
                    }
                    break;
            }


        }
        public void SetCharMaxBrokenAreaSetting(float fSetValue)
        {
            switch (m_intDisplayUnitMode)
            {
                case 0: // Pixel
                    for (int i = 0; i < m_arrTemplateSetting[m_intGroupIndex].Count; i++)
                    {
                        for (int j = 0; j < m_arrTemplateSetting[m_intGroupIndex][i].arrMaxBrokenArea.Count; j++)
                        {
                            if (!CheckWantInspectMissingMark(m_arrTemplateSetting[m_intGroupIndex][i].arrMarkType[j]))
                                continue;
                            m_arrTemplateSetting[m_intGroupIndex][i].arrMaxBrokenArea[j] = fSetValue;
                        }
                    }
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    for (int i = 0; i < m_arrTemplateSetting[m_intGroupIndex].Count; i++)
                    {
                        for (int j = 0; j < m_arrTemplateSetting[m_intGroupIndex][i].arrMaxBrokenArea.Count; j++)
                        {
                            if (!CheckWantInspectMissingMark(m_arrTemplateSetting[m_intGroupIndex][i].arrMarkType[j]))
                                continue;
                            m_arrTemplateSetting[m_intGroupIndex][i].arrMaxBrokenArea[j] = (fSetValue / m_fMMToUnitValueArea) / m_fMMPerPixelArea;
                        }
                    }
                    break;
            }
        }
        public void SetCharMaxBrokenAreaSetting(int intCharIndex, float fSetValue)
        {
            switch (m_intDisplayUnitMode)
            {
                case 0: // Pixel
                    if (intCharIndex < m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMaxBrokenArea.Count)
                    {
                        if (CheckWantInspectMissingMark(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMarkType[intCharIndex]))
                            m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMaxBrokenArea[intCharIndex] = fSetValue;
                    }
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    if (intCharIndex < m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMaxBrokenArea.Count)
                    {
                        if (CheckWantInspectMissingMark(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMarkType[intCharIndex]))
                            m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMaxBrokenArea[intCharIndex] = (fSetValue / m_fMMToUnitValueArea) / m_fMMPerPixelArea;
                    }
                    break;
            }
        }

        public void SetCharWantBrokenMarkSetting(bool bSetValue)
        {
            for (int i = 0; i < m_arrTemplateSetting[m_intGroupIndex].Count; i++)
            {
                for (int j = 0; j < m_arrTemplateSetting[m_intGroupIndex][i].arrWantBrokenMark.Count; j++)
                {
                    if (!CheckWantInspectMissingMark(m_arrTemplateSetting[m_intGroupIndex][i].arrMarkType[j]))
                        continue;

                    m_arrTemplateSetting[m_intGroupIndex][i].arrWantBrokenMark[j] = bSetValue;
                }
            }
        }
        public void SetCharWantBrokenMarkSetting(int intCharIndex, bool bSetValue)
        {
            if (intCharIndex < m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrWantBrokenMark.Count)
            {
                if (CheckWantInspectMissingMark(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMarkType[intCharIndex]))
                    m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrWantBrokenMark[intCharIndex] = bSetValue;
            }
        }


        public void SetCharMaxBrokenAreaSetting(int intCharIndex, float fSetValue, bool blnSetToAllTemplate)
        {
            switch (m_intDisplayUnitMode)
            {
                case 0: // Pixel
                    if (blnSetToAllTemplate)
                    {
                        for (int i = 0; i < m_arrTemplateSetting[m_intGroupIndex].Count; i++)
                        {
                            if (intCharIndex < m_arrTemplateSetting[m_intGroupIndex][i].arrMaxBrokenArea.Count)
                            {
                                if (!CheckWantInspectMissingMark(m_arrTemplateSetting[m_intGroupIndex][i].arrMarkType[intCharIndex]))
                                    continue;
                                m_arrTemplateSetting[m_intGroupIndex][i].arrMaxBrokenArea[intCharIndex] = fSetValue;
                            }
                        }
                    }
                    else
                    {
                        if (m_intTemplateIndex < m_arrTemplateSetting[m_intGroupIndex].Count)
                        {
                            if (intCharIndex < m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMaxBrokenArea.Count)
                            {
                                if (CheckWantInspectMissingMark(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMarkType[intCharIndex]))
                                {

                                    m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMaxBrokenArea[intCharIndex] = fSetValue;
                                }
                            }
                        }
                    }
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    if (blnSetToAllTemplate)
                    {
                        for (int i = 0; i < m_arrTemplateSetting[m_intGroupIndex].Count; i++)
                        {
                            if (intCharIndex < m_arrTemplateSetting[m_intGroupIndex][i].arrMaxBrokenArea.Count)
                            {
                                if (!CheckWantInspectMissingMark(m_arrTemplateSetting[m_intGroupIndex][i].arrMarkType[intCharIndex]))
                                    continue;
                                m_arrTemplateSetting[m_intGroupIndex][i].arrMaxBrokenArea[intCharIndex] = (fSetValue / m_fMMToUnitValueArea) / m_fMMPerPixelArea;
                            }
                        }
                    }
                    else
                    {
                        if (m_intTemplateIndex < m_arrTemplateSetting[m_intGroupIndex].Count)
                        {
                            if (intCharIndex < m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMaxBrokenArea.Count)
                            {
                                if (CheckWantInspectMissingMark(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMarkType[intCharIndex]))
                                {

                                    m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMaxBrokenArea[intCharIndex] = (fSetValue / m_fMMToUnitValueArea) / m_fMMPerPixelArea;
                                }
                            }
                        }
                    }
                    break;
            }
        }

        public void SetCharWantBrokenMarkSetting(int intCharIndex, bool bSetValue, bool blnSetToAllTemplate)
        {
            if (blnSetToAllTemplate)
            {
                for (int i = 0; i < m_arrTemplateSetting[m_intGroupIndex].Count; i++)
                {
                    if (intCharIndex < m_arrTemplateSetting[m_intGroupIndex][i].arrWantBrokenMark.Count)
                    {
                        if (!CheckWantInspectBrokenMark(m_arrTemplateSetting[m_intGroupIndex][i].arrMarkType[intCharIndex]))
                            continue;

                        m_arrTemplateSetting[m_intGroupIndex][i].arrWantBrokenMark[intCharIndex] = bSetValue;
                    }
                }
            }
            else
            {
                if (m_intTemplateIndex < m_arrTemplateSetting[m_intGroupIndex].Count)
                {
                    if (intCharIndex < m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrWantBrokenMark.Count)
                    {
                        if (CheckWantInspectBrokenMark(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrMarkType[intCharIndex]))
                        {
                            m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrWantBrokenMark[intCharIndex] = bSetValue;
                        }
                    }
                }
            }
        }
        public float GetCharExcessArea(int intCharIndex, int intGroupIndex, int intTemplateIndex)
        {
            if (intTemplateIndex >= m_arrCharExcessAreaResult.Length)
                return 0;

            if (m_arrCharExcessAreaResult[intTemplateIndex] == null)
                return 0;

            if (intCharIndex >= m_arrCharExcessAreaResult[intTemplateIndex].Length)
                return 0;

            switch (m_intDisplayUnitMode)
            {
                case 0: // Pixel
                    return m_arrCharExcessAreaResult[intTemplateIndex][intCharIndex];
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return (m_arrCharExcessAreaResult[intTemplateIndex][intCharIndex] * m_fMMPerPixelArea) * m_fMMToUnitValueArea;
                default:
                    return 0;
            }
        }

        public float GetCharBrokenArea(int intCharIndex, int intGroupIndex, int intTemplateIndex)
        {
            if (intTemplateIndex >= m_arrCharBrokenAreaResult.Length)
                return 0;

            if (m_arrCharBrokenAreaResult[intTemplateIndex] == null)
                return 0;

            if (intCharIndex >= m_arrCharBrokenAreaResult[intTemplateIndex].Length)
                return 0;

            switch (m_intDisplayUnitMode)
            {
                case 0: // Pixel
                    return m_arrCharBrokenAreaResult[intTemplateIndex][intCharIndex];
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return (m_arrCharBrokenAreaResult[intTemplateIndex][intCharIndex] * m_fMMPerPixelArea) * m_fMMToUnitValueArea;
                default:
                    return 0;
            }
        }
        public bool GetCharBrokenMark(int intCharIndex, int intGroupIndex, int intTemplateIndex)
        {
            if (intTemplateIndex >= m_arrCharBrokenMarkResult.Length)
                return false;

            if (m_arrCharBrokenMarkResult[intTemplateIndex] == null)
                return false;

            if (intCharIndex >= m_arrCharBrokenMarkResult[intTemplateIndex].Length)
                return false;

            return m_arrCharBrokenMarkResult[intTemplateIndex][intCharIndex];
        }
        public bool GetCharJointMark(int intCharIndex, int intGroupIndex, int intTemplateIndex)
        {
            if (intTemplateIndex >= m_arrCharJointMarkResult.Length)
                return false;

            if (m_arrCharJointMarkResult[intTemplateIndex] == null)
                return false;

            if (intCharIndex >= m_arrCharJointMarkResult[intTemplateIndex].Length)
                return false;

            return m_arrCharJointMarkResult[intTemplateIndex][intCharIndex];
        }
        public bool GetCharWantBrokenMark(int intCharIndex, int intGroupIndex, int intTemplateIndex)
        {
            if (intTemplateIndex >= m_arrCharWantBrokenMarkResult.Length)
                return false;

            if (m_arrCharWantBrokenMarkResult[intTemplateIndex] == null)
                return false;

            if (intCharIndex >= m_arrCharWantBrokenMarkResult[intTemplateIndex].Length)
                return false;

            return m_arrCharWantBrokenMarkResult[intTemplateIndex][intCharIndex];
        }

        public void Draw2DCodeObjects(Graphics g, float fDrawingScaleX, float fDrawingScaleY)
        {
            m_objMark2DCode.DrawBarcodeResult(g, fDrawingScaleX, fDrawingScaleY);
        }

        public bool Read2DCodeObjects(ROI objROI, int int2DCodeType)
        {
            if (m_objMark2DCode.ReadCodeObjects(objROI, int2DCodeType) == 1)
                return true;
            else
                return false;
        }

        public string Get2DCodeResult()
        {
            if (m_objMark2DCode.ref_strResultCode == "")
                return "-----";
            else
                return m_objMark2DCode.ref_strResultCode;
        }

        public bool Get2DCodeFound()
        {
            return m_objMark2DCode.ref_blnCodeFound;
        }

        public bool Get2DCodePassed()
        {
            return m_objMark2DCode.ref_blnPassedCode;
        }

        public string Get2DCodeErrorMessage()
        {
            return m_objMark2DCode.ref_strErrorMessage;
        }

        public void Get2DCodeStartEndXY(ref int intStartX, ref int intStartY, ref int intEndX, ref int intEndY)
        {
            intStartX = Convert.ToInt32(m_objMark2DCode.ref_fOrgX);
            intStartY = Convert.ToInt32(m_objMark2DCode.ref_fOrgY);
            intEndX = intStartX + Convert.ToInt32(m_objMark2DCode.ref_fSizeX);
            intEndY = intStartY + Convert.ToInt32(m_objMark2DCode.ref_fSizeY);
        }

        public bool GetCharIsBarPin1(int intGroupIndex, int intTemplateIndex, int intCharIndex)
        {
            if (intTemplateIndex < 0)
                return false;

            if (m_arrTemplateSetting.Count <= intGroupIndex)
                return false;

            if (m_arrTemplateSetting[intGroupIndex].Count <= intTemplateIndex)
                return false;

            if (m_arrTemplateSetting[intGroupIndex][intTemplateIndex].blnIsBarPin1.Count <= intCharIndex)
                return false;

            return m_arrTemplateSetting[intGroupIndex][intTemplateIndex].blnIsBarPin1[intCharIndex];
        }

        public int GetCharBarPin1Type(int intGroupIndex, int intTemplateIndex, int intCharIndex)
        {
            if (intTemplateIndex < 0)
                return 0;

            if (m_arrTemplateSetting.Count <= intGroupIndex)
                return 0;

            if (m_arrTemplateSetting[intGroupIndex].Count <= intTemplateIndex)
                return 0;

            if (m_arrTemplateSetting[intGroupIndex][intTemplateIndex].blnIsBarPin1.Count <= intCharIndex)
                return 0;

            return m_arrTemplateSetting[intGroupIndex][intTemplateIndex].arrBarPin1Type[intCharIndex];
        }

        public float GetMarkAngleTolerance(int intGroupIndex, int intTemplateIndex)
        {
            if (intTemplateIndex < 0)
                return 0;

            if (m_arrTemplateSetting.Count <= intGroupIndex)
                return 0;

            if (m_arrTemplateSetting[intGroupIndex].Count <= intTemplateIndex)
                return 0;

            return m_arrTemplateSetting[intGroupIndex][intTemplateIndex].fMarkAngleTolerance;
        }

        public void SetMarkAngleTolerance(float fMarkAngleTolerance, bool blnSetToAllTemplate)
        {
            if (blnSetToAllTemplate)
            {
                for (int i = 0; i < m_arrTemplateSetting[m_intGroupIndex].Count; i++)
                    m_arrTemplateSetting[m_intGroupIndex][i].fMarkAngleTolerance = fMarkAngleTolerance;
            }
            else
            {
                if (m_intTemplateIndex < m_arrTemplateSetting[m_intGroupIndex].Count)
                    m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].fMarkAngleTolerance = fMarkAngleTolerance;
            }
        }
        public void SetPreviosCharShiftXY()
        {
            if (m_arrOCV[m_intGroupIndex][m_intTemplateIndex].GetNumChars() == 0)
            {
                // Use last template set to current learn template
                if (m_intTemplateIndex > 0)
                {
                    float[] arrXToleranceChars = m_arrOCV[m_intGroupIndex][m_intTemplateIndex - 1].GetCharsShiftX();
                    float[] arrYToleranceChars = m_arrOCV[m_intGroupIndex][m_intTemplateIndex - 1].GetCharsShiftY();

                    for (int i = 0; i < arrXToleranceChars.Length; i++)
                    {
                        if ((arrXToleranceChars[i] - m_fCharROIOffsetX) >= 0)
                            arrXToleranceChars[i] = arrXToleranceChars[i] - m_fCharROIOffsetX;
                    }

                    for (int i = 0; i < arrYToleranceChars.Length; i++)
                    {
                        if ((arrYToleranceChars[i] - m_fCharROIOffsetY) >= 0)
                            arrYToleranceChars[i] = arrYToleranceChars[i] - m_fCharROIOffsetY;
                    }

                    for (int i = 0; i < m_arrBuildOcvCharShiftX.Count; i++)
                    {
                        if (i < arrXToleranceChars.Length)
                            m_arrBuildOcvCharShiftX[i] = arrXToleranceChars[i];
                    }

                    for (int i = 0; i < m_arrBuildOcvCharShiftY.Count; i++)
                    {
                        if (i < arrYToleranceChars.Length)
                            m_arrBuildOcvCharShiftY[i] = arrYToleranceChars[i];
                    }


                    if (arrXToleranceChars.Length > 0 && arrYToleranceChars.Length > 0)
                        m_objOCV.SetCharsShiftXY(arrXToleranceChars, arrYToleranceChars, m_fCharROIOffsetX, m_fCharROIOffsetY);
                }
                else //Set value 5 as default to shift XY
                    m_objOCV.SetCharsShiftXY(5 + m_fCharROIOffsetX, 5 + m_fCharROIOffsetY);
            }
        }
        public void SetCurrentCharShiftXY(string strFolderPath)
        {
            XmlParser objFile = new XmlParser(strFolderPath + "Template.xml");
            objFile.GetFirstSection("MarkSettings");

            for (int i = 0; i < m_intGroupNum; i++)
            {
                objFile.GetFirstSection("Group" + i);

                int intTemplateNum = objFile.GetValueAsInt("TemplateNum", 0);

                if (intTemplateNum != 0)
                    return;
                else
                    intTemplateNum = 1;

                for (int j = 0; j < intTemplateNum; j++)
                {
                    if (j < m_arrTemplateSetting[i].Count)
                    {
                        objFile.GetSecondSection("Template" + j);

                        int intCount;
                        objFile.GetThirdSection("CharShiftX");
                        intCount = objFile.GetFourthSectionCount();
                        for (int k = 0; k < m_arrBuildOcvCharShiftX.Count; k++)
                        {
                            if (k >= intCount)
                            {
                                m_arrBuildOcvCharShiftX[k] = objFile.GetValueAsFloat("CharShiftX" + (intCount - 1), 5, 3);
                            }
                            else
                            {
                                m_arrBuildOcvCharShiftX[k] = objFile.GetValueAsFloat("CharShiftX" + k, 5, 3);
                            }
                        }

                        objFile.GetThirdSection("CharShiftY");
                        intCount = objFile.GetFourthSectionCount();
                        for (int k = 0; k < m_arrBuildOcvCharShiftY.Count; k++)
                        {
                            if (k >= intCount)
                            {
                                m_arrBuildOcvCharShiftY[k] = objFile.GetValueAsFloat("CharShiftY" + (intCount - 1), 5, 3);
                            }
                            else
                            {
                                m_arrBuildOcvCharShiftY[k] = objFile.GetValueAsFloat("CharShiftY" + k, 5, 3);
                            }
                        }

                    }

                }
            }
        }
        public void SetCurrentCharType(string strFolderPath)
        {
            XmlParser objFile = new XmlParser(strFolderPath + "Template.xml");
            objFile.GetFirstSection("MarkSettings");

            for (int i = 0; i < m_intGroupNum; i++)
            {
                objFile.GetFirstSection("Group" + i);

                int intTemplateNum = objFile.GetValueAsInt("TemplateNum", 0);

                if (intTemplateNum != 0)
                    return;
                else
                    intTemplateNum = 1;

                for (int j = 0; j < intTemplateNum; j++)
                {
                    if (j < m_arrTemplateSetting[i].Count)
                    {
                        objFile.GetSecondSection("Template" + j);

                        int intCount;
                        objFile.GetThirdSection("MarkType");
                        intCount = objFile.GetFourthSectionCount();
                        for (int k = 0; k < m_arrBuildOcvType.Count; k++)
                        {
                            if (k >= intCount)
                            {
                                m_arrBuildOcvType[k] = objFile.GetValueAsInt("MarkType" + (intCount - 1), 0, 3);
                            }
                            else
                            {
                                m_arrBuildOcvType[k] = objFile.GetValueAsInt("MarkType" + k, 0, 3);
                            }
                        }

                    }

                }
            }
        }
        public void SetCurrentThreshold(string strFolderPath, int intGroupIndex, int intTemplateIndex)
        {
            XmlParser objFile = new XmlParser(strFolderPath + "Template.xml");
            objFile.GetFirstSection("MarkSettings");

            for (int i = 0; i < m_intGroupNum; i++)
            {
                objFile.GetFirstSection("Group" + i);

                int intTemplateNum = objFile.GetValueAsInt("TemplateNum", 0);

                if (intTemplateNum != 0)
                    return;
                else
                    intTemplateNum = 1;

                for (int j = 0; j < intTemplateNum; j++)
                {
                    if (j < m_arrTemplateSetting[i].Count)
                    {
                        objFile.GetSecondSection("Template" + j);
                        m_arrTemplateSetting[intGroupIndex][intTemplateIndex].intThreshold = objFile.GetValueAsInt("Threshold", -4, 2);

                    }

                }
            }
        }
        private NOCV GetNOCVSetting()
        {
            NOCV objNOCV;
            if (m_arrOCVPrev.Count > 0)
            {
                objNOCV = m_arrOCVPrev[m_arrOCVPrev.Count - 1];

                m_arrOCVPrev.RemoveAt(m_arrOCVPrev.Count - 1);
            }
            else
                objNOCV = new NOCV(m_intImageWidth, m_intImageHeight);

            return objNOCV;
        }
        private void ClearNOCVSettingArray(int intGroupIndex, bool blnWantDispose)
        {
            if (intGroupIndex >= m_arrOCV.Count)
                return;

            for (int n = m_arrOCV[intGroupIndex].Count - 1; n >= 0; n--)
            {
                m_arrOCV[intGroupIndex][n].ClearCharData();
                m_arrOCVPrev.Add(m_arrOCV[intGroupIndex][n]);
            }

            if (blnWantDispose) // 2020-05-29 ZJYEOH : If dispose, the m_arrOCVPrev will be empty
            {
                //for (int m = 0; m < m_arrOCV.Count; m++)
                //{
                //    for (int n = 0; n < m_arrOCV[m].Count; n++)
                //    {
                //        if (m_arrOCV[m][n] != null)
                //        {
                //            m_arrOCV[m][n].Dispose();
                //            m_arrOCV[m][n] = null;
                //        }

                //    }
                //}
            }

            m_arrOCV[intGroupIndex].Clear();
        }

        private void RemoveRangeNOCVSettingArray()
        {
            if (m_arrOCV[m_intGroupIndex].Count > 0)
            {
                for (int n = m_arrOCV[m_intGroupIndex].Count - 1; n >= 1; n--)
                {
                    m_arrOCV[m_intGroupIndex][n].ClearCharData();
                    m_arrOCVPrev.Add(m_arrOCV[m_intGroupIndex][n]);
                }

                m_arrOCV[m_intGroupIndex].RemoveRange(1, m_arrOCV[m_intGroupIndex].Count - 1);
            }
        }

        private TemplateSetting GetTemplateSetting()
        {
            TemplateSetting objTemplateSetting;
            if (m_arrTemplateSettingPrev.Count > 0)
            {
                objTemplateSetting = m_arrTemplateSettingPrev[m_arrTemplateSettingPrev.Count - 1];
                objTemplateSetting.intCharSetting.Clear();
                objTemplateSetting.intCharDividedLargestArea.Clear();
                objTemplateSetting.fAverageGray.Clear();
                objTemplateSetting.fMaxAGVPercent.Clear();
                objTemplateSetting.arrMaxExcessArea.Clear();
                objTemplateSetting.arrMaxBrokenArea.Clear();
                objTemplateSetting.arrWantBrokenMark.Clear();
                objTemplateSetting.fCharShiftX.Clear();
                objTemplateSetting.fCharShiftY.Clear();
                objTemplateSetting.intTextCharOffsetX.Clear();
                objTemplateSetting.intTextCharOffsetY.Clear();
                objTemplateSetting.blnEnable.Clear();
                objTemplateSetting.arrMarkType.Clear();
                objTemplateSetting.blnIsBarPin1.Clear();
                objTemplateSetting.arrBarPin1Type.Clear();
                for (int k = 0; k < objTemplateSetting.arrTemplateTextROI.Count; k++)
                {
                    if (objTemplateSetting.arrTemplateTextROI[k] != null)
                    {
                        objTemplateSetting.arrTemplateTextROI[k].Dispose();
                        objTemplateSetting.arrTemplateTextROI[k] = null;
                    }
                }
                objTemplateSetting.arrTemplateTextROI.Clear();

                for (int k = 0; k < objTemplateSetting.arrTemplateCharErodeROI.Count; k++)
                {
                    if (objTemplateSetting.arrTemplateCharErodeROI[k] != null)
                    {
                        objTemplateSetting.arrTemplateCharErodeROI[k].Dispose();
                        objTemplateSetting.arrTemplateCharErodeROI[k] = null;
                    }
                }
                objTemplateSetting.arrTemplateCharErodeROI.Clear();

                for (int k = 0; k < objTemplateSetting.arrTemplateCharDilateROI.Count; k++)
                {
                    if (objTemplateSetting.arrTemplateCharDilateROI[k] != null)
                    {
                        objTemplateSetting.arrTemplateCharDilateROI[k].Dispose();
                        objTemplateSetting.arrTemplateCharDilateROI[k] = null;
                    }
                }
                objTemplateSetting.arrTemplateCharDilateROI.Clear();


                m_arrTemplateSettingPrev.RemoveAt(m_arrTemplateSettingPrev.Count - 1);
            }
            else
                objTemplateSetting = new TemplateSetting();

            return objTemplateSetting;
        }

        private void ClearTemplateSettingArray()
        {
            if (m_intGroupIndex >= m_arrTemplateSetting.Count)
                return;

            for (int n = m_arrTemplateSetting[m_intGroupIndex].Count - 1; n >= 0; n--)
            {
                m_arrTemplateSettingPrev.Add(m_arrTemplateSetting[m_intGroupIndex][n]);
            }

            m_arrTemplateSetting[m_intGroupIndex].Clear();
        }


        private void RemoveRangeTemplateSettingArray(int intStartIndex)
        {
            if (m_arrTemplateSetting[m_intGroupIndex].Count > 0)
            {
                for (int n = m_arrTemplateSetting[m_intGroupIndex].Count - 1; n >= 1; n--)
                {
                    m_arrTemplateSettingPrev.Add(m_arrTemplateSetting[m_intGroupIndex][n]);
                }

                m_arrTemplateSetting[m_intGroupIndex].RemoveRange(1, m_arrTemplateSetting[m_intGroupIndex].Count - 1);
            }
        }

        private int GetGrayValueThreshold(ROI objMarkROI, int intInspectionAreaGrayValueSensitivity, int intBrightSensitivity)
        {
            ROI objROI = new ROI();
            objROI.LoadROISetting(0, 0, objMarkROI.ref_ROIWidth, objMarkROI.ref_ROIHeight);
            ImageDrawing objMarkImage = new ImageDrawing();
            objMarkROI.CopyToImage(ref objMarkImage);
            objROI.AttachImage(objMarkImage);

            // 2020-05-15 ZJYEOH : New Inspection Method using gray value
            // Step 1 : Get average gray value of package surface area
            float fAverageGrayValue = 0;
            EasyImage.PixelAverage(objROI.ref_ROI, out fAverageGrayValue);

            // Step 2 : declare another ROI and threshold it using (average gray value + sensitivity)
            ROI objThresholdROI = new ROI();
            objThresholdROI.LoadROISetting(0, 0, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
            ImageDrawing objImage = new ImageDrawing();
            objROI.CopyToImage(ref objImage);
            objThresholdROI.AttachImage(objImage);
            int intThreshold = (int)Math.Round(fAverageGrayValue) + intInspectionAreaGrayValueSensitivity;
            if (intThreshold > 255)
                intThreshold = 255;

            //objROI.ref_ROI.Save("D:\\objMarkROI1.bmp");
#if (Debug_2_12 || Release_2_12)
            EasyImage.Threshold(objThresholdROI.ref_ROI, objThresholdROI.ref_ROI, (uint)intThreshold);
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
            EasyImage.Threshold(objThresholdROI.ref_ROI, objThresholdROI.ref_ROI, intThreshold);
#endif

            //objThresholdROI.ref_ROI.Save("D:\\objMarkThresholdROI2.bmp");
            // Step 3 : invert the thrshold ROI 
            //EasyImage.Oper(EArithmeticLogicOperation.Invert, objThresholdROI.ref_ROI, objThresholdROI.ref_ROI);
            ROI.InvertOperationROI(objThresholdROI);
            //objThresholdROI.ref_ROI.Save("D:\\objMarkThresholdROI3.bmp");
            //// Step 4 : Subtract Original ROI with inverted threshold ROI will result defect above the threshold value only
            //EasyImage.Oper(EArithmeticLogicOperation.Subtract, objROI.ref_ROI, objThresholdROI.ref_ROI, objROI.ref_ROI);
            //objROI.ref_ROI.Save("D:\\objROI4.bmp");
            //// Step 5 : using Close morphology to link the small defect together using sensitivity set by user
            //EasyImage.CloseDisk(objROI.ref_ROI, objROI.ref_ROI, intMergeSensitivity);
            //objROI.ref_ROI.Save("D:\\objROI5.bmp");
            // Step 6 : Get average gray value of the final ROI
            fAverageGrayValue = 0;
            EasyImage.PixelAverage(objROI.ref_ROI, objThresholdROI.ref_ROI, out fAverageGrayValue);
            objThresholdROI.Dispose();
            objROI.Dispose();
            objImage.Dispose();
            objMarkImage.Dispose();
            // Step 7 : Build blob using the threshold value (average gray value + bright sensitivity)
            intThreshold = (int)Math.Round(fAverageGrayValue) + intBrightSensitivity;// intBrightSensitivity;
            if (intThreshold > 255)
                intThreshold = 255;

            return intThreshold;
        }
        public void DrawGrayValueSensitivity(ref ROI objROI, int intInspectionAreaGrayValueSensitivity, int intMergeSensitivity, bool blnViewThreshold, int intBrightSensitivity, int intDarkSensitivity, ref float fFinalAverageGrayValue)
        {
            if (objROI == null)
                return;

            // 2020-05-15 ZJYEOH : New Inspection Method using gray value
            // Step 1 : Get average gray value of package surface area
            float fAverageGrayValue = 0;
            EasyImage.PixelAverage(objROI.ref_ROI, out fAverageGrayValue);

            // Step 2 : declare another ROI and threshold it using (average gray value + sensitivity)
            ROI objThresholdROI = new ROI();
            objThresholdROI.LoadROISetting(0, 0, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
            ImageDrawing objImage = new ImageDrawing();
            //ImageDrawing objTempImage = new ImageDrawing();
            objROI.CopyToImage(ref objImage);
            //objROI.CopyToImage(ref objTempImage);
            objThresholdROI.AttachImage(objImage);
            int intThreshold = (int)Math.Round(fAverageGrayValue) + intInspectionAreaGrayValueSensitivity;
            if (intThreshold > 255)
                intThreshold = 255;
            //objROI.ref_ROI.Save("D:\\objROI1.bmp");
            //objThresholdROI.ref_ROI.Save("D:\\objThresholdROI1.bmp");
#if (Debug_2_12 || Release_2_12)
            EasyImage.Threshold(objThresholdROI.ref_ROI, objThresholdROI.ref_ROI, (uint)intThreshold);
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
            EasyImage.Threshold(objThresholdROI.ref_ROI, objThresholdROI.ref_ROI, intThreshold);
#endif

            //objROI.ref_ROI.Save("D:\\objROI2.bmp");
            //objThresholdROI.ref_ROI.Save("D:\\objThresholdROI2.bmp");
            // Step 3 : invert the thrshold ROI 
            //EasyImage.Oper(EArithmeticLogicOperation.Invert, objThresholdROI.ref_ROI, objThresholdROI.ref_ROI);
            ROI.InvertOperationROI(objThresholdROI);
            //objROI.ref_ROI.Save("D:\\objROI3.bmp");
            //objThresholdROI.ref_ROI.Save("D:\\objThresholdROI3.bmp");

            // Step 6 : Get average gray value of the final ROI
            //ROI objTempROI = new ROI();
            //    objTempROI.LoadROISetting(0, 0, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
            //    objTempROI.AttachImage(objTempImage);
            //    fAverageGrayValue = 0;
            EasyImage.PixelAverage(objROI.ref_ROI, objThresholdROI.ref_ROI, out fAverageGrayValue);
            //objTempROI.ref_ROI.Save("D:\\objTempROI1.bmp");

            objThresholdROI.Dispose();
            //objTempROI.Dispose();
            objImage.Dispose();
            //objTempImage.Dispose();

            fFinalAverageGrayValue = (float)Math.Round(fAverageGrayValue);
            if (blnViewThreshold)
            {
                intThreshold = (int)Math.Round(fAverageGrayValue) + intBrightSensitivity;
                if (intThreshold > 255)
                    intThreshold = 255;
#if (Debug_2_12 || Release_2_12)
                EasyImage.Threshold(objROI.ref_ROI, objROI.ref_ROI, (uint)intThreshold);
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                EasyImage.Threshold(objROI.ref_ROI, objROI.ref_ROI, intThreshold);
#endif

            }



        }
        public void SetArrayOcvtoSingleOcv()
        {
            if (m_intTemplateIndex < m_arrOCV[m_intGroupIndex].Count)
            {
                m_objOCV = m_arrOCV[m_intGroupIndex][m_intTemplateIndex];
            }
            else
            {
                m_objOCV = new NOCV(m_intImageWidth, m_intImageHeight);
            }
        }

        private void WaitEventDone(ref bool bTriggerEvent, bool bBreakResult)
        {
            HiPerfTimer hTimeout = new HiPerfTimer();
            hTimeout.Start();
            while (true)
            {
                if (bTriggerEvent == bBreakResult)
                {
                    return;
                }

                if (hTimeout.Timing > 10000)    // 2021 04 02 - CCENG: Change from 1s to 10s drawing drag.
                {
                    STTrackLog.WriteLine("Mark.cs > WaitEventDone > timout.");
                    return;
                }

                Thread.Sleep(1);    // 2018 10 01 - CCENG: Dun use Sleep(0) as it may cause other internal thread hang especially during waiting for grab image done. (Grab frame timeout happen)
            }
        }

        private bool IsInDontCareLeadArea(List<float> arrDontCareLeadAreaStartX, List<float> arrDontCareLeadAreaStartY, List<float> arrDontCareLeadAreaEndX, List<float> arrDontCareLeadAreaEndY, List<int> arrDontCareLeadDirection,
            float fBlobCenterX, float fBlobCenterY)
        {
            for (int i = 0; i < arrDontCareLeadAreaStartX.Count; i++)
            {
                switch (arrDontCareLeadDirection[i])
                {
                    case 1://Top
                        if (fBlobCenterX > arrDontCareLeadAreaStartX[i] && fBlobCenterX < arrDontCareLeadAreaEndX[i] &&
                            fBlobCenterY > arrDontCareLeadAreaStartY[i] && fBlobCenterY < (arrDontCareLeadAreaEndY[i] + m_intLeadDontCareInwardTolerance_Top))
                        {
                            return true;
                        }
                        break;
                    case 2://Right
                        if (fBlobCenterX > arrDontCareLeadAreaStartX[i] && fBlobCenterX < (arrDontCareLeadAreaEndX[i] + m_intLeadDontCareInwardTolerance_Right) &&
                            fBlobCenterY > arrDontCareLeadAreaStartY[i] && fBlobCenterY < arrDontCareLeadAreaEndY[i])
                        {
                            return true;
                        }
                        break;
                    case 3://Bottom
                        if (fBlobCenterX > arrDontCareLeadAreaStartX[i] && fBlobCenterX < arrDontCareLeadAreaEndX[i] &&
                            fBlobCenterY > (arrDontCareLeadAreaStartY[i] - m_intLeadDontCareInwardTolerance_Bottom) && fBlobCenterY < arrDontCareLeadAreaEndY[i])
                        {
                            return true;
                        }
                        break;
                    case 4://Left
                        if (fBlobCenterX > (arrDontCareLeadAreaStartX[i] - m_intLeadDontCareInwardTolerance_Left) && fBlobCenterX < arrDontCareLeadAreaEndX[i] &&
                            fBlobCenterY > arrDontCareLeadAreaStartY[i] && fBlobCenterY < arrDontCareLeadAreaEndY[i])
                        {
                            return true;
                        }
                        break;
                    case 0:
                    default:
                        if (fBlobCenterX > arrDontCareLeadAreaStartX[i] && fBlobCenterX < arrDontCareLeadAreaEndX[i] &&
                            fBlobCenterY > arrDontCareLeadAreaStartY[i] && fBlobCenterY < arrDontCareLeadAreaEndY[i])
                        {
                            return true;
                        }
                        break;
                }
            }

            return false;
        }

        public void DontCareOCVArea(ImageDrawing objDestinationImage, float fMarkAngle, bool blnWhiteOnBlack)
        {
            bool blnWantDebug = false;
            if (blnWantDebug)
            {
                objDestinationImage.SaveImage("D:\\TS\\1.objDestinationImage.bmp");
            }

            ROI objSubtractCharROI = new ROI();
            objSubtractCharROI.AttachImage(objDestinationImage);
            ROI objDilateROI = new ROI();
            ImageDrawing objDilateImage = new ImageDrawing(true, objDestinationImage.ref_intImageWidth, objDestinationImage.ref_intImageHeight);
            objDilateROI.AttachImage(objDilateImage);
            System.Drawing.Point pStart, pEnd;
            List<ROI> arrTemplateCharDilateROI = new List<ROI>();
            List<float> arrTemplateStartX = new List<float>();
            List<float> arrTemplateStartY = new List<float>();
            List<float> arrTemplateEndX = new List<float>();
            List<float> arrTemplateEndY = new List<float>();
            NOCV objOCV = m_arrOCV[m_intGroupIndex][m_intTemplateIndex];
            int intNumChars = objOCV.GetNumChars();
            int intThresholdValue = GetAutoThreshold(objSubtractCharROI);
            for (int i = 0; i < intNumChars; i++)
            {

                //// 2020-08-11 ZJYEOH : Skip Check Excess if mark is disabled
                //if (!m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i])
                //    continue;

                arrTemplateCharDilateROI.Add(m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].arrTemplateCharDilateROI[i]);
#if (Debug_2_12 || Release_2_12)
                EasyImage.Threshold(arrTemplateCharDilateROI[i].ref_ROI, arrTemplateCharDilateROI[i].ref_ROI, (uint)intThresholdValue);
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                EasyImage.Threshold(arrTemplateCharDilateROI[i].ref_ROI, arrTemplateCharDilateROI[i].ref_ROI, intThresholdValue);
#endif

                pStart = objOCV.GetCharStartXY(i);
                pEnd = objOCV.GetCharEndXY(i);
                float newSX = 0, newSY = 0, newEX = 0, newEY = 0;
                Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2, pStart.X, pStart.Y, -(fMarkAngle), ref newSX, ref newSY);

                Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2, pEnd.X, pEnd.Y, -(fMarkAngle), ref newEX, ref newEY);
                pStart = new Point((int)Math.Round(newSX), (int)Math.Round(newSY));
                pEnd = new Point((int)Math.Round(newEX), (int)Math.Round(newEY));

                List<Point> arrPoints = new List<Point>();
                arrPoints.Add(pStart);
                arrPoints.Add(new Point(pStart.X + (pEnd.X - pStart.X), pStart.Y));
                arrPoints.Add(new Point(pStart.X, pStart.Y + (pEnd.Y - pStart.Y)));
                arrPoints.Add(pEnd);

                PointF pTemp = new PointF();
                Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
                                                 arrPoints[0],
                                                 -(fMarkAngle),
                                                 ref pTemp);
                arrPoints[0] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

                Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
                                                 arrPoints[1],
                                                 -(fMarkAngle),
                                                 ref pTemp);
                arrPoints[1] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

                Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
                                                 arrPoints[2],
                                                 -(fMarkAngle),
                                                 ref pTemp);
                arrPoints[2] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

                Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2, (pEnd.Y + pStart.Y) / 2,
                                                 arrPoints[3],
                                                 -(fMarkAngle),
                                                 ref pTemp);
                arrPoints[3] = new Point((int)Math.Round(pTemp.X), (int)Math.Round(pTemp.Y));

                float fMinX = float.MaxValue;
                float fMinY = float.MaxValue;
                float fMaxX = 0;
                float fMaxY = 0;
                for (int a = 0; a < arrPoints.Count; a++)
                {
                    if (fMinX > arrPoints[a].X)
                        fMinX = arrPoints[a].X;

                    if (fMinY > arrPoints[a].Y)
                        fMinY = arrPoints[a].Y;

                    if (fMaxX < arrPoints[a].X)
                        fMaxX = arrPoints[a].X;

                    if (fMaxY < arrPoints[a].Y)
                        fMaxY = arrPoints[a].Y;
                }

                ROI objSampleCharROI = new ROI();

                objSampleCharROI.AttachImage(objDestinationImage);

                objSubtractCharROI.LoadROISetting((int)Math.Round(m_intROIOffSetX + fMinX), (int)Math.Round(m_intROIOffSetY + fMinY),
                   (int)Math.Round(fMaxX - fMinX), (int)Math.Round(fMaxY - fMinY));

                objSampleCharROI.LoadROISetting((int)Math.Round(m_intROIOffSetX + fMinX), (int)Math.Round(m_intROIOffSetY + fMinY),
                   (int)Math.Round(fMaxX - fMinX), (int)Math.Round(fMaxY - fMinY));

                arrTemplateStartX.Add(objSampleCharROI.ref_ROIPositionX - m_intROIOffSetX);
                arrTemplateStartY.Add(objSampleCharROI.ref_ROIPositionY - m_intROIOffSetY);
                arrTemplateEndX.Add(objSampleCharROI.ref_ROIPositionX + objSampleCharROI.ref_ROIWidth - m_intROIOffSetX);
                arrTemplateEndY.Add(objSampleCharROI.ref_ROIPositionY + objSampleCharROI.ref_ROIHeight - m_intROIOffSetY);

                objDilateROI.LoadROISetting((int)Math.Round(m_intROIOffSetX + fMinX), (int)Math.Round(m_intROIOffSetY + fMinY),
                   (int)Math.Round(fMaxX - fMinX), (int)Math.Round(fMaxY - fMinY));

                //objDilateROI.LoadROISetting(arrTemplateCharDilateROI[i].ref_ROITotalX, arrTemplateCharDilateROI[i].ref_ROITotalY, arrTemplateCharDilateROI[i].ref_ROIWidth, arrTemplateCharDilateROI[i].ref_ROIHeight);
                //arrTemplateCharDilateROI[i].SaveImage("D:\\arrTemplateCharDilateROI.bmp");
                //objDilateROI.SaveImage("D:\\objDilateROI.bmp");
                arrTemplateCharDilateROI[i].CopyImage(ref objDilateROI);
                ROI.Rotate0Degree_ForDontCare(arrTemplateCharDilateROI[i], -(fMarkAngle), 4, objDilateROI);
                //arrTemplateCharDilateROI[i].SaveImage("D:\\arrTemplateCharDilateROI.bmp");
                //objDilateROI.SaveImage("D:\\objDilateROI.bmp");

                //objDilateROI.LoadROISetting(objSampleCharROI.ref_ROIPositionX, objSampleCharROI.ref_ROIPositionY,
                //                                    objSampleCharROI.ref_ROIWidth, objSampleCharROI.ref_ROIHeight);

                if (!m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].blnEnable[i])
                {
                    EasyImage.Oper(EArithmeticLogicOperation.Subtract, objSampleCharROI.ref_ROI, objSampleCharROI.ref_ROI, objSubtractCharROI.ref_ROI);
                }
                else
                {
                    //2020-06-17 ZJYEOH : Image processing will be different for white on black and black one white
                    if (blnWhiteOnBlack)
                    {
                        EasyImage.Oper(EArithmeticLogicOperation.Subtract, objSampleCharROI.ref_ROI, objDilateROI.ref_ROI, objSubtractCharROI.ref_ROI);
                    }
                    else
                    {
                        //EasyImage.Oper(EArithmeticLogicOperation.Invert, objDilateROI.ref_ROI, objDilateROI.ref_ROI);
                        ROI.InvertOperationROI(objDilateROI);
                        EasyImage.Oper(EArithmeticLogicOperation.Add, objSampleCharROI.ref_ROI, objDilateROI.ref_ROI, objSubtractCharROI.ref_ROI);
                        //EasyImage.Oper(EArithmeticLogicOperation.Invert, arrTemplateCharDilateROI[i].ref_ROI, arrTemplateCharDilateROI[i].ref_ROI);
                    }

                }

                if (blnWantDebug)
                {
                    objDilateROI.SaveImage("D:\\TS\\2.objDilateROI" + i.ToString() + ".bmp");
                    objSampleCharROI.SaveImage("D:\\TS\\3.objSampleCharROI" + i.ToString() + ".bmp");
                    arrTemplateCharDilateROI[i].SaveImage("D:\\TS\\4.arrTemplateCharDilateROI[i]" + i.ToString() + ".bmp");
                    objSubtractCharROI.SaveImage("D:\\TS\\5.objSubtractCharROI" + i.ToString() + ".bmp");
                    objDestinationImage.SaveImage("D:\\TS\\6.objDestinationImage" + i.ToString() + ".bmp");
                }

            }
            objDilateROI.Dispose();
            objDilateImage.Dispose();
        }
        public bool CheckWantInspectBrokenMark(int intType)
        {
            if (!m_blnWantUseMarkTypeInspectionSetting)
                return true;

            switch (intType)
            {
                case 0:
                    if (m_blnWantCheckCharBrokenMark)
                        return true;
                    else
                        return false;
                    break;
                case 1:
                    if (m_blnWantCheckLogoBrokenMark)
                        return true;
                    else
                        return false;
                    break;
                case 2:
                    if (m_blnWantCheckSymbol1BrokenMark)
                        return true;
                    else
                        return false;
                    break;
                case 3:
                    if (m_blnWantCheckSymbol2BrokenMark)
                        return true;
                    else
                        return false;
                    break;
            }
            return true;
        }
        public bool CheckWantInspectExcessMark(int intType)
        {
            if (!m_blnWantUseMarkTypeInspectionSetting)
                return true;

            switch (intType)
            {
                case 0:
                    if (m_blnWantCheckCharExcessMark)
                        return true;
                    else
                        return false;
                    break;
                case 1:
                    if (m_blnWantCheckLogoExcessMark)
                        return true;
                    else
                        return false;
                    break;
                case 2:
                    if (m_blnWantCheckSymbol1ExcessMark)
                        return true;
                    else
                        return false;
                    break;
                case 3:
                    if (m_blnWantCheckSymbol2ExcessMark)
                        return true;
                    else
                        return false;
                    break;
            }
            return true;
        }
        public bool CheckWantInspectMissingMark(int intType)
        {
            if (!m_blnWantUseMarkTypeInspectionSetting)
                return true;

            switch (intType)
            {
                case 0:
                    if (m_blnWantCheckCharMissingMark)
                        return true;
                    else
                        return false;
                    break;
                case 1:
                    if (m_blnWantCheckLogoMissingMark)
                        return true;
                    else
                        return false;
                    break;
                case 2:
                    if (m_blnWantCheckSymbol1MissingMark)
                        return true;
                    else
                        return false;
                    break;
                case 3:
                    if (m_blnWantCheckSymbol2MissingMark)
                        return true;
                    else
                        return false;
                    break;
            }
            return true;
        }

        //cxlim 2020/12/11 - select and unselect for character in learn mark form
        public void SelectAll(bool bln_select)
        {
            if (bln_select)
            {
                for (int i = 0; i < m_arrBuildOcvSelectStatus.Count; i++)
                {
                    m_arrBuildOcvSelectStatus[i] = 2;
                }
            }
            else
            {
                for (int i = 0; i < m_arrBuildOcvSelectStatus.Count; i++)
                {
                    if (m_arrBuildOcvSelectStatus[i] == 2)
                        m_arrBuildOcvSelectStatus[i] = 1;
                }
            }
        }

        public void SetCalibrationData(float fPixelPerMMX, float fPixelPerMMY, int intUnitMode)
        {
            // MM to Pixel formula
            if (intUnitMode == 0)
            {
                m_fMMPerPixelX = 1f;
                m_fMMPerPixelY = 1f;
                m_fMMPerPixelArea = 1f;
                m_fMMToPixelXValue = 1f;
                m_fMMToPixelYValue = 1f;
                m_fMMtoPixelAreaValue = 1f;
            }
            else
            {
                m_fMMPerPixelX = 1 / fPixelPerMMX;
                m_fMMPerPixelY = 1 / fPixelPerMMY;
                m_fMMPerPixelArea = m_fMMPerPixelX * m_fMMPerPixelY;
                m_fMMToPixelXValue = fPixelPerMMX;
                m_fMMToPixelYValue = fPixelPerMMY;
                m_fMMtoPixelAreaValue = fPixelPerMMX * fPixelPerMMY;
            }

            // MM to Micron or Mil formula
            switch (intUnitMode)
            {
                case 0: // pixel
                case 1: // mm
                    m_fMMToUnitValue = 1;
                    m_fMMToUnitValueArea = 1;
                    break;
                case 2: // mil
                    m_fMMToUnitValue = 1 / 0.0254f;
                    m_fMMToUnitValueArea = 1 / (0.0254f * 0.0254f);
                    break;
                case 3: // micron
                    m_fMMToUnitValue = 1000;
                    m_fMMToUnitValueArea = 1000000;
                    break;
            }
        }

        public ImageDrawing getImage(int no)
        {
            if (no == 0)
                return obj_temp;
            else
                return obj_temp2;
        }

        public string GetDisplayUnitName(int intUnitMode, bool blnArea)
        {
            string strArea = "";
            if (blnArea)
                strArea = "2";

            switch (intUnitMode)
            {
                case 0: // pixel
                    return "pix";
                    break;
                case 1: // mm
                    return "mm" + strArea;
                    break;
                case 2: // mil
                    return "mil" + strArea;
                    break;
                case 3: // micron
                    return "um" + strArea;
                    break;
                default:
                    return "";
                    break;
            }
        }

        private int GetFailOptionMask(bool blnTestHandMade)
        {
            if (!blnTestHandMade)
                return m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intFailOptionMask;
            else
                return m_intFailOptionMask_ForPreTest;
        }

        public bool OCRDetect(int CharMinWidth, int CharMaxWidth, int CharHeight, ROI objROI, string TopologyConvertValue)
        {
            //if (CharMaxWidth == 0 || CharHeight == 0 || objROI == null || TopologyConvertValue == "")
            //    return false;

            //if (!mobjOCR.OCRDetect(m_blnWhiteOnBlack, CharMinWidth, CharMaxWidth, CharHeight, objROI.ref_ROI, TopologyConvertValue, true))
            //{
            //    return false;
            //}
            //else
                return true;
        }

        public void SaveTemplateOCR(string StrPath, bool blnNewSection)
        {
            //int intDefaultMarkScore = 50;
            //int intNewNumChars = mobjOCR.GetCharNum();
            //int intPreNumChars = arrOCRCharSetting.Count;
            //if (intPreNumChars == 0)
            //{
            //    for (int i = intPreNumChars; i < intNewNumChars; i++)
            //    {
            //        arrOCRCharSetting.Add(intDefaultMarkScore);
            //    }
            //}
            //else if (intPreNumChars > intNewNumChars)
            //{
            //    arrOCRCharSetting.RemoveRange(intNewNumChars, intPreNumChars - intNewNumChars);

            //    for (int i = 0; i < intNewNumChars; i++)
            //    {
            //        arrOCRCharSetting[i] = intDefaultMarkScore;
            //    }
            //}
            //else if (intPreNumChars < intNewNumChars)
            //{
            //    // 2021 02 28 - CCENG: sett all to default score when no use previous setting
            //    for (int i = 0; i < intNewNumChars; i++)
            //    {
            //        if (i < intPreNumChars)
            //        {
            //            arrOCRCharSetting[i] = intDefaultMarkScore;
            //        }
            //        else
            //        {
            //            arrOCRCharSetting.Add(intDefaultMarkScore);
            //        }
            //    }
            //}

            //XmlParser objFile = new XmlParser(StrPath + "OCRTemplate.xml", blnNewSection);
            //objFile.WriteSectionElement("MarkSettings");
            //objFile.WriteElement1Value("CharMinWidth", m_intCharMinWidth);
            //objFile.WriteElement1Value("CharMaxWidth", m_intCharMaxWidth);
            //objFile.WriteElement1Value("CharHeight", m_intCharHeight);
            //objFile.WriteElement1Value("TopologyConvertedValue", m_strConvertedTopologyValue);
            //objFile.WriteSectionElement("OCRCharSetting");

            //for (int k = 0; k < arrOCRCharSetting.Count; k++)
            //{
            //    objFile.WriteElement1Value("OCRCharSetting" + k, arrOCRCharSetting[k], "Char" + (k + 1).ToString(), true);
            //}

            //objFile.WriteElement1Value("OCRCharNum", mobjOCR.GetCharNum(), "Template" + 1.ToString(), true);
            //objFile.WriteEndElement();
        }

        public void AutoDefineTopology()
        {
            //int intNoSelectedBlobs = m_objLearnBlobs[m_intTemplateIndex].ref_intNumSelectedObject;
            //float centerX = 0;
            //float centerY = 0;
            //float width = 0;
            //float height = 0;
            //int CharCount = 0;
            //if (intNoSelectedBlobs > 0)
            //    m_intCharMinWidth = int.MaxValue;
            //else
            //    m_intCharMinWidth = 0;
            //m_intCharMaxWidth = 0;
            //m_intCharHeight = 0;
            ////m_strConvertedTopologyValue = "";
            //m_objLearnBlobs[m_intTemplateIndex].SetFirstListBlobs();

            //List<float> arrStartX = new List<float>();
            //List<float> arrStartY = new List<float>();
            //List<float> arrEndX = new List<float>();
            //List<float> arrEndY = new List<float>();
            //List<float> arrCenterX = new List<float>();
            //List<float> arrCenterY = new List<float>();
            //List<float> arrWidth = new List<float>();
            //List<float> arrHeight = new List<float>();

            //for (int i = 0; i < intNoSelectedBlobs; i++)
            //{
            //    m_objLearnBlobs[m_intTemplateIndex].GetSelectedListBlobsLimitCenterX(ref centerX);
            //    m_objLearnBlobs[m_intTemplateIndex].GetSelectedListBlobsLimitCenterY(ref centerY);
            //    m_objLearnBlobs[m_intTemplateIndex].GetSelectedListBlobsWidth(ref width);
            //    m_objLearnBlobs[m_intTemplateIndex].GetSelectedListBlobsHeight(ref height);
            //    m_intCharMaxWidth += (int)width;
            //    m_intCharHeight += (int)height;
            //    if (m_intCharMinWidth > (int)(width / 2))
            //        m_intCharMinWidth = (int)(width / 2);
            //    arrCenterX.Add(centerX);
            //    arrCenterY.Add(centerY);
            //    arrWidth.Add(width);
            //    arrHeight.Add(height);
            //    arrStartX.Add(centerX - width / 2);
            //    arrStartY.Add(centerY - height / 2);
            //    arrEndX.Add(centerX + width / 2);
            //    arrEndY.Add(centerY + height / 2);
            //    m_objLearnBlobs[m_intTemplateIndex].SetListBlobsToNext();
            //}

            //List<float> arrSortedStartX = new List<float>();
            //List<float> arrSortedStartY = new List<float>();
            //List<float> arrSortedEndX = new List<float>();
            //List<float> arrSortedEndY = new List<float>();
            //List<float> arrSortedCenterX = new List<float>();
            //List<float> arrSortedCenterY = new List<float>();
            //List<float> arrSortedWidth = new List<float>();
            //List<float> arrSortedHeight = new List<float>();
            //List<int> arrSortedIndex = new List<int>();
            //Math2.SortData(arrCenterY.ToArray(), Math2.Sorting.Increase, ref arrSortedCenterY, ref arrSortedIndex);
            //for (int i = 0; i < arrSortedCenterY.Count; i++)
            //{
            //    arrSortedStartX.Add(arrStartX[arrSortedIndex[i]]);
            //    arrSortedStartY.Add(arrStartY[arrSortedIndex[i]]);
            //    arrSortedEndX.Add(arrEndX[arrSortedIndex[i]]);
            //    arrSortedEndY.Add(arrEndY[arrSortedIndex[i]]);
            //    arrSortedCenterX.Add(arrCenterX[arrSortedIndex[i]]);
            //    arrSortedWidth.Add(arrWidth[arrSortedIndex[i]]);
            //    arrSortedHeight.Add(arrHeight[arrSortedIndex[i]]);
            //}

            //m_intCharHeight = (m_intCharHeight / intNoSelectedBlobs) + 10;
            //m_intCharMaxWidth = (m_intCharMaxWidth / intNoSelectedBlobs) + 10;

            //int intToleranceX = m_intCharMaxWidth * 2;
            //int intToleranceY = m_intCharHeight / 4;
            //List<List<int>> arrCharCount = new List<List<int>>();
            //List<List<float>> arrMaxStartX = new List<List<float>>();
            //List<List<float>> arrMaxStartY = new List<List<float>>();
            //List<List<float>> arrMaxEndX = new List<List<float>>();
            //List<List<float>> arrMaxEndY = new List<List<float>>();
            //List<int> arrSkip = new List<int>();
            //for (int i = 0; i < arrSortedCenterX.Count; i++)
            //{
            //    if (arrSkip.Contains(i))
            //        continue;
            //    int intCount = 0;
            //    arrSkip.Add(i);
            //    arrCharCount.Add(new List<int>());
            //    arrCharCount[arrCharCount.Count - 1].Add(++intCount);
            //    arrMaxStartY.Add(new List<float>());
            //    arrMaxStartY[arrMaxStartY.Count - 1].Add(arrSortedStartY[i]);
            //    arrMaxEndY.Add(new List<float>());
            //    arrMaxEndY[arrMaxEndY.Count - 1].Add(arrSortedEndY[i]);

            //    List<int> arrSelectedIndex = new List<int>();
            //    arrSelectedIndex.Add(i);
            //    for (int j = 0; j < arrSortedCenterX.Count; j++)
            //    {
            //        if (i == j || arrSkip.Contains(j))
            //            continue;

            //        if (Math.Abs(arrSortedCenterY[i] - arrSortedCenterY[j]) <= intToleranceY ||
            //            (arrSortedStartY[j] >= arrMaxStartY[arrMaxStartY.Count - 1][arrMaxStartY[arrMaxStartY.Count - 1].Count - 1] &&
            //             arrSortedEndY[j] <= arrMaxEndY[arrMaxEndY.Count - 1][arrMaxEndY[arrMaxEndY.Count - 1].Count - 1]))
            //        {
            //            if (arrMaxStartY[arrMaxStartY.Count - 1][arrMaxStartY[arrMaxStartY.Count - 1].Count - 1] > arrSortedStartY[j])
            //            {
            //                arrMaxStartY[arrMaxStartY.Count - 1][arrMaxStartY[arrMaxStartY.Count - 1].Count - 1] = arrSortedStartY[j];
            //            }
            //            if (arrMaxEndY[arrMaxEndY.Count - 1][arrMaxEndY[arrMaxEndY.Count - 1].Count - 1] < arrSortedEndY[j])
            //            {
            //                arrMaxEndY[arrMaxEndY.Count - 1][arrMaxEndY[arrMaxEndY.Count - 1].Count - 1] = arrSortedEndY[j];
            //            }
            //            arrSkip.Add(j);
            //            arrCharCount[arrCharCount.Count - 1][arrCharCount[arrCharCount.Count - 1].Count - 1] = ++intCount;
            //            arrSelectedIndex.Add(j);
            //            j = 0;
            //        }
            //    }

            //    arrMaxStartX = new List<List<float>>();
            //    arrMaxStartY = new List<List<float>>();
            //    arrMaxEndX = new List<List<float>>();
            //    arrMaxEndY = new List<List<float>>();
            //    List<int> arrSkip_Group = new List<int>();
            //    List<int> arrCharGroupCount = new List<int>();
            //    for (int a = 0; a < arrSelectedIndex.Count; a++)
            //    {
            //        if (arrSkip_Group.Contains(a))
            //            continue;
            //        arrSkip_Group.Add(a);
            //        int intGroupCount = 0;
            //        arrCharGroupCount.Add(++intGroupCount);
            //        arrMaxStartX.Add(new List<float>());
            //        arrMaxStartX[arrMaxStartX.Count - 1].Add(arrSortedStartX[arrSelectedIndex[a]]);
            //        arrMaxEndX.Add(new List<float>());
            //        arrMaxEndX[arrMaxEndX.Count - 1].Add(arrSortedEndX[arrSelectedIndex[a]]);
            //        arrMaxStartY.Add(new List<float>());
            //        arrMaxStartY[arrMaxStartY.Count - 1].Add(arrSortedStartY[arrSelectedIndex[a]]);
            //        arrMaxEndY.Add(new List<float>());
            //        arrMaxEndY[arrMaxEndY.Count - 1].Add(arrSortedEndY[arrSelectedIndex[a]]);
            //        for (int b = 0; b < arrSelectedIndex.Count; b++)
            //        {
            //            if (a == b || arrSkip_Group.Contains(b))
            //                continue;

            //            System.Windows.Point[] arrPoints1 = new System.Windows.Point[4]
            //            {
            //                new System.Windows.Point((int)Math.Ceiling(arrMaxStartX[arrMaxStartX.Count - 1][arrMaxStartX[arrMaxStartX.Count - 1].Count - 1]), (int)Math.Ceiling(arrMaxStartY[arrMaxStartY.Count - 1][arrMaxStartY[arrMaxStartY.Count - 1].Count - 1])), //TL
            //                new System.Windows.Point((int)Math.Floor(arrMaxEndX[arrMaxEndX.Count - 1][arrMaxEndX[arrMaxEndX.Count - 1].Count - 1]), (int)Math.Ceiling(arrMaxStartY[arrMaxStartY.Count - 1][arrMaxStartY[arrMaxStartY.Count - 1].Count - 1])), //TR
            //                new System.Windows.Point((int)Math.Floor(arrMaxEndX[arrMaxEndX.Count - 1][arrMaxEndX[arrMaxEndX.Count - 1].Count - 1]), (int)Math.Floor(arrMaxEndY[arrMaxEndY.Count - 1][arrMaxEndY[arrMaxEndY.Count - 1].Count - 1])), //BR
            //                new System.Windows.Point((int)Math.Ceiling(arrMaxStartX[arrMaxStartX.Count - 1][arrMaxStartX[arrMaxStartX.Count - 1].Count - 1]), (int)Math.Floor(arrMaxEndY[arrMaxEndY.Count - 1][arrMaxEndY[arrMaxEndY.Count - 1].Count - 1]))  //BL
            //            };

            //            System.Windows.Point[] arrPoints2 = new System.Windows.Point[4]
            //            {
            //                new System.Windows.Point((int)Math.Ceiling(arrSortedStartX[arrSelectedIndex[b]]) - intToleranceX / 2, (int)Math.Ceiling(arrSortedStartY[arrSelectedIndex[b]])), //TL
            //                new System.Windows.Point((int)Math.Floor(arrSortedEndX[arrSelectedIndex[b]]) + intToleranceX / 2, (int)Math.Ceiling(arrSortedStartY[arrSelectedIndex[b]])), //TR
            //                new System.Windows.Point((int)Math.Floor(arrSortedEndX[arrSelectedIndex[b]]) + intToleranceX / 2, (int)Math.Floor(arrSortedEndY[arrSelectedIndex[b]])), //BR
            //                new System.Windows.Point((int)Math.Ceiling(arrSortedStartX[arrSelectedIndex[b]]) - intToleranceX / 2, (int)Math.Floor(arrSortedEndY[arrSelectedIndex[b]]))  //BL
            //            };

            //            if (Math.Abs(arrSortedCenterX[arrSelectedIndex[a]] - arrSortedCenterX[arrSelectedIndex[b]]) <= intToleranceX ||
            //                (arrSortedStartX[arrSelectedIndex[b]] >= arrMaxStartX[arrMaxStartX.Count - 1][arrMaxStartX[arrMaxStartX.Count - 1].Count - 1] &&
            //                 arrSortedEndX[arrSelectedIndex[b]] <= arrMaxEndX[arrMaxEndX.Count - 1][arrMaxEndX[arrMaxEndX.Count - 1].Count - 1]) ||
            //                Intersection.CheckRectRectIntersection(arrPoints1, arrPoints2, 0))
            //            {
            //                if (arrMaxStartX[arrMaxStartX.Count - 1][arrMaxStartX[arrMaxStartX.Count - 1].Count - 1] > arrSortedStartX[arrSelectedIndex[b]])
            //                {
            //                    arrMaxStartX[arrMaxStartX.Count - 1][arrMaxStartX[arrMaxStartX.Count - 1].Count - 1] = arrSortedStartX[arrSelectedIndex[b]];
            //                }
            //                if (arrMaxEndX[arrMaxEndX.Count - 1][arrMaxEndX[arrMaxEndX.Count - 1].Count - 1] < arrSortedEndX[arrSelectedIndex[b]])
            //                {
            //                    arrMaxEndX[arrMaxEndX.Count - 1][arrMaxEndX[arrMaxEndX.Count - 1].Count - 1] = arrSortedEndX[arrSelectedIndex[b]];
            //                }
            //                if (arrMaxStartY[arrMaxStartY.Count - 1][arrMaxStartY[arrMaxStartY.Count - 1].Count - 1] > arrSortedStartY[arrSelectedIndex[b]])
            //                {
            //                    arrMaxStartY[arrMaxStartY.Count - 1][arrMaxStartY[arrMaxStartY.Count - 1].Count - 1] = arrSortedStartY[arrSelectedIndex[b]];
            //                }
            //                if (arrMaxEndY[arrMaxEndY.Count - 1][arrMaxEndY[arrMaxEndY.Count - 1].Count - 1] < arrSortedEndY[arrSelectedIndex[b]])
            //                {
            //                    arrMaxEndY[arrMaxEndY.Count - 1][arrMaxEndY[arrMaxEndY.Count - 1].Count - 1] = arrSortedEndY[arrSelectedIndex[b]];
            //                }
            //                arrSkip_Group.Add(b);
            //                arrCharGroupCount[arrCharGroupCount.Count - 1] = ++intGroupCount;
            //                b = 0;
            //            }
            //        }
            //    }

            //    for (int k = 0; k < arrCharGroupCount.Count; k++)
            //    {
            //        if (arrCharCount[arrCharCount.Count - 1].Count <= k)
            //            arrCharCount[arrCharCount.Count - 1].Add(arrCharGroupCount[k]);
            //        else
            //            arrCharCount[arrCharCount.Count - 1][k] = arrCharGroupCount[k];
            //    }
            //}

            //List<List<List<string>>> arrCharType = new List<List<List<string>>>();
            //string[] arrLine = m_strConvertedTopologyValue.Split('\n');
            //for (int i = 0; i < arrLine.Length; i++)
            //{
            //    arrCharType.Add(new List<List<string>>());
            //    string[] arrWord = arrLine[i].Split(' ');
            //    for (int j = 0; j < arrWord.Length; j++)
            //    {
            //        arrCharType[i].Add(new List<string>());
            //        char[] arrChar = arrWord[j].ToCharArray();
            //        for (int k = 0; k < arrChar.Length; k++)
            //        {
            //            if (arrChar[k] != '{' && arrChar[k] != '}' && arrChar[k] != '[' && arrChar[k] != ']')
            //            {
            //                if (arrChar[k] == 'L' && arrChar.Length > (k + 1) && (arrChar[k + 1] == 'u' || arrChar[k + 1] == 'l'))
            //                {
            //                    arrCharType[i][j].Add((arrChar[k].ToString() + arrChar[k + 1].ToString()).ToString());
            //                    k++;
            //                }
            //                else
            //                    arrCharType[i][j].Add(arrChar[k].ToString());
            //            }
            //            else if (arrChar[k] == '{')
            //            {
            //                for (int x = 1; x < Convert.ToInt32(arrChar[k + 1].ToString()); x++)
            //                {
            //                    arrCharType[i][j].Add(arrChar[k - 1].ToString());
            //                }
            //                k++;
            //            }
            //            else if (arrChar[k] == '[')
            //            {
            //                string strCombined = "";
            //                for (int x = k + 1; x < arrChar.Length; x++)
            //                {
            //                    if (arrChar[x] != ']')
            //                        strCombined += arrChar[x].ToString();
            //                    else
            //                    {
            //                        k++;
            //                        break;
            //                    }
            //                    k++;
            //                }
            //                arrCharType[i][j].Add(strCombined);
            //            }
            //        }
            //    }
            //}

            //m_strConvertedTopologyValue = "";
            //for (int i = 0; i < arrCharCount.Count; i++)
            //{
            //    if (i != 0)
            //    {
            //        m_strConvertedTopologyValue += "\n";
            //    }

            //    for (int j = 0; j < arrCharCount[i].Count; j++)
            //    {
            //        if (j != 0)
            //        {
            //            m_strConvertedTopologyValue += " ";
            //        }

            //        for (int k = 0; k < arrCharCount[i][j]; k++)
            //        {
            //            if (arrCharType.Count > i && arrCharType[i].Count > j && arrCharType[i][j].Count > k)
            //            {
            //                if (arrCharType[i][j][k].Length == 1)
            //                    m_strConvertedTopologyValue += arrCharType[i][j][k];
            //                else if (arrCharType[i][j][k] == "Lu" || arrCharType[i][j][k] == "Ll")
            //                {
            //                    m_strConvertedTopologyValue += arrCharType[i][j][k];
            //                }
            //                else
            //                {
            //                    m_strConvertedTopologyValue += "[" + arrCharType[i][j][k] + "]";
            //                }
            //            }
            //            else
            //                m_strConvertedTopologyValue += ".";
            //        }
            //    }
            //}
        }

        public void LoadTemplateOCR(string StrPath)
        {
            //XmlParser objFile = new XmlParser(StrPath + "OCRTemplate.xml");
            //objFile.GetFirstSection("MarkSettings");
            //m_intCharMaxWidth = objFile.GetValueAsInt("CharMaxWidth", 5);
            //m_intCharMinWidth = objFile.GetValueAsInt("CharMinWidth", 0);
            //m_intCharHeight = objFile.GetValueAsInt("CharHeight", 5);
            //m_strConvertedTopologyValue = objFile.GetValueAsString("TopologyConvertedValue", ".");
            //objFile.GetFirstSection("OCRCharSetting");
            //int intCharNum = objFile.GetValueAsInt("OCRCharNum", 0);

            //arrOCRCharSetting.Clear();

            //for (int k = 0; k < intCharNum; k++)
            //{
            //    arrOCRCharSetting.Add(objFile.GetValueAsInt("OCRCharSetting" + k, m_intDefaultCharSetting, 1));
            //}
        }

        public bool OCRInspect(ROI objMarkOcvSearchROI, ROI objMarkPackageMarkROI, bool blnByPassUnit, int intMinMarkScore)
        {
            //try
            //{
            //    m_blnLock = true;
            //    m_strResultTrack = "";

            //    if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OCRMark - 1");
            //    WaitEventDone(ref m_blnLockBlobs, false);
            //    //lock (m_objLockBlobs)
            //    {
            //        m_blnLockBlobs = true;

            //        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OCRMark - 2");
            //        // Check valid image
            //        if (objMarkPackageMarkROI.ref_ROI.Width == 0 || objMarkPackageMarkROI.ref_ROI.Height == 0)
            //        {
            //            // 2021 01 05 - CCENG: Need to set FailResultMask in order to fail the unit. 
            //            if ((m_intFailResultMask & 0x1000) == 0)
            //                m_intFailResultMask |= 0x1000;

            //            m_strErrorMessage = "Mark ROI size is 0!";
            //            m_blnLock = false;
            //            m_blnLockBlobs = false;
            //            return false;
            //        }

            //        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OCRMark - 3");

            //        // ------------------- checking loop timeout ---------------------------------------------------
            //        HiPerfTimer timeout = new HiPerfTimer();
            //        timeout.Start();

            //        // Reset error message and result mask
            //        m_strErrorMessage = "";
            //        m_intFailResultMask = 0;

            //        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OCRMark - 5");

            //        // Get fail option mask (Each template has own fail option setting)
            //        int intFailOptionMask = m_arrTemplateSetting[m_intGroupIndex][m_intTemplateIndex].intFailOptionMask;

            //        if (m_blnTrackOcvInspect) STTrackLog.WriteLine("Inspect OCRMark - 6");

            //        ImageDrawing objOCVImage = new ImageDrawing(true, objMarkOcvSearchROI.ref_ROI.TopParent.Width, objMarkOcvSearchROI.ref_ROI.TopParent.Height);
            //        if (!m_blnWhiteOnBlack)
            //        {
            //            EasyImage.Oper(EArithmeticLogicOperation.Copy, objMarkOcvSearchROI.ref_ROI.TopParent, objOCVImage.ref_objMainImage);
            //            objMarkOcvSearchROI.ref_ROI.Detach();
            //            objMarkOcvSearchROI.ref_ROI.Attach(objOCVImage.ref_objMainImage);
            //            ROI.InvertOperationROI(objMarkOcvSearchROI);
            //        }

            //        ////if (!mobjOCR.OCRDetect(m_blnWhiteOnBlack, m_intCharMinWidth, m_intCharMaxWidth, m_intCharHeight, objMarkPackageMarkROI.ref_ROI, m_strConvertedTopologyValue, false))
            //        //if (!mobjOCR.OCRDetect(objMarkPackageMarkROI.ref_ROI))
            //        //    return false;
            //        //if (!mobjOCR.Recognize())
            //        //    return false;
            //        if (!mobjOCR.Read(objMarkPackageMarkROI))
            //        {
            //            if ((m_intFailResultMask & 0x100) == 0)
            //                m_intFailResultMask |= 0x100;

            //            m_strErrorMessage += mobjOCR.getMessage(1).ToString();

            //            return false;
            //        }

            //        List<int> m_arrOCRScore = mobjOCR.GetCandidateResult();
            //        m_blnOCRCharResult[m_intTemplateIndex] = new bool[m_arrOCRScore.Count];
            //        int intSetValue;

            //        for (int i = 0; i < m_arrOCRScore.Count; i++)
            //        {
            //            if (blnByPassUnit)
            //            {
            //                intSetValue = intMinMarkScore;
            //            }
            //            else
            //            {
            //                intSetValue = arrOCRCharSetting[i];
            //            }

            //            if ((intSetValue > 0 && m_arrOCRScore[i] < intSetValue))
            //            {
            //                m_blnOCRCharResult[m_intTemplateIndex][i] = false;
            //                if ((m_intFailResultMask & 0x100) == 0)
            //                    m_intFailResultMask |= 0x100;
            //            }
            //            else
            //                m_blnOCRCharResult[m_intTemplateIndex][i] = true;

            //            if (blnByPassUnit)
            //            {
            //                if (m_intFailResultMask == 0)
            //                    break;
            //            }
            //        }
            //        m_blnLockBlobs = false;
            //        m_blnLock = false;
            return true;
            //    }
            //}
            //catch (Exception ex)
            //{
            //    if ((m_intFailResultMask & 0x1000) == 0)
            //        m_intFailResultMask |= 0x1000;
            //    m_strErrorMessage += "*OCR2 Exception : " + ex.ToString();
            //    m_blnLock = false;
            //    m_blnLockBlobs = false;
            //    return false;

            //}
        }

        public bool OCRRegconise()
        {
            //if (mobjOCR.ref_CharDatabase == 0)
            //    return false;

            //if (!mobjOCR.Recognize())
            //{
            //    return false;
            //}
            //else
                return true;
        }

        public void OCRLearn(object obj, string str)
        {
            //if (obj == null)
            //{
            //    SRMMessageBox.Show("Object Hit is Null, Please Select Object before learn");
            //    return;
            //}

            //if (!mobjOCR.OCRLearn(obj, str))
            //    SRMMessageBox.Show(mobjOCR.getMessage(1));
        }

        public void OCRHitTest(int x, int y, float scaleX, float scaleY)
        {
            //m_HitObject = mobjOCR.HitTest(x, y, scaleX, scaleY);
        }

        public void DrawOCR2(Graphics g, int type, float scaleX, float scaleY)
        {
            //mobjOCR.DrawOCR2(g, scaleX, scaleY, type);
        }

        public void DrawResult(Graphics g, float scaleX, float scaleY)
        {
            //List<int> a = mobjOCR.GetCandidateResult();

            //for (int i = 0; i < a.Count; i++)
            //{
            //    if (a[i] > arrOCRCharSetting[i])
            //    {
            //        mobjOCR.DrawResult(g, i, scaleX, scaleY, true);
            //    }
            //    else
            //    {
            //        mobjOCR.DrawResult(g, i, scaleX, scaleY, false);
            //    }
            //}
        }

        public void DrawOCRLearnROI(IntPtr hdc, float zoom)
        {
            //mobjOCR.LearnROIDraw(hdc, zoom);
        }

        public void OCRSaveDatabase(string StrPath)
        {
            //mobjOCR.SaveModel(StrPath);
        }

        public void OCRLoad(string filename)
        {
            //mobjOCR.LoadModel(filename);
        }
        public void OCRLoad(string[] filename)
        {
            //mobjOCR.LoadModel(filename);
        }
        public int GetDatabseNum()
        {
            //return mobjOCR.ref_CharDatabase;
            return 0;
        }

        public void OCRsetText(string text)
        {
            //mobjOCR.ref_Text = text;
        }
        public List<int> GetOCRResult()
        {
            //return mobjOCR.GetCandidateResult();
            return new List<int>();
        }

        public void OCRClearDatabase()
        {
            //mobjOCR.ClearDatabase();
        }

        public int OCRGetLearnROILengthWidth(int type)
        {
            //if (type == 0)
            //    return mobjOCR.getLearnROIWidth();
            //else
            //    return mobjOCR.getLearnROIHeight();
            return 0;
        }

        public string GetOCRInspectionMessage(int intUnitNo, bool blnByPassUnit, int intMinMarkScore)
        {
            //if (m_strErrorMessage.Length != 0)
                //return m_strErrorMessage;

            //m_strErrorMessage += "*Unit " + Convert.ToString(intUnitNo + 1) + ":";

            //if ((m_intFailResultMask & 0x100) > 0)
            //{
            //    List<int> CandidateResult = mobjOCR.GetCandidateResult();
            //    char[] strText = mobjOCR.getMessage(0).ToCharArray();
            //    int counter = 0;

            //    for (int i = 0; i < CandidateResult.Count; i++)
            //    {
            //        float fSetValue;

            //        if (strText[i] == '\n')
            //        {
            //            counter++;
            //        }

            //        if (blnByPassUnit)
            //        {
            //            fSetValue = intMinMarkScore;
            //        }
            //        else
            //        {
            //            fSetValue = Convert.ToSingle(arrOCRCharSetting[i]);
            //        }


            //        if (CandidateResult[i] < fSetValue)
            //        {
            //            m_strErrorMessage += "*Fail Mark - Template " + (m_intTemplateIndex + 1)
            //                          + ", Char" + (i + 1) + " " + strText[counter] + " : Set="
            //                          + fSetValue.ToString() + "% Score= "
            //                          + CandidateResult[i].ToString("F2") + "%";
            //        }
            //        counter++;
            //    }
            //}
            return m_strErrorMessage;
        }

        public string OCR2GetMessage(int type)
        {
            //string s = mobjOCR.getMessage(type);
            //return s;
            return "";
        }

        public bool CheckNoMark(ROI objNoMarkROI, int intInspectionMethod, int intInspectionAreaGrayValueSensitivity, int intBrightSensitivity)
        {
            ResetInspectionData(true);

            m_intTotalBlobArea = 0;

            // Get fix value threshold
            int intThresholdValue = GetAutoThreshold(objNoMarkROI);

            //2020-05-20 ZJYEOH : Use gray value threshold
            if (intInspectionMethod == 1)
                intThresholdValue = GetGrayValueThreshold(objNoMarkROI, intInspectionAreaGrayValueSensitivity, intBrightSensitivity);

            if (m_blnWhiteOnBlack)
                m_intTotalBlobArea = ROI.GetPixelArea(objNoMarkROI, intThresholdValue, 1);
            else
                m_intTotalBlobArea = ROI.GetPixelArea(objNoMarkROI, intThresholdValue, 0);
            
            if (m_intTotalBlobArea < (int)Math.Round(m_fNoMarkMaximumBlobArea))
            {
                if ((m_intFailResultMask & 0x1000) == 0)
                    m_intFailResultMask |= 0x1000;
                
                m_strErrorMessage = "*No Mark! Set = " + GetNoMarkMaximumBlobArea().ToString() + " " + GetDisplayUnitName(m_intDisplayUnitMode, true) + ", " +
                    "Result = " + GetResultTotalBlobArea().ToString() + " " + GetDisplayUnitName(m_intDisplayUnitMode, true) + ".";
                
                m_blnLock = false;
                m_blnLockBlobs = false;
                return false;
            }
            return true;
        }

        //public void AnalysisMarkGrid(int intGroupIndex, int intTemplateIndex, int intCharIndex)
        //{
        //    int intXCount = m_arrTemplateSetting[intGroupIndex][intTemplateIndex].intCharLink_Top[intCharIndex].Count;
        //    if (intXCount == 0)
        //    {
        //        return;
        //    }
        //    int intYCount = m_arrTemplateSetting[intGroupIndex][intTemplateIndex].intCharLink_Top[intCharIndex][0].Count;

        //    // Loop grid to find first point
        //    for (int x = 0; x < intXCount; x++)
        //    {
        //        for (int y = 0; y < intYCount; y++)
        //        {
                    
        //        }
        //    }
        //}
    }
}
