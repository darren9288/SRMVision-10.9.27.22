using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using System.IO;
using Common;
using System.Windows.Forms;
#if (Debug_2_12 || Release_2_12)
using Euresys.Open_eVision_2_12;
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
using Euresys.Open_eVision_1_2;
#endif

namespace VisionProcessing
{
    public class Lead3D
    {
        #region enum

        public enum PointIndex { BaseCenter = 0, BaseStart = 1, BaseEnd = 2, TipCenter = 3, TipStart = 4, TipEnd = 5 };
        public enum PointIndex_Side { TipCenter = 0, TipStart = 1, TipEnd = 2 };
        public enum PointIndex_Corner { Corner1 = 0, Corner2 = 1 };

        #endregion

        #region Member Variables

        //Calibration with range
        private Line m_obj2DCenterCalibrateLineX1 = new Line();
        private Line m_obj2DCenterCalibrateLineX2 = new Line();
        private Line m_obj2DCenterCalibrateLineX3 = new Line();
        private Line m_obj2DCenterCalibrateLineX4 = new Line();
        private Line m_obj2DCenterCalibrateLineX5 = new Line();
        private Line m_obj2DCenterCalibrateLineY1 = new Line();
        private Line m_obj2DCenterCalibrateLineY2 = new Line();
        private Line m_obj2DCenterCalibrateLineY3 = new Line();
        private Line m_obj2DCenterCalibrateLineY4 = new Line();
        private Line m_obj2DCenterCalibrateLineY5 = new Line();
        private Line m_obj3DCalibrateLine1 = new Line();
        private Line m_obj3DCalibrateLine2 = new Line();

        private float m_f2DCenterPixelCountX1;
        private float m_f2DCenterPixelCountX2;
        private float m_f2DCenterPixelCountX3;
        private float m_f2DCenterPixelCountX4;
        private float m_f2DCenterPixelCountX5;
        private float m_f2DCenterPixelCountY1;
        private float m_f2DCenterPixelCountY2;
        private float m_f2DCenterPixelCountY3;
        private float m_f2DCenterPixelCountY4;
        private float m_f2DCenterPixelCountY5;
        private float m_f3DPixelCount1;
        private float m_f3DPixelCount2;
        private float m_f2DCenterMMX1;
        private float m_f2DCenterMMX2;
        private float m_f2DCenterMMX3;
        private float m_f2DCenterMMX4;
        private float m_f2DCenterMMX5;
        private float m_f2DCenterMMY1;
        private float m_f2DCenterMMY2;
        private float m_f2DCenterMMY3;
        private float m_f2DCenterMMY4;
        private float m_f2DCenterMMY5;
        private float m_f3DMM1;
        private float m_f3DMM2;
        private float m_f3DAngle;

        private bool m_blnPatternMatchSuccess = true;
        private bool m_blnBuildSideLeadSuccess = true;
        private int m_intGaugeSizeImageIndex = 0;
        private int m_intCheckLeadDimensionImageIndex = 0;
        private bool m_blnWhiteOnBlack = true;
        private bool m_blnSelected = false;
        private bool m_blnWantUseClosestSizeDefineTolerance = false;
        private bool m_blnViewLeadResultDrawing = false;
        private bool m_blnWantTightSetting = false;
        private bool m_blnClockWise = false; //true=clockwise, false=counterclockwise 
        private bool m_blnLock = false;
        private bool m_blnFindLeadCenterPointsDone = false;
        private bool m_blnWantDebug = false;
        private int m_intThresholdValue = -4;
        private int m_intThresholdValuePrev = -4;
        private int m_intLeadROIDirection = 0;  //0=Center, 1=Top, 2=Right, 3=Bottom, 4=Left
        private int m_intFilterMinArea = 20;
        private int m_intMaxArea = 25000000;
        private int m_intNumberOfLead = 1;
        private int m_intSensitivityOnLeadMethod = 0;    // 0=No add Sensitivity Feature On Lead, 1= Add Split Feature On Lead, 2=Add Merge Feature On Lead
        private int m_intSensitivityOnLeadValue = 0;     // 1 to 10        private int m_intBaseOffset = 0; //offset from base to calculate base width
        private int m_intBaseOffset = 0; //offset from base to calculate base width
        private int m_intTipOffset = 0; //offset from tip to calculate top width
        private int m_intTipOffsetSide = 0; //offset from tip to calculate top width (Side ROI)
        private int m_intFirstLead = 0; //Use to define position of first lead (0=top, 1=right, 2=bottom, 3=left)
        private int m_intBaseLineTrimFromEdge = 6;  // Use for Side ROI to get correct base line when multi baseline steps case happen. It will trim edge of base line width before measure the base line.
        private int m_intBaseLineSteps = 1; // Use for Side ROI to get correct base line when multi baseline steps case happen. Sequence will loop base on this m_intBaseLineSteps value to get measure base line.
        private int m_intLeadDirection = 0;  // 0=Horizontal, 1=Vertical
        private float m_fImageGain = 1f;
        private float m_fTightSettingTolerance = 0.01f;
        private float m_fBlobsMinArea = 200f;
        private float m_fDefineSizePixel = 3;       // Use to define lead's direction mask(left, right, top, bottom or/and center)
        private float m_fDefaultPixelTolerance = 3; // For lead dimension default min and max tolerance.
        private float m_fTotalExtraArea = 0;
        private float m_fPointGaugeToleranceRate = 1f / 4f;
        private int m_intPointGaugeLoopMax = 3;
        private string m_strErrorMessage;
        private Font m_Font = new Font("Verdana", 10);

        private Object m_objLockBlobs = new Object();
        private EBlobs m_objEBlobs = new EBlobs();
        private EBlobs m_objExtraLeadEBlobs = new EBlobs();
        private BlobsFeatures m_stcBlobLead = new BlobsFeatures();
        private Contour[] m_arrTemplateContour;
        private PGauge m_objPointGauge;
        private List<List<PGauge>> m_arrCenterPointGauge = new List<List<PGauge>>();
        private List<List<PGauge>> m_arrSidePointGauge = new List<List<PGauge>>();
        private List<PGauge> m_arrCornerPointGauge= new List<PGauge>();
        private LGauge m_objLineGauge;   // Use to measure unit base line in side ROI.

        private ArrayList m_arrTemplateBlobBodyLeads = new ArrayList();
        private ArrayList m_arrTemplateBlobLeads = new ArrayList();
        private ArrayList m_arrTemplateFilteredBlobLeads = new ArrayList();
        private ArrayList m_arrTemporaryBlobLeads = new ArrayList();
        private ArrayList m_arrBackupTemplateBlobLeads = new ArrayList();
        private ToleranceBlobsFeatures m_stcBackupTemplateBlobLead = new ToleranceBlobsFeatures();   // Keep previous tolerance setting for learning 

        private SampleBlobsFeatures m_stcSampleBlobLead = new SampleBlobsFeatures();
        private List<BlobsFeatures> m_arrSampleBlobSideLeads = new List<BlobsFeatures>();
        private List<BlobsFeatures> m_arrSampleBlobBodyLeads = new List<BlobsFeatures>();
        private SampleBlobsFeatures[] m_arrSampleBlobLeads;          // sample blobs
        private List<SampleExtraBlobsFeatures> m_arrExtraBlobs; // Extra lead, join lead

        private PitchGap m_stcPitchGap = new PitchGap();
        private ArrayList m_arrTolePitchGap = new ArrayList();
        private List<PitchGap> m_arrPitchGap = new List<PitchGap>();
        private List<PitchGap> m_arrBackupPitchGap = new List<PitchGap>();
        private List<PitchGap> m_arrFailPitchGapList;
        private TolerancePitchGap m_stcTolePitchGap = new TolerancePitchGap();      // Keep previous tolerance setting for learning

        // Lead3D
        private ROI m_objLocalROI = new ROI();
        private int m_intNumberOfLead_Top = 0;
        private int m_intNumberOfLead_Bottom = 0;
        private int m_intNumberOfLead_Left = 0;
        private int m_intNumberOfLead_Right = 0;
        private PointF m_pCornerPoint_Left = new PointF(0, 0);
        private PointF m_pCornerPoint_Right = new PointF(0, 0);
        private PointF m_pCornerPoint_Top = new PointF(0, 0);
        private PointF m_pCornerPoint_Bottom = new PointF(0, 0);
        private PointF m_pCornerPoint_TopLeft = new PointF(0, 0);
        private PointF m_pCornerPoint_TopRight = new PointF(0, 0);
        private PointF m_pCornerPoint_BottomLeft = new PointF(0, 0);
        private PointF m_pCornerPoint_BottomRight = new PointF(0, 0);
        private PointF m_pCornerPoint_Center = new PointF(0, 0);
        private float m_fTemplateMatcher_CenterX = 0;
        private float m_fTemplateMatcher_CenterY = 0;
        private float m_fTemplateCornerPoint_CenterX = 0;
        private float m_fTemplateCornerPoint_CenterY = 0;
        private float m_fCenterUnitAngle = 0;
        private float m_fCenterUnitWidth = 0;
        private float m_fCenterUnitHeight = 0;
        private float m_fBaseLineAngle = 0;
        private bool m_blnWantUseAGVMasking = true;
        private bool m_blnWantUseAverageGrayValueMethod = false;
        private bool m_blnWantUsePkgToBaseTolerance = false;
        private bool m_blnWantUseGaugeMeasureBase = false;
        private int m_intImageRotateOption = 0;//0=Package Angle, 1=Pattern Angle 
        private bool m_blnMeasureCenterPkgSizeUsingCorner = false;
        private int m_intLeadWidthDisplayOption = 0; // 0: 2D Width ; 1: 3D Width ; 2: Max of 2D or 3D
        private int m_intLeadLengthVarianceMethod = 0; // 0: Side ; 1: Overall ; 2: Side & Overall
        private int m_intLeadSpanMethod = 0; // 0: Side ; 1: Overall ; 2: Side & Overall
        private int m_intLeadStandOffMethod = 0; // 0: Max Point ; 1: Tip Point ;
        private int m_intLeadContaminationRegion = 0; // 0: Lead Region ; 1: Package Region ; 2: Lead & Package Region
        private bool m_blnWantDontCareArea_Lead3D = false;
        private float m_fAngleTolerance = 1;
        private float m_fXTolerance = 10;
        private float m_fYTolerance = 10;
        private bool m_blnFailPosition = false;
        private int m_intLeadWidthRangeSelection = 0;  // 0: Refer to Lead Shoulder, 1: Refer to Lead Tip
        private int m_intLeadWidthRange = 10;
        private int m_intMatchingXTolerance = 10;
        private int m_intMatchingYTolerance = 10;

        private int m_intPkgToBaseTolerance_Top = 0;
        private int m_intPkgToBaseTolerance_Right = 0;
        private int m_intPkgToBaseTolerance_Bottom = 0;
        private int m_intPkgToBaseTolerance_Left = 0;

        private int m_intTipBuildAreaTolerance_Top = 0;
        private int m_intTipBuildAreaTolerance_Right = 0;
        private int m_intTipBuildAreaTolerance_Bottom = 0;
        private int m_intTipBuildAreaTolerance_Left = 0;

        private int[] m_arrCornerSearchingTolerance_Top = new int[2] { 0, 0 };
        private int[] m_arrCornerSearchingTolerance_Right = new int[2] { 0, 0 };
        private int[] m_arrCornerSearchingTolerance_Bottom = new int[2] { 0, 0 };
        private int[] m_arrCornerSearchingTolerance_Left = new int[2] { 0, 0 };
        private int[] m_arrCornerSearchingLength = new int[2] { 0, 0 };

        private PGauge m_objSettingPointGauge;
        private bool m_blnDrawSidePointGauge = true; // true: Draw Side Point Gauge , false: Draw Corner Point Gauge
        private int m_intSelectedLeadNo = 0;
        //Center
        private int m_intSelectedCenterDirectionIndex = 0;
        private List<List<float>> m_arrLead3DCenterPointGaugeStartX = new List<List<float>>();
        private List<List<float>> m_arrLead3DCenterPointGaugeStartY = new List<List<float>>();
        private List<List<float>> m_arrLead3DCenterPointGaugeTolerance = new List<List<float>>();
        private List<List<float>> m_arrLead3DCenterPointGaugeAngle = new List<List<float>>();
        private List<List<PointF>> m_arrLead3DEdgeCenterGaugePoints = new List<List<PointF>>();
        private List<List<bool>> m_arrLead3DEdgeCenterGaugePointsFound = new List<List<bool>>();
        private List<int> m_arrLead3DEdgeCenterGaugePointsPosition = new List<int>();
        //Side
        private int m_intSelectedSideDirectionIndex = 0;
        private List<List<float>> m_arrLead3DSidePointGaugeStartX = new List<List<float>>();
        private List<List<float>> m_arrLead3DSidePointGaugeStartY = new List<List<float>>();
        private List<List<float>> m_arrLead3DSidePointGaugeTolerance = new List<List<float>>();
        private List<List<float>> m_arrLead3DSidePointGaugeAngle = new List<List<float>>();
        private List<List<PointF>> m_arrLead3DEdgeSideGaugePoints = new List<List<PointF>>();
        private List<List<bool>> m_arrLead3DEdgeSideGaugePointsFound = new List<List<bool>>();
        private List<int> m_arrLead3DEdgeSideGaugePointsPosition = new List<int>();
        //Corner
        private int m_intSelectedCornerDirectionIndex = 0;
        private List<List<float>> m_arrLead3DCornerPointGaugeStartX = new List<List<float>>();
        private List<List<float>> m_arrLead3DCornerPointGaugeStartY = new List<List<float>>();
        private List<List<float>> m_arrLead3DCornerPointGaugeTolerance = new List<List<float>>();
        private List<List<float>> m_arrLead3DCornerPointGaugeAngle = new List<List<float>>();
        private List<List<PointF>> m_arrLead3DEdgeCornerGaugePoints = new List<List<PointF>>();
        private List<List<bool>> m_arrLead3DEdgeCornerGaugePointsFound = new List<List<bool>>();

        // ------ Whole Leads Result ------------------------------
        private float m_fPitchVarianceLeftResult = 0;
        private float m_fPitchVarianceRightResult = 0;
        private float m_fPitchVarianceTopResult = 0;
        private float m_fPitchVarianceBottomResult = 0;

        private float m_fLengthVarianceOverallResult = 0;
        private float m_fLengthVarianceLeftResult = 0;
        private float m_fLengthVarianceRightResult = 0;
        private float m_fLengthVarianceTopResult = 0;
        private float m_fLengthVarianceBottomResult = 0;

        private float m_fStandOffVarianceLeftResult = 0;
        private float m_fStandOffVarianceRightResult = 0;
        private float m_fStandOffVarianceTopResult = 0;
        private float m_fStandOffVarianceBottomResult = 0;
        private float m_fStandOffVarianceUnitResult = 0;

        private float m_fLeadSweepVarianceLeftResult = 0;
        private float m_fLeadSweepVarianceRightResult = 0;
        private float m_fLeadSweepVarianceTopResult = 0;
        private float m_fLeadSweepVarianceBottomResult = 0;

        private float m_fSpanOverallResult = 0;
        private float m_fSpanTopResult = 0;
        private float m_fSpanBottomResult = 0;
        private float m_fSpanLeftResult = 0;
        private float m_fSpanRightResult = 0;

        // ------ Whole Leads Setting ----------------------------
        private float m_fPitchVarianceLeftMaxSetting = 0;
        private float m_fPitchVarianceRightMaxSetting = 0;
        private float m_fPitchVarianceTopMaxSetting = 0;
        private float m_fPitchVarianceBottomMaxSetting = 0;

        private float m_fStandOffVarianceLeftMaxSetting = 0;
        private float m_fStandOffVarianceRightMaxSetting = 0;
        private float m_fStandOffVarianceTopMaxSetting = 0;
        private float m_fStandOffVarianceBottomMaxSetting = 0;
        private float m_fStandOffVarianceUnitMaxSetting = 0;

        private float m_fLeadSweepVarianceLeftMinSetting = 0;
        private float m_fLeadSweepVarianceRightMinSetting = 0;
        private float m_fLeadSweepVarianceTopMinSetting = 0;
        private float m_fLeadSweepVarianceBottomMinSetting = 0;

        private float m_fLeadSweepVarianceLeftMaxSetting = 0;
        private float m_fLeadSweepVarianceRightMaxSetting = 0;
        private float m_fLeadSweepVarianceTopMaxSetting = 0;
        private float m_fLeadSweepVarianceBottomMaxSetting = 0;

        private float m_fSpanOverallMinSetting = 0;
        private float m_fSpanOverallMaxSetting = 0;
        private float m_fSpanTopMinSetting = 0;
        private float m_fSpanTopMaxSetting = 0;
        private float m_fSpanBottomMinSetting = 0;
        private float m_fSpanBottomMaxSetting = 0;
        private float m_fSpanLeftMinSetting = 0;
        private float m_fSpanLeftMaxSetting = 0;
        private float m_fSpanRightMinSetting = 0;
        private float m_fSpanRightMaxSetting = 0;

        private float m_fLengthVarianceOverallMaxSetting = 0;
        private float m_fLengthVarianceLeftMaxSetting = 0;
        private float m_fLengthVarianceRightMaxSetting = 0;
        private float m_fLengthVarianceTopMaxSetting = 0;
        private float m_fLengthVarianceBottomMaxSetting = 0;

        private Line m_objBaseLine = new Line();
        private Line m_objEdgeLine_Left = new Line();
        private Line m_objEdgeLine_Right = new Line();
        private Line m_objEdgeLine_Top = new Line();
        private Line m_objEdgeLine_Bottom = new Line();
        /// <summary>
        /// 0x01=Stand Off  (table)
        /// 0x02=Coplan     (table)
        /// 0x04=LeadSweeps
        /// 0x08=Solder Pad Length  (table)
        /// 0x10=Un-Cut Tiebar
        /// 0x20=Missing Lead
        /// 0x40=Width  (table)
        /// 0x80=Height or Length   (table)
        /// 0x100=Skew
        /// 0x200=pitch (table)
        /// 0x400=gap
        /// 0x800=Length variance
        /// 0x1000=Span
        /// 0x2000=Pitch Variance
        /// 0x4000=Stand Off Variance 
        /// 0x8000=Contamination Length/Area
        /// 0x10000=Total Contamination Area
        /// 0x20000= Offset
        /// 0x40000= Average Gray Value
        /// 0x80000=Gap Variance
        /// 0x100000 = Lead Min and Max Width
        /// 0x200000 = Lead Burr Width
        /// 0x400000= Side ROI Width  (table)
        /// </summary>
        private int m_intFailOptionMask = 0;
        /// <summary>
        /// 0x01=Stand Off  (table)
        /// 0x02=Coplan     (table)
        /// 0x04=LeadSweeps
        /// 0x08=Solder Pad Length  (table)
        /// 0x10=Un-Cut Tiebar
        /// 0x20=Missing Lead
        /// 0x40=Width  (table)
        /// 0x80=Height or Length   (table)
        /// 0x100=Skew
        /// 0x200=pitch (table)
        /// 0x400=gap
        /// 0x800=Length variance
        /// 0x1000=Span
        /// 0x2000=Pitch Variance
        /// 0x4000=Stand Off Variance 
        /// 0x8000=Contamination Length/Area
        /// 0x10000=Total Contamination Area
        /// 0x20000= Offset
        /// 0x40000= Average Gray Value
        /// 0x80000=Gap Variance
        /// 0x100000 = Lead Min and Max Width
        /// 0x200000 = Lead Burr Width
        /// 0x400000= Side ROI Width  (table)
        /// 0x800000= Build Side ROI Fail
        /// </summary>
        private int[] m_arrFailResultMask = new int[5]; // Index 0=Center, 1=Top, 2=Right, 3=Bottom, 4=Left     
        private bool m_blnFailForeignMaterialLength = false;
        private bool m_blnFailForeignMaterialArea = false;
        private bool m_blnFailForeignMaterialTotalArea = false;
        private int[] m_intTemplateMatchStatus;
        private int[] m_intSampleMatchNumber;
        private List<int> m_arrSampleMatchNumber = new List<int>();
        private float m_fLeadRangeStartX;
        private float m_fLeadRangeStartY;
        private float m_fLeadRangeEndX;
        private float m_fLeadRangeEndY;
        private float m_fSampleLeadRangeStartX;
        private float m_fSampleLeadRangeStartY;
        private float m_fSampleLeadRangeEndX;
        private float m_fSampleLeadRangeEndY;

        //Template span data
        private float m_fLeadMinSpanStart;
        private float m_fLeadMinSpanEnd;
        private float m_fLeadMaxSpanStart;
        private float m_fLeadMaxSpanEnd;
        private float m_fTemplateLeadMinSpanLimit;
        private float m_fTemplateLeadMaxSpanLimit;

        //Sample span data
        private float m_fSampleLeadMinSpanStart;
        private float m_fSampleLeadMinSpanEnd;
        private float m_fSampleLeadMaxSpanStart;
        private float m_fSampleLeadMaxSpanEnd;
        private float m_fLeadMinSpanResult;
        private float m_fLeadMaxSpanResult;

        private float m_fReferencePointStartX;
        private float m_fReferencePointStartY;
        private float m_fReferencePointEndX;
        private float m_fReferencePointEndY;
        private float m_fSampleReferencePointStartX;
        private float m_fSampleReferencePointStartY;
        private float m_fSampleReferencePointEndX;
        private float m_fSampleReferencePointEndY;

        // PRS for unit position and angle.
        private EMatcher m_objMatcher = new EMatcher();
        //private EPatternFinder m_objFinder = new EPatternFinder();
        private PointF m_pUnitCenterPoint = new PointF();
        private float m_fUnitAngle = 0f;


        // Calibration
        private float m_fAreaMMPerPixel = 14;
        private float m_fMMPerPixelX = 1;
        private float m_fMMPerPixelY = 1;

        private float m_fSizeOffSetX = 0;
        private float m_fSizeOffSetY = 0;

        private float m_fMMToPixelXValue = 1;
        private float m_fMMToPixelYValue = 1;
        private float m_fMMtoPixelAreaValue = 1;

        private float m_fMMToUnitValue = 1;
        private float m_fMMToUnitValueArea = 1;

        private float m_intDecimal = 4;
        private float m_intDecimal2 = 6;

        private int m_intExtraBlobID = 0;
        private bool m_blnWantCheckExtraLeadLength = false;
        private bool m_blnWantCheckExtraLeadArea = false;
        private float m_fBaseLineMaxAngle = 0;
        private float m_fTotalExtraLeadSetArea = 0.004f;
        private float m_fExtraLeadSetArea = 0.004f;
        private float m_fExtraLeadSetLength = 0.001f;

        // Template Image
        private EImageBW8 m_ImgSearchROITemplateImage = new EImageBW8();
        private EImageBW8 m_ImgUnitTemplateImage = new EImageBW8();
        private EImageBW8 m_ImgTUnitDilateThresImage = new EImageBW8();
        private EImageBW8 m_ImgTUnitErodeThresImage = new EImageBW8();
        private EImageBW8 m_ImgTUnitInvertThresImage = new EImageBW8();
        private EImageBW8 m_ImgTLeadImage1 = new EImageBW8();
        private EImageBW8 m_ImgWhiteUnitTemplateImage = new EImageBW8();
        private EImageBW8 m_ImgWhiteUnitTemplateImage2 = new EImageBW8();
        private EImageBW8 m_ImgBlackUnitTemplateImage = new EImageBW8();
        private EImageBW8 m_ImgBlackUnitTemplateImage2 = new EImageBW8();
        private EImageBW8 m_ImgMPUnitTemplateImage = new EImageBW8();
        private List<EImageBW8> m_arrImgLeadImage = new List<EImageBW8>();

        //Dont Care Image
        private ImageDrawing m_objLead3DDontCareImage = new ImageDrawing();
        #endregion

        #region Package Member Variables

        private RectGauge4L m_objRectGauge4L;
        private bool m_blnDrawSamplingPoint = false;
        private bool m_blnDrawDraggingBox = false;
        private bool m_blnDrawTransitionTypeArrow = false;
        private int m_intSelectedGaugeEdgeMask = 0x0F;  // 0x01=Top edge, 0x02=Right edge, 0x04=Bottom edge, 0x08=Left edge

        private EImageBW8 m_ImgUnitTemplateImagePkg = new EImageBW8(); //Package
        private EImageBW8 m_ImgTUnitDilateThresImagePkg = new EImageBW8();//Package
        private EImageBW8 m_ImgTUnitErodeThresImagePkg = new EImageBW8();//Package
        private EImageBW8 m_ImgTUnitInvertThresImagePkg = new EImageBW8();//Package
        private EImageBW8 m_ImgWhiteUnitTemplateImagePkg = new EImageBW8();//Package
        private EImageBW8 m_ImgBlackUnitTemplateImagePkg = new EImageBW8();//Package

        private ImageDrawing m_objInsSurfacePkgImage1;
        private ImageDrawing m_objInsChipOffPkgImage1;
        private ImageDrawing m_objInsPkgImage2;
        private ImageDrawing m_objInsChipOffPkgImage2;
        private ImageDrawing m_objInsPkgImage3;

        private bool m_blnInspectPackage;
        //private bool m_blnUseDetailDefectCriteria = false;
        private List<int> m_arrGrabImageIndex = new List<int>();   // Record grab image index for different defect checking. // 0: Pkg Size, 1: Pkg Defect Bright Field, 2: Pkg Defect Dark Field

        private bool m_blnPkgDefectSelected = false;

        private float m_fPkgStartPixelFromEdge = 0;             // Tolerance edge for Package ROI during package inspection. E.g If Unit pkg size is 2x2mm, and the m_fPkgStartPixelFromEdge is 0.02mm, mean the the actual area for pkg inspection is 1.98x1.98mm.
        private float m_fPkgStartPixelFromRight = 0;
        private float m_fPkgStartPixelFromBottom = 0;
        private float m_fPkgStartPixelFromLeft = 0;
        private int m_intPkgSizeTolerance = 3;                    // Tolerance size for unit. E.g. If unit size is 100 x 120pixels , mean the actual size to find the pads will 103x 123 pixels.

        private bool m_blnViewEdgeNotFoundDrawing = false;
        private bool m_blnViewPkgSizeDrawing = false;
        private bool m_blnViewPkgResultDrawing = false;

        private int m_intPkgImage1HighPadThreshold = 255;     // not using
        private int m_intPkgImage1LowPadThreshold = 0;        // not using
        private int m_intPkgImage1HighSurfaceThreshold = 255;
        private int m_intPkgImage1LowSurfaceThreshold = 0;
        private float m_fPkgImage1Gain = 1f;
        private int m_intPkgImage2HighThreshold = 255;
        private int m_intPkgImage2LowThreshold = 0;
        private int m_intPkgImage3HighThreshold = 255;
        private int m_intPkgImage3LowThreshold = 0;
        private int m_intPkgImage1MoldFlashThreshold = 125;
        private int m_intPkgImage2VoidThreshold = 125;
        private int m_intPkgImage2HighCrackThreshold = 255;
        private int m_intPkgImage2LowCrackThreshold = 0;
        private int m_intPkgImage1ChippedThreshold = 125;
        private int m_intBrightFieldLowThreshold = 50;
        private int m_intBrightFieldHighThreshold = 255;
        private int m_intDarkFieldLowThreshold = 50;
        private float m_fDarkFieldImageGain = 1f;
        private int m_intDarkFieldHighThreshold = 255;

        private float m_fUnitWidth;
        private float m_fUnitHeight;
        private float m_fUnitThickness;
        private float m_fUnitWidthMin;
        private float m_fUnitWidthMax;
        private float m_fUnitHeightMin;
        private float m_fUnitHeightMax;
        private float m_fUnitThicknessMin;
        private float m_fUnitThicknessMax;
        private float m_fUnitSizeLength;

        private int m_intMPTolerance; // Morphology Half Width tolerance. (Some leads has quite large different size from one unit to another unit especially small unit)

        // Detail Defect Criteria Tolerance Setting
        private float m_fScratchLength;
        private float m_fScratchArea;
        private float m_fChipArea;
        private float m_fContaminationLength;
        private float m_fSolderMeltLength;
        private float m_fVoidLength;
        private float m_fVoidArea;
        private float m_fCrackLength;
        private float m_fCrackArea;
        private float m_fMoldFlashArea;
        private float m_fMoldFlashLength;
        private float m_fInCompletePlateLength;
        private float m_fLeadBrokenLength;
        private float m_fLeadBrokenArea;
        private float m_fChipStartPixelFromEdge;
        private float m_fChipStartPixelFromRight;
        private float m_fChipStartPixelFromLeft;
        private float m_fChipStartPixelFromBottom;
        private float m_fMoldStartPixelFromEdge;
        private float m_fMoldStartPixelFromRight;
        private float m_fMoldStartPixelFromLeft;
        private float m_fMoldStartPixelFromBottom;

        // Seperate Defect Setting
        private bool m_blnSeperateCrackDefectSetting = false;
        private bool m_blnSeperateMoldFlashDefectSetting = false;
        private bool m_blnSeperateChippedOffDefectSetting = false;

        // Simple Defect Criteria Tolerance Setting
        private float m_fResultBrightFieldTotalArea = -1;
        private float m_fResultDarkFieldTotalArea = -1;
        private float m_fBrightLength;
        private float m_fBrightWidth;
        private float m_fBrightArea;
        private float m_fBrightTotalArea;
        private float m_fDarkLength;
        private float m_fDarkWidth;
        private float m_fDarkArea;
        private float m_fDarkTotalArea;
        private float m_fBrightChippedOffArea;
        private float m_fDarkChippedOffArea;
        private float m_fDarkVerticalCrack;
        private float m_fDarkHorizontalCrack;

        private float m_fFilterMinArea = 20; //For learning
        private float m_fImageMerge2BlobsMinArea = 20; //For inspection
        private float m_fSurfaceMinArea = 20; //For inspection
        private float m_fImage2SurfaceMinArea = 20; //For inspection
        private float m_fMoldFlashMinArea = 20; //For inspection
        private float m_fVoidMinArea = 20;//For inspection
        private float m_fCrackMinArea = 20;//For inspection
        private int m_intBrightFieldMinArea = 20;
        private int m_intDarkFieldMinArea = 20;

        private EBlobs m_objImage1LeadEBlobs = new EBlobs();
        private EBlobs m_objImage1ChipOffEBlobs = new EBlobs();
        private EBlobs m_objImage1ChipOffEBlobsFor2Pixel = new EBlobs();
        private EBlobs m_objImage1SurfaceEBlobs = new EBlobs();
        private EBlobs m_objImage2SurfaceEBlobs = new EBlobs();
        private EBlobs m_objImage2ChipOffEBlobs = new EBlobs();
        private EBlobs m_objImage3EBlobs = new EBlobs();
        private EBlobs m_objImage1MoldFlashEBlobs = new EBlobs();

        /// <summary>
        /// 0x01: Package Size
        /// 0x04: Chipped off Area
        /// 0x08: Scratches Area
        /// 0x10: Contamination Length
        /// 0x20: Contamination Area
        /// 0x40: Contamination Total Area
        /// 0x80: Mold Flash
        /// 0x100: Void Length
        /// 0x200: Void Area
        /// 0x400: Crack Length
        /// 0x800: Crack Area
        /// 0x1000: Scratches Length
        /// 0x10000: Bright Area
        /// 0x20000: Bright Length
        /// 0x40000: Dark Area
        /// 0x80000: Dark Length
        /// </summary>
        private int m_intFailPkgOptionMask = 0;
        /// <summary>
        /// 0x01: Package Size
        /// 0x02: Crack
        /// 0x04: Chipped Off
        /// 0x08: Scratches
        /// 0x10: Contamination
        /// 0x20: Solder melt
        /// 0x40: Void
        /// 0x80: Mold Flash
        /// 0x100: Incomplete Plating
        /// 0x10000: Bright
        /// 0x20000: Dark
        /// </summary>
        private int m_intFailPkgResultMask = 0;

        struct Defect
        {
            public string ref_strName;
            public float ref_fStartX;
            public float ref_fStartY;
            public float ref_fEndX;
            public float ref_fEndY;
            public float ref_fWidth;        // Keep defect pixel value for drawing
            public float ref_fHeight;       // Keep defect pixel value for drawing
            public float ref_fArea;
            public float ref_fAngle;
            public float ref_fCenterX;
            public float ref_fCenterY;
            public float ref_fFailValue;    // Keep fail value for display message
            public float ref_fWidthFailValue;
            public float ref_fHeightFailValue;
            public float ref_fAreaFailValue;
            public int ref_intBlobNo;
            // 0x01: Package Size
            // 0x02: Crack
            // 0x04: Chipped Off
            // 0x08: Scratches
            // 0x10: Contamination
            // 0x20: Solder melt
            // 0x40: Void
            // 0x80: Mold Flash
            // 0x100: Incomplete Plating
            // 0x10000: Bright
            // 0x20000: Dark
            public int ref_intFailMask;
            public int ref_intFailCriteria; // 0x01:width, 0x02:Height, 0x04:Area
            public int ref_intImageNo;
            public float ref_fWidthInMM;
            public float ref_fHeightInMM;
            public float ref_fAreaInMM2;
        }

        private List<Defect> m_arrPkgDefectList = new List<Defect>();

        #endregion

        #region Package Properties
        public bool ref_blnPkgDefectSelected { get { return m_blnPkgDefectSelected; } set { m_blnPkgDefectSelected = value; } }
        public RectGauge4L ref_objRectGauge4L { get { return m_objRectGauge4L; } set { m_objRectGauge4L = value; } }
        public bool ref_blnDrawSamplingPoint { get { return m_blnDrawSamplingPoint; } set { m_blnDrawSamplingPoint = value; } }
        public bool ref_blnDrawDraggingBox { get { return m_blnDrawDraggingBox; } set { m_blnDrawDraggingBox = value; } }
        public bool ref_blnDrawTransitionTypeArrow { get { return m_blnDrawTransitionTypeArrow; } set { m_blnDrawTransitionTypeArrow = value; } }
        public int ref_intSelectedGaugeEdgeMask { get { return m_intSelectedGaugeEdgeMask; } set { m_intSelectedGaugeEdgeMask = value; } }
        public bool ref_blnViewEdgeNotFoundDrawing { get { return m_blnViewEdgeNotFoundDrawing; } set { m_blnViewEdgeNotFoundDrawing = value; } }
        public bool ref_blnViewPkgSizeDrawing { get { return m_blnViewPkgSizeDrawing; } set { m_blnViewPkgSizeDrawing = value; } }
        public bool ref_blnViewPkgResultDrawing { get { return m_blnViewPkgResultDrawing; } set { m_blnViewPkgResultDrawing = value; } }
        public int ref_intFailPkgOptionMask { get { return m_intFailPkgOptionMask; } set { m_intFailPkgOptionMask = value; } }
        public int ref_intFailPkgResultMask { get { return m_intFailPkgResultMask; } set { m_intFailPkgResultMask = value; } }
        public bool ref_blnSeperateCrackDefectSetting { set { m_blnSeperateCrackDefectSetting = value; } get { return m_blnSeperateCrackDefectSetting; } }
        public bool ref_blnSeperateMoldFlashDefectSetting { set { m_blnSeperateMoldFlashDefectSetting = value; } get { return m_blnSeperateMoldFlashDefectSetting; } }
        public bool ref_blnSeperateChippedOffDefectSetting { set { m_blnSeperateChippedOffDefectSetting = value; } get { return m_blnSeperateChippedOffDefectSetting; } }
        //public bool ref_blnUseDetailDefectCriteria { get { return m_blnUseDetailDefectCriteria; } set { m_blnUseDetailDefectCriteria = value; } }
        public float ref_fMoldStartPixelFromEdge { get { return m_fMoldStartPixelFromEdge; } set { m_fMoldStartPixelFromEdge = value; } }
        public float ref_fMoldStartPixelFromRight { get { return m_fMoldStartPixelFromRight; } set { m_fMoldStartPixelFromRight = value; } }
        public float ref_fMoldStartPixelFromBottom { get { return m_fMoldStartPixelFromBottom; } set { m_fMoldStartPixelFromBottom = value; } }
        public float ref_fMoldStartPixelFromLeft { get { return m_fMoldStartPixelFromLeft; } set { m_fMoldStartPixelFromLeft = value; } }
        public float ref_fChipStartPixelFromEdge { get { return m_fChipStartPixelFromEdge; } set { m_fChipStartPixelFromEdge = value; } }
        public float ref_fChipStartPixelFromRight { get { return m_fChipStartPixelFromRight; } set { m_fChipStartPixelFromRight = value; } }
        public float ref_fChipStartPixelFromBottom { get { return m_fChipStartPixelFromBottom; } set { m_fChipStartPixelFromBottom = value; } }
        public float ref_fChipStartPixelFromLeft { get { return m_fChipStartPixelFromLeft; } set { m_fChipStartPixelFromLeft = value; } }
        public float ref_fPkgStartPixelFromEdge { get { return m_fPkgStartPixelFromEdge; } set { m_fPkgStartPixelFromEdge = value; } }
        public float ref_fPkgStartPixelFromRight { get { return m_fPkgStartPixelFromRight; } set { m_fPkgStartPixelFromRight = value; } }
        public float ref_fPkgStartPixelFromBottom { get { return m_fPkgStartPixelFromBottom; } set { m_fPkgStartPixelFromBottom = value; } }
        public float ref_fPkgStartPixelFromLeft { get { return m_fPkgStartPixelFromLeft; } set { m_fPkgStartPixelFromLeft = value; } }
        public int ref_intPkgImage1HighPadThreshold { get { return m_intPkgImage1HighPadThreshold; } set { m_intPkgImage1HighPadThreshold = value; } }
        public int ref_intPkgImage1LowPadThreshold { get { return m_intPkgImage1LowPadThreshold; } set { m_intPkgImage1LowPadThreshold = value; } }
        public int ref_intPkgImage1HighSurfaceThreshold { get { return m_intPkgImage1HighSurfaceThreshold; } set { m_intPkgImage1HighSurfaceThreshold = value; } }
        public int ref_intPkgImage1LowSurfaceThreshold { get { return m_intPkgImage1LowSurfaceThreshold; } set { m_intPkgImage1LowSurfaceThreshold = value; } }
        public int ref_intPkgImage2HighCrackThreshold { get { return m_intPkgImage2HighCrackThreshold; } set { m_intPkgImage2HighCrackThreshold = value; } }
        public int ref_intPkgImage2LowCrackThreshold { get { return m_intPkgImage2LowCrackThreshold; } set { m_intPkgImage2LowCrackThreshold = value; } }
        public float ref_fPkgImage1Gain { get { return m_fPkgImage1Gain; } set { m_fPkgImage1Gain = value; } }
        public int ref_intPkgImage2HighThreshold { get { return m_intPkgImage2HighThreshold; } set { m_intPkgImage2HighThreshold = value; } }
        public int ref_intPkgImage2LowThreshold { get { return m_intPkgImage2LowThreshold; } set { m_intPkgImage2LowThreshold = value; } }
        public int ref_intPkgImage3HighThreshold { get { return m_intPkgImage3HighThreshold; } set { m_intPkgImage3HighThreshold = value; } }
        public int ref_intPkgImage3LowThreshold { get { return m_intPkgImage3LowThreshold; } set { m_intPkgImage3LowThreshold = value; } }
        public int ref_intPkgImage1MoldFlashThreshold { get { return m_intPkgImage1MoldFlashThreshold; } set { m_intPkgImage1MoldFlashThreshold = value; } }
        public int ref_intPkgImage2VoidThreshold { get { return m_intPkgImage2VoidThreshold; } set { m_intPkgImage2VoidThreshold = value; } }
        public int ref_intPkgImage1ChippedThreshold { get { return m_intPkgImage1ChippedThreshold; } set { m_intPkgImage1ChippedThreshold = value; } }
        public int ref_intBrightFieldLowThreshold { set { m_intBrightFieldLowThreshold = value; } get { return m_intBrightFieldLowThreshold; } }
        public int ref_intBrightFieldHighThreshold { set { m_intBrightFieldHighThreshold = value; } get { return m_intBrightFieldHighThreshold; } }
        public int ref_intDarkFieldLowThreshold { set { m_intDarkFieldLowThreshold = value; } get { return m_intDarkFieldLowThreshold; } }
        public float ref_fDarkFieldImageGain { set { m_fDarkFieldImageGain = value; } get { return m_fDarkFieldImageGain; } }
        public int ref_intDarkFieldHighThreshold { set { m_intDarkFieldHighThreshold = value; } get { return m_intDarkFieldHighThreshold; } }


        public float ref_fUnitWidth { get { return m_fUnitWidth; } set { m_fUnitWidth = value; } }
        public float ref_fUnitHeight { get { return m_fUnitHeight; } set { m_fUnitHeight = value; } }
        public float ref_fUnitThickness { get { return m_fUnitThickness; } set { m_fUnitThickness = value; } }
        public float ref_fUnitWidthMin { get { return m_fUnitWidthMin; } set { m_fUnitWidthMin = value; } }
        public float ref_fUnitWidthMax { get { return m_fUnitWidthMax; } set { m_fUnitWidthMax = value; } }
        public float ref_fUnitHeightMin { get { return m_fUnitHeightMin; } set { m_fUnitHeightMin = value; } }
        public float ref_fUnitHeightMax { get { return m_fUnitHeightMax; } set { m_fUnitHeightMax = value; } }
        public float ref_fUnitThicknessMin { get { return m_fUnitThicknessMin; } set { m_fUnitThicknessMin = value; } }
        public float ref_fUnitThicknessMax { get { return m_fUnitThicknessMax; } set { m_fUnitThicknessMax = value; } }
        public float ref_fUnitSizeLength { get { return m_fUnitSizeLength; } set { m_fUnitSizeLength = value; } }   // no use
        public float ref_fScratchArea { get { return m_fScratchArea; } set { m_fScratchArea = value; } }
        public float ref_fScratchLength { get { return m_fScratchLength; } set { m_fScratchLength = value; } }
        public float ref_fChipArea { get { return m_fChipArea; } set { m_fChipArea = value; } }
        public float ref_fContaminationLength { get { return m_fContaminationLength; } set { m_fContaminationLength = value; } }
        public float ref_fSolderMeltLength { get { return m_fSolderMeltLength; } set { m_fSolderMeltLength = value; } }
        public float ref_fVoidLength { get { return m_fVoidLength; } set { m_fVoidLength = value; } }
        public float ref_fVoidArea { get { return m_fVoidArea; } set { m_fVoidArea = value; } }
        public float ref_fCrackLength { get { return m_fCrackLength; } set { m_fCrackLength = value; } }
        public float ref_fCrackArea { get { return m_fCrackArea; } set { m_fCrackArea = value; } }
        public float ref_fMoldFlashLength { get { return m_fMoldFlashArea; } set { m_fMoldFlashArea = value; } }
        public float ref_fInCompletePlateLength { get { return m_fInCompletePlateLength; } set { m_fInCompletePlateLength = value; } }
        public float ref_fLeadBrokenLength { get { return m_fLeadBrokenLength; } set { m_fLeadBrokenLength = value; } }
        public float ref_fLeadBrokenArea { get { return m_fLeadBrokenArea; } set { m_fLeadBrokenArea = value; } }
        public int ref_intMPTolerance { get { return m_intMPTolerance; } set { m_intMPTolerance = value; } }

        public float ref_fFilterMinArea { get { return m_fFilterMinArea; } set { m_fFilterMinArea = value; } }
        public float ref_fBlobsMinArea { get { return m_fBlobsMinArea; } set { m_fBlobsMinArea = value; } }
        public float ref_fImageMerge2BlobsMinArea { get { return m_fImageMerge2BlobsMinArea; } set { m_fImageMerge2BlobsMinArea = value; } }
        public float ref_fSurfaceMinArea { get { return m_fSurfaceMinArea; } set { m_fSurfaceMinArea = value; } }
        public float ref_fImage2SurfaceMinArea { get { return m_fImage2SurfaceMinArea; } set { m_fImage2SurfaceMinArea = value; } }
        public float ref_fMoldFlashMinArea { get { return m_fMoldFlashMinArea; } set { m_fMoldFlashMinArea = value; } }
        public float ref_fVoidMinArea { get { return m_fVoidMinArea; } set { m_fVoidMinArea = value; } }
        public float ref_fCrackMinArea { get { return m_fCrackMinArea; } set { m_fCrackMinArea = value; } }
        public int ref_intBrightFieldMinArea { set { m_intBrightFieldMinArea = value; } get { return m_intBrightFieldMinArea; } }
        public int ref_intDarkFieldMinArea { set { m_intDarkFieldMinArea = value; } get { return m_intDarkFieldMinArea; } }
        #endregion

        #region Properties
        public int[] ref_arrFailResultMask { get { return m_arrFailResultMask; } set { m_arrFailResultMask = value; } }
        public float ref_f2DCenterPixelCountX1 { get { return m_f2DCenterPixelCountX1; } set { m_f2DCenterPixelCountX1 = value; } }
        public float ref_f2DCenterPixelCountX2 { get { return m_f2DCenterPixelCountX2; } set { m_f2DCenterPixelCountX2 = value; } }
        public float ref_f2DCenterPixelCountX3 { get { return m_f2DCenterPixelCountX3; } set { m_f2DCenterPixelCountX3 = value; } }
        public float ref_f2DCenterPixelCountX4 { get { return m_f2DCenterPixelCountX4; } set { m_f2DCenterPixelCountX4 = value; } }
        public float ref_f2DCenterPixelCountX5 { get { return m_f2DCenterPixelCountX5; } set { m_f2DCenterPixelCountX5 = value; } }
        public float ref_f2DCenterPixelCountY1 { get { return m_f2DCenterPixelCountY1; } set { m_f2DCenterPixelCountY1 = value; } }
        public float ref_f2DCenterPixelCountY2 { get { return m_f2DCenterPixelCountY2; } set { m_f2DCenterPixelCountY2 = value; } }
        public float ref_f2DCenterPixelCountY3 { get { return m_f2DCenterPixelCountY3; } set { m_f2DCenterPixelCountY3 = value; } }
        public float ref_f2DCenterPixelCountY4 { get { return m_f2DCenterPixelCountY4; } set { m_f2DCenterPixelCountY4 = value; } }
        public float ref_f2DCenterPixelCountY5 { get { return m_f2DCenterPixelCountY5; } set { m_f2DCenterPixelCountY5 = value; } }
        public float ref_f3DPixelCount1 { get { return m_f3DPixelCount1; } set { m_f3DPixelCount1 = value; } }
        public float ref_f3DPixelCount2 { get { return m_f3DPixelCount2; } set { m_f3DPixelCount2 = value; } }
        public float ref_f2DCenterMMX1 { get { return m_f2DCenterMMX1; } set { m_f2DCenterMMX1 = value; } }
        public float ref_f2DCenterMMX2 { get { return m_f2DCenterMMX2; } set { m_f2DCenterMMX2 = value; } }
        public float ref_f2DCenterMMX3 { get { return m_f2DCenterMMX3; } set { m_f2DCenterMMX3 = value; } }
        public float ref_f2DCenterMMX4 { get { return m_f2DCenterMMX4; } set { m_f2DCenterMMX4 = value; } }
        public float ref_f2DCenterMMX5 { get { return m_f2DCenterMMX5; } set { m_f2DCenterMMX5 = value; } }
        public float ref_f2DCenterMMY1 { get { return m_f2DCenterMMY1; } set { m_f2DCenterMMY1 = value; } }
        public float ref_f2DCenterMMY2 { get { return m_f2DCenterMMY2; } set { m_f2DCenterMMY2 = value; } }
        public float ref_f2DCenterMMY3 { get { return m_f2DCenterMMY3; } set { m_f2DCenterMMY3 = value; } }
        public float ref_f2DCenterMMY4 { get { return m_f2DCenterMMY4; } set { m_f2DCenterMMY4 = value; } }
        public float ref_f2DCenterMMY5 { get { return m_f2DCenterMMY5; } set { m_f2DCenterMMY5 = value; } }
        public float ref_f3DMM1 { get { return m_f3DMM1; } set { m_f3DMM1 = value; } }
        public float ref_f3DMM2 { get { return m_f3DMM2; } set { m_f3DMM2 = value; } }
        public float ref_f3DAngle { get { return m_f3DAngle; } set { m_f3DAngle = value; } }
        public int ref_intGaugeSizeImageIndex { get { return m_intGaugeSizeImageIndex; } set { m_intGaugeSizeImageIndex = value; } }
        public int ref_intCheckLeadDimensionImageIndex { get { return m_intCheckLeadDimensionImageIndex; } set { m_intCheckLeadDimensionImageIndex = value; } }
        public bool ref_blnMeasureCenterPkgSizeUsingCorner { get { return m_blnMeasureCenterPkgSizeUsingCorner; } set { m_blnMeasureCenterPkgSizeUsingCorner = value; } }
        public bool ref_blnWantUsePkgToBaseTolerance { get { return m_blnWantUsePkgToBaseTolerance; } set { m_blnWantUsePkgToBaseTolerance = value; } }
        public bool ref_blnWantUseGaugeMeasureBase { get { return m_blnWantUseGaugeMeasureBase; } set { m_blnWantUseGaugeMeasureBase = value; } }
        public int ref_intImageRotateOption { get { return m_intImageRotateOption; } set { m_intImageRotateOption = value; } }
        public bool ref_blnWantUseAGVMasking { get { return m_blnWantUseAGVMasking; } set { m_blnWantUseAGVMasking = value; } }
        public bool ref_blnWantUseAverageGrayValueMethod { get { return m_blnWantUseAverageGrayValueMethod; } set { m_blnWantUseAverageGrayValueMethod = value; } }
        public int ref_intLeadWidthDisplayOption { get { return m_intLeadWidthDisplayOption; } set { m_intLeadWidthDisplayOption = value; } }
        public int ref_intLeadLengthVarianceMethod { get { return m_intLeadLengthVarianceMethod; } set { m_intLeadLengthVarianceMethod = value; } }
        public int ref_intLeadSpanMethod { get { return m_intLeadSpanMethod; } set { m_intLeadSpanMethod = value; } }
        public int ref_intLeadContaminationRegion { get { return m_intLeadContaminationRegion; } set { m_intLeadContaminationRegion = value; } }
        public int ref_intLeadStandOffMethod { get { return m_intLeadStandOffMethod; } set { m_intLeadStandOffMethod = value; } }
        public int ref_intLeadWidthRangeSelection { get { return m_intLeadWidthRangeSelection; } set { m_intLeadWidthRangeSelection = value; } }
        public int ref_intLeadWidthRange { get { return m_intLeadWidthRange; } set { m_intLeadWidthRange = value; } }
        public int ref_intMatchingXTolerance { get { return m_intMatchingXTolerance; } set { m_intMatchingXTolerance = value; } }
        public int ref_intMatchingYTolerance { get { return m_intMatchingYTolerance; } set { m_intMatchingYTolerance = value; } }
        public bool ref_blnWantDontCareArea_Lead3D { get { return m_blnWantDontCareArea_Lead3D; } set { m_blnWantDontCareArea_Lead3D = value; } }
        public float ref_fAngleTolerance { get { return m_fAngleTolerance; } set { m_fAngleTolerance = value; } }
        public float ref_fXTolerance { get { return m_fXTolerance; } set { m_fXTolerance = value; } }
        public float ref_fYTolerance { get { return m_fYTolerance; } set { m_fYTolerance = value; } }
        public float ref_fXTolerance_Pixel { get { return Get2DXinPixel(m_fXTolerance); } }
        public float ref_fYTolerance_Pixel { get { return Get2DYinPixel(m_fYTolerance); } }
        public int ref_intExtraBlobID { get { return m_intExtraBlobID; } set { m_intExtraBlobID = value; } }
        public float ref_fTotalExtraLeadSetArea { get { return m_fTotalExtraLeadSetArea; } set { m_fTotalExtraLeadSetArea = value; } }
        public float ref_fBaseLineMaxAngle { get { return m_fBaseLineMaxAngle; } set { m_fBaseLineMaxAngle = value; } }
        public float ref_fExtraLeadSetArea { get { return m_fExtraLeadSetArea; } set { m_fExtraLeadSetArea = value; } }
        public float ref_fExtraLeadSetLength { get { return m_fExtraLeadSetLength; } set { m_fExtraLeadSetLength = value; } }
        public bool ref_blnWantCheckExtraLeadLength { get { return m_blnWantCheckExtraLeadLength; } set { m_blnWantCheckExtraLeadLength = value; } }
        public bool ref_blnWantCheckExtraLeadArea { get { return m_blnWantCheckExtraLeadArea; } set { m_blnWantCheckExtraLeadArea = value; } }
        public int[] ref_arrCornerSearchingLength { get { return m_arrCornerSearchingLength; } set { m_arrCornerSearchingLength = value; } }
        public int ref_intPkgToBaseTolerance_Top { get { return m_intPkgToBaseTolerance_Top; } set { m_intPkgToBaseTolerance_Top = value; } }
        public int ref_intPkgToBaseTolerance_Right { get { return m_intPkgToBaseTolerance_Right; } set { m_intPkgToBaseTolerance_Right = value; } }
        public int ref_intPkgToBaseTolerance_Bottom { get { return m_intPkgToBaseTolerance_Bottom; } set { m_intPkgToBaseTolerance_Bottom = value; } }
        public int ref_intPkgToBaseTolerance_Left { get { return m_intPkgToBaseTolerance_Left; } set { m_intPkgToBaseTolerance_Left = value; } }
        public int ref_intTipBuildAreaTolerance_Top { get { return m_intTipBuildAreaTolerance_Top; } set { m_intTipBuildAreaTolerance_Top = value; } }
        public int ref_intTipBuildAreaTolerance_Right { get { return m_intTipBuildAreaTolerance_Right; } set { m_intTipBuildAreaTolerance_Right = value; } }
        public int ref_intTipBuildAreaTolerance_Bottom { get { return m_intTipBuildAreaTolerance_Bottom; } set { m_intTipBuildAreaTolerance_Bottom = value; } }
        public int ref_intTipBuildAreaTolerance_Left { get { return m_intTipBuildAreaTolerance_Left; } set { m_intTipBuildAreaTolerance_Left = value; } }
        public int[] ref_arrCornerSearchingTolerance_Top { get { return m_arrCornerSearchingTolerance_Top; } set { m_arrCornerSearchingTolerance_Top = value; } }
        public int[] ref_arrCornerSearchingTolerance_Right { get { return m_arrCornerSearchingTolerance_Right; } set { m_arrCornerSearchingTolerance_Right = value; } }
        public int[] ref_arrCornerSearchingTolerance_Bottom { get { return m_arrCornerSearchingTolerance_Bottom; } set { m_arrCornerSearchingTolerance_Bottom = value; } }
        public int[] ref_arrCornerSearchingTolerance_Left { get { return m_arrCornerSearchingTolerance_Left; } set { m_arrCornerSearchingTolerance_Left = value; } }
        public bool ref_blnFindLeadCenterPointsDone { get { return m_blnFindLeadCenterPointsDone; } set { m_blnFindLeadCenterPointsDone = value; } }
        public bool ref_blnSelected { get { return m_blnSelected; } set { m_blnSelected = value; } }
        //public int ref_intCheckLeadDimensionImageIndex { get { return m_intCheckLeadDimensionImageIndex; } set { m_intCheckLeadDimensionImageIndex = value; } }
        public float ref_fImageGain { get { return m_fImageGain; } set { m_fImageGain = value; } }
        public int ref_intFilterMinArea { get { return m_intFilterMinArea; } set { m_intFilterMinArea = value; } }
        public bool ref_blnWhiteOnBlack { get { return m_blnWhiteOnBlack; } set { m_blnWhiteOnBlack = value; } }
        public int ref_intThresholdValue { get { return m_intThresholdValue; } set { m_intThresholdValue = value; } }
        public bool ref_blnWantUseClosestSizeDefineTolerance { get { return m_blnWantUseClosestSizeDefineTolerance; } set { m_blnWantUseClosestSizeDefineTolerance = value; } }
        public int ref_intNumberOfLead { get { return m_intNumberOfLead; } set { m_intNumberOfLead = value; } }

        public int ref_intNumberOfLead_Top { get { return m_intNumberOfLead_Top; } set { m_intNumberOfLead_Top = value; } }

        public int ref_intNumberOfLead_Bottom { get { return m_intNumberOfLead_Bottom; } set { m_intNumberOfLead_Bottom = value; } }

        public int ref_intNumberOfLead_Left { get { return m_intNumberOfLead_Left; } set { m_intNumberOfLead_Left = value; } }

        public int ref_intNumberOfLead_Right { get { return m_intNumberOfLead_Right; } set { m_intNumberOfLead_Right = value; } }

        public int ref_intLeadDirection { get { return m_intLeadDirection; } set { m_intLeadDirection = value; } }

        public float ref_fDefaultPixelTolerance { get { return m_fDefaultPixelTolerance; } set { m_fDefaultPixelTolerance = value; } }
        public bool ref_blnViewLeadResultDrawing { get { return m_blnViewLeadResultDrawing; } set { m_blnViewLeadResultDrawing = value; } }
        public bool ref_blnLock { get { return m_blnLock; } set { m_blnLock = value; } }
        public int ref_intSensitivityOnLeadValue { get { return m_intSensitivityOnLeadValue; } set { m_intSensitivityOnLeadValue = value; } }
        public string ref_strErrorMessage { get { return m_strErrorMessage; } set { m_strErrorMessage = value; } }
        public bool ref_blnWantTightSetting { get { return m_blnWantTightSetting; } set { m_blnWantTightSetting = value; } }
        public float ref_fTightSettingTolerance { get { return m_fTightSettingTolerance; } set { m_fTightSettingTolerance = value; } }
        public int ref_intBaseOffset { get { return m_intBaseOffset; } set { m_intBaseOffset = value; } }
        public int ref_intTipOffset { get { return m_intTipOffset; } set { m_intTipOffset = value; } }
        public int ref_intTipOffsetSide { get { return m_intTipOffsetSide; } set { m_intTipOffsetSide = value; } }
        public bool ref_blnClockWise { get { return m_blnClockWise; } set { m_blnClockWise = value; } }
        public int ref_intFirstLead { get { return m_intFirstLead; } set { m_intFirstLead = value; } }
        public float ref_fTemplateLeadMinSpanLimit { get { return m_fTemplateLeadMinSpanLimit; } set { m_fTemplateLeadMinSpanLimit = value; } }
        public float ref_fTemplateLeadMaxSpanLimit { get { return m_fTemplateLeadMaxSpanLimit; } set { m_fTemplateLeadMaxSpanLimit = value; } }
        public float ref_fLeadMinSpanResult { get { return m_fLeadMinSpanResult; } set { m_fLeadMinSpanResult = value; } }
        public float ref_fLeadMaxSpanResult { get { return m_fLeadMaxSpanResult; } set { m_fLeadMaxSpanResult = value; } }
        public int ref_intFailOptionMask { get { return m_intFailOptionMask; } set { m_intFailOptionMask = value; } }
        public int ref_intBaseLineTrimFromEdge { get { return m_intBaseLineTrimFromEdge; } set { m_intBaseLineTrimFromEdge = value; } }
        public int ref_intBaseLineSteps { get { return m_intBaseLineSteps; } set { m_intBaseLineSteps = value; } }
        public float ref_fBaseLineAngle { get { return m_fBaseLineAngle; } }
        public float ref_fCenterUnitAngle { get { return m_fCenterUnitAngle; } }
        public float ref_fCenterUnitWidth { get { return m_fCenterUnitWidth; } }
        public float ref_fCenterUnitHeight { get { return m_fCenterUnitHeight; } }
        public float ref_fCenterUnitWidthMM { get { return Get2DXinMM(m_fCenterUnitWidth) * m_fMMToUnitValue; } } //m_fCenterUnitWidth * m_fMMPerPixelX * m_fMMToUnitValue; 
        public float ref_fCenterUnitHeightMM { get { return Get2DYinMM(m_fCenterUnitHeight) * m_fMMToUnitValue; } } //m_fCenterUnitHeight * m_fMMPerPixelY * m_fMMToUnitValue;

        public PointF ref_pCornerPoint_Left { get { return m_pCornerPoint_Left; } }
        public PointF ref_pCornerPoint_Right { get { return m_pCornerPoint_Right; } }
        public PointF ref_pCornerPoint_Top { get { return m_pCornerPoint_Top; } }
        public PointF ref_pCornerPoint_Bottom { get { return m_pCornerPoint_Bottom; } }
        public PointF ref_pCornerPoint_Center { get { return m_pCornerPoint_Center; } set { m_pCornerPoint_Center = value; } }
        public float ref_fTemplateCornerPoint_CenterX { get { return m_fTemplateCornerPoint_CenterX; } set { m_fTemplateCornerPoint_CenterX = value; } }
        public float ref_fTemplateCornerPoint_CenterY { get { return m_fTemplateCornerPoint_CenterY; } set { m_fTemplateCornerPoint_CenterY = value; } }
        // ------------- Whole Leads Result ------------------------------
        public float ref_fPitchVarianceLeftResult { get { return m_fPitchVarianceLeftResult; } set { m_fPitchVarianceLeftResult = value; } }
        public float ref_fPitchVarianceRightResult { get { return m_fPitchVarianceRightResult; } set { m_fPitchVarianceRightResult = value; } }
        public float ref_fPitchVarianceTopResult { get { return m_fPitchVarianceTopResult; } set { m_fPitchVarianceTopResult = value; } }
        public float ref_fPitchVarianceBottomResult { get { return m_fPitchVarianceBottomResult; } set { m_fPitchVarianceBottomResult = value; } }
        public float ref_fLengthVarianceOverallResult { get { return m_fLengthVarianceOverallResult; } set { m_fLengthVarianceOverallResult = value; } }
        public float ref_fLengthVarianceLeftResult { get { return m_fLengthVarianceLeftResult; } set { m_fLengthVarianceLeftResult = value; } }
        public float ref_fLengthVarianceRightResult { get { return m_fLengthVarianceRightResult; } set { m_fLengthVarianceRightResult = value; } }
        public float ref_fLengthVarianceTopResult { get { return m_fLengthVarianceTopResult; } set { m_fLengthVarianceTopResult = value; } }
        public float ref_fLengthVarianceBottomResult { get { return m_fLengthVarianceBottomResult; } set { m_fLengthVarianceBottomResult = value; } }
        public float ref_fStandOffVarianceLeftResult { get { return m_fStandOffVarianceLeftResult; } set { m_fStandOffVarianceLeftResult = value; } }
        public float ref_fStandOffVarianceRightResult { get { return m_fStandOffVarianceRightResult; } set { m_fStandOffVarianceRightResult = value; } }
        public float ref_fStandOffVarianceTopResult { get { return m_fStandOffVarianceTopResult; } set { m_fStandOffVarianceTopResult = value; } }
        public float ref_fStandOffVarianceBottomResult { get { return m_fStandOffVarianceBottomResult; } set { m_fStandOffVarianceBottomResult = value; } }
        public float ref_fStandOffVarianceUnitResult { get { return m_fStandOffVarianceUnitResult; } set { m_fStandOffVarianceUnitResult = value; } }
        public float ref_fLeadSweepVarianceLeftResult { get { return m_fLeadSweepVarianceLeftResult; } set { m_fLeadSweepVarianceLeftResult = value; } }
        public float ref_fLeadSweepVarianceRightResult { get { return m_fLeadSweepVarianceRightResult; } set { m_fLeadSweepVarianceRightResult = value; } }
        public float ref_fLeadSweepVarianceTopResult { get { return m_fLeadSweepVarianceTopResult; } set { m_fLeadSweepVarianceTopResult = value; } }
        public float ref_fLeadSweepVarianceBottomResult { get { return m_fLeadSweepVarianceBottomResult; } set { m_fLeadSweepVarianceBottomResult = value; } }
        public float ref_fSpanOverallResult { get { return m_fSpanOverallResult; } set { m_fSpanOverallResult = value; } }
        public float ref_fSpanTopResult { get { return m_fSpanTopResult; } set { m_fSpanTopResult = value; } }
        public float ref_fSpanBottomResult { get { return m_fSpanBottomResult; } set { m_fSpanBottomResult = value; } }
        public float ref_fSpanLeftResult { get { return m_fSpanLeftResult; } set { m_fSpanLeftResult = value; } }
        public float ref_fSpanRightResult { get { return m_fSpanRightResult; } set { m_fSpanRightResult = value; } }

        // ------------- Whole Leads Setting -----------------------------
        public float ref_fPitchVarianceLeftMaxSetting { get { return m_fPitchVarianceLeftMaxSetting; } set { m_fPitchVarianceLeftMaxSetting = value; } }
        public float ref_fPitchVarianceRightMaxSetting { get { return m_fPitchVarianceRightMaxSetting; } set { m_fPitchVarianceRightMaxSetting = value; } }
        public float ref_fPitchVarianceTopMaxSetting { get { return m_fPitchVarianceTopMaxSetting; } set { m_fPitchVarianceTopMaxSetting = value; } }
        public float ref_fPitchVarianceBottomMaxSetting { get { return m_fPitchVarianceBottomMaxSetting; } set { m_fPitchVarianceBottomMaxSetting = value; } }
        public float ref_fStandOffVarianceLeftMaxSetting { get { return m_fStandOffVarianceLeftMaxSetting; } set { m_fStandOffVarianceLeftMaxSetting = value; } }
        public float ref_fStandOffVarianceRightMaxSetting { get { return m_fStandOffVarianceRightMaxSetting; } set { m_fStandOffVarianceRightMaxSetting = value; } }
        public float ref_fStandOffVarianceTopMaxSetting { get { return m_fStandOffVarianceTopMaxSetting; } set { m_fStandOffVarianceTopMaxSetting = value; } }
        public float ref_fStandOffVarianceBottomMaxSetting { get { return m_fStandOffVarianceBottomMaxSetting; } set { m_fStandOffVarianceBottomMaxSetting = value; } }
        public float ref_fStandOffVarianceUnitMaxSetting { get { return m_fStandOffVarianceUnitMaxSetting; } set { m_fStandOffVarianceUnitMaxSetting = value; } }
        public float ref_fLeadSweepVarianceLeftMinSetting { get { return m_fLeadSweepVarianceLeftMinSetting; } set { m_fLeadSweepVarianceLeftMinSetting = value; } }
        public float ref_fLeadSweepVarianceRightMinSetting { get { return m_fLeadSweepVarianceRightMinSetting; } set { m_fLeadSweepVarianceRightMinSetting = value; } }
        public float ref_fLeadSweepVarianceTopMinSetting { get { return m_fLeadSweepVarianceTopMinSetting; } set { m_fLeadSweepVarianceTopMinSetting = value; } }
        public float ref_fLeadSweepVarianceBottomMinSetting { get { return m_fLeadSweepVarianceBottomMinSetting; } set { m_fLeadSweepVarianceBottomMinSetting = value; } }
        public float ref_fLeadSweepVarianceLeftMaxSetting { get { return m_fLeadSweepVarianceLeftMaxSetting; } set { m_fLeadSweepVarianceLeftMaxSetting = value; } }
        public float ref_fLeadSweepVarianceRightMaxSetting { get { return m_fLeadSweepVarianceRightMaxSetting; } set { m_fLeadSweepVarianceRightMaxSetting = value; } }
        public float ref_fLeadSweepVarianceTopMaxSetting { get { return m_fLeadSweepVarianceTopMaxSetting; } set { m_fLeadSweepVarianceTopMaxSetting = value; } }
        public float ref_fLeadSweepVarianceBottomMaxSetting { get { return m_fLeadSweepVarianceBottomMaxSetting; } set { m_fLeadSweepVarianceBottomMaxSetting = value; } }
        public float ref_fSpanOverallMinSetting { get { return m_fSpanOverallMinSetting; } set { m_fSpanOverallMinSetting = value; } }
        public float ref_fSpanOverallMaxSetting { get { return m_fSpanOverallMaxSetting; } set { m_fSpanOverallMaxSetting = value; } }
        public float ref_fSpanTopMinSetting { get { return m_fSpanTopMinSetting; } set { m_fSpanTopMinSetting = value; } }
        public float ref_fSpanTopMaxSetting { get { return m_fSpanTopMaxSetting; } set { m_fSpanTopMaxSetting = value; } }
        public float ref_fSpanBottomMinSetting { get { return m_fSpanBottomMinSetting; } set { m_fSpanBottomMinSetting = value; } }
        public float ref_fSpanBottomMaxSetting { get { return m_fSpanBottomMaxSetting; } set { m_fSpanBottomMaxSetting = value; } }
        public float ref_fSpanLeftMinSetting { get { return m_fSpanLeftMinSetting; } set { m_fSpanLeftMinSetting = value; } }
        public float ref_fSpanLeftMaxSetting { get { return m_fSpanLeftMaxSetting; } set { m_fSpanLeftMaxSetting = value; } }
        public float ref_fSpanRightMinSetting { get { return m_fSpanRightMinSetting; } set { m_fSpanRightMinSetting = value; } }
        public float ref_fSpanRightMaxSetting { get { return m_fSpanRightMaxSetting; } set { m_fSpanRightMaxSetting = value; } }
        public float ref_fLengthVarianceOverallMaxSetting { get { return m_fLengthVarianceOverallMaxSetting; } set { m_fLengthVarianceOverallMaxSetting = value; } }
        public float ref_fLengthVarianceLeftMaxSetting { get { return m_fLengthVarianceLeftMaxSetting; } set { m_fLengthVarianceLeftMaxSetting = value; } }
        public float ref_fLengthVarianceRightMaxSetting { get { return m_fLengthVarianceRightMaxSetting; } set { m_fLengthVarianceRightMaxSetting = value; } }
        public float ref_fLengthVarianceTopMaxSetting { get { return m_fLengthVarianceTopMaxSetting; } set { m_fLengthVarianceTopMaxSetting = value; } }
        public float ref_fLengthVarianceBottomMaxSetting { get { return m_fLengthVarianceBottomMaxSetting; } set { m_fLengthVarianceBottomMaxSetting = value; } }
        public PGauge ref_objPointGauge { get { return m_objPointGauge; } set { m_objPointGauge = value; } }
        public List<List<PGauge>> ref_arrCenterPointGauge { get { return m_arrCenterPointGauge; } set { m_arrCenterPointGauge = value; } }
        public List<List<PGauge>> ref_arrSidePointGauge { get { return m_arrSidePointGauge; } set { m_arrSidePointGauge = value; } }
        public List<PGauge> ref_arrCornerPointGauge { get { return m_arrCornerPointGauge; } set { m_arrCornerPointGauge = value; } }
        public PGauge ref_objSettingPointGauge { get { return m_objSettingPointGauge; } set { m_objSettingPointGauge = value; } }
        public bool ref_blnDrawSidePointGauge { get { return m_blnDrawSidePointGauge; } set { m_blnDrawSidePointGauge = value; } }

        public int ref_intSelectedCenterDirectionIndex { get { return m_intSelectedCenterDirectionIndex; } set { m_intSelectedCenterDirectionIndex = value; } }
        public int ref_intSelectedSideDirectionIndex { get { return m_intSelectedSideDirectionIndex; } set { m_intSelectedSideDirectionIndex = value; } }
        public int ref_intSelectedCornerDirectionIndex { get { return m_intSelectedCornerDirectionIndex; } set { m_intSelectedCornerDirectionIndex = value; } }
        public int ref_intSelectedLeadNo { get { return m_intSelectedLeadNo; } set { m_intSelectedLeadNo = value; } }
        #endregion

        #region Struct 

        struct BlobsFeatures
        {
            // Object Data
            public int intNoID;
            public int intObjNo;
            public int intDirection;       //1 = left column, 2 = right column, 4 = high row, 8 = low row
            public int intSide;             //1 = top side, 2 = right side, 4 = bottom side, 8 = left side
            public int intGroupID;
            public int intLengthMode;  // 1: Length = Height, 2: Length = Width
            public int[] arrContourX;
            public int[] arrContourY;
            public int intContourX;
            public int intContourY;
            public float fArea;
            public int intStartX;
            public int intStartY;
            public int intEndX;
            public int intEndY;
            public float fStartX;
            public float fStartY;
            public float fEndX;
            public float fEndY;
            public float fCenterX;
            public float fCenterY;
            public float fLimitCenterX;
            public float fLimitCenterY;
            public float fWidth;
            public float fHeight;
            public float fBaseWidth;
            public float fBaseLength;
            public float fBaseCenterX;
            public float fBaseCenterY;
            public float fTipWidth;
            public float fTipLength;
            public float fTipCenterX;
            public float fTipCenterY;
            public float fLeadMinWidth;
            public float fLeadMaxWidth;
            public bool blnSelected;
            public float fSweepLeftReference;
            public float fSweepRightReference;
            public float fSweepTopReference;
            public float fSweepBottomReference;

            public bool blnCheckSkew;

            public bool blnTipCenterFound;
            public bool blnTipStartFound;
            public bool blnTipEndFound;
            public bool blnBaseCenterFound;
            public bool blnBaseStartFound;
            public bool blnBaseEndFound;

            public bool ref_blnSelected { get { return blnSelected; } set { blnSelected = value; } }

            // Object Relation Data
            public float fLeftDistance;
            public float fRightDistance;
            public float fTopDistance;
            public float fBottomDistance;
            public float fXDistance;
            public float fYDistance;
            public float fPitch;
            public float fGap;

            // Inspection Data
            public float fOffSet;
            public float fSkew;

            public float fMinBaseWidth;
            public float fMaxBaseWidth;
            public float fMinBaseLength;
            public float fMaxBaseLength;

            public float fMinTipWidth;
            public float fMaxTipWidth;
            public float fMinTipLength;
            public float fMaxTipLength;

            public float fMinPitch;
            public float fMaxPitch;

            public float fMinGap;
            public float fMaxGap;

            public float fMinSolderPadLength;
            public float fMaxSolderPadLength;

            public float fMinStandOff;
            public float fMaxStandOff;

            public float fMaxCoplan;

            public float fMinAGV;
            public float fMaxAGV;

            public float fLeadLimitMinWidth;
            public float fLeadLimitMaxWidth;
            public float fLeadMaxBurrWidth;

            public float fWidthOffset;
            public float fLengthOffset;
            public float fPitchOffset;
            public float fGapOffset;
            public float fStandOffOffset;
            public float fCoplanOffset;

            public int[] arrSelectedBlob;
            public int intSelectedBlob;

            // Average Gray Value ROI Tolerance
            public int intAGVROITolerance_Top;
            public int intAGVROITolerance_Right;
            public int intAGVROITolerance_Bottom;
            public int intAGVROITolerance_Left;
        }
        struct SampleBlobsFeatures
        {
            public int intDirection;
            public int intNoID;
            // Result
            public float fOffSetMM;
            public float fSkewMM;
            public float fAreaMM;
            public float fWidthMM;
            public float fHeightMM;
            public float fBaseWidthMM;
            public float fBaseLengthMM;
            public float fTipWidthMM;
            public float fTipLengthMM;
            public float fPitchMM;
            public float fGapMM;
            public float fStandOffMM;
            public float fSolderPadLengthMM;
            public float fCoplanMM;
            public float fAGV;
            public float fLeadMinWidthMM;
            public float fLeadMaxWidthMM;
            public float fLeadBurrWidthMM;

            // Object Data in pixel
            public float fOffSet;
            public float fSkew;
            public float fArea;
            public float fWidth;
            public float fHeight;
            public float fPitch;
            public float fGap;

            public int intFailMask;
            public float fStartX;
            public float fStartY;
            public float fEndX;
            public float fEndY;
            public float fCenterX;
            public float fCenterY;
            public float fGravityCenterX;
            public float fGravityCenterY;

            public float fBaseCenterX;
            public float fBaseCenterY;
            public float fBaseWidth;
            public float fBaseLength;
            public float fTipCenterX;
            public float fTipCenterY;
            public float fTipMaxX;
            public float fTipMaxY;
            public float fTipWidth;
            public float fTipLength;
            public float fLeadMinWidth;
            public float fLeadMaxWidth;
            public float fLeadBurrWidth;

            public int intContourIndex; // Keep sample blob index

            public bool blnTipCenterFound;
            public bool blnTipStartFound;
            public bool blnTipEndFound;
            public bool blnBaseCenterFound;
            public bool blnBaseStartFound;
            public bool blnBaseEndFound;
        }
        struct SampleExtraBlobsFeatures
        {
            // Object Data
            public float fStartX;
            public float fStartY;
            public float fEndX;
            public float fEndY;
            public float fCenterX;
            public float fCenterY;
            public float fWidth;
            public float fHeight;

            public float ref_fWidthFailValue;
            public float ref_fHeightFailValue;
            public float ref_fAreaFailValue;

            public int ref_intExtraBlobID;
            public int ref_intFailCriteria; // 0x01:width, 0x02:Height, 0x04:Area
        }
        struct ToleranceBlobsFeatures
        {
            // Inspection Data
            public float fOffSet;
            public float fSkew;

            public float fMinBaseWidth;
            public float fMaxBaseWidth;
            public float fMinBaseLength;
            public float fMaxBaseLength;

            public float fMinTipWidth;
            public float fMaxTipWidth;
            public float fMinTipLength;
            public float fMaxTipLength;

            public float fMinPitch;
            public float fMaxPitch;
            public float fMinGap;
            public float fMaxGap;

            public float fMinSolderPadLength;
            public float fMaxSolderPadLength;

            public float fMinStandOff;
            public float fMaxStandOff;

            public float fMaxCoplan;

            public float fMinAGV;
            public float fMaxAGV;

            public float fLeadLimitMinWidth;
            public float fLeadLimitMaxWidth;
            public float fLeadMaxBurrWidth;

            public float fWidthOffset;
            public float fLengthOffset;
            public float fPitchOffset;
            public float fGapOffset;
            public float fStandOffOffset;
            public float fCoplanOffset;

            public float fStartX;
            public float fStartY;
            public float fEndX;
            public float fEndY;
            public float fLimitCenterX;
            public float fLimitCenterY;
            public int intNoID;
            public int intGroupID;
            public int intDirection;
            public int intLengthMode;  // 1: Length = Height, 2: Length = Width

            public float fLearnArea;
            public float fLearnWidth;
            public float fLearnHeight;

            public bool blnCheckSkew;

            // Average Gray Value ROI Tolerance
            public int intAGVROITolerance_Top;
            public int intAGVROITolerance_Right;
            public int intAGVROITolerance_Bottom;
            public int intAGVROITolerance_Left;
        }
        struct TolerancePitchGap
        {
            public float fMinPitch;
            public float fMaxPitch;
            public float fMinGap;
            public float fMaxGap;
        }
        struct PitchGap
        {
            public int intFromLeadNo;
            public int intToLeadNo;
            public int intDirection;
            public float fPitch;
            public float fGap;
            public float fPitchMM;
            public float fGapMM;
            public float fMinPitch;
            public float fMaxPitch;
            public float fMinGap;
            public float fMaxGap;
            public int intStartPointX;
            public int intStartPointY;
            public int intEndPointX;
            public int intEndPointY;
            public int intFailMask;

        }
        struct GroupSetting
        {
            // Group reference info
            public float fReferenceArea;
            public float fReferenceWidth;
            public float fReferenceHeight;

            // Setting
            public float fOffSet;
            public float fSkew;
            //public float fMinArea;
            //public float fMaxArea;
            public float fMinWidth;
            public float fMaxWidth;
            public float fMinHeight;
            public float fMaxHeight;
            public float fMinPitch;
            public float fMaxPitch;
            public float fMinGap;
            public float fMaxGap;
            //public float fMaxBroken;
            //public float fMaxBrokenLength;
        }

        #endregion

        private bool m_blnInspectLock = false;
        private bool m_blnDrawingLock = false;

        public bool ref_blnInspectLock { get { return m_blnInspectLock; } set { m_blnInspectLock = value; } }
        public bool ref_blnDrawingLock { get { return m_blnDrawingLock; } set { m_blnDrawingLock = value; } }


        public Lead3D()
        {

        }

        public Lead3D(GaugeWorldShape objWorldShape, int intImageWidth, int intImageHeight, int intLeadROIDirection)
        {
            m_objLineGauge = new LGauge(objWorldShape);
            // 2021 08 28 - CCENG: change from largest amplitude to Begin. 
            //                   : This line gauge will use to measure side ROI base 
            //                   : For line gauge with version 2.12, transition choice should be 0 = NthFromBegin, 1 = NthFromEnd, 2 = LargestArea, 3 = LargestAmplitude, 4 = closest , 5 = All
            //m_objLineGauge.SetGaugeAdvancedSetting(10, 0, 1, 1, 4, 1, 3, 125);
            m_objLineGauge.SetGaugeAdvancedSetting(10, 0, 1, 1, 0, 1, 3, 125);  

            m_intLeadROIDirection = intLeadROIDirection;
            m_objPointGauge = new PGauge(objWorldShape);
            //m_objCenterPointGauge = new PGauge(objWorldShape);
            //m_objSidePointGauge = new PGauge(objWorldShape);
            //m_objCornerPointGauge = new PGauge(objWorldShape);
            m_objSettingPointGauge = new PGauge(objWorldShape);

            if (intLeadROIDirection == 0)
                m_objRectGauge4L = new RectGauge4L(objWorldShape, intLeadROIDirection);

            m_objInsSurfacePkgImage1 = new ImageDrawing(true, intImageWidth, intImageHeight);
            m_objInsChipOffPkgImage1 = new ImageDrawing(true, intImageWidth, intImageHeight);
            m_objInsPkgImage2 = new ImageDrawing(true, intImageWidth, intImageHeight);
            m_objInsChipOffPkgImage2 = new ImageDrawing(true, intImageWidth, intImageHeight);
            m_objInsPkgImage3 = new ImageDrawing(true, intImageWidth, intImageHeight);
        }

        /// <summary>
        /// Get blobs features count
        /// </summary>
        /// <returns></returns>
        public int GetBlobsFeaturesNumber()
        {
            return m_arrTemplateBlobLeads.Count;
        }

        public void DefineLeadBaseTipWidth(int intLeadPosition, ROI objROI)
        {
            float fLimitCenterX;
            float fLimitCenterY;
            float fNewCenterX;
            float fNewCenterY;
            float fWidth;
            float fHeight;
            int intFixPointXY;

            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                switch (intLeadPosition)
                {
                    //Top
                    case 1:
                        //Base
                        fLimitCenterX = m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterY + (m_stcBlobLead.fHeight / 2) - m_intBaseOffset, 0, MidpointRounding.AwayFromZero);
                        Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                                ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, true, true, intFixPointXY);

                        m_stcBlobLead.fBaseCenterX = fNewCenterX;
                        m_stcBlobLead.fBaseCenterY = fNewCenterY;
                        m_stcBlobLead.fBaseWidth = fWidth;
                        m_stcBlobLead.fBaseLength = fHeight;

                        //Tip
                        fLimitCenterX = m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterY - (m_stcBlobLead.fHeight / 2) + m_intTipOffset, 0, MidpointRounding.AwayFromZero);
                        Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                                ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, true, false, intFixPointXY);

                        m_stcBlobLead.fTipCenterX = fNewCenterX;
                        m_stcBlobLead.fTipCenterY = fNewCenterY;
                        m_stcBlobLead.fTipWidth = fWidth;
                        m_stcBlobLead.fTipLength = fHeight;
                        break;
                    //Right
                    case 2:
                        //Base
                        fLimitCenterX = m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterX - (m_stcBlobLead.fWidth / 2) + m_intBaseOffset, 0, MidpointRounding.AwayFromZero);
                        Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                                ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, false, false, intFixPointXY);

                        m_stcBlobLead.fBaseCenterX = fNewCenterX;
                        m_stcBlobLead.fBaseCenterY = fNewCenterY;
                        m_stcBlobLead.fBaseWidth = fWidth;
                        m_stcBlobLead.fBaseLength = fHeight;

                        //Tip
                        fLimitCenterX = m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterX + (m_stcBlobLead.fWidth / 2) - m_intTipOffset, 0, MidpointRounding.AwayFromZero);
                        Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                                ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, false, true, intFixPointXY);

                        m_stcBlobLead.fTipCenterX = fNewCenterX;
                        m_stcBlobLead.fTipCenterY = fNewCenterY;
                        m_stcBlobLead.fTipWidth = fWidth;
                        m_stcBlobLead.fTipLength = fHeight;
                        break;
                    //Bottom
                    case 3:
                        //Base
                        fLimitCenterX = m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterY - (m_stcBlobLead.fHeight / 2) + m_intBaseOffset, 0, MidpointRounding.AwayFromZero);
                        Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                                ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, true, false, intFixPointXY);

                        m_stcBlobLead.fBaseCenterX = fNewCenterX;
                        m_stcBlobLead.fBaseCenterY = fNewCenterY;
                        m_stcBlobLead.fBaseWidth = fWidth;
                        m_stcBlobLead.fBaseLength = fHeight;

                        //Tip
                        fLimitCenterX = m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterY + (m_stcBlobLead.fHeight / 2) - m_intTipOffset, 0, MidpointRounding.AwayFromZero);
                        Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                                ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, true, true, intFixPointXY);

                        m_stcBlobLead.fTipCenterX = fNewCenterX;
                        m_stcBlobLead.fTipCenterY = fNewCenterY;
                        m_stcBlobLead.fTipWidth = fWidth;
                        m_stcBlobLead.fTipLength = fHeight;
                        break;
                    //Left
                    case 4:
                        //Base
                        fLimitCenterX = m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterX + (m_stcBlobLead.fWidth / 2) - m_intBaseOffset, 0, MidpointRounding.AwayFromZero);
                        Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                                ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, false, true, intFixPointXY);

                        m_stcBlobLead.fBaseCenterX = fNewCenterX;
                        m_stcBlobLead.fBaseCenterY = fNewCenterY;
                        m_stcBlobLead.fBaseWidth = fWidth;
                        m_stcBlobLead.fBaseLength = fHeight;

                        //Tip
                        fLimitCenterX = m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterX - (m_stcBlobLead.fWidth / 2) + m_intTipOffset, 0, MidpointRounding.AwayFromZero);
                        Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                                ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, false, false, intFixPointXY);

                        m_stcBlobLead.fTipCenterX = fNewCenterX;
                        m_stcBlobLead.fTipCenterY = fNewCenterY;
                        m_stcBlobLead.fTipWidth = fWidth;
                        m_stcBlobLead.fTipLength = fHeight;
                        break;
                }

                m_arrTemplateBlobLeads.RemoveAt(i);
                m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
            }
        }

        public bool GetLeadTipInfoFromCenterLead3D(int intDirection, ref List<PointF> arrLeadTipPoint, ref List<float> arrLeadWidth)
        {
            arrLeadTipPoint.Clear();
            arrLeadWidth.Clear();

            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                if (m_stcBlobLead.intDirection == intDirection)
                {

                }

            }

            return true;
        }

        private void AddCenterPointGaugePlacementToArray(float fCenterX, float fCenterY, float fTolerance, float fAngle, int intLeadIndex)
        {
            //    TipStart = 0
            //    TipCenter = 1
            //    TipEnd = 2
            //    BaseStart = 3
            //    BaseCenter = 4
            //    BaseEnd = 5
            // 2021 05 04 - ZJYEOH : change point index to 
            // BaseCenter = 0
            // BaseStart = 1
            // BaseEnd = 2
            // Tip Center = 3
            // Tip Start = 4
            // Tip End = 5     

            //.Count - 1

            //m_arrLead3DCenterPointGaugeStartX.Add(new List<float>());
            m_arrLead3DCenterPointGaugeStartX[intLeadIndex].Add(fCenterX);//-1
            m_arrLead3DCenterPointGaugeStartX[intLeadIndex].Add(-1);
            m_arrLead3DCenterPointGaugeStartX[intLeadIndex].Add(-1);
            m_arrLead3DCenterPointGaugeStartX[intLeadIndex].Add(-1);
            m_arrLead3DCenterPointGaugeStartX[intLeadIndex].Add(-1);//fCenterX
            m_arrLead3DCenterPointGaugeStartX[intLeadIndex].Add(-1);

            //m_arrLead3DCenterPointGaugeStartY.Add(new List<float>());
            m_arrLead3DCenterPointGaugeStartY[intLeadIndex].Add(fCenterY);//-1
            m_arrLead3DCenterPointGaugeStartY[intLeadIndex].Add(-1);
            m_arrLead3DCenterPointGaugeStartY[intLeadIndex].Add(-1);
            m_arrLead3DCenterPointGaugeStartY[intLeadIndex].Add(-1);
            m_arrLead3DCenterPointGaugeStartY[intLeadIndex].Add(-1);//fCenterY
            m_arrLead3DCenterPointGaugeStartY[intLeadIndex].Add(-1);

            //m_arrLead3DCenterPointGaugeTolerance.Add(new List<float>());
            m_arrLead3DCenterPointGaugeTolerance[intLeadIndex].Add(fTolerance);//-1
            m_arrLead3DCenterPointGaugeTolerance[intLeadIndex].Add(-1);
            m_arrLead3DCenterPointGaugeTolerance[intLeadIndex].Add(-1);
            m_arrLead3DCenterPointGaugeTolerance[intLeadIndex].Add(-1);
            m_arrLead3DCenterPointGaugeTolerance[intLeadIndex].Add(-1);//fTolerance
            m_arrLead3DCenterPointGaugeTolerance[intLeadIndex].Add(-1);

            //m_arrLead3DCenterPointGaugeAngle.Add(new List<float>());
            m_arrLead3DCenterPointGaugeAngle[intLeadIndex].Add(fAngle);//-1
            m_arrLead3DCenterPointGaugeAngle[intLeadIndex].Add(-1);
            m_arrLead3DCenterPointGaugeAngle[intLeadIndex].Add(-1);
            m_arrLead3DCenterPointGaugeAngle[intLeadIndex].Add(-1);
            m_arrLead3DCenterPointGaugeAngle[intLeadIndex].Add(-1);//fAngle
            m_arrLead3DCenterPointGaugeAngle[intLeadIndex].Add(-1);
        }
        private void SetCenterPointGaugePlacementToArray(float fCenterX, float fCenterY, float fTolerance, float fAngle, int intPosition, int intLeadIndex)
        {
            //    TipStart = 0
            //    TipCenter = 1
            //    TipEnd = 2
            //    BaseStart = 3
            //    BaseCenter = 4
            //    BaseEnd = 5
            // 2021 05 04 - ZJYEOH : change point index to 
            // BaseCenter = 0
            // BaseStart = 1
            // BaseEnd = 2
            // Tip Center = 3
            // Tip Start = 4
            // Tip End = 5     

            //.Count - 1
            m_arrLead3DCenterPointGaugeStartX[intLeadIndex][intPosition] = fCenterX;
            m_arrLead3DCenterPointGaugeStartY[intLeadIndex][intPosition] = fCenterY;
            m_arrLead3DCenterPointGaugeTolerance[intLeadIndex][intPosition] = fTolerance;
            m_arrLead3DCenterPointGaugeAngle[intLeadIndex][intPosition] = fAngle;
        }
        public void DefineLeadBaseTipWidth_Lead3D_PkgToBaseTolerance(ROI objROI)
        {
            //if (m_objCenterPointGauge.ref_GaugeTransChoice != 2)
            //    m_objCenterPointGauge.ref_GaugeTransChoice = 2;   // Use Largest Amplitude

            //if (m_objCenterPointGauge.ref_GaugeTransType != 1)
            //    m_objCenterPointGauge.ref_GaugeTransType = 1;     // Black to white

            float fLimitCenterX;
            float fLimitCenterY;
            float fNewCenterX;
            float fNewCenterY;
            float fWidth;
            float fHeight;
            int intFixPointXY;
            int intTipStartAngle, intTipCenterAngle, intTipEndAngle, intBaseStartAngle, intBaseCenterAngle, intBaseEndAngle;

            m_arrLead3DCenterPointGaugeStartX.Clear();
            m_arrLead3DCenterPointGaugeStartY.Clear();
            m_arrLead3DCenterPointGaugeTolerance.Clear();
            m_arrLead3DCenterPointGaugeAngle.Clear();
            m_arrLead3DEdgeCenterGaugePoints.Clear();
            m_arrLead3DEdgeCenterGaugePointsFound.Clear();
            m_arrLead3DEdgeCenterGaugePointsPosition.Clear();

            for (int p = m_arrLead3DEdgeCenterGaugePoints.Count; p < m_arrTemplateBlobLeads.Count; p++)
            {
                m_arrLead3DCenterPointGaugeStartX.Add(new List<float>());
                m_arrLead3DCenterPointGaugeStartY.Add(new List<float>());
                m_arrLead3DCenterPointGaugeTolerance.Add(new List<float>());
                m_arrLead3DCenterPointGaugeAngle.Add(new List<float>());
            }

            //2021-05-07 ZJYEOH : in case build extra blob during learn then need assign extra PGauge object
            for (int i = m_arrCenterPointGauge.Count; i < m_arrTemplateBlobLeads.Count; i++)
            {
                if (i >= m_arrCenterPointGauge.Count)
                {
                    m_arrCenterPointGauge.Add(new List<PGauge>());
                }

                for (int j = 0; j < 6; j++)
                {
                    if (j >= m_arrCenterPointGauge[i].Count)
                    {
                        m_arrCenterPointGauge[i].Add(new PGauge());
                    }
                    
                    m_arrCenterPointGauge[i][j].ref_GaugeMinAmplitude = 0;
                    m_arrCenterPointGauge[i][j].ref_GaugeMinArea = 0;
                    m_arrCenterPointGauge[i][j].ref_GaugeFilter = 2;

                    m_arrCenterPointGauge[i][j].ref_objPointGauge.SetCenterXY(m_arrCenterPointGauge[i - 1][j].ref_objPointGauge.CenterX, m_arrCenterPointGauge[i - 1][j].ref_objPointGauge.CenterY);
                    m_arrCenterPointGauge[i][j].ref_objPointGauge.MinAmplitude = m_arrCenterPointGauge[i - 1][j].ref_objPointGauge.MinAmplitude;
                    m_arrCenterPointGauge[i][j].ref_objPointGauge.MinArea = m_arrCenterPointGauge[i - 1][j].ref_objPointGauge.MinArea;
                    m_arrCenterPointGauge[i][j].ref_objPointGauge.Smoothing = m_arrCenterPointGauge[i - 1][j].ref_objPointGauge.Smoothing;
                    m_arrCenterPointGauge[i][j].ref_objPointGauge.Thickness = m_arrCenterPointGauge[i - 1][j].ref_objPointGauge.Thickness;
                    m_arrCenterPointGauge[i][j].ref_objPointGauge.Threshold = m_arrCenterPointGauge[i - 1][j].ref_objPointGauge.Threshold;
                    m_arrCenterPointGauge[i][j].ref_objPointGauge.TransitionType = m_arrCenterPointGauge[i - 1][j].ref_objPointGauge.TransitionType;
                    m_arrCenterPointGauge[i][j].ref_objPointGauge.TransitionChoice = m_arrCenterPointGauge[i - 1][j].ref_objPointGauge.TransitionChoice;
                    m_arrCenterPointGauge[i][j].ref_objPointGauge.Tolerance = m_arrCenterPointGauge[i - 1][j].ref_objPointGauge.Tolerance;
                    m_arrCenterPointGauge[i][j].ref_objPointGauge.Angle = m_arrCenterPointGauge[i - 1][j].ref_objPointGauge.Angle;

                }
            }

            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                for (int p = m_arrLead3DEdgeCenterGaugePoints.Count; p <= i; p++)
                {
                    m_arrLead3DEdgeCenterGaugePoints.Add(new List<PointF>());
                    m_arrLead3DEdgeCenterGaugePointsFound.Add(new List<bool>());
                }
                m_arrLead3DEdgeCenterGaugePointsPosition.Add(m_stcBlobLead.intDirection);
                switch (m_stcBlobLead.intDirection)
                {
                    //Top
                    case 4:
                        //Base
                        intBaseCenterAngle = 90;
                        intBaseStartAngle = 180;
                        intBaseEndAngle = 0;
                        fLimitCenterX = objROI.ref_ROITotalX + m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = objROI.ref_ROITotalY + m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;

                        //float fTopFixPointY;
                        //PointF pTopStart;
                        //PointF pTopEnd;

                        //// Calculate the Base center Y
                        ////m_stcBlobLead.fBaseCenterY = m_pCornerPoint_Center.Y - (m_fCenterUnitHeight / 2) - m_intPkgToBaseTolerance_Top;
                        //m_stcBlobLead.fBaseCenterY = ((m_pCornerPoint_TopLeft.Y + m_pCornerPoint_TopRight.Y) / 2) - m_intPkgToBaseTolerance_Top;
                        //m_stcBlobLead.fBaseCenterY -= objROI.ref_ROITotalY;
                        //AddCenterPointGaugePlacementToArray(-1, -1, -1, -1);
                        //m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(-1, -1));
                        //m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        //m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(-1, -1));
                        //m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        //m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(-1, -1));
                        //m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);

                        // ------- Find Base Point X -----------------------------------------
                        m_stcBlobLead.fBaseCenterY = ((m_pCornerPoint_TopLeft.Y + m_pCornerPoint_TopRight.Y) / 2) - m_intPkgToBaseTolerance_Top;

                        if (m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].ref_GaugeTransType != 1)
                            m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].ref_GaugeTransType = 1;     // Black to white

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].SetGaugePlacement(fLimitCenterX,
                                                          m_stcBlobLead.fBaseCenterY,
                                                          fHeight * (m_fPointGaugeToleranceRate * m), 90);

                            m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].Measure(objROI);
                            if (m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                            {
                                AddCenterPointGaugePlacementToArray(fLimitCenterX,
                                                          m_stcBlobLead.fBaseCenterY,
                                                          fHeight * (m_fPointGaugeToleranceRate * m), 90, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                AddCenterPointGaugePlacementToArray(fLimitCenterX,
                                                          m_stcBlobLead.fBaseCenterY,
                                                          fHeight * (m_fPointGaugeToleranceRate * m), 90, i);
                            }
                        }

                        if (m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                        {
                            m_stcBlobLead.fBaseCenterX = m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointX(0);
                            if(m_blnWantUseGaugeMeasureBase)
                                m_stcBlobLead.fBaseCenterY = m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointY(0);
                            m_stcBlobLead.blnBaseCenterFound = true;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(m_stcBlobLead.fBaseCenterX, m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointY(0)));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            m_stcBlobLead.fBaseCenterX = fLimitCenterX;
                            if (m_blnWantUseGaugeMeasureBase)
                                m_stcBlobLead.fBaseCenterY = fLimitCenterY + (m_stcBlobLead.fHeight / 2);
                            m_stcBlobLead.blnBaseCenterFound = false;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(m_stcBlobLead.fBaseCenterX, m_stcBlobLead.fBaseCenterY));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Base start point -----------------------------------------
                        float fTopFixPointY = m_stcBlobLead.fBaseCenterY - m_intBaseOffset;

                        if (m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].ref_GaugeTransType != 1)
                            m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].ref_GaugeTransType = 1;     // Black to white

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].SetGaugePlacement(m_stcBlobLead.fBaseCenterX - fWidth / 2,
                                                              fTopFixPointY,
                                                             fWidth * (m_fPointGaugeToleranceRate * m), 180);

                            m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].Measure(objROI);
                            if (m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                            {
                                SetCenterPointGaugePlacementToArray(m_stcBlobLead.fBaseCenterX - fWidth / 2,
                                                          fTopFixPointY,
                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.BaseStart, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetCenterPointGaugePlacementToArray(m_stcBlobLead.fBaseCenterX - fWidth / 2,
                                                          fTopFixPointY,
                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.BaseStart, i);
                            }
                        }

                        PointF pTopStart;
                        if (m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                        {
                            pTopStart = m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].GetMeasurePoint(0);
                            m_stcBlobLead.blnBaseStartFound = true;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pTopStart.X, pTopStart.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pTopStart = new PointF(m_stcBlobLead.fBaseCenterX - fWidth / 2, fTopFixPointY);
                            m_stcBlobLead.blnBaseStartFound = false;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pTopStart.X, pTopStart.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Base end point -----------------------------------------

                        if (m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].ref_GaugeTransType != 1)
                            m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].ref_GaugeTransType = 1;     // Black to white

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].SetGaugePlacement(m_stcBlobLead.fBaseCenterX + fWidth / 2,
                                                        fTopFixPointY,
                                                       fWidth * (m_fPointGaugeToleranceRate * m), 0);

                            m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].Measure(objROI);
                            if (m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                            {
                                SetCenterPointGaugePlacementToArray(m_stcBlobLead.fBaseCenterX + fWidth / 2,
                                                         fTopFixPointY,
                                                        fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.BaseEnd, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetCenterPointGaugePlacementToArray(m_stcBlobLead.fBaseCenterX + fWidth / 2,
                                                         fTopFixPointY,
                                                        fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.BaseEnd, i);
                            }
                        }

                        PointF pTopEnd;
                        if (m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                        {
                            pTopEnd = m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].GetMeasurePoint(0);
                            m_stcBlobLead.blnBaseEndFound = true;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pTopEnd.X, pTopEnd.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pTopEnd = new PointF(m_stcBlobLead.fBaseCenterX + fWidth / 2, fTopFixPointY);
                            m_stcBlobLead.blnBaseEndFound = false;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pTopEnd.X, pTopEnd.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        }

                        // Calculate the Base width and center X
                        m_stcBlobLead.fBaseWidth = pTopEnd.X - pTopStart.X;
                        m_stcBlobLead.fBaseCenterX = (pTopEnd.X + pTopStart.X) / 2 - objROI.ref_ROITotalX;
                        m_stcBlobLead.fBaseCenterY -= objROI.ref_ROITotalY;


                        //Tip
                        intTipCenterAngle = -90;
                        intTipStartAngle = 180;
                        intTipEndAngle = 0;
                        fLimitCenterX = objROI.ref_ROITotalX + m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = objROI.ref_ROITotalY + m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        // ------- Find Tip Point X -----------------------------------------

                        if (m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].ref_GaugeTransType != 1)
                            m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].ref_GaugeTransType = 1;     // Black to white

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].SetGaugePlacement(fLimitCenterX,
                                                          fLimitCenterY - (m_stcBlobLead.fHeight / 2),
                                                          fHeight * (m_fPointGaugeToleranceRate * m), -90);

                            m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].Measure(objROI);
                            if (m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                            {
                                SetCenterPointGaugePlacementToArray(fLimitCenterX,
                                                          fLimitCenterY - (m_stcBlobLead.fHeight / 2),
                                                          fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.TipCenter, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetCenterPointGaugePlacementToArray(fLimitCenterX,
                                                          fLimitCenterY - (m_stcBlobLead.fHeight / 2),
                                                          fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.TipCenter, i);
                            }
                        }

                        if (m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                        {
                            m_stcBlobLead.fTipCenterX = m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].GetMeasurePointX(0);
                            m_stcBlobLead.fTipCenterY = m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].GetMeasurePointY(0);
                            m_stcBlobLead.blnTipCenterFound = true;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            m_stcBlobLead.fTipCenterX = fLimitCenterX;
                            m_stcBlobLead.fTipCenterY = fLimitCenterY - (m_stcBlobLead.fHeight / 2);
                            m_stcBlobLead.blnTipCenterFound = false;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Tip start point -----------------------------------------
                        fTopFixPointY = m_stcBlobLead.fTipCenterY + m_intTipOffset;

                        if (m_arrCenterPointGauge[i][(int)PointIndex.TipStart].ref_GaugeTransType != 1)
                            m_arrCenterPointGauge[i][(int)PointIndex.TipStart].ref_GaugeTransType = 1;     // Black to white

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrCenterPointGauge[i][(int)PointIndex.TipStart].SetGaugePlacement(m_stcBlobLead.fTipCenterX - fWidth / 2,
                                                          fTopFixPointY,
                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180);

                            m_arrCenterPointGauge[i][(int)PointIndex.TipStart].Measure(objROI);
                            if (m_arrCenterPointGauge[i][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                            {
                                SetCenterPointGaugePlacementToArray(m_stcBlobLead.fTipCenterX - fWidth / 2,
                                                          fTopFixPointY,
                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.TipStart, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetCenterPointGaugePlacementToArray(m_stcBlobLead.fTipCenterX - fWidth / 2,
                                                          fTopFixPointY,
                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.TipStart, i);
                            }
                        }

                        if (m_arrCenterPointGauge[i][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                        {
                            pTopStart = m_arrCenterPointGauge[i][(int)PointIndex.TipStart].GetMeasurePoint(0);
                            m_stcBlobLead.blnTipStartFound = true;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pTopStart.X, pTopStart.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pTopStart = new PointF(m_stcBlobLead.fTipCenterX - fWidth / 2, fTopFixPointY);
                            m_stcBlobLead.blnTipStartFound = false;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pTopStart.X, pTopStart.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Tip end point -----------------------------------------

                        if (m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].ref_GaugeTransType != 1)
                            m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].ref_GaugeTransType = 1;     // Black to white

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].SetGaugePlacement(m_stcBlobLead.fTipCenterX + fWidth / 2,
                                                        fTopFixPointY,
                                                       fWidth * (m_fPointGaugeToleranceRate * m), 0);

                            m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].Measure(objROI);
                            if (m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                            {
                                SetCenterPointGaugePlacementToArray(m_stcBlobLead.fTipCenterX + fWidth / 2,
                                                        fTopFixPointY,
                                                       fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.TipEnd, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetCenterPointGaugePlacementToArray(m_stcBlobLead.fTipCenterX + fWidth / 2,
                                                        fTopFixPointY,
                                                       fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.TipEnd, i);
                            }
                        }

                        if (m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                        {
                            pTopEnd = m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].GetMeasurePoint(0);
                            m_stcBlobLead.blnTipEndFound = true;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pTopEnd.X, pTopEnd.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pTopEnd = new PointF(m_stcBlobLead.fTipCenterX + fWidth / 2, fTopFixPointY);
                            m_stcBlobLead.blnTipEndFound = false;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pTopEnd.X, pTopEnd.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        }

                        // Calculate the Tip width and center point
                        m_stcBlobLead.fTipWidth = pTopEnd.X - pTopStart.X; //m_stcBlobLead.fBaseWidth = 
                        m_stcBlobLead.fTipCenterX = (pTopEnd.X + pTopStart.X) / 2 - objROI.ref_ROITotalX; //m_stcBlobLead.fBaseCenterX =
                        m_stcBlobLead.fTipCenterY -= objROI.ref_ROITotalY;

                        // Base and Tip Length
                        m_stcBlobLead.fBaseLength = m_stcBlobLead.fBaseCenterY - m_stcBlobLead.fTipCenterY;
                        m_stcBlobLead.fTipLength = m_stcBlobLead.fBaseCenterY - m_stcBlobLead.fTipCenterY;
                        break;
                    //Right
                    case 2:
                        //Base
                        intBaseCenterAngle = 180;
                        intBaseStartAngle = -90;
                        intBaseEndAngle = 90;
                        fLimitCenterX = objROI.ref_ROITotalX + m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = objROI.ref_ROITotalY + m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;

                        //float fRightFixPointX;
                        //PointF pRightStart;
                        //PointF pRightEnd;

                        //// Calculate the Base width and center X
                        ////m_stcBlobLead.fBaseCenterX = m_pCornerPoint_Center.X + (m_fCenterUnitWidth / 2) + m_intPkgToBaseTolerance_Right;
                        //m_stcBlobLead.fBaseCenterX = ((m_pCornerPoint_TopRight.X + m_pCornerPoint_BottomRight.X) / 2) + m_intPkgToBaseTolerance_Right;
                        //m_stcBlobLead.fBaseCenterX -= objROI.ref_ROITotalX;
                        //AddCenterPointGaugePlacementToArray(-1, -1, -1, -1);
                        //m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(-1, -1));
                        //m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        //m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(-1, -1));
                        //m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        //m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(-1, -1));
                        //m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);

                        // ------- Find Base Point Y -----------------------------------------
                        m_stcBlobLead.fBaseCenterX = ((m_pCornerPoint_TopRight.X + m_pCornerPoint_BottomRight.X) / 2) + m_intPkgToBaseTolerance_Right;

                        if (m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].ref_GaugeTransType != 1)
                            m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].ref_GaugeTransType = 1;     // Black to white

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].SetGaugePlacement(m_stcBlobLead.fBaseCenterX,
                                                          fLimitCenterY,
                                                          fWidth * (m_fPointGaugeToleranceRate * m), 180);

                            m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].Measure(objROI);
                            if (m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                            {
                                AddCenterPointGaugePlacementToArray(m_stcBlobLead.fBaseCenterX,
                                                          fLimitCenterY,
                                                          fWidth * (m_fPointGaugeToleranceRate * m), 180, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                AddCenterPointGaugePlacementToArray(m_stcBlobLead.fBaseCenterX,
                                                           fLimitCenterY,
                                                           fWidth * (m_fPointGaugeToleranceRate * m), 180, i);
                            }
                        }

                        if (m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                        {
                            if (m_blnWantUseGaugeMeasureBase)
                                m_stcBlobLead.fBaseCenterX = m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointX(0);
                            m_stcBlobLead.fBaseCenterY = m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointY(0);
                            m_stcBlobLead.blnBaseCenterFound = true;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointX(0), m_stcBlobLead.fBaseCenterY));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            if (m_blnWantUseGaugeMeasureBase)
                                m_stcBlobLead.fBaseCenterX = fLimitCenterX - (m_stcBlobLead.fWidth / 2);
                            m_stcBlobLead.fBaseCenterY = fLimitCenterY;
                            m_stcBlobLead.blnBaseCenterFound = false;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(m_stcBlobLead.fBaseCenterX, m_stcBlobLead.fBaseCenterY));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Base start point -----------------------------------------
                        float fRightFixPointX = m_stcBlobLead.fBaseCenterX + m_intBaseOffset;

                        if (m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].ref_GaugeTransType != 1)
                            m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].ref_GaugeTransType = 1;     // Black to white

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].SetGaugePlacement(fRightFixPointX,
                                                          m_stcBlobLead.fBaseCenterY - fHeight / 2,
                                                         fHeight * (m_fPointGaugeToleranceRate * m), -90);

                            m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].Measure(objROI);
                            if (m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                            {
                                SetCenterPointGaugePlacementToArray(fRightFixPointX,
                                                          m_stcBlobLead.fBaseCenterY - fHeight / 2,
                                                         fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.BaseStart, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetCenterPointGaugePlacementToArray(fRightFixPointX,
                                                          m_stcBlobLead.fBaseCenterY - fHeight / 2,
                                                         fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.BaseStart, i);
                            }
                        }

                        PointF pRightStart;
                        if (m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                        {
                            pRightStart = m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].GetMeasurePoint(0);
                            m_stcBlobLead.blnBaseStartFound = true;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pRightStart.X, pRightStart.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pRightStart = new PointF(fRightFixPointX, m_stcBlobLead.fBaseCenterY - fHeight / 2);
                            m_stcBlobLead.blnBaseStartFound = false;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pRightStart.X, pRightStart.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Base end point -----------------------------------------

                        if (m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].ref_GaugeTransType != 1)
                            m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].ref_GaugeTransType = 1;     // Black to white

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].SetGaugePlacement(fRightFixPointX,
                                                        m_stcBlobLead.fBaseCenterY + fHeight / 2,
                                                       fHeight * (m_fPointGaugeToleranceRate * m), 90);

                            m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].Measure(objROI);
                            if (m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                            {
                                SetCenterPointGaugePlacementToArray(fRightFixPointX,
                                                        m_stcBlobLead.fBaseCenterY + fHeight / 2,
                                                       fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.BaseEnd, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetCenterPointGaugePlacementToArray(fRightFixPointX,
                                                        m_stcBlobLead.fBaseCenterY + fHeight / 2,
                                                       fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.BaseEnd, i);
                            }
                        }

                        PointF pRightEnd;
                        if (m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                        {
                            pRightEnd = m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].GetMeasurePoint(0);
                            m_stcBlobLead.blnBaseEndFound = true;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pRightEnd.X, pRightEnd.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pRightEnd = new PointF(fRightFixPointX, m_stcBlobLead.fBaseCenterY + fHeight / 2);
                            m_stcBlobLead.blnBaseEndFound = false;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pRightEnd.X, pRightEnd.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        }

                        // Calculate the Base width and center Y
                        m_stcBlobLead.fBaseWidth = pRightEnd.Y - pRightStart.Y;
                        m_stcBlobLead.fBaseCenterY = (pRightEnd.Y + pRightStart.Y) / 2 - objROI.ref_ROITotalY;
                        m_stcBlobLead.fBaseCenterX -= objROI.ref_ROITotalX;


                        //Tip
                        intTipCenterAngle = 0;
                        intTipStartAngle = -90;
                        intTipEndAngle = 90;
                        fLimitCenterX = objROI.ref_ROITotalX + m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = objROI.ref_ROITotalY + m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        // ------- Find Tip Point X -----------------------------------------

                        if (m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].ref_GaugeTransType != 1)
                            m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].ref_GaugeTransType = 1;     // Black to white

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].SetGaugePlacement(fLimitCenterX + (m_stcBlobLead.fWidth / 2),
                                                        fLimitCenterY,
                                                        fWidth * (m_fPointGaugeToleranceRate * m), 0);

                            m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].Measure(objROI);
                            if (m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                            {
                                SetCenterPointGaugePlacementToArray(fLimitCenterX + (m_stcBlobLead.fWidth / 2),
                                                        fLimitCenterY,
                                                        fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.TipCenter, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetCenterPointGaugePlacementToArray(fLimitCenterX + (m_stcBlobLead.fWidth / 2),
                                                        fLimitCenterY,
                                                        fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.TipCenter, i);
                            }
                        }

                        if (m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                        {
                            m_stcBlobLead.fTipCenterX = m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].GetMeasurePointX(0);
                            m_stcBlobLead.fTipCenterY = m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].GetMeasurePointY(0);
                            m_stcBlobLead.blnTipCenterFound = true;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            m_stcBlobLead.fTipCenterX = fLimitCenterX + (m_stcBlobLead.fWidth / 2);
                            m_stcBlobLead.fTipCenterY = fLimitCenterY;
                            m_stcBlobLead.blnTipCenterFound = false;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Tip start point -----------------------------------------
                        fRightFixPointX = m_stcBlobLead.fTipCenterX - m_intTipOffset;

                        if (m_arrCenterPointGauge[i][(int)PointIndex.TipStart].ref_GaugeTransType != 1)
                            m_arrCenterPointGauge[i][(int)PointIndex.TipStart].ref_GaugeTransType = 1;     // Black to white

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrCenterPointGauge[i][(int)PointIndex.TipStart].SetGaugePlacement(fRightFixPointX,
                                                              m_stcBlobLead.fTipCenterY - (m_stcBlobLead.fHeight / 2),
                                                             fHeight * (m_fPointGaugeToleranceRate * m), -90);

                            m_arrCenterPointGauge[i][(int)PointIndex.TipStart].Measure(objROI);
                            if (m_arrCenterPointGauge[i][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                            {
                                SetCenterPointGaugePlacementToArray(fRightFixPointX,
                                                                  m_stcBlobLead.fTipCenterY - (m_stcBlobLead.fHeight / 2),
                                                                 fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.TipStart, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetCenterPointGaugePlacementToArray(fRightFixPointX,
                                                                  m_stcBlobLead.fTipCenterY - (m_stcBlobLead.fHeight / 2),
                                                                 fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.TipStart, i);
                            }
                        }

                        if (m_arrCenterPointGauge[i][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                        {
                            pRightStart = m_arrCenterPointGauge[i][(int)PointIndex.TipStart].GetMeasurePoint(0);
                            m_stcBlobLead.blnTipStartFound = true;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pRightStart.X, pRightStart.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pRightStart = new PointF(fRightFixPointX, m_stcBlobLead.fTipCenterY - (m_stcBlobLead.fHeight / 2));
                            m_stcBlobLead.blnTipStartFound = false;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pRightStart.X, pRightStart.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Tip end point -----------------------------------------

                        if (m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].ref_GaugeTransType != 1)
                            m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].ref_GaugeTransType = 1;     // Black to white

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].SetGaugePlacement(fRightFixPointX,
                                                                  m_stcBlobLead.fTipCenterY + (m_stcBlobLead.fHeight / 2),
                                                                 fHeight * (m_fPointGaugeToleranceRate * m), 90);

                            m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].Measure(objROI);
                            if (m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                            {
                                SetCenterPointGaugePlacementToArray(fRightFixPointX,
                                                                      m_stcBlobLead.fTipCenterY + (m_stcBlobLead.fHeight / 2),
                                                                     fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.TipEnd, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetCenterPointGaugePlacementToArray(fRightFixPointX,
                                                                      m_stcBlobLead.fTipCenterY + (m_stcBlobLead.fHeight / 2),
                                                                     fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.TipEnd, i);
                            }
                        }

                        if (m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                        {
                            pRightEnd = m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].GetMeasurePoint(0);
                            m_stcBlobLead.blnTipEndFound = true;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pRightEnd.X, pRightEnd.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pRightEnd = new PointF(fRightFixPointX, m_stcBlobLead.fTipCenterY + (m_stcBlobLead.fHeight / 2));
                            m_stcBlobLead.blnTipEndFound = false;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pRightEnd.X, pRightEnd.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        }

                        // Calculate the Tip width and center point
                        m_stcBlobLead.fTipWidth = pRightEnd.Y - pRightStart.Y;
                        m_stcBlobLead.fTipCenterY = (pRightEnd.Y + pRightStart.Y) / 2 - objROI.ref_ROITotalY;//m_stcBlobLead.fBaseWidth =
                        m_stcBlobLead.fTipCenterX -= objROI.ref_ROITotalX; //m_stcBlobLead.fBaseCenterY = 

                        // Base and Tip Length
                        m_stcBlobLead.fBaseLength = m_stcBlobLead.fTipCenterX - m_stcBlobLead.fBaseCenterX;
                        m_stcBlobLead.fTipLength = m_stcBlobLead.fTipCenterX - m_stcBlobLead.fBaseCenterX;
                        break;
                    //Bottom
                    case 8:
                        //Base
                        intBaseCenterAngle = -90;
                        intBaseStartAngle = 180;
                        intBaseEndAngle = 0;
                        fLimitCenterX = objROI.ref_ROITotalX + m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = objROI.ref_ROITotalY + m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;

                        //float fBottomFixPointY;
                        //PointF pBottomStart;
                        //PointF pBottomEnd;

                        //// Calculate the Base width and center Y
                        ////m_stcBlobLead.fBaseCenterY = m_pCornerPoint_Center.Y + (m_fCenterUnitHeight / 2) + m_intPkgToBaseTolerance_Bottom;
                        //m_stcBlobLead.fBaseCenterY = ((m_pCornerPoint_BottomRight.Y + m_pCornerPoint_BottomLeft.Y) / 2) + m_intPkgToBaseTolerance_Bottom;
                        //m_stcBlobLead.fBaseCenterY -= objROI.ref_ROITotalY;
                        //AddCenterPointGaugePlacementToArray(-1, -1, -1, -1);
                        //m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(-1, -1));
                        //m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        //m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(-1, -1));
                        //m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        //m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(-1, -1));
                        //m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);

                        // ------- Find Base Point X -----------------------------------------
                        m_stcBlobLead.fBaseCenterY = ((m_pCornerPoint_BottomRight.Y + m_pCornerPoint_BottomLeft.Y) / 2) + m_intPkgToBaseTolerance_Bottom;

                        if (m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].ref_GaugeTransType != 1)
                            m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].ref_GaugeTransType = 1;     // Black to white

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].SetGaugePlacement(fLimitCenterX,
                                                              m_stcBlobLead.fBaseCenterY,
                                                              fHeight * (m_fPointGaugeToleranceRate * m), -90);

                            m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].Measure(objROI);
                            if (m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                            {
                                AddCenterPointGaugePlacementToArray(fLimitCenterX,
                                                                  m_stcBlobLead.fBaseCenterY,
                                                                  fHeight * (m_fPointGaugeToleranceRate * m), -90, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                AddCenterPointGaugePlacementToArray(fLimitCenterX,
                                                                  m_stcBlobLead.fBaseCenterY,
                                                                  fHeight * (m_fPointGaugeToleranceRate * m), -90, i);
                            }
                        }

                        if (m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                        {
                            m_stcBlobLead.fBaseCenterX = m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointX(0);
                            if (m_blnWantUseGaugeMeasureBase)
                                m_stcBlobLead.fBaseCenterY = m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointY(0);
                            m_stcBlobLead.blnBaseCenterFound = true;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(m_stcBlobLead.fBaseCenterX, m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointY(0)));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            m_stcBlobLead.fBaseCenterX = fLimitCenterX;
                            if (m_blnWantUseGaugeMeasureBase)
                                m_stcBlobLead.fBaseCenterY = fLimitCenterY - (m_stcBlobLead.fHeight / 2);
                            m_stcBlobLead.blnBaseCenterFound = false;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(m_stcBlobLead.fBaseCenterX, m_stcBlobLead.fBaseCenterY));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Base start point -----------------------------------------
                        float fBottomFixPointY = m_stcBlobLead.fBaseCenterY + m_intBaseOffset;

                        if (m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].ref_GaugeTransType != 1)
                            m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].ref_GaugeTransType = 1;     // Black to white

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].SetGaugePlacement(m_stcBlobLead.fBaseCenterX - fWidth / 2,
                                                              fBottomFixPointY,
                                                             fWidth * (m_fPointGaugeToleranceRate * m), 180);

                            m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].Measure(objROI);
                            if (m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                            {
                                SetCenterPointGaugePlacementToArray(m_stcBlobLead.fBaseCenterX - fWidth / 2,
                                                                  fBottomFixPointY,
                                                                 fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.BaseStart, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetCenterPointGaugePlacementToArray(m_stcBlobLead.fBaseCenterX - fWidth / 2,
                                                                  fBottomFixPointY,
                                                                 fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.BaseStart, i);
                            }
                        }

                        PointF pBottomStart;
                        if (m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                        {
                            pBottomStart = m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].GetMeasurePoint(0);
                            m_stcBlobLead.blnBaseStartFound = true;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pBottomStart.X, pBottomStart.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pBottomStart = new PointF(m_stcBlobLead.fBaseCenterX - fWidth / 2, fBottomFixPointY);
                            m_stcBlobLead.blnBaseStartFound = false;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pBottomStart.X, pBottomStart.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Base end point -----------------------------------------

                        if (m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].ref_GaugeTransType != 1)
                            m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].ref_GaugeTransType = 1;     // Black to white

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].SetGaugePlacement(m_stcBlobLead.fBaseCenterX + fWidth / 2,
                                                            fBottomFixPointY,
                                                           fWidth * (m_fPointGaugeToleranceRate * m), 0);

                            m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].Measure(objROI);
                            if (m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                            {
                                SetCenterPointGaugePlacementToArray(m_stcBlobLead.fBaseCenterX + fWidth / 2,
                                                                fBottomFixPointY,
                                                               fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.BaseEnd, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetCenterPointGaugePlacementToArray(m_stcBlobLead.fBaseCenterX + fWidth / 2,
                                                                fBottomFixPointY,
                                                               fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.BaseEnd, i);
                            }
                        }

                        PointF pBottomEnd;
                        if (m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                        {
                            pBottomEnd = m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].GetMeasurePoint(0);
                            m_stcBlobLead.blnBaseEndFound = true;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pBottomEnd.X, pBottomEnd.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pBottomEnd = new PointF(m_stcBlobLead.fBaseCenterX + fWidth / 2, fBottomFixPointY);
                            m_stcBlobLead.blnBaseEndFound = false;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pBottomEnd.X, pBottomEnd.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        }

                        // Calculate the Base width and center X
                        m_stcBlobLead.fBaseWidth = pBottomEnd.X - pBottomStart.X;
                        m_stcBlobLead.fBaseCenterX = (pBottomEnd.X + pBottomStart.X) / 2 - objROI.ref_ROITotalX;
                        m_stcBlobLead.fBaseCenterY -= objROI.ref_ROITotalY;


                        //Tip
                        intTipCenterAngle = 90;
                        intTipStartAngle = 180;
                        intTipEndAngle = 0;
                        fLimitCenterX = objROI.ref_ROITotalX + m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = objROI.ref_ROITotalY + m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        // ------- Find Tip Point X -----------------------------------------

                        if (m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].ref_GaugeTransType != 1)
                            m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].ref_GaugeTransType = 1;     // Black to white

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].SetGaugePlacement(fLimitCenterX,
                                                              fLimitCenterY + (m_stcBlobLead.fHeight / 2),
                                                              fHeight * (m_fPointGaugeToleranceRate * m), 90);

                            m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].Measure(objROI);
                            if (m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                            {
                                SetCenterPointGaugePlacementToArray(fLimitCenterX,
                                                                  fLimitCenterY + (m_stcBlobLead.fHeight / 2),
                                                                  fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.TipCenter, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetCenterPointGaugePlacementToArray(fLimitCenterX,
                                                                  fLimitCenterY + (m_stcBlobLead.fHeight / 2),
                                                                  fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.TipCenter, i);
                            }
                        }

                        if (m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                        {
                            m_stcBlobLead.fTipCenterX = m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].GetMeasurePointX(0);
                            m_stcBlobLead.fTipCenterY = m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].GetMeasurePointY(0);
                            m_stcBlobLead.blnTipCenterFound = true;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            m_stcBlobLead.fTipCenterX = fLimitCenterX;
                            m_stcBlobLead.fTipCenterY = fLimitCenterY + (m_stcBlobLead.fHeight / 2);
                            m_stcBlobLead.blnTipCenterFound = false;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Tip start point -----------------------------------------
                        fBottomFixPointY = m_stcBlobLead.fTipCenterY - m_intTipOffset;

                        if (m_arrCenterPointGauge[i][(int)PointIndex.TipStart].ref_GaugeTransType != 1)
                            m_arrCenterPointGauge[i][(int)PointIndex.TipStart].ref_GaugeTransType = 1;     // Black to white

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrCenterPointGauge[i][(int)PointIndex.TipStart].SetGaugePlacement(m_stcBlobLead.fTipCenterX - fWidth / 2,
                                                              fBottomFixPointY,
                                                             fWidth * (m_fPointGaugeToleranceRate * m), 180);

                            m_arrCenterPointGauge[i][(int)PointIndex.TipStart].Measure(objROI);
                            if (m_arrCenterPointGauge[i][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                            {
                                SetCenterPointGaugePlacementToArray(m_stcBlobLead.fTipCenterX - fWidth / 2,
                                                                  fBottomFixPointY,
                                                                 fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.TipStart, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetCenterPointGaugePlacementToArray(m_stcBlobLead.fTipCenterX - fWidth / 2,
                                                                  fBottomFixPointY,
                                                                 fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.TipStart, i);
                            }
                        }

                        if (m_arrCenterPointGauge[i][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                        {
                            pBottomStart = m_arrCenterPointGauge[i][(int)PointIndex.TipStart].GetMeasurePoint(0);
                            m_stcBlobLead.blnTipStartFound = true;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pBottomStart.X, pBottomStart.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pBottomStart = new PointF(m_stcBlobLead.fTipCenterX - fWidth / 2, fBottomFixPointY);
                            m_stcBlobLead.blnTipStartFound = false;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pBottomStart.X, pBottomStart.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Tip end point -----------------------------------------

                        if (m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].ref_GaugeTransType != 1)
                            m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].ref_GaugeTransType = 1;     // Black to white

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].SetGaugePlacement(m_stcBlobLead.fTipCenterX + fWidth / 2,
                                                            fBottomFixPointY,
                                                           fWidth * (m_fPointGaugeToleranceRate * m), 0);

                            m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].Measure(objROI);
                            if (m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                            {
                                SetCenterPointGaugePlacementToArray(m_stcBlobLead.fTipCenterX + fWidth / 2,
                                                                fBottomFixPointY,
                                                               fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.TipEnd, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetCenterPointGaugePlacementToArray(m_stcBlobLead.fTipCenterX + fWidth / 2,
                                                                fBottomFixPointY,
                                                               fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.TipEnd, i);
                            }
                        }

                        if (m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                        {
                            pBottomEnd = m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].GetMeasurePoint(0);
                            m_stcBlobLead.blnTipEndFound = true;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pBottomEnd.X, pBottomEnd.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pBottomEnd = new PointF(m_stcBlobLead.fTipCenterX + fWidth / 2, fBottomFixPointY);
                            m_stcBlobLead.blnTipEndFound = false;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pBottomEnd.X, pBottomEnd.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        }

                        // Calculate the Tip width and center point
                        m_stcBlobLead.fTipWidth = pBottomEnd.X - pBottomStart.X; //m_stcBlobLead.fBaseWidth = 
                        m_stcBlobLead.fTipCenterX = (pBottomEnd.X + pBottomStart.X) / 2 - objROI.ref_ROITotalX; //m_stcBlobLead.fBaseCenterX = 
                        m_stcBlobLead.fTipCenterY -= objROI.ref_ROITotalY;

                        // Base and Tip Length
                        m_stcBlobLead.fBaseLength = m_stcBlobLead.fTipCenterY - m_stcBlobLead.fBaseCenterY;
                        m_stcBlobLead.fTipLength = m_stcBlobLead.fTipCenterY - m_stcBlobLead.fBaseCenterY;
                        break;
                    //Left
                    case 1:
                        //Base
                        intBaseCenterAngle = 0;
                        intBaseStartAngle = -90;
                        intBaseEndAngle = 90;
                        fLimitCenterX = objROI.ref_ROITotalX + m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = objROI.ref_ROITotalY + m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;

                        //float fLeftFixPointX;
                        //PointF pLeftStart;
                        //PointF pLeftEnd;

                        //// Calculate the Base width center X
                        ////m_stcBlobLead.fBaseCenterX = m_pCornerPoint_Center.X - (m_fCenterUnitWidth / 2) - m_intPkgToBaseTolerance_Left;
                        //m_stcBlobLead.fBaseCenterX = ((m_pCornerPoint_BottomLeft.X + m_pCornerPoint_TopLeft.X) / 2) - m_intPkgToBaseTolerance_Left;
                        //m_stcBlobLead.fBaseCenterX -= objROI.ref_ROITotalX;
                        //AddCenterPointGaugePlacementToArray(-1, -1, -1, -1);
                        //m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(-1, -1));
                        //m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        //m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(-1, -1));
                        //m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        //m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(-1, -1));
                        //m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);

                        // ------- Find Base Point Y -----------------------------------------
                        m_stcBlobLead.fBaseCenterX = ((m_pCornerPoint_BottomLeft.X + m_pCornerPoint_TopLeft.X) / 2) - m_intPkgToBaseTolerance_Left;

                        if (m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].ref_GaugeTransType != 1)
                            m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].ref_GaugeTransType = 1;     // Black to white

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].SetGaugePlacement(m_stcBlobLead.fBaseCenterX,
                                                              fLimitCenterY,
                                                              fWidth * (m_fPointGaugeToleranceRate * m), 0);

                            m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].Measure(objROI);
                            if (m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                            {
                                AddCenterPointGaugePlacementToArray(m_stcBlobLead.fBaseCenterX,
                                                                  fLimitCenterY,
                                                                  fWidth * (m_fPointGaugeToleranceRate * m), 0, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                AddCenterPointGaugePlacementToArray(m_stcBlobLead.fBaseCenterX,
                                                                  fLimitCenterY,
                                                                  fWidth * (m_fPointGaugeToleranceRate * m), 0, i);
                            }
                        }

                        if (m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                        {
                            if (m_blnWantUseGaugeMeasureBase)
                                m_stcBlobLead.fBaseCenterX = m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointX(0);
                            m_stcBlobLead.fBaseCenterY = m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointY(0);
                            m_stcBlobLead.blnBaseCenterFound = true;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointX(0), m_stcBlobLead.fBaseCenterY));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            if (m_blnWantUseGaugeMeasureBase)
                                m_stcBlobLead.fBaseCenterX = fLimitCenterX + (m_stcBlobLead.fWidth / 2);
                            m_stcBlobLead.fBaseCenterY = fLimitCenterY;
                            m_stcBlobLead.blnBaseCenterFound = false;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(m_stcBlobLead.fBaseCenterX, m_stcBlobLead.fBaseCenterY));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Base start point -----------------------------------------
                        float fLeftFixPointX = m_stcBlobLead.fBaseCenterX - m_intBaseOffset;

                        if (m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].ref_GaugeTransType != 1)
                            m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].ref_GaugeTransType = 1;     // Black to white

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].SetGaugePlacement(fLeftFixPointX,
                                                              m_stcBlobLead.fBaseCenterY - fHeight / 2,
                                                             fHeight * (m_fPointGaugeToleranceRate * m), -90);

                            m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].Measure(objROI);
                            if (m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                            {
                                SetCenterPointGaugePlacementToArray(fLeftFixPointX,
                                                                  m_stcBlobLead.fBaseCenterY - fHeight / 2,
                                                                 fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.BaseStart, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetCenterPointGaugePlacementToArray(fLeftFixPointX,
                                                                  m_stcBlobLead.fBaseCenterY - fHeight / 2,
                                                                 fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.BaseStart, i);
                            }
                        }

                        PointF pLeftStart;
                        if (m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                        {
                            pLeftStart = m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].GetMeasurePoint(0);
                            m_stcBlobLead.blnBaseStartFound = true;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pLeftStart.X, pLeftStart.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pLeftStart = new PointF(fLeftFixPointX, m_stcBlobLead.fBaseCenterY - fHeight / 2);
                            m_stcBlobLead.blnBaseStartFound = false;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pLeftStart.X, pLeftStart.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Base end point -----------------------------------------

                        if (m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].ref_GaugeTransType != 1)
                            m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].ref_GaugeTransType = 1;     // Black to white

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].SetGaugePlacement(fLeftFixPointX,
                                                            m_stcBlobLead.fBaseCenterY + fHeight / 2,
                                                           fHeight * (m_fPointGaugeToleranceRate * m), 90);

                            m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].Measure(objROI);
                            if (m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                            {
                                SetCenterPointGaugePlacementToArray(fLeftFixPointX,
                                                                m_stcBlobLead.fBaseCenterY + fHeight / 2,
                                                               fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.BaseEnd, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetCenterPointGaugePlacementToArray(fLeftFixPointX,
                                                                m_stcBlobLead.fBaseCenterY + fHeight / 2,
                                                               fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.BaseEnd, i);
                            }
                        }

                        PointF pLeftEnd;
                        if (m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                        {
                            pLeftEnd = m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].GetMeasurePoint(0);
                            m_stcBlobLead.blnBaseEndFound = true;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pLeftEnd.X, pLeftEnd.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pLeftEnd = new PointF(fLeftFixPointX, m_stcBlobLead.fBaseCenterY + fHeight / 2);
                            m_stcBlobLead.blnBaseEndFound = false;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pLeftEnd.X, pLeftEnd.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        }

                        // Calculate the Base width center Y
                        m_stcBlobLead.fBaseWidth = pLeftEnd.Y - pLeftStart.Y;
                        m_stcBlobLead.fBaseCenterY = (pLeftEnd.Y + pLeftStart.Y) / 2 - objROI.ref_ROITotalY;
                        m_stcBlobLead.fBaseCenterX -= objROI.ref_ROITotalX;


                        //Tip
                        intTipCenterAngle = 180;
                        intTipStartAngle = -90;
                        intTipEndAngle = 90;
                        fLimitCenterX = objROI.ref_ROITotalX + m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = objROI.ref_ROITotalY + m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        // ------- Find Tip Point X -----------------------------------------

                        if (m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].ref_GaugeTransType != 1)
                            m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].ref_GaugeTransType = 1;     // Black to white

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].SetGaugePlacement(fLimitCenterX - (m_stcBlobLead.fWidth / 2),
                                                            fLimitCenterY,
                                                            fWidth * (m_fPointGaugeToleranceRate * m), 180);

                            m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].Measure(objROI);
                            if (m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                            {
                                SetCenterPointGaugePlacementToArray(fLimitCenterX - (m_stcBlobLead.fWidth / 2),
                                                                fLimitCenterY,
                                                                fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.TipCenter, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetCenterPointGaugePlacementToArray(fLimitCenterX - (m_stcBlobLead.fWidth / 2),
                                                                fLimitCenterY,
                                                                fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.TipCenter, i);
                            }
                        }

                        if (m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                        {
                            m_stcBlobLead.fTipCenterX = m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].GetMeasurePointX(0);
                            m_stcBlobLead.fTipCenterY = m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].GetMeasurePointY(0);
                            m_stcBlobLead.blnTipCenterFound = true;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            m_stcBlobLead.fTipCenterX = fLimitCenterX - (m_stcBlobLead.fWidth / 2);
                            m_stcBlobLead.fTipCenterY = fLimitCenterY;
                            m_stcBlobLead.blnTipCenterFound = false;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Tip start point -----------------------------------------
                        fLeftFixPointX = m_stcBlobLead.fTipCenterX + m_intTipOffset;

                        if (m_arrCenterPointGauge[i][(int)PointIndex.TipStart].ref_GaugeTransType != 1)
                            m_arrCenterPointGauge[i][(int)PointIndex.TipStart].ref_GaugeTransType = 1;     // Black to white

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrCenterPointGauge[i][(int)PointIndex.TipStart].SetGaugePlacement(fLeftFixPointX,
                                                              m_stcBlobLead.fTipCenterY - (m_stcBlobLead.fHeight / 2),
                                                             fHeight * (m_fPointGaugeToleranceRate * m), -90);

                            m_arrCenterPointGauge[i][(int)PointIndex.TipStart].Measure(objROI);
                            if (m_arrCenterPointGauge[i][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                            {
                                SetCenterPointGaugePlacementToArray(fLeftFixPointX,
                                                                  m_stcBlobLead.fTipCenterY - (m_stcBlobLead.fHeight / 2),
                                                                 fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.TipStart, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetCenterPointGaugePlacementToArray(fLeftFixPointX,
                                                                  m_stcBlobLead.fTipCenterY - (m_stcBlobLead.fHeight / 2),
                                                                 fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.TipStart, i);
                            }
                        }

                        if (m_arrCenterPointGauge[i][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                        {
                            pLeftStart = m_arrCenterPointGauge[i][(int)PointIndex.TipStart].GetMeasurePoint(0);
                            m_stcBlobLead.blnTipStartFound = true;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pLeftStart.X, pLeftStart.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pLeftStart = new PointF(fLeftFixPointX, m_stcBlobLead.fTipCenterY - (m_stcBlobLead.fHeight / 2));
                            m_stcBlobLead.blnTipStartFound = false;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pLeftStart.X, pLeftStart.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Tip end point -----------------------------------------

                        if (m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].ref_GaugeTransType != 1)
                            m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].ref_GaugeTransType = 1;     // Black to white

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].SetGaugePlacement(fLeftFixPointX,
                                                                  m_stcBlobLead.fTipCenterY + (m_stcBlobLead.fHeight / 2),
                                                                 fHeight * (m_fPointGaugeToleranceRate * m), 90);

                            m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].Measure(objROI);
                            if (m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                            {
                                SetCenterPointGaugePlacementToArray(fLeftFixPointX,
                                                                      m_stcBlobLead.fTipCenterY + (m_stcBlobLead.fHeight / 2),
                                                                     fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.TipEnd, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetCenterPointGaugePlacementToArray(fLeftFixPointX,
                                                                      m_stcBlobLead.fTipCenterY + (m_stcBlobLead.fHeight / 2),
                                                                     fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.TipEnd, i);
                            }
                        }

                        if (m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                        {
                            pLeftEnd = m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].GetMeasurePoint(0);
                            m_stcBlobLead.blnTipEndFound = true;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pLeftEnd.X, pLeftEnd.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pLeftEnd = new PointF(fLeftFixPointX, m_stcBlobLead.fTipCenterY + (m_stcBlobLead.fHeight / 2));
                            m_stcBlobLead.blnTipEndFound = false;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pLeftEnd.X, pLeftEnd.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        }

                        // Calculate the Tip width and center point
                        m_stcBlobLead.fTipWidth = pLeftEnd.Y - pLeftStart.Y; //m_stcBlobLead.fBaseWidth = 
                        m_stcBlobLead.fTipCenterY = (pLeftEnd.Y + pLeftStart.Y) / 2 - objROI.ref_ROITotalY; //m_stcBlobLead.fBaseCenterY = 
                        m_stcBlobLead.fTipCenterX -= objROI.ref_ROITotalX;

                        // Base and Tip Length
                        m_stcBlobLead.fBaseLength = m_stcBlobLead.fBaseCenterX - m_stcBlobLead.fTipCenterX;
                        m_stcBlobLead.fTipLength = m_stcBlobLead.fBaseCenterX - m_stcBlobLead.fTipCenterX;
                        break;
                }

                m_arrTemplateBlobLeads.RemoveAt(i);
                m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
            }
        }
        public void DefineLeadBaseTipWidth_Lead3D_PointGauge(ROI objROI)
        {
            //if (m_objCenterPointGauge.ref_GaugeTransChoice != 2)
            //    m_objCenterPointGauge.ref_GaugeTransChoice = 2;   // Use Largest Amplitude

            //if (m_objCenterPointGauge.ref_GaugeTransType != 1)
            //    m_objCenterPointGauge.ref_GaugeTransType = 1;     // Black to white

            float fLimitCenterX;
            float fLimitCenterY;
            float fNewCenterX;
            float fNewCenterY;
            float fWidth;
            float fHeight;
            int intFixPointXY;
            int intTipStartAngle, intTipCenterAngle, intTipEndAngle, intBaseStartAngle, intBaseCenterAngle, intBaseEndAngle;

            m_arrLead3DCenterPointGaugeStartX.Clear();
            m_arrLead3DCenterPointGaugeStartY.Clear();
            m_arrLead3DCenterPointGaugeTolerance.Clear();
            m_arrLead3DCenterPointGaugeAngle.Clear();
            m_arrLead3DEdgeCenterGaugePoints.Clear();
            m_arrLead3DEdgeCenterGaugePointsFound.Clear();
            m_arrLead3DEdgeCenterGaugePointsPosition.Clear();

            for (int p = m_arrLead3DEdgeCenterGaugePoints.Count; p < m_arrTemplateBlobLeads.Count; p++)
            {
                m_arrLead3DCenterPointGaugeStartX.Add(new List<float>());
                m_arrLead3DCenterPointGaugeStartY.Add(new List<float>());
                m_arrLead3DCenterPointGaugeTolerance.Add(new List<float>());
                m_arrLead3DCenterPointGaugeAngle.Add(new List<float>());
            }

            //2021-05-07 ZJYEOH : in case build extra blob during learn then need assign extra PGauge object
            for (int i = m_arrCenterPointGauge.Count; i < m_arrTemplateBlobLeads.Count; i++)
            {
                if (i >= m_arrCenterPointGauge.Count)
                {
                    m_arrCenterPointGauge.Add(new List<PGauge>());
                }

                for (int j = 0; j < 6; j++)
                {
                    if (j >= m_arrCenterPointGauge[i].Count)
                    {
                        m_arrCenterPointGauge[i].Add(new PGauge());
                    }

                    m_arrCenterPointGauge[i][j].ref_GaugeMinAmplitude = 0;
                    m_arrCenterPointGauge[i][j].ref_GaugeMinArea = 0;
                    m_arrCenterPointGauge[i][j].ref_GaugeFilter = 2;

                    m_arrCenterPointGauge[i][j].ref_objPointGauge.SetCenterXY(m_arrCenterPointGauge[i - 1][j].ref_objPointGauge.CenterX, m_arrCenterPointGauge[i - 1][j].ref_objPointGauge.CenterY);
                    m_arrCenterPointGauge[i][j].ref_objPointGauge.MinAmplitude = m_arrCenterPointGauge[i - 1][j].ref_objPointGauge.MinAmplitude;
                    m_arrCenterPointGauge[i][j].ref_objPointGauge.MinArea = m_arrCenterPointGauge[i - 1][j].ref_objPointGauge.MinArea;
                    m_arrCenterPointGauge[i][j].ref_objPointGauge.Smoothing = m_arrCenterPointGauge[i - 1][j].ref_objPointGauge.Smoothing;
                    m_arrCenterPointGauge[i][j].ref_objPointGauge.Thickness = m_arrCenterPointGauge[i - 1][j].ref_objPointGauge.Thickness;
                    m_arrCenterPointGauge[i][j].ref_objPointGauge.Threshold = m_arrCenterPointGauge[i - 1][j].ref_objPointGauge.Threshold;
                    m_arrCenterPointGauge[i][j].ref_objPointGauge.TransitionType = m_arrCenterPointGauge[i - 1][j].ref_objPointGauge.TransitionType;
                    m_arrCenterPointGauge[i][j].ref_objPointGauge.TransitionChoice = m_arrCenterPointGauge[i - 1][j].ref_objPointGauge.TransitionChoice;
                    m_arrCenterPointGauge[i][j].ref_objPointGauge.Tolerance = m_arrCenterPointGauge[i - 1][j].ref_objPointGauge.Tolerance;
                    m_arrCenterPointGauge[i][j].ref_objPointGauge.Angle = m_arrCenterPointGauge[i - 1][j].ref_objPointGauge.Angle;

                }
            }

            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                for (int p = m_arrLead3DEdgeCenterGaugePoints.Count; p <= i; p++)
                {
                    m_arrLead3DEdgeCenterGaugePoints.Add(new List<PointF>());
                    m_arrLead3DEdgeCenterGaugePointsFound.Add(new List<bool>());
                }
                m_arrLead3DEdgeCenterGaugePointsPosition.Add(m_stcBlobLead.intDirection);
                switch (m_stcBlobLead.intDirection)
                {
                    //Top
                    case 4:
                        //Base
                        intBaseCenterAngle = 90;
                        intBaseStartAngle = 180;
                        intBaseEndAngle = 0;
                        fLimitCenterX = objROI.ref_ROITotalX + m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = objROI.ref_ROITotalY + m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        // ------- Find Base Point X -----------------------------------------
                        //xxxxxx

                        if (m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].ref_GaugeTransType != 1)
                            m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].ref_GaugeTransType = 1;     // Black to white

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].SetGaugePlacement(fLimitCenterX,
                                                          fLimitCenterY + (m_stcBlobLead.fHeight / 2),
                                                          fHeight * (m_fPointGaugeToleranceRate * m), 90);

                            m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].Measure(objROI);
                            if (m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                            {
                                AddCenterPointGaugePlacementToArray(fLimitCenterX,
                                                          fLimitCenterY + (m_stcBlobLead.fHeight / 2),
                                                          fHeight * (m_fPointGaugeToleranceRate * m), 90, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                AddCenterPointGaugePlacementToArray(fLimitCenterX,
                                                          fLimitCenterY + (m_stcBlobLead.fHeight / 2),
                                                          fHeight * (m_fPointGaugeToleranceRate * m), 90, i);
                            }
                        }


                        if (m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                        {
                            m_stcBlobLead.fBaseCenterX = m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointX(0);
                            m_stcBlobLead.fBaseCenterY = m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointY(0);
                            m_stcBlobLead.blnBaseCenterFound = true;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(m_stcBlobLead.fBaseCenterX, m_stcBlobLead.fBaseCenterY));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            m_stcBlobLead.fBaseCenterX = fLimitCenterX;
                            m_stcBlobLead.fBaseCenterY = fLimitCenterY + (m_stcBlobLead.fHeight / 2);
                            m_stcBlobLead.blnBaseCenterFound = false;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(m_stcBlobLead.fBaseCenterX, m_stcBlobLead.fBaseCenterY));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Base start point -----------------------------------------
                        float fTopFixPointY = m_stcBlobLead.fBaseCenterY - m_intBaseOffset;

                        if (m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].ref_GaugeTransType != 1)
                            m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].ref_GaugeTransType = 1;     // Black to white

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].SetGaugePlacement(m_stcBlobLead.fBaseCenterX - fWidth / 2,
                                                          fTopFixPointY,
                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180);


                            m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].Measure(objROI);
                            if (m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                            {
                                SetCenterPointGaugePlacementToArray(m_stcBlobLead.fBaseCenterX - fWidth / 2,
                                                         fTopFixPointY,
                                                        fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.BaseStart, i);

                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetCenterPointGaugePlacementToArray(m_stcBlobLead.fBaseCenterX - fWidth / 2,
                                                         fTopFixPointY,
                                                        fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.BaseStart, i);

                            }
                        }


                        PointF pTopStart;
                        if (m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                        {
                            pTopStart = m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].GetMeasurePoint(0);
                            m_stcBlobLead.blnBaseStartFound = true;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pTopStart.X, pTopStart.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pTopStart = new PointF(m_stcBlobLead.fBaseCenterX - fWidth / 2, fTopFixPointY);
                            m_stcBlobLead.blnBaseStartFound = false;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pTopStart.X, pTopStart.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Base end point -----------------------------------------

                        if (m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].ref_GaugeTransType != 1)
                            m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].ref_GaugeTransType = 1;     // Black to white

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].SetGaugePlacement(m_stcBlobLead.fBaseCenterX + fWidth / 2,
                                                        fTopFixPointY,
                                                       fWidth * (m_fPointGaugeToleranceRate * m), 0);

                            m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].Measure(objROI);
                            if (m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                            {
                                SetCenterPointGaugePlacementToArray(m_stcBlobLead.fBaseCenterX + fWidth / 2,
                                                        fTopFixPointY,
                                                       fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.BaseEnd, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetCenterPointGaugePlacementToArray(m_stcBlobLead.fBaseCenterX + fWidth / 2,
                                                        fTopFixPointY,
                                                       fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.BaseEnd, i);
                            }
                        }


                        PointF pTopEnd;
                        if (m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                        {
                            pTopEnd = m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].GetMeasurePoint(0);
                            m_stcBlobLead.blnBaseEndFound = true;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pTopEnd.X, pTopEnd.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pTopEnd = new PointF(m_stcBlobLead.fBaseCenterX + fWidth / 2, fTopFixPointY);
                            m_stcBlobLead.blnBaseEndFound = false;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pTopEnd.X, pTopEnd.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        }

                        // Calculate the Base width and center X
                        m_stcBlobLead.fBaseWidth = pTopEnd.X - pTopStart.X;
                        m_stcBlobLead.fBaseCenterX = (pTopEnd.X + pTopStart.X) / 2 - objROI.ref_ROITotalX;
                        m_stcBlobLead.fBaseCenterY -= objROI.ref_ROITotalY;

                        //Tip
                        intTipCenterAngle = -90;
                        intTipStartAngle = 180;
                        intTipEndAngle = 0;
                        fLimitCenterX = objROI.ref_ROITotalX + m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = objROI.ref_ROITotalY + m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        // ------- Find Tip Point X -----------------------------------------

                        if (m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].ref_GaugeTransType != 1)
                            m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].ref_GaugeTransType = 1;     // Black to white

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].SetGaugePlacement(fLimitCenterX,
                                                           fLimitCenterY - (m_stcBlobLead.fHeight / 2),
                                                           fHeight * (m_fPointGaugeToleranceRate * m), -90);

                            m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].Measure(objROI);
                            if (m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                            {
                                SetCenterPointGaugePlacementToArray(fLimitCenterX,
                                                          fLimitCenterY - (m_stcBlobLead.fHeight / 2),
                                                          fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.TipCenter, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetCenterPointGaugePlacementToArray(fLimitCenterX,
                                                           fLimitCenterY - (m_stcBlobLead.fHeight / 2),
                                                           fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.TipCenter, i);
                            }
                        }


                        if (m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                        {
                            m_stcBlobLead.fTipCenterX = m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].GetMeasurePointX(0);
                            m_stcBlobLead.fTipCenterY = m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].GetMeasurePointY(0);
                            m_stcBlobLead.blnTipCenterFound = true;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            m_stcBlobLead.fTipCenterX = fLimitCenterX;
                            m_stcBlobLead.fTipCenterY = fLimitCenterY - (m_stcBlobLead.fHeight / 2);
                            m_stcBlobLead.blnTipCenterFound = false;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Tip start point -----------------------------------------
                        fTopFixPointY = m_stcBlobLead.fTipCenterY + m_intTipOffset;

                        if (m_arrCenterPointGauge[i][(int)PointIndex.TipStart].ref_GaugeTransType != 1)
                            m_arrCenterPointGauge[i][(int)PointIndex.TipStart].ref_GaugeTransType = 1;     // Black to white

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrCenterPointGauge[i][(int)PointIndex.TipStart].SetGaugePlacement(m_stcBlobLead.fTipCenterX - fWidth / 2,
                                                          fTopFixPointY,
                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180);

                            m_arrCenterPointGauge[i][(int)PointIndex.TipStart].Measure(objROI);
                            if (m_arrCenterPointGauge[i][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                            {
                                SetCenterPointGaugePlacementToArray(m_stcBlobLead.fTipCenterX - fWidth / 2,
                                                          fTopFixPointY,
                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.TipStart, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetCenterPointGaugePlacementToArray(m_stcBlobLead.fTipCenterX - fWidth / 2,
                                                           fTopFixPointY,
                                                          fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.TipStart, i);
                            }
                        }

                        if (m_arrCenterPointGauge[i][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                        {
                            pTopStart = m_arrCenterPointGauge[i][(int)PointIndex.TipStart].GetMeasurePoint(0);
                            m_stcBlobLead.blnTipStartFound = true;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pTopStart.X, pTopStart.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pTopStart = new PointF(m_stcBlobLead.fTipCenterX - fWidth / 2, fTopFixPointY);
                            m_stcBlobLead.blnTipStartFound = false;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pTopStart.X, pTopStart.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Tip end point -----------------------------------------

                        if (m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].ref_GaugeTransType != 1)
                            m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].ref_GaugeTransType = 1;     // Black to white

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].SetGaugePlacement(m_stcBlobLead.fTipCenterX + fWidth / 2,
                                                        fTopFixPointY,
                                                       fWidth * (m_fPointGaugeToleranceRate * m), 0);

                            m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].Measure(objROI);
                            if (m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                            {
                                SetCenterPointGaugePlacementToArray(m_stcBlobLead.fTipCenterX + fWidth / 2,
                                                        fTopFixPointY,
                                                       fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.TipEnd, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetCenterPointGaugePlacementToArray(m_stcBlobLead.fTipCenterX + fWidth / 2,
                                                        fTopFixPointY,
                                                       fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.TipEnd, i);
                            }
                        }

                        if (m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                        {
                            pTopEnd = m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].GetMeasurePoint(0);
                            m_stcBlobLead.blnTipEndFound = true;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pTopEnd.X, pTopEnd.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pTopEnd = new PointF(m_stcBlobLead.fTipCenterX + fWidth / 2, fTopFixPointY);
                            m_stcBlobLead.blnTipEndFound = false;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pTopEnd.X, pTopEnd.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        }

                        // Calculate the Tip width and center X
                        m_stcBlobLead.fTipWidth = pTopEnd.X - pTopStart.X;
                        m_stcBlobLead.fTipCenterX = (pTopEnd.X + pTopStart.X) / 2 - objROI.ref_ROITotalX;
                        m_stcBlobLead.fTipCenterY -= objROI.ref_ROITotalY;

                        // Base and Tip Length
                        m_stcBlobLead.fBaseLength = m_stcBlobLead.fBaseCenterY - m_stcBlobLead.fTipCenterY;
                        m_stcBlobLead.fTipLength = m_stcBlobLead.fBaseCenterY - m_stcBlobLead.fTipCenterY;
                        break;
                    //Right
                    case 2:
                        //Base
                        intBaseCenterAngle = 180;
                        intBaseStartAngle = -90;
                        intBaseEndAngle = 90;
                        fLimitCenterX = objROI.ref_ROITotalX + m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = objROI.ref_ROITotalY + m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        // ------- Find Base Point Y -----------------------------------------

                        if (m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].ref_GaugeTransType != 1)
                            m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].ref_GaugeTransType = 1;     // Black to white

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].SetGaugePlacement(fLimitCenterX - (m_stcBlobLead.fWidth / 2),
                                                          fLimitCenterY,
                                                          fWidth * (m_fPointGaugeToleranceRate * m), 180);

                            m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].Measure(objROI);
                            if (m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                            {
                                AddCenterPointGaugePlacementToArray(fLimitCenterX - (m_stcBlobLead.fWidth / 2),
                                                          fLimitCenterY,
                                                          fWidth * (m_fPointGaugeToleranceRate * m), 180, i);

                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                AddCenterPointGaugePlacementToArray(fLimitCenterX - (m_stcBlobLead.fWidth / 2),
                                                          fLimitCenterY,
                                                          fWidth * (m_fPointGaugeToleranceRate * m), 180, i);
                            }
                        }

                        if (m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                        {
                            m_stcBlobLead.fBaseCenterX = m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointX(0);
                            m_stcBlobLead.fBaseCenterY = m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointY(0);
                            m_stcBlobLead.blnBaseCenterFound = true;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(m_stcBlobLead.fBaseCenterX, m_stcBlobLead.fBaseCenterY));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            m_stcBlobLead.fBaseCenterX = fLimitCenterX - (m_stcBlobLead.fWidth / 2);
                            m_stcBlobLead.fBaseCenterY = fLimitCenterY;
                            m_stcBlobLead.blnBaseCenterFound = false;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(m_stcBlobLead.fBaseCenterX, m_stcBlobLead.fBaseCenterY));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Base start point -----------------------------------------
                        float fRightFixPointX = m_stcBlobLead.fBaseCenterX + m_intBaseOffset;

                        if (m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].ref_GaugeTransType != 1)
                            m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].ref_GaugeTransType = 1;     // Black to white

                        m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].Measure(objROI);

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].SetGaugePlacement(fRightFixPointX,
                                                           m_stcBlobLead.fBaseCenterY - fHeight / 2,
                                                          fHeight * (m_fPointGaugeToleranceRate * m), -90);

                            m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].Measure(objROI);
                            if (m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                            {
                                SetCenterPointGaugePlacementToArray(fRightFixPointX,
                                                         m_stcBlobLead.fBaseCenterY - fHeight / 2,
                                                        fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.BaseStart, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetCenterPointGaugePlacementToArray(fRightFixPointX,
                                                         m_stcBlobLead.fBaseCenterY - fHeight / 2,
                                                        fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.BaseStart, i);
                            }
                        }

                        PointF pRightStart;
                        if (m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                        {
                            pRightStart = m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].GetMeasurePoint(0);
                            m_stcBlobLead.blnBaseStartFound = true;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pRightStart.X, pRightStart.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pRightStart = new PointF(fRightFixPointX, m_stcBlobLead.fBaseCenterY - fHeight / 2);
                            m_stcBlobLead.blnBaseStartFound = false;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pRightStart.X, pRightStart.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Base end point -----------------------------------------

                        if (m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].ref_GaugeTransType != 1)
                            m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].ref_GaugeTransType = 1;     // Black to white

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].SetGaugePlacement(fRightFixPointX,
                                                        m_stcBlobLead.fBaseCenterY + fHeight / 2,
                                                       fHeight * (m_fPointGaugeToleranceRate * m), 90);

                            m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].Measure(objROI);
                            if (m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                            {
                                SetCenterPointGaugePlacementToArray(fRightFixPointX,
                                                        m_stcBlobLead.fBaseCenterY + fHeight / 2,
                                                       fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.BaseEnd, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetCenterPointGaugePlacementToArray(fRightFixPointX,
                                                        m_stcBlobLead.fBaseCenterY + fHeight / 2,
                                                       fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.BaseEnd, i);
                            }
                        }


                        PointF pRightEnd;
                        if (m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                        {
                            pRightEnd = m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].GetMeasurePoint(0);
                            m_stcBlobLead.blnBaseEndFound = true;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pRightEnd.X, pRightEnd.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pRightEnd = new PointF(fRightFixPointX, m_stcBlobLead.fBaseCenterY + fHeight / 2);
                            m_stcBlobLead.blnBaseEndFound = false;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pRightEnd.X, pRightEnd.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        }

                        // Calculate the Base width and center Y
                        m_stcBlobLead.fBaseWidth = pRightEnd.Y - pRightStart.Y;
                        m_stcBlobLead.fBaseCenterY = (pRightEnd.Y + pRightStart.Y) / 2 - objROI.ref_ROITotalY;
                        m_stcBlobLead.fBaseCenterX -= objROI.ref_ROITotalX;

                        //Tip
                        intTipCenterAngle = 0;
                        intTipStartAngle = -90;
                        intTipEndAngle = 90;
                        fLimitCenterX = objROI.ref_ROITotalX + m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = objROI.ref_ROITotalY + m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        // ------- Find Tip Point X -----------------------------------------

                        if (m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].ref_GaugeTransType != 1)
                            m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].ref_GaugeTransType = 1;     // Black to white

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].SetGaugePlacement(fLimitCenterX + (m_stcBlobLead.fWidth / 2),
                                                                            fLimitCenterY,
                                                                            fWidth * (m_fPointGaugeToleranceRate * m), 0);
                            m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].Measure(objROI);
                            if (m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                            {
                                SetCenterPointGaugePlacementToArray(fLimitCenterX + (m_stcBlobLead.fWidth / 2),
                                                        fLimitCenterY,
                                                        fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.TipCenter, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetCenterPointGaugePlacementToArray(fLimitCenterX + (m_stcBlobLead.fWidth / 2),
                                                       fLimitCenterY,
                                                       fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.TipCenter, i);
                            }
                        }

                        if (m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                        {
                            m_stcBlobLead.fTipCenterX = m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].GetMeasurePointX(0);
                            m_stcBlobLead.fTipCenterY = m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].GetMeasurePointY(0);
                            m_stcBlobLead.blnTipCenterFound = true;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            m_stcBlobLead.fTipCenterX = fLimitCenterX + (m_stcBlobLead.fWidth / 2);
                            m_stcBlobLead.fTipCenterY = fLimitCenterY;
                            m_stcBlobLead.blnTipCenterFound = false;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Tip start point -----------------------------------------
                        fRightFixPointX = m_stcBlobLead.fTipCenterX - m_intTipOffset;

                        if (m_arrCenterPointGauge[i][(int)PointIndex.TipStart].ref_GaugeTransType != 1)
                            m_arrCenterPointGauge[i][(int)PointIndex.TipStart].ref_GaugeTransType = 1;     // Black to white

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrCenterPointGauge[i][(int)PointIndex.TipStart].SetGaugePlacement(fRightFixPointX,
                                                          m_stcBlobLead.fTipCenterY - (m_stcBlobLead.fHeight / 2),
                                                         fHeight * (m_fPointGaugeToleranceRate * m), -90);

                            m_arrCenterPointGauge[i][(int)PointIndex.TipStart].Measure(objROI);
                            if (m_arrCenterPointGauge[i][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                            {

                                SetCenterPointGaugePlacementToArray(fRightFixPointX,
                                                                  m_stcBlobLead.fTipCenterY - (m_stcBlobLead.fHeight / 2),
                                                                fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.TipStart, i);
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetCenterPointGaugePlacementToArray(fRightFixPointX,
                                                             m_stcBlobLead.fTipCenterY - (m_stcBlobLead.fHeight / 2),
                                                            fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.TipStart, i);
                            }
                        }

                        if (m_arrCenterPointGauge[i][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                        {
                            pRightStart = m_arrCenterPointGauge[i][(int)PointIndex.TipStart].GetMeasurePoint(0);
                            m_stcBlobLead.blnTipStartFound = true;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pRightStart.X, pRightStart.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pRightStart = new PointF(fRightFixPointX, m_stcBlobLead.fTipCenterY - (m_stcBlobLead.fHeight / 2));
                            m_stcBlobLead.blnTipStartFound = false;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pRightStart.X, pRightStart.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Tip end point -----------------------------------------

                        if (m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].ref_GaugeTransType != 1)
                            m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].ref_GaugeTransType = 1;     // Black to white

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].SetGaugePlacement(fRightFixPointX,
                                                              m_stcBlobLead.fTipCenterY + (m_stcBlobLead.fHeight / 2),
                                                             fHeight * (m_fPointGaugeToleranceRate * m), 90);

                            m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].Measure(objROI);
                            if (m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                            {
                                SetCenterPointGaugePlacementToArray(fRightFixPointX,
                                                              m_stcBlobLead.fTipCenterY + (m_stcBlobLead.fHeight / 2),
                                                             fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.TipEnd, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetCenterPointGaugePlacementToArray(fRightFixPointX,
                                                              m_stcBlobLead.fTipCenterY + (m_stcBlobLead.fHeight / 2),
                                                             fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.TipEnd, i);
                            }
                        }

                        if (m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                        {
                            pRightEnd = m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].GetMeasurePoint(0);
                            m_stcBlobLead.blnTipEndFound = true;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pRightEnd.X, pRightEnd.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pRightEnd = new PointF(fRightFixPointX, m_stcBlobLead.fTipCenterY + (m_stcBlobLead.fHeight / 2));
                            m_stcBlobLead.blnTipEndFound = false;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pRightEnd.X, pRightEnd.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        }

                        // Calculate the Tip width and center Y
                        m_stcBlobLead.fTipWidth = pRightEnd.Y - pRightStart.Y;
                        m_stcBlobLead.fTipCenterY = (pRightEnd.Y + pRightStart.Y) / 2 - objROI.ref_ROITotalY;
                        m_stcBlobLead.fTipCenterX -= objROI.ref_ROITotalX;

                        // Base and Tip Length
                        m_stcBlobLead.fBaseLength = m_stcBlobLead.fTipCenterX - m_stcBlobLead.fBaseCenterX;
                        m_stcBlobLead.fTipLength = m_stcBlobLead.fTipCenterX - m_stcBlobLead.fBaseCenterX;
                        break;
                    //Bottom
                    case 8:
                        //Base
                        intBaseCenterAngle = -90;
                        intBaseStartAngle = 180;
                        intBaseEndAngle = 0;
                        fLimitCenterX = objROI.ref_ROITotalX + m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = objROI.ref_ROITotalY + m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        // ------- Find Base Point X -----------------------------------------

                        if (m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].ref_GaugeTransType != 1)
                            m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].ref_GaugeTransType = 1;     // Black to white

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].SetGaugePlacement(fLimitCenterX,
                                                          fLimitCenterY - (m_stcBlobLead.fHeight / 2),
                                                          fHeight * (m_fPointGaugeToleranceRate * m), -90);

                            m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].Measure(objROI);
                            if (m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                            {
                                AddCenterPointGaugePlacementToArray(fLimitCenterX,
                                                           fLimitCenterY - (m_stcBlobLead.fHeight / 2),
                                                           fHeight * (m_fPointGaugeToleranceRate * m), -90, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                AddCenterPointGaugePlacementToArray(fLimitCenterX,
                                                          fLimitCenterY - (m_stcBlobLead.fHeight / 2),
                                                          fHeight * (m_fPointGaugeToleranceRate * m), -90, i);
                            }
                        }


                        if (m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                        {
                            m_stcBlobLead.fBaseCenterX = m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointX(0);
                            m_stcBlobLead.fBaseCenterY = m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointY(0);
                            m_stcBlobLead.blnBaseCenterFound = true;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(m_stcBlobLead.fBaseCenterX, m_stcBlobLead.fBaseCenterY));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            m_stcBlobLead.fBaseCenterX = fLimitCenterX;
                            m_stcBlobLead.fBaseCenterY = fLimitCenterY - (m_stcBlobLead.fHeight / 2);
                            m_stcBlobLead.blnBaseCenterFound = false;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(m_stcBlobLead.fBaseCenterX, m_stcBlobLead.fBaseCenterY));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Base start point -----------------------------------------
                        float fBottomFixPointY = m_stcBlobLead.fBaseCenterY + m_intBaseOffset;

                        if (m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].ref_GaugeTransType != 1)
                            m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].ref_GaugeTransType = 1;     // Black to white

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].SetGaugePlacement(m_stcBlobLead.fBaseCenterX - fWidth / 2,
                                                          fBottomFixPointY,
                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180);

                            m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].Measure(objROI);
                            if (m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                            {
                                SetCenterPointGaugePlacementToArray(m_stcBlobLead.fBaseCenterX - fWidth / 2,
                                                          fBottomFixPointY,
                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.BaseStart, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetCenterPointGaugePlacementToArray(m_stcBlobLead.fBaseCenterX - fWidth / 2,
                                                          fBottomFixPointY,
                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.BaseStart, i);
                            }
                        }

                        PointF pBottomStart;
                        if (m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                        {
                            pBottomStart = m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].GetMeasurePoint(0);
                            m_stcBlobLead.blnBaseStartFound = true;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pBottomStart.X, pBottomStart.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pBottomStart = new PointF(m_stcBlobLead.fBaseCenterX - fWidth / 2, fBottomFixPointY);
                            m_stcBlobLead.blnBaseStartFound = false;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pBottomStart.X, pBottomStart.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Base end point -----------------------------------------

                        if (m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].ref_GaugeTransType != 1)
                            m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].ref_GaugeTransType = 1;     // Black to white

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].SetGaugePlacement(m_stcBlobLead.fBaseCenterX + fWidth / 2,
                                                        fBottomFixPointY,
                                                       fWidth * (m_fPointGaugeToleranceRate * m), 0);

                            m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].Measure(objROI);
                            if (m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                            {
                                SetCenterPointGaugePlacementToArray(m_stcBlobLead.fBaseCenterX + fWidth / 2,
                                                        fBottomFixPointY,
                                                       fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.BaseEnd, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetCenterPointGaugePlacementToArray(m_stcBlobLead.fBaseCenterX + fWidth / 2,
                                                        fBottomFixPointY,
                                                       fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.BaseEnd, i);
                            }
                        }

                        PointF pBottomEnd;
                        if (m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                        {
                            pBottomEnd = m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].GetMeasurePoint(0);
                            m_stcBlobLead.blnBaseEndFound = true;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pBottomEnd.X, pBottomEnd.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pBottomEnd = new PointF(m_stcBlobLead.fBaseCenterX + fWidth / 2, fBottomFixPointY);
                            m_stcBlobLead.blnBaseEndFound = false;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pBottomEnd.X, pBottomEnd.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        }

                        // Calculate the Base width and center X
                        m_stcBlobLead.fBaseWidth = pBottomEnd.X - pBottomStart.X;
                        m_stcBlobLead.fBaseCenterX = (pBottomEnd.X + pBottomStart.X) / 2 - objROI.ref_ROITotalX;
                        m_stcBlobLead.fBaseCenterY -= objROI.ref_ROITotalY;

                        //Tip
                        intTipCenterAngle = 90;
                        intTipStartAngle = 180;
                        intTipEndAngle = 0;
                        fLimitCenterX = objROI.ref_ROITotalX + m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = objROI.ref_ROITotalY + m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        // ------- Find Tip Point X -----------------------------------------

                        if (m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].ref_GaugeTransType != 1)
                            m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].ref_GaugeTransType = 1;     // Black to white

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].SetGaugePlacement(fLimitCenterX,
                                                         fLimitCenterY + (m_stcBlobLead.fHeight / 2),
                                                         fHeight * (m_fPointGaugeToleranceRate * m), 90);

                            m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].Measure(objROI);
                            if (m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                            {
                                SetCenterPointGaugePlacementToArray(fLimitCenterX,
                                                          fLimitCenterY + (m_stcBlobLead.fHeight / 2),
                                                          fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.TipCenter, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetCenterPointGaugePlacementToArray(fLimitCenterX,
                                                          fLimitCenterY + (m_stcBlobLead.fHeight / 2),
                                                          fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.TipCenter, i);
                            }
                        }

                        if (m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                        {
                            m_stcBlobLead.fTipCenterX = m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].GetMeasurePointX(0);
                            m_stcBlobLead.fTipCenterY = m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].GetMeasurePointY(0);
                            m_stcBlobLead.blnTipCenterFound = true;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            m_stcBlobLead.fTipCenterX = fLimitCenterX;
                            m_stcBlobLead.fTipCenterY = fLimitCenterY + (m_stcBlobLead.fHeight / 2);
                            m_stcBlobLead.blnTipCenterFound = false;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Tip start point -----------------------------------------
                        fBottomFixPointY = m_stcBlobLead.fTipCenterY - m_intTipOffset;

                        if (m_arrCenterPointGauge[i][(int)PointIndex.TipStart].ref_GaugeTransType != 1)
                            m_arrCenterPointGauge[i][(int)PointIndex.TipStart].ref_GaugeTransType = 1;     // Black to white

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrCenterPointGauge[i][(int)PointIndex.TipStart].SetGaugePlacement(m_stcBlobLead.fTipCenterX - fWidth / 2,
                                                          fBottomFixPointY,
                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180);

                            m_arrCenterPointGauge[i][(int)PointIndex.TipStart].Measure(objROI);
                            if (m_arrCenterPointGauge[i][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                            {
                                SetCenterPointGaugePlacementToArray(m_stcBlobLead.fTipCenterX - fWidth / 2,
                                                          fBottomFixPointY,
                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.TipStart, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetCenterPointGaugePlacementToArray(m_stcBlobLead.fTipCenterX - fWidth / 2,
                                                          fBottomFixPointY,
                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.TipStart, i);
                            }
                        }


                        if (m_arrCenterPointGauge[i][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                        {
                            pBottomStart = m_arrCenterPointGauge[i][(int)PointIndex.TipStart].GetMeasurePoint(0);
                            m_stcBlobLead.blnTipStartFound = true;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pBottomStart.X, pBottomStart.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pBottomStart = new PointF(m_stcBlobLead.fTipCenterX - fWidth / 2, fBottomFixPointY);
                            m_stcBlobLead.blnTipStartFound = false;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pBottomStart.X, pBottomStart.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Tip end point -----------------------------------------

                        if (m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].ref_GaugeTransType != 1)
                            m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].ref_GaugeTransType = 1;     // Black to white

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].SetGaugePlacement(m_stcBlobLead.fTipCenterX + fWidth / 2,
                                                       fBottomFixPointY,
                                                      fWidth * (m_fPointGaugeToleranceRate * m), 0);

                            m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].Measure(objROI);
                            if (m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                            {
                                SetCenterPointGaugePlacementToArray(m_stcBlobLead.fTipCenterX + fWidth / 2,
                                                        fBottomFixPointY,
                                                       fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.TipEnd, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetCenterPointGaugePlacementToArray(m_stcBlobLead.fTipCenterX + fWidth / 2,
                                                        fBottomFixPointY,
                                                       fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.TipEnd, i);
                            }
                        }


                        if (m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                        {
                            pBottomEnd = m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].GetMeasurePoint(0);
                            m_stcBlobLead.blnTipEndFound = true;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pBottomEnd.X, pBottomEnd.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pBottomEnd = new PointF(m_stcBlobLead.fTipCenterX + fWidth / 2, fBottomFixPointY);
                            m_stcBlobLead.blnTipEndFound = false;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pBottomEnd.X, pBottomEnd.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        }

                        // Calculate the Tip width and center X
                        m_stcBlobLead.fTipWidth = pBottomEnd.X - pBottomStart.X;
                        m_stcBlobLead.fTipCenterX = (pBottomEnd.X + pBottomStart.X) / 2 - objROI.ref_ROITotalX;
                        m_stcBlobLead.fTipCenterY -= objROI.ref_ROITotalY;

                        // Base and Tip Length
                        m_stcBlobLead.fBaseLength = m_stcBlobLead.fTipCenterY - m_stcBlobLead.fBaseCenterY;
                        m_stcBlobLead.fTipLength = m_stcBlobLead.fTipCenterY - m_stcBlobLead.fBaseCenterY;
                        break;
                    //Left
                    case 1:
                        //Base
                        intBaseCenterAngle = 0;
                        intBaseStartAngle = -90;
                        intBaseEndAngle = 90;
                        fLimitCenterX = objROI.ref_ROITotalX + m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = objROI.ref_ROITotalY + m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        // ------- Find Base Point Y -----------------------------------------

                        if (m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].ref_GaugeTransType != 1)
                            m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].ref_GaugeTransType = 1;     // Black to white

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].SetGaugePlacement(fLimitCenterX + (m_stcBlobLead.fWidth / 2),
                                                          fLimitCenterY,
                                                          fWidth * (m_fPointGaugeToleranceRate * m), 0);
                            m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].Measure(objROI);
                            if (m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                            {
                                AddCenterPointGaugePlacementToArray(fLimitCenterX + (m_stcBlobLead.fWidth / 2),
                                                          fLimitCenterY,
                                                          fWidth * (m_fPointGaugeToleranceRate * m), 0, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                AddCenterPointGaugePlacementToArray(fLimitCenterX + (m_stcBlobLead.fWidth / 2),
                                                          fLimitCenterY,
                                                          fWidth * (m_fPointGaugeToleranceRate * m), 0, i);
                            }
                        }

                        if (m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                        {
                            m_stcBlobLead.fBaseCenterX = m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointX(0);
                            m_stcBlobLead.fBaseCenterY = m_arrCenterPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointY(0);
                            m_stcBlobLead.blnBaseCenterFound = true;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(m_stcBlobLead.fBaseCenterX, m_stcBlobLead.fBaseCenterY));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            m_stcBlobLead.fBaseCenterX = fLimitCenterX + (m_stcBlobLead.fWidth / 2);
                            m_stcBlobLead.fBaseCenterY = fLimitCenterY;
                            m_stcBlobLead.blnBaseCenterFound = false;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(m_stcBlobLead.fBaseCenterX, m_stcBlobLead.fBaseCenterY));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Base start point -----------------------------------------
                        float fLeftFixPointX = m_stcBlobLead.fBaseCenterX - m_intBaseOffset;

                        if (m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].ref_GaugeTransType != 1)
                            m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].ref_GaugeTransType = 1;     // Black to white

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].SetGaugePlacement(fLeftFixPointX,
                                                          m_stcBlobLead.fBaseCenterY - fHeight / 2,
                                                         fHeight * (m_fPointGaugeToleranceRate * m), -90);

                            m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].Measure(objROI);
                            if (m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                            {
                                SetCenterPointGaugePlacementToArray(fLeftFixPointX,
                                  m_stcBlobLead.fBaseCenterY - fHeight / 2,
                                 fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.BaseStart, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetCenterPointGaugePlacementToArray(fLeftFixPointX,
                                  m_stcBlobLead.fBaseCenterY - fHeight / 2,
                                 fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.BaseStart, i);
                            }
                        }

                        PointF pLeftStart;
                        if (m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                        {
                            pLeftStart = m_arrCenterPointGauge[i][(int)PointIndex.BaseStart].GetMeasurePoint(0);
                            m_stcBlobLead.blnBaseStartFound = true;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pLeftStart.X, pLeftStart.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pLeftStart = new PointF(fLeftFixPointX, m_stcBlobLead.fBaseCenterY - fHeight / 2);
                            m_stcBlobLead.blnBaseStartFound = false;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pLeftStart.X, pLeftStart.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Base end point -----------------------------------------

                        if (m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].ref_GaugeTransType != 1)
                            m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].ref_GaugeTransType = 1;     // Black to white

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].SetGaugePlacement(fLeftFixPointX,
                                                        m_stcBlobLead.fBaseCenterY + fHeight / 2,
                                                       fHeight * (m_fPointGaugeToleranceRate * m), 90);

                            m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].Measure(objROI);
                            if (m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                            {
                                SetCenterPointGaugePlacementToArray(fLeftFixPointX,
                                                        m_stcBlobLead.fBaseCenterY + fHeight / 2,
                                                       fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.BaseEnd, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetCenterPointGaugePlacementToArray(fLeftFixPointX,
                                                        m_stcBlobLead.fBaseCenterY + fHeight / 2,
                                                       fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.BaseEnd, i);
                            }
                        }


                        PointF pLeftEnd;
                        if (m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                        {
                            pLeftEnd = m_arrCenterPointGauge[i][(int)PointIndex.BaseEnd].GetMeasurePoint(0);
                            m_stcBlobLead.blnBaseEndFound = true;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pLeftEnd.X, pLeftEnd.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pLeftEnd = new PointF(fLeftFixPointX, m_stcBlobLead.fBaseCenterY + fHeight / 2);
                            m_stcBlobLead.blnBaseEndFound = false;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pLeftEnd.X, pLeftEnd.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        }

                        // Calculate the Base width center Y
                        m_stcBlobLead.fBaseWidth = pLeftEnd.Y - pLeftStart.Y;
                        m_stcBlobLead.fBaseCenterY = (pLeftEnd.Y + pLeftStart.Y) / 2 - objROI.ref_ROITotalY;
                        m_stcBlobLead.fBaseCenterX -= objROI.ref_ROITotalX;

                        //Tip
                        intTipCenterAngle = 180;
                        intTipStartAngle = -90;
                        intTipEndAngle = 90;
                        fLimitCenterX = objROI.ref_ROITotalX + m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = objROI.ref_ROITotalY + m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        // ------- Find Tip Point X -----------------------------------------

                        if (m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].ref_GaugeTransType != 1)
                            m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].ref_GaugeTransType = 1;     // Black to white

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].SetGaugePlacement(fLimitCenterX - (m_stcBlobLead.fWidth / 2),
                                                        fLimitCenterY,
                                                        fWidth * (m_fPointGaugeToleranceRate * m), 180);

                            m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].Measure(objROI);
                            if (m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                            {
                                SetCenterPointGaugePlacementToArray(fLimitCenterX - (m_stcBlobLead.fWidth / 2),
                                                        fLimitCenterY,
                                                        fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.TipCenter, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetCenterPointGaugePlacementToArray(fLimitCenterX - (m_stcBlobLead.fWidth / 2),
                                                                            fLimitCenterY,
                                                                            fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.TipCenter, i);
                            }
                        }

                        if (m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                        {
                            m_stcBlobLead.fTipCenterX = m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].GetMeasurePointX(0);
                            m_stcBlobLead.fTipCenterY = m_arrCenterPointGauge[i][(int)PointIndex.TipCenter].GetMeasurePointY(0);
                            m_stcBlobLead.blnTipCenterFound = true;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            m_stcBlobLead.fTipCenterX = fLimitCenterX - (m_stcBlobLead.fWidth / 2);
                            m_stcBlobLead.fTipCenterY = fLimitCenterY;
                            m_stcBlobLead.blnTipCenterFound = false;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Tip start point -----------------------------------------
                        fLeftFixPointX = m_stcBlobLead.fTipCenterX + m_intTipOffset;

                        if (m_arrCenterPointGauge[i][(int)PointIndex.TipStart].ref_GaugeTransType != 1)
                            m_arrCenterPointGauge[i][(int)PointIndex.TipStart].ref_GaugeTransType = 1;     // Black to white

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrCenterPointGauge[i][(int)PointIndex.TipStart].SetGaugePlacement(fLeftFixPointX,
                                                          m_stcBlobLead.fTipCenterY - (m_stcBlobLead.fHeight / 2),
                                                         fHeight * (m_fPointGaugeToleranceRate * m), -90);

                            m_arrCenterPointGauge[i][(int)PointIndex.TipStart].Measure(objROI);
                            if (m_arrCenterPointGauge[i][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                            {
                                SetCenterPointGaugePlacementToArray(fLeftFixPointX,
                                                           m_stcBlobLead.fTipCenterY - (m_stcBlobLead.fHeight / 2),
                                                          fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.TipStart, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetCenterPointGaugePlacementToArray(fLeftFixPointX,
                                                           m_stcBlobLead.fTipCenterY - (m_stcBlobLead.fHeight / 2),
                                                          fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.TipStart, i);
                            }
                        }


                        if (m_arrCenterPointGauge[i][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                        {
                            pLeftStart = m_arrCenterPointGauge[i][(int)PointIndex.TipStart].GetMeasurePoint(0);
                            m_stcBlobLead.blnTipStartFound = true;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pLeftStart.X, pLeftStart.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pLeftStart = new PointF(fLeftFixPointX, m_stcBlobLead.fTipCenterY - (m_stcBlobLead.fHeight / 2));
                            m_stcBlobLead.blnTipStartFound = false;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pLeftStart.X, pLeftStart.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Tip end point -----------------------------------------

                        if (m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].ref_GaugeTransType != 1)
                            m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].ref_GaugeTransType = 1;     // Black to white

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].SetGaugePlacement(fLeftFixPointX,
                                                              m_stcBlobLead.fTipCenterY + (m_stcBlobLead.fHeight / 2),
                                                             fHeight * (m_fPointGaugeToleranceRate * m), 90);

                            m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].Measure(objROI);
                            if (m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                            {
                                SetCenterPointGaugePlacementToArray(fLeftFixPointX,
                                                              m_stcBlobLead.fTipCenterY + (m_stcBlobLead.fHeight / 2),
                                                             fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.TipEnd, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetCenterPointGaugePlacementToArray(fLeftFixPointX,
                                                              m_stcBlobLead.fTipCenterY + (m_stcBlobLead.fHeight / 2),
                                                             fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.TipEnd, i);
                            }
                        }

                        if (m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                        {
                            pLeftEnd = m_arrCenterPointGauge[i][(int)PointIndex.TipEnd].GetMeasurePoint(0);
                            m_stcBlobLead.blnTipEndFound = true;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pLeftEnd.X, pLeftEnd.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pLeftEnd = new PointF(fLeftFixPointX, m_stcBlobLead.fTipCenterY + (m_stcBlobLead.fHeight / 2));
                            m_stcBlobLead.blnTipEndFound = false;
                            m_arrLead3DEdgeCenterGaugePoints[i].Add(new PointF(pLeftEnd.X, pLeftEnd.Y));
                            m_arrLead3DEdgeCenterGaugePointsFound[i].Add(false);
                        }

                        // Calculate the Tip width and center Y
                        m_stcBlobLead.fTipWidth = pLeftEnd.Y - pLeftStart.Y;
                        m_stcBlobLead.fTipCenterY = (pLeftEnd.Y + pLeftStart.Y) / 2 - objROI.ref_ROITotalY;
                        m_stcBlobLead.fTipCenterX -= objROI.ref_ROITotalX;

                        // Base and Tip Length
                        m_stcBlobLead.fBaseLength = m_stcBlobLead.fBaseCenterX - m_stcBlobLead.fTipCenterX;
                        m_stcBlobLead.fTipLength = m_stcBlobLead.fBaseCenterX - m_stcBlobLead.fTipCenterX;
                        break;
                }

                m_arrTemplateBlobLeads.RemoveAt(i);
                m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
            }
        }
        public void DefineLeadBaseTipWidth_Lead3D(ROI objROI)
        {
            float fLimitCenterX;
            float fLimitCenterY;
            float fNewCenterX;
            float fNewCenterY;
            float fWidth;
            float fHeight;
            int intFixPointXY;

            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                switch (m_stcBlobLead.intDirection)
                {
                    //Top
                    case 4:
                        //Base
                        fLimitCenterX = m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterY + (m_stcBlobLead.fHeight / 2) - m_intBaseOffset, 0, MidpointRounding.AwayFromZero);

                        Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                                ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, true, true, intFixPointXY);

                        m_stcBlobLead.fBaseCenterX = fNewCenterX;
                        m_stcBlobLead.fBaseCenterY = fNewCenterY;
                        m_stcBlobLead.fBaseWidth = fWidth;
                        m_stcBlobLead.fBaseLength = fHeight;

                        //Tip
                        fLimitCenterX = m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterY - (m_stcBlobLead.fHeight / 2) + m_intTipOffset, 0, MidpointRounding.AwayFromZero);
                        Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                                ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, true, false, intFixPointXY);

                        m_stcBlobLead.fTipCenterX = fNewCenterX;
                        m_stcBlobLead.fTipCenterY = fNewCenterY;
                        m_stcBlobLead.fTipWidth = fWidth;
                        m_stcBlobLead.fTipLength = fHeight;
                        break;
                    //Right
                    case 2:
                        //Base
                        fLimitCenterX = m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterX - (m_stcBlobLead.fWidth / 2) + m_intBaseOffset, 0, MidpointRounding.AwayFromZero);
                        Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                                ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, false, false, intFixPointXY);

                        m_stcBlobLead.fBaseCenterX = fNewCenterX;
                        m_stcBlobLead.fBaseCenterY = fNewCenterY;
                        m_stcBlobLead.fBaseWidth = fWidth;
                        m_stcBlobLead.fBaseLength = fHeight;

                        //Tip
                        fLimitCenterX = m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterX + (m_stcBlobLead.fWidth / 2) - m_intTipOffset, 0, MidpointRounding.AwayFromZero);
                        Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                                ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, false, true, intFixPointXY);

                        m_stcBlobLead.fTipCenterX = fNewCenterX;
                        m_stcBlobLead.fTipCenterY = fNewCenterY;
                        m_stcBlobLead.fTipWidth = fWidth;
                        m_stcBlobLead.fTipLength = fHeight;
                        break;
                    //Bottom
                    case 8:
                        //Base
                        fLimitCenterX = m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterY - (m_stcBlobLead.fHeight / 2) + m_intBaseOffset, 0, MidpointRounding.AwayFromZero);
                        Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                                ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, true, false, intFixPointXY);

                        m_stcBlobLead.fBaseCenterX = fNewCenterX;
                        m_stcBlobLead.fBaseCenterY = fNewCenterY;
                        m_stcBlobLead.fBaseWidth = fWidth;
                        m_stcBlobLead.fBaseLength = fHeight;

                        //Tip
                        fLimitCenterX = m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterY + (m_stcBlobLead.fHeight / 2) - m_intTipOffset, 0, MidpointRounding.AwayFromZero);
                        Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                                ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, true, true, intFixPointXY);

                        m_stcBlobLead.fTipCenterX = fNewCenterX;
                        m_stcBlobLead.fTipCenterY = fNewCenterY;
                        m_stcBlobLead.fTipWidth = fWidth;
                        m_stcBlobLead.fTipLength = fHeight;
                        break;
                    //Left
                    case 1:
                        //Base
                        fLimitCenterX = m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;

                        intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterX + (m_stcBlobLead.fWidth / 2) - m_intBaseOffset, 0, MidpointRounding.AwayFromZero);
                        Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                                ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, false, true, intFixPointXY);

                        m_stcBlobLead.fBaseCenterX = fNewCenterX;
                        m_stcBlobLead.fBaseCenterY = fNewCenterY;
                        m_stcBlobLead.fBaseWidth = fWidth;
                        m_stcBlobLead.fBaseLength = fHeight;

                        //Tip
                        fLimitCenterX = m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterX - (m_stcBlobLead.fWidth / 2) + m_intTipOffset, 0, MidpointRounding.AwayFromZero);
                        Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                                ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, false, false, intFixPointXY);

                        m_stcBlobLead.fTipCenterX = fNewCenterX;
                        m_stcBlobLead.fTipCenterY = fNewCenterY;
                        m_stcBlobLead.fTipWidth = fWidth;
                        m_stcBlobLead.fTipLength = fHeight;
                        break;
                }

                m_arrTemplateBlobLeads.RemoveAt(i);
                m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
            }
        }

        public void DefineLeadTipWidth_SideLead3D(ROI objROI)
        {
            float fLimitCenterX;
            float fLimitCenterY;
            float fNewCenterX;
            float fNewCenterY;
            float fWidth;
            float fHeight;
            int intFixPointXY;

            for (int i = 0; i < m_intNumberOfLead; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                switch (m_stcBlobLead.intDirection)
                {
                    //Top
                    case 4:
                        //Base
                        fLimitCenterX = m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterY + (m_stcBlobLead.fHeight / 2) - m_intBaseOffset, 0, MidpointRounding.AwayFromZero);
                        Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                                ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, true, true, intFixPointXY);

                        m_stcBlobLead.fBaseCenterX = fNewCenterX;
                        m_stcBlobLead.fBaseCenterY = fNewCenterY;
                        m_stcBlobLead.fBaseWidth = fWidth;
                        m_stcBlobLead.fBaseLength = fHeight;

                        //Tip
                        fLimitCenterX = m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterY - (m_stcBlobLead.fHeight / 2) + m_intTipOffset, 0, MidpointRounding.AwayFromZero);
                        Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                                ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, true, false, intFixPointXY);

                        m_stcBlobLead.fTipCenterX = fNewCenterX;
                        m_stcBlobLead.fTipCenterY = fNewCenterY;
                        m_stcBlobLead.fTipWidth = fWidth;
                        m_stcBlobLead.fTipLength = fHeight;
                        break;
                    //Right
                    case 2:
                        //Base
                        fLimitCenterX = m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterX - (m_stcBlobLead.fWidth / 2) + m_intBaseOffset, 0, MidpointRounding.AwayFromZero);
                        Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                                ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, false, false, intFixPointXY);

                        m_stcBlobLead.fBaseCenterX = fNewCenterX;
                        m_stcBlobLead.fBaseCenterY = fNewCenterY;
                        m_stcBlobLead.fBaseWidth = fWidth;
                        m_stcBlobLead.fBaseLength = fHeight;

                        //Tip
                        fLimitCenterX = m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterX + (m_stcBlobLead.fWidth / 2) - m_intTipOffset, 0, MidpointRounding.AwayFromZero);
                        Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                                ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, false, true, intFixPointXY);

                        m_stcBlobLead.fTipCenterX = fNewCenterX;
                        m_stcBlobLead.fTipCenterY = fNewCenterY;
                        m_stcBlobLead.fTipWidth = fWidth;
                        m_stcBlobLead.fTipLength = fHeight;
                        break;
                    //Bottom
                    case 8:
                        //Base
                        fLimitCenterX = m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterY - (m_stcBlobLead.fHeight / 2) + m_intBaseOffset, 0, MidpointRounding.AwayFromZero);
                        Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                                ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, true, false, intFixPointXY);

                        m_stcBlobLead.fBaseCenterX = fNewCenterX;
                        m_stcBlobLead.fBaseCenterY = fNewCenterY;
                        m_stcBlobLead.fBaseWidth = fWidth;
                        m_stcBlobLead.fBaseLength = fHeight;

                        //Tip
                        fLimitCenterX = m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterY + (m_stcBlobLead.fHeight / 2) - m_intTipOffset, 0, MidpointRounding.AwayFromZero);
                        Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                                ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, true, true, intFixPointXY);

                        m_stcBlobLead.fTipCenterX = fNewCenterX;
                        m_stcBlobLead.fTipCenterY = fNewCenterY;
                        m_stcBlobLead.fTipWidth = fWidth;
                        m_stcBlobLead.fTipLength = fHeight;
                        break;
                    //Left
                    case 1:
                        //Base
                        fLimitCenterX = m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;

                        intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterX + (m_stcBlobLead.fWidth / 2) - m_intBaseOffset, 0, MidpointRounding.AwayFromZero);
                        Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                                ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, false, true, intFixPointXY);

                        m_stcBlobLead.fBaseCenterX = fNewCenterX;
                        m_stcBlobLead.fBaseCenterY = fNewCenterY;
                        m_stcBlobLead.fBaseWidth = fWidth;
                        m_stcBlobLead.fBaseLength = fHeight;

                        //Tip
                        fLimitCenterX = m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterX - (m_stcBlobLead.fWidth / 2) + m_intTipOffset, 0, MidpointRounding.AwayFromZero);
                        Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                                ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, false, false, intFixPointXY);

                        m_stcBlobLead.fTipCenterX = fNewCenterX;
                        m_stcBlobLead.fTipCenterY = fNewCenterY;
                        m_stcBlobLead.fTipWidth = fWidth;
                        m_stcBlobLead.fTipLength = fHeight;
                        break;
                }

                m_arrTemplateBlobLeads.RemoveAt(i);
                m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
            }
        }

        public void DefineLeadVariance(ROI objROI)
        {
            float fStartX, fStartY, fEndX, fEndY;
            float fMinLength = float.MaxValue;
            float fMaxLength = 0;

            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                //Top and bottom height=length
                if (m_stcBlobLead.intLengthMode == 1)
                {
                    fStartY = m_stcBlobLead.fLimitCenterY - m_stcBlobLead.fHeight / 2;
                    fEndY = m_stcBlobLead.fLimitCenterY + m_stcBlobLead.fHeight / 2;

                    if (fEndY - fStartY > fMaxLength)
                        fMaxLength = fEndY - fStartY;

                    if (fEndY - fStartY < fMinLength)
                        fMinLength = fEndY - fStartY;
                }
                else
                {
                    fStartX = m_stcBlobLead.fLimitCenterX - m_stcBlobLead.fWidth / 2;
                    fEndX = m_stcBlobLead.fLimitCenterX + m_stcBlobLead.fWidth / 2;

                    if (fEndX - fStartX > fMaxLength)
                        fMaxLength = fEndX - fStartX;

                    if (fEndX - fStartX < fMinLength)
                        fMinLength = fEndX - fStartX;
                }
            }

            //m_fLengthVariance = (float)Math.Round(fMaxLength - fMinLength, 3, MidpointRounding.AwayFromZero);
        }

        /// <summary>
        /// Build Lead range - start X, start Y, end X, end Y
        /// </summary>
        /// <param name="objROI"></param>
        public void BuildLeadRange(ROI objROI)
        {
            float fStartX, fStartY, fEndX, fEndY;
            fStartX = (float)objROI.ref_ROIWidth;
            fStartY = (float)objROI.ref_ROIHeight;
            fEndX = 0;
            fEndY = 0;

            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];


                if (m_stcBlobLead.fLimitCenterX - m_stcBlobLead.fWidth / 2 < fStartX)
                    fStartX = m_stcBlobLead.fLimitCenterX - m_stcBlobLead.fWidth / 2;

                if (m_stcBlobLead.fLimitCenterY - m_stcBlobLead.fHeight / 2 < fStartY)
                    fStartY = m_stcBlobLead.fLimitCenterY - m_stcBlobLead.fHeight / 2;

                if (m_stcBlobLead.fLimitCenterX + m_stcBlobLead.fWidth / 2 > fEndX)
                    fEndX = m_stcBlobLead.fLimitCenterX + m_stcBlobLead.fWidth / 2;

                if (m_stcBlobLead.fLimitCenterY + m_stcBlobLead.fHeight / 2 > fEndY)
                    fEndY = m_stcBlobLead.fLimitCenterY + m_stcBlobLead.fHeight / 2;
            }

            m_fLeadRangeStartX = fStartX;
            m_fLeadRangeStartY = fStartY;
            m_fLeadRangeEndX = fEndX;
            m_fLeadRangeEndY = fEndY;
        }

        public void BuildLeadDistance(ROI objROI)
        {
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                m_stcBlobLead.fLeftDistance = m_stcBlobLead.fLimitCenterX - m_fLeadRangeStartX;
                m_stcBlobLead.fRightDistance = m_fLeadRangeEndX - m_stcBlobLead.fLimitCenterX;
                m_stcBlobLead.fTopDistance = m_stcBlobLead.fLimitCenterY - m_fLeadRangeStartY;
                m_stcBlobLead.fBottomDistance = m_fLeadRangeEndY - m_stcBlobLead.fLimitCenterY;
                m_stcBlobLead.fXDistance = objROI.ref_ROITotalX + m_stcBlobLead.fTipCenterX - m_pCornerPoint_Center.X;
                m_stcBlobLead.fYDistance = objROI.ref_ROITotalY + m_stcBlobLead.fTipCenterY - m_pCornerPoint_Center.Y;
                // Keep this in case when the method use corner point to find unit center unstable, might need to use pattern match
                //m_stcBlobLead.fXDistance = m_stcBlobLead.fLimitCenterX - (float)objROI.ref_ROIWidth / 2;
                //m_stcBlobLead.fYDistance = m_stcBlobLead.fLimitCenterY - (float)objROI.ref_ROIHeight / 2;

                m_arrTemplateBlobLeads.RemoveAt(i);
                m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
            }
        }
        public void BuildLeadDistance_PatternMatch(ROI objROI)
        {
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                //m_stcBlobLead.fXDistance = objROI.ref_ROITotalX + m_stcBlobLead.fTipCenterX - m_pCornerPoint_Center.X;
                //m_stcBlobLead.fYDistance = objROI.ref_ROITotalY + m_stcBlobLead.fTipCenterY - m_pCornerPoint_Center.Y;
                m_stcBlobLead.fXDistance = objROI.ref_ROITotalX + m_stcBlobLead.fTipCenterX - GetUnitPRResultCenterX();
                m_stcBlobLead.fYDistance = objROI.ref_ROITotalY + m_stcBlobLead.fTipCenterY - GetUnitPRResultCenterY();
                // Keep this in case when the method use corner point to find unit center unstable, might need to use pattern match
                //m_stcBlobLead.fXDistance = m_stcBlobLead.fLimitCenterX - (float)objROI.ref_ROIWidth / 2;
                //m_stcBlobLead.fYDistance = m_stcBlobLead.fLimitCenterY - (float)objROI.ref_ROIHeight / 2;

                m_arrTemplateBlobLeads.RemoveAt(i);
                m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
            }
        }
        public void BuildLeadSweepReference(ROI objROI)
        {
            // --------- Leads Sweep --------------------------------
            if (m_intLeadDirection == 0)    // Horizontal
            {
                float fUnitCenterY, fLeadTotalY, fLeadAverageY, fLeadSweepVarianceLeftResult, fLeadSweepVarianceRightResult;

                // Left Leads Sweep
                fUnitCenterY = (float)(m_pCornerPoint_TopLeft.Y + m_pCornerPoint_BottomLeft.Y) / 2 - objROI.ref_ROITotalY;
                fLeadTotalY = 0;
                for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
                {
                    m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                    if (m_stcBlobLead.intDirection == 1)  // Border Left Direction
                    {
                        fLeadTotalY += m_stcBlobLead.fTipCenterY;
                    }
                }
                fLeadAverageY = fLeadTotalY / m_intNumberOfLead_Left;
                //2021-03-18 ZJYEOH : Cannot save in mm, bacause calibration value will not be the same if calibrate again
                fLeadSweepVarianceLeftResult = fUnitCenterY - fLeadAverageY;//Get2DYinMM(fUnitCenterY - fLeadAverageY)
                for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
                {
                    m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                    if (m_stcBlobLead.intDirection == 1)  // Border Left Direction
                    {
                        m_stcBlobLead.fSweepLeftReference = fLeadSweepVarianceLeftResult;

                        m_arrTemplateBlobLeads.RemoveAt(i);
                        m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
                    }
                }
                // Right Leads Sweep
                fUnitCenterY = (float)(m_pCornerPoint_TopRight.Y + m_pCornerPoint_BottomRight.Y) / 2 - objROI.ref_ROITotalY;
                fLeadTotalY = 0;
                for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
                {
                    m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                    if (m_stcBlobLead.intDirection == 2)  // Border Right Direction
                    {
                        fLeadTotalY += m_stcBlobLead.fTipCenterY;
                    }
                }
                fLeadAverageY = fLeadTotalY / m_intNumberOfLead_Right;
                //2021-03-18 ZJYEOH : Cannot save in mm, bacause calibration value will not be the same if calibrate again
                fLeadSweepVarianceRightResult = fUnitCenterY - fLeadAverageY;//Get2DYinMM(fUnitCenterY - fLeadAverageY)
                for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
                {
                    m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                    if (m_stcBlobLead.intDirection == 2)  // Border Right Direction
                    {
                        m_stcBlobLead.fSweepRightReference = fLeadSweepVarianceRightResult;

                        m_arrTemplateBlobLeads.RemoveAt(i);
                        m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
                    }
                }

            }
            else
            {
                float fUnitCenterX, fLeadTotalX, fLeadAverageX, fLeadSweepVarianceTopResult, fLeadSweepVarianceBottomResult;

                // Top Leads Sweep
                fUnitCenterX = (float)(m_pCornerPoint_TopLeft.X + m_pCornerPoint_TopRight.X) / 2;
                fLeadTotalX = 0;
                for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
                {
                    m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                    if (m_stcBlobLead.intDirection == 4)  // Border Top Direction
                    {
                        fLeadTotalX += m_stcBlobLead.fTipCenterX;
                    }
                }
                fLeadAverageX = fLeadTotalX / m_intNumberOfLead_Top;
                //2021-03-18 ZJYEOH : Cannot save in mm, bacause calibration value will not be the same if calibrate again
                fLeadSweepVarianceTopResult = fUnitCenterX - fLeadAverageX;//Get2DXinMM(fUnitCenterX - fLeadAverageX)
                for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
                {
                    m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                    if (m_stcBlobLead.intDirection == 4)  // Border Top Direction
                    {
                        m_stcBlobLead.fSweepTopReference = fLeadSweepVarianceTopResult;

                        m_arrTemplateBlobLeads.RemoveAt(i);
                        m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
                    }
                }

                // Bottom Leads Sweep
                fUnitCenterX = (float)(m_pCornerPoint_BottomLeft.X + m_pCornerPoint_BottomRight.X) / 2;
                fLeadTotalX = 0;
                for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
                {
                    m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                    if (m_stcBlobLead.intDirection == 8)  // Border Bottom Direction
                    {
                        fLeadTotalX += m_stcBlobLead.fTipCenterX;
                    }
                }
                fLeadAverageX = fLeadTotalX / m_intNumberOfLead_Bottom;
                //2021-03-18 ZJYEOH : Cannot save in mm, bacause calibration value will not be the same if calibrate again
                fLeadSweepVarianceBottomResult = fUnitCenterX - fLeadAverageX;//Get2DXinMM(fUnitCenterX - fLeadAverageX)
                for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
                {
                    m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                    if (m_stcBlobLead.intDirection == 8)  // Border Bottom Direction
                    {
                        m_stcBlobLead.fSweepBottomReference = fLeadSweepVarianceBottomResult;

                        m_arrTemplateBlobLeads.RemoveAt(i);
                        m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
                    }
                }

            }
        }
        private void BuildLeadReferencePoint(int intLeadPosition, ROI objROI)
        {
            m_fReferencePointStartX = objROI.ref_ROIWidth;
            m_fReferencePointStartY = objROI.ref_ROIHeight;
            m_fReferencePointEndX = 0;
            m_fReferencePointEndY = 0;

            switch (intLeadPosition)
            {
                case 1:
                    for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
                    {
                        m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                        if (m_stcBlobLead.fBaseCenterX - m_stcBlobLead.fBaseWidth / 2 < m_fReferencePointStartX)
                        {
                            m_fReferencePointStartX = m_stcBlobLead.fBaseCenterX - m_stcBlobLead.fBaseWidth / 2;
                            m_fReferencePointStartY = m_stcBlobLead.fLimitCenterY + m_stcBlobLead.fHeight / 2;
                        }

                        if (m_stcBlobLead.fBaseCenterX + m_stcBlobLead.fBaseWidth / 2 > m_fReferencePointEndX)
                        {
                            m_fReferencePointEndX = m_stcBlobLead.fBaseCenterX + m_stcBlobLead.fBaseWidth / 2;
                            m_fReferencePointEndY = m_stcBlobLead.fLimitCenterY + m_stcBlobLead.fHeight / 2;
                        }
                    }
                    break;
                case 2:
                    for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
                    {
                        m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                        if (m_stcBlobLead.fBaseCenterY - m_stcBlobLead.fBaseLength / 2 < m_fReferencePointStartY)
                        {
                            m_fReferencePointStartY = m_stcBlobLead.fBaseCenterY - m_stcBlobLead.fBaseLength / 2;
                            m_fReferencePointStartX = m_stcBlobLead.fLimitCenterX - m_stcBlobLead.fWidth / 2;
                        }

                        if (m_stcBlobLead.fBaseCenterY + m_stcBlobLead.fBaseLength / 2 > m_fReferencePointEndY)
                        {
                            m_fReferencePointEndY = m_stcBlobLead.fBaseCenterY + m_stcBlobLead.fBaseLength / 2;
                            m_fReferencePointEndX = m_stcBlobLead.fLimitCenterX - m_stcBlobLead.fWidth / 2;
                        }
                    }
                    break;
                case 3:
                    for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
                    {
                        m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                        if (m_stcBlobLead.fBaseCenterX - m_stcBlobLead.fBaseWidth / 2 < m_fReferencePointStartX)
                        {
                            m_fReferencePointStartX = m_stcBlobLead.fBaseCenterX - m_stcBlobLead.fBaseWidth / 2;
                            m_fReferencePointStartY = m_stcBlobLead.fLimitCenterY - m_stcBlobLead.fHeight / 2;
                        }

                        if (m_stcBlobLead.fBaseCenterX + m_stcBlobLead.fBaseWidth / 2 > m_fReferencePointEndX)
                        {
                            m_fReferencePointEndX = m_stcBlobLead.fBaseCenterX + m_stcBlobLead.fBaseWidth / 2;
                            m_fReferencePointEndY = m_stcBlobLead.fLimitCenterY - m_stcBlobLead.fHeight / 2;
                        }
                    }
                    break;
                case 4:
                    for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
                    {
                        m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                        if (m_stcBlobLead.fBaseCenterY - m_stcBlobLead.fBaseLength / 2 < m_fReferencePointStartY)
                        {
                            m_fReferencePointStartY = m_stcBlobLead.fBaseCenterY - m_stcBlobLead.fBaseLength / 2;
                            m_fReferencePointStartX = m_stcBlobLead.fLimitCenterX + m_stcBlobLead.fWidth / 2;
                        }

                        if (m_stcBlobLead.fBaseCenterY + m_stcBlobLead.fBaseLength / 2 > m_fReferencePointEndY)
                        {
                            m_fReferencePointEndY = m_stcBlobLead.fBaseCenterY + m_stcBlobLead.fBaseLength / 2;
                            m_fReferencePointEndX = m_stcBlobLead.fLimitCenterX + m_stcBlobLead.fWidth / 2;
                        }
                    }
                    break;
            }
        }

        private void BuildLeadReferencePoint_Lead3D(ROI objROI)
        {
            /*
             *          4
             *      --------- 
             *     |         |
             *   1 |         | 2
             *     |         |
             *      ---------
             *          8
             */

            m_fReferencePointStartX = objROI.ref_ROIWidth;
            m_fReferencePointStartY = objROI.ref_ROIHeight;
            m_fReferencePointEndX = 0;
            m_fReferencePointEndY = 0;

            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                switch (m_stcBlobLead.intDirection)
                {
                    case 4: // Top
                        {
                            if (m_stcBlobLead.fBaseCenterX - m_stcBlobLead.fBaseWidth / 2 < m_fReferencePointStartX)
                            {
                                m_fReferencePointStartX = m_stcBlobLead.fBaseCenterX - m_stcBlobLead.fBaseWidth / 2;
                                m_fReferencePointStartY = m_stcBlobLead.fLimitCenterY + m_stcBlobLead.fHeight / 2;
                            }

                            if (m_stcBlobLead.fBaseCenterX + m_stcBlobLead.fBaseWidth / 2 > m_fReferencePointEndX)
                            {
                                m_fReferencePointEndX = m_stcBlobLead.fBaseCenterX + m_stcBlobLead.fBaseWidth / 2;
                                m_fReferencePointEndY = m_stcBlobLead.fLimitCenterY + m_stcBlobLead.fHeight / 2;
                            }
                        }
                        break;
                    case 2: // Right
                        {
                            if (m_stcBlobLead.fBaseCenterY - m_stcBlobLead.fBaseLength / 2 < m_fReferencePointStartY)
                            {
                                m_fReferencePointStartY = m_stcBlobLead.fBaseCenterY - m_stcBlobLead.fBaseLength / 2;
                                m_fReferencePointStartX = m_stcBlobLead.fLimitCenterX - m_stcBlobLead.fWidth / 2;
                            }

                            if (m_stcBlobLead.fBaseCenterY + m_stcBlobLead.fBaseLength / 2 > m_fReferencePointEndY)
                            {
                                m_fReferencePointEndY = m_stcBlobLead.fBaseCenterY + m_stcBlobLead.fBaseLength / 2;
                                m_fReferencePointEndX = m_stcBlobLead.fLimitCenterX - m_stcBlobLead.fWidth / 2;
                            }
                        }
                        break;
                    case 8: // Bottom
                        {
                            if (m_stcBlobLead.fBaseCenterX - m_stcBlobLead.fBaseWidth / 2 < m_fReferencePointStartX)
                            {
                                m_fReferencePointStartX = m_stcBlobLead.fBaseCenterX - m_stcBlobLead.fBaseWidth / 2;
                                m_fReferencePointStartY = m_stcBlobLead.fLimitCenterY - m_stcBlobLead.fHeight / 2;
                            }

                            if (m_stcBlobLead.fBaseCenterX + m_stcBlobLead.fBaseWidth / 2 > m_fReferencePointEndX)
                            {
                                m_fReferencePointEndX = m_stcBlobLead.fBaseCenterX + m_stcBlobLead.fBaseWidth / 2;
                                m_fReferencePointEndY = m_stcBlobLead.fLimitCenterY - m_stcBlobLead.fHeight / 2;
                            }
                        }
                        break;
                    case 1: // Left
                        {
                            if (m_stcBlobLead.fBaseCenterY - m_stcBlobLead.fBaseLength / 2 < m_fReferencePointStartY)
                            {
                                m_fReferencePointStartY = m_stcBlobLead.fBaseCenterY - m_stcBlobLead.fBaseLength / 2;
                                m_fReferencePointStartX = m_stcBlobLead.fLimitCenterX + m_stcBlobLead.fWidth / 2;
                            }

                            if (m_stcBlobLead.fBaseCenterY + m_stcBlobLead.fBaseLength / 2 > m_fReferencePointEndY)
                            {
                                m_fReferencePointEndY = m_stcBlobLead.fBaseCenterY + m_stcBlobLead.fBaseLength / 2;
                                m_fReferencePointEndX = m_stcBlobLead.fLimitCenterX + m_stcBlobLead.fWidth / 2;
                            }
                        }
                        break;
                }
            }
        }


        /// <summary>
        /// Clear m_arrTemplateBlobLeads
        /// </summary>
        public void ClearTemplateBlobsFeatures()
        {
            m_arrTemplateBlobLeads.Clear();
            m_arrTemplateBlobBodyLeads.Clear();
        }

        /// <summary>
        /// Clear m_arrTemporaryBlobLeads
        /// </summary>
        public void ClearTempBlobsFeatures()
        {
            m_arrTemporaryBlobLeads.Clear();
        }

        /// <summary>
        /// Clear m_arrPitchGap
        /// </summary>
        public void ClearTemplatePitchGap()
        {
            m_arrPitchGap.Clear();
        }

        /// <summary>
        /// Get total pitch gap
        /// </summary>
        /// <returns>total pitch gap</returns>
        public int GetTotalPitchGap()
        {
            return m_arrPitchGap.Count;
        }

        public PointF GetResultCenterPoint_UnitMatcher()
        {
            return m_pUnitCenterPoint;
        }

        /// <summary>
        /// Get blobs features length mode
        /// </summary>
        /// <param name="intIndex">blob index</param>
        /// <returns>length mode, 1: Length = Height, 2: Length = Width</returns>
        public int GetSampleLengthMode(int intIndex)
        {
            return ((BlobsFeatures)m_arrTemplateBlobLeads[intIndex]).intLengthMode;
        }

        /// <summary>
        /// Get pitch gap data
        /// </summary>
        /// <param name="intPitchGapIndex">pitch gap index</param>
        /// <returns>pitch gap data</returns>
        public string GetPitchGapData(int intPitchGapIndex)
        {
            string strPitchGapData = "";

            PitchGap stcPitchGap = m_arrPitchGap[intPitchGapIndex];

            strPitchGapData += stcPitchGap.intFromLeadNo.ToString() + "#";
            strPitchGapData += stcPitchGap.intToLeadNo.ToString() + "#";
            strPitchGapData += (stcPitchGap.fMinPitch * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "#";
            strPitchGapData += (stcPitchGap.fMaxPitch * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "#";
            strPitchGapData += (stcPitchGap.fMinGap * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "#";
            strPitchGapData += (stcPitchGap.fMaxGap * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "#";
            strPitchGapData += stcPitchGap.fPitch.ToString() + "#";
            strPitchGapData += stcPitchGap.fGap.ToString() + "#";
            strPitchGapData += stcPitchGap.intStartPointX.ToString() + "#";
            strPitchGapData += stcPitchGap.intStartPointY.ToString() + "#";
            strPitchGapData += stcPitchGap.intEndPointX.ToString() + "#";
            strPitchGapData += stcPitchGap.intEndPointY.ToString() + "#";
            strPitchGapData += stcPitchGap.intDirection.ToString() + "#";

            return strPitchGapData;
        }

        /// <summary>
        /// Get total selected object
        /// </summary>
        /// <returns>selected object count</returns>
        public int GetSelectedObjectNumber()
        {
            int intObjectCount = 0;
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                if (((BlobsFeatures)m_arrTemplateBlobLeads[i]).blnSelected)
                    intObjectCount++;
            }

            for (int i = 0; i < m_arrTemplateBlobBodyLeads.Count; i++)
            {
                if (((BlobsFeatures)m_arrTemplateBlobBodyLeads[i]).blnSelected)
                    intObjectCount++;
            }
            return intObjectCount;
        }

        /// <summary>
        /// Get the pitch gap drawing point
        /// </summary>
        /// <param name="intStartLine1">start line 1</param>
        /// <param name="intEndLine1">end line 1</param>
        /// <param name="intStartLine2">start line 2</param>
        /// <param name="intEndLine2">end line 2</param>
        /// <returns>pitch gap drawing point</returns>
        public int GetDrawPoint(int intStartLine1, int intEndLine1, int intStartLine2, int intEndLine2)
        {
            int intStartPoint;
            int intEndPoint;

            if (intStartLine1 > intStartLine2)
                intStartPoint = intStartLine1;
            else
                intStartPoint = intStartLine2;

            if (intEndLine1 < intEndLine2)
                intEndPoint = intEndLine1;
            else
                intEndPoint = intEndLine2;

            return intStartPoint + (int)Math.Abs((intStartPoint - intEndPoint) / 2);
        }

        /// <summary>
        /// Get inspection fail result
        /// </summary>
        /// <param name="strPosition">ROI position (Center ROI, Top ROI, Bottom ROI, Left ROI, Right ROI)</param>
        /// <returns>inspection fail result in string</returns>
        public string GetLeadFailTestDisplayResult()
        {
            float fData;
            float fMin;
            float fMax;
            float fMeasure;
            int intNoID;
            string strFailMessage = "";
            List<int> arrJoint = new List<int>();
            BlobsFeatures stcBlobsFeatures;

            for (int i = 0; i < m_arrSampleBlobLeads.Length; i++)
            {
                stcBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                intNoID = stcBlobsFeatures.intNoID;

                if ((m_arrSampleBlobLeads[i].intFailMask & 0x10) > 0)
                {
                    arrJoint.Add(i);
                }

                if ((m_arrSampleBlobLeads[i].intFailMask & 0x20) > 0)
                {
                    strFailMessage += "*Lead " + intNoID + ": Missing Lead";
                }

                if ((m_arrSampleBlobLeads[i].intFailMask & 0x40) > 0)
                {
                    strFailMessage += "*Lead " + intNoID + ": Width Fail. ";

                    fMin = stcBlobsFeatures.fMinTipWidth * m_fMMToUnitValue;
                    fMax = stcBlobsFeatures.fMaxTipWidth * m_fMMToUnitValue;
                    fMeasure = m_arrSampleBlobLeads[i].fTipWidthMM * m_fMMToUnitValue;
                    strFailMessage += "Min: " + fMin.ToString("F" + m_intDecimal) + ", Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                }

                if ((m_arrSampleBlobLeads[i].intFailMask & 0x400000) > 0)
                {
                    strFailMessage += "*Lead " + intNoID + ": Side Width Fail. ";

                    fMin = stcBlobsFeatures.fMinTipWidth * m_fMMToUnitValue;
                    fMax = stcBlobsFeatures.fMaxTipWidth * m_fMMToUnitValue;
                    fMeasure = m_arrSampleBlobLeads[i].fTipWidthMM * m_fMMToUnitValue;
                    strFailMessage += "Min: " + fMin.ToString("F" + m_intDecimal) + ", Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                }

                if ((m_arrSampleBlobLeads[i].intFailMask & 0x80) > 0)
                {
                    strFailMessage += "*Lead " + intNoID + ": Length Fail. ";

                    fMin = stcBlobsFeatures.fMinTipLength * m_fMMToUnitValue;
                    fMax = stcBlobsFeatures.fMaxTipLength * m_fMMToUnitValue;
                    fMeasure = m_arrSampleBlobLeads[i].fTipLengthMM * m_fMMToUnitValue;
                    strFailMessage += "Min: " + fMin.ToString("F" + m_intDecimal) + ", Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                }

                if ((m_arrSampleBlobLeads[i].intFailMask & 0x100) > 0)
                {
                    strFailMessage += "*Lead " + intNoID + ": Skew. ";
                    if (m_arrSampleBlobLeads[i].blnBaseStartFound || m_arrSampleBlobLeads[i].blnBaseEndFound)
                    {
                        fMax = stcBlobsFeatures.fSkew * m_fMMToUnitValue;    // Can use either m_fMMToUnitValue or m_fMMToUnitValue
                        fMeasure = m_arrSampleBlobLeads[i].fSkewMM * m_fMMToUnitValue;
                        strFailMessage += "Set < " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                    }
                    else
                    {
                        strFailMessage += "Fail to find base points";
                    }
                }

                if ((m_arrSampleBlobLeads[i].intFailMask & 0x20000) > 0)
                {
                    strFailMessage += "*Lead " + intNoID + ": Offset Fail. ";
                    fMax = stcBlobsFeatures.fOffSet * m_fMMToUnitValue;    // Can use either m_fMMToUnitValue or m_fMMToUnitValue
                    fMeasure = m_arrSampleBlobLeads[i].fOffSetMM * m_fMMToUnitValue;
                    strFailMessage += "Set < " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                }

                if ((m_arrSampleBlobLeads[i].intFailMask & 0x01) > 0)
                {
                    strFailMessage += "*Lead " + intNoID + ": Stand Off Fail. ";

                    fMin = stcBlobsFeatures.fMinStandOff * m_fMMToUnitValue;
                    fMax = stcBlobsFeatures.fMaxStandOff * m_fMMToUnitValue;
                    fMeasure = m_arrSampleBlobLeads[i].fStandOffMM * m_fMMToUnitValue;
                    strFailMessage += "Min: " + fMin.ToString("F" + m_intDecimal) + ", Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                }

                if ((m_arrSampleBlobLeads[i].intFailMask & 0x02) > 0)
                {
                    strFailMessage += "*Lead " + intNoID + ": Coplan Fail. ";

                    fMax = stcBlobsFeatures.fMaxCoplan * m_fMMToUnitValue;
                    fMeasure = m_arrSampleBlobLeads[i].fCoplanMM * m_fMMToUnitValue;
                    strFailMessage += "Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                }

                if ((m_arrSampleBlobLeads[i].intFailMask & 0x40000) > 0)
                {
                    strFailMessage += "*Lead " + intNoID + ": Average Gray Value Fail. ";
                    fMin = stcBlobsFeatures.fMinAGV;
                    fMax = stcBlobsFeatures.fMaxAGV;
                    fMeasure = m_arrSampleBlobLeads[i].fAGV;
                    strFailMessage += "Min: " + fMin.ToString("F" + m_intDecimal) + ", Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                }

                if ((m_arrSampleBlobLeads[i].intFailMask & 0x100000) > 0)
                {
                    strFailMessage += "*Lead " + intNoID + ": Min Max Width Fail. ";

                    fMin = stcBlobsFeatures.fLeadLimitMinWidth * m_fMMToUnitValue;
                    fMax = stcBlobsFeatures.fLeadLimitMaxWidth * m_fMMToUnitValue;
                    float fMeasureMin = m_arrSampleBlobLeads[i].fLeadMinWidthMM * m_fMMToUnitValue;
                    float fMeasureMax = m_arrSampleBlobLeads[i].fLeadMaxWidthMM * m_fMMToUnitValue;
                    strFailMessage += "Min: " + fMin.ToString("F" + m_intDecimal) +
                                      ", Max: " + fMax.ToString("F" + m_intDecimal) +
                                      ", Measure Min: " + fMeasureMin.ToString("F" + m_intDecimal) +
                                      ", Measure Max: " + fMeasureMax.ToString("F" + m_intDecimal);
                }

                if ((m_arrSampleBlobLeads[i].intFailMask & 0x200000) > 0)
                {
                    strFailMessage += "*Lead " + intNoID + ": Burr Width Fail. ";

                    fMax = stcBlobsFeatures.fLeadMaxBurrWidth * m_fMMToUnitValue;
                    fMeasure = m_arrSampleBlobLeads[i].fLeadBurrWidthMM * m_fMMToUnitValue;
                    strFailMessage += "Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                }
            }

            if (arrJoint.Count > 0)
            {
                for (int i = 0; i < arrJoint.Count; i++)
                {
                    if (i == 0)
                        strFailMessage += "*Lead " + (arrJoint[i] + 1);
                    else
                        strFailMessage += (arrJoint[i] + 1);

                    if (i != arrJoint.Count - 1)
                        strFailMessage += ", ";
                    else
                    {
                        strFailMessage += ": Un-Cut Tiebar.";
                    }
                }
            }

            if (m_arrExtraBlobs.Count > 0)
            {
                for (int i = 0; i < m_arrExtraBlobs.Count; i++)
                {
                    //strFailMessage += strPosition + "Extra Lead.";
                    // Contamination
                    if (m_blnWantCheckExtraLeadLength)
                    {
                        if ((m_arrExtraBlobs[i].ref_intFailCriteria & 0x01) > 0)
                        {
                            strFailMessage += "*Defect " + m_arrExtraBlobs[i].ref_intExtraBlobID + " Lead contamination width. Set=" + m_fExtraLeadSetLength +
                                "mm, Result=" + (m_arrExtraBlobs[i].ref_fWidthFailValue).ToString("F" + m_intDecimal) + "mm.";
                        }

                        if ((m_arrExtraBlobs[i].ref_intFailCriteria & 0x02) > 0)
                        {
                            strFailMessage += "*Defect " + m_arrExtraBlobs[i].ref_intExtraBlobID + " Lead contamination length. Set=" + m_fExtraLeadSetLength +
                                "mm, Result=" + (m_arrExtraBlobs[i].ref_fHeightFailValue).ToString("F" + m_intDecimal) + "mm.";
                        }
                    }
                    if (m_blnWantCheckExtraLeadArea)
                    {
                        if ((m_arrExtraBlobs[i].ref_intFailCriteria & 0x04) > 0 && !m_blnFailForeignMaterialTotalArea)
                        {
                            strFailMessage += "*Defect " + m_arrExtraBlobs[i].ref_intExtraBlobID + " Lead contamination area. Set=" + m_fExtraLeadSetArea +
                                "mm^2, Result=" + (m_arrExtraBlobs[i].ref_fAreaFailValue).ToString("F" + m_intDecimal2) + "mm^2.";
                        }
                    }
                    if ((m_intFailOptionMask & 0x2000) > 0)
                    {
                        if (((m_arrExtraBlobs[i].ref_intFailCriteria & 0x04) > 0) && m_blnFailForeignMaterialTotalArea)
                        {
                            strFailMessage += "*Defect " + m_arrExtraBlobs[i].ref_intExtraBlobID + " Lead contamination Total area. Set=" + m_fTotalExtraLeadSetArea +
                                "mm^2, Result=" + (m_arrExtraBlobs[i].ref_fAreaFailValue).ToString("F" + m_intDecimal2) + "mm^2.";
                        }
                    }
                }
            }

            for (int y = 0; y < m_arrPitchGap.Count; y++)
            {
                int intFrom = m_arrPitchGap[y].intFromLeadNo + 1;
                int intTo = m_arrPitchGap[y].intToLeadNo + 1;

                if ((m_arrPitchGap[y].intFailMask & 0x200) > 0)
                {
                    strFailMessage += "*Pitch " + intFrom.ToString() + " to " + intTo.ToString() + " Fail. ";
                    fMin = m_arrPitchGap[y].fMinPitch * m_fMMToUnitValue;
                    fMax = m_arrPitchGap[y].fMaxPitch * m_fMMToUnitValue;
                    fMeasure = m_arrPitchGap[y].fPitchMM * m_fMMToUnitValue;
                    strFailMessage += "Min: " + fMin.ToString("F" + m_intDecimal) + ", Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                }

                if ((m_arrPitchGap[y].intFailMask & 0x400) > 0)
                {
                    strFailMessage += "*Gap " + intFrom.ToString() + " to " + intTo.ToString() + " Fail. ";
                    fMin = m_arrPitchGap[y].fMinGap * m_fMMToUnitValue;
                    fMax = m_arrPitchGap[y].fMaxGap * m_fMMToUnitValue;
                    fMeasure = m_arrPitchGap[y].fGapMM * m_fMMToUnitValue;
                    strFailMessage += "Min: " + fMin.ToString("F" + m_intDecimal) + ", Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                }
            }

            for (int i = 1; i < m_arrFailResultMask.Length; i++)
            {
                // Pitch variance
                if ((m_arrFailResultMask[i] & 0x2000) > 0)
                {
                    switch (i)
                    {
                        case 1:
                            strFailMessage += "*Top Pitch Variance Fail.";
                            fMax = m_fPitchVarianceTopMaxSetting * m_fMMToUnitValue;
                            fMeasure = m_fPitchVarianceTopResult * m_fMMToUnitValue;
                            strFailMessage += "Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                            break;
                        case 2:
                            strFailMessage += "*Right Pitch Variance Fail.";
                            fMax = m_fPitchVarianceRightMaxSetting * m_fMMToUnitValue;
                            fMeasure = m_fPitchVarianceRightResult * m_fMMToUnitValue;
                            strFailMessage += "Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                            break;
                        case 3:
                            strFailMessage += "*Bottom Pitch Variance Fail.";
                            fMax = m_fPitchVarianceBottomMaxSetting * m_fMMToUnitValue;
                            fMeasure = m_fPitchVarianceBottomResult * m_fMMToUnitValue;
                            strFailMessage += "Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                            break;
                        case 4:
                            strFailMessage += "*Left Pitch Variance Fail.";

                            fMax = m_fPitchVarianceLeftMaxSetting * m_fMMToUnitValue;
                            fMeasure = m_fPitchVarianceLeftResult * m_fMMToUnitValue;
                            strFailMessage += "Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                            break;
                    }
                }
            }

            for (int i = 0; i < m_arrFailResultMask.Length; i++)
            {
                // Length variance
                if ((m_arrFailResultMask[i] & 0x800) > 0)
                {
                    switch (i)
                    {
                        case 0:
                            if (m_intLeadLengthVarianceMethod != 0)
                            {
                                strFailMessage += "*Overall Length Variance Fail.";
                                fMax = m_fLengthVarianceOverallMaxSetting * m_fMMToUnitValue;
                                fMeasure = m_fLengthVarianceOverallResult * m_fMMToUnitValue;
                                strFailMessage += "Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                            }
                            break;
                        case 1:
                            if (m_intLeadLengthVarianceMethod != 1)
                            {
                                strFailMessage += "*Top Length Variance Fail.";
                                fMax = m_fLengthVarianceTopMaxSetting * m_fMMToUnitValue;
                                fMeasure = m_fLengthVarianceTopResult * m_fMMToUnitValue;
                                strFailMessage += "Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                            }
                            break;
                        case 2:
                            if (m_intLeadLengthVarianceMethod != 1)
                            {
                                strFailMessage += "*Right Length Variance Fail.";
                                fMax = m_fLengthVarianceRightMaxSetting * m_fMMToUnitValue;
                                fMeasure = m_fLengthVarianceRightResult * m_fMMToUnitValue;
                                strFailMessage += "Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                            }
                            break;
                        case 3:
                            if (m_intLeadLengthVarianceMethod != 1)
                            {
                                strFailMessage += "*Bottom Length Variance Fail.";
                                fMax = m_fLengthVarianceBottomMaxSetting * m_fMMToUnitValue;
                                fMeasure = m_fLengthVarianceBottomResult * m_fMMToUnitValue;
                                strFailMessage += "Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                            }
                            break;
                        case 4:
                            if (m_intLeadLengthVarianceMethod != 1)
                            {
                                strFailMessage += "*Left Length Variance Fail.";
                                fMax = m_fLengthVarianceLeftMaxSetting * m_fMMToUnitValue;
                                fMeasure = m_fLengthVarianceLeftResult * m_fMMToUnitValue;
                                strFailMessage += "Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                            }
                            break;
                    }
                }
            }

            for (int i = 0; i < m_arrFailResultMask.Length; i++)
            {
                // Stand Off variance
                if ((m_arrFailResultMask[i] & 0x4000) > 0)
                {
                    switch (i)
                    {
                        case 0:
                            strFailMessage += "*Unit Stand Off Variance Fail.";
                            fMax = m_fStandOffVarianceUnitMaxSetting * m_fMMToUnitValue;
                            fMeasure = m_fStandOffVarianceUnitResult * m_fMMToUnitValue;
                            strFailMessage += "Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                            break;
                        case 1:
                            strFailMessage += "*Top Stand Off Variance Fail.";
                            fMax = m_fStandOffVarianceTopMaxSetting * m_fMMToUnitValue;
                            fMeasure = m_fStandOffVarianceTopResult * m_fMMToUnitValue;
                            strFailMessage += "Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                            break;
                        case 2:
                            strFailMessage += "*Right Stand Off Variance Fail.";
                            fMax = m_fStandOffVarianceRightMaxSetting * m_fMMToUnitValue;
                            fMeasure = m_fStandOffVarianceRightResult * m_fMMToUnitValue;
                            strFailMessage += "Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                            break;
                        case 3:
                            strFailMessage += "*Bottom Stand Off Variance Fail.";
                            fMax = m_fStandOffVarianceBottomMaxSetting * m_fMMToUnitValue;
                            fMeasure = m_fStandOffVarianceBottomResult * m_fMMToUnitValue;
                            strFailMessage += "Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                            break;
                        case 4:
                            strFailMessage += "*Left Stand Off Variance Fail.";

                            fMax = m_fStandOffVarianceLeftMaxSetting * m_fMMToUnitValue;
                            fMeasure = m_fStandOffVarianceLeftResult * m_fMMToUnitValue;
                            strFailMessage += "Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                            break;
                    }
                }
            }

            for (int i = 1; i < m_arrFailResultMask.Length; i++)
            {
                // Leads Sweep 
                if ((m_arrFailResultMask[i] & 0x04) > 0)
                {
                    switch (i)
                    {
                        case 1:
                            strFailMessage += "*Top Leads Sweep Fail.";
                            fMin = m_fLeadSweepVarianceTopMinSetting * m_fMMToUnitValue;
                            fMax = m_fLeadSweepVarianceTopMaxSetting * m_fMMToUnitValue;
                            fMeasure = m_fLeadSweepVarianceTopResult * m_fMMToUnitValue;
                            strFailMessage += "Min: " + fMin.ToString("F" + m_intDecimal) + ", Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                            break;
                        case 2:
                            strFailMessage += "*Right Leads Sweep Fail.";
                            fMin = m_fLeadSweepVarianceRightMinSetting * m_fMMToUnitValue;
                            fMax = m_fLeadSweepVarianceRightMaxSetting * m_fMMToUnitValue;
                            fMeasure = m_fLeadSweepVarianceRightResult * m_fMMToUnitValue;
                            strFailMessage += "Min: " + fMin.ToString("F" + m_intDecimal) + ", Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                            break;
                        case 3:
                            strFailMessage += "*Bottom Leads Sweep Fail.";
                            fMin = m_fLeadSweepVarianceBottomMinSetting * m_fMMToUnitValue;
                            fMax = m_fLeadSweepVarianceBottomMaxSetting * m_fMMToUnitValue;
                            fMeasure = m_fLeadSweepVarianceTopResult * m_fMMToUnitValue;
                            strFailMessage += "Min: " + fMin.ToString("F" + m_intDecimal) + ", Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                            break;
                        case 4:
                            strFailMessage += "*Left Leads Sweep Fail.";
                            fMin = m_fLeadSweepVarianceLeftMinSetting * m_fMMToUnitValue;
                            fMax = m_fLeadSweepVarianceLeftMaxSetting * m_fMMToUnitValue;
                            fMeasure = m_fLeadSweepVarianceLeftResult * m_fMMToUnitValue;
                            strFailMessage += "Min: " + fMin.ToString("F" + m_intDecimal) + ", Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                            break;
                    }
                }
            }

            for (int i = 0; i < m_arrFailResultMask.Length; i++)
            {
                // Span
                if ((m_arrFailResultMask[i] & 0x1000) > 0)
                {
                    switch (i)
                    {
                        case 0:
                            if (m_intLeadSpanMethod != 0)
                            {
                                strFailMessage += "*Overall Span Fail.";
                                fMin = m_fSpanOverallMinSetting * m_fMMToUnitValue;
                                fMax = m_fSpanOverallMaxSetting * m_fMMToUnitValue;
                                fMeasure = m_fSpanOverallResult * m_fMMToUnitValue;
                                strFailMessage += "Min: " + fMin.ToString("F" + m_intDecimal) + ", Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                            }
                            break;
                        case 1:
                            if (m_intLeadSpanMethod != 1)
                            {
                                strFailMessage += "*Top Span Fail.";
                                fMin = m_fSpanTopMinSetting * m_fMMToUnitValue;
                                fMax = m_fSpanTopMaxSetting * m_fMMToUnitValue;
                                fMeasure = m_fSpanTopResult * m_fMMToUnitValue;
                                strFailMessage += "Min: " + fMin.ToString("F" + m_intDecimal) + ", Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                            }
                            break;
                        case 2:
                            if (m_intLeadSpanMethod != 1)
                            {
                                strFailMessage += "*Right Span Fail.";
                                fMin = m_fSpanRightMinSetting * m_fMMToUnitValue;
                                fMax = m_fSpanRightMaxSetting * m_fMMToUnitValue;
                                fMeasure = m_fSpanRightResult * m_fMMToUnitValue;
                                strFailMessage += "Min: " + fMin.ToString("F" + m_intDecimal) + ", Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                            }
                            break;
                        case 3:
                            if (m_intLeadSpanMethod != 1)
                            {
                                strFailMessage += "*Bottom Span Fail.";
                                fMin = m_fSpanBottomMinSetting * m_fMMToUnitValue;
                                fMax = m_fSpanBottomMaxSetting * m_fMMToUnitValue;
                                fMeasure = m_fSpanBottomResult * m_fMMToUnitValue;
                                strFailMessage += "Min: " + fMin.ToString("F" + m_intDecimal) + ", Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                            }
                            break;
                        case 4:
                            if (m_intLeadSpanMethod != 1)
                            {
                                strFailMessage += "*Left Span Fail.";
                                fMin = m_fSpanLeftMinSetting * m_fMMToUnitValue;
                                fMax = m_fSpanLeftMaxSetting * m_fMMToUnitValue;
                                fMeasure = m_fSpanLeftResult * m_fMMToUnitValue;
                                strFailMessage += "Min: " + fMin.ToString("F" + m_intDecimal) + ", Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                            }
                            break;
                    }
                }
            }
            return strFailMessage;
        }

        /// <summary>
        /// Get threshold value of particular ROI using specific threshold mode
        /// </summary>
        /// <param name="objROI">ROI</param>
        /// <param name="intThresholdMode">threshold mode, 0 = absolute, 1 = isodata, 3 = max entropy, 4 = min residue, 5 = relative</param>
        /// <returns>threshold value</returns>
        public int GetAutoThresholdValue(ROI objROI, int intThresholdMode)
        {
            EBW8 objBW8;
            if (intThresholdMode == 0)
                objBW8 = EasyImage.AutoThreshold(objROI.ref_ROI, EThresholdMode.Absolute);
            else if (intThresholdMode == 1)
                objBW8 = EasyImage.AutoThreshold(objROI.ref_ROI, EThresholdMode.Isodata);
            else if (intThresholdMode == 2)
                objBW8 = EasyImage.AutoThreshold(objROI.ref_ROI, EThresholdMode.MaxEntropy);
            else if (intThresholdMode == 3)
                objBW8 = EasyImage.AutoThreshold(objROI.ref_ROI, EThresholdMode.MinResidue);
            else
                objBW8 = EasyImage.AutoThreshold(objROI.ref_ROI, EThresholdMode.Relative);

            return objBW8.Value;
        }

        public void GetSpanData(int intLeadNo, ref float fLeadMinSpan, ref float fLeadMaxSpan)
        {
            switch (intLeadNo)
            {
                case 1:
                    fLeadMinSpan = m_fLeadMinSpanStart;
                    fLeadMaxSpan = m_fLeadMaxSpanStart;
                    break;
                case 2:
                    fLeadMinSpan = m_fLeadMinSpanEnd;
                    fLeadMaxSpan = m_fLeadMaxSpanEnd;
                    break;
                case 3:
                    fLeadMinSpan = m_fLeadMinSpanEnd;
                    fLeadMaxSpan = m_fLeadMaxSpanEnd;
                    break;
                case 4:
                    fLeadMinSpan = m_fLeadMinSpanStart;
                    fLeadMaxSpan = m_fLeadMaxSpanStart;
                    break;
            }
        }

        public void GetSampleSpanData(int intLeadNo, ref float fSampleLeadMinSpan, ref float fSampleLeadMaxSpan)
        {
            switch (intLeadNo)
            {
                case 1:
                    fSampleLeadMinSpan = m_fSampleLeadMinSpanStart;
                    fSampleLeadMaxSpan = m_fSampleLeadMaxSpanStart;
                    break;
                case 2:
                    fSampleLeadMinSpan = m_fSampleLeadMinSpanEnd;
                    fSampleLeadMaxSpan = m_fSampleLeadMaxSpanEnd;
                    break;
                case 3:
                    fSampleLeadMinSpan = m_fSampleLeadMinSpanEnd;
                    fSampleLeadMaxSpan = m_fSampleLeadMaxSpanEnd;
                    break;
                case 4:
                    fSampleLeadMinSpan = m_fSampleLeadMinSpanStart;
                    fSampleLeadMaxSpan = m_fSampleLeadMaxSpanStart;
                    break;
            }
        }

        /// <summary>
        /// Check no of objects is it tally with previous setting
        /// </summary>
        /// <param name="intCount">no of previous objects</param>
        /// <returns>true = objects no is tally, false = otherwise</returns>
        public bool CheckLeadTally(ref int intCount)
        {
            intCount = m_arrBackupTemplateBlobLeads.Count;
            int intNewCount = GetSelectedObjectNumber();

            if (intNewCount == m_arrBackupTemplateBlobLeads.Count)
                return true;
            else
                return false;
        }


        /// <summary>
        /// Check whether pitch gap link is exist
        /// </summary>
        /// <param name="intFromLeadNo">from Lead no</param>
        /// <param name="intToLeadNo">to Lead no</param>
        /// <returns>true = pitch gap link exist, false = otherwise</returns>
        public bool CheckPitchGapLinkExist(int intFromLeadNo, int intToLeadNo)
        {
            for (int i = 0; i < m_arrPitchGap.Count; i++)
            {
                if ((m_arrPitchGap[i].intFromLeadNo == (intFromLeadNo)) &&
                    (m_arrPitchGap[i].intToLeadNo == (intToLeadNo)) ||
                    (m_arrPitchGap[i].intFromLeadNo == (intToLeadNo)) &&
                    (m_arrPitchGap[i].intToLeadNo == (intFromLeadNo)))
                {
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// Check whether this Lead has already link with other Lead
        /// </summary>
        /// <param name="intFromLeadNo">from Lead no</param>
        /// <returns>true = Lead has link with other Lead, false = otherwise</returns>
        public bool CheckPitchGapLinkInLeadAlready(int intFromLeadNo)
        {
            for (int i = 0; i < m_arrPitchGap.Count; i++)
            {
                if (m_arrPitchGap[i].intFromLeadNo == intFromLeadNo)
                {
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// Verify whether pitch gap allow to be created between two Leads
        /// </summary>
        /// <param name="intFromLeadNo">from Lead no</param>
        /// <param name="intToLeadNo">to Lead no</param>
        /// <returns>true = valid pitch gap link, false = invalid pitch gap link</returns>
        public bool CheckPitchGapLinkAvailable(int intFromLeadNo, int intToLeadNo)
        {
            m_stcPitchGap = new PitchGap();
            m_stcPitchGap.intFromLeadNo = intFromLeadNo;
            m_stcPitchGap.intToLeadNo = intToLeadNo;

            if ((intFromLeadNo < m_arrTemplateBlobLeads.Count) && (intToLeadNo < m_arrTemplateBlobLeads.Count))
            {
                int intDrawPoint;
                bool blnUpDownFound = false;
                bool blnLeftRightFound = false;
                BlobsFeatures stcFromBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobLeads[intFromLeadNo];
                BlobsFeatures stcToBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobLeads[intToLeadNo];

                if (stcFromBlobsFeatures.intDirection != stcToBlobsFeatures.intDirection)
                    return false;

                int intStartX_From = 0, intStartY_From = 0, intEndX_From = 0, intEndY_From = 0;
                int intStartX_To = 0, intStartY_To = 0, intEndX_To = 0, intEndY_To = 0;

                switch (stcFromBlobsFeatures.intDirection)
                {
                    case 4: //Top
                        intStartX_From = (int)(stcFromBlobsFeatures.fTipCenterX - stcFromBlobsFeatures.fTipWidth / 2);

                        intEndX_From = (int)(stcFromBlobsFeatures.fTipCenterX + stcFromBlobsFeatures.fTipWidth / 2);

                        intStartY_From = (int)(stcFromBlobsFeatures.fTipCenterY);

                        intEndY_From = (int)(stcFromBlobsFeatures.fTipCenterY + stcFromBlobsFeatures.fTipLength);
                        break;
                    case 2: //Right
                        intStartX_From = (int)(stcFromBlobsFeatures.fTipCenterX - stcFromBlobsFeatures.fTipLength);

                        intEndX_From = (int)(stcFromBlobsFeatures.fTipCenterX);

                        intStartY_From = (int)(stcFromBlobsFeatures.fTipCenterY - stcFromBlobsFeatures.fTipWidth / 2);

                        intEndY_From = (int)(stcFromBlobsFeatures.fTipCenterY + stcFromBlobsFeatures.fTipWidth / 2);
                        break;
                    case 8: //Bottom
                        intStartX_From = (int)(stcFromBlobsFeatures.fTipCenterX - stcFromBlobsFeatures.fTipWidth / 2);

                        intEndX_From = (int)(stcFromBlobsFeatures.fTipCenterX + stcFromBlobsFeatures.fTipWidth / 2);

                        intStartY_From = (int)(stcFromBlobsFeatures.fTipCenterY - stcFromBlobsFeatures.fTipLength);

                        intEndY_From = (int)(stcFromBlobsFeatures.fTipCenterY);
                        break;
                    case 1: //Left
                        intStartX_From = (int)(stcFromBlobsFeatures.fTipCenterX);

                        intEndX_From = (int)(stcFromBlobsFeatures.fTipCenterX + stcFromBlobsFeatures.fTipLength);

                        intStartY_From = (int)(stcFromBlobsFeatures.fTipCenterY - stcFromBlobsFeatures.fTipWidth / 2);

                        intEndY_From = (int)(stcFromBlobsFeatures.fTipCenterY + stcFromBlobsFeatures.fTipWidth / 2);
                        break;
                }

                switch (stcToBlobsFeatures.intDirection)
                {
                    case 4: //Top
                        intStartX_To = (int)(stcToBlobsFeatures.fTipCenterX - stcToBlobsFeatures.fTipWidth / 2);

                        intEndX_To = (int)(stcToBlobsFeatures.fTipCenterX + stcToBlobsFeatures.fTipWidth / 2);

                        intStartY_To = (int)(stcToBlobsFeatures.fTipCenterY);

                        intEndY_To = (int)(stcToBlobsFeatures.fTipCenterY + stcToBlobsFeatures.fTipLength);
                        break;
                    case 2: //Right
                        intStartX_To = (int)(stcToBlobsFeatures.fTipCenterX - stcToBlobsFeatures.fTipLength);

                        intEndX_To = (int)(stcToBlobsFeatures.fTipCenterX);

                        intStartY_To = (int)(stcToBlobsFeatures.fTipCenterY - stcToBlobsFeatures.fTipWidth / 2);

                        intEndY_To = (int)(stcToBlobsFeatures.fTipCenterY + stcToBlobsFeatures.fTipWidth / 2);
                        break;
                    case 8: //Bottom
                        intStartX_To = (int)(stcToBlobsFeatures.fTipCenterX - stcToBlobsFeatures.fTipWidth / 2);

                        intEndX_To = (int)(stcToBlobsFeatures.fTipCenterX + stcToBlobsFeatures.fTipWidth / 2);

                        intStartY_To = (int)(stcToBlobsFeatures.fTipCenterY - stcToBlobsFeatures.fTipLength);

                        intEndY_To = (int)(stcToBlobsFeatures.fTipCenterY);
                        break;
                    case 1: //Left
                        intStartX_To = (int)(stcToBlobsFeatures.fTipCenterX);

                        intEndX_To = (int)(stcToBlobsFeatures.fTipCenterX + stcToBlobsFeatures.fTipLength);

                        intStartY_To = (int)(stcToBlobsFeatures.fTipCenterY - stcToBlobsFeatures.fTipWidth / 2);

                        intEndY_To = (int)(stcToBlobsFeatures.fTipCenterY + stcToBlobsFeatures.fTipWidth / 2);
                        break;
                }

                // Check pitch available between up and down Leads
                if ((intStartX_From >= intStartX_To) && (intStartX_From <= intEndX_To) ||
                    (intEndX_From >= intStartX_To) && (intEndX_From <= intEndX_To) ||
                    (intStartX_To >= intStartX_From) && (intEndX_To <= intEndX_From) ||
                    (intEndX_To >= intStartX_From) && (intEndX_To <= intEndX_From))
                {
                    blnUpDownFound = true;
                }

                // Check pitch available between left and right Leads
                if ((intStartY_From >= intStartY_To) && (intStartY_From <= intEndY_To) ||
                    (intEndY_From >= intStartY_To) && (intEndY_From <= intEndY_To) ||
                    (intStartY_To >= intStartY_From) && (intEndY_To <= intEndY_From) ||
                    (intEndY_To >= intStartY_From) && (intEndY_To <= intEndY_From))
                {
                    blnLeftRightFound = true;
                }

                // Pitch only available in up down or left right only
                if ((blnLeftRightFound && !blnUpDownFound) || (!blnLeftRightFound && blnUpDownFound))
                {
                    if (blnUpDownFound)
                    {
                        // Pitch only available if distance gap between Leads > 1 pixel
                        if ((intStartY_To - intEndY_From) > 1)
                        {
                            intDrawPoint = GetDrawPoint(intStartX_From, intEndX_From, intStartX_To, intEndX_To);
                            m_stcPitchGap.intStartPointX = intDrawPoint;
                            m_stcPitchGap.intEndPointX = intDrawPoint;
                            m_stcPitchGap.intStartPointY = intEndY_From;
                            m_stcPitchGap.intEndPointY = intStartY_To;
                            m_stcPitchGap.fGap = intStartY_To - intEndY_From;
                            m_stcPitchGap.fPitch = stcToBlobsFeatures.fTipCenterY - stcFromBlobsFeatures.fTipCenterY;
                            m_stcPitchGap.intDirection = 180;
                            return true;
                        }
                        else if ((intStartY_From - intEndY_To) > 1)
                        {
                            intDrawPoint = GetDrawPoint(intStartX_From, intEndX_From, intStartX_To, intEndX_To);
                            m_stcPitchGap.intStartPointX = intDrawPoint;
                            m_stcPitchGap.intEndPointX = intDrawPoint;
                            m_stcPitchGap.intStartPointY = intStartY_From;
                            m_stcPitchGap.intEndPointY = intEndY_To;
                            m_stcPitchGap.fGap = intStartY_From - intEndY_To;
                            m_stcPitchGap.fPitch = stcFromBlobsFeatures.fTipCenterY - stcToBlobsFeatures.fTipCenterY;
                            m_stcPitchGap.intDirection = 0;
                            return true;
                        }
                        else
                        {
                            return false;
                        }
                    }
                    else
                    {
                        // Pitch only available if distance gap between Leads > 1 pixel
                        if ((intStartX_To - intEndX_From) > 1)
                        {
                            intDrawPoint = GetDrawPoint(intStartY_From, intEndY_From, intStartY_To, intEndY_To);
                            m_stcPitchGap.intStartPointX = intEndX_From;
                            m_stcPitchGap.intEndPointX = intStartX_To;
                            m_stcPitchGap.intStartPointY = intDrawPoint;
                            m_stcPitchGap.intEndPointY = intDrawPoint;
                            m_stcPitchGap.fGap = intStartX_To - intEndX_From;
                            m_stcPitchGap.fPitch = stcToBlobsFeatures.fTipCenterX - stcFromBlobsFeatures.fTipCenterX;
                            m_stcPitchGap.intDirection = 90;
                            return true;
                        }
                        else if ((intStartX_From - intEndX_To) > 1)
                        {
                            intDrawPoint = GetDrawPoint(intStartY_From, intEndY_From, intStartY_To, intEndY_To);
                            m_stcPitchGap.intStartPointX = intStartX_From;
                            m_stcPitchGap.intEndPointX = intEndX_To;
                            m_stcPitchGap.intStartPointY = intDrawPoint;
                            m_stcPitchGap.intEndPointY = intDrawPoint;
                            m_stcPitchGap.fGap = intStartX_From - intEndX_To;
                            m_stcPitchGap.fPitch = stcFromBlobsFeatures.fTipCenterX - stcToBlobsFeatures.fTipCenterX;
                            m_stcPitchGap.intDirection = 270;
                            return true;
                        }
                        else
                        {
                            return false;
                        }
                    }
                }
                else
                    return false;
            }
            return true;
        }

        private void CheckPitchGap(ROI objROI)
        {
            // Check pitch using tip center point (which equal to tip width center)
            #region ---- Check Pitch and Gap ----
            if ((m_intFailOptionMask & 0x400) > 0 || (m_intFailOptionMask & 0x200) > 0 || (m_intFailOptionMask & 0x2000) > 0)
            {
                // Reset Variance Result
                m_fPitchVarianceTopResult = -999;
                m_fPitchVarianceRightResult = -999;
                m_fPitchVarianceBottomResult = -999;
                m_fPitchVarianceLeftResult = -999;

                float fPitchVarianceMax = float.MinValue;
                float fPitchVarianceMin = float.MaxValue;
                int intDirectionPrev = 0;
                for (int i = 0; i < m_arrPitchGap.Count; i++)
                {
                    int intFrom = m_arrPitchGap[i].intFromLeadNo;
                    int intTo = m_arrPitchGap[i].intToLeadNo;
                    float fPitch, fDiffX, fDiffY, fPitchMM, fGap, fGapMM;
                    fPitch = fDiffX = fDiffY = fPitchMM = fGap = fGapMM = 0.0f;

                    //if is valid, broken, hole blob
                    if (((m_arrSampleBlobLeads[intFrom].intFailMask & 0x10) == 0) && ((m_arrSampleBlobLeads[intFrom].intFailMask & 0x20) == 0)) // 0x02 , 0x04
                    {
                        if (((m_arrSampleBlobLeads[intTo].intFailMask & 0x10) == 0) && ((m_arrSampleBlobLeads[intTo].intFailMask & 0x20) == 0))
                        {
                            bool blnResult = true;

                            //Check Pitch 

                            //fDiffX = Math.Abs(m_arrSampleBlobLeads[intFrom].fCenterX - m_arrSampleBlobLeads[intTo].fCenterX);
                            //fDiffY = Math.Abs(m_arrSampleBlobLeads[intFrom].fCenterY - m_arrSampleBlobLeads[intTo].fCenterY);

                            //if (fDiffX > fDiffY)
                            //    fPitch = fDiffX;
                            //else
                            //    fPitch = fDiffY;

                            m_stcPitchGap = m_arrPitchGap[i];
                            if (m_stcPitchGap.intDirection == 0 || m_stcPitchGap.intDirection == 180)
                            {

                                //fPitch = Math.Abs(m_arrSampleBlobLeads[intFrom].fCenterY - m_arrSampleBlobLeads[intTo].fCenterY);
                                fPitch = Math.Abs(m_arrSampleBlobLeads[intFrom].fTipCenterY - m_arrSampleBlobLeads[intTo].fTipCenterY);
                                fPitchMM = Get2DYinMM(fPitch) + m_stcBlobLead.fPitchOffset;// / m_fMMToPixelYValue;
                            }
                            else
                            {
                                //fPitch = Math.Abs(m_arrSampleBlobLeads[intFrom].fCenterX - m_arrSampleBlobLeads[intTo].fCenterX);
                                fPitch = Math.Abs(m_arrSampleBlobLeads[intFrom].fTipCenterX - m_arrSampleBlobLeads[intTo].fTipCenterX);
                                fPitchMM = Get2DXinMM(fPitch) + m_stcBlobLead.fPitchOffset;//fPitch / m_fMMToPixelXValue;
                            }

                            bool blnPitchResult;
                            if (m_blnWantTightSetting)
                            {
                                if ((fPitchMM < (m_arrPitchGap[i].fMinPitch + m_fTightSettingTolerance)) || (fPitchMM > (m_arrPitchGap[i].fMaxPitch - m_fTightSettingTolerance)))
                                    blnPitchResult = true;
                                else
                                    blnPitchResult = false;
                            }
                            else
                            {
                                if ((fPitchMM < m_arrPitchGap[i].fMinPitch) || (fPitchMM > m_arrPitchGap[i].fMaxPitch))
                                    blnPitchResult = true;
                                else
                                    blnPitchResult = false;
                            }

                            // Check is pitch fail
                            if (blnPitchResult && ((m_intFailOptionMask & 0x400) > 0 || (m_intFailOptionMask & 0x200) > 0))
                            {
                                PitchGap objPitchGap = new PitchGap();
                                objPitchGap.intFromLeadNo = intFrom;
                                objPitchGap.intToLeadNo = intTo;
                                if (m_arrPitchGap[i].intStartPointX == m_arrPitchGap[i].intEndPointX)
                                {
                                    //objPitchGap.intStartPointX = objROI.ref_ROITotalX + m_arrPitchGap[i].intStartPointX;
                                    //objPitchGap.intStartPointY = objROI.ref_ROITotalY + (int)Math.Round(m_arrSampleBlobLeads[intFrom].fCenterY, 0, MidpointRounding.AwayFromZero);
                                    //objPitchGap.intEndPointX = objROI.ref_ROITotalX + m_arrPitchGap[i].intStartPointX;
                                    //objPitchGap.intEndPointY = objROI.ref_ROITotalY + (int)Math.Round(m_arrSampleBlobLeads[intTo].fCenterY, 0, MidpointRounding.AwayFromZero);
                                    objPitchGap.intStartPointX = objROI.ref_ROITotalX + m_arrPitchGap[i].intStartPointX;
                                    objPitchGap.intStartPointY = objROI.ref_ROITotalY + (int)Math.Round(m_arrSampleBlobLeads[intFrom].fTipCenterY, 0, MidpointRounding.AwayFromZero);
                                    objPitchGap.intEndPointX = objROI.ref_ROITotalX + m_arrPitchGap[i].intStartPointX;
                                    objPitchGap.intEndPointY = objROI.ref_ROITotalY + (int)Math.Round(m_arrSampleBlobLeads[intTo].fTipCenterY, 0, MidpointRounding.AwayFromZero);
                                }
                                else
                                {
                                    //objPitchGap.intStartPointX = objROI.ref_ROITotalX + (int)Math.Round(m_arrSampleBlobLeads[intFrom].fCenterX, 0, MidpointRounding.AwayFromZero);
                                    //objPitchGap.intStartPointY = objROI.ref_ROITotalY + m_arrPitchGap[i].intStartPointY;
                                    //objPitchGap.intEndPointX = objROI.ref_ROITotalX + (int)Math.Round(m_arrSampleBlobLeads[intTo].fCenterX, 0, MidpointRounding.AwayFromZero);
                                    //objPitchGap.intEndPointY = objROI.ref_ROITotalY + m_arrPitchGap[i].intStartPointY;
                                    objPitchGap.intStartPointX = objROI.ref_ROITotalX + (int)Math.Round(m_arrSampleBlobLeads[intFrom].fTipCenterX, 0, MidpointRounding.AwayFromZero);
                                    objPitchGap.intStartPointY = objROI.ref_ROITotalY + m_arrPitchGap[i].intStartPointY;
                                    objPitchGap.intEndPointX = objROI.ref_ROITotalX + (int)Math.Round(m_arrSampleBlobLeads[intTo].fTipCenterX, 0, MidpointRounding.AwayFromZero);
                                    objPitchGap.intEndPointY = objROI.ref_ROITotalY + m_arrPitchGap[i].intStartPointY;
                                }
                                m_arrFailPitchGapList.Add(objPitchGap);     // Add Pitch location
                                //m_arrSampleBlobLeads[intFrom].intFailMask |= 0x400;
                                m_stcPitchGap.intFailMask = 0x200;
                                m_arrFailResultMask[0] |= 0x200;

                                blnResult = false;
                            }

                            // record the inspection result
                            m_stcPitchGap.fPitchMM = fPitchMM; //m_stcPitchGap.fPitchMM = fPitchMM + m_stcBlobLead.fPitchOffset;
                            m_arrPitchGap.RemoveAt(i);
                            m_arrPitchGap.Insert(i, m_stcPitchGap);
                            m_arrSampleBlobLeads[intFrom].fPitch = fPitch;

                            //Check Gap
                            float fCenterX_From = 0, fCenterY_From = 0, fWidth_From = 0, fHeight_From = 0;
                            float fCenterX_To = 0, fCenterY_To = 0, fWidth_To = 0, fHeight_To = 0;

                            switch (m_arrSampleBlobLeads[intFrom].intDirection)
                            {
                                case 4: // Top
                                    fCenterX_From = m_arrSampleBlobLeads[intFrom].fTipCenterX;
                                    fCenterY_From = m_arrSampleBlobLeads[intFrom].fTipCenterY + m_arrSampleBlobLeads[intFrom].fTipLength / 2;
                                    fWidth_From = m_arrSampleBlobLeads[intFrom].fTipWidth;
                                    fHeight_From = m_arrSampleBlobLeads[intFrom].fTipLength;
                                    break;
                                case 2: // Right
                                    fCenterX_From = m_arrSampleBlobLeads[intFrom].fTipCenterX - m_arrSampleBlobLeads[intFrom].fTipLength / 2;
                                    fCenterY_From = m_arrSampleBlobLeads[intFrom].fTipCenterY;
                                    fWidth_From = m_arrSampleBlobLeads[intFrom].fTipLength;
                                    fHeight_From = m_arrSampleBlobLeads[intFrom].fTipWidth;
                                    break;
                                case 8: // Bottom
                                    fCenterX_From = m_arrSampleBlobLeads[intFrom].fTipCenterX;
                                    fCenterY_From = m_arrSampleBlobLeads[intFrom].fTipCenterY - m_arrSampleBlobLeads[intFrom].fTipLength / 2;
                                    fWidth_From = m_arrSampleBlobLeads[intFrom].fTipWidth;
                                    fHeight_From = m_arrSampleBlobLeads[intFrom].fTipLength;
                                    break;
                                case 1: // Left
                                    fCenterX_From = m_arrSampleBlobLeads[intFrom].fTipCenterX + m_arrSampleBlobLeads[intFrom].fTipLength / 2;
                                    fCenterY_From = m_arrSampleBlobLeads[intFrom].fTipCenterY;
                                    fWidth_From = m_arrSampleBlobLeads[intFrom].fTipLength;
                                    fHeight_From = m_arrSampleBlobLeads[intFrom].fTipWidth;
                                    break;
                            }

                            switch (m_arrSampleBlobLeads[intTo].intDirection)
                            {
                                case 4: // Top
                                    fCenterX_To = m_arrSampleBlobLeads[intTo].fTipCenterX;
                                    fCenterY_To = m_arrSampleBlobLeads[intTo].fTipCenterY + m_arrSampleBlobLeads[intTo].fTipLength / 2;
                                    fWidth_To = m_arrSampleBlobLeads[intTo].fTipWidth;
                                    fHeight_To = m_arrSampleBlobLeads[intTo].fTipLength;
                                    break;
                                case 2: // Right
                                    fCenterX_To = m_arrSampleBlobLeads[intTo].fTipCenterX - m_arrSampleBlobLeads[intTo].fTipLength / 2;
                                    fCenterY_To = m_arrSampleBlobLeads[intTo].fTipCenterY;
                                    fWidth_To = m_arrSampleBlobLeads[intTo].fTipLength;
                                    fHeight_To = m_arrSampleBlobLeads[intTo].fTipWidth;
                                    break;
                                case 8: // Bottom
                                    fCenterX_To = m_arrSampleBlobLeads[intTo].fTipCenterX;
                                    fCenterY_To = m_arrSampleBlobLeads[intTo].fTipCenterY - m_arrSampleBlobLeads[intTo].fTipLength / 2;
                                    fWidth_To = m_arrSampleBlobLeads[intTo].fTipWidth;
                                    fHeight_To = m_arrSampleBlobLeads[intTo].fTipLength;
                                    break;
                                case 1: // Left
                                    fCenterX_To = m_arrSampleBlobLeads[intTo].fTipCenterX + m_arrSampleBlobLeads[intTo].fTipLength / 2;
                                    fCenterY_To = m_arrSampleBlobLeads[intTo].fTipCenterY;
                                    fWidth_To = m_arrSampleBlobLeads[intTo].fTipLength;
                                    fHeight_To = m_arrSampleBlobLeads[intTo].fTipWidth;
                                    break;
                            }

                            if (fCenterX_To > fCenterX_From)
                            {
                                fDiffX = (fCenterX_To - (fWidth_To / 2)) -
                                (fCenterX_From + (fWidth_From / 2));
                            }
                            else
                            {
                                fDiffX = (fCenterX_From - (fWidth_From / 2)) -
                                 (fCenterX_To + (fWidth_To / 2));
                            }

                            if (fCenterY_To > fCenterY_From)
                            {
                                fDiffY = (fCenterY_To - (fHeight_To / 2)) -
                                (fCenterY_From + (fHeight_From / 2));
                            }
                            else
                            {
                                fDiffY = (fCenterY_From - (fHeight_From / 2)) -
                                 (fCenterY_To + (fHeight_To / 2));
                            }

                            float fFromSize, fToSize;
                            if (fDiffX > fDiffY)
                            {
                                fGap = fDiffX;
                                //// 05-07-2019 ZJYEOH : Include offset in Gap
                                //if (m_blnWantUseGroupToleranceSetting)
                                //    fGap += ((BlobsFeatures)m_arrGroupTemplateBlobPads[((BlobsFeatures)m_arrTemplateBlobPads[intFrom]).intGroupID]).fGapOffset * m_fMMToPixelXValue;
                                //else
                                //    fGap += ((BlobsFeatures)m_arrTemplateBlobPads[intFrom]).fGapOffset * m_fMMToPixelXValue;
                                fFromSize = fWidth_From / 2;
                                fToSize = fWidth_To / 2;
                            }
                            else
                            {
                                fGap = fDiffY;
                                //// 05-07-2019 ZJYEOH : Include offset in Gap
                                //if (m_blnWantUseGroupToleranceSetting)
                                //    fGap += ((BlobsFeatures)m_arrGroupTemplateBlobPads[((BlobsFeatures)m_arrTemplateBlobPads[intFrom]).intGroupID]).fGapOffset * m_fMMToPixelYValue;
                                //else
                                //    fGap += ((BlobsFeatures)m_arrTemplateBlobPads[intFrom]).fGapOffset * m_fMMToPixelYValue;
                                fFromSize = fHeight_From / 2;
                                fToSize = fHeight_To / 2;
                            }

                            m_stcPitchGap = m_arrPitchGap[i];
                            if (m_stcPitchGap.intDirection == 0 || m_stcPitchGap.intDirection == 180)
                                fGapMM = Get2DYinMM(fGap) + m_stcBlobLead.fGapOffset;//fGap / m_fMMToPixelYValue;
                            else
                                fGapMM = Get2DXinMM(fGap) + m_stcBlobLead.fGapOffset;//fGap / m_fMMToPixelXValue;

                            bool blnGapResult;
                            //if (m_blnWantUseGroupToleranceSetting)
                            //{
                            //    int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[intFrom]).intGroupID;
                            //    if (m_blnWantTightSetting)
                            //    {
                            //        if ((fGapMM < (((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMinGap + m_fTightSettingTolerance)) || (fGapMM > (((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxGap - m_fTightSettingTolerance)))
                            //            blnGapResult = true;
                            //        else
                            //            blnGapResult = false;
                            //    }
                            //    else
                            //    {
                            //        if ((fGapMM < ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMinGap) || (fGapMM > ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxGap))
                            //            blnGapResult = true;
                            //        else
                            //            blnGapResult = false;
                            //    }
                            //}
                            //else
                            //{
                            if (m_blnWantTightSetting)
                            {
                                if ((fGapMM < (m_arrPitchGap[i].fMinGap + m_fTightSettingTolerance)) || (fGapMM > (m_arrPitchGap[i].fMaxGap - m_fTightSettingTolerance)))
                                    blnGapResult = true;
                                else
                                    blnGapResult = false;
                            }
                            else
                            {
                                if ((fGapMM < m_arrPitchGap[i].fMinGap) || (fGapMM > m_arrPitchGap[i].fMaxGap))
                                    blnGapResult = true;
                                else
                                    blnGapResult = false;
                            }
                            //}

                            if (blnGapResult && ((m_intFailOptionMask & 0x400) > 0 || (m_intFailOptionMask & 0x200) > 0))
                            {
                                m_arrFailResultMask[0] |= 0x400;
                                m_arrSampleBlobLeads[intFrom].fGap = fGap;
                                //m_arrSampleBlobPads[intFrom].intFailMask |= 0x200;
                                m_stcPitchGap.intFailMask |= 0x400;

                                if (blnResult)
                                {
                                    PitchGap objPitchGap = new PitchGap();
                                    objPitchGap.intFromLeadNo = intFrom;
                                    objPitchGap.intToLeadNo = intTo;
                                    if (m_arrPitchGap[i].intStartPointX == m_arrPitchGap[i].intEndPointX)
                                    {
                                        if (fCenterY_From > fCenterY_To)
                                        {
                                            //objPitchGap.intStartPointX = objROI.ref_ROITotalX + m_arrPitchGap[i].intStartPointX;
                                            //objPitchGap.intStartPointY = objROI.ref_ROITotalY + (int)Math.Round(m_arrSampleBlobLeads[intFrom].fTipCenterY - fFromSize, 0, MidpointRounding.AwayFromZero);
                                            //objPitchGap.intEndPointX = objROI.ref_ROITotalX + m_arrPitchGap[i].intStartPointX;
                                            //objPitchGap.intEndPointY = objROI.ref_ROITotalY + (int)Math.Round(m_arrSampleBlobLeads[intTo].fTipCenterY + fToSize, 0, MidpointRounding.AwayFromZero);
                                            if (m_arrSampleBlobLeads[intFrom].intDirection == 2)
                                                objPitchGap.intStartPointX = objROI.ref_ROITotalX + (int)Math.Round(m_arrSampleBlobLeads[intFrom].fTipCenterX - m_intTipOffset, 0, MidpointRounding.AwayFromZero);
                                            else if (m_arrSampleBlobLeads[intFrom].intDirection == 1)
                                                objPitchGap.intStartPointX = objROI.ref_ROITotalX + (int)Math.Round(m_arrSampleBlobLeads[intFrom].fTipCenterX + m_intTipOffset, 0, MidpointRounding.AwayFromZero);

                                            objPitchGap.intStartPointY = objROI.ref_ROITotalY + (int)Math.Round(m_arrSampleBlobLeads[intFrom].fTipCenterY - fFromSize, 0, MidpointRounding.AwayFromZero);

                                            if (m_arrSampleBlobLeads[intTo].intDirection == 2)
                                                objPitchGap.intEndPointX = objROI.ref_ROITotalX + (int)Math.Round(m_arrSampleBlobLeads[intTo].fTipCenterX - m_intTipOffset, 0, MidpointRounding.AwayFromZero);
                                            else if (m_arrSampleBlobLeads[intTo].intDirection == 1)
                                                objPitchGap.intEndPointX = objROI.ref_ROITotalX + (int)Math.Round(m_arrSampleBlobLeads[intTo].fTipCenterX + m_intTipOffset, 0, MidpointRounding.AwayFromZero);

                                            objPitchGap.intEndPointY = objROI.ref_ROITotalY + (int)Math.Round(m_arrSampleBlobLeads[intTo].fTipCenterY + fToSize, 0, MidpointRounding.AwayFromZero);
                                        }
                                        else
                                        {
                                            //objPitchGap.intStartPointX = objROI.ref_ROITotalX + m_arrPitchGap[i].intStartPointX;
                                            //objPitchGap.intStartPointY = objROI.ref_ROITotalY + (int)Math.Round(m_arrSampleBlobLeads[intFrom].fTipCenterY + fFromSize, 0, MidpointRounding.AwayFromZero);
                                            //objPitchGap.intEndPointX = objROI.ref_ROITotalX + m_arrPitchGap[i].intStartPointX;
                                            //objPitchGap.intEndPointY = objROI.ref_ROITotalY + (int)Math.Round(m_arrSampleBlobLeads[intTo].fTipCenterY - fToSize, 0, MidpointRounding.AwayFromZero);
                                            if (m_arrSampleBlobLeads[intFrom].intDirection == 2)
                                                objPitchGap.intStartPointX = objROI.ref_ROITotalX + (int)Math.Round(m_arrSampleBlobLeads[intFrom].fTipCenterX - m_intTipOffset, 0, MidpointRounding.AwayFromZero);
                                            else if (m_arrSampleBlobLeads[intFrom].intDirection == 1)
                                                objPitchGap.intStartPointX = objROI.ref_ROITotalX + (int)Math.Round(m_arrSampleBlobLeads[intFrom].fTipCenterX + m_intTipOffset, 0, MidpointRounding.AwayFromZero);

                                            objPitchGap.intStartPointY = objROI.ref_ROITotalY + (int)Math.Round(m_arrSampleBlobLeads[intFrom].fTipCenterY + fFromSize, 0, MidpointRounding.AwayFromZero);

                                            if (m_arrSampleBlobLeads[intTo].intDirection == 2)
                                                objPitchGap.intEndPointX = objROI.ref_ROITotalX + (int)Math.Round(m_arrSampleBlobLeads[intTo].fTipCenterX - m_intTipOffset, 0, MidpointRounding.AwayFromZero);
                                            else if (m_arrSampleBlobLeads[intTo].intDirection == 1)
                                                objPitchGap.intEndPointX = objROI.ref_ROITotalX + (int)Math.Round(m_arrSampleBlobLeads[intTo].fTipCenterX + m_intTipOffset, 0, MidpointRounding.AwayFromZero);

                                            objPitchGap.intEndPointY = objROI.ref_ROITotalY + (int)Math.Round(m_arrSampleBlobLeads[intTo].fTipCenterY - fToSize, 0, MidpointRounding.AwayFromZero);
                                        }
                                    }
                                    else
                                    {
                                        if (fCenterX_From > fCenterX_To)
                                        {
                                            //objPitchGap.intStartPointX = objROI.ref_ROITotalX + (int)Math.Round(m_arrSampleBlobLeads[intFrom].fTipCenterX - fFromSize, 0, MidpointRounding.AwayFromZero);
                                            //objPitchGap.intStartPointY = objROI.ref_ROITotalY + m_arrPitchGap[i].intStartPointY;
                                            //objPitchGap.intEndPointX = objROI.ref_ROITotalX + (int)Math.Round(m_arrSampleBlobLeads[intTo].fTipCenterX + fToSize, 0, MidpointRounding.AwayFromZero);
                                            //objPitchGap.intEndPointY = objROI.ref_ROITotalY + m_arrPitchGap[i].intStartPointY;
                                            objPitchGap.intStartPointX = objROI.ref_ROITotalX + (int)Math.Round(m_arrSampleBlobLeads[intFrom].fTipCenterX - fFromSize, 0, MidpointRounding.AwayFromZero);

                                            if (m_arrSampleBlobLeads[intFrom].intDirection == 4)
                                                objPitchGap.intStartPointY = objROI.ref_ROITotalY + (int)Math.Round(m_arrSampleBlobLeads[intFrom].fTipCenterY + m_intTipOffset, 0, MidpointRounding.AwayFromZero);
                                            else if (m_arrSampleBlobLeads[intFrom].intDirection == 8)
                                                objPitchGap.intStartPointY = objROI.ref_ROITotalY + (int)Math.Round(m_arrSampleBlobLeads[intFrom].fTipCenterY - m_intTipOffset, 0, MidpointRounding.AwayFromZero);

                                            objPitchGap.intEndPointX = objROI.ref_ROITotalX + (int)Math.Round(m_arrSampleBlobLeads[intTo].fTipCenterX + fToSize, 0, MidpointRounding.AwayFromZero);

                                            if (m_arrSampleBlobLeads[intTo].intDirection == 4)
                                                objPitchGap.intEndPointY = objROI.ref_ROITotalY + (int)Math.Round(m_arrSampleBlobLeads[intTo].fTipCenterY + m_intTipOffset, 0, MidpointRounding.AwayFromZero);
                                            else if (m_arrSampleBlobLeads[intTo].intDirection == 8)
                                                objPitchGap.intEndPointY = objROI.ref_ROITotalY + (int)Math.Round(m_arrSampleBlobLeads[intTo].fTipCenterY - m_intTipOffset, 0, MidpointRounding.AwayFromZero);
                                        }
                                        else
                                        {
                                            //objPitchGap.intStartPointX = objROI.ref_ROITotalX + (int)Math.Round(m_arrSampleBlobLeads[intFrom].fTipCenterX + fFromSize, 0, MidpointRounding.AwayFromZero);
                                            //objPitchGap.intStartPointY = objROI.ref_ROITotalY + m_arrPitchGap[i].intStartPointY;
                                            //objPitchGap.intEndPointX = objROI.ref_ROITotalX + (int)Math.Round(m_arrSampleBlobLeads[intTo].fTipCenterX - fToSize, 0, MidpointRounding.AwayFromZero);
                                            //objPitchGap.intEndPointY = objROI.ref_ROITotalY + m_arrPitchGap[i].intStartPointY;
                                            objPitchGap.intStartPointX = objROI.ref_ROITotalX + (int)Math.Round(m_arrSampleBlobLeads[intFrom].fTipCenterX + fFromSize, 0, MidpointRounding.AwayFromZero);

                                            if (m_arrSampleBlobLeads[intFrom].intDirection == 4)
                                                objPitchGap.intStartPointY = objROI.ref_ROITotalY + (int)Math.Round(m_arrSampleBlobLeads[intFrom].fTipCenterY + m_intTipOffset, 0, MidpointRounding.AwayFromZero);
                                            else if (m_arrSampleBlobLeads[intFrom].intDirection == 8)
                                                objPitchGap.intStartPointY = objROI.ref_ROITotalY + (int)Math.Round(m_arrSampleBlobLeads[intFrom].fTipCenterY - m_intTipOffset, 0, MidpointRounding.AwayFromZero);

                                            objPitchGap.intEndPointX = objROI.ref_ROITotalX + (int)Math.Round(m_arrSampleBlobLeads[intTo].fTipCenterX - fToSize, 0, MidpointRounding.AwayFromZero);

                                            if (m_arrSampleBlobLeads[intTo].intDirection == 4)
                                                objPitchGap.intEndPointY = objROI.ref_ROITotalY + (int)Math.Round(m_arrSampleBlobLeads[intTo].fTipCenterY + m_intTipOffset, 0, MidpointRounding.AwayFromZero);
                                            else if (m_arrSampleBlobLeads[intTo].intDirection == 8)
                                                objPitchGap.intEndPointY = objROI.ref_ROITotalY + (int)Math.Round(m_arrSampleBlobLeads[intTo].fTipCenterY - m_intTipOffset, 0, MidpointRounding.AwayFromZero);
                                        }
                                    }
                                    m_arrFailPitchGapList.Add(objPitchGap); // Add gap location
                                }
                            }
                            m_stcPitchGap.fGapMM = fGapMM; //m_stcPitchGap.fGapMM = fGapMM + m_stcBlobLead.fGapOffset;
                            m_arrPitchGap.RemoveAt(i);
                            m_arrPitchGap.Insert(i, m_stcPitchGap);
                            m_arrSampleBlobLeads[intFrom].fGap = fGap;


                            //Pitch Variance
                            if ((m_intFailOptionMask & 0x2000) > 0)
                            {
                                if (m_arrSampleBlobLeads[intFrom].intDirection == m_arrSampleBlobLeads[intTo].intDirection)
                                {
                                    if (intDirectionPrev != m_arrSampleBlobLeads[intFrom].intDirection)
                                    {
                                        intDirectionPrev = m_arrSampleBlobLeads[intFrom].intDirection;
                                        fPitchVarianceMax = float.MinValue;
                                        fPitchVarianceMin = float.MaxValue;
                                    }

                                    if (fPitchVarianceMax < m_stcPitchGap.fPitchMM)
                                        fPitchVarianceMax = m_stcPitchGap.fPitchMM;

                                    if (fPitchVarianceMin > m_stcPitchGap.fPitchMM)
                                        fPitchVarianceMin = m_stcPitchGap.fPitchMM;

                                    if (fPitchVarianceMax != float.MinValue && fPitchVarianceMin != float.MaxValue)
                                    {
                                        switch (m_arrSampleBlobLeads[intFrom].intDirection)
                                        {
                                            case 4:
                                                m_fPitchVarianceTopResult = fPitchVarianceMax - fPitchVarianceMin;
                                                break;
                                            case 2:
                                                m_fPitchVarianceRightResult = fPitchVarianceMax - fPitchVarianceMin;
                                                break;
                                            case 8:
                                                m_fPitchVarianceBottomResult = fPitchVarianceMax - fPitchVarianceMin;
                                                break;
                                            case 1:
                                                m_fPitchVarianceLeftResult = fPitchVarianceMax - fPitchVarianceMin;
                                                break;
                                        }
                                    }
                                }
                            }

                        }
                        else
                        {
                            m_stcPitchGap = m_arrPitchGap[i];
                            m_stcPitchGap.fPitchMM = -999;
                            m_stcPitchGap.fGapMM = -999;
                            m_arrPitchGap.RemoveAt(i);
                            m_arrPitchGap.Insert(i, m_stcPitchGap);
                            //m_arrSampleBlobLeads[intFrom].fPitch = -999;
                        }
                    }
                    else
                    {
                        m_stcPitchGap = m_arrPitchGap[i];
                        m_stcPitchGap.fPitchMM = -999;
                        m_stcPitchGap.fGapMM = -999;
                        m_arrPitchGap.RemoveAt(i);
                        m_arrPitchGap.Insert(i, m_stcPitchGap);
                        //m_arrSampleBlobLeads[intFrom].fPitch = -999;
                    }
                }

                // Pitch Variance
                if ((m_intFailOptionMask & 0x2000) > 0)
                {
                    if (m_fPitchVarianceTopResult > m_fPitchVarianceTopMaxSetting)
                        if (m_arrFailResultMask.Length > 1)
                            m_arrFailResultMask[1] |= 0x2000;//Top
                    if (m_fPitchVarianceRightResult > m_fPitchVarianceRightMaxSetting)
                        if (m_arrFailResultMask.Length > 2)
                            m_arrFailResultMask[2] |= 0x2000;//Right
                    if (m_fPitchVarianceBottomResult > m_fPitchVarianceBottomMaxSetting)
                        if (m_arrFailResultMask.Length > 3)
                            m_arrFailResultMask[3] |= 0x2000;//Bottom
                    if (m_fPitchVarianceLeftResult > m_fPitchVarianceLeftMaxSetting)
                        if (m_arrFailResultMask.Length > 4)
                            m_arrFailResultMask[4] |= 0x2000;//Left
                }
            }
            #endregion

        }

        /// <summary>
        /// Check whether sample objects fall in don't care area
        /// </summary>
        /// <param name="fCenterX">object gravity center X</param>
        /// <param name="fCenterY">object gravity center Y</param>
        /// <param name="arrDontCare">don't care area points</param>
        /// <returns>true = fall in don't care area, false = fall in don't care area</returns>
        private bool IsInDontCareArea(float fCenterX, float fCenterY, List<List<PointF>> arrDontCare)
        {
            //Check is in Don't Care area or not
            for (int j = 0; j < arrDontCare.Count; j++)
            {
                if ((fCenterX >= arrDontCare[j][0].X) && (fCenterX <= arrDontCare[j][1].X) &&
                    (fCenterY >= arrDontCare[j][0].Y) && (fCenterY <= arrDontCare[j][1].Y))
                {
                    return true;
                }
            }

            return false;
        }

        private void AddCenterPointGaugePlacementToArray_Inspection(float fCenterX, float fCenterY, float fTolerance, float fAngle, int LeadIndex)
        {
            //    TipStart = 0
            //    TipCenter = 1
            //    TipEnd = 2
            //    BaseStart = 3
            //    BaseCenter = 4
            //    BaseEnd = 5
            // 2021 05 04 - ZJYEOH : change point index to 
            // BaseCenter = 0
            // BaseStart = 1
            // BaseEnd = 2
            // Tip Center = 3
            // Tip Start = 4
            // Tip End = 5     

            m_arrLead3DCenterPointGaugeStartX[LeadIndex].Add(fCenterX);//-1
            m_arrLead3DCenterPointGaugeStartX[LeadIndex].Add(-1);
            m_arrLead3DCenterPointGaugeStartX[LeadIndex].Add(-1);
            m_arrLead3DCenterPointGaugeStartX[LeadIndex].Add(-1);
            m_arrLead3DCenterPointGaugeStartX[LeadIndex].Add(-1);//fCenterX
            m_arrLead3DCenterPointGaugeStartX[LeadIndex].Add(-1);

            m_arrLead3DCenterPointGaugeStartY[LeadIndex].Add(fCenterY);//-1
            m_arrLead3DCenterPointGaugeStartY[LeadIndex].Add(-1);
            m_arrLead3DCenterPointGaugeStartY[LeadIndex].Add(-1);
            m_arrLead3DCenterPointGaugeStartY[LeadIndex].Add(-1);
            m_arrLead3DCenterPointGaugeStartY[LeadIndex].Add(-1);//fCenterY
            m_arrLead3DCenterPointGaugeStartY[LeadIndex].Add(-1);

            m_arrLead3DCenterPointGaugeTolerance[LeadIndex].Add(fTolerance);//-1
            m_arrLead3DCenterPointGaugeTolerance[LeadIndex].Add(-1);
            m_arrLead3DCenterPointGaugeTolerance[LeadIndex].Add(-1);
            m_arrLead3DCenterPointGaugeTolerance[LeadIndex].Add(-1);
            m_arrLead3DCenterPointGaugeTolerance[LeadIndex].Add(-1);//fTolerance
            m_arrLead3DCenterPointGaugeTolerance[LeadIndex].Add(-1);

            m_arrLead3DCenterPointGaugeAngle[LeadIndex].Add(fAngle);//-1
            m_arrLead3DCenterPointGaugeAngle[LeadIndex].Add(-1);
            m_arrLead3DCenterPointGaugeAngle[LeadIndex].Add(-1);
            m_arrLead3DCenterPointGaugeAngle[LeadIndex].Add(-1);
            m_arrLead3DCenterPointGaugeAngle[LeadIndex].Add(-1);//fAngle
            m_arrLead3DCenterPointGaugeAngle[LeadIndex].Add(-1);
        }
        private void SetCenterPointGaugePlacementToArray_Inspection(float fCenterX, float fCenterY, float fTolerance, float fAngle, int intPosition, int LeadIndex)
        {
            //    TipStart = 0
            //    TipCenter = 1
            //    TipEnd = 2
            //    BaseStart = 3
            //    BaseCenter = 4
            //    BaseEnd = 5
            // 2021 05 04 - ZJYEOH : change point index to 
            // BaseCenter = 0
            // BaseStart = 1
            // BaseEnd = 2
            // Tip Center = 3
            // Tip Start = 4
            // Tip End = 5     

            m_arrLead3DCenterPointGaugeStartX[LeadIndex][intPosition] = fCenterX;
            m_arrLead3DCenterPointGaugeStartY[LeadIndex][intPosition] = fCenterY;
            m_arrLead3DCenterPointGaugeTolerance[LeadIndex][intPosition] = fTolerance;
            m_arrLead3DCenterPointGaugeAngle[LeadIndex][intPosition] = fAngle;
        }

        private void MeasureDimension_CenterLeads_UsingPkgToBaseTolerance(ROI objParentROI, ROI objROI, int intNumberOfLead, int intDirection)
        {
            float fUnitAreaWidth = objROI.ref_ROIWidth;
            float fUnitAreaHeight = objROI.ref_ROIHeight;
            //float fUnitAreaStartX = (float)Math.Round(objROI.ref_ROITotalCenterX - fUnitAreaWidth / 2, MidpointRounding.AwayFromZero) - objROI.ref_ROITotalX;// * m_fMMToPixelXValue;
            //float fUnitAreaStartY = (float)Math.Round(objROI.ref_ROITotalCenterY - fUnitAreaHeight / 2, MidpointRounding.AwayFromZero) - objROI.ref_ROITotalY;// * m_fMMToPixelYValue;
            //float fUnitAreaEndX = (float)Math.Round(objROI.ref_ROITotalCenterX + fUnitAreaWidth / 2, MidpointRounding.AwayFromZero) - objROI.ref_ROITotalX;// * m_fMMToPixelXValue;
            //float fUnitAreaEndY = (float)Math.Round(objROI.ref_ROITotalCenterY + fUnitAreaHeight / 2, MidpointRounding.AwayFromZero) - objROI.ref_ROITotalY;// * m_fMMToPixelYValue;
            float fUnitAreaStartX = objROI.ref_ROIPositionX;
            float fUnitAreaStartY = objROI.ref_ROIPositionY;
            float fUnitAreaEndX = objROI.ref_ROIPositionX + fUnitAreaWidth;
            float fUnitAreaEndY = objROI.ref_ROIPositionY + fUnitAreaHeight;
            // Testing Type:
            // 1. Match Blobs Object to Template Lead
            // 2. Find reference point of lead
            //float fTotalExtraArea = 0;
            float fLimitCenterX = 0;
            float fLimitCenterY = 0;
            float fWidth = 0;
            float fHeight = 0;
            float fOrgX = 0;
            float fOrgY = 0;
            int intTotalBlobCount = 0;
            int intArea = 0;
            float fGravityCenterX = 0;
            float fGravityCenterY = 0;
            float fStartX = 0;
            float fStartY = 0;
            float fEndX = 0;
            float fEndY = 0;
            float fBaseCenterX = 0;
            float fBaseCenterY = 0;
            float fBaseWidth = 0;
            float fBaseLength = 0;
            float fTipCenterX = 0;
            float fTipCenterY = 0;
            float fTipWidth = 0;
            float fTipLength = 0;
            float fLeadMinWidth = 0;
            float fLeadMaxWidth = 0;
            float fLeadBurrWidth = 0;
            int intFixPointXY = 0;
            int intSampleIndex = 0;
            List<int> arrSkipNo = new List<int>();
            bool blnSkipToNextObject = false;
            List<int> arrCombinedBlobNo = new List<int>();
            List<int> arrAllBlobNo = new List<int>();

            int intSelectedObjectNum = 0;
            if (m_objEBlobs.ref_intNumSelectedObject >= intNumberOfLead)
                intSelectedObjectNum = intNumberOfLead;
            else
                intSelectedObjectNum = m_objEBlobs.ref_intNumSelectedObject;

            // Assign blobs to sample arrary
            for (int i = 0; i < intSelectedObjectNum; i++)
            {
                for (int k = 0; k < arrSkipNo.Count; k++)
                {
                    if (i == arrSkipNo[k])
                    {
                        blnSkipToNextObject = true;
                        break;
                    }
                }

                if (blnSkipToNextObject)
                {
                    blnSkipToNextObject = false;
                    continue;
                }

                m_arrSampleMatchNumber.Add(-1);
                intSampleIndex = m_arrSampleMatchNumber.Count - 1;

                float fFromROIOffsetLimitCenterX = objROI.ref_ROIPositionX + m_objEBlobs.ref_arrLimitCenterX[i];
                float fFromROIOffsetLimitCenterY = objROI.ref_ROIPositionY + m_objEBlobs.ref_arrLimitCenterY[i];
                // Get blob center point, start point and size
                fWidth = m_objEBlobs.ref_arrWidth[i];
                fHeight = m_objEBlobs.ref_arrHeight[i];
                fOrgX = fFromROIOffsetLimitCenterX - fWidth / 2;
                fOrgY = fFromROIOffsetLimitCenterY - fHeight / 2;
                intArea = 0;
                fGravityCenterX = 0;
                fGravityCenterY = 0;
                fLimitCenterX = 0;
                fLimitCenterY = 0;
                fStartX = fOrgX;
                fStartY = fOrgY;
                fEndX = fOrgX + fWidth;
                fEndY = fOrgY + fHeight;
                intTotalBlobCount = 0;
                fTipWidth = 0;
                fTipLength = 0;
                fBaseWidth = 0;
                fBaseLength = 0;
                fLeadMinWidth = 0;
                fLeadMaxWidth = 0;
                fLeadBurrWidth = 0;

                // Search Is there other blobs same under same lead area.
                for (int j = i; j < m_objEBlobs.ref_intNumSelectedObject; j++)
                {
                    if (arrAllBlobNo.Count < m_objEBlobs.ref_intNumSelectedObject)
                        arrAllBlobNo.Add(j);

                    float fFromROIOffsetCenterX2 = objROI.ref_ROIPositionX + m_objEBlobs.ref_arrGravityCenterX[j];
                    float fFromROIOffsetCenterY2 = objROI.ref_ROIPositionY + m_objEBlobs.ref_arrGravityCenterY[j];
                    float fFromROIOffsetLimitCenterX2 = objROI.ref_ROIPositionX + m_objEBlobs.ref_arrLimitCenterX[j];
                    float fFromROIOffsetLimitCenterY2 = objROI.ref_ROIPositionY + m_objEBlobs.ref_arrLimitCenterY[j];

                    if (m_intLeadDirection == 0)    // Horizontal
                    {
                        //Horizontal lead
                        if (fFromROIOffsetLimitCenterY2 < fOrgY || fFromROIOffsetLimitCenterY2 > (fOrgY + fHeight))
                            continue;
                    }
                    else
                    {
                        //Vertical lead
                        if (fFromROIOffsetLimitCenterX2 < fOrgX || fFromROIOffsetLimitCenterX2 > (fOrgX + fWidth))
                            continue;
                    }

                    if (intSelectedObjectNum >= j && i != j)
                    {
                        if (m_objEBlobs.ref_intNumSelectedObject > intSelectedObjectNum)
                            intSelectedObjectNum++;
                        arrSkipNo.Add(j);
                    }

                    intArea += m_objEBlobs.ref_arrArea[j];
                    fGravityCenterX += fFromROIOffsetCenterX2 * m_objEBlobs.ref_arrArea[j];
                    fGravityCenterY += fFromROIOffsetCenterY2 * m_objEBlobs.ref_arrArea[j];

                    if (fStartX > fFromROIOffsetLimitCenterX2 - (m_objEBlobs.ref_arrWidth[j] / 2))
                    {
                        fStartX = fFromROIOffsetLimitCenterX2 - (m_objEBlobs.ref_arrWidth[j] / 2);
                    }

                    if (fStartY > fFromROIOffsetLimitCenterY2 - (m_objEBlobs.ref_arrHeight[j] / 2))
                    {
                        fStartY = fFromROIOffsetLimitCenterY2 - (m_objEBlobs.ref_arrHeight[j] / 2);
                    }

                    if (fEndX < fFromROIOffsetLimitCenterX2 + (m_objEBlobs.ref_arrWidth[j] / 2))
                    {
                        fEndX = fFromROIOffsetLimitCenterX2 + (m_objEBlobs.ref_arrWidth[j] / 2);
                    }

                    if (fEndY < fFromROIOffsetLimitCenterY2 + (m_objEBlobs.ref_arrHeight[j] / 2))
                    {
                        fEndY = fFromROIOffsetLimitCenterY2 + (m_objEBlobs.ref_arrHeight[j] / 2);
                    }

                    intTotalBlobCount++;
                    arrCombinedBlobNo.Add(j);
                }

                if (intArea == 0)
                {
                    continue;
                }
                fGravityCenterX = fGravityCenterX / intArea;
                fGravityCenterY = fGravityCenterY / intArea;
                fLimitCenterX = (fEndX + fStartX) / 2;
                fLimitCenterY = (fEndY + fStartY) / 2;
                fWidth = fEndX - fStartX;
                fHeight = fEndY - fStartY;

                // Get template number which match with sample
                List<int> arrMatch = MatchTemplateObjects_Inspection(objROI, fStartX, fStartY,
                                                        fEndX, fEndY,
                                                        fWidth, fHeight,
                                                        fBaseWidth, fBaseLength,
                                                        fTipWidth, fTipLength,
                                                        fGravityCenterX, fGravityCenterY,
                                                        intArea, intDirection);
                for (int j = 0; j < arrMatch.Count; j++)
                    m_intTemplateMatchStatus[arrMatch[j]]++;

                if (arrMatch.Count == 0)        // Set to -1 if match nothing with any template leads
                    m_arrSampleMatchNumber[intSampleIndex] = -1;
                else if (arrMatch.Count > 1)    // Set to -2 if match more than 1 template leads
                    m_arrSampleMatchNumber[intSampleIndex] = -2;
                else
                    m_arrSampleMatchNumber[intSampleIndex] = arrMatch[0];

                // No template match with sample
                if (m_arrSampleMatchNumber[intSampleIndex] == -1)
                {
                    //Extra Lead
                    if ((((m_intFailOptionMask & 0x8000) > 0) || ((m_intFailOptionMask & 0x10000) > 0)) && m_intLeadContaminationRegion != 1)
                    {
                        float fOutWidth = Math.Max(fUnitAreaStartX - fStartX, 0) + Math.Max(fEndX - fUnitAreaEndX, 0);
                        float fOutHeight = Math.Max(fUnitAreaStartY - fStartY, 0) + Math.Max(fEndY - fUnitAreaEndY, 0);

                        // check is sample under unit area range
                        if (((fWidth - fOutWidth) > 0) && ((fHeight - fOutHeight) > 0)) // both value are > 0 when it is in check area range
                        {
                            //if (m_blnWantCheckExtraLeadLength || m_blnWantCheckExtraLeadArea)
                            {
                                // Create small ROI for the extra area
                                ROI objExtraAreaROI = new ROI();
                                objExtraAreaROI.AttachImage(objROI);
                                //objExtraAreaROI.LoadROISetting((int)Math.Ceiling(fStartX + Math.Max(fUnitAreaStartX - fStartX, 0)),
                                //                               (int)Math.Ceiling(fStartY + Math.Max(fUnitAreaStartY - fStartY, 0)),
                                //                               (int)Math.Floor(fWidth - Math.Max(fUnitAreaStartX - fStartX, 0) - Math.Max(fEndX - fUnitAreaEndX, 0)),
                                //                               (int)Math.Floor(fHeight - Math.Max(fUnitAreaStartY - fStartY, 0) - Math.Max(fEndY - fUnitAreaEndY, 0)));
                                objExtraAreaROI.LoadROISetting((int)Math.Ceiling(fStartX), (int)Math.Ceiling(fStartY), (int)Math.Floor(fEndX - fStartX), (int)Math.Floor(fEndY - fStartY));

                                if (objExtraAreaROI.ref_ROIWidth > 0 && objExtraAreaROI.ref_ROIHeight > 0)
                                {
                                    m_objExtraLeadEBlobs.BuildObjects_Filter_GetElement(objExtraAreaROI, false, true, 0, m_objEBlobs.ref_intAbsoluteThreshold,
                                       m_intFilterMinArea, objExtraAreaROI.ref_ROIHeight * objExtraAreaROI.ref_ROIWidth, false, 0x0F);

                                    if (m_objExtraLeadEBlobs.ref_intNumSelectedObject > 0)
                                    {

                                        float fLimitCenterX2 = 0, fLimitCenterY2 = 0;
                                        float fFinalLimitCenterX = 0, fFinalLimitCenterY = 0;
                                        for (int k = 0; k < m_objExtraLeadEBlobs.ref_intNumSelectedObject; k++)
                                        {
                                            m_intExtraBlobID++;
                                            fLimitCenterX2 = m_objExtraLeadEBlobs.ref_arrLimitCenterX[k];
                                            fLimitCenterY2 = m_objExtraLeadEBlobs.ref_arrLimitCenterY[k];


                                            fFinalLimitCenterX = fLimitCenterX2;
                                            fFinalLimitCenterY = fLimitCenterY2;
                                            fWidth = m_objExtraLeadEBlobs.ref_arrWidth[k];
                                            fHeight = m_objExtraLeadEBlobs.ref_arrHeight[k];
                                            intArea = m_objExtraLeadEBlobs.ref_arrArea[k];

                                            // Reposition so that it offset to objROI
                                            fFinalLimitCenterX += (objROI.ref_ROIPositionX + objExtraAreaROI.ref_ROIPositionX);
                                            fFinalLimitCenterY += (objROI.ref_ROIPositionY + objExtraAreaROI.ref_ROIPositionY);

                                            // Get object start point and end point
                                            fStartX = fFinalLimitCenterX - (fWidth / 2);
                                            fStartY = fFinalLimitCenterY - (fHeight / 2);
                                            fEndX = fFinalLimitCenterX + (fWidth / 2);
                                            fEndY = fFinalLimitCenterY + (fHeight / 2);
                                            //m_blnFailForeignMaterialLength = false;
                                            //m_blnFailForeignMaterialArea = false;
                                            //m_blnFailForeignMaterialTotalArea = false;
                                            SampleExtraBlobsFeatures extra = new SampleExtraBlobsFeatures();
                                            extra.fStartX = fStartX;
                                            extra.fEndX = fEndX;
                                            extra.fStartY = fStartY;
                                            extra.fEndY = fEndY;
                                            extra.fWidth = fWidth;
                                            extra.fHeight = fHeight;
                                            extra.fCenterX = fLimitCenterX;
                                            extra.fCenterY = fLimitCenterY;
                                            extra.ref_intExtraBlobID = m_intExtraBlobID;
                                            float fWidthInMM = Get2DXinMM(fWidth);//fWidth / m_fMMToPixelXValue;
                                            float fHeightInMM = Get2DYinMM(fHeight);//fHeight / m_fMMToPixelXValue;

                                            float fArea = intArea * m_fAreaMMPerPixel;

                                            if (m_blnWantCheckExtraLeadLength)
                                            {
                                                //////////////// Check extra Lead using length limit setting ////////////////////
                                                extra.ref_fWidthFailValue = fWidthInMM;
                                                extra.ref_fHeightFailValue = fHeightInMM;

                                                if ((fWidthInMM > m_fExtraLeadSetLength) ||
                                                    (fHeightInMM > m_fExtraLeadSetLength))
                                                {

                                                    if (fWidthInMM > m_fExtraLeadSetLength)
                                                    {
                                                        extra.ref_intFailCriteria |= 0x01;
                                                        m_arrFailResultMask[0] |= 0x8000;
                                                    }

                                                    if (fHeightInMM > m_fExtraLeadSetLength)
                                                    {
                                                        extra.ref_intFailCriteria |= 0x02;
                                                        m_arrFailResultMask[0] |= 0x8000;
                                                    }
                                                    m_blnFailForeignMaterialLength = true;
                                                    // Collect extra Lead min and max area for display error message
                                                    //if ((fWidthInMM > m_fExtraLeadSetLength) &&
                                                    //(fHeightInMM > m_fExtraLeadSetLength))
                                                    //{
                                                    //    float fMin = Math.Min(fWidthInMM, fHeightInMM);
                                                    //    if ((m_fResultExtraLeadMinArea == -1) || (fMin < m_fResultExtraLeadMinArea))
                                                    //        m_fResultExtraLeadMinArea = fMin;

                                                    //    float fMax = Math.Max(fWidthInMM, fHeightInMM);
                                                    //    if ((m_fResultExtraLeadMaxArea == -1) || (fMax > m_fResultExtraLeadMaxArea))
                                                    //        m_fResultExtraLeadMaxArea = fMax;
                                                    //}
                                                    //else if (fWidthInMM > m_fExtraLeadSetLength)
                                                    //{
                                                    //    if ((m_fResultExtraLeadMinArea == -1) || (fWidthInMM < m_fResultExtraLeadMinArea))
                                                    //        m_fResultExtraLeadMinArea = fWidthInMM;
                                                    //    if ((m_fResultExtraLeadMaxArea == -1) || (fWidthInMM > m_fResultExtraLeadMaxArea))
                                                    //        m_fResultExtraLeadMaxArea = fWidthInMM;
                                                    //}
                                                    //else if (fHeightInMM > m_fExtraLeadSetLength)
                                                    //{
                                                    //    if ((m_fResultExtraLeadMinArea == -1) || (fHeightInMM < m_fResultExtraLeadMinArea))
                                                    //        m_fResultExtraLeadMinArea = fHeightInMM;
                                                    //    if ((m_fResultExtraLeadMaxArea == -1) || (fHeightInMM > m_fResultExtraLeadMaxArea))
                                                    //        m_fResultExtraLeadMaxArea = fHeightInMM;
                                                    //}
                                                }

                                            }

                                            if (m_blnWantCheckExtraLeadArea)
                                            {
                                                //////////////// Check extra Lead using area limit setting ////////////////////
                                                // Change unit pixel to mm
                                                extra.ref_fAreaFailValue = fArea;
                                                if (fArea > m_fExtraLeadSetArea)
                                                {
                                                    m_blnFailForeignMaterialArea = true;
                                                    extra.ref_intFailCriteria |= 0x04;

                                                    m_arrFailResultMask[0] |= 0x8000;
                                                    //// Collect extra Lead min and max area for display error message
                                                    //if ((m_fResultExtraLeadMinArea == -1) || (fArea < m_fResultExtraLeadMinArea))
                                                    //    m_fResultExtraLeadMinArea = fArea;
                                                    //if ((m_fResultExtraLeadMaxArea == -1) || (fArea > m_fResultExtraLeadMaxArea))
                                                    //    m_fResultExtraLeadMaxArea = fArea;
                                                }
                                                //////////////////////////////////////////////////////////////////////
                                            }

                                            //////////////// Get Total Extra pad unit area ///////////////////////////////
                                            if ((m_intFailOptionMask & 0x10000) > 0)
                                            {
                                                m_fTotalExtraArea += fArea;
                                            }

                                            if (m_blnWantCheckExtraLeadLength || m_blnWantCheckExtraLeadArea || ((m_intFailOptionMask & 0x10000) > 0))
                                                m_arrExtraBlobs.Add(extra);
                                        }

                                    }
                                    else
                                    {
                                        // Set extra area as empty if cannot find object in small ROI
                                        fWidth = 0;
                                        fHeight = 0;
                                        intArea = 0;
                                    }
                                }
                                else
                                {
                                    fWidth = 0;
                                    fHeight = 0;
                                    intArea = 0;
                                }

                                objExtraAreaROI.Dispose();
                            }


                        }
                    }
                }
                // More than 1 templates match with sample
                if (m_arrSampleMatchNumber[intSampleIndex] == -2)
                {
                    //Join/Bridge Lead
                    SampleExtraBlobsFeatures extra = new SampleExtraBlobsFeatures();
                    extra.fStartX = fStartX;
                    extra.fEndX = fEndX;
                    extra.fStartY = fStartY;
                    extra.fEndY = fEndY;
                    extra.fWidth = fWidth;
                    extra.fHeight = fHeight;
                    extra.fCenterX = fLimitCenterX;
                    extra.fCenterY = fLimitCenterY;

                    m_arrExtraBlobs.Add(extra);

                    for (int b = 0; b < arrMatch.Count; b++)
                    {
                        m_arrSampleBlobLeads[arrMatch[b]].intFailMask |= 0x10;  // Bridging or Un-Cut TieBar
                    }

                    m_arrFailResultMask[0] |= 0x10;
                }
                //Sample fall in Don't Care ROI area
                else if (m_arrSampleMatchNumber[intSampleIndex] == -3)
                {
                    return;
                }
                // Found only 1 templates match with sample
                else if (m_arrSampleMatchNumber[intSampleIndex] >= 0)
                {
                    if (m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fArea == -999)
                    {
                        m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[m_arrSampleMatchNumber[intSampleIndex]];
                        m_arrLead3DEdgeCenterGaugePointsPosition[m_arrSampleMatchNumber[intSampleIndex]] = m_stcBlobLead.intDirection;
                        switch (m_stcBlobLead.intDirection)
                        {
                            //Top
                            case 4:
                                //Base       
                                //float fTopFixPointY;
                                //PointF pTopStart;
                                //PointF pTopEnd;

                                //// Calculate the Base width and center Y
                                ////fBaseCenterY = m_pCornerPoint_Center.Y - (m_fCenterUnitHeight / 2) - m_intPkgToBaseTolerance_Top;
                                //fBaseCenterY = ((m_pCornerPoint_TopLeft.Y + m_pCornerPoint_TopRight.Y) / 2) - m_intPkgToBaseTolerance_Top;
                                //AddCenterPointGaugePlacementToArray_Inspection(-1, -1, -1, -1, m_arrSampleMatchNumber[intSampleIndex]);
                                //m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(-1, -1));
                                //m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                //m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(-1, -1));
                                //m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                //m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(-1, -1));
                                //m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);

                                //Base             
                                // ------- Find Base Point X -----------------------------------------
                                fBaseCenterY = ((m_pCornerPoint_TopLeft.Y + m_pCornerPoint_TopRight.Y) / 2) - m_intPkgToBaseTolerance_Top;

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].ref_GaugeTransType != 1)
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].ref_GaugeTransType = 1;     // Black to white

                                for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                                {
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].SetGaugePlacement(objParentROI.ref_ROITotalX + fLimitCenterX,
                                                                          fBaseCenterY,
                                                                          fHeight * (m_fPointGaugeToleranceRate * m), 90);

                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].Measure(objROI);
                                    if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                                    {
                                        AddCenterPointGaugePlacementToArray_Inspection(objParentROI.ref_ROITotalX + fLimitCenterX,
                                                                          fBaseCenterY,
                                                                          fHeight * (m_fPointGaugeToleranceRate * m), 90, m_arrSampleMatchNumber[intSampleIndex]);
                                        break;
                                    }
                                    else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                                    {
                                        AddCenterPointGaugePlacementToArray_Inspection(objParentROI.ref_ROITotalX + fLimitCenterX,
                                                                          fBaseCenterY,
                                                                          fHeight * (m_fPointGaugeToleranceRate * m), 90, m_arrSampleMatchNumber[intSampleIndex]);
                                    }
                                }

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                                {
                                    fBaseCenterX = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].GetMeasurePointX(0);
                                    if (m_blnWantUseGaugeMeasureBase)
                                        fBaseCenterY = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].GetMeasurePointY(0);
                                    m_stcBlobLead.blnBaseCenterFound = true;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(fBaseCenterX, m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].GetMeasurePointY(0)));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(true);
                                }
                                else
                                {
                                    fBaseCenterX = objParentROI.ref_ROITotalX + fLimitCenterX;
                                    if (m_blnWantUseGaugeMeasureBase)
                                        fBaseCenterY = objParentROI.ref_ROITotalY + fLimitCenterY + (fHeight / 2);
                                    m_stcBlobLead.blnBaseCenterFound = false;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(fBaseCenterX, fBaseCenterY));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                }

                                // ------- Find Base start point -----------------------------------------
                                float fTopFixPointY = fBaseCenterY - m_intBaseOffset;

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].ref_GaugeTransType != 1)
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].ref_GaugeTransType = 1;     // Black to white

                                for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                                {
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].SetGaugePlacement(fBaseCenterX - fWidth / 2,
                                                                          fTopFixPointY,
                                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180);

                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].Measure(objROI);
                                    if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fBaseCenterX - fWidth / 2,
                                                                          fTopFixPointY,
                                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.BaseStart, m_arrSampleMatchNumber[intSampleIndex]);
                                        break;
                                    }
                                    else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fBaseCenterX - fWidth / 2,
                                                                          fTopFixPointY,
                                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.BaseStart, m_arrSampleMatchNumber[intSampleIndex]);
                                    }
                                }


                                PointF pTopStart;
                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                                {
                                    pTopStart = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].GetMeasurePoint(0);
                                    m_stcBlobLead.blnBaseStartFound = true;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pTopStart.X, pTopStart.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(true);
                                }
                                else
                                {
                                    pTopStart = new PointF(fBaseCenterX - fWidth / 2, fTopFixPointY);
                                    m_stcBlobLead.blnBaseStartFound = false;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pTopStart.X, pTopStart.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                }

                                // ------- Find Base end point -----------------------------------------

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].ref_GaugeTransType != 1)
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].ref_GaugeTransType = 1;     // Black to white

                                for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                                {
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].SetGaugePlacement(fBaseCenterX + fWidth / 2,
                                                                        fTopFixPointY,
                                                                       fWidth * (m_fPointGaugeToleranceRate * m), 0);

                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].Measure(objROI);
                                    if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fBaseCenterX + fWidth / 2,
                                                                        fTopFixPointY,
                                                                       fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.BaseEnd, m_arrSampleMatchNumber[intSampleIndex]);
                                        break;
                                    }
                                    else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fBaseCenterX + fWidth / 2,
                                                                         fTopFixPointY,
                                                                        fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.BaseEnd, m_arrSampleMatchNumber[intSampleIndex]);
                                    }
                                }

                                PointF pTopEnd;
                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                                {
                                    pTopEnd = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].GetMeasurePoint(0);
                                    m_stcBlobLead.blnBaseEndFound = true;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pTopEnd.X, pTopEnd.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(true);
                                }
                                else
                                {
                                    pTopEnd = new PointF(fBaseCenterX + fWidth / 2, fTopFixPointY);
                                    m_stcBlobLead.blnBaseEndFound = false;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pTopEnd.X, pTopEnd.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                }

                                // Calculate the Base width and center X
                                fBaseWidth = pTopEnd.X - pTopStart.X;
                                fBaseCenterX = (pTopEnd.X + pTopStart.X) / 2;

                                //Tip

                                // ------- Find Tip Point X -----------------------------------------

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].ref_GaugeTransType != 1)
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].ref_GaugeTransType = 1;     // Black to white

                                for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                                {
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].SetGaugePlacement(objParentROI.ref_ROITotalX + fLimitCenterX,
                                                                           objParentROI.ref_ROITotalY + fLimitCenterY - (fHeight / 2),
                                                                          fHeight * (m_fPointGaugeToleranceRate * m), -90);

                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].Measure(objROI);
                                    if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(objParentROI.ref_ROITotalX + fLimitCenterX,
                                                                           objParentROI.ref_ROITotalY + fLimitCenterY - (fHeight / 2),
                                                                          fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.TipCenter, m_arrSampleMatchNumber[intSampleIndex]);
                                        break;
                                    }
                                    else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(objParentROI.ref_ROITotalX + fLimitCenterX,
                                                                           objParentROI.ref_ROITotalY + fLimitCenterY - (fHeight / 2),
                                                                          fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.TipCenter, m_arrSampleMatchNumber[intSampleIndex]);
                                    }
                                }


                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                                {
                                    fTipCenterX = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].GetMeasurePointX(0);
                                    fTipCenterY = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].GetMeasurePointY(0);
                                    m_stcBlobLead.blnTipCenterFound = true;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(fTipCenterX, fTipCenterY));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(true);
                                }
                                else
                                {
                                    fTipCenterX = objParentROI.ref_ROITotalX + fLimitCenterX;
                                    fTipCenterY = objParentROI.ref_ROITotalY + fLimitCenterY - (fHeight / 2);
                                    m_stcBlobLead.blnTipCenterFound = false;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(fTipCenterX, fTipCenterY));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                }

                                // ------- Find Tip start point -----------------------------------------
                                fTopFixPointY = fTipCenterY + m_intTipOffset;

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].ref_GaugeTransType != 1)
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].ref_GaugeTransType = 1;     // Black to white

                                for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                                {
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].SetGaugePlacement(fTipCenterX - fWidth / 2,
                                                                          fTopFixPointY,
                                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180);

                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].Measure(objROI);
                                    if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fTipCenterX - fWidth / 2,
                                                                          fTopFixPointY,
                                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.TipStart, m_arrSampleMatchNumber[intSampleIndex]);
                                        break;
                                    }
                                    else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fTipCenterX - fWidth / 2,
                                                                          fTopFixPointY,
                                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.TipStart, m_arrSampleMatchNumber[intSampleIndex]);
                                    }
                                }

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                                {
                                    pTopStart = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].GetMeasurePoint(0);
                                    m_stcBlobLead.blnTipStartFound = true;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pTopStart.X, pTopStart.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(true);
                                }
                                else
                                {
                                    pTopStart = new PointF(fTipCenterX - fWidth / 2, fTopFixPointY);
                                    m_stcBlobLead.blnTipStartFound = false;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pTopStart.X, pTopStart.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                }

                                // ------- Find Tip end point -----------------------------------------

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].ref_GaugeTransType != 1)
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].ref_GaugeTransType = 1;     // Black to white

                                for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                                {
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].SetGaugePlacement(fTipCenterX + fWidth / 2,
                                                                        fTopFixPointY,
                                                                       fWidth * (m_fPointGaugeToleranceRate * m), 0);

                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].Measure(objROI);
                                    if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fTipCenterX + fWidth / 2,
                                                                        fTopFixPointY,
                                                                       fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.TipEnd, m_arrSampleMatchNumber[intSampleIndex]);
                                        break;
                                    }
                                    else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fTipCenterX + fWidth / 2,
                                                                        fTopFixPointY,
                                                                       fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.TipEnd, m_arrSampleMatchNumber[intSampleIndex]);
                                    }
                                }

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                                {
                                    pTopEnd = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].GetMeasurePoint(0);
                                    m_stcBlobLead.blnTipEndFound = true;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pTopEnd.X, pTopEnd.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(true);
                                }
                                else
                                {
                                    pTopEnd = new PointF(fTipCenterX + fWidth / 2, fTopFixPointY);
                                    m_stcBlobLead.blnTipEndFound = false;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pTopEnd.X, pTopEnd.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                }

                                // ----- Find Lead min max and burr width -----------------------------------------------------------------------------
                                if ((m_intFailOptionMask & 0x100000) > 0 || (m_intFailOptionMask & 0x200000) > 0)
                                {
                                    float fTopStartMin = pTopStart.X;
                                    float fTopStartMax = pTopStart.X;
                                    float fTopEndMin = pTopEnd.X;
                                    float fTopEndMax = pTopEnd.X;

                                    // Define scanning range
                                    int intStartRangeY;
                                    int intEndRangeY;

                                    if (m_intLeadWidthRangeSelection == 0) // From shoulder to lead tip(for max) and lead offset tip(for min)
                                    {
                                        intStartRangeY = (int)Math.Ceiling(fTipCenterY);
                                        intEndRangeY = (int)Math.Round(fBaseCenterY - m_intLeadWidthRange, 0, MidpointRounding.AwayFromZero);
                                    }
                                    else // 
                                    {
                                        intStartRangeY = (int)Math.Ceiling(fTipCenterY);
                                        intEndRangeY = intStartRangeY + m_intTipOffset + m_intLeadWidthRange;
                                    }

                                    // Scan Lead start point range
                                    for (int g = intStartRangeY; g <= intEndRangeY; g++)
                                    {
                                        m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].SetGaugePlacement(fTipCenterX - fWidth / 2,
                                                                          g,
                                                                         fWidth * m_fPointGaugeToleranceRate, 180);

                                        m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].Measure(objROI);

                                        PointF p;
                                        if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                                        {
                                            p = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].GetMeasurePoint(0);

                                        }
                                        else
                                        {
                                            continue;
                                            //p = new PointF(fLeftFixPointX, fTipCenterY - (fHeight / 2));
                                        }

                                        // Min width check from lead offset tip
                                        if (g >= (intStartRangeY + m_intTipOffset))
                                        {
                                            if (fTopStartMin > p.X)
                                            {
                                                fTopStartMin = p.X;
                                            }
                                        }

                                        // Max width check from lead tip
                                        if (fTopStartMax < p.X)
                                        {
                                            fTopStartMax = p.X;
                                        }
                                    }

                                    // Scan Lead end point range
                                    for (int g = intStartRangeY; g <= intEndRangeY; g++)
                                    {
                                        m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].SetGaugePlacement(fTipCenterX + fWidth / 2,
                                                                        g,
                                                                       fWidth * m_fPointGaugeToleranceRate, 0);

                                        m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].Measure(objROI);

                                        PointF p;
                                        if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                                        {
                                            p = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].GetMeasurePoint(0);

                                        }
                                        else
                                        {
                                            continue;
                                            //p = new PointF(fLeftFixPointX, fTipCenterY + (fHeight / 2));
                                        }

                                        // Min width check from lead offset tip
                                        if (g >= (intStartRangeY + m_intTipOffset))
                                        {
                                            if (fTopEndMin > p.X)
                                            {
                                                fTopEndMin = p.X;
                                            }
                                        }

                                        // Max width check from lead tip
                                        if (fTopEndMax < p.X)
                                        {
                                            fTopEndMax = p.X;
                                        }
                                    }

                                    fLeadMinWidth = fTopEndMin - fTopStartMax;
                                    fLeadMaxWidth = fTopEndMax - fTopStartMin;
                                    fLeadBurrWidth = fLeadMaxWidth - fLeadMinWidth;
                                }

                                // Calculate the Tip width and center X
                                fTipWidth = pTopEnd.X - pTopStart.X; //fBaseWidth = 
                                fTipCenterX = (pTopEnd.X + pTopStart.X) / 2; //fBaseCenterX = 

                                // Base and Tip Length
                                fBaseLength = fBaseCenterY - fTipCenterY;
                                fTipLength = fBaseCenterY - fTipCenterY;
                                break;
                            //Right
                            case 2:
                                //Base

                                //float fRightFixPointX;
                                //PointF pRightStart;
                                //PointF pRightEnd;

                                //// Calculate the Base width and center X
                                ////fBaseCenterX = m_pCornerPoint_Center.X + (m_fCenterUnitWidth / 2) + m_intPkgToBaseTolerance_Right;
                                //fBaseCenterX = ((m_pCornerPoint_TopRight.X + m_pCornerPoint_BottomRight.X) / 2) + m_intPkgToBaseTolerance_Right;

                                //AddCenterPointGaugePlacementToArray_Inspection(-1, -1, -1, -1, m_arrSampleMatchNumber[intSampleIndex]);
                                //m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(-1, -1));
                                //m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                //m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(-1, -1));
                                //m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                //m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(-1, -1));
                                //m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);

                                //Base
                                // ------- Find Base Point Y -----------------------------------------
                                fBaseCenterX = ((m_pCornerPoint_TopRight.X + m_pCornerPoint_BottomRight.X) / 2) + m_intPkgToBaseTolerance_Right;

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].ref_GaugeTransType != 1)
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].ref_GaugeTransType = 1;     // Black to white

                                for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                                {
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].SetGaugePlacement(fBaseCenterX,
                                                                          objParentROI.ref_ROITotalY + fLimitCenterY,
                                                                          fWidth * (m_fPointGaugeToleranceRate * m), 180);

                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].Measure(objROI);
                                    if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                                    {
                                        AddCenterPointGaugePlacementToArray_Inspection(fBaseCenterX,
                                                                         objParentROI.ref_ROITotalY + fLimitCenterY,
                                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180, m_arrSampleMatchNumber[intSampleIndex]);
                                        break;
                                    }
                                    else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                                    {
                                        AddCenterPointGaugePlacementToArray_Inspection(fBaseCenterX,
                                                                         objParentROI.ref_ROITotalY + fLimitCenterY,
                                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180, m_arrSampleMatchNumber[intSampleIndex]);
                                    }
                                }


                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                                {
                                    if (m_blnWantUseGaugeMeasureBase)
                                        fBaseCenterX = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].GetMeasurePointX(0);
                                    fBaseCenterY = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].GetMeasurePointY(0);
                                    m_stcBlobLead.blnBaseCenterFound = true;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].GetMeasurePointX(0), fBaseCenterY));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(true);
                                }
                                else
                                {
                                    if (m_blnWantUseGaugeMeasureBase)
                                        fBaseCenterX = objParentROI.ref_ROITotalX + fLimitCenterX - (fWidth / 2);
                                    fBaseCenterY = objParentROI.ref_ROITotalY + fLimitCenterY;
                                    m_stcBlobLead.blnBaseCenterFound = false;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(fBaseCenterX, fBaseCenterY));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                }

                                // ------- Find Base start point -----------------------------------------
                                float fRightFixPointX = fBaseCenterX + m_intBaseOffset;

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].ref_GaugeTransType != 1)
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].ref_GaugeTransType = 1;     // Black to white

                                for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                                {
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].SetGaugePlacement(fRightFixPointX,
                                                                          fBaseCenterY - fHeight / 2,
                                                                         fHeight * (m_fPointGaugeToleranceRate * m), -90);

                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].Measure(objROI);
                                    if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fRightFixPointX,
                                                                          fBaseCenterY - fHeight / 2,
                                                                         fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.BaseStart, m_arrSampleMatchNumber[intSampleIndex]);
                                        break;
                                    }
                                    else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fRightFixPointX,
                                                                          fBaseCenterY - fHeight / 2,
                                                                         fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.BaseStart, m_arrSampleMatchNumber[intSampleIndex]);
                                    }
                                }


                                PointF pRightStart;
                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                                {
                                    pRightStart = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].GetMeasurePoint(0);
                                    m_stcBlobLead.blnBaseStartFound = true;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pRightStart.X, pRightStart.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(true);
                                }
                                else
                                {
                                    pRightStart = new PointF(fRightFixPointX, fBaseCenterY - fHeight / 2);
                                    m_stcBlobLead.blnBaseStartFound = false;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pRightStart.X, pRightStart.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                }

                                // ------- Find Base end point -----------------------------------------                                

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].ref_GaugeTransType != 1)
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].ref_GaugeTransType = 1;     // Black to white

                                for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                                {
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].SetGaugePlacement(fRightFixPointX,
                                                                        fBaseCenterY + fHeight / 2,
                                                                       fHeight * (m_fPointGaugeToleranceRate * m), 90);

                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].Measure(objROI);
                                    if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fRightFixPointX,
                                                                        fBaseCenterY + fHeight / 2,
                                                                       fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.BaseEnd, m_arrSampleMatchNumber[intSampleIndex]);
                                        break;
                                    }
                                    else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fRightFixPointX,
                                                                        fBaseCenterY + fHeight / 2,
                                                                       fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.BaseEnd, m_arrSampleMatchNumber[intSampleIndex]);
                                    }
                                }

                                PointF pRightEnd;
                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                                {
                                    pRightEnd = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].GetMeasurePoint(0);
                                    m_stcBlobLead.blnBaseEndFound = true;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pRightEnd.X, pRightEnd.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(true);
                                }
                                else
                                {
                                    pRightEnd = new PointF(fRightFixPointX, fBaseCenterY + fHeight / 2);
                                    m_stcBlobLead.blnBaseEndFound = false;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pRightEnd.X, pRightEnd.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                }

                                // Calculate the Base width and center Y
                                fBaseWidth = pRightEnd.Y - pRightStart.Y;
                                fBaseCenterY = (pRightEnd.Y + pRightStart.Y) / 2;


                                //Tip
                                // ------- Find Tip Point X -----------------------------------------

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].ref_GaugeTransType != 1)
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].ref_GaugeTransType = 1;     // Black to white

                                for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                                {
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].SetGaugePlacement(objParentROI.ref_ROITotalX + fLimitCenterX + (fWidth / 2),
                                                                        objParentROI.ref_ROITotalY + fLimitCenterY,
                                                                        fWidth * (m_fPointGaugeToleranceRate * m), 0);

                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].Measure(objROI);
                                    if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(objParentROI.ref_ROITotalX + fLimitCenterX + (fWidth / 2),
                                                                       objParentROI.ref_ROITotalY + fLimitCenterY,
                                                                       fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.TipCenter, m_arrSampleMatchNumber[intSampleIndex]);
                                        break;
                                    }
                                    else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(objParentROI.ref_ROITotalX + fLimitCenterX + (fWidth / 2),
                                                                        objParentROI.ref_ROITotalY + fLimitCenterY,
                                                                        fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.TipCenter, m_arrSampleMatchNumber[intSampleIndex]);
                                    }
                                }


                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                                {
                                    fTipCenterX = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].GetMeasurePointX(0);
                                    fTipCenterY = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].GetMeasurePointY(0);
                                    m_stcBlobLead.blnTipCenterFound = true;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(fTipCenterX, fTipCenterY));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(true);
                                }
                                else
                                {
                                    fTipCenterX = objParentROI.ref_ROITotalX + fLimitCenterX + (fWidth / 2);
                                    fTipCenterY = objParentROI.ref_ROITotalY + fLimitCenterY;
                                    m_stcBlobLead.blnTipCenterFound = false;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(fTipCenterX, fTipCenterY));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                }

                                // ------- Find Tip start point -----------------------------------------
                                fRightFixPointX = fTipCenterX - m_intTipOffset;

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].ref_GaugeTransType != 1)
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].ref_GaugeTransType = 1;     // Black to white

                                for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                                {
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].SetGaugePlacement(fRightFixPointX,
                                                                        fTipCenterY - (fHeight / 2),
                                                                        fHeight * (m_fPointGaugeToleranceRate * m), -90);

                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].Measure(objROI);
                                    if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fRightFixPointX,
                                                                         fTipCenterY - (fHeight / 2),
                                                                        fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.TipStart, m_arrSampleMatchNumber[intSampleIndex]);
                                        break;
                                    }
                                    else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fRightFixPointX,
                                                                         fTipCenterY - (fHeight / 2),
                                                                        fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.TipStart, m_arrSampleMatchNumber[intSampleIndex]);
                                    }
                                }

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                                {
                                    pRightStart = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].GetMeasurePoint(0);
                                    m_stcBlobLead.blnTipStartFound = true;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pRightStart.X, pRightStart.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(true);
                                }
                                else
                                {
                                    pRightStart = new PointF(fRightFixPointX, fTipCenterY - (fHeight / 2));
                                    m_stcBlobLead.blnTipStartFound = false;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pRightStart.X, pRightStart.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                }

                                // ------- Find Tip end point -----------------------------------------

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].ref_GaugeTransType != 1)
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].ref_GaugeTransType = 1;     // Black to white

                                for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                                {
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].SetGaugePlacement(fRightFixPointX,
                                                                             fTipCenterY + (fHeight / 2),
                                                                             fHeight * (m_fPointGaugeToleranceRate * m), 90);
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].Measure(objROI);
                                    if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fRightFixPointX,
                                                                            fTipCenterY + (fHeight / 2),
                                                                            fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.TipEnd, m_arrSampleMatchNumber[intSampleIndex]);
                                        break;
                                    }
                                    else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fRightFixPointX,
                                                                             fTipCenterY + (fHeight / 2),
                                                                             fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.TipEnd, m_arrSampleMatchNumber[intSampleIndex]);
                                    }
                                }


                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                                {
                                    pRightEnd = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].GetMeasurePoint(0);
                                    m_stcBlobLead.blnTipEndFound = true;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pRightEnd.X, pRightEnd.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(true);
                                }
                                else
                                {
                                    pRightEnd = new PointF(fRightFixPointX, fTipCenterY + (fHeight / 2));
                                    m_stcBlobLead.blnTipEndFound = false;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pRightEnd.X, pRightEnd.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                }

                                // ----- Find Lead min max and burr width -----------------------------------------------------------------------------
                                if ((m_intFailOptionMask & 0x100000) > 0 || (m_intFailOptionMask & 0x200000) > 0)
                                {
                                    float fRightStartMin = pRightStart.Y;
                                    float fRightStartMax = pRightStart.Y;
                                    float fRightEndMin = pRightEnd.Y;
                                    float fRightEndMax = pRightEnd.Y;

                                    // Define scanning range
                                    int intStartRangeX;
                                    int intEndRangeX;

                                    if (m_intLeadWidthRangeSelection == 0) // From shoulder to lead tip(for max) and lead offset tip(for min)
                                    {
                                        intStartRangeX = (int)Math.Ceiling(fTipCenterX);
                                        intEndRangeX = (int)Math.Round(fBaseCenterX + m_intLeadWidthRange, 0, MidpointRounding.AwayFromZero);
                                    }
                                    else // 
                                    {
                                        intStartRangeX = (int)Math.Ceiling(fTipCenterX);
                                        intEndRangeX = intStartRangeX - m_intTipOffset - m_intLeadWidthRange;
                                    }

                                    // Scan Lead start point range
                                    for (int g = intStartRangeX; g >= intEndRangeX; g--)
                                    {
                                        m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].SetGaugePlacement(g,
                                                                               fTipCenterY - (fHeight / 2),
                                                                               fHeight * m_fPointGaugeToleranceRate, -90);

                                        m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].Measure(objROI);

                                        PointF p;
                                        if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                                        {
                                            p = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].GetMeasurePoint(0);

                                        }
                                        else
                                        {
                                            continue;
                                            //p = new PointF(fLeftFixPointX, fTipCenterY - (fHeight / 2));
                                        }

                                        // Min width check from lead offset tip
                                        if (g <= (intStartRangeX - m_intTipOffset))
                                        {
                                            if (fRightStartMin > p.Y)
                                            {
                                                fRightStartMin = p.Y;
                                            }
                                        }

                                        // Max width check from lead tip
                                        if (fRightStartMax < p.Y)
                                        {
                                            fRightStartMax = p.Y;
                                        }
                                    }

                                    // Scan Lead end point range
                                    for (int g = intStartRangeX; g >= intEndRangeX; g--)
                                    {
                                        m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].SetGaugePlacement(g,
                                                                             fTipCenterY + (fHeight / 2),
                                                                             fHeight * m_fPointGaugeToleranceRate, 90);

                                        m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].Measure(objROI);

                                        PointF p;
                                        if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                                        {
                                            p = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].GetMeasurePoint(0);

                                        }
                                        else
                                        {
                                            continue;
                                            //p = new PointF(fLeftFixPointX, fTipCenterY + (fHeight / 2));
                                        }

                                        // Min width check from lead offset tip
                                        if (g <= (intStartRangeX - m_intTipOffset))
                                        {
                                            if (fRightEndMin > p.Y)
                                            {
                                                fRightEndMin = p.Y;
                                            }
                                        }

                                        // Max width check from lead tip
                                        if (fRightEndMax < p.Y)
                                        {
                                            fRightEndMax = p.Y;
                                        }
                                    }

                                    fLeadMinWidth = fRightEndMin - fRightStartMax;
                                    fLeadMaxWidth = fRightEndMax - fRightStartMin;
                                    fLeadBurrWidth = fLeadMaxWidth - fLeadMinWidth;
                                }

                                // Calculate the Tip width and center Y
                                fTipWidth = pRightEnd.Y - pRightStart.Y; //fBaseWidth = 
                                fTipCenterY = (pRightEnd.Y + pRightStart.Y) / 2; //fBaseCenterY = 

                                // Base and Tip Length
                                fBaseLength = fTipCenterX - fBaseCenterX;
                                fTipLength = fTipCenterX - fBaseCenterX;

                                break;
                            //Bottom
                            case 8:
                                //Base

                                //float fBottomFixPointY;
                                //PointF pBottomStart;
                                //PointF pBottomEnd;

                                //// Calculate the Base width and center Y
                                ////fBaseCenterY = m_pCornerPoint_Center.Y + (m_fCenterUnitHeight / 2) + m_intPkgToBaseTolerance_Bottom;
                                //fBaseCenterY = ((m_pCornerPoint_BottomRight.Y + m_pCornerPoint_BottomLeft.Y) / 2) + m_intPkgToBaseTolerance_Bottom;
                                //AddCenterPointGaugePlacementToArray_Inspection(-1, -1, -1, -1, m_arrSampleMatchNumber[intSampleIndex]);
                                //m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(-1, -1));
                                //m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                //m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(-1, -1));
                                //m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                //m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(-1, -1));
                                //m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);

                                //Base
                                fBaseCenterY = ((m_pCornerPoint_BottomRight.Y + m_pCornerPoint_BottomLeft.Y) / 2) + m_intPkgToBaseTolerance_Bottom;
                                // ------- Find Base Point X -----------------------------------------

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].ref_GaugeTransType != 1)
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].ref_GaugeTransType = 1;     // Black to white

                                for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                                {
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].SetGaugePlacement(objParentROI.ref_ROITotalX + fLimitCenterX,
                                                                          fBaseCenterY,
                                                                          fHeight * (m_fPointGaugeToleranceRate * m), -90);

                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].Measure(objROI);
                                    if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                                    {
                                        AddCenterPointGaugePlacementToArray_Inspection(objParentROI.ref_ROITotalX + fLimitCenterX,
                                                                          fBaseCenterY,
                                                                          fHeight * (m_fPointGaugeToleranceRate * m), -90, m_arrSampleMatchNumber[intSampleIndex]);
                                        break;
                                    }
                                    else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                                    {
                                        AddCenterPointGaugePlacementToArray_Inspection(objParentROI.ref_ROITotalX + fLimitCenterX,
                                                                          fBaseCenterY,
                                                                          fHeight * (m_fPointGaugeToleranceRate * m), -90, m_arrSampleMatchNumber[intSampleIndex]);
                                    }
                                }


                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                                {
                                    fBaseCenterX = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].GetMeasurePointX(0);
                                    if (m_blnWantUseGaugeMeasureBase)
                                        fBaseCenterY = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].GetMeasurePointY(0);
                                    m_stcBlobLead.blnBaseCenterFound = true;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(fBaseCenterX, m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].GetMeasurePointY(0)));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(true);
                                }
                                else
                                {
                                    fBaseCenterX = objParentROI.ref_ROITotalX + fLimitCenterX;
                                    if (m_blnWantUseGaugeMeasureBase)
                                        fBaseCenterY = objParentROI.ref_ROITotalY + fLimitCenterY - (fHeight / 2);
                                    m_stcBlobLead.blnBaseCenterFound = false;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(fBaseCenterX, fBaseCenterY));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                }

                                // ------- Find Base start point -----------------------------------------
                                float fBottomFixPointY = fBaseCenterY + m_intBaseOffset;

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].ref_GaugeTransType != 1)
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].ref_GaugeTransType = 1;     // Black to white

                                for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                                {
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].SetGaugePlacement(fBaseCenterX - fWidth / 2,
                                                                           fBottomFixPointY,
                                                                          fWidth * (m_fPointGaugeToleranceRate * m), 180);
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].Measure(objROI);
                                    if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fBaseCenterX - fWidth / 2,
                                                                          fBottomFixPointY,
                                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.BaseStart, m_arrSampleMatchNumber[intSampleIndex]);
                                        break;
                                    }
                                    else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fBaseCenterX - fWidth / 2,
                                                                           fBottomFixPointY,
                                                                          fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.BaseStart, m_arrSampleMatchNumber[intSampleIndex]);
                                    }
                                }


                                PointF pBottomStart;
                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                                {
                                    pBottomStart = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].GetMeasurePoint(0);
                                    m_stcBlobLead.blnBaseStartFound = true;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pBottomStart.X, pBottomStart.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(true);
                                }
                                else
                                {
                                    pBottomStart = new PointF(fBaseCenterX - fWidth / 2, fBottomFixPointY);
                                    m_stcBlobLead.blnBaseStartFound = false;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pBottomStart.X, pBottomStart.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                }

                                // ------- Find Base end point -----------------------------------------

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].ref_GaugeTransType != 1)
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].ref_GaugeTransType = 1;     // Black to white

                                for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                                {
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].SetGaugePlacement(fBaseCenterX + fWidth / 2,
                                                                       fBottomFixPointY,
                                                                      fWidth * (m_fPointGaugeToleranceRate * m), 0);

                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].Measure(objROI);
                                    if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fBaseCenterX + fWidth / 2,
                                                                        fBottomFixPointY,
                                                                       fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.BaseEnd, m_arrSampleMatchNumber[intSampleIndex]);
                                        break;
                                    }
                                    else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fBaseCenterX + fWidth / 2,
                                                                        fBottomFixPointY,
                                                                       fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.BaseEnd, m_arrSampleMatchNumber[intSampleIndex]);
                                    }
                                }


                                PointF pBottomEnd;
                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                                {
                                    pBottomEnd = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].GetMeasurePoint(0);
                                    m_stcBlobLead.blnBaseEndFound = true;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pBottomEnd.X, pBottomEnd.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(true);
                                }
                                else
                                {
                                    pBottomEnd = new PointF(fBaseCenterX + fWidth / 2, fBottomFixPointY);
                                    m_stcBlobLead.blnBaseEndFound = false;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pBottomEnd.X, pBottomEnd.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                }

                                // Calculate the Base width and center X
                                fBaseWidth = pBottomEnd.X - pBottomStart.X;
                                fBaseCenterX = (pBottomEnd.X + pBottomStart.X) / 2;


                                //Tip
                                // ------- Find Tip Point X -----------------------------------------

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].ref_GaugeTransType != 1)
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].ref_GaugeTransType = 1;     // Black to white

                                for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                                {
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].SetGaugePlacement(objParentROI.ref_ROITotalX + fLimitCenterX,
                                                                          objParentROI.ref_ROITotalY + fLimitCenterY + (fHeight / 2),
                                                                          fHeight * (m_fPointGaugeToleranceRate * m), 90);

                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].Measure(objROI);
                                    if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(objParentROI.ref_ROITotalX + fLimitCenterX,
                                                                          objParentROI.ref_ROITotalY + fLimitCenterY + (fHeight / 2),
                                                                          fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.TipCenter, m_arrSampleMatchNumber[intSampleIndex]);
                                        break;
                                    }
                                    else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(objParentROI.ref_ROITotalX + fLimitCenterX,
                                                                          objParentROI.ref_ROITotalY + fLimitCenterY + (fHeight / 2),
                                                                          fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.TipCenter, m_arrSampleMatchNumber[intSampleIndex]);
                                    }
                                }

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                                {
                                    fTipCenterX = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].GetMeasurePointX(0);
                                    fTipCenterY = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].GetMeasurePointY(0);
                                    m_stcBlobLead.blnTipCenterFound = true;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(fTipCenterX, fTipCenterY));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(true);
                                }
                                else
                                {
                                    fTipCenterX = objParentROI.ref_ROITotalX + fLimitCenterX;
                                    fTipCenterY = objParentROI.ref_ROITotalY + fLimitCenterY + (fHeight / 2);
                                    m_stcBlobLead.blnTipCenterFound = false;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(fTipCenterX, fTipCenterY));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                }

                                // ------- Find Tip start point -----------------------------------------
                                fBottomFixPointY = fTipCenterY - m_intTipOffset;

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].ref_GaugeTransType != 1)
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].ref_GaugeTransType = 1;     // Black to white

                                for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                                {
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].SetGaugePlacement(fTipCenterX - fWidth / 2,
                                                                          fBottomFixPointY,
                                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180);

                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].Measure(objROI);
                                    if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fTipCenterX - fWidth / 2,
                                                                          fBottomFixPointY,
                                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.TipStart, m_arrSampleMatchNumber[intSampleIndex]);
                                        break;
                                    }
                                    else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fTipCenterX - fWidth / 2,
                                                                          fBottomFixPointY,
                                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.TipStart, m_arrSampleMatchNumber[intSampleIndex]);
                                    }
                                }


                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                                {
                                    pBottomStart = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].GetMeasurePoint(0);
                                    m_stcBlobLead.blnTipStartFound = true;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pBottomStart.X, pBottomStart.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(true);
                                }
                                else
                                {
                                    pBottomStart = new PointF(fTipCenterX - fWidth / 2, fBottomFixPointY);
                                    m_stcBlobLead.blnTipStartFound = false;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pBottomStart.X, pBottomStart.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                }

                                // ------- Find Tip end point -----------------------------------------

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].ref_GaugeTransType != 1)
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].ref_GaugeTransType = 1;     // Black to white

                                for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                                {
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].SetGaugePlacement(fTipCenterX + fWidth / 2,
                                                                         fBottomFixPointY,
                                                                        fWidth * (m_fPointGaugeToleranceRate * m), 0);

                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].Measure(objROI);
                                    if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fTipCenterX + fWidth / 2,
                                                                        fBottomFixPointY,
                                                                       fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.TipEnd, m_arrSampleMatchNumber[intSampleIndex]);
                                        break;
                                    }
                                    else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fTipCenterX + fWidth / 2,
                                                                         fBottomFixPointY,
                                                                        fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.TipEnd, m_arrSampleMatchNumber[intSampleIndex]);
                                    }
                                }

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                                {
                                    pBottomEnd = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].GetMeasurePoint(0);
                                    m_stcBlobLead.blnTipEndFound = true;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pBottomEnd.X, pBottomEnd.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(true);
                                }
                                else
                                {
                                    pBottomEnd = new PointF(fTipCenterX + fWidth / 2, fBottomFixPointY);
                                    m_stcBlobLead.blnTipEndFound = false;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pBottomEnd.X, pBottomEnd.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                }

                                // ----- Find Lead min max and burr width -----------------------------------------------------------------------------
                                if ((m_intFailOptionMask & 0x100000) > 0 || (m_intFailOptionMask & 0x200000) > 0)
                                {
                                    float fBottomStartMin = pBottomStart.X;
                                    float fBottomStartMax = pBottomStart.X;
                                    float fBottomEndMin = pBottomEnd.X;
                                    float fBottomEndMax = pBottomEnd.X;

                                    // Define scanning range
                                    int intStartRangeY;
                                    int intEndRangeY;

                                    if (m_intLeadWidthRangeSelection == 0) // From shoulder to lead tip(for max) and lead offset tip(for min)
                                    {
                                        intStartRangeY = (int)Math.Ceiling(fTipCenterY);
                                        intEndRangeY = (int)Math.Round(fBaseCenterY + m_intLeadWidthRange, 0, MidpointRounding.AwayFromZero);
                                    }
                                    else // 
                                    {
                                        intStartRangeY = (int)Math.Ceiling(fTipCenterY);
                                        intEndRangeY = intStartRangeY - m_intTipOffset - m_intLeadWidthRange;
                                    }

                                    // Scan Lead start point range
                                    for (int g = intStartRangeY; g >= intEndRangeY; g--)
                                    {
                                        m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].SetGaugePlacement(fTipCenterX - fWidth / 2,
                                                                          g,
                                                                         fWidth * m_fPointGaugeToleranceRate, 180);

                                        m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].Measure(objROI);

                                        PointF p;
                                        if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                                        {
                                            p = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].GetMeasurePoint(0);

                                        }
                                        else
                                        {
                                            continue;
                                            //p = new PointF(fLeftFixPointX, fTipCenterY - (fHeight / 2));
                                        }

                                        // Min width check from lead offset tip
                                        if (g <= (intStartRangeY - m_intTipOffset))
                                        {
                                            if (fBottomStartMin > p.X)
                                            {
                                                fBottomStartMin = p.X;
                                            }
                                        }

                                        // Max width check from lead tip
                                        if (fBottomStartMax < p.X)
                                        {
                                            fBottomStartMax = p.X;
                                        }
                                    }

                                    // Scan Lead end point range
                                    for (int g = intStartRangeY; g >= intEndRangeY; g--)
                                    {
                                        m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].SetGaugePlacement(fTipCenterX + fWidth / 2,
                                                                g,
                                                               fWidth * m_fPointGaugeToleranceRate, 0);

                                        m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].Measure(objROI);

                                        PointF p;
                                        if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                                        {
                                            p = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].GetMeasurePoint(0);

                                        }
                                        else
                                        {
                                            continue;
                                            //p = new PointF(fLeftFixPointX, fTipCenterY + (fHeight / 2));
                                        }

                                        // Min width check from lead offset tip
                                        if (g <= (intStartRangeY - m_intTipOffset))
                                        {
                                            if (fBottomEndMin > p.X)
                                            {
                                                fBottomEndMin = p.X;
                                            }
                                        }

                                        // Max width check from lead tip
                                        if (fBottomEndMax < p.X)
                                        {
                                            fBottomEndMax = p.X;
                                        }
                                    }

                                    fLeadMinWidth = fBottomEndMin - fBottomStartMax;
                                    fLeadMaxWidth = fBottomEndMax - fBottomStartMin;
                                    fLeadBurrWidth = fLeadMaxWidth - fLeadMinWidth;
                                }

                                // Calculate the Tip width and center X
                                fTipWidth = pBottomEnd.X - pBottomStart.X; //fBaseWidth = 
                                fTipCenterX = (pBottomEnd.X + pBottomStart.X) / 2; //fBaseCenterX = 
                                // Base and Tip Length
                                fBaseLength = fTipCenterY - fBaseCenterY;
                                fTipLength = fTipCenterY - fBaseCenterY;
                                break;
                            //Left
                            case 1:
                                //Base

                                //float fLeftFixPointX;
                                //PointF pLeftStart;
                                //PointF pLeftEnd;

                                //// Calculate the Base width and center X
                                ////fBaseCenterX = m_pCornerPoint_Center.X - (m_fCenterUnitWidth / 2) - m_intPkgToBaseTolerance_Left;
                                //fBaseCenterX = ((m_pCornerPoint_BottomLeft.X + m_pCornerPoint_TopLeft.X) / 2) - m_intPkgToBaseTolerance_Left;
                                //AddCenterPointGaugePlacementToArray_Inspection(-1, -1, -1, -1, m_arrSampleMatchNumber[intSampleIndex]);
                                //m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(-1, -1));
                                //m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                //m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(-1, -1));
                                //m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                //m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(-1, -1));
                                //m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);

                                //Base
                                fBaseCenterX = ((m_pCornerPoint_BottomLeft.X + m_pCornerPoint_TopLeft.X) / 2) - m_intPkgToBaseTolerance_Left;
                                // ------- Find Base Point Y -----------------------------------------

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].ref_GaugeTransType != 1)
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].ref_GaugeTransType = 1;     // Black to white

                                for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                                {
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].SetGaugePlacement(fBaseCenterX,
                                                                          objParentROI.ref_ROITotalY + fLimitCenterY,
                                                                           fWidth * (m_fPointGaugeToleranceRate * m), 0);

                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].Measure(objROI);
                                    if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                                    {
                                        AddCenterPointGaugePlacementToArray_Inspection(fBaseCenterX,
                                                                         objParentROI.ref_ROITotalY + fLimitCenterY,
                                                                          fWidth * (m_fPointGaugeToleranceRate * m), 0, m_arrSampleMatchNumber[intSampleIndex]);
                                        break;
                                    }
                                    else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                                    {
                                        AddCenterPointGaugePlacementToArray_Inspection(fBaseCenterX,
                                                                           objParentROI.ref_ROITotalY + fLimitCenterY,
                                                                            fWidth * (m_fPointGaugeToleranceRate * m), 0, m_arrSampleMatchNumber[intSampleIndex]);
                                    }
                                }


                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                                {
                                    if (m_blnWantUseGaugeMeasureBase)
                                        fBaseCenterX = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].GetMeasurePointX(0);
                                    fBaseCenterY = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].GetMeasurePointY(0);
                                    m_stcBlobLead.blnBaseCenterFound = true;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].GetMeasurePointX(0), fBaseCenterY));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(true);
                                }
                                else
                                {
                                    if (m_blnWantUseGaugeMeasureBase)
                                        fBaseCenterX = objParentROI.ref_ROITotalX + fLimitCenterX + (fWidth / 2);
                                    fBaseCenterY = objParentROI.ref_ROITotalY + fLimitCenterY;
                                    m_stcBlobLead.blnBaseCenterFound = false;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(fBaseCenterX, fBaseCenterY));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                }

                                // ------- Find Base start point -----------------------------------------
                                float fLeftFixPointX = fBaseCenterX - m_intBaseOffset;

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].ref_GaugeTransType != 1)
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].ref_GaugeTransType = 1;     // Black to white

                                for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                                {
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].SetGaugePlacement(fLeftFixPointX,
                                                                          fBaseCenterY - fHeight / 2,
                                                                         fHeight * (m_fPointGaugeToleranceRate * m), -90);

                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].Measure(objROI);
                                    if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fLeftFixPointX,
                                                                          fBaseCenterY - fHeight / 2,
                                                                         fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.BaseStart, m_arrSampleMatchNumber[intSampleIndex]);
                                        break;
                                    }
                                    else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fLeftFixPointX,
                                                                          fBaseCenterY - fHeight / 2,
                                                                         fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.BaseStart, m_arrSampleMatchNumber[intSampleIndex]);
                                    }
                                }

                                PointF pLeftStart;
                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                                {
                                    pLeftStart = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].GetMeasurePoint(0);
                                    m_stcBlobLead.blnBaseStartFound = true;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pLeftStart.X, pLeftStart.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(true);
                                }
                                else
                                {
                                    pLeftStart = new PointF(fLeftFixPointX, fBaseCenterY - fHeight / 2);
                                    m_stcBlobLead.blnBaseStartFound = false;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pLeftStart.X, pLeftStart.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                }

                                // ------- Find Base end point -----------------------------------------

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].ref_GaugeTransType != 1)
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].ref_GaugeTransType = 1;     // Black to white

                                for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                                {
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].SetGaugePlacement(fLeftFixPointX,
                                                                        fBaseCenterY + fHeight / 2,
                                                                       fHeight * (m_fPointGaugeToleranceRate * m), 90);

                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].Measure(objROI);
                                    if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fLeftFixPointX,
                                                                        fBaseCenterY + fHeight / 2,
                                                                       fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.BaseEnd, m_arrSampleMatchNumber[intSampleIndex]);
                                        break;
                                    }
                                    else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fLeftFixPointX,
                                                                        fBaseCenterY + fHeight / 2,
                                                                       fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.BaseEnd, m_arrSampleMatchNumber[intSampleIndex]);
                                    }
                                }


                                PointF pLeftEnd;
                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                                {
                                    pLeftEnd = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].GetMeasurePoint(0);
                                    m_stcBlobLead.blnBaseEndFound = true;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pLeftEnd.X, pLeftEnd.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(true);
                                }
                                else
                                {
                                    pLeftEnd = new PointF(fLeftFixPointX, fBaseCenterY + fHeight / 2);
                                    m_stcBlobLead.blnBaseEndFound = false;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pLeftEnd.X, pLeftEnd.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                }

                                // Calculate the Base width center Y
                                fBaseWidth = pLeftEnd.Y - pLeftStart.Y;
                                fBaseCenterY = (pLeftEnd.Y + pLeftStart.Y) / 2;

                                //Tip
                                //objParentROI.ref_ROI.TopParent.Save("D:\\TS\\TopParent.bmp");
                                // ------- Find Tip Point X -----------------------------------------

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].ref_GaugeTransType != 1)
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].ref_GaugeTransType = 1;     // Black to white

                                for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                                {
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].SetGaugePlacement(objParentROI.ref_ROITotalX + fLimitCenterX - (fWidth / 2),
                                                                       objParentROI.ref_ROITotalY + fLimitCenterY,
                                                                        fWidth * (m_fPointGaugeToleranceRate * m), 180);

                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].Measure(objROI);
                                    if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(objParentROI.ref_ROITotalX + fLimitCenterX - (fWidth / 2),
                                                                       objParentROI.ref_ROITotalY + fLimitCenterY,
                                                                        fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.TipCenter, m_arrSampleMatchNumber[intSampleIndex]);
                                        break;
                                    }
                                    else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(objParentROI.ref_ROITotalX + fLimitCenterX - (fWidth / 2),
                                                                       objParentROI.ref_ROITotalY + fLimitCenterY,
                                                                        fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.TipCenter, m_arrSampleMatchNumber[intSampleIndex]);
                                    }
                                }

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                                {
                                    fTipCenterX = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].GetMeasurePointX(0);
                                    fTipCenterY = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].GetMeasurePointY(0);
                                    m_stcBlobLead.blnTipCenterFound = true;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(fTipCenterX, fTipCenterY));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(true);
                                }
                                else
                                {
                                    fTipCenterX = objParentROI.ref_ROITotalX + fLimitCenterX - (fWidth / 2);
                                    fTipCenterY = objParentROI.ref_ROITotalY + fLimitCenterY;
                                    m_stcBlobLead.blnTipCenterFound = false;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(fTipCenterX, fTipCenterY));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                }

                                // ------- Find Tip start point -----------------------------------------
                                fLeftFixPointX = fTipCenterX + m_intTipOffset;

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].ref_GaugeTransType != 1)
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].ref_GaugeTransType = 1;     // Black to white

                                for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                                {
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].SetGaugePlacement(fLeftFixPointX,
                                                                      fTipCenterY - (fHeight / 2),
                                                                         fHeight * (m_fPointGaugeToleranceRate * m), -90);

                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].Measure(objROI);
                                    if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fLeftFixPointX,
                                                                        fTipCenterY - (fHeight / 2),
                                                                         fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.TipStart, m_arrSampleMatchNumber[intSampleIndex]);
                                        break;
                                    }
                                    else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fLeftFixPointX,
                                                                        fTipCenterY - (fHeight / 2),
                                                                         fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.TipStart, m_arrSampleMatchNumber[intSampleIndex]);
                                    }
                                }


                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                                {
                                    pLeftStart = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].GetMeasurePoint(0);
                                    m_stcBlobLead.blnTipStartFound = true;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pLeftStart.X, pLeftStart.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(true);
                                }
                                else
                                {
                                    pLeftStart = new PointF(fLeftFixPointX, fTipCenterY - (fHeight / 2));
                                    m_stcBlobLead.blnTipStartFound = false;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pLeftStart.X, pLeftStart.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                }

                                // ------- Find Tip end point -----------------------------------------

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].ref_GaugeTransType != 1)
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].ref_GaugeTransType = 1;     // Black to white

                                for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                                {
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].SetGaugePlacement(fLeftFixPointX,
                                                                           fTipCenterY + (fHeight / 2),
                                                                             fHeight * (m_fPointGaugeToleranceRate * m), 90);

                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].Measure(objROI);
                                    if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fLeftFixPointX,
                                                                            fTipCenterY + (fHeight / 2),
                                                                             fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.TipEnd, m_arrSampleMatchNumber[intSampleIndex]);
                                        break;
                                    }
                                    else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fLeftFixPointX,
                                                                            fTipCenterY + (fHeight / 2),
                                                                             fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.TipEnd, m_arrSampleMatchNumber[intSampleIndex]);
                                    }
                                }

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                                {
                                    pLeftEnd = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].GetMeasurePoint(0);
                                    m_stcBlobLead.blnTipEndFound = true;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pLeftEnd.X, pLeftEnd.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(true);
                                }
                                else
                                {
                                    pLeftEnd = new PointF(fLeftFixPointX, fTipCenterY + (fHeight / 2));
                                    m_stcBlobLead.blnTipEndFound = false;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pLeftEnd.X, pLeftEnd.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                }

                                // ----- Find Lead min max and burr width -----------------------------------------------------------------------------
                                if ((m_intFailOptionMask & 0x100000) > 0 || (m_intFailOptionMask & 0x200000) > 0)
                                {
                                    float fLeftStartMin = pLeftStart.Y;
                                    float fLeftStartMax = pLeftStart.Y;
                                    float fLeftEndMin = pLeftEnd.Y;
                                    float fLeftEndMax = pLeftEnd.Y;

                                    // Define scanning range
                                    int intStartRangeX;
                                    int intEndRangeX;

                                    if (m_intLeadWidthRangeSelection == 0) // From shoulder to lead tip(for max) and lead offset tip(for min)
                                    {
                                        intStartRangeX = (int)Math.Ceiling(fTipCenterX);
                                        intEndRangeX = (int)Math.Round(fBaseCenterX - m_intLeadWidthRange, 0, MidpointRounding.AwayFromZero);
                                    }
                                    else // 
                                    {
                                        intStartRangeX = (int)Math.Ceiling(fTipCenterX);
                                        intEndRangeX = intStartRangeX + m_intTipOffset + m_intLeadWidthRange;
                                    }

                                    // Scan Lead start point range
                                    for (int g = intStartRangeX; g <= intEndRangeX; g++)
                                    {
                                        m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].SetGaugePlacement(g,
                                                                         fTipCenterY - (fHeight / 2),
                                                                         fHeight * m_fPointGaugeToleranceRate, -90);

                                        m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].Measure(objROI);

                                        PointF p;
                                        if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                                        {
                                            p = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].GetMeasurePoint(0);

                                        }
                                        else
                                        {
                                            continue;
                                            //p = new PointF(fLeftFixPointX, fTipCenterY - (fHeight / 2));
                                        }

                                        // Min width check from lead offset tip
                                        if (g >= (intStartRangeX + m_intTipOffset))
                                        {
                                            if (fLeftStartMin > p.Y)
                                            {
                                                fLeftStartMin = p.Y;
                                            }
                                        }

                                        // Max width check from lead tip
                                        if (fLeftStartMax < p.Y)
                                        {
                                            fLeftStartMax = p.Y;
                                        }
                                    }

                                    // Scan Lead end point range
                                    for (int g = intStartRangeX; g <= intEndRangeX; g++)
                                    {
                                        m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].SetGaugePlacement(g,
                                                                             fTipCenterY + (fHeight / 2),
                                                                             fHeight * m_fPointGaugeToleranceRate, 90);

                                        m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].Measure(objROI);

                                        PointF p;
                                        if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                                        {
                                            p = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].GetMeasurePoint(0);

                                        }
                                        else
                                        {
                                            continue;
                                            //p = new PointF(fLeftFixPointX, fTipCenterY + (fHeight / 2));
                                        }

                                        // Min width check from lead offset tip
                                        if (g >= (intStartRangeX + m_intTipOffset))
                                        {
                                            if (fLeftEndMin > p.Y)
                                            {
                                                fLeftEndMin = p.Y;
                                            }
                                        }

                                        // Max width check from lead tip
                                        if (fLeftEndMax < p.Y)
                                        {
                                            fLeftEndMax = p.Y;
                                        }
                                    }

                                    fLeadMinWidth = fLeftEndMin - fLeftStartMax;
                                    fLeadMaxWidth = fLeftEndMax - fLeftStartMin;
                                    fLeadBurrWidth = fLeadMaxWidth - fLeadMinWidth;
                                }

                                // Calculate the Tip width and center Y
                                fTipWidth = pLeftEnd.Y - pLeftStart.Y; //fBaseWidth = 
                                fTipCenterY = (pLeftEnd.Y + pLeftStart.Y) / 2; //fBaseCenterY = 

                                // Base and Tip Length
                                fBaseLength = fBaseCenterX - fTipCenterX;
                                fTipLength = fBaseCenterX - fTipCenterX;
                                break;
                        }

                        float fSkew = 0;
                        float fMaxOffSet = 0;
                        switch (m_stcBlobLead.intDirection)
                        {
                            case 4:
                            case 8:
                                if (m_stcBlobLead.blnBaseStartFound || m_stcBlobLead.blnBaseEndFound)
                                    fSkew = Get2DXinMM(Math.Abs(fBaseCenterX - fTipCenterX)); // m_fMMToPixelXValue //2019-10-11 ZJYEOH : Lead Offset or bend --> Compare the center point between base and tip
                                else
                                    fSkew = -999;

                                fMaxOffSet = Get2DXinMM(Math.Abs(m_stcBlobLead.fXDistance - (fTipCenterX - m_pCornerPoint_Center.X)));
                                break;
                            case 1:
                            case 2:
                                if (m_stcBlobLead.blnBaseStartFound || m_stcBlobLead.blnBaseEndFound)
                                    fSkew = Get2DYinMM(Math.Abs(fBaseCenterY - fTipCenterY)); // m_fMMToPixelYValue //2019-10-11 ZJYEOH : Lead Offset or bend --> Compare the center point between base and tip
                                else
                                    fSkew = -999;

                                fMaxOffSet = Get2DYinMM(Math.Abs(m_stcBlobLead.fYDistance - (fTipCenterY - m_pCornerPoint_Center.Y)));
                                break;
                        }

                        //float fMaxOffSet = Math.Max(Math.Abs(m_stcBlobLead.fXDistance - (fTipCenterX - m_pCornerPoint_Center.X)) / m_fMMToPixelXValue,
                        //                                Math.Abs(m_stcBlobLead.fYDistance - (fTipCenterY - m_pCornerPoint_Center.Y)) / m_fMMToPixelYValue);
                        //float fMaxOffSet = Math.Max(Get2DXinMM(Math.Abs(m_stcBlobLead.fXDistance - (fTipCenterX - GetUnitPRResultCenterX()))),// m_fMMToPixelXValue
                        //                            Get2DYinMM(Math.Abs(m_stcBlobLead.fYDistance - (fTipCenterY - GetUnitPRResultCenterY()))));// m_fMMToPixelYValue
                        //float fMaxOffSet = Math.Max(Get2DXinMM(Math.Abs(m_stcBlobLead.fXDistance - (fTipCenterX - m_pCornerPoint_Center.X))),// m_fMMToPixelXValue
                        //         Get2DYinMM(Math.Abs(m_stcBlobLead.fYDistance - (fTipCenterY - m_pCornerPoint_Center.Y))));// m_fMMToPixelYValue


                        //Collect ordinary blob data
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].intDirection = m_stcBlobLead.intDirection;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].intNoID = m_stcBlobLead.intNoID;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].intFailMask |= 0;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fStartX = fStartX;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fStartY = fStartY;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fEndX = fEndX;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fEndY = fEndY;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fCenterX = fLimitCenterX;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fCenterY = fLimitCenterY;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fGravityCenterX = fGravityCenterX;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fGravityCenterY = fGravityCenterY;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fWidth = fWidth;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fHeight = fHeight;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fArea = (float)intArea;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].intContourIndex = 0;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fBaseCenterX = fBaseCenterX - objParentROI.ref_ROITotalX;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fBaseCenterY = fBaseCenterY - objParentROI.ref_ROITotalY;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fTipCenterX = fTipCenterX - objParentROI.ref_ROITotalX;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fTipCenterY = fTipCenterY - objParentROI.ref_ROITotalY;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fBaseWidth = fBaseWidth;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fBaseLength = fBaseLength;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fTipWidth = fTipWidth;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fTipLength = fTipLength;

                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fLeadMinWidth = fLeadMinWidth;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fLeadMaxWidth = fLeadMaxWidth;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fLeadBurrWidth = fLeadBurrWidth;

                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].blnTipCenterFound = m_stcBlobLead.blnTipCenterFound;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].blnTipStartFound = m_stcBlobLead.blnTipStartFound;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].blnTipEndFound = m_stcBlobLead.blnTipEndFound;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].blnBaseCenterFound = m_stcBlobLead.blnBaseCenterFound;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].blnBaseStartFound = m_stcBlobLead.blnBaseStartFound;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].blnBaseEndFound = m_stcBlobLead.blnBaseEndFound;

                        // Collect Lead range data
                        if (fStartX < m_fSampleLeadRangeStartX)
                            m_fSampleLeadRangeStartX = fStartX;
                        if (fStartY < m_fSampleLeadRangeStartY)
                            m_fSampleLeadRangeStartY = fStartY;
                        if (fEndX > m_fSampleLeadRangeEndX)
                            m_fSampleLeadRangeEndX = fEndX;
                        if (fEndY > m_fSampleLeadRangeEndY)
                            m_fSampleLeadRangeEndY = fEndY;

                        // Collect sample blobs data in MM
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fWidthMM = Get2DXinMM(fWidth); // / m_fMMToPixelXValue
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fHeightMM = Get2DYinMM(fHeight);// / m_fMMToPixelXValue
                        switch (m_stcBlobLead.intDirection)
                        {
                            case 4: //Top
                            case 8: //Bottom
                                m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fTipWidthMM = Get2DXinMM(fTipWidth) + m_stcBlobLead.fWidthOffset;// / m_fMMToPixelXValue
                                m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fTipLengthMM = Get2DYinMM(fTipLength) + m_stcBlobLead.fLengthOffset;// / m_fMMToPixelXValue
                                m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fBaseWidthMM = Get2DXinMM(fBaseWidth) + m_stcBlobLead.fWidthOffset;// / m_fMMToPixelXValue
                                m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fBaseLengthMM = Get2DYinMM(fBaseLength) + m_stcBlobLead.fLengthOffset;// / m_fMMToPixelXValue

                                m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fLeadMinWidthMM = Get2DXinMM(fLeadMinWidth) + m_stcBlobLead.fWidthOffset;
                                m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fLeadMaxWidthMM = Get2DXinMM(fLeadMaxWidth) + m_stcBlobLead.fWidthOffset;
                                m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fLeadBurrWidthMM = Get2DXinMM(fLeadBurrWidth);
                                break;
                            case 1: //Left
                            case 2: //Right
                                m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fTipWidthMM = Get2DYinMM(fTipWidth) + m_stcBlobLead.fWidthOffset;// / m_fMMToPixelXValue
                                m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fTipLengthMM = Get2DXinMM(fTipLength) + m_stcBlobLead.fLengthOffset;// / m_fMMToPixelXValue
                                m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fBaseWidthMM = Get2DYinMM(fBaseWidth) + m_stcBlobLead.fWidthOffset;// / m_fMMToPixelXValue
                                m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fBaseLengthMM = Get2DXinMM(fBaseLength) + m_stcBlobLead.fLengthOffset;// / m_fMMToPixelXValue

                                m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fLeadMinWidthMM = Get2DYinMM(fLeadMinWidth) + m_stcBlobLead.fWidthOffset;
                                m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fLeadMaxWidthMM = Get2DYinMM(fLeadMaxWidth) + m_stcBlobLead.fWidthOffset;
                                m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fLeadBurrWidthMM = Get2DYinMM(fLeadBurrWidth);

                                break;
                        }
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fAreaMM = (float)intArea / m_fMMtoPixelAreaValue;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fSkewMM = (float)Math.Round(fSkew, 4, MidpointRounding.AwayFromZero);
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fOffSetMM = (float)Math.Round(fMaxOffSet, 4, MidpointRounding.AwayFromZero);
                    }
                }
            }

            // Scan which blob number still no combined
            for (int i = 0; i < arrAllBlobNo.Count; i++)
            {
                for (int j = 0; j < arrCombinedBlobNo.Count; j++)
                {
                    if (arrAllBlobNo[i] == arrCombinedBlobNo[j])
                    {
                        arrAllBlobNo.RemoveAt(i);
                        i--;
                        break;
                    }
                }
            }

            float fLimitCenterX2Extra = 0, fLimitCenterY2Extra = 0;
            float fFinalLimitCenterXExtra = 0, fFinalLimitCenterYExtra = 0;
            // Uncombined blob will be comtamination
            for (int i = 0; i < arrAllBlobNo.Count; i++)
            {
                if (m_intLeadContaminationRegion == 1)
                    break;

                m_intExtraBlobID++;
                fLimitCenterX2Extra = m_objEBlobs.ref_arrLimitCenterX[arrAllBlobNo[i]];
                fLimitCenterY2Extra = m_objEBlobs.ref_arrLimitCenterY[arrAllBlobNo[i]];


                fFinalLimitCenterXExtra = fLimitCenterX2Extra;
                fFinalLimitCenterYExtra = fLimitCenterY2Extra;
                fWidth = m_objEBlobs.ref_arrWidth[arrAllBlobNo[i]];
                fHeight = m_objEBlobs.ref_arrHeight[arrAllBlobNo[i]];
                intArea = m_objEBlobs.ref_arrArea[arrAllBlobNo[i]];

                // Reposition so that it offset to objROI
                fFinalLimitCenterXExtra += objROI.ref_ROIPositionX;
                fFinalLimitCenterYExtra += objROI.ref_ROIPositionY;

                // Get object start point and end point
                fStartX = fFinalLimitCenterXExtra - (fWidth / 2);
                fStartY = fFinalLimitCenterYExtra - (fHeight / 2);
                fEndX = fFinalLimitCenterXExtra + (fWidth / 2);
                fEndY = fFinalLimitCenterYExtra + (fHeight / 2);
                //m_blnFailForeignMaterialLength = false;
                //m_blnFailForeignMaterialArea = false;
                //m_blnFailForeignMaterialTotalArea = false;
                SampleExtraBlobsFeatures extra = new SampleExtraBlobsFeatures();
                extra.fStartX = fStartX;
                extra.fEndX = fEndX;
                extra.fStartY = fStartY;
                extra.fEndY = fEndY;
                extra.fWidth = fWidth;
                extra.fHeight = fHeight;
                extra.fCenterX = fLimitCenterX;
                extra.fCenterY = fLimitCenterY;
                extra.ref_intExtraBlobID = m_intExtraBlobID;
                float fWidthInMM = Get2DXinMM(fWidth);/// m_fMMToPixelXValue
                float fHeightInMM = Get2DYinMM(fHeight);/// m_fMMToPixelXValue

                float fArea = intArea * m_fAreaMMPerPixel;

                if (m_blnWantCheckExtraLeadLength)
                {
                    //////////////// Check extra Lead using length limit setting ////////////////////
                    extra.ref_fWidthFailValue = fWidthInMM;
                    extra.ref_fHeightFailValue = fHeightInMM;

                    if ((fWidthInMM > m_fExtraLeadSetLength) ||
                        (fHeightInMM > m_fExtraLeadSetLength))
                    {

                        if (fWidthInMM > m_fExtraLeadSetLength)
                        {
                            extra.ref_intFailCriteria |= 0x01;
                            m_arrFailResultMask[0] |= 0x8000;
                        }

                        if (fHeightInMM > m_fExtraLeadSetLength)
                        {
                            extra.ref_intFailCriteria |= 0x02;
                            m_arrFailResultMask[0] |= 0x8000;
                        }
                        m_blnFailForeignMaterialLength = true;
                        // Collect extra Lead min and max area for display error message
                        //if ((fWidthInMM > m_fExtraLeadSetLength) &&
                        //(fHeightInMM > m_fExtraLeadSetLength))
                        //{
                        //    float fMin = Math.Min(fWidthInMM, fHeightInMM);
                        //    if ((m_fResultExtraLeadMinArea == -1) || (fMin < m_fResultExtraLeadMinArea))
                        //        m_fResultExtraLeadMinArea = fMin;

                        //    float fMax = Math.Max(fWidthInMM, fHeightInMM);
                        //    if ((m_fResultExtraLeadMaxArea == -1) || (fMax > m_fResultExtraLeadMaxArea))
                        //        m_fResultExtraLeadMaxArea = fMax;
                        //}
                        //else if (fWidthInMM > m_fExtraLeadSetLength)
                        //{
                        //    if ((m_fResultExtraLeadMinArea == -1) || (fWidthInMM < m_fResultExtraLeadMinArea))
                        //        m_fResultExtraLeadMinArea = fWidthInMM;
                        //    if ((m_fResultExtraLeadMaxArea == -1) || (fWidthInMM > m_fResultExtraLeadMaxArea))
                        //        m_fResultExtraLeadMaxArea = fWidthInMM;
                        //}
                        //else if (fHeightInMM > m_fExtraLeadSetLength)
                        //{
                        //    if ((m_fResultExtraLeadMinArea == -1) || (fHeightInMM < m_fResultExtraLeadMinArea))
                        //        m_fResultExtraLeadMinArea = fHeightInMM;
                        //    if ((m_fResultExtraLeadMaxArea == -1) || (fHeightInMM > m_fResultExtraLeadMaxArea))
                        //        m_fResultExtraLeadMaxArea = fHeightInMM;
                        //}
                    }

                }

                if (m_blnWantCheckExtraLeadArea)
                {
                    //////////////// Check extra Lead using area limit setting ////////////////////
                    // Change unit pixel to mm
                    extra.ref_fAreaFailValue = fArea;
                    if (fArea > m_fExtraLeadSetArea)
                    {
                        m_blnFailForeignMaterialArea = true;
                        extra.ref_intFailCriteria |= 0x04;

                        m_arrFailResultMask[0] |= 0x8000;
                        //// Collect extra Lead min and max area for display error message
                        //if ((m_fResultExtraLeadMinArea == -1) || (fArea < m_fResultExtraLeadMinArea))
                        //    m_fResultExtraLeadMinArea = fArea;
                        //if ((m_fResultExtraLeadMaxArea == -1) || (fArea > m_fResultExtraLeadMaxArea))
                        //    m_fResultExtraLeadMaxArea = fArea;
                    }
                    //////////////////////////////////////////////////////////////////////
                }

                //////////////// Get Total Extra pad unit area ///////////////////////////////
                if ((m_intFailOptionMask & 0x10000) > 0)
                {
                    m_fTotalExtraArea += fArea;
                }
                if (m_blnWantCheckExtraLeadLength || m_blnWantCheckExtraLeadArea || ((m_intFailOptionMask & 0x10000) > 0))
                    m_arrExtraBlobs.Add(extra);
            }

            //if (((m_intFailOptionMask & 0x10000) > 0) && !m_blnFailForeignMaterialLength && !m_blnFailForeignMaterialArea)
            //{
            //    if (fTotalExtraArea > 0)
            //    {
            //        m_intExtraBlobID++;
            //        //////////////// Check Total Extra pad unit area ///////////////////////////////
            //        SampleExtraBlobsFeatures extra = new SampleExtraBlobsFeatures();
            //        extra.ref_intExtraBlobID = m_intExtraBlobID;
            //        extra.ref_fWidthFailValue = -999;
            //        extra.ref_fHeightFailValue = -999;
            //        extra.ref_fAreaFailValue = fTotalExtraArea;
            //        if (fTotalExtraArea > m_fTotalExtraLeadSetArea)
            //        {
            //            m_blnFailForeignMaterialTotalArea = true;
            //            for (int i = 0; i < m_arrExtraBlobs.Count; i++)
            //            {
            //                SampleExtraBlobsFeatures objExtraBlob = m_arrExtraBlobs[i];
            //                objExtraBlob.ref_intFailCriteria |= 0x08;
            //                m_arrExtraBlobs[i] = objExtraBlob;
            //            }
            //            extra.ref_intFailCriteria |= 0x04;
            //            m_arrFailResultMask[0] |= 0x10000;
            //        }
            //        m_arrExtraBlobs.Add(extra);
            //    }
            //}
        }

        private void MeasureDimension_CenterLeads_UsingPointGauge(ROI objParentROI, ROI objROI, int intNumberOfLead, int intDirection)
        {
            float fUnitAreaWidth = objROI.ref_ROIWidth;
            float fUnitAreaHeight = objROI.ref_ROIHeight;
            //float fUnitAreaStartX = (float)Math.Round(objROI.ref_ROITotalCenterX - fUnitAreaWidth / 2, MidpointRounding.AwayFromZero) - objROI.ref_ROITotalX;// * m_fMMToPixelXValue;
            //float fUnitAreaStartY = (float)Math.Round(objROI.ref_ROITotalCenterY - fUnitAreaHeight / 2, MidpointRounding.AwayFromZero) - objROI.ref_ROITotalY;// * m_fMMToPixelYValue;
            //float fUnitAreaEndX = (float)Math.Round(objROI.ref_ROITotalCenterX + fUnitAreaWidth / 2, MidpointRounding.AwayFromZero) - objROI.ref_ROITotalX;// * m_fMMToPixelXValue;
            //float fUnitAreaEndY = (float)Math.Round(objROI.ref_ROITotalCenterY + fUnitAreaHeight / 2, MidpointRounding.AwayFromZero) - objROI.ref_ROITotalY;// * m_fMMToPixelYValue;
            float fUnitAreaStartX = objROI.ref_ROIPositionX;
            float fUnitAreaStartY = objROI.ref_ROIPositionY;
            float fUnitAreaEndX = objROI.ref_ROIPositionX + fUnitAreaWidth;
            float fUnitAreaEndY = objROI.ref_ROIPositionY + fUnitAreaHeight;
            // Testing Type:
            // 1. Match Blobs Object to Template Lead
            // 2. Find reference point of lead
            //float fTotalExtraArea = 0;
            float fLimitCenterX = 0;
            float fLimitCenterY = 0;
            float fWidth = 0;
            float fHeight = 0;
            float fOrgX = 0;
            float fOrgY = 0;
            int intTotalBlobCount = 0;
            int intArea = 0;
            float fGravityCenterX = 0;
            float fGravityCenterY = 0;
            float fStartX = 0;
            float fStartY = 0;
            float fEndX = 0;
            float fEndY = 0;
            float fBaseCenterX = 0;
            float fBaseCenterY = 0;
            float fBaseWidth = 0;
            float fBaseLength = 0;
            float fTipCenterX = 0;
            float fTipCenterY = 0;
            float fTipWidth = 0;
            float fTipLength = 0;
            float fLeadMinWidth = 0;
            float fLeadMaxWidth = 0;
            float fLeadBurrWidth = 0;
            int intFixPointXY = 0;
            int intSampleIndex = 0;
            List<int> arrSkipNo = new List<int>();
            bool blnSkipToNextObject = false;
            List<int> arrCombinedBlobNo = new List<int>();
            List<int> arrAllBlobNo = new List<int>();

            int intSelectedObjectNum = 0;
            if (m_objEBlobs.ref_intNumSelectedObject >= intNumberOfLead)
                intSelectedObjectNum = intNumberOfLead;
            else
                intSelectedObjectNum = m_objEBlobs.ref_intNumSelectedObject;

            // Assign blobs to sample arrary
            for (int i = 0; i < intSelectedObjectNum; i++)
            {
                for (int k = 0; k < arrSkipNo.Count; k++)
                {
                    if (i == arrSkipNo[k])
                    {
                        blnSkipToNextObject = true;
                        break;
                    }
                }

                if (blnSkipToNextObject)
                {
                    blnSkipToNextObject = false;
                    continue;
                }

                m_arrSampleMatchNumber.Add(-1);
                intSampleIndex = m_arrSampleMatchNumber.Count - 1;

                float fFromROIOffsetLimitCenterX = objROI.ref_ROIPositionX + m_objEBlobs.ref_arrLimitCenterX[i];
                float fFromROIOffsetLimitCenterY = objROI.ref_ROIPositionY + m_objEBlobs.ref_arrLimitCenterY[i];
                // Get blob center point, start point and size
                fWidth = m_objEBlobs.ref_arrWidth[i];
                fHeight = m_objEBlobs.ref_arrHeight[i];
                fOrgX = fFromROIOffsetLimitCenterX - fWidth / 2;
                fOrgY = fFromROIOffsetLimitCenterY - fHeight / 2;
                intArea = 0;
                fGravityCenterX = 0;
                fGravityCenterY = 0;
                fLimitCenterX = 0;
                fLimitCenterY = 0;
                fStartX = fOrgX;
                fStartY = fOrgY;
                fEndX = fOrgX + fWidth;
                fEndY = fOrgY + fHeight;
                intTotalBlobCount = 0;
                fTipWidth = 0;
                fTipLength = 0;
                fBaseWidth = 0;
                fBaseLength = 0;
                fLeadMinWidth = 0;
                fLeadMaxWidth = 0;
                fLeadBurrWidth = 0;

                // Search Is there other blobs same under same lead area.
                for (int j = i; j < m_objEBlobs.ref_intNumSelectedObject; j++)
                {
                    if (arrAllBlobNo.Count < m_objEBlobs.ref_intNumSelectedObject)
                        arrAllBlobNo.Add(j);

                    float fFromROIOffsetCenterX2 = objROI.ref_ROIPositionX + m_objEBlobs.ref_arrGravityCenterX[j];
                    float fFromROIOffsetCenterY2 = objROI.ref_ROIPositionY + m_objEBlobs.ref_arrGravityCenterY[j];
                    float fFromROIOffsetLimitCenterX2 = objROI.ref_ROIPositionX + m_objEBlobs.ref_arrLimitCenterX[j];
                    float fFromROIOffsetLimitCenterY2 = objROI.ref_ROIPositionY + m_objEBlobs.ref_arrLimitCenterY[j];

                    if (m_intLeadDirection == 0)    // Horizontal
                    {
                        //Horizontal lead
                        if (fFromROIOffsetLimitCenterY2 < fOrgY || fFromROIOffsetLimitCenterY2 > (fOrgY + fHeight))
                            continue;
                    }
                    else
                    {
                        //Vertical lead
                        if (fFromROIOffsetLimitCenterX2 < fOrgX || fFromROIOffsetLimitCenterX2 > (fOrgX + fWidth))
                            continue;
                    }

                    if (intSelectedObjectNum >= j && i != j)
                    {
                        if (m_objEBlobs.ref_intNumSelectedObject > intSelectedObjectNum)
                            intSelectedObjectNum++;
                        arrSkipNo.Add(j);
                    }

                    intArea += m_objEBlobs.ref_arrArea[j];
                    fGravityCenterX += fFromROIOffsetCenterX2 * m_objEBlobs.ref_arrArea[j];
                    fGravityCenterY += fFromROIOffsetCenterY2 * m_objEBlobs.ref_arrArea[j];

                    if (fStartX > fFromROIOffsetLimitCenterX2 - (m_objEBlobs.ref_arrWidth[j] / 2))
                    {
                        fStartX = fFromROIOffsetLimitCenterX2 - (m_objEBlobs.ref_arrWidth[j] / 2);
                    }

                    if (fStartY > fFromROIOffsetLimitCenterY2 - (m_objEBlobs.ref_arrHeight[j] / 2))
                    {
                        fStartY = fFromROIOffsetLimitCenterY2 - (m_objEBlobs.ref_arrHeight[j] / 2);
                    }

                    if (fEndX < fFromROIOffsetLimitCenterX2 + (m_objEBlobs.ref_arrWidth[j] / 2))
                    {
                        fEndX = fFromROIOffsetLimitCenterX2 + (m_objEBlobs.ref_arrWidth[j] / 2);
                    }

                    if (fEndY < fFromROIOffsetLimitCenterY2 + (m_objEBlobs.ref_arrHeight[j] / 2))
                    {
                        fEndY = fFromROIOffsetLimitCenterY2 + (m_objEBlobs.ref_arrHeight[j] / 2);
                    }

                    intTotalBlobCount++;
                    arrCombinedBlobNo.Add(j);
                }

                if (intArea == 0)
                {
                    continue;
                }
                fGravityCenterX = fGravityCenterX / intArea;
                fGravityCenterY = fGravityCenterY / intArea;
                fLimitCenterX = (fEndX + fStartX) / 2;
                fLimitCenterY = (fEndY + fStartY) / 2;
                fWidth = fEndX - fStartX;
                fHeight = fEndY - fStartY;

                // Get template number which match with sample
                List<int> arrMatch = MatchTemplateObjects_Inspection(objROI, fStartX, fStartY,
                                                        fEndX, fEndY,
                                                        fWidth, fHeight,
                                                        fBaseWidth, fBaseLength,
                                                        fTipWidth, fTipLength,
                                                        fGravityCenterX, fGravityCenterY,
                                                        intArea, intDirection);
                for (int j = 0; j < arrMatch.Count; j++)
                    m_intTemplateMatchStatus[arrMatch[j]]++;

                if (arrMatch.Count == 0)        // Set to -1 if match nothing with any template leads
                    m_arrSampleMatchNumber[intSampleIndex] = -1;
                else if (arrMatch.Count > 1)    // Set to -2 if match more than 1 template leads
                    m_arrSampleMatchNumber[intSampleIndex] = -2;
                else
                    m_arrSampleMatchNumber[intSampleIndex] = arrMatch[0];

                // No template match with sample
                if (m_arrSampleMatchNumber[intSampleIndex] == -1)
                {
                    //Extra Lead
                    if ((((m_intFailOptionMask & 0x8000) > 0) || ((m_intFailOptionMask & 0x10000) > 0)) && m_intLeadContaminationRegion != 1)
                    {
                        float fOutWidth = Math.Max(fUnitAreaStartX - fStartX, 0) + Math.Max(fEndX - fUnitAreaEndX, 0);
                        float fOutHeight = Math.Max(fUnitAreaStartY - fStartY, 0) + Math.Max(fEndY - fUnitAreaEndY, 0);

                        // check is sample under unit area range
                        if (((fWidth - fOutWidth) > 0) && ((fHeight - fOutHeight) > 0)) // both value are > 0 when it is in check area range
                        {
                            //if (m_blnWantCheckExtraLeadLength || m_blnWantCheckExtraLeadArea)
                            {
                                // Create small ROI for the extra area
                                ROI objExtraAreaROI = new ROI();
                                objExtraAreaROI.AttachImage(objROI);
                                //objExtraAreaROI.LoadROISetting((int)Math.Ceiling(fStartX + Math.Max(fUnitAreaStartX - fStartX, 0)),
                                //                               (int)Math.Ceiling(fStartY + Math.Max(fUnitAreaStartY - fStartY, 0)),
                                //                               (int)Math.Floor(fWidth - Math.Max(fUnitAreaStartX - fStartX, 0) - Math.Max(fEndX - fUnitAreaEndX, 0)),
                                //                               (int)Math.Floor(fHeight - Math.Max(fUnitAreaStartY - fStartY, 0) - Math.Max(fEndY - fUnitAreaEndY, 0)));
                                objExtraAreaROI.LoadROISetting((int)Math.Ceiling(fStartX), (int)Math.Ceiling(fStartY), (int)Math.Floor(fEndX - fStartX), (int)Math.Floor(fEndY - fStartY));

                                if (objExtraAreaROI.ref_ROIWidth > 0 && objExtraAreaROI.ref_ROIHeight > 0)
                                {
                                    m_objExtraLeadEBlobs.BuildObjects_Filter_GetElement(objExtraAreaROI, false, true, 0, m_objEBlobs.ref_intAbsoluteThreshold,
                                       m_intFilterMinArea, objExtraAreaROI.ref_ROIHeight * objExtraAreaROI.ref_ROIWidth, false, 0x0F);

                                    if (m_objExtraLeadEBlobs.ref_intNumSelectedObject > 0)
                                    {

                                        float fLimitCenterX2 = 0, fLimitCenterY2 = 0;
                                        float fFinalLimitCenterX = 0, fFinalLimitCenterY = 0;
                                        for (int k = 0; k < m_objExtraLeadEBlobs.ref_intNumSelectedObject; k++)
                                        {
                                            m_intExtraBlobID++;
                                            fLimitCenterX2 = m_objExtraLeadEBlobs.ref_arrLimitCenterX[k];
                                            fLimitCenterY2 = m_objExtraLeadEBlobs.ref_arrLimitCenterY[k];


                                            fFinalLimitCenterX = fLimitCenterX2;
                                            fFinalLimitCenterY = fLimitCenterY2;
                                            fWidth = m_objExtraLeadEBlobs.ref_arrWidth[k];
                                            fHeight = m_objExtraLeadEBlobs.ref_arrHeight[k];
                                            intArea = m_objExtraLeadEBlobs.ref_arrArea[k];

                                            // Reposition so that it offset to objROI
                                            fFinalLimitCenterX += (objROI.ref_ROIPositionX + objExtraAreaROI.ref_ROIPositionX);
                                            fFinalLimitCenterY += (objROI.ref_ROIPositionY + objExtraAreaROI.ref_ROIPositionY);

                                            // Get object start point and end point
                                            fStartX = fFinalLimitCenterX - (fWidth / 2);
                                            fStartY = fFinalLimitCenterY - (fHeight / 2);
                                            fEndX = fFinalLimitCenterX + (fWidth / 2);
                                            fEndY = fFinalLimitCenterY + (fHeight / 2);
                                            //m_blnFailForeignMaterialLength = false;
                                            //m_blnFailForeignMaterialArea = false;
                                            //m_blnFailForeignMaterialTotalArea = false;
                                            SampleExtraBlobsFeatures extra = new SampleExtraBlobsFeatures();
                                            extra.fStartX = fStartX;
                                            extra.fEndX = fEndX;
                                            extra.fStartY = fStartY;
                                            extra.fEndY = fEndY;
                                            extra.fWidth = fWidth;
                                            extra.fHeight = fHeight;
                                            extra.fCenterX = fLimitCenterX;
                                            extra.fCenterY = fLimitCenterY;
                                            extra.ref_intExtraBlobID = m_intExtraBlobID;
                                            float fWidthInMM = Get2DXinMM(fWidth);/// m_fMMToPixelXValue
                                            float fHeightInMM = Get2DYinMM(fHeight);/// m_fMMToPixelXValue

                                            float fArea = intArea * m_fAreaMMPerPixel;

                                            if (m_blnWantCheckExtraLeadLength)
                                            {
                                                //////////////// Check extra Lead using length limit setting ////////////////////
                                                extra.ref_fWidthFailValue = fWidthInMM;
                                                extra.ref_fHeightFailValue = fHeightInMM;

                                                if ((fWidthInMM > m_fExtraLeadSetLength) ||
                                                    (fHeightInMM > m_fExtraLeadSetLength))
                                                {

                                                    if (fWidthInMM > m_fExtraLeadSetLength)
                                                    {
                                                        extra.ref_intFailCriteria |= 0x01;
                                                        m_arrFailResultMask[0] |= 0x8000;
                                                    }

                                                    if (fHeightInMM > m_fExtraLeadSetLength)
                                                    {
                                                        extra.ref_intFailCriteria |= 0x02;
                                                        m_arrFailResultMask[0] |= 0x8000;
                                                    }
                                                    m_blnFailForeignMaterialLength = true;
                                                    // Collect extra Lead min and max area for display error message
                                                    //if ((fWidthInMM > m_fExtraLeadSetLength) &&
                                                    //(fHeightInMM > m_fExtraLeadSetLength))
                                                    //{
                                                    //    float fMin = Math.Min(fWidthInMM, fHeightInMM);
                                                    //    if ((m_fResultExtraLeadMinArea == -1) || (fMin < m_fResultExtraLeadMinArea))
                                                    //        m_fResultExtraLeadMinArea = fMin;

                                                    //    float fMax = Math.Max(fWidthInMM, fHeightInMM);
                                                    //    if ((m_fResultExtraLeadMaxArea == -1) || (fMax > m_fResultExtraLeadMaxArea))
                                                    //        m_fResultExtraLeadMaxArea = fMax;
                                                    //}
                                                    //else if (fWidthInMM > m_fExtraLeadSetLength)
                                                    //{
                                                    //    if ((m_fResultExtraLeadMinArea == -1) || (fWidthInMM < m_fResultExtraLeadMinArea))
                                                    //        m_fResultExtraLeadMinArea = fWidthInMM;
                                                    //    if ((m_fResultExtraLeadMaxArea == -1) || (fWidthInMM > m_fResultExtraLeadMaxArea))
                                                    //        m_fResultExtraLeadMaxArea = fWidthInMM;
                                                    //}
                                                    //else if (fHeightInMM > m_fExtraLeadSetLength)
                                                    //{
                                                    //    if ((m_fResultExtraLeadMinArea == -1) || (fHeightInMM < m_fResultExtraLeadMinArea))
                                                    //        m_fResultExtraLeadMinArea = fHeightInMM;
                                                    //    if ((m_fResultExtraLeadMaxArea == -1) || (fHeightInMM > m_fResultExtraLeadMaxArea))
                                                    //        m_fResultExtraLeadMaxArea = fHeightInMM;
                                                    //}
                                                }

                                            }

                                            if (m_blnWantCheckExtraLeadArea)
                                            {
                                                //////////////// Check extra Lead using area limit setting ////////////////////
                                                // Change unit pixel to mm
                                                extra.ref_fAreaFailValue = fArea;
                                                if (fArea > m_fExtraLeadSetArea)
                                                {
                                                    m_blnFailForeignMaterialArea = true;
                                                    extra.ref_intFailCriteria |= 0x04;

                                                    m_arrFailResultMask[0] |= 0x8000;
                                                    //// Collect extra Lead min and max area for display error message
                                                    //if ((m_fResultExtraLeadMinArea == -1) || (fArea < m_fResultExtraLeadMinArea))
                                                    //    m_fResultExtraLeadMinArea = fArea;
                                                    //if ((m_fResultExtraLeadMaxArea == -1) || (fArea > m_fResultExtraLeadMaxArea))
                                                    //    m_fResultExtraLeadMaxArea = fArea;
                                                }
                                                //////////////////////////////////////////////////////////////////////
                                            }

                                            //////////////// Get Total Extra pad unit area ///////////////////////////////
                                            if ((m_intFailOptionMask & 0x10000) > 0)
                                            {
                                                m_fTotalExtraArea += fArea;
                                            }
                                            if (m_blnWantCheckExtraLeadLength || m_blnWantCheckExtraLeadArea || ((m_intFailOptionMask & 0x10000) > 0))
                                                m_arrExtraBlobs.Add(extra);
                                        }

                                    }
                                    else
                                    {
                                        // Set extra area as empty if cannot find object in small ROI
                                        fWidth = 0;
                                        fHeight = 0;
                                        intArea = 0;
                                    }
                                }
                                else
                                {
                                    fWidth = 0;
                                    fHeight = 0;
                                    intArea = 0;
                                }

                                objExtraAreaROI.Dispose();
                            }


                        }
                    }
                }
                // More than 1 templates match with sample
                if (m_arrSampleMatchNumber[intSampleIndex] == -2)
                {
                    //Join/Bridge Lead
                    SampleExtraBlobsFeatures extra = new SampleExtraBlobsFeatures();
                    extra.fStartX = fStartX;
                    extra.fEndX = fEndX;
                    extra.fStartY = fStartY;
                    extra.fEndY = fEndY;
                    extra.fWidth = fWidth;
                    extra.fHeight = fHeight;
                    extra.fCenterX = fLimitCenterX;
                    extra.fCenterY = fLimitCenterY;

                    m_arrExtraBlobs.Add(extra);

                    for (int b = 0; b < arrMatch.Count; b++)
                    {
                        m_arrSampleBlobLeads[arrMatch[b]].intFailMask |= 0x10;  // Bridging or Un-Cut TieBar
                    }

                    m_arrFailResultMask[0] |= 0x10;
                }
                //Sample fall in Don't Care ROI area
                else if (m_arrSampleMatchNumber[intSampleIndex] == -3)
                {
                    return;
                }
                // Found only 1 templates match with sample
                else if (m_arrSampleMatchNumber[intSampleIndex] >= 0)
                {
                    if (m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fArea == -999)
                    {
                        m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[m_arrSampleMatchNumber[intSampleIndex]];
                        m_arrLead3DEdgeCenterGaugePointsPosition[m_arrSampleMatchNumber[intSampleIndex]] = m_stcBlobLead.intDirection;
                        switch (m_stcBlobLead.intDirection)
                        {
                            //Top
                            case 4:
                                //Base             
                                // ------- Find Base Point X -----------------------------------------

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].ref_GaugeTransType != 1)
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].ref_GaugeTransType = 1;     // Black to white

                                for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                                {

                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].SetGaugePlacement(objParentROI.ref_ROITotalX + fLimitCenterX,
                                                                      objParentROI.ref_ROITotalY + fLimitCenterY + (fHeight / 2),
                                                                      fHeight * (m_fPointGaugeToleranceRate * m), 90);

                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].Measure(objROI);
                                    if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                                    {
                                        AddCenterPointGaugePlacementToArray_Inspection(objParentROI.ref_ROITotalX + fLimitCenterX,
                                                                          objParentROI.ref_ROITotalY + fLimitCenterY + (fHeight / 2),
                                                                          fHeight * (m_fPointGaugeToleranceRate * m), 90, m_arrSampleMatchNumber[intSampleIndex]);
                                        break;
                                    }
                                    else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                                    {
                                        AddCenterPointGaugePlacementToArray_Inspection(objParentROI.ref_ROITotalX + fLimitCenterX,
                                                                          objParentROI.ref_ROITotalY + fLimitCenterY + (fHeight / 2),
                                                                          fHeight * (m_fPointGaugeToleranceRate * m), 90, m_arrSampleMatchNumber[intSampleIndex]);
                                    }
                                }


                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                                {
                                    fBaseCenterX = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].GetMeasurePointX(0);
                                    fBaseCenterY = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].GetMeasurePointY(0);
                                    m_stcBlobLead.blnBaseCenterFound = true;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(fBaseCenterX, fBaseCenterY));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(true);
                                }
                                else
                                {
                                    fBaseCenterX = objParentROI.ref_ROITotalX + fLimitCenterX;
                                    fBaseCenterY = objParentROI.ref_ROITotalY + fLimitCenterY + (fHeight / 2);
                                    m_stcBlobLead.blnBaseCenterFound = false;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(fBaseCenterX, fBaseCenterY));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                }

                                // ------- Find Base start point -----------------------------------------
                                float fTopFixPointY = fBaseCenterY - m_intBaseOffset;

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].ref_GaugeTransType != 1)
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].ref_GaugeTransType = 1;     // Black to white

                                for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                                {
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].SetGaugePlacement(fBaseCenterX - fWidth / 2,
                                                                          fTopFixPointY,
                                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180);


                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].Measure(objROI);
                                    if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fBaseCenterX - fWidth / 2,
                                                                          fTopFixPointY,
                                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.BaseStart, m_arrSampleMatchNumber[intSampleIndex]);
                                        break;
                                    }
                                    else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fBaseCenterX - fWidth / 2,
                                                                          fTopFixPointY,
                                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.BaseStart, m_arrSampleMatchNumber[intSampleIndex]);
                                    }
                                }


                                PointF pTopStart;
                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                                {
                                    pTopStart = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].GetMeasurePoint(0);
                                    m_stcBlobLead.blnBaseStartFound = true;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pTopStart.X, pTopStart.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(true);
                                }
                                else
                                {
                                    pTopStart = new PointF(fBaseCenterX - fWidth / 2, fTopFixPointY);
                                    m_stcBlobLead.blnBaseStartFound = false;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pTopStart.X, pTopStart.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                }

                                // ------- Find Base end point -----------------------------------------

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].ref_GaugeTransType != 1)
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].ref_GaugeTransType = 1;     // Black to white

                                for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                                {
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].SetGaugePlacement(fBaseCenterX + fWidth / 2,
                                                                        fTopFixPointY,
                                                                       fWidth * (m_fPointGaugeToleranceRate * m), 0);

                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].Measure(objROI);
                                    if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fBaseCenterX + fWidth / 2,
                                                                         fTopFixPointY,
                                                                        fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.BaseEnd, m_arrSampleMatchNumber[intSampleIndex]);
                                        break;
                                    }
                                    else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fBaseCenterX + fWidth / 2,
                                                                        fTopFixPointY,
                                                                       fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.BaseEnd, m_arrSampleMatchNumber[intSampleIndex]);
                                    }
                                }


                                PointF pTopEnd;
                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                                {
                                    pTopEnd = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].GetMeasurePoint(0);
                                    m_stcBlobLead.blnBaseEndFound = true;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pTopEnd.X, pTopEnd.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(true);
                                }
                                else
                                {
                                    pTopEnd = new PointF(fBaseCenterX + fWidth / 2, fTopFixPointY);
                                    m_stcBlobLead.blnBaseEndFound = false;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pTopEnd.X, pTopEnd.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                }

                                // Calculate the Base width and center X
                                fBaseWidth = pTopEnd.X - pTopStart.X;
                                fBaseCenterX = (pTopEnd.X + pTopStart.X) / 2;

                                //Tip

                                // ------- Find Tip Point X -----------------------------------------

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].ref_GaugeTransType != 1)
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].ref_GaugeTransType = 1;     // Black to white

                                for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                                {
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].SetGaugePlacement(objParentROI.ref_ROITotalX + fLimitCenterX,
                                                                            objParentROI.ref_ROITotalY + fLimitCenterY - (fHeight / 2),
                                                                           fHeight * (m_fPointGaugeToleranceRate * m), -90);

                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].Measure(objROI);
                                    if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(objParentROI.ref_ROITotalX + fLimitCenterX,
                                                                          objParentROI.ref_ROITotalY + fLimitCenterY - (fHeight / 2),
                                                                         fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.TipCenter, m_arrSampleMatchNumber[intSampleIndex]);
                                        break;
                                    }
                                    else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(objParentROI.ref_ROITotalX + fLimitCenterX,
                                                                           objParentROI.ref_ROITotalY + fLimitCenterY - (fHeight / 2),
                                                                          fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.TipCenter, m_arrSampleMatchNumber[intSampleIndex]);
                                    }
                                }

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                                {
                                    fTipCenterX = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].GetMeasurePointX(0);
                                    fTipCenterY = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].GetMeasurePointY(0);
                                    m_stcBlobLead.blnTipCenterFound = true;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(fTipCenterX, fTipCenterY));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(true);
                                }
                                else
                                {
                                    fTipCenterX = objParentROI.ref_ROITotalX + fLimitCenterX;
                                    fTipCenterY = objParentROI.ref_ROITotalY + fLimitCenterY - (fHeight / 2);
                                    m_stcBlobLead.blnTipCenterFound = false;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(fTipCenterX, fTipCenterY));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                }

                                // ------- Find Tip start point -----------------------------------------
                                fTopFixPointY = fTipCenterY + m_intTipOffset;

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].ref_GaugeTransType != 1)
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].ref_GaugeTransType = 1;     // Black to white

                                for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                                {
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].SetGaugePlacement(fTipCenterX - fWidth / 2,
                                                                           fTopFixPointY,
                                                                          fWidth * (m_fPointGaugeToleranceRate * m), 180);
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].Measure(objROI);
                                    if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fTipCenterX - fWidth / 2,
                                                                          fTopFixPointY,
                                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.TipStart, m_arrSampleMatchNumber[intSampleIndex]);
                                        break;
                                    }
                                    else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fTipCenterX - fWidth / 2,
                                                                          fTopFixPointY,
                                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.TipStart, m_arrSampleMatchNumber[intSampleIndex]);
                                    }
                                }


                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                                {
                                    pTopStart = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].GetMeasurePoint(0);
                                    m_stcBlobLead.blnTipStartFound = true;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pTopStart.X, pTopStart.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(true);
                                }
                                else
                                {
                                    pTopStart = new PointF(fTipCenterX - fWidth / 2, fTopFixPointY);
                                    m_stcBlobLead.blnTipStartFound = false;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pTopStart.X, pTopStart.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                }

                                // ------- Find Tip end point -----------------------------------------

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].ref_GaugeTransType != 1)
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].ref_GaugeTransType = 1;     // Black to white

                                for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                                {
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].SetGaugePlacement(fTipCenterX + fWidth / 2,
                                                                        fTopFixPointY,
                                                                       fWidth * (m_fPointGaugeToleranceRate * m), 0);

                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].Measure(objROI);
                                    if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fTipCenterX + fWidth / 2,
                                                                        fTopFixPointY,
                                                                       fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.TipEnd, m_arrSampleMatchNumber[intSampleIndex]);
                                        break;
                                    }
                                    else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fTipCenterX + fWidth / 2,
                                                                         fTopFixPointY,
                                                                        fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.TipEnd, m_arrSampleMatchNumber[intSampleIndex]);
                                    }
                                }
                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                                {
                                    pTopEnd = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].GetMeasurePoint(0);
                                    m_stcBlobLead.blnTipEndFound = true;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pTopEnd.X, pTopEnd.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(true);
                                }
                                else
                                {
                                    pTopEnd = new PointF(fTipCenterX + fWidth / 2, fTopFixPointY);
                                    m_stcBlobLead.blnTipEndFound = false;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pTopEnd.X, pTopEnd.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                }

                                // ----- Find Lead min max and burr width -----------------------------------------------------------------------------
                                if ((m_intFailOptionMask & 0x100000) > 0 || (m_intFailOptionMask & 0x200000) > 0)
                                {
                                    float fTopStartMin = pTopStart.X;
                                    float fTopStartMax = pTopStart.X;
                                    float fTopEndMin = pTopEnd.X;
                                    float fTopEndMax = pTopEnd.X;

                                    // Define scanning range
                                    int intStartRangeY;
                                    int intEndRangeY;

                                    if (m_intLeadWidthRangeSelection == 0) // From shoulder to lead tip(for max) and lead offset tip(for min)
                                    {
                                        intStartRangeY = (int)Math.Ceiling(fTipCenterY);
                                        intEndRangeY = (int)Math.Round(fBaseCenterY - m_intLeadWidthRange, 0, MidpointRounding.AwayFromZero);
                                    }
                                    else // 
                                    {
                                        intStartRangeY = (int)Math.Ceiling(fTipCenterY);
                                        intEndRangeY = intStartRangeY + m_intTipOffset + m_intLeadWidthRange;
                                    }

                                    // Scan Lead start point range
                                    for (int g = intStartRangeY; g <= intEndRangeY; g++)
                                    {
                                        m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].SetGaugePlacement(fTipCenterX - fWidth / 2,
                                                                          g,
                                                                         fWidth * m_fPointGaugeToleranceRate, 180);

                                        m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].Measure(objROI);

                                        PointF p;
                                        if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                                        {
                                            p = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].GetMeasurePoint(0);

                                        }
                                        else
                                        {
                                            continue;
                                            //p = new PointF(fLeftFixPointX, fTipCenterY - (fHeight / 2));
                                        }

                                        // Min width check from lead offset tip
                                        if (g >= (intStartRangeY + m_intTipOffset))
                                        {
                                            if (fTopStartMin > p.X)
                                            {
                                                fTopStartMin = p.X;
                                            }
                                        }

                                        // Max width check from lead tip
                                        if (fTopStartMax < p.X)
                                        {
                                            fTopStartMax = p.X;
                                        }
                                    }

                                    // Scan Lead end point range
                                    for (int g = intStartRangeY; g <= intEndRangeY; g++)
                                    {
                                        m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].SetGaugePlacement(fTipCenterX + fWidth / 2,
                                                                        g,
                                                                       fWidth * m_fPointGaugeToleranceRate, 0);

                                        m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].Measure(objROI);

                                        PointF p;
                                        if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                                        {
                                            p = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].GetMeasurePoint(0);

                                        }
                                        else
                                        {
                                            continue;
                                            //p = new PointF(fLeftFixPointX, fTipCenterY + (fHeight / 2));
                                        }

                                        // Min width check from lead offset tip
                                        if (g >= (intStartRangeY + m_intTipOffset))
                                        {
                                            if (fTopEndMin > p.X)
                                            {
                                                fTopEndMin = p.X;
                                            }
                                        }

                                        // Max width check from lead tip
                                        if (fTopEndMax < p.X)
                                        {
                                            fTopEndMax = p.X;
                                        }
                                    }

                                    fLeadMinWidth = fTopEndMin - fTopStartMax;
                                    fLeadMaxWidth = fTopEndMax - fTopStartMin;
                                    fLeadBurrWidth = fLeadMaxWidth - fLeadMinWidth;
                                }

                                // Calculate the Tip width and center X
                                fTipWidth = pTopEnd.X - pTopStart.X;
                                fTipCenterX = (pTopEnd.X + pTopStart.X) / 2;

                                // Base and Tip Length
                                fBaseLength = fBaseCenterY - fTipCenterY;
                                fTipLength = fBaseCenterY - fTipCenterY;
                                break;
                            //Right
                            case 2:
                                //Base
                                // ------- Find Base Point Y -----------------------------------------

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].ref_GaugeTransType != 1)
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].ref_GaugeTransType = 1;     // Black to white

                                m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].Measure(objROI);

                                for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                                {
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].SetGaugePlacement(objParentROI.ref_ROITotalX + fLimitCenterX - (fWidth / 2),
                                                                           objParentROI.ref_ROITotalY + fLimitCenterY,
                                                                           fWidth * (m_fPointGaugeToleranceRate * m), 180);

                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].Measure(objROI);
                                    if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                                    {
                                        AddCenterPointGaugePlacementToArray_Inspection(objParentROI.ref_ROITotalX + fLimitCenterX - (fWidth / 2),
                                                                           objParentROI.ref_ROITotalY + fLimitCenterY,
                                                                           fWidth * (m_fPointGaugeToleranceRate * m), 180, m_arrSampleMatchNumber[intSampleIndex]);
                                        break;
                                    }
                                    else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                                    {
                                        AddCenterPointGaugePlacementToArray_Inspection(objParentROI.ref_ROITotalX + fLimitCenterX - (fWidth / 2),
                                                                          objParentROI.ref_ROITotalY + fLimitCenterY,
                                                                          fWidth * (m_fPointGaugeToleranceRate * m), 180, m_arrSampleMatchNumber[intSampleIndex]);
                                    }
                                }
                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                                {
                                    fBaseCenterX = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].GetMeasurePointX(0);
                                    fBaseCenterY = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].GetMeasurePointY(0);
                                    m_stcBlobLead.blnBaseCenterFound = true;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(fBaseCenterX, fBaseCenterY));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(true);
                                }
                                else
                                {
                                    fBaseCenterX = objParentROI.ref_ROITotalX + fLimitCenterX - (fWidth / 2);
                                    fBaseCenterY = objParentROI.ref_ROITotalY + fLimitCenterY;
                                    m_stcBlobLead.blnBaseCenterFound = false;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(fBaseCenterX, fBaseCenterY));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                }

                                // ------- Find Base start point -----------------------------------------
                                float fRightFixPointX = fBaseCenterX + m_intBaseOffset;

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].ref_GaugeTransType != 1)
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].ref_GaugeTransType = 1;     // Black to white

                                for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                                {
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].SetGaugePlacement(fRightFixPointX,
                                                                          fBaseCenterY - fHeight / 2,
                                                                         fHeight * (m_fPointGaugeToleranceRate * m), -90);

                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].Measure(objROI);
                                    if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fRightFixPointX,
                                                                          fBaseCenterY - fHeight / 2,
                                                                         fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.BaseStart, m_arrSampleMatchNumber[intSampleIndex]);
                                        break;
                                    }
                                    else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fRightFixPointX,
                                                                          fBaseCenterY - fHeight / 2,
                                                                         fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.BaseStart, m_arrSampleMatchNumber[intSampleIndex]);
                                    }
                                }
                                PointF pRightStart;
                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                                {
                                    pRightStart = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].GetMeasurePoint(0);
                                    m_stcBlobLead.blnBaseStartFound = true;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pRightStart.X, pRightStart.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(true);
                                }
                                else
                                {
                                    pRightStart = new PointF(fRightFixPointX, fBaseCenterY - fHeight / 2);
                                    m_stcBlobLead.blnBaseStartFound = false;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pRightStart.X, pRightStart.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                }

                                // ------- Find Base end point -----------------------------------------

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].ref_GaugeTransType != 1)
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].ref_GaugeTransType = 1;     // Black to white

                                for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                                {
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].SetGaugePlacement(fRightFixPointX,
                                                                        fBaseCenterY + fHeight / 2,
                                                                       fHeight * (m_fPointGaugeToleranceRate * m), 90);
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].Measure(objROI);
                                    if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fRightFixPointX,
                                                                        fBaseCenterY + fHeight / 2,
                                                                       fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.BaseEnd, m_arrSampleMatchNumber[intSampleIndex]);
                                        break;
                                    }
                                    else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fRightFixPointX,
                                                                        fBaseCenterY + fHeight / 2,
                                                                       fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.BaseEnd, m_arrSampleMatchNumber[intSampleIndex]);
                                    }
                                }
                                PointF pRightEnd;
                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                                {
                                    pRightEnd = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].GetMeasurePoint(0);
                                    m_stcBlobLead.blnBaseEndFound = true;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pRightEnd.X, pRightEnd.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(true);
                                }
                                else
                                {
                                    pRightEnd = new PointF(fRightFixPointX, fBaseCenterY + fHeight / 2);
                                    m_stcBlobLead.blnBaseEndFound = false;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pRightEnd.X, pRightEnd.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                }

                                // Calculate the Base width and center Y
                                fBaseWidth = pRightEnd.Y - pRightStart.Y;
                                fBaseCenterY = (pRightEnd.Y + pRightStart.Y) / 2;

                                //Tip
                                // ------- Find Tip Point X -----------------------------------------

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].ref_GaugeTransType != 1)
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].ref_GaugeTransType = 1;     // Black to white

                                for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                                {
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].SetGaugePlacement(objParentROI.ref_ROITotalX + fLimitCenterX + (fWidth / 2),
                                                                        objParentROI.ref_ROITotalY + fLimitCenterY,
                                                                        fWidth * (m_fPointGaugeToleranceRate * m), 0);

                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].Measure(objROI);
                                    if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(objParentROI.ref_ROITotalX + fLimitCenterX + (fWidth / 2),
                                                                        objParentROI.ref_ROITotalY + fLimitCenterY,
                                                                        fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.TipCenter, m_arrSampleMatchNumber[intSampleIndex]);
                                        break;
                                    }
                                    else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(objParentROI.ref_ROITotalX + fLimitCenterX + (fWidth / 2),
                                                                        objParentROI.ref_ROITotalY + fLimitCenterY,
                                                                        fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.TipCenter, m_arrSampleMatchNumber[intSampleIndex]);
                                    }
                                }
                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                                {
                                    fTipCenterX = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].GetMeasurePointX(0);
                                    fTipCenterY = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].GetMeasurePointY(0);
                                    m_stcBlobLead.blnTipCenterFound = true;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(fTipCenterX, fTipCenterY));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(true);
                                }
                                else
                                {
                                    fTipCenterX = objParentROI.ref_ROITotalX + fLimitCenterX + (fWidth / 2);
                                    fTipCenterY = objParentROI.ref_ROITotalY + fLimitCenterY;
                                    m_stcBlobLead.blnTipCenterFound = false;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(fTipCenterX, fTipCenterY));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                }

                                // ------- Find Tip start point -----------------------------------------
                                fRightFixPointX = fTipCenterX - m_intTipOffset;

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].ref_GaugeTransType != 1)
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].ref_GaugeTransType = 1;     // Black to white

                                for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                                {
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].SetGaugePlacement(fRightFixPointX,
                                                                         fTipCenterY - (fHeight / 2),
                                                                         fHeight * (m_fPointGaugeToleranceRate * m), -90);

                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].Measure(objROI);
                                    if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fRightFixPointX,
                                                                          fTipCenterY - (fHeight / 2),
                                                                         fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.TipStart, m_arrSampleMatchNumber[intSampleIndex]);
                                        break;
                                    }
                                    else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fRightFixPointX,
                                                                         fTipCenterY - (fHeight / 2),
                                                                        fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.TipStart, m_arrSampleMatchNumber[intSampleIndex]);
                                    }
                                }
                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                                {
                                    pRightStart = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].GetMeasurePoint(0);
                                    m_stcBlobLead.blnTipStartFound = true;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pRightStart.X, pRightStart.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(true);
                                }
                                else
                                {
                                    pRightStart = new PointF(fRightFixPointX, fTipCenterY - (fHeight / 2));
                                    m_stcBlobLead.blnTipStartFound = false;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pRightStart.X, pRightStart.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                }

                                // ------- Find Tip end point -----------------------------------------

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].ref_GaugeTransType != 1)
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].ref_GaugeTransType = 1;     // Black to white

                                for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                                {
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].SetGaugePlacement(fRightFixPointX,
                                                                             fTipCenterY + (fHeight / 2),
                                                                             fHeight * (m_fPointGaugeToleranceRate * m), 90);

                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].Measure(objROI);
                                    if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fRightFixPointX,
                                                                             fTipCenterY + (fHeight / 2),
                                                                             fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.TipEnd, m_arrSampleMatchNumber[intSampleIndex]);
                                        break;
                                    }
                                    else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fRightFixPointX,
                                                                             fTipCenterY + (fHeight / 2),
                                                                             fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.TipEnd, m_arrSampleMatchNumber[intSampleIndex]);
                                    }
                                }

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                                {
                                    pRightEnd = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].GetMeasurePoint(0);
                                    m_stcBlobLead.blnTipEndFound = true;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pRightEnd.X, pRightEnd.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(true);
                                }
                                else
                                {
                                    pRightEnd = new PointF(fRightFixPointX, fTipCenterY + (fHeight / 2));
                                    m_stcBlobLead.blnTipEndFound = false;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pRightEnd.X, pRightEnd.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                }

                                // ----- Find Lead min max and burr width -----------------------------------------------------------------------------
                                if ((m_intFailOptionMask & 0x100000) > 0 || (m_intFailOptionMask & 0x200000) > 0)
                                {
                                    float fRightStartMin = pRightStart.Y;
                                    float fRightStartMax = pRightStart.Y;
                                    float fRightEndMin = pRightEnd.Y;
                                    float fRightEndMax = pRightEnd.Y;

                                    // Define scanning range
                                    int intStartRangeX;
                                    int intEndRangeX;

                                    if (m_intLeadWidthRangeSelection == 0) // From shoulder to lead tip(for max) and lead offset tip(for min)
                                    {
                                        intStartRangeX = (int)Math.Ceiling(fTipCenterX);
                                        intEndRangeX = (int)Math.Round(fBaseCenterX + m_intLeadWidthRange, 0, MidpointRounding.AwayFromZero);
                                    }
                                    else // 
                                    {
                                        intStartRangeX = (int)Math.Ceiling(fTipCenterX);
                                        intEndRangeX = intStartRangeX - m_intTipOffset - m_intLeadWidthRange;
                                    }

                                    // Scan Lead start point range
                                    for (int g = intStartRangeX; g >= intEndRangeX; g--)
                                    {
                                        m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].SetGaugePlacement(g,
                                                                               fTipCenterY - (fHeight / 2),
                                                                               fHeight * m_fPointGaugeToleranceRate, -90);

                                        m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].Measure(objROI);

                                        PointF p;
                                        if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                                        {
                                            p = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].GetMeasurePoint(0);

                                        }
                                        else
                                        {
                                            continue;
                                            //p = new PointF(fLeftFixPointX, fTipCenterY - (fHeight / 2));
                                        }

                                        // Min width check from lead offset tip
                                        if (g <= (intStartRangeX - m_intTipOffset))
                                        {
                                            if (fRightStartMin > p.Y)
                                            {
                                                fRightStartMin = p.Y;
                                            }
                                        }

                                        // Max width check from lead tip
                                        if (fRightStartMax < p.Y)
                                        {
                                            fRightStartMax = p.Y;
                                        }
                                    }

                                    // Scan Lead end point range
                                    for (int g = intStartRangeX; g >= intEndRangeX; g--)
                                    {
                                        m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].SetGaugePlacement(g,
                                                                             fTipCenterY + (fHeight / 2),
                                                                             fHeight * m_fPointGaugeToleranceRate, 90);

                                        m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].Measure(objROI);

                                        PointF p;
                                        if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                                        {
                                            p = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].GetMeasurePoint(0);

                                        }
                                        else
                                        {
                                            continue;
                                            //p = new PointF(fLeftFixPointX, fTipCenterY + (fHeight / 2));
                                        }

                                        // Min width check from lead offset tip
                                        if (g <= (intStartRangeX - m_intTipOffset))
                                        {
                                            if (fRightEndMin > p.Y)
                                            {
                                                fRightEndMin = p.Y;
                                            }
                                        }

                                        // Max width check from lead tip
                                        if (fRightEndMax < p.Y)
                                        {
                                            fRightEndMax = p.Y;
                                        }
                                    }

                                    fLeadMinWidth = fRightEndMin - fRightStartMax;
                                    fLeadMaxWidth = fRightEndMax - fRightStartMin;
                                    fLeadBurrWidth = fLeadMaxWidth - fLeadMinWidth;
                                }

                                // Calculate the Tip width and center Y
                                fTipWidth = pRightEnd.Y - pRightStart.Y;
                                fTipCenterY = (pRightEnd.Y + pRightStart.Y) / 2;

                                // Base and Tip Length
                                fBaseLength = fTipCenterX - fBaseCenterX;
                                fTipLength = fTipCenterX - fBaseCenterX;

                                break;
                            //Bottom
                            case 8:
                                //Base
                                // ------- Find Base Point X -----------------------------------------

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].ref_GaugeTransType != 1)
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].ref_GaugeTransType = 1;     // Black to white

                                for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                                {
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].SetGaugePlacement(objParentROI.ref_ROITotalX + fLimitCenterX,
                                                                          objParentROI.ref_ROITotalY + fLimitCenterY - (fHeight / 2),
                                                                          fHeight * (m_fPointGaugeToleranceRate * m), -90);

                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].Measure(objROI);
                                    if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                                    {
                                        AddCenterPointGaugePlacementToArray_Inspection(objParentROI.ref_ROITotalX + fLimitCenterX,
                                                                          objParentROI.ref_ROITotalY + fLimitCenterY - (fHeight / 2),
                                                                          fHeight * (m_fPointGaugeToleranceRate * m), -90, m_arrSampleMatchNumber[intSampleIndex]);
                                        break;
                                    }
                                    else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                                    {
                                        AddCenterPointGaugePlacementToArray_Inspection(objParentROI.ref_ROITotalX + fLimitCenterX,
                                                                           objParentROI.ref_ROITotalY + fLimitCenterY - (fHeight / 2),
                                                                           fHeight * (m_fPointGaugeToleranceRate * m), -90, m_arrSampleMatchNumber[intSampleIndex]);
                                    }
                                }
                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                                {
                                    fBaseCenterX = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].GetMeasurePointX(0);
                                    fBaseCenterY = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].GetMeasurePointY(0);
                                    m_stcBlobLead.blnBaseCenterFound = true;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(fBaseCenterX, fBaseCenterY));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(true);
                                }
                                else
                                {
                                    fBaseCenterX = objParentROI.ref_ROITotalX + fLimitCenterX;
                                    fBaseCenterY = objParentROI.ref_ROITotalY + fLimitCenterY - (fHeight / 2);
                                    m_stcBlobLead.blnBaseCenterFound = false;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(fBaseCenterX, fBaseCenterY));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                }

                                // ------- Find Base start point -----------------------------------------
                                float fBottomFixPointY = fBaseCenterY + m_intBaseOffset;

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].ref_GaugeTransType != 1)
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].ref_GaugeTransType = 1;     // Black to white

                                for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                                {
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].SetGaugePlacement(fBaseCenterX - fWidth / 2,
                                                                          fBottomFixPointY,
                                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180);

                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].Measure(objROI);
                                    if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fBaseCenterX - fWidth / 2,
                                                                          fBottomFixPointY,
                                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.BaseStart, m_arrSampleMatchNumber[intSampleIndex]);
                                        break;
                                    }
                                    else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fBaseCenterX - fWidth / 2,
                                                                          fBottomFixPointY,
                                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.BaseStart, m_arrSampleMatchNumber[intSampleIndex]);
                                    }
                                }
                                PointF pBottomStart;
                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                                {
                                    pBottomStart = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].GetMeasurePoint(0);
                                    m_stcBlobLead.blnBaseStartFound = true;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pBottomStart.X, pBottomStart.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(true);
                                }
                                else
                                {
                                    pBottomStart = new PointF(fBaseCenterX - fWidth / 2, fBottomFixPointY);
                                    m_stcBlobLead.blnBaseStartFound = false;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pBottomStart.X, pBottomStart.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                }

                                // ------- Find Base end point -----------------------------------------

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].ref_GaugeTransType != 1)
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].ref_GaugeTransType = 1;     // Black to white

                                for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                                {
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].SetGaugePlacement(fBaseCenterX + fWidth / 2,
                                                                        fBottomFixPointY,
                                                                       fWidth * (m_fPointGaugeToleranceRate * m), 0);
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].Measure(objROI);
                                    if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fBaseCenterX + fWidth / 2,
                                                                      fBottomFixPointY,
                                                                     fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.BaseEnd, m_arrSampleMatchNumber[intSampleIndex]);
                                        break;
                                    }
                                    else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fBaseCenterX + fWidth / 2,
                                                                      fBottomFixPointY,
                                                                     fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.BaseEnd, m_arrSampleMatchNumber[intSampleIndex]);
                                    }
                                }
                                PointF pBottomEnd;
                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                                {
                                    pBottomEnd = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].GetMeasurePoint(0);
                                    m_stcBlobLead.blnBaseEndFound = true;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pBottomEnd.X, pBottomEnd.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(true);
                                }
                                else
                                {
                                    pBottomEnd = new PointF(fBaseCenterX + fWidth / 2, fBottomFixPointY);
                                    m_stcBlobLead.blnBaseEndFound = false;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pBottomEnd.X, pBottomEnd.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                }

                                // Calculate the Base width and center X
                                fBaseWidth = pBottomEnd.X - pBottomStart.X;
                                fBaseCenterX = (pBottomEnd.X + pBottomStart.X) / 2;

                                //Tip
                                // ------- Find Tip Point X -----------------------------------------

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].ref_GaugeTransType != 1)
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].ref_GaugeTransType = 1;     // Black to white

                                for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                                {
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].SetGaugePlacement(objParentROI.ref_ROITotalX + fLimitCenterX,
                                                                          objParentROI.ref_ROITotalY + fLimitCenterY + (fHeight / 2),
                                                                          fHeight * (m_fPointGaugeToleranceRate * m), 90);

                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].Measure(objROI);
                                    if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(objParentROI.ref_ROITotalX + fLimitCenterX,
                                                                          objParentROI.ref_ROITotalY + fLimitCenterY + (fHeight / 2),
                                                                          fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.TipCenter, m_arrSampleMatchNumber[intSampleIndex]);
                                        break;
                                    }
                                    else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(objParentROI.ref_ROITotalX + fLimitCenterX,
                                                                          objParentROI.ref_ROITotalY + fLimitCenterY + (fHeight / 2),
                                                                          fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.TipCenter, m_arrSampleMatchNumber[intSampleIndex]);
                                    }
                                }

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                                {
                                    fTipCenterX = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].GetMeasurePointX(0);
                                    fTipCenterY = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].GetMeasurePointY(0);
                                    m_stcBlobLead.blnTipCenterFound = true;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(fTipCenterX, fTipCenterY));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(true);
                                }
                                else
                                {
                                    fTipCenterX = objParentROI.ref_ROITotalX + fLimitCenterX;
                                    fTipCenterY = objParentROI.ref_ROITotalY + fLimitCenterY + (fHeight / 2);
                                    m_stcBlobLead.blnTipCenterFound = false;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(fTipCenterX, fTipCenterY));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                }

                                // ------- Find Tip start point -----------------------------------------
                                fBottomFixPointY = fTipCenterY - m_intTipOffset;

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].ref_GaugeTransType != 1)
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].ref_GaugeTransType = 1;     // Black to white

                                for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                                {
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].SetGaugePlacement(fTipCenterX - fWidth / 2,
                                                                          fBottomFixPointY,
                                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180);

                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].Measure(objROI);
                                    if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fTipCenterX - fWidth / 2,
                                                                          fBottomFixPointY,
                                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.TipStart, m_arrSampleMatchNumber[intSampleIndex]);
                                        break;
                                    }
                                    else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fTipCenterX - fWidth / 2,
                                                                          fBottomFixPointY,
                                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.TipStart, m_arrSampleMatchNumber[intSampleIndex]);
                                    }
                                }
                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                                {
                                    pBottomStart = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].GetMeasurePoint(0);
                                    m_stcBlobLead.blnTipStartFound = true;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pBottomStart.X, pBottomStart.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(true);
                                }
                                else
                                {
                                    pBottomStart = new PointF(fTipCenterX - fWidth / 2, fBottomFixPointY);
                                    m_stcBlobLead.blnTipStartFound = false;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pBottomStart.X, pBottomStart.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                }

                                // ------- Find Tip end point -----------------------------------------

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].ref_GaugeTransType != 1)
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].ref_GaugeTransType = 1;     // Black to white

                                for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                                {
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].SetGaugePlacement(fTipCenterX + fWidth / 2,
                                                                        fBottomFixPointY,
                                                                       fWidth * (m_fPointGaugeToleranceRate * m), 0);

                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].Measure(objROI);
                                    if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fTipCenterX + fWidth / 2,
                                                                        fBottomFixPointY,
                                                                       fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.TipEnd, m_arrSampleMatchNumber[intSampleIndex]);
                                        break;
                                    }
                                    else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fTipCenterX + fWidth / 2,
                                                                        fBottomFixPointY,
                                                                       fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.TipEnd, m_arrSampleMatchNumber[intSampleIndex]);
                                    }
                                }

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                                {
                                    pBottomEnd = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].GetMeasurePoint(0);
                                    m_stcBlobLead.blnTipEndFound = true;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pBottomEnd.X, pBottomEnd.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(true);
                                }
                                else
                                {
                                    pBottomEnd = new PointF(fTipCenterX + fWidth / 2, fBottomFixPointY);
                                    m_stcBlobLead.blnTipEndFound = false;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pBottomEnd.X, pBottomEnd.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                }

                                // ----- Find Lead min max and burr width -----------------------------------------------------------------------------
                                if ((m_intFailOptionMask & 0x100000) > 0 || (m_intFailOptionMask & 0x200000) > 0)
                                {
                                    float fBottomStartMin = pBottomStart.X;
                                    float fBottomStartMax = pBottomStart.X;
                                    float fBottomEndMin = pBottomEnd.X;
                                    float fBottomEndMax = pBottomEnd.X;

                                    // Define scanning range
                                    int intStartRangeY;
                                    int intEndRangeY;

                                    if (m_intLeadWidthRangeSelection == 0) // From shoulder to lead tip(for max) and lead offset tip(for min)
                                    {
                                        intStartRangeY = (int)Math.Ceiling(fTipCenterY);
                                        intEndRangeY = (int)Math.Round(fBaseCenterY + m_intLeadWidthRange, 0, MidpointRounding.AwayFromZero);
                                    }
                                    else // 
                                    {
                                        intStartRangeY = (int)Math.Ceiling(fTipCenterY);
                                        intEndRangeY = intStartRangeY - m_intTipOffset - m_intLeadWidthRange;
                                    }

                                    // Scan Lead start point range
                                    for (int g = intStartRangeY; g >= intEndRangeY; g--)
                                    {
                                        m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].SetGaugePlacement(fTipCenterX - fWidth / 2,
                                                                          g,
                                                                         fWidth * m_fPointGaugeToleranceRate, 180);

                                        m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].Measure(objROI);

                                        PointF p;
                                        if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                                        {
                                            p = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].GetMeasurePoint(0);

                                        }
                                        else
                                        {
                                            continue;
                                            //p = new PointF(fLeftFixPointX, fTipCenterY - (fHeight / 2));
                                        }

                                        // Min width check from lead offset tip
                                        if (g <= (intStartRangeY - m_intTipOffset))
                                        {
                                            if (fBottomStartMin > p.X)
                                            {
                                                fBottomStartMin = p.X;
                                            }
                                        }

                                        // Max width check from lead tip
                                        if (fBottomStartMax < p.X)
                                        {
                                            fBottomStartMax = p.X;
                                        }
                                    }

                                    // Scan Lead end point range
                                    for (int g = intStartRangeY; g >= intEndRangeY; g--)
                                    {
                                        m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].SetGaugePlacement(fTipCenterX + fWidth / 2,
                                                                g,
                                                               fWidth * m_fPointGaugeToleranceRate, 0);

                                        m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].Measure(objROI);

                                        PointF p;
                                        if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                                        {
                                            p = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].GetMeasurePoint(0);

                                        }
                                        else
                                        {
                                            continue;
                                            //p = new PointF(fLeftFixPointX, fTipCenterY + (fHeight / 2));
                                        }

                                        // Min width check from lead offset tip
                                        if (g <= (intStartRangeY - m_intTipOffset))
                                        {
                                            if (fBottomEndMin > p.X)
                                            {
                                                fBottomEndMin = p.X;
                                            }
                                        }

                                        // Max width check from lead tip
                                        if (fBottomEndMax < p.X)
                                        {
                                            fBottomEndMax = p.X;
                                        }
                                    }

                                    fLeadMinWidth = fBottomEndMin - fBottomStartMax;
                                    fLeadMaxWidth = fBottomEndMax - fBottomStartMin;
                                    fLeadBurrWidth = fLeadMaxWidth - fLeadMinWidth;
                                }

                                // Calculate the Tip width and center X
                                fTipWidth = pBottomEnd.X - pBottomStart.X;
                                fTipCenterX = (pBottomEnd.X + pBottomStart.X) / 2;
                                // Base and Tip Length
                                fBaseLength = fTipCenterY - fBaseCenterY;
                                fTipLength = fTipCenterY - fBaseCenterY;
                                break;
                            //Left
                            case 1:
                                //Base
                                // ------- Find Base Point Y -----------------------------------------

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].ref_GaugeTransType != 1)
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].ref_GaugeTransType = 1;     // Black to white

                                for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                                {
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].SetGaugePlacement(objParentROI.ref_ROITotalX + fLimitCenterX + (fWidth / 2),
                                                                         objParentROI.ref_ROITotalY + fLimitCenterY,
                                                                          fWidth * (m_fPointGaugeToleranceRate * m), 0);

                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].Measure(objROI);
                                    if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                                    {
                                        AddCenterPointGaugePlacementToArray_Inspection(objParentROI.ref_ROITotalX + fLimitCenterX + (fWidth / 2),
                                                                          objParentROI.ref_ROITotalY + fLimitCenterY,
                                                                           fWidth * (m_fPointGaugeToleranceRate * m), 0, m_arrSampleMatchNumber[intSampleIndex]);
                                        break;
                                    }
                                    else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                                    {
                                        AddCenterPointGaugePlacementToArray_Inspection(objParentROI.ref_ROITotalX + fLimitCenterX + (fWidth / 2),
                                                                         objParentROI.ref_ROITotalY + fLimitCenterY,
                                                                          fWidth * (m_fPointGaugeToleranceRate * m), 0, m_arrSampleMatchNumber[intSampleIndex]);
                                    }
                                }

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                                {
                                    fBaseCenterX = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].GetMeasurePointX(0);
                                    fBaseCenterY = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseCenter].GetMeasurePointY(0);
                                    m_stcBlobLead.blnBaseCenterFound = true;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(fBaseCenterX, fBaseCenterY));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(true);
                                }
                                else
                                {
                                    fBaseCenterX = objParentROI.ref_ROITotalX + fLimitCenterX + (fWidth / 2);
                                    fBaseCenterY = objParentROI.ref_ROITotalY + fLimitCenterY;
                                    m_stcBlobLead.blnBaseCenterFound = false;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(fBaseCenterX, fBaseCenterY));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                }

                                // ------- Find Base start point -----------------------------------------
                                float fLeftFixPointX = fBaseCenterX - m_intBaseOffset;

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].ref_GaugeTransType != 1)
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].ref_GaugeTransType = 1;     // Black to white

                                for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                                {
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].SetGaugePlacement(fLeftFixPointX,
                                                                          fBaseCenterY - fHeight / 2,
                                                                         fHeight * (m_fPointGaugeToleranceRate * m), -90);

                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].Measure(objROI);
                                    if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fLeftFixPointX,
                                                                          fBaseCenterY - fHeight / 2,
                                                                         fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.BaseStart, m_arrSampleMatchNumber[intSampleIndex]);
                                        break;
                                    }
                                    else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fLeftFixPointX,
                                                                           fBaseCenterY - fHeight / 2,
                                                                          fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.BaseStart, m_arrSampleMatchNumber[intSampleIndex]);
                                    }
                                }
                                PointF pLeftStart;
                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                                {
                                    pLeftStart = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseStart].GetMeasurePoint(0);
                                    m_stcBlobLead.blnBaseStartFound = true;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pLeftStart.X, pLeftStart.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(true);
                                }
                                else
                                {
                                    pLeftStart = new PointF(fLeftFixPointX, fBaseCenterY - fHeight / 2);
                                    m_stcBlobLead.blnBaseStartFound = false;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pLeftStart.X, pLeftStart.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                }

                                // ------- Find Base end point -----------------------------------------

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].ref_GaugeTransType != 1)
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].ref_GaugeTransType = 1;     // Black to white

                                for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                                {
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].SetGaugePlacement(fLeftFixPointX,
                                                                        fBaseCenterY + fHeight / 2,
                                                                       fHeight * (m_fPointGaugeToleranceRate * m), 90);

                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].Measure(objROI);
                                    if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fLeftFixPointX,
                                                                        fBaseCenterY + fHeight / 2,
                                                                       fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.BaseEnd, m_arrSampleMatchNumber[intSampleIndex]);
                                        break;
                                    }
                                    else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fLeftFixPointX,
                                                                        fBaseCenterY + fHeight / 2,
                                                                       fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.BaseEnd, m_arrSampleMatchNumber[intSampleIndex]);
                                    }
                                }
                                PointF pLeftEnd;
                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                                {
                                    pLeftEnd = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.BaseEnd].GetMeasurePoint(0);
                                    m_stcBlobLead.blnBaseEndFound = true;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pLeftEnd.X, pLeftEnd.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(true);
                                }
                                else
                                {
                                    pLeftEnd = new PointF(fLeftFixPointX, fBaseCenterY + fHeight / 2);
                                    m_stcBlobLead.blnBaseEndFound = false;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pLeftEnd.X, pLeftEnd.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                }

                                // Calculate the Base width center Y
                                fBaseWidth = pLeftEnd.Y - pLeftStart.Y;
                                fBaseCenterY = (pLeftEnd.Y + pLeftStart.Y) / 2;

                                //Tip
                                // ------- Find Tip Point X -----------------------------------------

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].ref_GaugeTransType != 1)
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].ref_GaugeTransType = 1;     // Black to white

                                for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                                {
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].SetGaugePlacement(objParentROI.ref_ROITotalX + fLimitCenterX - (fWidth / 2),
                                                                        objParentROI.ref_ROITotalY + fLimitCenterY,
                                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180);

                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].Measure(objROI);
                                    if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(objParentROI.ref_ROITotalX + fLimitCenterX - (fWidth / 2),
                                                                       objParentROI.ref_ROITotalY + fLimitCenterY,
                                                                        fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.TipCenter, m_arrSampleMatchNumber[intSampleIndex]);
                                        break;
                                    }
                                    else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(objParentROI.ref_ROITotalX + fLimitCenterX - (fWidth / 2),
                                                                       objParentROI.ref_ROITotalY + fLimitCenterY,
                                                                        fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.TipCenter, m_arrSampleMatchNumber[intSampleIndex]);
                                    }
                                }
                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                                {
                                    fTipCenterX = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].GetMeasurePointX(0);
                                    fTipCenterY = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipCenter].GetMeasurePointY(0);
                                    m_stcBlobLead.blnTipCenterFound = true;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(fTipCenterX, fTipCenterY));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(true);
                                }
                                else
                                {
                                    fTipCenterX = objParentROI.ref_ROITotalX + fLimitCenterX - (fWidth / 2);
                                    fTipCenterY = objParentROI.ref_ROITotalY + fLimitCenterY;
                                    m_stcBlobLead.blnTipCenterFound = false;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(fTipCenterX, fTipCenterY));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                }

                                // ------- Find Tip start point -----------------------------------------
                                fLeftFixPointX = fTipCenterX + m_intTipOffset;

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].ref_GaugeTransType != 1)
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].ref_GaugeTransType = 1;     // Black to white

                                for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                                {
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].SetGaugePlacement(fLeftFixPointX,
                                                                                          fTipCenterY - (fHeight / 2),
                                                                                             fHeight * (m_fPointGaugeToleranceRate * m), -90);

                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].Measure(objROI);
                                    if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fLeftFixPointX,
                                                                         fTipCenterY - (fHeight / 2),
                                                                          fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.TipStart, m_arrSampleMatchNumber[intSampleIndex]);
                                        break;
                                    }
                                    else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fLeftFixPointX,
                                                                        fTipCenterY - (fHeight / 2),
                                                                         fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.TipStart, m_arrSampleMatchNumber[intSampleIndex]);
                                    }
                                }
                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                                {
                                    pLeftStart = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].GetMeasurePoint(0);
                                    m_stcBlobLead.blnTipStartFound = true;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pLeftStart.X, pLeftStart.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(true);
                                }
                                else
                                {
                                    pLeftStart = new PointF(fLeftFixPointX, fTipCenterY - (fHeight / 2));
                                    m_stcBlobLead.blnTipStartFound = false;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pLeftStart.X, pLeftStart.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                }

                                // ------- Find Tip end point -----------------------------------------

                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].ref_GaugeTransType != 1)
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].ref_GaugeTransType = 1;     // Black to white

                                for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                                {
                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].SetGaugePlacement(fLeftFixPointX,
                                                                           fTipCenterY + (fHeight / 2),
                                                                             fHeight * (m_fPointGaugeToleranceRate * m), 90);

                                    m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].Measure(objROI);
                                    if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fLeftFixPointX,
                                                                           fTipCenterY + (fHeight / 2),
                                                                            fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.TipEnd, m_arrSampleMatchNumber[intSampleIndex]);
                                        break;
                                    }
                                    else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                                    {
                                        SetCenterPointGaugePlacementToArray_Inspection(fLeftFixPointX,
                                                                           fTipCenterY + (fHeight / 2),
                                                                            fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.TipEnd, m_arrSampleMatchNumber[intSampleIndex]);
                                    }
                                }
                                if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                                {
                                    pLeftEnd = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].GetMeasurePoint(0);
                                    m_stcBlobLead.blnTipEndFound = true;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pLeftEnd.X, pLeftEnd.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(true);
                                }
                                else
                                {
                                    pLeftEnd = new PointF(fLeftFixPointX, fTipCenterY + (fHeight / 2));
                                    m_stcBlobLead.blnTipEndFound = false;
                                    m_arrLead3DEdgeCenterGaugePoints[m_arrSampleMatchNumber[intSampleIndex]].Add(new PointF(pLeftEnd.X, pLeftEnd.Y));
                                    m_arrLead3DEdgeCenterGaugePointsFound[m_arrSampleMatchNumber[intSampleIndex]].Add(false);
                                }

                                // ----- Find Lead min max and burr width -----------------------------------------------------------------------------
                                if ((m_intFailOptionMask & 0x100000) > 0 || (m_intFailOptionMask & 0x200000) > 0)
                                {
                                    float fLeftStartMin = pLeftStart.Y;
                                    float fLeftStartMax = pLeftStart.Y;
                                    float fLeftEndMin = pLeftEnd.Y;
                                    float fLeftEndMax = pLeftEnd.Y;

                                    // Define scanning range
                                    int intStartRangeX;
                                    int intEndRangeX;

                                    if (m_intLeadWidthRangeSelection == 0) // From shoulder to lead tip(for max) and lead offset tip(for min)
                                    {
                                        intStartRangeX = (int)Math.Ceiling(fTipCenterX);
                                        intEndRangeX = (int)Math.Round(fBaseCenterX - m_intLeadWidthRange, 0, MidpointRounding.AwayFromZero);
                                    }
                                    else // 
                                    {
                                        intStartRangeX = (int)Math.Ceiling(fTipCenterX);
                                        intEndRangeX = intStartRangeX + m_intTipOffset + m_intLeadWidthRange;
                                    }

                                    // Scan Lead start point range
                                    for (int g = intStartRangeX; g <= intEndRangeX; g++)
                                    {
                                        m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].SetGaugePlacement(g,
                                                                         fTipCenterY - (fHeight / 2),
                                                                         fHeight * m_fPointGaugeToleranceRate, -90);

                                        m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].Measure(objROI);

                                        PointF p;
                                        if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                                        {
                                            p = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipStart].GetMeasurePoint(0);

                                        }
                                        else
                                        {
                                            continue;
                                            //p = new PointF(fLeftFixPointX, fTipCenterY - (fHeight / 2));
                                        }

                                        // Min width check from lead offset tip
                                        if (g >= (intStartRangeX + m_intTipOffset))
                                        {
                                            if (fLeftStartMin > p.Y)
                                            {
                                                fLeftStartMin = p.Y;
                                            }
                                        }

                                        // Max width check from lead tip
                                        if (fLeftStartMax < p.Y)
                                        {
                                            fLeftStartMax = p.Y;
                                        }
                                    }

                                    // Scan Lead end point range
                                    for (int g = intStartRangeX; g <= intEndRangeX; g++)
                                    {
                                        m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].SetGaugePlacement(g,
                                                                             fTipCenterY + (fHeight / 2),
                                                                             fHeight * m_fPointGaugeToleranceRate, 90);

                                        m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].Measure(objROI);

                                        PointF p;
                                        if (m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                                        {
                                            p = m_arrCenterPointGauge[m_arrSampleMatchNumber[intSampleIndex]][(int)PointIndex.TipEnd].GetMeasurePoint(0);

                                        }
                                        else
                                        {
                                            continue;
                                            //p = new PointF(fLeftFixPointX, fTipCenterY + (fHeight / 2));
                                        }

                                        // Min width check from lead offset tip
                                        if (g >= (intStartRangeX + m_intTipOffset))
                                        {
                                            if (fLeftEndMin > p.Y)
                                            {
                                                fLeftEndMin = p.Y;
                                            }
                                        }

                                        // Max width check from lead tip
                                        if (fLeftEndMax < p.Y)
                                        {
                                            fLeftEndMax = p.Y;
                                        }
                                    }

                                    fLeadMinWidth = fLeftEndMin - fLeftStartMax;
                                    fLeadMaxWidth = fLeftEndMax - fLeftStartMin;
                                    fLeadBurrWidth = fLeadMaxWidth - fLeadMinWidth;
                                }

                                // Calculate the Tip width and center Y
                                fTipWidth = pLeftEnd.Y - pLeftStart.Y;
                                fTipCenterY = (pLeftEnd.Y + pLeftStart.Y) / 2;

                                // Base and Tip Length
                                fBaseLength = fBaseCenterX - fTipCenterX;
                                fTipLength = fBaseCenterX - fTipCenterX;
                                break;
                        }

                        float fSkew = 0;
                        float fMaxOffSet = 0;
                        switch (m_stcBlobLead.intDirection)
                        {
                            case 4:
                            case 8:
                                fSkew = Get2DXinMM(Math.Abs(fBaseCenterX - fTipCenterX)); // m_fMMToPixelXValue //2019-10-11 ZJYEOH : Lead Offset or bend --> Compare the center point between base and tip

                                fMaxOffSet = Get2DXinMM(Math.Abs(m_stcBlobLead.fXDistance - (fTipCenterX - m_pCornerPoint_Center.X)));
                                break;
                            case 1:
                            case 2:
                                fSkew = Get2DYinMM(Math.Abs(fBaseCenterY - fTipCenterY)); // m_fMMToPixelYValue //2019-10-11 ZJYEOH : Lead Offset or bend --> Compare the center point between base and tip

                                fMaxOffSet = Get2DYinMM(Math.Abs(m_stcBlobLead.fYDistance - (fTipCenterY - m_pCornerPoint_Center.Y)));
                                break;
                        }

                        //float fMaxOffSet = Math.Max(Math.Abs(m_stcBlobLead.fXDistance - (fTipCenterX - m_pCornerPoint_Center.X)) / m_fMMToPixelXValue,
                        //                               Math.Abs(m_stcBlobLead.fYDistance - (fTipCenterY - m_pCornerPoint_Center.Y)) / m_fMMToPixelYValue);

                        //float fMaxOffSet = Math.Max(Get2DXinMM(Math.Abs(m_stcBlobLead.fXDistance - (fTipCenterX - GetUnitPRResultCenterX()))),//m_fMMToPixelXValue
                        //                             Get2DYinMM(Math.Abs(m_stcBlobLead.fYDistance - (fTipCenterY - GetUnitPRResultCenterY()))));//m_fMMToPixelYValue

                        //float fMaxOffSet = Math.Max(Get2DXinMM(Math.Abs(m_stcBlobLead.fXDistance - (fTipCenterX - m_pCornerPoint_Center.X))),// m_fMMToPixelXValue
                        //      Get2DYinMM(Math.Abs(m_stcBlobLead.fYDistance - (fTipCenterY - m_pCornerPoint_Center.Y))));// m_fMMToPixelYValue

                        //Collect ordinary blob data
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].intDirection = m_stcBlobLead.intDirection;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].intNoID = m_stcBlobLead.intNoID;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].intFailMask |= 0;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fStartX = fStartX;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fStartY = fStartY;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fEndX = fEndX;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fEndY = fEndY;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fCenterX = fLimitCenterX;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fCenterY = fLimitCenterY;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fGravityCenterX = fGravityCenterX;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fGravityCenterY = fGravityCenterY;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fWidth = fWidth;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fHeight = fHeight;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fArea = (float)intArea;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].intContourIndex = 0;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fBaseCenterX = fBaseCenterX - objParentROI.ref_ROITotalX;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fBaseCenterY = fBaseCenterY - objParentROI.ref_ROITotalY;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fTipCenterX = fTipCenterX - objParentROI.ref_ROITotalX;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fTipCenterY = fTipCenterY - objParentROI.ref_ROITotalY;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fBaseWidth = fBaseWidth;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fBaseLength = fBaseLength;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fTipWidth = fTipWidth;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fTipLength = fTipLength;

                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fLeadMinWidth = fLeadMinWidth;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fLeadMaxWidth = fLeadMaxWidth;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fLeadBurrWidth = fLeadBurrWidth;

                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].blnTipCenterFound = m_stcBlobLead.blnTipCenterFound;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].blnTipStartFound = m_stcBlobLead.blnTipStartFound;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].blnTipEndFound = m_stcBlobLead.blnTipEndFound;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].blnBaseCenterFound = m_stcBlobLead.blnBaseCenterFound;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].blnBaseStartFound = m_stcBlobLead.blnBaseStartFound;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].blnBaseEndFound = m_stcBlobLead.blnBaseEndFound;

                        // Collect Lead range data
                        if (fStartX < m_fSampleLeadRangeStartX)
                            m_fSampleLeadRangeStartX = fStartX;
                        if (fStartY < m_fSampleLeadRangeStartY)
                            m_fSampleLeadRangeStartY = fStartY;
                        if (fEndX > m_fSampleLeadRangeEndX)
                            m_fSampleLeadRangeEndX = fEndX;
                        if (fEndY > m_fSampleLeadRangeEndY)
                            m_fSampleLeadRangeEndY = fEndY;

                        // Collect sample blobs data in MM
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fWidthMM = Get2DXinMM(fWidth); //m_fMMToPixelXValue
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fHeightMM = Get2DYinMM(fHeight);//m_fMMToPixelXValue
                        switch (m_stcBlobLead.intDirection)
                        {
                            case 4: //Top
                            case 8: //Bottom
                                m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fTipWidthMM = Get2DXinMM(fTipWidth) + m_stcBlobLead.fWidthOffset;// / m_fMMToPixelXValue
                                m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fTipLengthMM = Get2DYinMM(fTipLength) + m_stcBlobLead.fLengthOffset;// / m_fMMToPixelXValue
                                m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fBaseWidthMM = Get2DXinMM(fBaseWidth) + m_stcBlobLead.fWidthOffset;// / m_fMMToPixelXValue
                                m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fBaseLengthMM = Get2DYinMM(fBaseLength) + m_stcBlobLead.fLengthOffset;// / m_fMMToPixelXValue

                                m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fLeadMinWidthMM = Get2DXinMM(fLeadMinWidth) + m_stcBlobLead.fWidthOffset;
                                m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fLeadMaxWidthMM = Get2DXinMM(fLeadMaxWidth) + m_stcBlobLead.fWidthOffset;
                                m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fLeadBurrWidthMM = Get2DXinMM(fLeadBurrWidth);

                                break;
                            case 1: //Left
                            case 2: //Right
                                m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fTipWidthMM = Get2DYinMM(fTipWidth) + m_stcBlobLead.fWidthOffset;// / m_fMMToPixelXValue
                                m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fTipLengthMM = Get2DXinMM(fTipLength) + m_stcBlobLead.fLengthOffset;// / m_fMMToPixelXValue
                                m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fBaseWidthMM = Get2DYinMM(fBaseWidth) + m_stcBlobLead.fWidthOffset;// / m_fMMToPixelXValue
                                m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fBaseLengthMM = Get2DXinMM(fBaseLength) + m_stcBlobLead.fLengthOffset;// / m_fMMToPixelXValue

                                m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fLeadMinWidthMM = Get2DYinMM(fLeadMinWidth) + m_stcBlobLead.fWidthOffset;
                                m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fLeadMaxWidthMM = Get2DYinMM(fLeadMaxWidth) + m_stcBlobLead.fWidthOffset;
                                m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fLeadBurrWidthMM = Get2DYinMM(fLeadBurrWidth);

                                break;
                        }
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fAreaMM = (float)intArea / m_fMMtoPixelAreaValue;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fSkewMM = (float)Math.Round(fSkew, 4, MidpointRounding.AwayFromZero);
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fOffSetMM = (float)Math.Round(fMaxOffSet, 4, MidpointRounding.AwayFromZero);
                    }
                }
            }

            // Scan which blob number still no combined
            for (int i = 0; i < arrAllBlobNo.Count; i++)
            {
                for (int j = 0; j < arrCombinedBlobNo.Count; j++)
                {
                    if (arrAllBlobNo[i] == arrCombinedBlobNo[j])
                    {
                        arrAllBlobNo.RemoveAt(i);
                        i--;
                        break;
                    }
                }
            }

            float fLimitCenterX2Extra = 0, fLimitCenterY2Extra = 0;
            float fFinalLimitCenterXExtra = 0, fFinalLimitCenterYExtra = 0;
            // Uncombined blob will be comtamination
            for (int i = 0; i < arrAllBlobNo.Count; i++)
            {
                if (m_intLeadContaminationRegion == 1)
                    break;

                m_intExtraBlobID++;
                fLimitCenterX2Extra = m_objEBlobs.ref_arrLimitCenterX[arrAllBlobNo[i]];
                fLimitCenterY2Extra = m_objEBlobs.ref_arrLimitCenterY[arrAllBlobNo[i]];


                fFinalLimitCenterXExtra = fLimitCenterX2Extra;
                fFinalLimitCenterYExtra = fLimitCenterY2Extra;
                fWidth = m_objEBlobs.ref_arrWidth[arrAllBlobNo[i]];
                fHeight = m_objEBlobs.ref_arrHeight[arrAllBlobNo[i]];
                intArea = m_objEBlobs.ref_arrArea[arrAllBlobNo[i]];

                // Reposition so that it offset to objROI
                fFinalLimitCenterXExtra += objROI.ref_ROIPositionX;
                fFinalLimitCenterYExtra += objROI.ref_ROIPositionY;

                // Get object start point and end point
                fStartX = fFinalLimitCenterXExtra - (fWidth / 2);
                fStartY = fFinalLimitCenterYExtra - (fHeight / 2);
                fEndX = fFinalLimitCenterXExtra + (fWidth / 2);
                fEndY = fFinalLimitCenterYExtra + (fHeight / 2);
                //m_blnFailForeignMaterialLength = false;
                //m_blnFailForeignMaterialArea = false;
                //m_blnFailForeignMaterialTotalArea = false;
                SampleExtraBlobsFeatures extra = new SampleExtraBlobsFeatures();
                extra.fStartX = fStartX;
                extra.fEndX = fEndX;
                extra.fStartY = fStartY;
                extra.fEndY = fEndY;
                extra.fWidth = fWidth;
                extra.fHeight = fHeight;
                extra.fCenterX = fLimitCenterX;
                extra.fCenterY = fLimitCenterY;
                extra.ref_intExtraBlobID = m_intExtraBlobID;
                float fWidthInMM = Get2DXinMM(fWidth);//m_fMMToPixelXValue
                float fHeightInMM = Get2DYinMM(fHeight);//m_fMMToPixelXValue

                float fArea = intArea * m_fAreaMMPerPixel;

                if (m_blnWantCheckExtraLeadLength)
                {
                    //////////////// Check extra Lead using length limit setting ////////////////////
                    extra.ref_fWidthFailValue = fWidthInMM;
                    extra.ref_fHeightFailValue = fHeightInMM;

                    if ((fWidthInMM > m_fExtraLeadSetLength) ||
                        (fHeightInMM > m_fExtraLeadSetLength))
                    {

                        if (fWidthInMM > m_fExtraLeadSetLength)
                        {
                            extra.ref_intFailCriteria |= 0x01;
                            m_arrFailResultMask[0] |= 0x8000;
                        }

                        if (fHeightInMM > m_fExtraLeadSetLength)
                        {
                            extra.ref_intFailCriteria |= 0x02;
                            m_arrFailResultMask[0] |= 0x8000;
                        }
                        m_blnFailForeignMaterialLength = true;
                        // Collect extra Lead min and max area for display error message
                        //if ((fWidthInMM > m_fExtraLeadSetLength) &&
                        //(fHeightInMM > m_fExtraLeadSetLength))
                        //{
                        //    float fMin = Math.Min(fWidthInMM, fHeightInMM);
                        //    if ((m_fResultExtraLeadMinArea == -1) || (fMin < m_fResultExtraLeadMinArea))
                        //        m_fResultExtraLeadMinArea = fMin;

                        //    float fMax = Math.Max(fWidthInMM, fHeightInMM);
                        //    if ((m_fResultExtraLeadMaxArea == -1) || (fMax > m_fResultExtraLeadMaxArea))
                        //        m_fResultExtraLeadMaxArea = fMax;
                        //}
                        //else if (fWidthInMM > m_fExtraLeadSetLength)
                        //{
                        //    if ((m_fResultExtraLeadMinArea == -1) || (fWidthInMM < m_fResultExtraLeadMinArea))
                        //        m_fResultExtraLeadMinArea = fWidthInMM;
                        //    if ((m_fResultExtraLeadMaxArea == -1) || (fWidthInMM > m_fResultExtraLeadMaxArea))
                        //        m_fResultExtraLeadMaxArea = fWidthInMM;
                        //}
                        //else if (fHeightInMM > m_fExtraLeadSetLength)
                        //{
                        //    if ((m_fResultExtraLeadMinArea == -1) || (fHeightInMM < m_fResultExtraLeadMinArea))
                        //        m_fResultExtraLeadMinArea = fHeightInMM;
                        //    if ((m_fResultExtraLeadMaxArea == -1) || (fHeightInMM > m_fResultExtraLeadMaxArea))
                        //        m_fResultExtraLeadMaxArea = fHeightInMM;
                        //}
                    }

                }

                if (m_blnWantCheckExtraLeadArea)
                {
                    //////////////// Check extra Lead using area limit setting ////////////////////
                    // Change unit pixel to mm
                    extra.ref_fAreaFailValue = fArea;
                    if (fArea > m_fExtraLeadSetArea)
                    {
                        m_blnFailForeignMaterialArea = true;
                        extra.ref_intFailCriteria |= 0x04;

                        m_arrFailResultMask[0] |= 0x8000;
                        //// Collect extra Lead min and max area for display error message
                        //if ((m_fResultExtraLeadMinArea == -1) || (fArea < m_fResultExtraLeadMinArea))
                        //    m_fResultExtraLeadMinArea = fArea;
                        //if ((m_fResultExtraLeadMaxArea == -1) || (fArea > m_fResultExtraLeadMaxArea))
                        //    m_fResultExtraLeadMaxArea = fArea;
                    }
                    //////////////////////////////////////////////////////////////////////
                }

                //////////////// Get Total Extra pad unit area ///////////////////////////////
                if ((m_intFailOptionMask & 0x10000) > 0)
                {
                    m_fTotalExtraArea += fArea;
                }
                if (m_blnWantCheckExtraLeadLength || m_blnWantCheckExtraLeadArea || ((m_intFailOptionMask & 0x10000) > 0))
                    m_arrExtraBlobs.Add(extra);
            }

            //if (((m_intFailOptionMask & 0x10000) > 0) && !m_blnFailForeignMaterialLength && !m_blnFailForeignMaterialArea)
            //{
            //    if (fTotalExtraArea > 0)
            //    {
            //        m_intExtraBlobID++;
            //        //////////////// Check Total Extra pad unit area ///////////////////////////////
            //        SampleExtraBlobsFeatures extra = new SampleExtraBlobsFeatures();
            //        extra.ref_intExtraBlobID = m_intExtraBlobID;
            //        extra.ref_fWidthFailValue = -999;
            //        extra.ref_fHeightFailValue = -999;
            //        extra.ref_fAreaFailValue = fTotalExtraArea;
            //        if (fTotalExtraArea > m_fTotalExtraLeadSetArea)
            //        {
            //            m_blnFailForeignMaterialTotalArea = true;
            //            for (int i = 0; i < m_arrExtraBlobs.Count; i++)
            //            {
            //                SampleExtraBlobsFeatures objExtraBlob = m_arrExtraBlobs[i];
            //                objExtraBlob.ref_intFailCriteria |= 0x08;
            //                m_arrExtraBlobs[i] = objExtraBlob;
            //            }
            //            extra.ref_intFailCriteria |= 0x04;
            //            m_arrFailResultMask[0] |= 0x10000;
            //        }
            //        m_arrExtraBlobs.Add(extra);
            //    }
            //}
        }
        private void MeasureDimension_CenterLeads(ROI objParentROI, ROI objROI, int intNumberOfLead)
        {
            // Testing Type:
            // 1. Match Blobs Object to Template Lead
            // 2. Find reference point of lead

            float fLimitCenterX = 0;
            float fLimitCenterY = 0;
            float fWidth = 0;
            float fHeight = 0;
            float fOrgX = 0;
            float fOrgY = 0;
            int intTotalBlobCount = 0;
            int intArea = 0;
            float fGravityCenterX = 0;
            float fGravityCenterY = 0;
            float fStartX = 0;
            float fStartY = 0;
            float fEndX = 0;
            float fEndY = 0;
            float fBaseCenterX = 0;
            float fBaseCenterY = 0;
            float fBaseWidth = 0;
            float fBaseLength = 0;
            float fTipCenterX = 0;
            float fTipCenterY = 0;
            float fTipWidth = 0;
            float fTipLength = 0;
            int intFixPointXY = 0;
            int intSampleIndex = 0;
            List<int> arrSkipNo = new List<int>();
            bool blnSkipToNextObject = false;

            int intSelectedObjectNum = 0;
            if (m_objEBlobs.ref_intNumSelectedObject >= intNumberOfLead)
                intSelectedObjectNum = intNumberOfLead;
            else
                intSelectedObjectNum = m_objEBlobs.ref_intNumSelectedObject;

            // Assign blobs to sample arrary
            for (int i = 0; i < intSelectedObjectNum; i++)
            {
                for (int k = 0; k < arrSkipNo.Count; k++)
                {
                    if (i == arrSkipNo[k])
                    {
                        blnSkipToNextObject = true;
                        break;
                    }
                }

                if (blnSkipToNextObject)
                {
                    blnSkipToNextObject = false;
                    continue;
                }

                m_arrSampleMatchNumber.Add(-1);
                intSampleIndex = m_arrSampleMatchNumber.Count - 1;

                float fFromROIOffsetLimitCenterX = objROI.ref_ROIPositionX + m_objEBlobs.ref_arrLimitCenterX[i];
                float fFromROIOffsetLimitCenterY = objROI.ref_ROIPositionY + m_objEBlobs.ref_arrLimitCenterY[i];
                // Get blob center point, start point and size
                fWidth = m_objEBlobs.ref_arrWidth[i];
                fHeight = m_objEBlobs.ref_arrHeight[i];
                fOrgX = fFromROIOffsetLimitCenterX - fWidth / 2;
                fOrgY = fFromROIOffsetLimitCenterY - fHeight / 2;
                intArea = 0;
                fGravityCenterX = 0;
                fGravityCenterY = 0;
                fLimitCenterX = 0;
                fLimitCenterY = 0;
                fStartX = fOrgX;
                fStartY = fOrgY;
                fEndX = fOrgX + fWidth;
                fEndY = fOrgY + fHeight;
                intTotalBlobCount = 0;
                fTipWidth = 0;
                fTipLength = 0;
                fBaseWidth = 0;
                fBaseLength = 0;

                // Search Is there other blobs same under same lead area.
                for (int j = i; j < m_objEBlobs.ref_intNumSelectedObject; j++)
                {
                    float fFromROIOffsetCenterX2 = objROI.ref_ROIPositionX + m_objEBlobs.ref_arrGravityCenterX[j];
                    float fFromROIOffsetCenterY2 = objROI.ref_ROIPositionY + m_objEBlobs.ref_arrGravityCenterY[j];
                    float fFromROIOffsetLimitCenterX2 = objROI.ref_ROIPositionX + m_objEBlobs.ref_arrLimitCenterX[j];
                    float fFromROIOffsetLimitCenterY2 = objROI.ref_ROIPositionY + m_objEBlobs.ref_arrLimitCenterY[j];

                    if (m_intLeadDirection == 0)    // Horizontal
                    {
                        //Horizontal lead
                        if (fFromROIOffsetLimitCenterY2 < fOrgY || fFromROIOffsetLimitCenterY2 > (fOrgY + fHeight))
                            continue;
                    }
                    else
                    {
                        //Vertical lead
                        if (fFromROIOffsetLimitCenterX2 < fOrgX || fFromROIOffsetLimitCenterX2 > (fOrgX + fWidth))
                            continue;
                    }

                    if (intSelectedObjectNum >= j && i != j)
                    {
                        if (m_objEBlobs.ref_intNumSelectedObject > intSelectedObjectNum)
                            intSelectedObjectNum++;
                        arrSkipNo.Add(j);
                    }

                    intArea += m_objEBlobs.ref_arrArea[j];
                    fGravityCenterX += fFromROIOffsetCenterX2 * m_objEBlobs.ref_arrArea[j];
                    fGravityCenterY += fFromROIOffsetCenterY2 * m_objEBlobs.ref_arrArea[j];

                    if (fStartX > fFromROIOffsetLimitCenterX2 - (m_objEBlobs.ref_arrWidth[j] / 2))
                    {
                        fStartX = fFromROIOffsetLimitCenterX2 - (m_objEBlobs.ref_arrWidth[j] / 2);
                    }

                    if (fStartY > fFromROIOffsetLimitCenterY2 - (m_objEBlobs.ref_arrHeight[j] / 2))
                    {
                        fStartY = fFromROIOffsetLimitCenterY2 - (m_objEBlobs.ref_arrHeight[j] / 2);
                    }

                    if (fEndX < fFromROIOffsetLimitCenterX2 + (m_objEBlobs.ref_arrWidth[j] / 2))
                    {
                        fEndX = fFromROIOffsetLimitCenterX2 + (m_objEBlobs.ref_arrWidth[j] / 2);
                    }

                    if (fEndY < fFromROIOffsetLimitCenterY2 + (m_objEBlobs.ref_arrHeight[j] / 2))
                    {
                        fEndY = fFromROIOffsetLimitCenterY2 + (m_objEBlobs.ref_arrHeight[j] / 2);
                    }

                    intTotalBlobCount++;
                }

                if (intArea == 0)
                {
                    continue;
                }
                fGravityCenterX = fGravityCenterX / intArea;
                fGravityCenterY = fGravityCenterY / intArea;
                fLimitCenterX = (fEndX + fStartX) / 2;
                fLimitCenterY = (fEndY + fStartY) / 2;
                fWidth = fEndX - fStartX;
                fHeight = fEndY - fStartY;

                // Get template number which match with sample
                List<int> arrMatch = MatchTemplateObjects_Inspection(objROI, fStartX, fStartY,
                                                        fEndX, fEndY,
                                                        fWidth, fHeight,
                                                        fBaseWidth, fBaseLength,
                                                        fTipWidth, fTipLength,
                                                        fGravityCenterX, fGravityCenterY,
                                                        intArea);
                for (int j = 0; j < arrMatch.Count; j++)
                    m_intTemplateMatchStatus[arrMatch[j]]++;

                if (arrMatch.Count == 0)        // Set to -1 if match nothing with any template leads
                    m_arrSampleMatchNumber[intSampleIndex] = -1;
                else if (arrMatch.Count > 1)    // Set to -2 if match more than 1 template leads
                    m_arrSampleMatchNumber[intSampleIndex] = -2;
                else
                    m_arrSampleMatchNumber[intSampleIndex] = arrMatch[0];

                // No template match with sample
                if (m_arrSampleMatchNumber[intSampleIndex] == -1)
                {
                }
                // More than 1 templates match with sample
                if (m_arrSampleMatchNumber[intSampleIndex] == -2)
                {
                    //Join/Bridge Lead
                    SampleExtraBlobsFeatures extra = new SampleExtraBlobsFeatures();
                    extra.fStartX = fStartX;
                    extra.fEndX = fEndX;
                    extra.fStartY = fStartY;
                    extra.fEndY = fEndY;
                    extra.fWidth = fWidth;
                    extra.fHeight = fHeight;
                    extra.fCenterX = fLimitCenterX;
                    extra.fCenterY = fLimitCenterY;

                    m_arrExtraBlobs.Add(extra);

                    for (int b = 0; b < arrMatch.Count; b++)
                    {
                        m_arrSampleBlobLeads[arrMatch[b]].intFailMask |= 0x10;  // Bridging or Un-Cut TieBar
                    }

                    m_arrFailResultMask[0] |= 0x10;
                }
                //Sample fall in Don't Care ROI area
                else if (m_arrSampleMatchNumber[intSampleIndex] == -3)
                {
                    return;
                }
                // Found only 1 templates match with sample
                else if (m_arrSampleMatchNumber[intSampleIndex] >= 0)
                {
                    if (m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fArea == -999)
                    {
                        m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[m_arrSampleMatchNumber[intSampleIndex]];

                        switch (m_stcBlobLead.intDirection)
                        {
                            //Top
                            case 4:
                                //Base             
                                fBaseWidth = fWidth;
                                fBaseLength = fHeight;
                                intFixPointXY = (int)Math.Round(fLimitCenterY + (fHeight / 2) - m_intBaseOffset, 0, MidpointRounding.AwayFromZero);
                                Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objParentROI, fLimitCenterX, fLimitCenterY,
                                        ref fBaseWidth, ref fBaseLength, ref fBaseCenterX, ref fBaseCenterY, m_intThresholdValue, true, true, intFixPointXY);

                                //Tip
                                fTipWidth = fWidth;
                                fTipLength = fHeight;
                                intFixPointXY = (int)Math.Round(fLimitCenterY - (fHeight / 2) + m_intTipOffset, 0, MidpointRounding.AwayFromZero);
                                Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objParentROI, fLimitCenterX, fLimitCenterY,
                                        ref fTipWidth, ref fTipLength, ref fTipCenterX, ref fTipCenterY, m_intThresholdValue, true, false, intFixPointXY);

                                break;
                            //Right
                            case 2:
                                //Base
                                fBaseLength = fWidth;
                                fBaseWidth = fHeight;
                                intFixPointXY = (int)Math.Round(fLimitCenterX - (fWidth / 2) + m_intBaseOffset, 0, MidpointRounding.AwayFromZero);
                                Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objParentROI, fLimitCenterX, fLimitCenterY,
                                        ref fBaseLength, ref fBaseWidth, ref fBaseCenterX, ref fBaseCenterY, m_intThresholdValue, false, false, intFixPointXY);

                                //Tip
                                fTipLength = fWidth;
                                fTipWidth = fHeight;
                                intFixPointXY = (int)Math.Round(fLimitCenterX + (fWidth / 2) - m_intTipOffset, 0, MidpointRounding.AwayFromZero);
                                Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objParentROI, fLimitCenterX, fLimitCenterY,
                                        ref fTipLength, ref fTipWidth, ref fTipCenterX, ref fTipCenterY, m_intThresholdValue, false, true, intFixPointXY);

                                break;
                            //Bottom
                            case 8:
                                //Base
                                fBaseWidth = fWidth;
                                fBaseLength = fHeight;
                                intFixPointXY = (int)Math.Round(fLimitCenterY - (fHeight / 2) + m_intBaseOffset, 0, MidpointRounding.AwayFromZero);
                                Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objParentROI, fLimitCenterX, fLimitCenterY,
                                        ref fBaseWidth, ref fBaseLength, ref fBaseCenterX, ref fBaseCenterY, m_intThresholdValue, true, false, intFixPointXY);

                                //Tip
                                fTipWidth = fWidth;
                                fTipLength = fHeight;
                                intFixPointXY = (int)Math.Round(fLimitCenterY + (fHeight / 2) - m_intTipOffset, 0, MidpointRounding.AwayFromZero);
                                Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objParentROI, fLimitCenterX, fLimitCenterY,
                                        ref fTipWidth, ref fTipLength, ref fTipCenterX, ref fTipCenterY, m_intThresholdValue, true, true, intFixPointXY);

                                break;
                            //Left
                            case 1:
                                //Base
                                fBaseLength = fWidth;
                                fBaseWidth = fHeight;
                                intFixPointXY = (int)Math.Round(fLimitCenterX + (fWidth / 2) - m_intBaseOffset, 0, MidpointRounding.AwayFromZero);
                                Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objParentROI, fLimitCenterX, fLimitCenterY,
                                        ref fBaseLength, ref fBaseWidth, ref fBaseCenterX, ref fBaseCenterY, m_intThresholdValue, false, true, intFixPointXY);

                                //Tip
                                fTipLength = fWidth;
                                fTipWidth = fHeight;
                                intFixPointXY = (int)Math.Round(fLimitCenterX - (fWidth / 2) + m_intTipOffset, 0, MidpointRounding.AwayFromZero);
                                Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objParentROI, fLimitCenterX, fLimitCenterY,
                                        ref fTipLength, ref fTipWidth, ref fTipCenterX, ref fTipCenterY, m_intThresholdValue, false, false, intFixPointXY);
                                break;
                        }


                        //Collect ordinary blob data
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].intDirection = m_stcBlobLead.intDirection;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].intNoID = m_stcBlobLead.intNoID;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].intFailMask |= 0;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fStartX = fStartX;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fStartY = fStartY;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fEndX = fEndX;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fEndY = fEndY;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fCenterX = fLimitCenterX;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fCenterY = fLimitCenterY;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fGravityCenterX = fGravityCenterX;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fGravityCenterY = fGravityCenterY;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fWidth = fWidth;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fHeight = fHeight;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fArea = (float)intArea;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].intContourIndex = 0;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fBaseCenterX = fBaseCenterX;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fBaseCenterY = fBaseCenterY;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fTipCenterX = fTipCenterX;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fTipCenterY = fTipCenterY;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fBaseWidth = fBaseWidth;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fBaseLength = fBaseLength;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fTipWidth = fTipWidth;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fTipLength = fTipLength;

                        // Collect Lead range data
                        if (fStartX < m_fSampleLeadRangeStartX)
                            m_fSampleLeadRangeStartX = fStartX;
                        if (fStartY < m_fSampleLeadRangeStartY)
                            m_fSampleLeadRangeStartY = fStartY;
                        if (fEndX > m_fSampleLeadRangeEndX)
                            m_fSampleLeadRangeEndX = fEndX;
                        if (fEndY > m_fSampleLeadRangeEndY)
                            m_fSampleLeadRangeEndY = fEndY;

                        // Collect sample blobs data in MM
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fWidthMM = Get2DXinMM(fWidth);//m_fMMToPixelXValue
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fHeightMM = Get2DYinMM(fHeight);//m_fMMToPixelXValue
                        switch (m_stcBlobLead.intDirection)
                        {
                            case 4: //Top
                            case 8: //Bottom
                                m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fTipWidthMM = Get2DXinMM(fTipWidth);// / m_fMMToPixelXValue
                                m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fTipLengthMM = Get2DYinMM(fTipLength);// / m_fMMToPixelXValue
                                m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fBaseWidthMM = Get2DXinMM(fBaseWidth);// / m_fMMToPixelXValue
                                m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fBaseLengthMM = Get2DYinMM(fBaseLength);// / m_fMMToPixelXValue
                                break;
                            case 1: //Left
                            case 2: //Right
                                m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fTipWidthMM = Get2DYinMM(fTipWidth);// / m_fMMToPixelXValue
                                m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fTipLengthMM = Get2DXinMM(fTipLength);// / m_fMMToPixelXValue
                                m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fBaseWidthMM = Get2DYinMM(fBaseWidth);// / m_fMMToPixelXValue
                                m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fBaseLengthMM = Get2DXinMM(fBaseLength);// / m_fMMToPixelXValue
                                break;
                        }
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[intSampleIndex]].fAreaMM = (float)intArea / m_fMMtoPixelAreaValue;
                    }
                }
            }
        }

        private void CheckReferencePoint()
        {
            //switch (m_stcBlobLead.intGroupID)
            //{
            //    case 1:
            //        for (int i = 0; i < m_arrSampleBlobLeads.Length; i++)
            //        {
            //            ////Skip if join Lead
            //            if ((m_arrSampleBlobLeads[i].intFailMask & 0x02) > 0)
            //                return;

            //            ////Skip if missing Lead
            //            if ((m_arrSampleBlobLeads[i].intFailMask & 0x04) > 0)
            //                return;

            //            if (m_arrSampleBlobLeads[i].fBaseCenterX - m_arrSampleBlobLeads[i].fBaseWidth / 2 < m_fSampleReferencePointStartX)
            //            {
            //                m_fSampleReferencePointStartX = m_arrSampleBlobLeads[i].fBaseCenterX - m_arrSampleBlobLeads[i].fBaseWidth / 2;
            //                m_fSampleReferencePointStartY = m_arrSampleBlobLeads[i].fCenterY + m_arrSampleBlobLeads[i].fHeight / 2;
            //            }

            //            if (m_arrSampleBlobLeads[i].fBaseCenterX + m_arrSampleBlobLeads[i].fBaseWidth / 2 > m_fSampleReferencePointEndX)
            //            {
            //                m_fSampleReferencePointEndX = m_arrSampleBlobLeads[i].fBaseCenterX + m_arrSampleBlobLeads[i].fBaseWidth / 2;
            //                m_fSampleReferencePointEndY = m_arrSampleBlobLeads[i].fCenterY + m_arrSampleBlobLeads[i].fHeight / 2;
            //            }
            //        }
            //        break;
            //    case 2:
            //        for (int i = 0; i < m_arrSampleBlobLeads.Length; i++)
            //        {
            //            ////Skip if join Lead
            //            if ((m_arrSampleBlobLeads[i].intFailMask & 0x02) > 0)
            //                return;

            //            ////Skip if missing Lead
            //            if ((m_arrSampleBlobLeads[i].intFailMask & 0x04) > 0)
            //                return;

            //            if (m_arrSampleBlobLeads[i].fBaseCenterY - m_arrSampleBlobLeads[i].fBaseLength / 2 < m_fSampleReferencePointStartY)
            //            {
            //                m_fSampleReferencePointStartY = m_arrSampleBlobLeads[i].fBaseCenterY - m_arrSampleBlobLeads[i].fBaseLength / 2;
            //                m_fSampleReferencePointStartX = m_arrSampleBlobLeads[i].fCenterX - m_arrSampleBlobLeads[i].fWidth / 2;
            //            }

            //            if (m_arrSampleBlobLeads[i].fBaseCenterY + m_arrSampleBlobLeads[i].fBaseLength / 2 > m_fSampleReferencePointEndY)
            //            {
            //                m_fSampleReferencePointEndY = m_arrSampleBlobLeads[i].fBaseCenterY + m_arrSampleBlobLeads[i].fBaseLength / 2;
            //                m_fSampleReferencePointEndX = m_arrSampleBlobLeads[i].fCenterX - m_arrSampleBlobLeads[i].fWidth / 2;
            //            }
            //        }
            //        break;
            //    case 3:
            //        for (int i = 0; i < m_arrSampleBlobLeads.Length; i++)
            //        {
            //            ////Skip if join Lead
            //            if ((m_arrSampleBlobLeads[i].intFailMask & 0x02) > 0)
            //                return;

            //            ////Skip if missing Lead
            //            if ((m_arrSampleBlobLeads[i].intFailMask & 0x04) > 0)
            //                return;

            //            if (m_arrSampleBlobLeads[i].fBaseCenterX - m_arrSampleBlobLeads[i].fBaseWidth / 2 < m_fSampleReferencePointStartX)
            //            {
            //                m_fSampleReferencePointStartX = m_arrSampleBlobLeads[i].fBaseCenterX - m_arrSampleBlobLeads[i].fBaseWidth / 2;
            //                m_fSampleReferencePointStartY = m_arrSampleBlobLeads[i].fCenterY - m_arrSampleBlobLeads[i].fHeight / 2;
            //            }

            //            if (m_arrSampleBlobLeads[i].fBaseCenterX + m_arrSampleBlobLeads[i].fBaseWidth / 2 > m_fSampleReferencePointEndX)
            //            {
            //                m_fSampleReferencePointEndX = m_arrSampleBlobLeads[i].fBaseCenterX + m_arrSampleBlobLeads[i].fBaseWidth / 2;
            //                m_fSampleReferencePointEndY = m_arrSampleBlobLeads[i].fCenterY - m_arrSampleBlobLeads[i].fHeight / 2;
            //            }
            //        }
            //        break;
            //    case 4:
            //        for (int i = 0; i < m_arrSampleBlobLeads.Length; i++)
            //        {
            //            ////Skip if join Lead
            //            if ((m_arrSampleBlobLeads[i].intFailMask & 0x02) > 0)
            //                return;

            //            ////Skip if missing Lead
            //            if ((m_arrSampleBlobLeads[i].intFailMask & 0x04) > 0)
            //                return;

            //            if (m_arrSampleBlobLeads[i].fBaseCenterY - m_arrSampleBlobLeads[i].fBaseLength / 2 < m_fSampleReferencePointStartY)
            //            {
            //                m_fSampleReferencePointStartY = m_arrSampleBlobLeads[i].fBaseCenterY - m_arrSampleBlobLeads[i].fBaseLength / 2;
            //                m_fSampleReferencePointStartX = m_arrSampleBlobLeads[i].fCenterX + m_arrSampleBlobLeads[i].fWidth / 2;
            //            }

            //            if (m_arrSampleBlobLeads[i].fBaseCenterY + m_arrSampleBlobLeads[i].fBaseLength / 2 > m_fSampleReferencePointEndY)
            //            {
            //                m_fSampleReferencePointEndY = m_arrSampleBlobLeads[i].fBaseCenterY + m_arrSampleBlobLeads[i].fBaseLength / 2;
            //                m_fSampleReferencePointEndX = m_arrSampleBlobLeads[i].fCenterX + m_arrSampleBlobLeads[i].fWidth / 2;
            //            }
            //        }
            //        break;
            //}

            //// ---------------------------- Check reference point ----------------------------

            //if (!MatchTemplateObjectsReferencePoint())
            //{
            //    m_arrFailResultMask[0] |= 0x01;
            //    return;
            //}
        }

        private void CheckAverageGrayValue_CenterLeads(ROI objROI)
        {
            if ((m_intFailOptionMask & 0x40000) == 0 || !m_blnWantUseAverageGrayValueMethod)
                return;

            for (int i = 0; i < m_arrSampleBlobLeads.Length; i++)
            {
                ////Skip if fail reference point
                if ((m_arrSampleBlobLeads[i].intFailMask & 0x01) > 0)
                    continue;

                ////Skip if join Lead
                if ((m_arrSampleBlobLeads[i].intFailMask & 0x10) > 0) // 0x02
                    continue;

                ////Skip if missing Lead
                if ((m_arrSampleBlobLeads[i].intFailMask & 0x20) > 0) //0x04
                    continue;

                float fStartX = 0, fStartY = 0, fWidth = 0, fHeight = 0;

                m_stcSampleBlobLead = (SampleBlobsFeatures)m_arrSampleBlobLeads[i];
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                //fStartX = (intROIX + m_stcSampleBlobLead.fStartX + m_stcBlobLead.intAGVROITolerance_Left) * fScaleX;
                //fStartY = (intROIY + m_stcSampleBlobLead.fStartY + m_stcBlobLead.intAGVROITolerance_Top) * fScaleY;
                //fEndX = (intROIX + m_stcSampleBlobLead.fEndX - m_stcBlobLead.intAGVROITolerance_Right) * fScaleX;
                //fEndY = (intROIY + m_stcSampleBlobLead.fEndY - m_stcBlobLead.intAGVROITolerance_Bottom) * fScaleY;
                switch (m_stcSampleBlobLead.intDirection)
                {
                    case 4: // Top
                        fStartX = (m_stcSampleBlobLead.fTipCenterX - (m_stcSampleBlobLead.fTipWidth / 2) + m_stcBlobLead.intAGVROITolerance_Left);
                        fStartY = (m_stcSampleBlobLead.fTipCenterY + m_stcBlobLead.intAGVROITolerance_Top);
                        fWidth = (m_stcSampleBlobLead.fTipWidth - m_stcBlobLead.intAGVROITolerance_Left - m_stcBlobLead.intAGVROITolerance_Right);
                        fHeight = (m_stcSampleBlobLead.fTipLength - m_stcBlobLead.intAGVROITolerance_Top - m_stcBlobLead.intAGVROITolerance_Bottom);
                        break;
                    case 8: // Bottom
                        fStartX = (m_stcSampleBlobLead.fTipCenterX - (m_stcSampleBlobLead.fTipWidth / 2) + m_stcBlobLead.intAGVROITolerance_Left);
                        fStartY = (m_stcSampleBlobLead.fTipCenterY - m_stcSampleBlobLead.fTipLength + m_stcBlobLead.intAGVROITolerance_Top);
                        fWidth = (m_stcSampleBlobLead.fTipWidth - m_stcBlobLead.intAGVROITolerance_Left - m_stcBlobLead.intAGVROITolerance_Right);
                        fHeight = (m_stcSampleBlobLead.fTipLength - m_stcBlobLead.intAGVROITolerance_Top - m_stcBlobLead.intAGVROITolerance_Bottom);
                        break;
                    case 1: // Left
                        fStartX = (m_stcSampleBlobLead.fTipCenterX + m_stcBlobLead.intAGVROITolerance_Left);
                        fStartY = (m_stcSampleBlobLead.fTipCenterY - (m_stcSampleBlobLead.fTipWidth / 2) + m_stcBlobLead.intAGVROITolerance_Top);
                        fWidth = (m_stcSampleBlobLead.fTipLength - m_stcBlobLead.intAGVROITolerance_Left - m_stcBlobLead.intAGVROITolerance_Right);
                        fHeight = (m_stcSampleBlobLead.fTipWidth - m_stcBlobLead.intAGVROITolerance_Top - m_stcBlobLead.intAGVROITolerance_Bottom);
                        break;
                    case 2: // Right
                        fStartX = (m_stcSampleBlobLead.fTipCenterX - m_stcSampleBlobLead.fTipLength + m_stcBlobLead.intAGVROITolerance_Left);
                        fStartY = (m_stcSampleBlobLead.fTipCenterY - (m_stcSampleBlobLead.fTipWidth / 2) + m_stcBlobLead.intAGVROITolerance_Top);
                        fWidth = (m_stcSampleBlobLead.fTipLength - m_stcBlobLead.intAGVROITolerance_Left - m_stcBlobLead.intAGVROITolerance_Right);
                        fHeight = (m_stcSampleBlobLead.fTipWidth - m_stcBlobLead.intAGVROITolerance_Top - m_stcBlobLead.intAGVROITolerance_Bottom);
                        break;
                }
                if (fStartX < 0)
                    fStartX = 0;
                if (fStartY < 0)
                    fStartY = 0;
                if (fWidth < 1)
                    fWidth = 1;
                if (fHeight < 1)
                    fHeight = 1;
                float fAverageGrayValue = 0;
                ROI objTempROI = new ROI();
                objTempROI.LoadROISetting((int)Math.Round(fStartX, 0), (int)Math.Round(fStartY, 0), (int)Math.Round(fWidth, 0), (int)Math.Round(fHeight, 0));
                objTempROI.AttachImage(objROI);

                ROI objThresholdROI = new ROI();
                objThresholdROI.LoadROISetting((int)Math.Round(fStartX, 0), (int)Math.Round(fStartY, 0), (int)Math.Round(fWidth, 0), (int)Math.Round(fHeight, 0));
                ImageDrawing objTempImage = new ImageDrawing(true);

                objROI.CopyToImage(ref objTempImage);
                objThresholdROI.AttachImage(objTempImage);

                EasyImage.PixelAverage(objTempROI.ref_ROI, out fAverageGrayValue);

                if (m_blnWantUseAGVMasking)
                {
                    int intThreshold = (int)Math.Round(fAverageGrayValue);

                    //objThresholdROI.ref_ROI.Save("D:\\objThresholdROI1.bmp");
                    //objROI.ref_ROI.Save("D:\\objROI1.bmp");
#if (Debug_2_12 || Release_2_12)
                    EasyImage.Threshold(objThresholdROI.ref_ROI, objThresholdROI.ref_ROI, (uint)intThreshold);
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                    EasyImage.Threshold(objThresholdROI.ref_ROI, objThresholdROI.ref_ROI, intThreshold);
#endif

                    //objThresholdROI.ref_ROI.Save("D:\\objThresholdROI2.bmp");
                    // Step 3 : invert the thrshold ROI 
                    //EasyImage.Oper(EArithmeticLogicOperation.Invert, objThresholdROI.ref_ROI, objThresholdROI.ref_ROI);
                    ROI.InvertOperationROI(objThresholdROI);
                    //objThresholdROI.ref_ROI.Save("D:\\objThresholdROI3.bmp");

                    fAverageGrayValue = 0;
                    EasyImage.PixelAverage(objTempROI.ref_ROI, objThresholdROI.ref_ROI, out fAverageGrayValue);
                    //objTempROI.ref_ROI.Save("D:\\objTempROI1.bmp");
                }

                objThresholdROI.Dispose();
                objTempROI.Dispose();
                objTempImage.Dispose();


                m_stcSampleBlobLead.fAGV = fAverageGrayValue;
                m_arrSampleBlobLeads[i] = m_stcSampleBlobLead;

                // -------- Check Average Gray Value ----------------------------------------------
                if (!MatchTemplateObjectsAverageGrayValue(i, m_arrSampleBlobLeads[i].fAGV))
                {
                    m_arrSampleBlobLeads[i].intFailMask |= 0x40000;
                    m_arrFailResultMask[0] |= 0x40000;
                }
            }

        }

        private void CheckDimension_CenterLeads(ROI objROI)
        {
            float fMinLengthTLMM = float.MaxValue;
            float fMaxLengthTLMM = 0;
            float fMinLengthBRMM = float.MaxValue;
            float fMaxLengthBRMM = 0;
            float fMinOverallSpanMM = float.MaxValue;
            float fMaxOverallSpanMM = 0;
            float fMinTopSpanMM = float.MaxValue;
            float fMaxTopSpanMM = 0;
            float fMinBottomSpanMM = float.MaxValue;
            float fMaxBottomSpanMM = 0;
            float fMinLeftSpanMM = float.MaxValue;
            float fMaxLeftSpanMM = 0;
            float fMinRightSpanMM = float.MaxValue;
            float fMaxRightSpanMM = 0;
            bool blnCheckSweepLeft = true, blnCheckSweepRight = true, blnCheckSweepTop = true, blnCheckSweepBottom = true;
            int intCountLeft = 0, intCountRight = 0, intCountTop = 0, intCountBottom = 0;
            for (int i = 0; i < m_arrSampleBlobLeads.Length; i++)
            {
                ////Skip if fail reference point
                if ((m_arrSampleBlobLeads[i].intFailMask & 0x01) > 0)
                    continue;

                ////Skip if join Lead
                if ((m_arrSampleBlobLeads[i].intFailMask & 0x10) > 0) // 0x02
                    continue;

                ////Skip if missing Lead
                if ((m_arrSampleBlobLeads[i].intFailMask & 0x20) > 0) //0x04
                    continue;

                // Check Skew
                if (!MatchTemplateObjectsSkew(i, m_arrSampleBlobLeads[i].fSkewMM) || (!m_arrSampleBlobLeads[i].blnBaseStartFound && !m_arrSampleBlobLeads[i].blnBaseEndFound))
                {
                    if ((m_intFailOptionMask & 0x100) > 0)// && !m_blnWantUsePkgToBaseTolerance) //2020-07-28 ZJYEOH : only check Skew if no use package to base method
                    {
                        m_arrSampleBlobLeads[i].intFailMask |= 0x100;
                        m_arrFailResultMask[0] |= 0x100;
                    }
                }

                // Check Off Set
                if (!MatchTemplateObjectsOffset(i, m_arrSampleBlobLeads[i].fOffSetMM))
                {
                    if ((m_intFailOptionMask & 0x20000) > 0)
                    {
                        m_arrSampleBlobLeads[i].intFailMask |= 0x20000;
                        m_arrFailResultMask[0] |= 0x20000;
                    }
                }

                if (m_intLeadWidthDisplayOption != 1)   // 0: 2D Width ; 1: 3D Width ; 2: Max of 2D or 3D
                {
                    // Check base/tip Width
                    if (!MatchTemplateObjectsWidth(i, m_arrSampleBlobLeads[i].fTipWidthMM))
                    {
                        if ((m_intFailOptionMask & 0x40) > 0)
                        {
                            m_arrSampleBlobLeads[i].intFailMask |= 0x40;
                            m_arrFailResultMask[0] |= 0x40;
                        }
                    }
                }

                // Check base/tip Height
                if (!MatchTemplateObjectsHeight(i, m_arrSampleBlobLeads[i].fTipLengthMM))
                {
                    if ((m_intFailOptionMask & 0x80) > 0)
                    {
                        m_arrSampleBlobLeads[i].intFailMask |= 0x80;
                        m_arrFailResultMask[0] |= 0x80;
                    }
                }

                if (m_arrSampleBlobLeads[i].intDirection == 0x01 || m_arrSampleBlobLeads[i].intDirection == 0x04)
                {
                    if (fMinLengthTLMM > m_arrSampleBlobLeads[i].fTipLengthMM)
                    {
                        fMinLengthTLMM = m_arrSampleBlobLeads[i].fTipLengthMM;
                    }
                    if (fMaxLengthTLMM < m_arrSampleBlobLeads[i].fTipLengthMM)
                    {
                        fMaxLengthTLMM = m_arrSampleBlobLeads[i].fTipLengthMM;
                    }

                    //2020-07-20 ZJYEOH : Need to get X Y based on Direction
                    if (m_arrSampleBlobLeads[i].intDirection == 0x01) // Left
                    {
                        //if (fMinOverallSpanMM > m_arrSampleBlobLeads[i].fStartX)
                        //{
                        //    fMinOverallSpanMM = m_arrSampleBlobLeads[i].fStartX;
                        //}
                        //if (fMaxOverallSpanMM < m_arrSampleBlobLeads[i].fEndX)
                        //{
                        //    fMaxOverallSpanMM = m_arrSampleBlobLeads[i].fEndX;
                        //}

                        //if (fMinLeftSpanMM > m_arrSampleBlobLeads[i].fStartY)
                        //{
                        //    fMinLeftSpanMM = m_arrSampleBlobLeads[i].fStartY;
                        //}
                        //if (fMaxLeftSpanMM < m_arrSampleBlobLeads[i].fEndY)
                        //{
                        //    fMaxLeftSpanMM = m_arrSampleBlobLeads[i].fEndY;
                        //}
                        if (fMinOverallSpanMM > m_arrSampleBlobLeads[i].fTipCenterX)
                        {
                            fMinOverallSpanMM = m_arrSampleBlobLeads[i].fTipCenterX;
                        }
                        if (fMaxOverallSpanMM < m_arrSampleBlobLeads[i].fBaseCenterX)
                        {
                            fMaxOverallSpanMM = m_arrSampleBlobLeads[i].fBaseCenterX;
                        }

                        if (fMinLeftSpanMM > m_arrSampleBlobLeads[i].fTipCenterY - m_arrSampleBlobLeads[i].fTipWidth / 2)
                        {
                            fMinLeftSpanMM = m_arrSampleBlobLeads[i].fTipCenterY - m_arrSampleBlobLeads[i].fTipWidth / 2;
                        }
                        if (fMaxLeftSpanMM < m_arrSampleBlobLeads[i].fTipCenterY + m_arrSampleBlobLeads[i].fTipWidth / 2)
                        {
                            fMaxLeftSpanMM = m_arrSampleBlobLeads[i].fTipCenterY + m_arrSampleBlobLeads[i].fTipWidth / 2;
                        }
                    }
                    else if (m_arrSampleBlobLeads[i].intDirection == 0x04) // Top
                    {
                        //if (fMinOverallSpanMM > m_arrSampleBlobLeads[i].fStartY)
                        //{
                        //    fMinOverallSpanMM = m_arrSampleBlobLeads[i].fStartY;
                        //}
                        //if (fMaxOverallSpanMM < m_arrSampleBlobLeads[i].fEndY)
                        //{
                        //    fMaxOverallSpanMM = m_arrSampleBlobLeads[i].fEndY;
                        //}

                        //if (fMinTopSpanMM > m_arrSampleBlobLeads[i].fStartX)
                        //{
                        //    fMinTopSpanMM = m_arrSampleBlobLeads[i].fStartX;
                        //}
                        //if (fMaxTopSpanMM < m_arrSampleBlobLeads[i].fEndX)
                        //{
                        //    fMaxTopSpanMM = m_arrSampleBlobLeads[i].fEndX;
                        //}
                        if (fMinOverallSpanMM > m_arrSampleBlobLeads[i].fTipCenterY)
                        {
                            fMinOverallSpanMM = m_arrSampleBlobLeads[i].fTipCenterY;
                        }
                        if (fMaxOverallSpanMM < m_arrSampleBlobLeads[i].fBaseCenterY)
                        {
                            fMaxOverallSpanMM = m_arrSampleBlobLeads[i].fBaseCenterY;
                        }

                        if (fMinTopSpanMM > m_arrSampleBlobLeads[i].fTipCenterX - m_arrSampleBlobLeads[i].fTipWidth / 2)
                        {
                            fMinTopSpanMM = m_arrSampleBlobLeads[i].fTipCenterX - m_arrSampleBlobLeads[i].fTipWidth / 2;
                        }
                        if (fMaxTopSpanMM < m_arrSampleBlobLeads[i].fTipCenterX + m_arrSampleBlobLeads[i].fTipWidth / 2)
                        {
                            fMaxTopSpanMM = m_arrSampleBlobLeads[i].fTipCenterX + m_arrSampleBlobLeads[i].fTipWidth / 2;
                        }
                    }
                }
                else if (m_arrSampleBlobLeads[i].intDirection == 0x02 || m_arrSampleBlobLeads[i].intDirection == 0x08)
                {
                    if (fMinLengthBRMM > m_arrSampleBlobLeads[i].fTipLengthMM)
                    {
                        fMinLengthBRMM = m_arrSampleBlobLeads[i].fTipLengthMM;
                    }
                    if (fMaxLengthBRMM < m_arrSampleBlobLeads[i].fTipLengthMM)
                    {
                        fMaxLengthBRMM = m_arrSampleBlobLeads[i].fTipLengthMM;
                    }

                    //2020-07-20 ZJYEOH : Need to get X Y based on Direction
                    if (m_arrSampleBlobLeads[i].intDirection == 0x02) // Right
                    {
                        //if (fMinOverallSpanMM > m_arrSampleBlobLeads[i].fStartX)
                        //{
                        //    fMinOverallSpanMM = m_arrSampleBlobLeads[i].fStartX;
                        //}
                        //if (fMaxOverallSpanMM < m_arrSampleBlobLeads[i].fEndX)
                        //{
                        //    fMaxOverallSpanMM = m_arrSampleBlobLeads[i].fEndX;
                        //}

                        //if (fMinRightSpanMM > m_arrSampleBlobLeads[i].fStartY)
                        //{
                        //    fMinRightSpanMM = m_arrSampleBlobLeads[i].fStartY;
                        //}
                        //if (fMaxRightSpanMM < m_arrSampleBlobLeads[i].fEndY)
                        //{
                        //    fMaxRightSpanMM = m_arrSampleBlobLeads[i].fEndY;
                        //}
                        if (fMinOverallSpanMM > m_arrSampleBlobLeads[i].fBaseCenterX)
                        {
                            fMinOverallSpanMM = m_arrSampleBlobLeads[i].fBaseCenterX;
                        }
                        if (fMaxOverallSpanMM < m_arrSampleBlobLeads[i].fTipCenterX)
                        {
                            fMaxOverallSpanMM = m_arrSampleBlobLeads[i].fTipCenterX;
                        }

                        if (fMinRightSpanMM > m_arrSampleBlobLeads[i].fTipCenterY - m_arrSampleBlobLeads[i].fTipWidth / 2)
                        {
                            fMinRightSpanMM = m_arrSampleBlobLeads[i].fTipCenterY - m_arrSampleBlobLeads[i].fTipWidth / 2;
                        }
                        if (fMaxRightSpanMM < m_arrSampleBlobLeads[i].fTipCenterY + m_arrSampleBlobLeads[i].fTipWidth / 2)
                        {
                            fMaxRightSpanMM = m_arrSampleBlobLeads[i].fTipCenterY + m_arrSampleBlobLeads[i].fTipWidth / 2;
                        }
                    }
                    else if (m_arrSampleBlobLeads[i].intDirection == 0x08) // Bottom
                    {
                        //if (fMinOverallSpanMM > m_arrSampleBlobLeads[i].fStartY)
                        //{
                        //    fMinOverallSpanMM = m_arrSampleBlobLeads[i].fStartY;
                        //}
                        //if (fMaxOverallSpanMM < m_arrSampleBlobLeads[i].fEndY)
                        //{
                        //    fMaxOverallSpanMM = m_arrSampleBlobLeads[i].fEndY;
                        //}

                        //if (fMinBottomSpanMM > m_arrSampleBlobLeads[i].fStartX)
                        //{
                        //    fMinBottomSpanMM = m_arrSampleBlobLeads[i].fStartX;
                        //}
                        //if (fMaxBottomSpanMM < m_arrSampleBlobLeads[i].fEndX)
                        //{
                        //    fMaxBottomSpanMM = m_arrSampleBlobLeads[i].fEndX;
                        //}
                        if (fMinOverallSpanMM > m_arrSampleBlobLeads[i].fBaseCenterY)
                        {
                            fMinOverallSpanMM = m_arrSampleBlobLeads[i].fBaseCenterY;
                        }
                        if (fMaxOverallSpanMM < m_arrSampleBlobLeads[i].fTipCenterY)
                        {
                            fMaxOverallSpanMM = m_arrSampleBlobLeads[i].fTipCenterY;
                        }

                        if (fMinBottomSpanMM > m_arrSampleBlobLeads[i].fTipCenterX - m_arrSampleBlobLeads[i].fTipWidth / 2)
                        {
                            fMinBottomSpanMM = m_arrSampleBlobLeads[i].fTipCenterX - m_arrSampleBlobLeads[i].fTipWidth / 2;
                        }
                        if (fMaxBottomSpanMM < m_arrSampleBlobLeads[i].fTipCenterX + m_arrSampleBlobLeads[i].fTipWidth / 2)
                        {
                            fMaxBottomSpanMM = m_arrSampleBlobLeads[i].fTipCenterX + m_arrSampleBlobLeads[i].fTipWidth / 2;
                        }
                    }
                }

                // Check min max width
                if (!MatchTemplateObjectsMinMaxWidth(i, m_arrSampleBlobLeads[i].fLeadMinWidthMM, m_arrSampleBlobLeads[i].fLeadMaxWidthMM))
                {
                    if ((m_intFailOptionMask & 0x100000) > 0)
                    {
                        m_arrSampleBlobLeads[i].intFailMask |= 0x100000;
                        m_arrFailResultMask[0] |= 0x100000;
                    }
                }

                // Check burr width
                // Check base/tip Height
                if (!MatchTemplateObjectsBurrWidth(i, m_arrSampleBlobLeads[i].fLeadBurrWidthMM))
                {
                    if ((m_intFailOptionMask & 0x200000) > 0)
                    {
                        m_arrSampleBlobLeads[i].intFailMask |= 0x200000;
                        m_arrFailResultMask[0] |= 0x200000;
                    }
                }
            }

            // -------- Check Length Variances ----------------------------------------------
            if (m_intLeadDirection == 0)    // Horizontal
            {
                if (fMinLengthTLMM == float.MaxValue)
                    m_fLengthVarianceLeftResult = -999;
                else
                    m_fLengthVarianceLeftResult = (float)Math.Round(fMaxLengthTLMM - fMinLengthTLMM, 4, MidpointRounding.AwayFromZero);

                if (fMinLengthBRMM == float.MaxValue)
                    m_fLengthVarianceRightResult = -999;
                else
                    m_fLengthVarianceRightResult = (float)Math.Round(fMaxLengthBRMM - fMinLengthBRMM, 4, MidpointRounding.AwayFromZero);

                if (fMinLengthTLMM == float.MaxValue || fMinLengthBRMM == float.MaxValue)
                    m_fLengthVarianceOverallResult = -999;
                else
                    m_fLengthVarianceOverallResult = (float)Math.Round(Math.Max(fMaxLengthTLMM, fMaxLengthBRMM) - Math.Min(fMinLengthTLMM, fMinLengthBRMM), 4, MidpointRounding.AwayFromZero);

                if ((m_intFailOptionMask & 0x800) > 0)
                {
                    if (m_intLeadLengthVarianceMethod != 0)
                    {
                        if (m_fLengthVarianceOverallResult != -999 && m_fLengthVarianceOverallResult > m_fLengthVarianceOverallMaxSetting)
                        {
                            m_arrFailResultMask[0] |= 0x800;
                        }
                    }

                    if (m_intLeadLengthVarianceMethod != 1)
                    {
                        if (m_fLengthVarianceLeftResult != -999 && m_fLengthVarianceLeftResult > m_fLengthVarianceLeftMaxSetting)
                        {
                            m_arrFailResultMask[4] |= 0x800;
                        }

                        if (m_fLengthVarianceRightResult != -999 && m_fLengthVarianceRightResult > m_fLengthVarianceRightMaxSetting)
                        {
                            m_arrFailResultMask[2] |= 0x800;
                        }
                    }
                }
            }
            else
            {
                if (fMinLengthTLMM == float.MaxValue)
                    m_fLengthVarianceTopResult = -999;
                else
                    m_fLengthVarianceTopResult = (float)Math.Round(fMaxLengthTLMM - fMinLengthTLMM, 4, MidpointRounding.AwayFromZero);

                if (fMinLengthBRMM == float.MaxValue)
                    m_fLengthVarianceBottomResult = -999;
                else
                    m_fLengthVarianceBottomResult = (float)Math.Round(fMaxLengthBRMM - fMinLengthBRMM, 4, MidpointRounding.AwayFromZero);

                if (fMinLengthTLMM == float.MaxValue || fMinLengthBRMM == float.MaxValue)
                    m_fLengthVarianceOverallResult = -999;
                else
                    m_fLengthVarianceOverallResult = (float)Math.Round(Math.Max(fMaxLengthTLMM, fMaxLengthBRMM) - Math.Min(fMinLengthTLMM, fMinLengthBRMM), 4, MidpointRounding.AwayFromZero);

                if ((m_intFailOptionMask & 0x800) > 0)
                {
                    if (m_intLeadLengthVarianceMethod != 0)
                    {
                        if (m_fLengthVarianceOverallResult != -999 && m_fLengthVarianceOverallResult > m_fLengthVarianceOverallMaxSetting)
                        {
                            m_arrFailResultMask[0] |= 0x800;
                        }
                    }

                    if (m_intLeadLengthVarianceMethod != 1)
                    {
                        if (m_fLengthVarianceTopResult != -999 && m_fLengthVarianceTopResult > m_fLengthVarianceTopMaxSetting)
                        {
                            m_arrFailResultMask[1] |= 0x800;
                        }

                        if (m_fLengthVarianceBottomResult != -999 && m_fLengthVarianceBottomResult > m_fLengthVarianceBottomMaxSetting)
                        {
                            m_arrFailResultMask[3] |= 0x800;
                        }
                    }
                }
            }

            // --------- Solder Pad length Variances ----------------------------------------


            // --------- Span ------------------------------------
            if (m_intLeadDirection == 0)    // Horizontal
            {
                if (fMinOverallSpanMM == float.MaxValue)
                    m_fSpanOverallResult = -999;
                else
                    m_fSpanOverallResult = (float)Math.Round(Get2DXinMM((fMaxOverallSpanMM - fMinOverallSpanMM)), 4, MidpointRounding.AwayFromZero);//m_fMMToPixelXValue

                if (fMinLeftSpanMM == float.MaxValue)
                    m_fSpanLeftResult = -999;
                else
                    m_fSpanLeftResult = (float)Math.Round(Get2DYinMM((fMaxLeftSpanMM - fMinLeftSpanMM)), 4, MidpointRounding.AwayFromZero);//m_fMMToPixelXValue

                if (fMinRightSpanMM == float.MaxValue)
                    m_fSpanRightResult = -999;
                else
                    m_fSpanRightResult = (float)Math.Round(Get2DYinMM((fMaxRightSpanMM - fMinRightSpanMM)), 4, MidpointRounding.AwayFromZero);//m_fMMToPixelXValue

                if ((m_intFailOptionMask & 0x1000) > 0)
                {
                    if (m_intLeadSpanMethod != 0)
                    {
                        if (m_fSpanOverallResult != -999 && ((m_fSpanOverallResult < m_fSpanOverallMinSetting) ||
                      (m_fSpanOverallResult > m_fSpanOverallMaxSetting)))
                        {
                            m_arrFailResultMask[0] |= 0x1000;
                        }
                    }

                    if (m_intLeadSpanMethod != 1)
                    {
                        if (m_fSpanLeftResult != -999 && ((m_fSpanLeftResult < m_fSpanLeftMinSetting) ||
                      (m_fSpanLeftResult > m_fSpanLeftMaxSetting)))
                        {
                            m_arrFailResultMask[4] |= 0x1000;
                        }

                        if (m_fSpanRightResult != -999 && ((m_fSpanRightResult < m_fSpanRightMinSetting) ||
                     (m_fSpanRightResult > m_fSpanRightMaxSetting)))
                        {
                            m_arrFailResultMask[2] |= 0x1000;
                        }
                    }
                }
            }
            else
            {
                if (fMinOverallSpanMM == float.MaxValue)
                    m_fSpanOverallResult = -999;
                else
                    m_fSpanOverallResult = (float)Math.Round(Get2DYinMM((fMaxOverallSpanMM - fMinOverallSpanMM)), 4, MidpointRounding.AwayFromZero);//m_fMMToPixelXValue

                if (fMinTopSpanMM == float.MaxValue)
                    m_fSpanTopResult = -999;
                else
                    m_fSpanTopResult = (float)Math.Round(Get2DXinMM((fMaxTopSpanMM - fMinTopSpanMM)), 4, MidpointRounding.AwayFromZero);//m_fMMToPixelXValue

                if (fMinBottomSpanMM == float.MaxValue)
                    m_fSpanBottomResult = -999;
                else
                    m_fSpanBottomResult = (float)Math.Round(Get2DXinMM((fMaxBottomSpanMM - fMinBottomSpanMM)), 4, MidpointRounding.AwayFromZero);//m_fMMToPixelXValue

                if ((m_intFailOptionMask & 0x1000) > 0)
                {
                    if (m_intLeadSpanMethod != 0)
                    {
                        if (m_fSpanOverallResult != -999 && ((m_fSpanOverallResult < m_fSpanOverallMinSetting) ||
                     (m_fSpanOverallResult > m_fSpanOverallMaxSetting)))
                        {
                            m_arrFailResultMask[0] |= 0x1000;
                        }
                    }

                    if (m_intLeadSpanMethod != 1)
                    {
                        if (m_fSpanTopResult != -999 && ((m_fSpanTopResult < m_fSpanTopMinSetting) ||
                 (m_fSpanTopResult > m_fSpanTopMaxSetting)))
                        {
                            m_arrFailResultMask[1] |= 0x1000;
                        }

                        if (m_fSpanBottomResult != -999 && ((m_fSpanBottomResult < m_fSpanBottomMinSetting) ||
                 (m_fSpanBottomResult > m_fSpanBottomMaxSetting)))
                        {
                            m_arrFailResultMask[3] |= 0x1000;
                        }
                    }
                }
            }

            // --------- Leads Sweep --------------------------------
            if (m_intLeadDirection == 0)    // Horizontal
            {
                float fUnitCenterY, fLeadTotalY, fLeadAverageY, fSweepLeftReference = 0, fSweepRightReference = 0;

                // Check Left Leads Sweep
                fUnitCenterY = (float)(m_pCornerPoint_TopLeft.Y + m_pCornerPoint_BottomLeft.Y) / 2 - objROI.ref_ROITotalY;
                fLeadTotalY = 0;
                for (int i = 0; i < m_arrSampleBlobLeads.Length; i++)
                {
                    if (m_arrSampleBlobLeads[i].intDirection == 1)  // Border Left Direction
                    {
                        intCountLeft++;
                        fLeadTotalY += m_arrSampleBlobLeads[i].fTipCenterY;
                        m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                        fSweepLeftReference = Get2DYinMM(m_stcBlobLead.fSweepLeftReference); //2021-03-18 ZJYEOH : Convert to MM because save as pixel
                    }
                }
                if (intCountLeft != m_intNumberOfLead_Left)
                    blnCheckSweepLeft = false;
                fLeadAverageY = fLeadTotalY / m_intNumberOfLead_Left;
                m_fLeadSweepVarianceLeftResult = Get2DYinMM(fUnitCenterY - fLeadAverageY);// / m_fMMToPixelYValue;
                m_fLeadSweepVarianceLeftResult = (float)Math.Round(Math.Abs(m_fLeadSweepVarianceLeftResult - fSweepLeftReference), 4, MidpointRounding.AwayFromZero);
                if (!blnCheckSweepLeft)
                    m_fLeadSweepVarianceLeftResult = 0;

                if (fLeadTotalY == 0)
                    m_fLeadSweepVarianceLeftResult = -999;

                // Check Right Leads Sweep
                fUnitCenterY = (float)(m_pCornerPoint_TopRight.Y + m_pCornerPoint_BottomRight.Y) / 2 - objROI.ref_ROITotalY;
                fLeadTotalY = 0;
                for (int i = 0; i < m_arrSampleBlobLeads.Length; i++)
                {
                    if (m_arrSampleBlobLeads[i].intDirection == 2)  // Border Right Direction
                    {
                        intCountRight++;
                        fLeadTotalY += m_arrSampleBlobLeads[i].fTipCenterY;
                        m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                        fSweepRightReference = Get2DYinMM(m_stcBlobLead.fSweepRightReference);//2021-03-18 ZJYEOH : Convert to MM because save as pixel
                    }
                }
                if (intCountRight != m_intNumberOfLead_Right)
                    blnCheckSweepRight = false;
                fLeadAverageY = fLeadTotalY / m_intNumberOfLead_Right;
                m_fLeadSweepVarianceRightResult = Get2DYinMM(fUnitCenterY - fLeadAverageY);// / m_fMMToPixelYValue;
                m_fLeadSweepVarianceRightResult = (float)Math.Round(Math.Abs(m_fLeadSweepVarianceRightResult - fSweepRightReference), 4, MidpointRounding.AwayFromZero);
                if (!blnCheckSweepRight)
                    m_fLeadSweepVarianceRightResult = 0;

                if (fLeadTotalY == 0)
                    m_fLeadSweepVarianceRightResult = -999;

                if ((m_intFailOptionMask & 0x04) > 0)
                {
                    if (//(m_fLeadSweepVarianceLeftResult < m_fLeadSweepVarianceLeftMinSetting) ||
                        (m_fLeadSweepVarianceLeftResult > m_fLeadSweepVarianceLeftMaxSetting) && blnCheckSweepLeft)
                    {
                        m_arrFailResultMask[4] |= 0x04;
                    }

                    if (//(m_fLeadSweepVarianceRightResult < m_fLeadSweepVarianceRightMinSetting) ||
                        (m_fLeadSweepVarianceRightResult > m_fLeadSweepVarianceRightMaxSetting) && blnCheckSweepRight)
                    {
                        m_arrFailResultMask[2] |= 0x04;
                    }

                }
            }
            else
            {
                float fUnitCenterX, fLeadTotalX, fLeadAverageX, fSweepTopReference = 0, fSweepBottomReference = 0;

                // Check Top Leads Sweep
                fUnitCenterX = (float)(m_pCornerPoint_TopLeft.X + m_pCornerPoint_TopRight.X) / 2;
                fLeadTotalX = 0;
                for (int i = 0; i < m_arrSampleBlobLeads.Length; i++)
                {
                    ////Skip if missing Lead
                    if ((m_arrSampleBlobLeads[i].intFailMask & 0x20) > 0 && m_arrSampleBlobLeads[i].intDirection == 4) //0x04
                        blnCheckSweepTop = false;

                    if (m_arrSampleBlobLeads[i].intDirection == 4)  // Border Top Direction
                    {
                        intCountTop++;
                        fLeadTotalX += m_arrSampleBlobLeads[i].fTipCenterX;
                        m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                        fSweepTopReference = Get2DXinMM(m_stcBlobLead.fSweepTopReference);//2021-03-18 ZJYEOH : Convert to MM because save as pixel
                    }
                }
                if (intCountTop != m_intNumberOfLead_Top)
                    blnCheckSweepTop = false;
                fLeadAverageX = fLeadTotalX / m_intNumberOfLead_Top;
                m_fLeadSweepVarianceTopResult = Get2DXinMM(fUnitCenterX - fLeadAverageX);//m_fMMToPixelXValue
                m_fLeadSweepVarianceTopResult = (float)Math.Round(Math.Abs(m_fLeadSweepVarianceTopResult - fSweepTopReference), 4, MidpointRounding.AwayFromZero);
                if (!blnCheckSweepTop)
                    m_fLeadSweepVarianceTopResult = 0;

                if(fLeadTotalX == 0)
                    m_fLeadSweepVarianceTopResult = -999;

                // Check Bottom Leads Sweep
                fUnitCenterX = (float)(m_pCornerPoint_BottomLeft.X + m_pCornerPoint_BottomRight.X) / 2;
                fLeadTotalX = 0;
                for (int i = 0; i < m_arrSampleBlobLeads.Length; i++)
                {
                    ////Skip if missing Lead
                    if ((m_arrSampleBlobLeads[i].intFailMask & 0x20) > 0 && m_arrSampleBlobLeads[i].intDirection == 8) //0x04
                        blnCheckSweepBottom = false;

                    if (m_arrSampleBlobLeads[i].intDirection == 8)  // Border Bottom Direction
                    {
                        intCountBottom++;
                        fLeadTotalX += m_arrSampleBlobLeads[i].fTipCenterX;
                        m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                        fSweepBottomReference = Get2DXinMM(m_stcBlobLead.fSweepBottomReference);//2021-03-18 ZJYEOH : Convert to MM because save as pixel
                    }
                }
                if (intCountBottom != m_intNumberOfLead_Bottom)
                    blnCheckSweepBottom = false;
                fLeadAverageX = fLeadTotalX / m_intNumberOfLead_Bottom;
                m_fLeadSweepVarianceBottomResult = Get2DXinMM(fUnitCenterX - fLeadAverageX);//m_fMMToPixelXValue
                m_fLeadSweepVarianceBottomResult = (float)Math.Round(Math.Abs(m_fLeadSweepVarianceBottomResult - fSweepBottomReference), 4, MidpointRounding.AwayFromZero);
                if (!blnCheckSweepBottom)
                    m_fLeadSweepVarianceBottomResult = 0;

                if (fLeadTotalX == 0)
                    m_fLeadSweepVarianceBottomResult = -999;

                if ((m_intFailOptionMask & 0x04) > 0)
                {
                    if (//(m_fLeadSweepVarianceTopResult < m_fLeadSweepVarianceTopMinSetting) ||
                        (m_fLeadSweepVarianceTopResult > m_fLeadSweepVarianceTopMaxSetting) && blnCheckSweepTop)
                    {
                        m_arrFailResultMask[1] |= 0x04;
                    }

                    if (//(m_fLeadSweepVarianceBottomResult < m_fLeadSweepVarianceBottomMinSetting) ||
                        (m_fLeadSweepVarianceBottomResult > m_fLeadSweepVarianceBottomMaxSetting) && blnCheckSweepBottom)
                    {
                        m_arrFailResultMask[3] |= 0x04;
                    }

                }
            }
        }

        /// <summary>
        /// Sort object number
        /// </summary>
        private void SortObjectNumber()
        {
            int intNoID = 1;
            BlobsFeatures stcBlobsFeatures = new BlobsFeatures();
            int[] intDirectionOrder = { -1, -1, -1, -1, -1, -1, -1, -1, -1 };

            #region Set Direction Sequence
            bool blnTopFound = false;
            bool blnBottomFound = false;
            bool blnLeftFound = false;
            bool blnRightFound = false;
            int intOneColumn = 0;
            int intOneRow = 0;
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                if (!m_stcBlobLead.blnSelected)
                    continue;

                if (m_stcBlobLead.intDirection == 1)
                    blnLeftFound = true;

                if (m_stcBlobLead.intDirection == 2)
                    blnRightFound = true;

                if (m_stcBlobLead.intDirection == 4)
                    blnTopFound = true;

                if (m_stcBlobLead.intDirection == 8)
                    blnBottomFound = true;

                if (m_stcBlobLead.intDirection == 7)
                    intOneColumn |= 0x01;

                if (m_stcBlobLead.intDirection == 3)
                    intOneColumn |= 0x02;

                if (m_stcBlobLead.intDirection == 11)
                    intOneColumn |= 0x04;

                if (m_stcBlobLead.intDirection == 13)
                    intOneRow |= 0x01;

                if (m_stcBlobLead.intDirection == 12)
                    intOneRow |= 0x02;

                if (m_stcBlobLead.intDirection == 14)
                    intOneRow |= 0x04;
            }

            int intIndex = 0;
            //if (intOneColumn == 0x07)
            if (intOneColumn > 0)
            {
                intDirectionOrder[intIndex++] = 7;
                intDirectionOrder[intIndex++] = 3;
                intDirectionOrder[intIndex++] = 11;
            }
            //else if (intOneRow == 0x07)
            else if (intOneRow > 0)
            {
                intDirectionOrder[intIndex++] = 13;
                intDirectionOrder[intIndex++] = 12;
                intDirectionOrder[intIndex++] = 14;
            }
            else
            {
                if (blnTopFound)
                {
                    intDirectionOrder[intIndex++] = 5;

                }

                intDirectionOrder[intIndex++] = 4;
                intDirectionOrder[intIndex++] = 6;
                intDirectionOrder[intIndex++] = 2;
                intDirectionOrder[intIndex++] = 10;
                intDirectionOrder[intIndex++] = 8;
                intDirectionOrder[intIndex++] = 9;
                intDirectionOrder[intIndex++] = 1;

                if (!blnTopFound)
                    intDirectionOrder[intIndex++] = 5;

                intDirectionOrder[intIndex] = 0;
            }

            #endregion

            #region Known Direction
            for (int d = 0; d < intDirectionOrder.Length; d++)
            {
                if (intDirectionOrder[d] == -1)
                    continue;

                for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
                {
                    m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                    if (!m_stcBlobLead.blnSelected)
                        continue;

                    if (m_stcBlobLead.intDirection == intDirectionOrder[d])
                    {
                        m_stcBlobLead.intNoID = intNoID;

                        for (int j = 0; j < i; j++)
                        {
                            stcBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobLeads[j];

                            if (!stcBlobsFeatures.blnSelected)
                                continue;

                            if (stcBlobsFeatures.intDirection == intDirectionOrder[d])
                            {
                                if ((intDirectionOrder[d] == 5) || (intDirectionOrder[d] == 4) || (intDirectionOrder[d] == 6) || (intDirectionOrder[d] == 12) || (intDirectionOrder[d] == 13) || (intDirectionOrder[d] == 14))
                                {
                                    if (m_stcBlobLead.intStartX < stcBlobsFeatures.intStartX)
                                    {
                                        if (m_stcBlobLead.intNoID > stcBlobsFeatures.intNoID)
                                            m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                    }
                                }
                                else if ((intDirectionOrder[d] == 2) || (intDirectionOrder[d] == 0) || (intDirectionOrder[d] == 7) || (intDirectionOrder[d] == 3) || (intDirectionOrder[d] == 11))
                                {
                                    if (m_stcBlobLead.intStartY < stcBlobsFeatures.intStartY)
                                    {
                                        if (m_stcBlobLead.intNoID > stcBlobsFeatures.intNoID)
                                            m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                    }
                                }
                                else if ((intDirectionOrder[d] == 10) || (intDirectionOrder[d] == 8) || (intDirectionOrder[d] == 9))
                                {
                                    if (m_stcBlobLead.intStartX > stcBlobsFeatures.intStartX)
                                    {
                                        if (m_stcBlobLead.intNoID > stcBlobsFeatures.intNoID)
                                            m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                    }
                                }
                                else
                                {
                                    if (m_stcBlobLead.intStartY > stcBlobsFeatures.intStartY)
                                    {
                                        if (m_stcBlobLead.intNoID > stcBlobsFeatures.intNoID)
                                            m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                    }
                                }
                            }
                        }

                        for (int j = 0; j < i; j++)
                        {
                            stcBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobLeads[j];
                            if (stcBlobsFeatures.intDirection == intDirectionOrder[d])
                            {
                                if (m_stcBlobLead.intNoID <= stcBlobsFeatures.intNoID)
                                {
                                    stcBlobsFeatures.intNoID++;
                                    m_arrTemplateBlobLeads.RemoveAt(j);
                                    m_arrTemplateBlobLeads.Insert(j, stcBlobsFeatures);
                                }
                            }
                        }
                        intNoID++;
                    }
                    m_arrTemplateBlobLeads.RemoveAt(i);
                    m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
                }
            }
            #endregion

            #region Unknown Direction

            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                if (!m_stcBlobLead.blnSelected)
                    continue;

                if (m_stcBlobLead.intNoID == 0)
                {
                    m_stcBlobLead.intNoID = intNoID;
                    m_arrTemplateBlobLeads.RemoveAt(i);
                    m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
                    intNoID++;
                }
            }

            #endregion
        }

        private void SortObjectNumber(int intLeadPosition)
        {
            int intNoID = 1;
            BlobsFeatures stcBlobsFeatures = new BlobsFeatures();
            int[] intDirectionOrder = { -1, -1, -1, -1, -1, -1, -1, -1, -1 };

            #region Set Direction Sequence
            bool blnTopFound = false;
            bool blnBottomFound = false;
            bool blnLeftFound = false;
            bool blnRightFound = false;
            int intOneColumn = 0;
            int intOneRow = 0;
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                if (!m_stcBlobLead.blnSelected)
                    continue;

                if (m_stcBlobLead.intDirection == 1)
                    blnLeftFound = true;

                if (m_stcBlobLead.intDirection == 2)
                    blnRightFound = true;

                if (m_stcBlobLead.intDirection == 4)
                    blnTopFound = true;

                if (m_stcBlobLead.intDirection == 8)
                    blnBottomFound = true;

                if (m_stcBlobLead.intDirection == 7)
                    intOneColumn |= 0x01;

                if (m_stcBlobLead.intDirection == 3)
                    intOneColumn |= 0x02;

                if (m_stcBlobLead.intDirection == 11)
                    intOneColumn |= 0x04;

                if (m_stcBlobLead.intDirection == 13)
                    intOneRow |= 0x01;

                if (m_stcBlobLead.intDirection == 12)
                    intOneRow |= 0x02;

                if (m_stcBlobLead.intDirection == 14)
                    intOneRow |= 0x04;
            }

            int intIndex = 0;
            if ((intLeadPosition == 0 && (intOneColumn == 0x05 || intOneColumn == 0x07)) ||
                (intLeadPosition > 0 && (intOneColumn > 0)))
            {
                intDirectionOrder[intIndex++] = 7;
                intDirectionOrder[intIndex++] = 3;
                intDirectionOrder[intIndex++] = 11;
            }
            else if ((intLeadPosition == 0 && (intOneRow == 0x05 || intOneRow == 0x07)) ||
                (intLeadPosition > 0 && (intOneRow > 0)))
            {
                intDirectionOrder[intIndex++] = 13;
                intDirectionOrder[intIndex++] = 12;
                intDirectionOrder[intIndex++] = 14;
            }
            else
            {
                if (blnTopFound)
                {
                    intDirectionOrder[intIndex++] = 5;

                }

                intDirectionOrder[intIndex++] = 4;
                intDirectionOrder[intIndex++] = 6;
                intDirectionOrder[intIndex++] = 2;
                intDirectionOrder[intIndex++] = 10;
                intDirectionOrder[intIndex++] = 8;
                intDirectionOrder[intIndex++] = 9;
                intDirectionOrder[intIndex++] = 1;

                if (!blnTopFound)
                    intDirectionOrder[intIndex++] = 5;

                intDirectionOrder[intIndex] = 0;
            }

            #endregion

            #region Known Direction
            for (int d = 0; d < intDirectionOrder.Length; d++)
            {
                if (intDirectionOrder[d] == -1)
                    continue;

                for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
                {
                    m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                    if (!m_stcBlobLead.blnSelected)
                        continue;

                    if (m_stcBlobLead.intDirection == intDirectionOrder[d])
                    {
                        m_stcBlobLead.intNoID = intNoID;

                        for (int j = 0; j < i; j++)
                        {
                            stcBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobLeads[j];

                            if (!stcBlobsFeatures.blnSelected)
                                continue;

                            if (stcBlobsFeatures.intDirection == intDirectionOrder[d])
                            {
                                if ((intDirectionOrder[d] == 5) || (intDirectionOrder[d] == 4) || (intDirectionOrder[d] == 6) || (intDirectionOrder[d] == 12) || (intDirectionOrder[d] == 13) || (intDirectionOrder[d] == 14))
                                {
                                    if (m_stcBlobLead.intStartX < stcBlobsFeatures.intStartX)
                                    {
                                        if (m_stcBlobLead.intNoID > stcBlobsFeatures.intNoID)
                                            m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                    }
                                }
                                else if ((intDirectionOrder[d] == 2) || (intDirectionOrder[d] == 0) || (intDirectionOrder[d] == 7) || (intDirectionOrder[d] == 3) || (intDirectionOrder[d] == 11))
                                {
                                    if (m_stcBlobLead.intStartY < stcBlobsFeatures.intStartY)
                                    {
                                        if (m_stcBlobLead.intNoID > stcBlobsFeatures.intNoID)
                                            m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                    }
                                }
                                else if ((intDirectionOrder[d] == 10) || (intDirectionOrder[d] == 8) || (intDirectionOrder[d] == 9))
                                {
                                    if (m_stcBlobLead.intStartX > stcBlobsFeatures.intStartX)
                                    {
                                        if (m_stcBlobLead.intNoID > stcBlobsFeatures.intNoID)
                                            m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                    }
                                }
                                else
                                {
                                    if (m_stcBlobLead.intStartY > stcBlobsFeatures.intStartY)
                                    {
                                        if (m_stcBlobLead.intNoID > stcBlobsFeatures.intNoID)
                                            m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                    }
                                }
                            }
                        }

                        for (int j = 0; j < i; j++)
                        {
                            stcBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobLeads[j];
                            if (stcBlobsFeatures.intDirection == intDirectionOrder[d])
                            {
                                if (m_stcBlobLead.intNoID <= stcBlobsFeatures.intNoID)
                                {
                                    stcBlobsFeatures.intNoID++;
                                    m_arrTemplateBlobLeads.RemoveAt(j);
                                    m_arrTemplateBlobLeads.Insert(j, stcBlobsFeatures);
                                }
                            }
                        }
                        intNoID++;
                    }
                    m_arrTemplateBlobLeads.RemoveAt(i);
                    m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
                }
            }
            #endregion

            #region Unknown Direction

            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                if (!m_stcBlobLead.blnSelected)
                    continue;

                if (m_stcBlobLead.intNoID == 0)
                {
                    m_stcBlobLead.intNoID = intNoID;
                    m_arrTemplateBlobLeads.RemoveAt(i);
                    m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
                    intNoID++;
                }
            }

            #endregion
        }

        /// <summary>
        /// Sort object number
        /// </summary>
        private void SortObjectNumber(int intLeadPosition, bool blnClockWise, ref int intLeadNo)
        {
            int intStartNoID = intLeadNo;
            BlobsFeatures stcBlobsFeatures = new BlobsFeatures();
            int[] intDirectionOrder = { -1, -1, -1, -1, -1, -1, -1, -1, -1 };

            #region Set Direction Sequence
            bool blnTopFound = false;
            bool blnBottomFound = false;
            bool blnLeftFound = false;
            bool blnRightFound = false;
            int intOneColumn = 0;
            int intOneRow = 0;
            int intSelectedBlobCount = m_arrTemplateBlobLeads.Count;

            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                if (!m_stcBlobLead.blnSelected)
                {
                    intSelectedBlobCount--;
                    continue;
                }

                if (m_stcBlobLead.intDirection == 1)
                    blnLeftFound = true;

                if (m_stcBlobLead.intDirection == 2)
                    blnRightFound = true;

                if (m_stcBlobLead.intDirection == 4)
                    blnTopFound = true;

                if (m_stcBlobLead.intDirection == 8)
                    blnBottomFound = true;

                if (m_stcBlobLead.intDirection == 7)
                    intOneColumn |= 0x01;

                if (m_stcBlobLead.intDirection == 3)
                    intOneColumn |= 0x02;

                if (m_stcBlobLead.intDirection == 11)
                    intOneColumn |= 0x04;

                if (m_stcBlobLead.intDirection == 13)
                    intOneRow |= 0x01;

                if (m_stcBlobLead.intDirection == 12)
                    intOneRow |= 0x02;

                if (m_stcBlobLead.intDirection == 14)
                    intOneRow |= 0x04;
            }

            int intIndex = 0;
            //if (intOneColumn == 0x07)
            if (intOneColumn > 0)
            {
                intDirectionOrder[intIndex++] = 7;
                intDirectionOrder[intIndex++] = 3;
                intDirectionOrder[intIndex++] = 11;
            }
            //else if (intOneRow == 0x07)
            else if (intOneRow > 0)
            {
                intDirectionOrder[intIndex++] = 13;
                intDirectionOrder[intIndex++] = 12;
                intDirectionOrder[intIndex++] = 14;

            }
            else
            {
                if (blnTopFound)
                {
                    intDirectionOrder[intIndex++] = 5;

                }

                intDirectionOrder[intIndex++] = 4;
                intDirectionOrder[intIndex++] = 6;
                intDirectionOrder[intIndex++] = 2;
                intDirectionOrder[intIndex++] = 10;
                intDirectionOrder[intIndex++] = 8;
                intDirectionOrder[intIndex++] = 9;
                intDirectionOrder[intIndex++] = 1;

                if (!blnTopFound)
                    intDirectionOrder[intIndex++] = 5;

                intDirectionOrder[intIndex] = 0;
            }

            #endregion

            #region Known Direction
            for (int d = 0; d < intDirectionOrder.Length; d++)
            {
                if (intDirectionOrder[d] == -1)
                    continue;

                for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
                {
                    m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                    if (!m_stcBlobLead.blnSelected)
                        continue;

                    if (m_stcBlobLead.intDirection == intDirectionOrder[d])
                    {
                        if ((intLeadPosition == 1 && blnClockWise) || (intLeadPosition == 3 && !blnClockWise) || (intLeadPosition == 2 && blnClockWise) || (intLeadPosition == 4 && !blnClockWise))
                        {
                            m_stcBlobLead.intNoID = intLeadNo;
                        }
                        else
                        {
                            if (intLeadPosition == m_intFirstLead)
                                m_stcBlobLead.intNoID = intSelectedBlobCount - (intLeadNo - 1);
                            else
                                m_stcBlobLead.intNoID = intSelectedBlobCount + intStartNoID - (intLeadNo - (intStartNoID - 1));

                        }

                        for (int j = 0; j < i; j++)
                        {
                            stcBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobLeads[j];

                            if (!stcBlobsFeatures.blnSelected)
                                continue;

                            if (stcBlobsFeatures.intDirection == intDirectionOrder[d])
                            {
                                if ((intDirectionOrder[d] == 5) || (intDirectionOrder[d] == 4) || (intDirectionOrder[d] == 6) || (intDirectionOrder[d] == 12) || (intDirectionOrder[d] == 13) || (intDirectionOrder[d] == 14))
                                {
                                    if ((intLeadPosition == 1 && blnClockWise) || (intLeadPosition == 3 && !blnClockWise) || (intLeadPosition == 2 && blnClockWise) || (intLeadPosition == 4 && !blnClockWise))
                                    {
                                        if (m_stcBlobLead.intStartX < stcBlobsFeatures.intStartX)
                                        {
                                            if (m_stcBlobLead.intNoID > stcBlobsFeatures.intNoID)
                                                m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                        }
                                    }
                                    else
                                    {
                                        if (m_stcBlobLead.intStartX < stcBlobsFeatures.intStartX)
                                        {
                                            if (m_stcBlobLead.intNoID < stcBlobsFeatures.intNoID)
                                                m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                        }
                                    }
                                }
                                else if ((intDirectionOrder[d] == 2) || (intDirectionOrder[d] == 0) || (intDirectionOrder[d] == 7) || (intDirectionOrder[d] == 3) || (intDirectionOrder[d] == 11))
                                {
                                    if ((intLeadPosition == 1 && blnClockWise) || (intLeadPosition == 3 && !blnClockWise) || (intLeadPosition == 2 && blnClockWise) || (intLeadPosition == 4 && !blnClockWise))
                                    {
                                        if (m_stcBlobLead.intStartY < stcBlobsFeatures.intStartY)
                                        {
                                            if (m_stcBlobLead.intNoID > stcBlobsFeatures.intNoID)
                                                m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                        }
                                    }
                                    else
                                    {
                                        if (m_stcBlobLead.intStartY < stcBlobsFeatures.intStartY)
                                        {
                                            if (m_stcBlobLead.intNoID < stcBlobsFeatures.intNoID)
                                                m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                        }
                                    }
                                }
                                else if ((intDirectionOrder[d] == 10) || (intDirectionOrder[d] == 8) || (intDirectionOrder[d] == 9))
                                {
                                    if ((intLeadPosition == 1 && blnClockWise) || (intLeadPosition == 3 && !blnClockWise) || (intLeadPosition == 2 && blnClockWise) || (intLeadPosition == 4 && !blnClockWise))
                                    {
                                        if (m_stcBlobLead.intStartX > stcBlobsFeatures.intStartX)
                                        {
                                            if (m_stcBlobLead.intNoID > stcBlobsFeatures.intNoID)
                                                m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                        }
                                    }
                                    else
                                    {
                                        if (m_stcBlobLead.intStartX > stcBlobsFeatures.intStartX)
                                        {
                                            if (m_stcBlobLead.intNoID < stcBlobsFeatures.intNoID)
                                                m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                        }
                                    }
                                }
                                else
                                {
                                    if ((intLeadPosition == 1 && blnClockWise) || (intLeadPosition == 3 && !blnClockWise) || (intLeadPosition == 2 && blnClockWise) || (intLeadPosition == 4 && !blnClockWise))
                                    {
                                        if (m_stcBlobLead.intStartY > stcBlobsFeatures.intStartY)
                                        {
                                            if (m_stcBlobLead.intNoID > stcBlobsFeatures.intNoID)
                                                m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                        }
                                    }
                                    else
                                    {
                                        if (m_stcBlobLead.intStartY > stcBlobsFeatures.intStartY)
                                        {
                                            if (m_stcBlobLead.intNoID < stcBlobsFeatures.intNoID)
                                                m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                        }
                                    }
                                }
                            }
                        }

                        for (int j = 0; j < i; j++)
                        {
                            stcBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobLeads[j];
                            if (stcBlobsFeatures.intDirection == intDirectionOrder[d])
                            {
                                if ((intLeadPosition == 1 && blnClockWise) || (intLeadPosition == 3 && !blnClockWise) || (intLeadPosition == 2 && blnClockWise) || (intLeadPosition == 4 && !blnClockWise))
                                {
                                    if (m_stcBlobLead.intNoID <= stcBlobsFeatures.intNoID)
                                    {
                                        stcBlobsFeatures.intNoID++;
                                        m_arrTemplateBlobLeads.RemoveAt(j);
                                        m_arrTemplateBlobLeads.Insert(j, stcBlobsFeatures);
                                    }
                                }
                                else
                                {
                                    if (m_stcBlobLead.intNoID >= stcBlobsFeatures.intNoID)
                                    {
                                        stcBlobsFeatures.intNoID--;
                                        m_arrTemplateBlobLeads.RemoveAt(j);
                                        m_arrTemplateBlobLeads.Insert(j, stcBlobsFeatures);
                                    }
                                }
                            }
                        }
                        intLeadNo++;
                    }
                    m_arrTemplateBlobLeads.RemoveAt(i);
                    m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
                }
            }
            #endregion

            #region Unknown Direction

            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                if (!m_stcBlobLead.blnSelected)
                    continue;

                if (m_stcBlobLead.intNoID == 0)
                {
                    m_stcBlobLead.intNoID = intLeadNo;
                    m_arrTemplateBlobLeads.RemoveAt(i);
                    m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
                    intLeadNo++;
                }
            }

            #endregion
        }

        public void SetBlobsFeaturesToArray(EBlobs objEBlobs, ArrayList arrBlobsFeature, ROI objROI, bool blnTemporaryBlob)
        {
            arrBlobsFeature.Clear();

            int intSelectedObjectNum = 0;
            //float fBorderDistanceX, fBorderDistanceY;

            //if (objEBlobs.ref_intNumSelectedObject >= m_intNumberOfLead)
            //    intSelectedObjectNum = m_intNumberOfLead;
            //else
            intSelectedObjectNum = objEBlobs.ref_intNumSelectedObject;

            if (intSelectedObjectNum > 0)
            {
                //if there are more than 1 blob
                //Combine all the blob within the range
                float fLimitCenterX;
                float fLimitCenterY;
                float fWidth;
                float fHeight;
                float fOrgX;
                float fOrgY;
                int intTotalSelectedBlobCount;
                int intCycleCount = 0;
                List<int> arrSelectedBlob = new List<int>();
                int intTotalArea;
                float fTotalCenterX;
                float fTotalCenterY;
                float fTotalLimitCenterX;
                float fTotalLimitCenterY;
                float fStartX;
                float fStartY;
                float fEndX;
                float fEndY;
                List<int> arrSkipNo = new List<int>();
                bool blnSkipToNextObject = false;

                for (int i = 0; i < intSelectedObjectNum; i++)
                {
                    for (int k = 0; k < arrSkipNo.Count; k++)
                    {
                        if (i == arrSkipNo[k])
                        {
                            blnSkipToNextObject = true;
                            break;
                        }
                    }

                    if (blnSkipToNextObject)
                    {
                        // This segment is to handle the case when the largest blob builded is from the same lead
                        // Since the number of lead is predefined, each blob data collected must be from different lead
                        if (objEBlobs.ref_intNumSelectedObject > intSelectedObjectNum)
                            intSelectedObjectNum++;

                        blnSkipToNextObject = false;
                        continue;
                    }

                    fLimitCenterX = objEBlobs.ref_arrLimitCenterX[i];
                    fLimitCenterY = objEBlobs.ref_arrLimitCenterY[i];
                    fWidth = objEBlobs.ref_arrWidth[i];
                    fHeight = objEBlobs.ref_arrHeight[i];
                    fOrgX = fLimitCenterX - fWidth / 2;
                    fOrgY = fLimitCenterY - fHeight / 2;
                    intTotalArea = 0;
                    fTotalCenterX = 0;
                    fTotalCenterY = 0;
                    fTotalLimitCenterX = 0;
                    fTotalLimitCenterY = 0;
                    fStartX = fOrgX;
                    fStartY = fOrgY;
                    fEndX = fOrgX + fWidth;
                    fEndY = fOrgY + fHeight;
                    intTotalSelectedBlobCount = 0;
                    arrSelectedBlob.Clear();

                    for (int j = i; j < objEBlobs.ref_intNumSelectedObject; j++)
                    {

                        if (m_intLeadDirection == 0)
                        {
                            //Horizontal lead
                            if (objEBlobs.ref_arrLimitCenterY[j] < fOrgY || objEBlobs.ref_arrLimitCenterY[j] > (fOrgY + fHeight))
                                continue;
                        }
                        else
                        {
                            //Vertical lead
                            if (objEBlobs.ref_arrLimitCenterX[j] < fOrgX || objEBlobs.ref_arrLimitCenterX[j] > (fOrgX + fWidth))
                                continue;
                        }

                        //Once the blob met the requirement, add the blob into skip array to prevent the same blob added twice
                        arrSkipNo.Add(j);

                        intTotalArea += objEBlobs.ref_arrArea[j];
                        fTotalCenterX += objEBlobs.ref_arrGravityCenterX[j] * objEBlobs.ref_arrArea[j];
                        fTotalCenterY += objEBlobs.ref_arrGravityCenterY[j] * objEBlobs.ref_arrArea[j];
                        //fTotalLimitCenterX += objEBlobs.ref_arrLimitCenterX[j] * objEBlobs.ref_arrArea[j];
                        //fTotalLimitCenterY += objEBlobs.ref_arrLimitCenterY[j] * objEBlobs.ref_arrArea[j];

                        if (fStartX > objEBlobs.ref_arrLimitCenterX[j] - (objEBlobs.ref_arrWidth[j] / 2))
                        {
                            fStartX = objEBlobs.ref_arrLimitCenterX[j] - (objEBlobs.ref_arrWidth[j] / 2);
                        }

                        if (fStartY > objEBlobs.ref_arrLimitCenterY[j] - (objEBlobs.ref_arrHeight[j] / 2))
                        {
                            fStartY = objEBlobs.ref_arrLimitCenterY[j] - (objEBlobs.ref_arrHeight[j] / 2);
                        }

                        if (fEndX < objEBlobs.ref_arrLimitCenterX[j] + (objEBlobs.ref_arrWidth[j] / 2))
                        {
                            fEndX = objEBlobs.ref_arrLimitCenterX[j] + (objEBlobs.ref_arrWidth[j] / 2);
                        }

                        if (fEndY < objEBlobs.ref_arrLimitCenterY[j] + (objEBlobs.ref_arrHeight[j] / 2))
                        {
                            fEndY = objEBlobs.ref_arrLimitCenterY[j] + (objEBlobs.ref_arrHeight[j] / 2);
                        }

                        arrSelectedBlob.Add(j);
                        intTotalSelectedBlobCount++;
                    }

                    m_stcBlobLead = new BlobsFeatures();
                    m_stcBlobLead.fArea = intTotalArea;
                    m_stcBlobLead.fCenterX = fTotalCenterX / intTotalArea;
                    m_stcBlobLead.fCenterY = fTotalCenterY / intTotalArea;
                    m_stcBlobLead.fLimitCenterX = (fEndX + fStartX) / 2;  //fTotalLimitCenterX / intTotalArea;
                    m_stcBlobLead.fLimitCenterY = (fEndY + fStartY) / 2; //fTotalLimitCenterY / intTotalArea;
                    m_stcBlobLead.fWidth = fEndX - fStartX;
                    m_stcBlobLead.fHeight = fEndY - fStartY;

                    m_stcBlobLead.intLengthMode = -1;

                    m_stcBlobLead.arrContourX = new int[intTotalSelectedBlobCount];
                    m_stcBlobLead.arrContourY = new int[intTotalSelectedBlobCount];


                    for (int j = 0; j < arrSelectedBlob.Count; j++)
                    {
                        for (int k = 0; k < objEBlobs.ref_intNumSelectedObject; k++)
                        {
                            if (arrSelectedBlob[j] == k)
                            {
                                m_stcBlobLead.arrContourX[j] = objEBlobs.ref_arrContourX[k];
                                m_stcBlobLead.arrContourY[j] = objEBlobs.ref_arrContourY[k];
                            }
                        }
                    }

                    m_stcBlobLead.intObjNo = 0;
                    m_stcBlobLead.fStartX = (float)Math.Round(fStartX, 4);
                    m_stcBlobLead.fEndX = (float)Math.Round(fEndX, 4);
                    m_stcBlobLead.fStartY = (float)Math.Round(fStartY, 4);
                    m_stcBlobLead.fEndY = (float)Math.Round(fEndY, 4);
                    m_stcBlobLead.intStartX = (int)Math.Round(fStartX, 0, MidpointRounding.AwayFromZero);
                    m_stcBlobLead.intEndX = (int)Math.Round(fEndX, 0, MidpointRounding.AwayFromZero);
                    m_stcBlobLead.intStartY = (int)Math.Round(fStartY, 0, MidpointRounding.AwayFromZero);
                    m_stcBlobLead.intEndY = (int)Math.Round(fEndY, 0, MidpointRounding.AwayFromZero);
                    m_stcBlobLead.intDirection = -1;
                    m_stcBlobLead.intGroupID = 0;
                    //m_stcBlobLead.fPitch = -1;
                    m_stcBlobLead.intNoID = 0;
                    
                    if (blnTemporaryBlob)
                    {
                        m_stcBlobLead.blnSelected = ((BlobsFeatures)m_arrTemplateBlobLeads[intCycleCount]).blnSelected;
                        m_stcBlobLead.blnCheckSkew = ((BlobsFeatures)m_arrTemplateBlobLeads[intCycleCount]).blnCheckSkew;
                    }
                    else
                    {
                        if (arrBlobsFeature.Count >= m_intNumberOfLead)
                            m_stcBlobLead.blnSelected = false;
                        else
                            m_stcBlobLead.blnSelected = true;

                        m_stcBlobLead.blnCheckSkew = true;
                    }

                    m_stcBlobLead.arrSelectedBlob = new int[arrSelectedBlob.Count];

                    for (int l = 0; l < arrSelectedBlob.Count; l++)
                        m_stcBlobLead.arrSelectedBlob[l] = arrSelectedBlob[l];

                    arrBlobsFeature.Add(m_stcBlobLead);

                    intCycleCount++;
                }
            }
            //else if (intSelectedObjectNum > 0)
            //{
            //    m_stcBlobLead = new BlobsFeatures();
            //    m_stcBlobLead.fArea = objEBlobs.ref_arrArea[0];
            //    m_stcBlobLead.fCenterX = objEBlobs.ref_arrGravityCenterX[0];
            //    m_stcBlobLead.fCenterY = objEBlobs.ref_arrGravityCenterY[0];
            //    m_stcBlobLead.fLimitCenterX = objEBlobs.ref_arrLimitCenterX[0];
            //    m_stcBlobLead.fLimitCenterY = objEBlobs.ref_arrLimitCenterY[0];
            //    m_stcBlobLead.fWidth = objEBlobs.ref_arrWidth[0];
            //    m_stcBlobLead.fHeight = objEBlobs.ref_arrHeight[0];

            //    fBorderDistanceX = Math.Min(m_stcBlobLead.fLimitCenterX, objROI.ref_ROIWidth - m_stcBlobLead.fLimitCenterX);
            //    fBorderDistanceY = Math.Min(m_stcBlobLead.fLimitCenterY, objROI.ref_ROIHeight - m_stcBlobLead.fLimitCenterY);

            //    if ((fBorderDistanceX / fBorderDistanceY) < 0.7) // point x closer to border compare with point y
            //    {
            //        m_stcBlobLead.intLengthMode = 2;   // 2 mean length == width OR set Width == fHeight, Length == fWidth
            //    }
            //    else if ((fBorderDistanceY / fBorderDistanceX) < 0.7)   // point y closer to border compare with point x
            //    {
            //        m_stcBlobLead.intLengthMode = 1;   // 1 mean length == height OR set Width == fWidth, Length == fHeight
            //    }
            //    else
            //    {
            //        if (m_stcBlobLead.fWidth < m_stcBlobLead.fHeight)  // width shorter then height
            //        {
            //            m_stcBlobLead.intLengthMode = 1;   // 1 mean length == height
            //        }
            //        else
            //        {
            //            m_stcBlobLead.intLengthMode = 2;   // 2 mean length == width
            //        }
            //    }

            //    m_stcBlobLead.intContourX = objEBlobs.ref_arrContourX[0];
            //    m_stcBlobLead.intContourY = objEBlobs.ref_arrContourY[0];
            //    m_stcBlobLead.intObjNo = 0;
            //    m_stcBlobLead.fStartX = (float)Math.Round(m_stcBlobLead.fLimitCenterX - (m_stcBlobLead.fWidth / 2), 4);
            //    m_stcBlobLead.fEndX = (float)Math.Round(m_stcBlobLead.fLimitCenterX + (m_stcBlobLead.fWidth / 2), 4);
            //    m_stcBlobLead.fStartY = (float)Math.Round(m_stcBlobLead.fLimitCenterY - (m_stcBlobLead.fHeight / 2), 4);
            //    m_stcBlobLead.fEndY = (float)Math.Round(m_stcBlobLead.fLimitCenterY + (m_stcBlobLead.fHeight / 2), 4);
            //    m_stcBlobLead.intStartX = (int)Math.Round(m_stcBlobLead.fLimitCenterX - (m_stcBlobLead.fWidth / 2), 0, MidpointRounding.AwayFromZero);
            //    m_stcBlobLead.intEndX = (int)Math.Round(m_stcBlobLead.fLimitCenterX + (m_stcBlobLead.fWidth / 2), 0, MidpointRounding.AwayFromZero);
            //    m_stcBlobLead.intStartY = (int)Math.Round(m_stcBlobLead.fLimitCenterY - (m_stcBlobLead.fHeight / 2), 0, MidpointRounding.AwayFromZero);
            //    m_stcBlobLead.intEndY = (int)Math.Round(m_stcBlobLead.fLimitCenterY + (m_stcBlobLead.fHeight / 2), 0, MidpointRounding.AwayFromZero);
            //    m_stcBlobLead.blnSelected = true;
            //    m_stcBlobLead.intDirection = -1;
            //    m_stcBlobLead.intGroupID = 0;
            //    //m_stcBlobLead.fPitch = -1;
            //    //m_stcBlobLead.fGap = -1;
            //    m_stcBlobLead.intNoID = 0;
            //    m_stcBlobLead.intSelectedBlob = intSelectedBlob;
            //    arrBlobsFeature.Add(m_stcBlobLead);
            //}
        }

        public void SetBlobsFeaturesToArray_CenterLead3D(ROI objROI)
        {
            EBlobs objEBlobs = m_objEBlobs;
            ArrayList arrBlobsFeature = m_arrTemplateBlobLeads;

            arrBlobsFeature.Clear();

            int intSelectedObjectNum = objEBlobs.ref_intNumSelectedObject;
            float fBorderDistanceX, fBorderDistanceY;
            for (int i = 0; i < intSelectedObjectNum; i++)
            {

                m_stcBlobLead = new BlobsFeatures();

                m_stcBlobLead.fArea = objEBlobs.ref_arrArea[i];
                m_stcBlobLead.fCenterX = objEBlobs.ref_arrGravityCenterX[i];
                m_stcBlobLead.fCenterY = objEBlobs.ref_arrGravityCenterY[i];
                m_stcBlobLead.fLimitCenterX = objEBlobs.ref_arrLimitCenterX[i];
                m_stcBlobLead.fLimitCenterY = objEBlobs.ref_arrLimitCenterY[i];
                m_stcBlobLead.fWidth = objEBlobs.ref_arrWidth[i];
                m_stcBlobLead.fHeight = objEBlobs.ref_arrHeight[i];

                fBorderDistanceX = Math.Min(m_stcBlobLead.fLimitCenterX, objROI.ref_ROIWidth - m_stcBlobLead.fLimitCenterX);
                fBorderDistanceY = Math.Min(m_stcBlobLead.fLimitCenterY, objROI.ref_ROIHeight - m_stcBlobLead.fLimitCenterY);

                if ((fBorderDistanceX / fBorderDistanceY) < 0.7) // point x closer to border compare with point y
                {
                    m_stcBlobLead.intLengthMode = 2;   // 2 mean length == width OR set Width == fHeight, Length == fWidth
                }
                else if ((fBorderDistanceY / fBorderDistanceX) < 0.7)   // point y closer to border compare with point x
                {
                    m_stcBlobLead.intLengthMode = 1;   // 1 mean length == height OR set Width == fWidth, Length == fHeight
                }
                else
                {
                    if (m_stcBlobLead.fWidth < m_stcBlobLead.fHeight)  // width shorter then height
                    {
                        m_stcBlobLead.intLengthMode = 1;   // 1 mean length == height
                    }
                    else
                    {
                        m_stcBlobLead.intLengthMode = 2;   // 2 mean length == width
                    }
                }

                m_stcBlobLead.intContourX = objEBlobs.ref_arrContourX[i];
                m_stcBlobLead.intContourY = objEBlobs.ref_arrContourY[i];
                m_stcBlobLead.intObjNo = i;
                m_stcBlobLead.fStartX = (float)Math.Round(m_stcBlobLead.fLimitCenterX - (m_stcBlobLead.fWidth / 2), 4);
                m_stcBlobLead.fEndX = (float)Math.Round(m_stcBlobLead.fLimitCenterX + (m_stcBlobLead.fWidth / 2), 4);
                m_stcBlobLead.fStartY = (float)Math.Round(m_stcBlobLead.fLimitCenterY - (m_stcBlobLead.fHeight / 2), 4);
                m_stcBlobLead.fEndY = (float)Math.Round(m_stcBlobLead.fLimitCenterY + (m_stcBlobLead.fHeight / 2), 4);
                m_stcBlobLead.intStartX = (int)Math.Round(m_stcBlobLead.fLimitCenterX - (m_stcBlobLead.fWidth / 2), 0, MidpointRounding.AwayFromZero);
                m_stcBlobLead.intEndX = (int)Math.Round(m_stcBlobLead.fLimitCenterX + (m_stcBlobLead.fWidth / 2), 0, MidpointRounding.AwayFromZero);
                m_stcBlobLead.intStartY = (int)Math.Round(m_stcBlobLead.fLimitCenterY - (m_stcBlobLead.fHeight / 2), 0, MidpointRounding.AwayFromZero);
                m_stcBlobLead.intEndY = (int)Math.Round(m_stcBlobLead.fLimitCenterY + (m_stcBlobLead.fHeight / 2), 0, MidpointRounding.AwayFromZero);
                m_stcBlobLead.blnSelected = true;
                m_stcBlobLead.blnCheckSkew = true;
                m_stcBlobLead.intDirection = -1;
                m_stcBlobLead.intGroupID = 0;
                m_stcBlobLead.intNoID = 0;
                m_stcBlobLead.intSelectedBlob = i;
                arrBlobsFeature.Add(m_stcBlobLead);
            }
        }

        public void SetBlobsFeaturesToArray_SideLead3D(ROI objROI)
        {
            EBlobs objEBlobs = m_objEBlobs;

            //#if (DEBUG)
            //            objROI.SaveImage("D:\\TS\\objROI.bmp");
            //#endif


            m_arrTemplateBlobBodyLeads.Clear();

            int intSelectedObjectNum = 0;
            float fBorderDistanceX, fBorderDistanceY;

            if (objEBlobs.ref_intNumSelectedObject > 0)
                intSelectedObjectNum = 1;

            //If more than 1 blob is found
            if (intSelectedObjectNum > 0)
            {
                //if there are more than 1 blob
                //Combine all the blob within the range
                float fLimitCenterX;
                float fLimitCenterY;
                float fWidth;
                float fHeight;
                float fOrgX;
                float fOrgY;
                int intTotalBlobCount;
                int intSelectedBlob = 0;
                int intTotalArea;
                float fTotalCenterX;
                float fTotalCenterY;
                float fTotalLimitCenterX;
                float fTotalLimitCenterY;
                float fStartX;
                float fStartY;
                float fEndX;
                float fEndY;
                List<int> arrSkipNo = new List<int>();
                bool blnSkipToNextObject = false;

                for (int i = 0; i < intSelectedObjectNum; i++)
                {
                    for (int k = 0; k < arrSkipNo.Count; k++)
                    {
                        if (i == arrSkipNo[k])
                        {
                            blnSkipToNextObject = true;
                            break;
                        }
                    }

                    if (blnSkipToNextObject)
                    {
                        blnSkipToNextObject = false;
                        continue;
                    }

                    fLimitCenterX = objEBlobs.ref_arrLimitCenterX[i];
                    fLimitCenterY = objEBlobs.ref_arrLimitCenterY[i];
                    fWidth = objEBlobs.ref_arrWidth[i];
                    fHeight = objEBlobs.ref_arrHeight[i];
                    fOrgX = fLimitCenterX - fWidth / 2;
                    fOrgY = fLimitCenterY - fHeight / 2;
                    intTotalArea = 0;
                    fTotalCenterX = 0;
                    fTotalCenterY = 0;
                    fTotalLimitCenterX = 0;
                    fTotalLimitCenterY = 0;
                    fStartX = fOrgX;
                    fStartY = fOrgY;
                    fEndX = fOrgX + fWidth;
                    fEndY = fOrgY + fHeight;
                    intSelectedBlob = 0;
                    intTotalBlobCount = 0;

                    //2021-08-28 ZJYEOH: Use largest blob as Side Lead body, no need to consider other blob to filter noise build near mirror edge
                    //for (int j = i; j < objEBlobs.ref_intNumSelectedObject; j++)
                    //{

                    //    if (m_intLeadDirection == 0)
                    //    {
                    //        //Horizontal lead
                    //        if (objEBlobs.ref_arrLimitCenterY[j] < fOrgY || objEBlobs.ref_arrLimitCenterY[j] > (fOrgY + fHeight))
                    //            continue;
                    //    }
                    //    else
                    //    {
                    //        //Vertical lead
                    //        if (objEBlobs.ref_arrLimitCenterX[j] < fOrgX || objEBlobs.ref_arrLimitCenterX[j] > (fOrgX + fWidth))
                    //            continue;
                    //    }

                    //    // This segment is to handle the case when the largest blob builded is from the same lead
                    //    // Since the number of lead is predefined, each blob data collected must be from different lead
                    //    if (intSelectedObjectNum >= j && i != j)
                    //    {
                    //        if (objEBlobs.ref_intNumSelectedObject > intSelectedObjectNum)
                    //            intSelectedObjectNum++;
                    //        arrSkipNo.Add(j);
                    //    }

                    //    intTotalArea += objEBlobs.ref_arrArea[j];
                    //    fTotalCenterX += objEBlobs.ref_arrGravityCenterX[j] * objEBlobs.ref_arrArea[j];
                    //    fTotalCenterY += objEBlobs.ref_arrGravityCenterY[j] * objEBlobs.ref_arrArea[j];
                    //    //fTotalLimitCenterX += objEBlobs.ref_arrLimitCenterX[j] * objEBlobs.ref_arrArea[j];
                    //    //fTotalLimitCenterY += objEBlobs.ref_arrLimitCenterY[j] * objEBlobs.ref_arrArea[j];

                    //    if (fStartX > objEBlobs.ref_arrLimitCenterX[j] - (objEBlobs.ref_arrWidth[j] / 2))
                    //    {
                    //        fStartX = objEBlobs.ref_arrLimitCenterX[j] - (objEBlobs.ref_arrWidth[j] / 2);
                    //    }

                    //    if (fStartY > objEBlobs.ref_arrLimitCenterY[j] - (objEBlobs.ref_arrHeight[j] / 2))
                    //    {
                    //        fStartY = objEBlobs.ref_arrLimitCenterY[j] - (objEBlobs.ref_arrHeight[j] / 2);
                    //    }

                    //    if (fEndX < objEBlobs.ref_arrLimitCenterX[j] + (objEBlobs.ref_arrWidth[j] / 2))
                    //    {
                    //        fEndX = objEBlobs.ref_arrLimitCenterX[j] + (objEBlobs.ref_arrWidth[j] / 2);
                    //    }

                    //    if (fEndY < objEBlobs.ref_arrLimitCenterY[j] + (objEBlobs.ref_arrHeight[j] / 2))
                    //    {
                    //        fEndY = objEBlobs.ref_arrLimitCenterY[j] + (objEBlobs.ref_arrHeight[j] / 2);
                    //    }

                    //    intSelectedBlob |= (1 << j);
                    //    intTotalBlobCount++;
                    //}

                    m_stcBlobLead = new BlobsFeatures();
                    m_stcBlobLead.fArea = m_objEBlobs.ref_arrArea[i]; //intTotalArea;
                    m_stcBlobLead.fCenterX = (fEndX + fStartX) / 2; //fTotalCenterX / intTotalArea;
                    m_stcBlobLead.fCenterY = (fEndY + fStartY) / 2; //fTotalCenterY / intTotalArea;
                    m_stcBlobLead.fLimitCenterX = (fEndX + fStartX) / 2; //fTotalLimitCenterX / intTotalArea;
                    m_stcBlobLead.fLimitCenterY = (fEndY + fStartY) / 2; //fTotalLimitCenterY / intTotalArea;
                    m_stcBlobLead.fWidth = fEndX - fStartX;
                    m_stcBlobLead.fHeight = fEndY - fStartY;

                    fBorderDistanceX = Math.Min(m_stcBlobLead.fLimitCenterX, objROI.ref_ROIWidth - m_stcBlobLead.fLimitCenterX);
                    fBorderDistanceY = Math.Min(m_stcBlobLead.fLimitCenterY, objROI.ref_ROIHeight - m_stcBlobLead.fLimitCenterY);

                    if ((fBorderDistanceX / fBorderDistanceY) < 0.7) // point x closer to border compare with point y
                    {
                        m_stcBlobLead.intLengthMode = 2;   // 2 mean length == width OR set Width == fHeight, Length == fWidth
                    }
                    else if ((fBorderDistanceY / fBorderDistanceX) < 0.7)   // point y closer to border compare with point x
                    {
                        m_stcBlobLead.intLengthMode = 1;   // 1 mean length == height OR set Width == fWidth, Length == fHeight
                    }
                    else
                    {
                        if (m_stcBlobLead.fWidth < m_stcBlobLead.fHeight)  // width shorter then height
                        {
                            m_stcBlobLead.intLengthMode = 1;   // 1 mean length == height
                        }
                        else
                        {
                            m_stcBlobLead.intLengthMode = 2;   // 2 mean length == width
                        }
                    }

                    m_stcBlobLead.intContourX = objEBlobs.ref_arrContourX[0];
                    m_stcBlobLead.intContourY = objEBlobs.ref_arrContourY[0];
                    m_stcBlobLead.intObjNo = 0;
                    m_stcBlobLead.fStartX = (float)Math.Round(fStartX, 4);
                    m_stcBlobLead.fEndX = (float)Math.Round(fEndX, 4);
                    m_stcBlobLead.fStartY = (float)Math.Round(fStartY, 4);
                    m_stcBlobLead.fEndY = (float)Math.Round(fEndY, 4);
                    m_stcBlobLead.intStartX = (int)Math.Round(fStartX, 0, MidpointRounding.AwayFromZero);
                    m_stcBlobLead.intEndX = (int)Math.Round(fEndX, 0, MidpointRounding.AwayFromZero);
                    m_stcBlobLead.intStartY = (int)Math.Round(fStartY, 0, MidpointRounding.AwayFromZero);
                    m_stcBlobLead.intEndY = (int)Math.Round(fEndY, 0, MidpointRounding.AwayFromZero);
                    m_stcBlobLead.blnSelected = true;
                    m_stcBlobLead.blnCheckSkew = true;
                    m_stcBlobLead.intDirection = -1;
                    m_stcBlobLead.intGroupID = 0;
                    //m_stcBlobLead.fPitch = -1;
                    m_stcBlobLead.intNoID = 0;
                    m_stcBlobLead.intSelectedBlob = intSelectedBlob;
                    m_arrTemplateBlobBodyLeads.Add(m_stcBlobLead);
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="objEBlobs"></param>
        /// <param name="arrBlobsFeature"></param>
        /// <param name="objROI"></param>
        /// <param name="intNumberOfLead"></param>
        /// <param name="intUnitLeadDirection">0=Horizontal, 1=Vertical</param>
        /// <param name="intLeadBorderDirection">0x01=left, 0x02=Right, 0x04=Top, 0x08=Bottom</param>
        public void SetBlobsFeaturesToArray_CenterLead3D_SingleSide(EBlobs objEBlobs, ArrayList arrBlobsFeature, ROI objROI, int intNumberOfLead, int intUnitLeadDirection, int intLeadBorderDirection)
        {
            /*
             * 
             * 
             */

            int intSelectedObjectNum = 0;

            //2020-08-06 ZJYEOH : will not allow user to coninue next step if blob not tally with lead count
            //if (objEBlobs.ref_intNumSelectedObject >= intNumberOfLead)
            //    intSelectedObjectNum = intNumberOfLead;
            //else
            intSelectedObjectNum = objEBlobs.ref_intNumSelectedObject;

            //If more than 1 blob is found
            if (intSelectedObjectNum > 0)
            {
                //if there are more than 1 blob
                //Combine all the blob within the range
                float fLimitCenterX;
                float fLimitCenterY;
                float fWidth;
                float fHeight;
                float fOrgX;
                float fOrgY;
                int intTotalBlobCount;
                int intSelectedBlob = 0;
                int intTotalArea;
                float fTotalCenterX;
                float fTotalCenterY;
                float fTotalLimitCenterX;
                float fTotalLimitCenterY;
                float fStartX;
                float fStartY;
                float fEndX;
                float fEndY;
                List<int> arrSkipNo = new List<int>();
                bool blnSkipToNextObject = false;

                // Scan blob to get biggest size blobs for the each lead location.
                for (int i = 0; i < intSelectedObjectNum; i++)
                {
                    for (int k = 0; k < arrSkipNo.Count; k++)
                    {
                        if (i == arrSkipNo[k])
                        {
                            blnSkipToNextObject = true;
                            break;
                        }
                    }

                    // Skip this blob because ???
                    if (blnSkipToNextObject)
                    {
                        blnSkipToNextObject = false;
                        continue;
                    }

                    float fFromROIOffsetLimitCenterX = objROI.ref_ROIPositionX + objEBlobs.ref_arrLimitCenterX[i];
                    float fFromROIOffsetLimitCenterY = objROI.ref_ROIPositionY + objEBlobs.ref_arrLimitCenterY[i];
                    // Get blob center point, start point and size
                    fLimitCenterX = fFromROIOffsetLimitCenterX;
                    fLimitCenterY = fFromROIOffsetLimitCenterY;
                    fWidth = objEBlobs.ref_arrWidth[i];
                    fHeight = objEBlobs.ref_arrHeight[i];
                    fOrgX = fLimitCenterX - fWidth / 2;
                    fOrgY = fLimitCenterY - fHeight / 2;
                    intTotalArea = 0;
                    fTotalCenterX = 0;
                    fTotalCenterY = 0;
                    fTotalLimitCenterX = 0;
                    fTotalLimitCenterY = 0;
                    fStartX = fOrgX;
                    fStartY = fOrgY;
                    fEndX = fOrgX + fWidth;
                    fEndY = fOrgY + fHeight;
                    intSelectedBlob = 0;
                    intTotalBlobCount = 0;

                    // Scan the i blob itself and rest of the smaller blob whether they are same y range (horizontal) or x range (vertical).
                    for (int j = i; j < objEBlobs.ref_intNumSelectedObject; j++)    // start from i itselft
                    {
                        float fFromROIOffsetCenterX2 = objROI.ref_ROIPositionX + objEBlobs.ref_arrGravityCenterX[j];
                        float fFromROIOffsetCenterY2 = objROI.ref_ROIPositionY + objEBlobs.ref_arrGravityCenterY[j];
                        float fFromROIOffsetLimitCenterX2 = objROI.ref_ROIPositionX + objEBlobs.ref_arrLimitCenterX[j];
                        float fFromROIOffsetLimitCenterY2 = objROI.ref_ROIPositionY + objEBlobs.ref_arrLimitCenterY[j];


                        if (i != j)
                        {
                            if (m_intLeadDirection == 0)    //Horizontal lead
                            {
                                // skip if j blob not within i blob y range.
                                if (fFromROIOffsetLimitCenterY2 < fOrgY || fFromROIOffsetLimitCenterY2 > (fOrgY + fHeight))
                                    continue;
                            }
                            else    //Vertical lead
                            {
                                // skip if j blob not within i blob x range.
                                if (fFromROIOffsetLimitCenterX2 < fOrgX || fFromROIOffsetLimitCenterX2 > (fOrgX + fWidth))
                                    continue;
                            }

                            // This segment is to handle the case when the largest blob builded is from the same lead
                            // Since the number of lead is predefined, each blob data collected must be from different lead
                            if (intSelectedObjectNum >= j && i != j)
                            {
                                if (objEBlobs.ref_intNumSelectedObject > intSelectedObjectNum)
                                    intSelectedObjectNum++;
                                arrSkipNo.Add(j);   // Add this j blob to skip list so that this blob will not be checked again in i blob scanning.
                            }
                        }

                        intTotalArea += objEBlobs.ref_arrArea[j];
                        fTotalCenterX += fFromROIOffsetCenterX2 * objEBlobs.ref_arrArea[j];
                        fTotalCenterY += fFromROIOffsetCenterY2 * objEBlobs.ref_arrArea[j];
                        //fTotalLimitCenterX += fFromROIOffsetLimitCenterX2 * objEBlobs.ref_arrArea[j];
                        //fTotalLimitCenterY += fFromROIOffsetLimitCenterY2 * objEBlobs.ref_arrArea[j];

                        if (fStartX > fFromROIOffsetLimitCenterX2 - (objEBlobs.ref_arrWidth[j] / 2))
                        {
                            fStartX = fFromROIOffsetLimitCenterX2 - (objEBlobs.ref_arrWidth[j] / 2);
                        }

                        if (fStartY > fFromROIOffsetLimitCenterY2 - (objEBlobs.ref_arrHeight[j] / 2))
                        {
                            fStartY = fFromROIOffsetLimitCenterY2 - (objEBlobs.ref_arrHeight[j] / 2);
                        }

                        if (fEndX < fFromROIOffsetLimitCenterX2 + (objEBlobs.ref_arrWidth[j] / 2))
                        {
                            fEndX = fFromROIOffsetLimitCenterX2 + (objEBlobs.ref_arrWidth[j] / 2);
                        }

                        if (fEndY < fFromROIOffsetLimitCenterY2 + (objEBlobs.ref_arrHeight[j] / 2))
                        {
                            fEndY = fFromROIOffsetLimitCenterY2 + (objEBlobs.ref_arrHeight[j] / 2);
                        }

                        intSelectedBlob |= (1 << j);
                        intTotalBlobCount++;
                    }

                    m_stcBlobLead = new BlobsFeatures();
                    m_stcBlobLead.fArea = intTotalArea;
                    m_stcBlobLead.fCenterX = fTotalCenterX / intTotalArea;
                    m_stcBlobLead.fCenterY = fTotalCenterY / intTotalArea;
                    m_stcBlobLead.fLimitCenterX = (fEndX + fStartX) / 2;
                    m_stcBlobLead.fLimitCenterY = (fEndY + fStartY) / 2;
                    m_stcBlobLead.fWidth = fEndX - fStartX;
                    m_stcBlobLead.fHeight = fEndY - fStartY;

                    if (intUnitLeadDirection == 0)  // Horizontal
                    {
                        // For horizontal lead, lead's width == blob's height, lead's length == blob's width
                        m_stcBlobLead.intLengthMode = 2;   // 2 mean length == width OR set Width == fHeight, Length == fWidth
                    }
                    else // Vertical
                    {
                        // For horizontal lead, lead's width == blob's width, lead's length == blob's height
                        m_stcBlobLead.intLengthMode = 1;   // 1 mean length == height OR set Width == fWidth, Length == fHeight
                    }

                    m_stcBlobLead.intContourX = objEBlobs.ref_arrContourX[0];
                    m_stcBlobLead.intContourY = objEBlobs.ref_arrContourY[0];
                    m_stcBlobLead.intObjNo = 0;
                    m_stcBlobLead.fStartX = (float)Math.Round(fStartX, 4);
                    m_stcBlobLead.fEndX = (float)Math.Round(fEndX, 4);
                    m_stcBlobLead.fStartY = (float)Math.Round(fStartY, 4);
                    m_stcBlobLead.fEndY = (float)Math.Round(fEndY, 4);
                    m_stcBlobLead.intStartX = (int)Math.Round(fStartX, 0, MidpointRounding.AwayFromZero);
                    m_stcBlobLead.intEndX = (int)Math.Round(fEndX, 0, MidpointRounding.AwayFromZero);
                    m_stcBlobLead.intStartY = (int)Math.Round(fStartY, 0, MidpointRounding.AwayFromZero);
                    m_stcBlobLead.intEndY = (int)Math.Round(fEndY, 0, MidpointRounding.AwayFromZero);
                    m_stcBlobLead.blnSelected = true;
                    m_stcBlobLead.blnCheckSkew = true;
                    m_stcBlobLead.intDirection = intLeadBorderDirection;
                    m_stcBlobLead.intGroupID = 0;
                    //m_stcBlobLead.fPitch = -1;
                    m_stcBlobLead.intNoID = 0;
                    m_stcBlobLead.intSelectedBlob = intSelectedBlob;
                    arrBlobsFeature.Add(m_stcBlobLead);
                }
            }
        }

        public string GetBlobsFeaturesAllData()
        {
            string strBlobsFeatures = "";

            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).intGroupID.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fArea.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).intLengthMode.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).intContourX.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).intContourY.ToString() + "#";
                if (((BlobsFeatures)m_arrTemplateBlobLeads[i]).arrContourX == null)
                {
                    strBlobsFeatures += "0#";
                }
                else
                {
                    strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).arrContourX.Length.ToString() + "#";

                    for (int j = 0; j < ((BlobsFeatures)m_arrTemplateBlobLeads[i]).arrContourX.Length; j++)
                    {
                        strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).arrContourX[j].ToString() + "#";
                        strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).arrContourY[j].ToString() + "#";
                    }
                }
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).intStartX.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).intStartY.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).intEndX.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).intEndY.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fStartX.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fStartY.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fEndX.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fEndY.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).intDirection.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).intSide.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCenterX.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCenterY.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterX.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterY.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fWidth.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fHeight.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fBaseWidth.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fBaseLength.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fBaseCenterX.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fBaseCenterY.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fTipWidth.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fTipLength.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fTipCenterX.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fTipCenterY.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).blnSelected.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fSweepLeftReference.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fSweepRightReference.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fSweepTopReference.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fSweepBottomReference.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLeftDistance.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fRightDistance.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fTopDistance.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fBottomDistance.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fXDistance.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fYDistance.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fPitch.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fGap.ToString() + "#";

                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fSkew).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fOffSet).ToString("F4") + "#";

                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinBaseWidth).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxBaseWidth).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinBaseLength).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxBaseLength).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinTipWidth).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxTipWidth).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinTipLength).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxTipLength).ToString("F4") + "#";

                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinPitch).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxPitch).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinGap).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxGap).ToString("F4") + "#";

                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinStandOff).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxStandOff).ToString("F4") + "#";

                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinSolderPadLength).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxSolderPadLength).ToString("F4") + "#";

                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxCoplan).ToString("F4") + "#";

                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinAGV).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxAGV).ToString("F4") + "#";

                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).intAGVROITolerance_Top).ToString() + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).intAGVROITolerance_Right).ToString() + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).intAGVROITolerance_Bottom).ToString() + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).intAGVROITolerance_Left).ToString() + "#";

                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLeadLimitMinWidth).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLeadLimitMaxWidth).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLeadMaxBurrWidth).ToString("F4") + "#";

                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fWidthOffset).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLengthOffset).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fPitchOffset).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fGapOffset).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fStandOffOffset).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCoplanOffset).ToString("F4") + "#";
            }
            return strBlobsFeatures;
        }

        public List<string> GetBlobFeaturesResult_WithPassFailIndicator(int intMatchTemplateIndex)
        {
            List<string> arrResultList = new List<string>();

            int intResultTableFailMask = 0;
            float fData, fMaxData, fMinData;
            int i = intMatchTemplateIndex;

            if (m_arrSampleBlobLeads == null || i >= m_arrSampleBlobLeads.Length || !m_blnViewLeadResultDrawing)
            {
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add(intResultTableFailMask.ToString());
                return arrResultList;
            }

            if (m_arrSampleBlobLeads[i].fOffSetMM == -999 || (m_intFailOptionMask & 0x20000) == 0)
                arrResultList.Add("---");
            else
            {
                fData = m_arrSampleBlobLeads[i].fOffSetMM * m_fMMToUnitValue;
                arrResultList.Add(fData.ToString("F" + m_intDecimal));
                fMaxData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fOffSet * m_fMMToUnitValue;
                if (fData > fMaxData)
                {
                    intResultTableFailMask |= 0x20000;
                }
            }

            if (m_arrSampleBlobLeads[i].fSkewMM == -999 || (m_intFailOptionMask & 0x100) == 0)
            {
                arrResultList.Add("---");
                if (((m_arrSampleBlobLeads[i].intFailMask & 0x10) == 0) && ((m_arrSampleBlobLeads[i].intFailMask & 0x20) == 0) && !m_arrSampleBlobLeads[i].blnBaseStartFound && !m_arrSampleBlobLeads[i].blnBaseEndFound)
                {
                    intResultTableFailMask |= 0x100;
                }
            }
            else
            {
                fData = m_arrSampleBlobLeads[i].fSkewMM * m_fMMToUnitValue;
                arrResultList.Add(fData.ToString("F" + m_intDecimal));
                fMaxData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fSkew * m_fMMToUnitValue;
                if (fData > fMaxData)
                {
                    intResultTableFailMask |= 0x100;
                }
            }

            if (m_arrSampleBlobLeads[i].fTipWidthMM == -999 || (m_intFailOptionMask & 0x40) == 0)
                arrResultList.Add("---");
            else
            {
                fData = m_arrSampleBlobLeads[i].fTipWidthMM * m_fMMToUnitValue;
                arrResultList.Add(fData.ToString("F" + m_intDecimal));
                fMinData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinTipWidth * m_fMMToUnitValue;
                fMaxData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxTipWidth * m_fMMToUnitValue;
                if (fData < fMinData || fData > fMaxData)
                {
                    intResultTableFailMask |= 0x01;
                }
            }

            if (m_arrSampleBlobLeads[i].fTipLengthMM == -999 || (m_intFailOptionMask & 0x80) == 0)
                arrResultList.Add("---");
            else
            {
                fData = m_arrSampleBlobLeads[i].fTipLengthMM * m_fMMToUnitValue;
                arrResultList.Add(fData.ToString("F" + m_intDecimal));
                fMinData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinTipLength * m_fMMToUnitValue;
                fMaxData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxTipLength * m_fMMToUnitValue;
                if (fData < fMinData || fData > fMaxData)
                {
                    intResultTableFailMask |= 0x02;
                }
            }

            float fPitch = 0, fGap = 0;
            float fMinP = 0, fMaxP = 0, fMinG = 0, fMaxG = 0;
            if (GetPitchGapResult(i, ref fPitch, ref fGap) && (((m_intFailOptionMask & 0x200) > 0) || ((m_intFailOptionMask & 0x400) > 0)))
            {
                if (fPitch != -999 && ((m_intFailOptionMask & 0x200) > 0))
                {
                    if (GetPitchGapMinMax(i, ref fMinP, ref fMaxP, ref fMinG, ref fMaxG))
                    {
                        fData = fPitch * m_fMMToUnitValue;
                        arrResultList.Add(fData.ToString("F" + m_intDecimal));
                        fMinData = fMinP * m_fMMToUnitValue;
                        fMaxData = fMaxP * m_fMMToUnitValue;
                        if (fData < fMinData || fData > fMaxData)
                        {
                            intResultTableFailMask |= 0x04;
                        }
                    }
                    else
                    {
                        arrResultList.Add("---");
                    }
                }
                else
                {
                    arrResultList.Add("---");
                }

                if (fGap != -999 && ((m_intFailOptionMask & 0x400) > 0))
                {
                    if (GetPitchGapMinMax(i, ref fMinP, ref fMaxP, ref fMinG, ref fMaxG))
                    {
                        fData = fGap * m_fMMToUnitValue;
                        arrResultList.Add(fData.ToString("F" + m_intDecimal));
                        fMinData = fMinG * m_fMMToUnitValue;
                        fMaxData = fMaxG * m_fMMToUnitValue;
                        if (fData < fMinData || fData > fMaxData)
                        {
                            intResultTableFailMask |= 0x08;
                        }
                    }
                    else
                    {
                        arrResultList.Add("---");
                    }
                }
                else
                {
                    arrResultList.Add("---");
                }
            }
            else
            {
                arrResultList.Add("---");
                arrResultList.Add("---");
            }

            // Stand Off
            if (m_arrSampleBlobLeads[i].fStandOffMM == -999 || (m_intFailOptionMask & 0x01) == 0)
            {
                arrResultList.Add("---");
                if ((m_arrFailResultMask[0] & 0x800000) > 0)
                {
                    intResultTableFailMask |= 0x10;
                }
            }
            else
            {
                fData = m_arrSampleBlobLeads[i].fStandOffMM * m_fMMToUnitValue;
                arrResultList.Add(fData.ToString("F" + m_intDecimal));
                fMinData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinStandOff * m_fMMToUnitValue;
                fMaxData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxStandOff * m_fMMToUnitValue;
                if (fData < fMinData || fData > fMaxData)
                {
                    intResultTableFailMask |= 0x10;
                }
            }

            if (m_arrSampleBlobLeads[i].fSolderPadLengthMM == -999 || (m_intFailOptionMask & 0x08) == 0)
                arrResultList.Add("---");
            else
            {
                fData = m_arrSampleBlobLeads[i].fSolderPadLengthMM * m_fMMToUnitValue;
                arrResultList.Add(fData.ToString("F" + m_intDecimal));
                fMinData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinSolderPadLength * m_fMMToUnitValue;
                fMaxData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxSolderPadLength * m_fMMToUnitValue;
                if (fData < fMinData || fData > fMaxData)
                {
                    intResultTableFailMask |= 0x20;
                }
            }

            if (m_arrSampleBlobLeads[i].fCoplanMM == -999 || (m_intFailOptionMask & 0x02) == 0)
            {
                arrResultList.Add("---");
                if ((m_arrFailResultMask[0] & 0x800000) > 0)
                {
                    intResultTableFailMask |= 0x40;
                }
            }
            else
            {
                fData = m_arrSampleBlobLeads[i].fCoplanMM * m_fMMToUnitValue;
                arrResultList.Add(fData.ToString("F" + m_intDecimal));
                fMaxData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxCoplan * m_fMMToUnitValue;
                if (fData > fMaxData)
                {
                    intResultTableFailMask |= 0x40;
                }
            }

            if (m_arrSampleBlobLeads[i].fAGV == -999 || (m_intFailOptionMask & 0x40000) == 0)
                arrResultList.Add("---");
            else
            {
                fData = m_arrSampleBlobLeads[i].fAGV;
                arrResultList.Add(fData.ToString("F" + m_intDecimal));
                fMinData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinAGV;
                fMaxData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxAGV;
                if (fData < fMinData || fData > fMaxData)
                {
                    intResultTableFailMask |= 0x80;
                }
            }

            if (m_arrSampleBlobLeads[i].fLeadMinWidth == -999 || (m_intFailOptionMask & 0x100000) == 0)
                arrResultList.Add("---");
            else
            {
                fData = m_arrSampleBlobLeads[i].fLeadMinWidthMM * m_fMMToUnitValue;
                arrResultList.Add(fData.ToString("F" + m_intDecimal));
                fMaxData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLeadLimitMinWidth * m_fMMToUnitValue;
                if (fData < fMaxData)
                {
                    intResultTableFailMask |= 0x200;
                }
            }

            if (m_arrSampleBlobLeads[i].fLeadMaxWidth == -999 || (m_intFailOptionMask & 0x100000) == 0)
                arrResultList.Add("---");
            else
            {
                fData = m_arrSampleBlobLeads[i].fLeadMaxWidthMM * m_fMMToUnitValue;
                arrResultList.Add(fData.ToString("F" + m_intDecimal));
                fMaxData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLeadLimitMaxWidth * m_fMMToUnitValue;
                if (fData > fMaxData)
                {
                    intResultTableFailMask |= 0x400;
                }
            }

            if (m_arrSampleBlobLeads[i].fLeadBurrWidth == -999 || (m_intFailOptionMask & 0x200000) == 0)
                arrResultList.Add("---");
            else
            {
                fData = m_arrSampleBlobLeads[i].fLeadBurrWidthMM * m_fMMToUnitValue;
                arrResultList.Add(fData.ToString("F" + m_intDecimal));
                fMaxData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLeadMaxBurrWidth * m_fMMToUnitValue;
                if (fData > fMaxData)
                {
                    intResultTableFailMask |= 0x800;
                }
            }

            if ((m_arrSampleBlobLeads[i].intFailMask & 0x20) > 0)
            {
                intResultTableFailMask |= 0x1000;
            }

            arrResultList.Add(intResultTableFailMask.ToString());

            return arrResultList;
        }

        public string GetBlobFeaturesResult(int intMatchTemplateIndex)
        {
            string strBlobFeatures = "";
            float fData;
            int i = intMatchTemplateIndex;

            if (m_arrSampleBlobLeads == null || i >= m_arrSampleBlobLeads.Length)
                return "---#---#---#---#---#---#---#---#---#";

            if (m_arrSampleBlobLeads == null)
                return "---#---#---#---#---#---#---#---#---#";

            strBlobFeatures += "Set Value#";

            if (m_arrSampleBlobLeads[i].fOffSetMM == -999)
                strBlobFeatures += "---#";
            else
            {
                fData = m_arrSampleBlobLeads[i].fOffSetMM * m_fMMToUnitValue;
                strBlobFeatures += fData.ToString("F" + m_intDecimal) + "#";
            }

            if (m_arrSampleBlobLeads[i].fTipWidthMM == -999)
                strBlobFeatures += "---#";
            else
            {
                fData = m_arrSampleBlobLeads[i].fTipWidthMM * m_fMMToUnitValue;
                strBlobFeatures += fData.ToString("F" + m_intDecimal) + "#";
            }

            if (m_arrSampleBlobLeads[i].fTipLengthMM == -999)
                strBlobFeatures += "---#";
            else
            {
                fData = m_arrSampleBlobLeads[i].fTipLengthMM * m_fMMToUnitValue;
                strBlobFeatures += fData.ToString("F" + m_intDecimal) + "#";
            }


            float fPitch = 0, fGap = 0;
            if (GetPitchGapResult(i, ref fPitch, ref fGap))
            {
                strBlobFeatures += (fPitch * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "#";
                strBlobFeatures += (fGap * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "#";
            }
            else
            {
                strBlobFeatures += "---#";
                strBlobFeatures += "---#";
            }

            if (m_arrSampleBlobLeads[i].fSkewMM == -999)
                strBlobFeatures += "---#";
            else
            {
                fData = m_arrSampleBlobLeads[i].fSkewMM * m_fMMToUnitValue;
                strBlobFeatures += fData.ToString("F" + m_intDecimal) + "#";
            }

            if (m_arrSampleBlobLeads[i].fStandOffMM == -999)
                strBlobFeatures += "---#";
            else
            {
                fData = m_arrSampleBlobLeads[i].fStandOffMM * m_fMMToUnitValue;
                strBlobFeatures += fData.ToString("F" + m_intDecimal) + "#";
            }

            if (m_arrSampleBlobLeads[i].fCoplanMM == -999)
                strBlobFeatures += "---#";
            else
            {
                fData = m_arrSampleBlobLeads[i].fCoplanMM * m_fMMToUnitValue;
                strBlobFeatures += fData.ToString("F" + m_intDecimal) + "#";
            }

            return strBlobFeatures;

        }

        public string GetBlobFeaturesInspectRealData(int intTemplateIndex)
        {
            string strBlobsFeatures = "";
            float fData;

            fData = ((BlobsFeatures)m_arrTemplateBlobLeads[intTemplateIndex]).fOffSet * m_fMMToUnitValue;
            strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";

            fData = ((BlobsFeatures)m_arrTemplateBlobLeads[intTemplateIndex]).fMinTipWidth * m_fMMToUnitValue;
            strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
            fData = ((BlobsFeatures)m_arrTemplateBlobLeads[intTemplateIndex]).fMaxTipWidth * m_fMMToUnitValue;
            strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
            fData = ((BlobsFeatures)m_arrTemplateBlobLeads[intTemplateIndex]).fMinTipLength * m_fMMToUnitValue;
            strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
            fData = ((BlobsFeatures)m_arrTemplateBlobLeads[intTemplateIndex]).fMaxTipLength * m_fMMToUnitValue;
            strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";

            float fMinP, fMaxP, fMinG, fMaxG;
            fMinP = fMaxP = fMinG = fMaxG = 0.0f;

            if (GetPitchGapMinMax(intTemplateIndex, ref fMinP, ref fMaxP, ref fMinG, ref fMaxG))
            {
                fData = fMinP * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";

                fData = fMaxP * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";

                fData = fMinG * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";

                fData = fMaxG * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
            }
            else
            {
                for (int j = 0; j < 4; j++)
                {
                    fData = -1;
                    strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                }
            }


            fData = ((BlobsFeatures)m_arrTemplateBlobLeads[intTemplateIndex]).fSkew * m_fMMToUnitValue;
            strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";

            fData = ((BlobsFeatures)m_arrTemplateBlobLeads[intTemplateIndex]).fMinStandOff * m_fMMToUnitValue;
            strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
            fData = ((BlobsFeatures)m_arrTemplateBlobLeads[intTemplateIndex]).fMaxStandOff * m_fMMToUnitValue;
            strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";

            fData = ((BlobsFeatures)m_arrTemplateBlobLeads[intTemplateIndex]).fMaxCoplan * m_fMMToUnitValue;
            strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";


            //fData = ((BlobsFeatures)m_arrTemplateBlobPads[intTemplateIndex]).fMaxBroken * m_fMMToUnitValueArea;
            //strBlobsFeatures += fData.ToString("F" + m_intDecimal2) + "#";

            return strBlobsFeatures;
        }

        public List<string> GetBlobFeaturesResult_WithPassFailIndicator_CenterLeads(int intMatchTemplateIndex)
        {
            List<string> arrResultList = new List<string>();

            int intResultTableFailMask = 0;
            float fData, fMaxData, fMinData;
            int i = intMatchTemplateIndex;

            if (m_arrSampleBlobLeads == null || i >= m_arrSampleBlobLeads.Length)
            {
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add(intResultTableFailMask.ToString());
                return arrResultList;
            }

            if (m_arrSampleBlobLeads[i].fTipWidthMM == -999 || (m_intFailOptionMask & 0x40) == 0)
                arrResultList.Add("---");
            else
            {
                fData = m_arrSampleBlobLeads[i].fTipWidthMM * m_fMMToUnitValue;
                arrResultList.Add(fData.ToString("F" + m_intDecimal));
                fMinData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinTipWidth * m_fMMToUnitValue;
                fMaxData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxTipWidth * m_fMMToUnitValue;
                if (fData < fMinData || fData > fMaxData)
                {
                    intResultTableFailMask |= 0x01;
                }
            }

            if (m_arrSampleBlobLeads[i].fTipLengthMM == -999 || (m_intFailOptionMask & 0x80) == 0)
                arrResultList.Add("---");
            else
            {
                fData = m_arrSampleBlobLeads[i].fTipLengthMM * m_fMMToUnitValue;
                arrResultList.Add(fData.ToString("F" + m_intDecimal));
                fMinData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinTipLength * m_fMMToUnitValue;
                fMaxData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxTipLength * m_fMMToUnitValue;
                if (fData < fMinData || fData > fMaxData)
                {
                    intResultTableFailMask |= 0x02;
                }
            }

            float fPitch = 0, fGap = 0;
            float fMinP = 0, fMaxP = 0, fMinG = 0, fMaxG = 0;
            if (GetPitchGapResult(i, ref fPitch, ref fGap) && (((m_intFailOptionMask & 0x200) > 0) || ((m_intFailOptionMask & 0x400) > 0)))
            {
                if (GetPitchGapMinMax(i, ref fMinP, ref fMaxP, ref fMinG, ref fMaxG) && ((m_intFailOptionMask & 0x200) > 0))
                {
                    fData = fPitch * m_fMMToUnitValue;
                    arrResultList.Add(fData.ToString("F" + m_intDecimal));
                    fMinData = fMinP * m_fMMToUnitValue;
                    fMaxData = fMaxP * m_fMMToUnitValue;
                    if (fData < fMinData || fData > fMaxData)
                    {
                        intResultTableFailMask |= 0x04;
                    }
                }
                else
                {
                    arrResultList.Add("---");
                }

                if (GetPitchGapMinMax(i, ref fMinP, ref fMaxP, ref fMinG, ref fMaxG) && ((m_intFailOptionMask & 0x400) > 0))
                {
                    fData = fGap * m_fMMToUnitValue;
                    arrResultList.Add(fData.ToString("F" + m_intDecimal));
                    fMinData = fMinG * m_fMMToUnitValue;
                    fMaxData = fMaxG * m_fMMToUnitValue;
                    if (fData < fMinData || fData > fMaxData)
                    {
                        intResultTableFailMask |= 0x08;
                    }
                }
                else
                {
                    arrResultList.Add("---");
                }
            }
            else
            {
                arrResultList.Add("---");
                arrResultList.Add("---");
            }

            if (m_arrSampleBlobLeads[i].fSolderPadLengthMM == -999 || (m_intFailOptionMask & 0x08) == 0)
                arrResultList.Add("---");
            else
            {
                fData = m_arrSampleBlobLeads[i].fSolderPadLengthMM * m_fMMToUnitValue;
                arrResultList.Add(fData.ToString("F" + m_intDecimal));
                fMinData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinSolderPadLength * m_fMMToUnitValue;
                fMaxData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxSolderPadLength * m_fMMToUnitValue;
                if (fData < fMinData || fData > fMaxData)
                {
                    intResultTableFailMask |= 0x10;
                }
            }

            arrResultList.Add(intResultTableFailMask.ToString());

            return arrResultList;
        }

        public List<string> GetBlobFeaturesResult_WithPassFailIndicator_SideLeads(int intMatchTemplateIndex)
        {
            List<string> arrResultList = new List<string>();

            int intResultTableFailMask = 0;
            float fData, fMaxData, fMinData;

            GetLeadArrayIndexFromNoID(intMatchTemplateIndex, ref intMatchTemplateIndex);

            int i = intMatchTemplateIndex;

            if (m_arrSampleBlobLeads == null || i >= m_arrSampleBlobLeads.Length)
            {
                return arrResultList;
            }

            arrResultList.Add(m_arrSampleBlobLeads[i].intNoID.ToString());

            // Stand Off
            if (m_arrSampleBlobLeads[i].fStandOffMM == -999 || (m_intFailOptionMask & 0x01) == 0)
                arrResultList.Add("---");
            else
            {
                fData = m_arrSampleBlobLeads[i].fStandOffMM * m_fMMToUnitValue;
                arrResultList.Add(fData.ToString("F" + m_intDecimal));
                fMinData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinStandOff * m_fMMToUnitValue;
                fMaxData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxStandOff * m_fMMToUnitValue;
                if (fData < fMinData || fData > fMaxData)
                {
                    intResultTableFailMask |= 0x08;
                }
            }

            if (m_arrSampleBlobLeads[i].fCoplanMM == -999 || (m_intFailOptionMask & 0x80) == 0)
                arrResultList.Add("---");
            else
            {
                fData = m_arrSampleBlobLeads[i].fCoplanMM * m_fMMToUnitValue;
                arrResultList.Add(fData.ToString("F" + m_intDecimal));
                fMaxData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxCoplan * m_fMMToUnitValue;
                if (fData > fMaxData)
                {
                    intResultTableFailMask |= 0x20;
                }
            }

            arrResultList.Add(intResultTableFailMask.ToString());

            return arrResultList;
        }

        /// <summary>
        /// Get pitch gap data include min pitch, max pitch, min gap, max gap
        /// </summary>
        /// <param name="intIndex">pitch gap index</param>
        /// <param name="minPitch">min pitch</param>
        /// <param name="maxPitch">max pitch</param>
        /// <param name="minGap">min gap</param>
        /// <param name="maxGap">max gap</param>
        /// <returns>true = min pitch != 0.0, false = min pitch = 0.0</returns>
        private bool GetPitchGapMinMax(int intIndex, ref float minPitch, ref float maxPitch, ref float minGap, ref float maxGap)
        {
            int iFrom, iTo;
            iFrom = iTo = 0;

            for (int i = 0; i < GetTotalPitchGap(); i++)
            {
                GetPitchGapLeadLink(i, ref iFrom, ref iTo);

                if ((intIndex + 1) == iFrom)
                {
                    minPitch = m_arrPitchGap[i].fMinPitch;
                    maxPitch = m_arrPitchGap[i].fMaxPitch;
                    minGap = m_arrPitchGap[i].fMinGap;
                    maxGap = m_arrPitchGap[i].fMaxGap;
                    return true;
                }
            }

            //if (minPitch != 0.0f)
            //    return true;
            //else
            return false;
        }

        public List<List<string>> GetBlobsFeaturesInspectRealData()
        {
            BlobsFeatures stcBlobPad;
            List<List<string>> arrBlobsFeaturesData = new List<List<string>>();
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                arrBlobsFeaturesData.Add(new List<string>());
                stcBlobPad = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                arrBlobsFeaturesData[i].Add("Lead");
                arrBlobsFeaturesData[i].Add((i).ToString());

                arrBlobsFeaturesData[i].Add((stcBlobPad.fOffSet * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((stcBlobPad.fSkew * m_fMMToUnitValue).ToString("F" + m_intDecimal));

                arrBlobsFeaturesData[i].Add((stcBlobPad.fMinTipWidth * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((stcBlobPad.fMaxTipWidth * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((stcBlobPad.fMinTipLength * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((stcBlobPad.fMaxTipLength * m_fMMToUnitValue).ToString("F" + m_intDecimal));

                float fMinP, fMaxP, fMinG, fMaxG;
                fMinP = fMaxP = fMinG = fMaxG = 0.0f;

                if (GetPitchGapMinMax(i, ref fMinP, ref fMaxP, ref fMinG, ref fMaxG))
                {
                    arrBlobsFeaturesData[i].Add((fMinP * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                    arrBlobsFeaturesData[i].Add((fMaxP * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                    arrBlobsFeaturesData[i].Add((fMinG * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                    arrBlobsFeaturesData[i].Add((fMaxG * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                }
                else
                {
                    for (int j = 0; j < 4; j++)
                    {
                        arrBlobsFeaturesData[i].Add((-1).ToString("F" + m_intDecimal));
                    }
                }

                arrBlobsFeaturesData[i].Add((stcBlobPad.fMinStandOff * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((stcBlobPad.fMaxStandOff * m_fMMToUnitValue).ToString("F" + m_intDecimal));

                arrBlobsFeaturesData[i].Add((stcBlobPad.fMinSolderPadLength * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((stcBlobPad.fMaxSolderPadLength * m_fMMToUnitValue).ToString("F" + m_intDecimal));

                arrBlobsFeaturesData[i].Add((stcBlobPad.fMaxCoplan * m_fMMToUnitValue).ToString("F" + m_intDecimal));

                arrBlobsFeaturesData[i].Add((stcBlobPad.fMinAGV).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((stcBlobPad.fMaxAGV).ToString("F" + m_intDecimal));

                arrBlobsFeaturesData[i].Add((stcBlobPad.fLeadLimitMinWidth).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((stcBlobPad.fLeadLimitMaxWidth).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((stcBlobPad.fLeadMaxBurrWidth).ToString("F" + m_intDecimal));

                //arrBlobsFeaturesData[i].Add((stcBlobPad.fWidthOffset).ToString("F" + m_intDecimal));
                //arrBlobsFeaturesData[i].Add((stcBlobPad.fLengthOffset).ToString("F" + m_intDecimal));
                //arrBlobsFeaturesData[i].Add((stcBlobPad.fPitchOffset).ToString("F" + m_intDecimal));
                //arrBlobsFeaturesData[i].Add((stcBlobPad.fGapOffset).ToString("F" + m_intDecimal));
                //arrBlobsFeaturesData[i].Add((stcBlobPad.fStandOffOffset).ToString("F" + m_intDecimal));
                //arrBlobsFeaturesData[i].Add((stcBlobPad.fCoplanOffset).ToString("F" + m_intDecimal));
            }

            return arrBlobsFeaturesData;
        }
        public List<List<string>> GetLeadOffsetSettingValue()
        {
            BlobsFeatures stcBlobPad;
            List<List<string>> arrBlobsFeaturesData = new List<List<string>>();
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                arrBlobsFeaturesData.Add(new List<string>());
                stcBlobPad = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                arrBlobsFeaturesData[i].Add("Lead");
                arrBlobsFeaturesData[i].Add((i).ToString());

                arrBlobsFeaturesData[i].Add((stcBlobPad.fWidthOffset).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((stcBlobPad.fLengthOffset).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((stcBlobPad.fPitchOffset).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((stcBlobPad.fGapOffset).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((stcBlobPad.fStandOffOffset).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((stcBlobPad.fCoplanOffset).ToString("F" + m_intDecimal));
            }

            return arrBlobsFeaturesData;
        }
        public List<List<string>> GetBlobsFeaturesSkewInspectOption()
        {
            BlobsFeatures stcBlobPad;
            List<List<string>> arrBlobsFeaturesData = new List<List<string>>();
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                arrBlobsFeaturesData.Add(new List<string>());
                stcBlobPad = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                arrBlobsFeaturesData[i].Add("Lead");
                arrBlobsFeaturesData[i].Add((i + 1).ToString());

                arrBlobsFeaturesData[i].Add(stcBlobPad.blnCheckSkew.ToString());
               
            }

            return arrBlobsFeaturesData;
        }
        public bool GetWantCheckSkew(int intLeadIndex)
        {
            if (m_arrTemplateBlobLeads.Count <= intLeadIndex)
                return true;
            
            return ((BlobsFeatures)m_arrTemplateBlobLeads[intLeadIndex]).blnCheckSkew;
        }
        public float GetSkewLimit(int intLeadIndex)
        {
            if (m_arrTemplateBlobLeads.Count <= intLeadIndex)
                return 0;

            return ((BlobsFeatures)m_arrTemplateBlobLeads[intLeadIndex]).fSkew;
        }
        /// <summary>
        /// Get all inspection data store in blobs features 
        /// </summary>
        /// <returns>blobs features inspection data in string</returns>
        public string GetBlobsFeaturesInspectRealData_Old()
        {
            string strBlobsFeatures = "";
            float fData;
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fSkew * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fOffSet * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";

                fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinTipWidth * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxTipWidth * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinTipLength * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxTipLength * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";

                float fMinP, fMaxP, fMinG, fMaxG;
                fMinP = fMaxP = fMinG = fMaxG = 0.0f;

                if (GetPitchGapMinMax(i, ref fMinP, ref fMaxP, ref fMinG, ref fMaxG))
                {
                    fData = fMinP * m_fMMToUnitValue;
                    strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";

                    fData = fMaxP * m_fMMToUnitValue;
                    strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";

                    fData = fMinG * m_fMMToUnitValue;
                    strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";

                    fData = fMaxG * m_fMMToUnitValue;
                    strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                }
                else
                {
                    for (int j = 0; j < 4; j++)
                    {
                        fData = -1;
                        strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                    }
                }
                fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinStandOff * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxStandOff * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinSolderPadLength * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxSolderPadLength * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";

                fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxCoplan * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";

                fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinAGV;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxAGV;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
            }
            return strBlobsFeatures;
        }

        public int GetBlobsNoID()
        {
            if (m_arrTemplateBlobLeads.Count > 0)
                return Convert.ToInt32(((BlobsFeatures)m_arrTemplateBlobLeads[0]).intNoID);
            else
                return 0;
        }
        public int GetTemplateLeadDirection(int intLeadIndex)
        {
            if (m_arrTemplateBlobLeads.Count > intLeadIndex)
                return Convert.ToInt32(((BlobsFeatures)m_arrTemplateBlobLeads[intLeadIndex]).intDirection);
            else
                return 0;
        }
        public int GetSampleLeadTipWidth(int intLeadIndex)
        {
            if (m_arrSampleBlobLeads.Length > intLeadIndex)
                return Convert.ToInt32(((SampleBlobsFeatures)m_arrSampleBlobLeads[intLeadIndex]).fTipWidth);
            else
                return 0;
        }
        public int GetSampleLeadTipLength(int intLeadIndex)
        {
            if (m_arrSampleBlobLeads.Length > intLeadIndex)
                return Convert.ToInt32(((SampleBlobsFeatures)m_arrSampleBlobLeads[intLeadIndex]).fTipLength);
            else
                return 0;
        }
        private bool GetPitchGapResult(int intIndex, ref float fPitch, ref float fGap)
        {
            int iFrom, iTo;
            iFrom = iTo = 0;

            for (int i = 0; i < GetTotalPitchGap(); i++)
            {
                GetPitchGapLeadLink(i, ref iFrom, ref iTo);

                if ((intIndex + 1) == iFrom)
                {
                    fPitch = m_arrPitchGap[i].fPitchMM;
                    fGap = m_arrPitchGap[i].fGapMM;
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// Get pitch gap from Lead no and to Lead no
        /// </summary>
        /// <param name="intPitchGapIndex">pitch gap index</param>
        /// <param name="intFromLeadNo">from Lead no</param>
        /// <param name="intToLeadNo">to Lead no</param>
        public void GetPitchGapLeadLink(int intPitchGapIndex, ref int intFromLeadNo, ref int intToLeadNo)
        {
            if (intPitchGapIndex < m_arrPitchGap.Count)
            {
                intFromLeadNo = m_arrPitchGap[intPitchGapIndex].intFromLeadNo + 1;
                intToLeadNo = m_arrPitchGap[intPitchGapIndex].intToLeadNo + 1;
            }
        }

        public void DefineLeadSpanStartEnd(bool blnStart, ROI objROI)
        {
            if (blnStart)
            {
                float fMinStart = 0;
                float fMaxStart = 0;
                for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
                {
                    m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                    if (m_stcBlobLead.intLengthMode == 2)
                    {
                        if (i == 0)
                        {
                            fMinStart = m_stcBlobLead.fTipCenterX - m_stcBlobLead.fTipWidth / 2;
                            fMaxStart = m_stcBlobLead.fTipCenterX - m_stcBlobLead.fTipWidth / 2;
                        }
                        else
                        {
                            if (m_stcBlobLead.fTipCenterX - m_stcBlobLead.fTipWidth / 2 > fMinStart)
                                fMinStart = m_stcBlobLead.fTipCenterX - m_stcBlobLead.fTipWidth / 2;

                            if (m_stcBlobLead.fTipCenterX - m_stcBlobLead.fTipWidth / 2 < fMaxStart)
                                fMaxStart = m_stcBlobLead.fTipCenterX - m_stcBlobLead.fTipWidth / 2;
                        }
                    }
                    else
                    {
                        if (i == 0)
                        {
                            fMinStart = m_stcBlobLead.fTipCenterY - m_stcBlobLead.fTipLength / 2;
                            fMaxStart = m_stcBlobLead.fTipCenterY - m_stcBlobLead.fTipLength / 2;
                        }
                        else
                        {
                            if (m_stcBlobLead.fTipCenterY - m_stcBlobLead.fTipLength / 2 > fMinStart)
                                fMinStart = m_stcBlobLead.fTipCenterY - m_stcBlobLead.fTipLength / 2;

                            if (m_stcBlobLead.fTipCenterY - m_stcBlobLead.fTipLength / 2 < fMaxStart)
                                fMaxStart = m_stcBlobLead.fTipCenterY - m_stcBlobLead.fTipLength / 2;
                        }
                    }
                }

                if (m_stcBlobLead.intLengthMode == 2)
                {
                    m_fLeadMinSpanStart = fMinStart + objROI.ref_ROITotalX;
                    m_fLeadMaxSpanStart = fMaxStart + objROI.ref_ROITotalX;
                }
                else
                {
                    m_fLeadMinSpanStart = fMinStart + objROI.ref_ROITotalY;
                    m_fLeadMaxSpanStart = fMaxStart + objROI.ref_ROITotalY;
                }
            }
            else
            {
                float fMinEnd = 0;
                float fMaxEnd = 0;
                for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
                {
                    m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                    if (m_stcBlobLead.intLengthMode == 2)
                    {
                        if (i == 0)
                        {
                            fMinEnd = m_stcBlobLead.fTipCenterX + m_stcBlobLead.fTipWidth / 2;
                            fMaxEnd = m_stcBlobLead.fTipCenterX + m_stcBlobLead.fTipWidth / 2;
                        }
                        else
                        {
                            if (m_stcBlobLead.fTipCenterX + m_stcBlobLead.fTipWidth / 2 < fMinEnd)
                                fMinEnd = m_stcBlobLead.fTipCenterX + m_stcBlobLead.fTipWidth / 2;

                            if (m_stcBlobLead.fTipCenterX + m_stcBlobLead.fTipWidth / 2 > fMaxEnd)
                                fMaxEnd = m_stcBlobLead.fTipCenterX + m_stcBlobLead.fTipWidth / 2;
                        }
                    }
                    else
                    {
                        if (i == 0)
                        {
                            fMinEnd = m_stcBlobLead.fTipCenterY + m_stcBlobLead.fTipLength / 2;
                            fMaxEnd = m_stcBlobLead.fTipCenterY + m_stcBlobLead.fTipLength / 2;
                        }
                        else
                        {
                            if (m_stcBlobLead.fTipCenterY + m_stcBlobLead.fTipLength / 2 < fMinEnd)
                                fMinEnd = m_stcBlobLead.fTipCenterY + m_stcBlobLead.fTipLength / 2;

                            if (m_stcBlobLead.fTipCenterY + m_stcBlobLead.fTipLength / 2 > fMaxEnd)
                                fMaxEnd = m_stcBlobLead.fTipCenterY + m_stcBlobLead.fTipLength / 2;
                        }
                    }
                }

                if (m_stcBlobLead.intLengthMode == 2)
                {
                    m_fLeadMinSpanEnd = fMinEnd + objROI.ref_ROITotalX;
                    m_fLeadMaxSpanEnd = fMaxEnd + objROI.ref_ROITotalX;
                }
                else
                {
                    m_fLeadMinSpanEnd = fMinEnd + objROI.ref_ROITotalY;
                    m_fLeadMaxSpanEnd = fMaxEnd + objROI.ref_ROITotalY;
                }

            }
        }

        /// <summary>
        /// Add pitch gap into m_arrPitchGap
        /// </summary>
        /// <param name="intFromLeadNo">from lead no</param>
        /// <param name="intToLeadNo">to lead no</param>
        /// <param name="fMinPitch">min pitch</param>
        /// <param name="fMaxPitch">max pitch</param>
        /// <param name="fMinGap">min gap</param>
        /// <param name="fMaxGap">max gap</param>
        /// <param name="fPitch">pitch</param>
        /// <param name="fGap">gap</param>
        /// <param name="intStartX">start X position</param>
        /// <param name="intStartY">start Y position</param>
        /// <param name="intEndX">end X position</param>
        /// <param name="intEndY">end Y position</param>
        /// <param name="intDirection">direction</param>
        public void SetPitchGapData(int intFromLeadNo, int intToLeadNo, float fMinPitch, float fMaxPitch, float fMinGap, float fMaxGap,
            float fPitch, float fGap,
            int intStartX, int intStartY, int intEndX, int intEndY, int intDirection)
        {
            m_stcPitchGap.intFromLeadNo = intFromLeadNo;
            m_stcPitchGap.intToLeadNo = intToLeadNo;
            m_stcPitchGap.fMinPitch = fMinPitch;
            m_stcPitchGap.fMaxPitch = fMaxPitch;
            m_stcPitchGap.fMinGap = fMinGap;
            m_stcPitchGap.fMaxGap = fMaxGap;
            m_stcPitchGap.fPitch = fPitch;
            m_stcPitchGap.fGap = fGap;
            m_stcPitchGap.intStartPointX = intStartX;
            m_stcPitchGap.intStartPointY = intStartY;
            m_stcPitchGap.intEndPointX = intEndX;
            m_stcPitchGap.intEndPointY = intEndY;
            m_stcPitchGap.intDirection = intDirection;

            m_arrPitchGap.Add(m_stcPitchGap);
        }

        public string GetMicronBlobsFeaturesData()
        {
            string strBlobsFeatures = "";
            float fData;
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fSkew * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fOffSet * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";

                if (((BlobsFeatures)m_arrTemplateBlobLeads[i]).intLengthMode == 1)
                {
                    //fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinWidth * m_fMMToUnitValue;
                    //strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                    //fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxWidth * m_fMMToUnitValue;
                    //strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                    //fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinHeight * m_fMMToUnitValue;
                    //strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                    //fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxHeight * m_fMMToUnitValue;
                    //strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";

                    fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinTipWidth * m_fMMToUnitValue;
                    strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                    fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxTipWidth * m_fMMToUnitValue;
                    strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                    fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinTipLength * m_fMMToUnitValue;
                    strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                    fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxTipLength * m_fMMToUnitValue;
                    strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                }
                else
                {
                    //fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinHeight * m_fMMToUnitValue;
                    //strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                    //fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxHeight * m_fMMToUnitValue;
                    //strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                    //fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinWidth * m_fMMToUnitValue;
                    //strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                    //fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxWidth * m_fMMToUnitValue;
                    //strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";

                    fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinTipLength * m_fMMToUnitValue;
                    strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                    fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxTipLength * m_fMMToUnitValue;
                    strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                    fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinTipWidth * m_fMMToUnitValue;
                    strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                    fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxTipWidth * m_fMMToUnitValue;
                    strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";

                }
            }
            return strBlobsFeatures;
        }

        public string GetMicronPitchGapData(int intPitchGapIndex)
        {
            string strPitchGapData = "";

            PitchGap stcPitchGap = m_arrPitchGap[intPitchGapIndex];

            strPitchGapData += stcPitchGap.intFromLeadNo.ToString() + "#";
            strPitchGapData += stcPitchGap.intToLeadNo.ToString() + "#";
            strPitchGapData += (stcPitchGap.fMinPitch).ToString() + "#";
            strPitchGapData += (stcPitchGap.fMaxPitch).ToString() + "#";
            strPitchGapData += (stcPitchGap.fMinGap).ToString() + "#";
            strPitchGapData += (stcPitchGap.fMaxGap).ToString() + "#";
            strPitchGapData += stcPitchGap.fPitch.ToString() + "#";
            strPitchGapData += stcPitchGap.fGap.ToString() + "#";
            strPitchGapData += stcPitchGap.intStartPointX.ToString() + "#";
            strPitchGapData += stcPitchGap.intStartPointY.ToString() + "#";
            strPitchGapData += stcPitchGap.intEndPointX.ToString() + "#";
            strPitchGapData += stcPitchGap.intEndPointY.ToString() + "#";
            strPitchGapData += stcPitchGap.intDirection.ToString() + "#";

            return strPitchGapData;
        }

        /// <summary>
        /// Build lead range, lead distance and define side lead
        /// </summary>
        /// <param name="objROI"></param>
        public void BuildLeadsParameter(int intLeadPosition, ROI objROI)
        {
            DefineLeadBaseTipWidth(intLeadPosition, objROI);
            BuildLeadRange(objROI);
            BuildLeadDistance(objROI);
            BuildLeadReferencePoint(intLeadPosition, objROI);
            //DefineSideLead(15);
        }

        public void BuildLeadsParameter_CenterLead3D(ROI objROI)
        {
            if (m_blnWantUsePkgToBaseTolerance)
                DefineLeadBaseTipWidth_Lead3D_PkgToBaseTolerance(objROI);
            else
                DefineLeadBaseTipWidth_Lead3D_PointGauge(objROI);
            BuildLeadSweepReference(objROI);
            BuildLeadRange(objROI);
            BuildLeadDistance(objROI);
            BuildLeadReferencePoint_Lead3D(objROI);
            //DefineSideLead(15);
        }

        public void BuildLeadsParameter_SideLead3D(ROI objROI)
        {
            DefineLeadTipWidth_SideLead3D(objROI);
            BuildLeadRange(objROI);
            BuildLeadDistance(objROI);
            BuildLeadReferencePoint_Lead3D(objROI);
            //DefineSideLead(15);
        }

        /// <summary>
        /// Build object in ROI
        /// </summary>
        /// <param name="objROI">ROI</param>
        /// <returns>true = selected objects > 0, false = otherwise</returns>
        public bool BuildOnlyLeadObjects(ROI objROI)
        {
            //#if (DEBUG)
            //            objROI.SaveImage("D:\\TS\\objROI.bmp");
            //#endif

            // Define actual threshold value
            m_intThresholdValuePrev = m_intThresholdValue;
            if (m_intThresholdValue == -4)
                m_intThresholdValue = GetAutoThresholdValue(objROI, 3);

            m_objEBlobs.BuildObjects_Filter_GetElement(objROI, !m_blnWhiteOnBlack, true, 0, m_intThresholdValue,
                m_intFilterMinArea, m_intMaxArea, false, 0x1F);

            m_intThresholdValue = m_intThresholdValuePrev;
            if (m_objEBlobs.ref_intNumSelectedObject > 0)
                return true;
            else
                return false;
        }

        public bool BuildOnlySideLeadObjects_BlackObject(ROI objROI)
        {

            m_objEBlobs.BuildObjects_Filter_GetElement(objROI, !m_blnWhiteOnBlack, true, 0, m_intThresholdValue,
                m_intFilterMinArea, m_intMaxArea, false, 0x1F);

            bool blnDebugImage = false;
            if (blnDebugImage)
            {
                objROI.SaveImage("D:\\TS\\objSampleBlobROI.bmp");// debug
            }

            if (m_objEBlobs.ref_intNumSelectedObject > 0)
                return true;
            else
                return false;
        }
        public bool BuildOnlySideLeadObjects_BlackObject(ROI objROI, int intMinArea)
        {

            m_objEBlobs.BuildObjects_Filter_GetElement(objROI, !m_blnWhiteOnBlack, true, 0, m_intThresholdValue,
                intMinArea, m_intMaxArea, false, 0x1F);

            bool blnDebugImage = false;
            if (blnDebugImage)
            {
                objROI.SaveImage("D:\\TS\\objSampleBlobROI.bmp");// debug
            }

            if (m_objEBlobs.ref_intNumSelectedObject > 0)
                return true;
            else
                return false;
        }
        /// <summary>
        /// Build Lead pitch gap link
        /// </summary>
        /// <param name="blnUpdateTolerance">true = use default pitch gap tolerance, false = use previous pitch gap tolerance</param>
        //public void BuildLeadPitchLink(bool blnUpdateTolerance)
        //{
        //    int intCheckCount = m_arrTemplateBlobLeads.Count - 1;
        //    BlobsFeatures stcFirstBlobsFeatures;
        //    BlobsFeatures stcSecondBlobsFeatures;

        //    bool blnFound;
        //    int intDrawPoint;
        //    int intPitchCount = 0;
        //    bool blnUpDownFound;
        //    bool blnLeftRightFound;
        //    m_arrPitchGap.Clear();
        //    for (int i = 0; i < intCheckCount; i++)
        //    {
        //        m_stcPitchGap = new PitchGap();
        //        m_stcPitchGap.intFromLeadNo = i;
        //        m_stcPitchGap.intToLeadNo = i + 1;
        //        blnFound = false;
        //        blnUpDownFound = false;
        //        blnLeftRightFound = false;
        //        stcFirstBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobLeads[i];
        //        stcSecondBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobLeads[i + 1];

        //        // Check pitch available between up and down Leads
        //        if ((stcFirstBlobsFeatures.intStartX >= stcSecondBlobsFeatures.intStartX) && (stcFirstBlobsFeatures.intStartX <= stcSecondBlobsFeatures.intEndX) ||
        //            (stcFirstBlobsFeatures.intEndX >= stcSecondBlobsFeatures.intStartX) && (stcFirstBlobsFeatures.intEndX <= stcSecondBlobsFeatures.intEndX) ||
        //            (stcSecondBlobsFeatures.intStartX >= stcFirstBlobsFeatures.intStartX) && (stcSecondBlobsFeatures.intEndX <= stcFirstBlobsFeatures.intEndX) ||
        //            (stcSecondBlobsFeatures.intEndX >= stcFirstBlobsFeatures.intStartX) && (stcSecondBlobsFeatures.intEndX <= stcFirstBlobsFeatures.intEndX))
        //        {
        //            blnUpDownFound = true;
        //        }

        //        // Check pitch available between left and right Leads
        //        if ((stcFirstBlobsFeatures.intStartY >= stcSecondBlobsFeatures.intStartY) && (stcFirstBlobsFeatures.intStartY <= stcSecondBlobsFeatures.intEndY) ||
        //            (stcFirstBlobsFeatures.intEndY >= stcSecondBlobsFeatures.intStartY) && (stcFirstBlobsFeatures.intEndY <= stcSecondBlobsFeatures.intEndY) ||
        //            (stcSecondBlobsFeatures.intStartY >= stcFirstBlobsFeatures.intStartY) && (stcSecondBlobsFeatures.intEndY <= stcFirstBlobsFeatures.intEndY) ||
        //            (stcSecondBlobsFeatures.intEndY >= stcFirstBlobsFeatures.intStartY) && (stcSecondBlobsFeatures.intEndY <= stcFirstBlobsFeatures.intEndY))
        //        {
        //            blnLeftRightFound = true;
        //        }


        //        if ((blnLeftRightFound && !blnUpDownFound) || (!blnLeftRightFound && blnUpDownFound))
        //        {
        //            if (blnUpDownFound)
        //            {
        //                // Pitch only available if distance gap between Leads > 1 pixel
        //                if ((stcSecondBlobsFeatures.intStartY - stcFirstBlobsFeatures.intEndY) > 1)
        //                {
        //                    intDrawPoint = GetDrawPoint(stcFirstBlobsFeatures.intStartX, stcFirstBlobsFeatures.intEndX, stcSecondBlobsFeatures.intStartX, stcSecondBlobsFeatures.intEndX);
        //                    m_stcPitchGap.intStartPointX = intDrawPoint;
        //                    m_stcPitchGap.intEndPointX = intDrawPoint;
        //                    m_stcPitchGap.intStartPointY = stcFirstBlobsFeatures.intEndY;
        //                    m_stcPitchGap.intEndPointY = stcSecondBlobsFeatures.intStartY;
        //                    //m_stcPitchGap.fGap = stcSecondBlobsFeatures.intStartY - stcFirstBlobsFeatures.intEndY;
        //                    m_stcPitchGap.fPitch = stcSecondBlobsFeatures.fLimitCenterY - stcFirstBlobsFeatures.fLimitCenterY;
        //                    m_stcPitchGap.intDirection = 180;
        //                    if (blnUpdateTolerance)
        //                        DefinePitchGapTolerance();
        //                    else
        //                        UpdatePreviousPitchToleranceToTemplate(intPitchCount);
        //                    blnFound = true;
        //                }
        //                else if ((stcFirstBlobsFeatures.intStartY - stcSecondBlobsFeatures.intEndY) > 1)
        //                {
        //                    intDrawPoint = GetDrawPoint(stcFirstBlobsFeatures.intStartX, stcFirstBlobsFeatures.intEndX, stcSecondBlobsFeatures.intStartX, stcSecondBlobsFeatures.intEndX);
        //                    m_stcPitchGap.intStartPointX = intDrawPoint;
        //                    m_stcPitchGap.intEndPointX = intDrawPoint;
        //                    m_stcPitchGap.intStartPointY = stcFirstBlobsFeatures.intStartY;
        //                    m_stcPitchGap.intEndPointY = stcSecondBlobsFeatures.intEndY;
        //                    //m_stcPitchGap.fGap = stcFirstBlobsFeatures.intStartY - stcSecondBlobsFeatures.intEndY;
        //                    m_stcPitchGap.fPitch = stcFirstBlobsFeatures.fLimitCenterY - stcSecondBlobsFeatures.fLimitCenterY;
        //                    m_stcPitchGap.intDirection = 0;
        //                    if (blnUpdateTolerance)
        //                        DefinePitchGapTolerance();
        //                    else
        //                        UpdatePreviousPitchToleranceToTemplate(intPitchCount);
        //                    blnFound = true;
        //                }
        //            }
        //            else
        //            {
        //                // Pitch only available if distance gap between Leads > 1 pixel
        //                if ((stcSecondBlobsFeatures.intStartX - stcFirstBlobsFeatures.intEndX) > 1)
        //                {
        //                    intDrawPoint = GetDrawPoint(stcFirstBlobsFeatures.intStartY, stcFirstBlobsFeatures.intEndY, stcSecondBlobsFeatures.intStartY, stcSecondBlobsFeatures.intEndY);
        //                    m_stcPitchGap.intStartPointX = stcFirstBlobsFeatures.intEndX;
        //                    m_stcPitchGap.intEndPointX = stcSecondBlobsFeatures.intStartX;
        //                    m_stcPitchGap.intStartPointY = intDrawPoint;
        //                    m_stcPitchGap.intEndPointY = intDrawPoint;
        //                    //m_stcPitchGap.fGap = stcSecondBlobsFeatures.intStartX - stcFirstBlobsFeatures.intEndX;
        //                    m_stcPitchGap.fPitch = stcSecondBlobsFeatures.fLimitCenterX - stcFirstBlobsFeatures.fLimitCenterX;
        //                    m_stcPitchGap.intDirection = 90;
        //                    if (blnUpdateTolerance)
        //                        DefinePitchGapTolerance();
        //                    else
        //                        UpdatePreviousPitchToleranceToTemplate(intPitchCount);
        //                    blnFound = true;
        //                }
        //                else if ((stcFirstBlobsFeatures.intStartX - stcSecondBlobsFeatures.intEndX) > 1)
        //                {
        //                    intDrawPoint = GetDrawPoint(stcFirstBlobsFeatures.intStartY, stcFirstBlobsFeatures.intEndY, stcSecondBlobsFeatures.intStartY, stcSecondBlobsFeatures.intEndY);
        //                    m_stcPitchGap.intStartPointX = stcFirstBlobsFeatures.intStartX;
        //                    m_stcPitchGap.intEndPointX = stcSecondBlobsFeatures.intEndX;
        //                    m_stcPitchGap.intStartPointY = intDrawPoint;
        //                    m_stcPitchGap.intEndPointY = intDrawPoint;
        //                    //m_stcPitchGap.fGap = stcFirstBlobsFeatures.intStartX - stcSecondBlobsFeatures.intEndX;
        //                    m_stcPitchGap.fPitch = stcFirstBlobsFeatures.fLimitCenterX - stcSecondBlobsFeatures.fLimitCenterX;
        //                    m_stcPitchGap.intDirection = 270;
        //                    if (blnUpdateTolerance)
        //                        DefinePitchGapTolerance();
        //                    else
        //                        UpdatePreviousPitchToleranceToTemplate(intPitchCount);
        //                    blnFound = true;
        //                }
        //            }
        //        }

        //        //// Define Top Gap and Pitch
        //        //if (((stcFirstBlobsFeatures.intDirection == 0x05) && (stcSecondBlobsFeatures.intDirection == 0x04)) ||
        //        //    ((stcFirstBlobsFeatures.intDirection == 0x04) && (stcSecondBlobsFeatures.intDirection == 0x04)) ||
        //        //    ((stcFirstBlobsFeatures.intDirection == 0x04) && (stcSecondBlobsFeatures.intDirection == 0x06)) ||
        //        //    ((stcFirstBlobsFeatures.intDirection == 0x0D) && (stcSecondBlobsFeatures.intDirection == 0x0C)) ||
        //        //    ((stcFirstBlobsFeatures.intDirection == 0x0C) && (stcSecondBlobsFeatures.intDirection == 0x0C)) ||
        //        //    ((stcFirstBlobsFeatures.intDirection == 0x0C) && (stcSecondBlobsFeatures.intDirection == 0x0E)))
        //        //{
        //        //    if (stcSecondBlobsFeatures.fStartX > stcFirstBlobsFeatures.fEndX)
        //        //    {
        //        //        intDrawPoint = GetDrawPoint(stcFirstBlobsFeatures.intStartY, stcFirstBlobsFeatures.intEndY, stcSecondBlobsFeatures.intStartY, stcSecondBlobsFeatures.intEndY);
        //        //        m_stcPitchGap.intStartPointX = stcSecondBlobsFeatures.intStartX;
        //        //        m_stcPitchGap.intEndPointX = stcFirstBlobsFeatures.intEndX;
        //        //        m_stcPitchGap.intStartPointY = intDrawPoint;
        //        //        m_stcPitchGap.intEndPointY = intDrawPoint;
        //        //        //m_stcPitchGap.fGap = stcSecondBlobsFeatures.fStartX - stcFirstBlobsFeatures.fEndX;
        //        //        m_stcPitchGap.fPitch = stcSecondBlobsFeatures.fLimitCenterX - stcFirstBlobsFeatures.fLimitCenterX;
        //        //        m_stcPitchGap.intDirection = 90;
        //        //        if (blnUpdateTolerance)
        //        //            DefinePitchGapTolerance();
        //        //        else
        //        //            UpdatePreviousPitchToleranceToTemplate(intPitchCount);
        //        //        blnFound = true;
        //        //    }
        //        //}
        //        //// Define Right Gap and Pitch
        //        //else if (((stcFirstBlobsFeatures.intDirection == 0x06) && (stcSecondBlobsFeatures.intDirection == 0x02)) ||
        //        //    ((stcFirstBlobsFeatures.intDirection == 0x02) && (stcSecondBlobsFeatures.intDirection == 0x02)) ||
        //        //    ((stcFirstBlobsFeatures.intDirection == 0x02) && (stcSecondBlobsFeatures.intDirection == 0x0A)) ||
        //        //    ((stcFirstBlobsFeatures.intDirection == 0x07) && (stcSecondBlobsFeatures.intDirection == 0x03)) ||
        //        //    ((stcFirstBlobsFeatures.intDirection == 0x03) && (stcSecondBlobsFeatures.intDirection == 0x03)) ||
        //        //    ((stcFirstBlobsFeatures.intDirection == 0x03) && (stcSecondBlobsFeatures.intDirection == 0x0B)))
        //        //{
        //        //    if (stcSecondBlobsFeatures.fStartY > stcFirstBlobsFeatures.fEndY)
        //        //    {
        //        //        intDrawPoint = GetDrawPoint(stcFirstBlobsFeatures.intStartX, stcFirstBlobsFeatures.intEndX, stcSecondBlobsFeatures.intStartX, stcSecondBlobsFeatures.intEndX);
        //        //        m_stcPitchGap.intStartPointY = stcSecondBlobsFeatures.intStartY;
        //        //        m_stcPitchGap.intEndPointY = stcFirstBlobsFeatures.intEndY;
        //        //        m_stcPitchGap.intStartPointX = intDrawPoint;
        //        //        m_stcPitchGap.intEndPointX = intDrawPoint;
        //        //        //m_stcPitchGap.fGap = stcSecondBlobsFeatures.fStartY - stcFirstBlobsFeatures.fEndY;
        //        //        m_stcPitchGap.fPitch = stcSecondBlobsFeatures.fLimitCenterY - stcFirstBlobsFeatures.fLimitCenterY;
        //        //        m_stcPitchGap.intDirection = 180;
        //        //        if (blnUpdateTolerance)
        //        //            DefinePitchGapTolerance();
        //        //        else
        //        //            UpdatePreviousPitchToleranceToTemplate(intPitchCount);
        //        //        blnFound = true;
        //        //    }
        //        //}
        //        //// Define Bottom Gap and Pitch
        //        //else if (((stcFirstBlobsFeatures.intDirection == 0x0A) && (stcSecondBlobsFeatures.intDirection == 0x08)) ||
        //        //    ((stcFirstBlobsFeatures.intDirection == 0x08) && (stcSecondBlobsFeatures.intDirection == 0x08)) ||
        //        //    ((stcFirstBlobsFeatures.intDirection == 0x08) && (stcSecondBlobsFeatures.intDirection == 0x09)))
        //        //{
        //        //    if (stcFirstBlobsFeatures.fStartX > stcSecondBlobsFeatures.fEndX)
        //        //    {
        //        //        intDrawPoint = GetDrawPoint(stcFirstBlobsFeatures.intStartY, stcFirstBlobsFeatures.intEndY, stcSecondBlobsFeatures.intStartY, stcSecondBlobsFeatures.intEndY);
        //        //        m_stcPitchGap.intStartPointX = stcSecondBlobsFeatures.intEndX;
        //        //        m_stcPitchGap.intEndPointX = stcFirstBlobsFeatures.intStartX;
        //        //        m_stcPitchGap.intStartPointY = intDrawPoint;
        //        //        m_stcPitchGap.intEndPointY = intDrawPoint;
        //        //        //m_stcPitchGap.fGap = stcFirstBlobsFeatures.fStartX - stcSecondBlobsFeatures.fEndX;
        //        //        m_stcPitchGap.fPitch = stcFirstBlobsFeatures.fLimitCenterX - stcSecondBlobsFeatures.fLimitCenterX;
        //        //        m_stcPitchGap.intDirection = 270;
        //        //        if (blnUpdateTolerance)
        //        //            DefinePitchGapTolerance();
        //        //        else
        //        //            UpdatePreviousPitchToleranceToTemplate(intPitchCount);
        //        //        blnFound = true;
        //        //    }
        //        //}
        //        //// Define Left Gap and Pitch
        //        //else if (((stcFirstBlobsFeatures.intDirection == 0x09) && (stcSecondBlobsFeatures.intDirection == 0x01)) ||
        //        //    ((stcFirstBlobsFeatures.intDirection == 0x01) && (stcSecondBlobsFeatures.intDirection == 0x01)) ||
        //        //    ((stcFirstBlobsFeatures.intDirection == 0x01) && (stcSecondBlobsFeatures.intDirection == 0x05)))
        //        //{
        //        //    if (stcFirstBlobsFeatures.fStartY > stcSecondBlobsFeatures.fEndY)
        //        //    {
        //        //        intDrawPoint = GetDrawPoint(stcFirstBlobsFeatures.intStartX, stcFirstBlobsFeatures.intEndX, stcSecondBlobsFeatures.intStartX, stcSecondBlobsFeatures.intEndX);
        //        //        m_stcPitchGap.intStartPointY = stcSecondBlobsFeatures.intEndY;
        //        //        m_stcPitchGap.intEndPointY = stcFirstBlobsFeatures.intStartY;
        //        //        m_stcPitchGap.intStartPointX = intDrawPoint;
        //        //        m_stcPitchGap.intEndPointX = intDrawPoint;
        //        //        //m_stcPitchGap.fGap = stcFirstBlobsFeatures.fStartY - stcSecondBlobsFeatures.fEndY;
        //        //        m_stcPitchGap.fPitch = stcFirstBlobsFeatures.fLimitCenterY - stcSecondBlobsFeatures.fLimitCenterY;
        //        //        m_stcPitchGap.intDirection = 0;
        //        //        if (blnUpdateTolerance)
        //        //            DefinePitchGapTolerance();
        //        //        else
        //        //            UpdatePreviousPitchToleranceToTemplate(intPitchCount);
        //        //        blnFound = true;
        //        //    }
        //        //}

        //        if (blnFound)
        //        {
        //            intPitchCount++;
        //            m_arrPitchGap.Add(m_stcPitchGap);
        //        }

        //    }
        //}

        /// <summary>
        /// Analyzing lead
        /// </summary>
        /// <param name="intLeadPosition">lead position</param>
        public void AnalyingLead_ClosestSizeMethod(int intLeadPosition)
        {
            // Reset blob pitch, gab and direction information
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                m_stcBlobLead.intDirection = -1;
                m_stcBlobLead.intGroupID = intLeadPosition;
                m_stcBlobLead.fPitch = -1;
                m_stcBlobLead.fGap = -1;
                m_stcBlobLead.intNoID = 0;
                m_arrTemplateBlobLeads.RemoveAt(i);
                m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
            }

            ClassifyObjectLengthMode(intLeadPosition);
            ClassifyObjectsToDirectionGroup(intLeadPosition);
            SortObjectNumber(intLeadPosition);
            RearrangeBlobs();

            //m_arrPitchGap.Clear();
        }

        public void AnalyingLead_DefaultToleranceMethod(int intLeadPosition)
        {
            // Reset blob pitch, gab and direction information
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                m_stcBlobLead.intDirection = -1;
                m_stcBlobLead.intGroupID = intLeadPosition;
                m_stcBlobLead.fPitch = -1;
                m_stcBlobLead.fGap = -1;
                m_stcBlobLead.intNoID = 0;
                m_arrTemplateBlobLeads.RemoveAt(i);
                m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
            }

            ClassifyObjectLengthMode(intLeadPosition);
            ClassifyObjectsToDirectionGroup(intLeadPosition);
            SortObjectNumber_Lead3D();
            RearrangeBlobs();

            m_arrPitchGap.Clear();
        }

        public void AnalyingLead_DefaultToleranceMethod(int intLeadPosition, bool blnClockWise, ref int intLeadNo)
        {
            // Reset blob pitch, gab and direction information
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                m_stcBlobLead.intDirection = -1;
                m_stcBlobLead.intGroupID = intLeadPosition;
                m_stcBlobLead.fPitch = -1;
                m_stcBlobLead.fGap = -1;
                m_stcBlobLead.intNoID = 0;
                m_arrTemplateBlobLeads.RemoveAt(i);
                m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
            }

            ClassifyObjectLengthMode(intLeadPosition);
            ClassifyObjectsToDirectionGroup(intLeadPosition);
            SortObjectNumber(intLeadPosition, blnClockWise, ref intLeadNo);
            RearrangeBlobs(intLeadNo);

            m_arrPitchGap.Clear();
        }

        /// <summary>
        /// Check the direction of the Lead (left column, right column, high row, low row)
        /// </summary>
        /// <param name="intLeadPosition">Lead position</param>
        private void ClassifyObjectLengthMode(int intLeadPosition)
        {
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                if (!m_stcBlobLead.blnSelected)
                    continue;

                if (intLeadPosition == 1 || intLeadPosition == 3)
                {
                    m_stcBlobLead.intLengthMode = 1;   // 1 mean length == height
                }
                else if (intLeadPosition == 2 || intLeadPosition == 4)
                {
                    m_stcBlobLead.intLengthMode = 2;   // 2 mean length == width
                }

                m_arrTemplateBlobLeads.RemoveAt(i);
                m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
            }
        }

        /// <summary>
        /// Check the direction of the Lead (left column, right column, high row, low row)
        /// </summary>
        /// <param name="intLeadPosition">Lead position</param>
        private void ClassifyObjectsToDirectionGroup(int intLeadPosition)
        {
            BlobsFeatures stcBlobsFeatures = new BlobsFeatures();
            int intDirectionMask;

            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                if (!m_stcBlobLead.blnSelected)
                    continue;

                intDirectionMask = 0x0F;

                for (int j = 0; j < m_arrTemplateBlobLeads.Count; j++)
                {
                    if (i == j)
                        continue;

                    stcBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobLeads[j];

                    if (!stcBlobsFeatures.blnSelected)
                        continue;

                    if (intLeadPosition != 2 && intLeadPosition != 4)
                    {
                        // Check is left column
                        if ((m_stcBlobLead.intStartX + (int)m_fDefineSizePixel) > (stcBlobsFeatures.intEndX - (int)m_fDefineSizePixel))
                        {
                            intDirectionMask &= ~0x01;
                        }

                        // Check is right column
                        if ((m_stcBlobLead.intEndX - (int)m_fDefineSizePixel) < (stcBlobsFeatures.intStartX + (int)m_fDefineSizePixel))
                        {
                            intDirectionMask &= ~0x02;
                        }
                    }

                    if (intLeadPosition != 1 && intLeadPosition != 3)
                    {
                        // Check is high row
                        if ((m_stcBlobLead.intStartY + (int)m_fDefineSizePixel) > (stcBlobsFeatures.intEndY - (int)m_fDefineSizePixel))
                        {
                            intDirectionMask &= ~0x04;
                        }

                        // Check is low row
                        if ((m_stcBlobLead.intEndY - (int)m_fDefineSizePixel) < (stcBlobsFeatures.intStartY + (int)m_fDefineSizePixel))
                        {
                            intDirectionMask &= ~0x08;
                        }
                    }
                }
                m_stcBlobLead.intDirection = intDirectionMask;
                m_arrTemplateBlobLeads.RemoveAt(i);
                m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
            }
        }

        /// <summary>
        /// Back up all data of blobs features into m_arrTemporaryBlobLeads
        /// </summary>
        public void BackupBlobsFeatures()
        {
            BlobsFeatures stcTemporaryBlobLead;
            m_arrTemporaryBlobLeads = new ArrayList();
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                stcTemporaryBlobLead = new BlobsFeatures();
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                stcTemporaryBlobLead.fArea = m_stcBlobLead.fArea;
                stcTemporaryBlobLead.fCenterX = m_stcBlobLead.fCenterX;
                stcTemporaryBlobLead.fCenterY = m_stcBlobLead.fCenterY;
                stcTemporaryBlobLead.fLimitCenterX = m_stcBlobLead.fLimitCenterX;
                stcTemporaryBlobLead.fLimitCenterY = m_stcBlobLead.fLimitCenterY;
                stcTemporaryBlobLead.fWidth = m_stcBlobLead.fWidth;
                stcTemporaryBlobLead.fHeight = m_stcBlobLead.fHeight;
                stcTemporaryBlobLead.intLengthMode = m_stcBlobLead.intLengthMode;
                stcTemporaryBlobLead.intContourX = m_stcBlobLead.intContourX;
                stcTemporaryBlobLead.intContourY = m_stcBlobLead.intContourY;
                stcTemporaryBlobLead.arrContourX = m_stcBlobLead.arrContourX;
                stcTemporaryBlobLead.arrContourY = m_stcBlobLead.arrContourY;
                stcTemporaryBlobLead.intObjNo = m_stcBlobLead.intObjNo;
                stcTemporaryBlobLead.fStartX = m_stcBlobLead.fStartX;
                stcTemporaryBlobLead.fEndX = m_stcBlobLead.fEndX;
                stcTemporaryBlobLead.fStartY = m_stcBlobLead.fStartY;
                stcTemporaryBlobLead.fEndY = m_stcBlobLead.fEndY;
                stcTemporaryBlobLead.intStartX = m_stcBlobLead.intStartX;
                stcTemporaryBlobLead.intEndX = m_stcBlobLead.intEndX;
                stcTemporaryBlobLead.intStartY = m_stcBlobLead.intStartY;
                stcTemporaryBlobLead.intEndY = m_stcBlobLead.intEndY;
                stcTemporaryBlobLead.blnSelected = m_stcBlobLead.blnSelected;
                stcTemporaryBlobLead.blnCheckSkew = m_stcBlobLead.blnCheckSkew;
                stcTemporaryBlobLead.intDirection = m_stcBlobLead.intDirection;
                stcTemporaryBlobLead.intGroupID = m_stcBlobLead.intGroupID;
                stcTemporaryBlobLead.fPitch = m_stcBlobLead.fPitch;
                stcTemporaryBlobLead.fGap = m_stcBlobLead.fGap;
                stcTemporaryBlobLead.intNoID = m_stcBlobLead.intNoID;
                stcTemporaryBlobLead.intSelectedBlob = m_stcBlobLead.intSelectedBlob;
                stcTemporaryBlobLead.arrSelectedBlob = m_stcBlobLead.arrSelectedBlob;

                stcTemporaryBlobLead.intAGVROITolerance_Top = m_stcBlobLead.intAGVROITolerance_Top;
                stcTemporaryBlobLead.intAGVROITolerance_Bottom = m_stcBlobLead.intAGVROITolerance_Bottom;
                stcTemporaryBlobLead.intAGVROITolerance_Left = m_stcBlobLead.intAGVROITolerance_Left;
                stcTemporaryBlobLead.intAGVROITolerance_Right = m_stcBlobLead.intAGVROITolerance_Right;

                m_arrTemporaryBlobLeads.Add(stcTemporaryBlobLead);
            }
        }

        /// <summary>
        /// Backup all tolerance of blobs features into m_arrBackupTemplateBlobLeads and all tolerance of pitch gap into m_arrTolePitchGap
        /// </summary>
        public void BackupPreviousTolerance()
        {
            m_arrBackupTemplateBlobLeads.Clear();
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                m_stcBackupTemplateBlobLead.intDirection = m_stcBlobLead.intDirection;
                m_stcBackupTemplateBlobLead.intNoID = m_stcBlobLead.intNoID;
                m_stcBackupTemplateBlobLead.intGroupID = m_stcBlobLead.intGroupID;
                m_stcBackupTemplateBlobLead.fStartX = m_stcBlobLead.fStartX;
                m_stcBackupTemplateBlobLead.fStartY = m_stcBlobLead.fStartY;
                m_stcBackupTemplateBlobLead.fEndX = m_stcBlobLead.fEndX;
                m_stcBackupTemplateBlobLead.fEndY = m_stcBlobLead.fEndY;
                m_stcBackupTemplateBlobLead.fLimitCenterX = m_stcBlobLead.fLimitCenterX;
                m_stcBackupTemplateBlobLead.fLimitCenterY = m_stcBlobLead.fLimitCenterY;
                m_stcBackupTemplateBlobLead.fSkew = m_stcBlobLead.fSkew;
                m_stcBackupTemplateBlobLead.fOffSet = m_stcBlobLead.fOffSet;

                m_stcBackupTemplateBlobLead.fMinBaseWidth = m_stcBlobLead.fMinBaseWidth;
                m_stcBackupTemplateBlobLead.fMaxBaseWidth = m_stcBlobLead.fMaxBaseWidth;
                m_stcBackupTemplateBlobLead.fMinBaseLength = m_stcBlobLead.fMinBaseLength;
                m_stcBackupTemplateBlobLead.fMaxBaseLength = m_stcBlobLead.fMaxBaseLength;

                m_stcBackupTemplateBlobLead.fMinTipWidth = m_stcBlobLead.fMinTipWidth;
                m_stcBackupTemplateBlobLead.fMaxTipWidth = m_stcBlobLead.fMaxTipWidth;
                m_stcBackupTemplateBlobLead.fMinTipLength = m_stcBlobLead.fMinTipLength;
                m_stcBackupTemplateBlobLead.fMaxTipLength = m_stcBlobLead.fMaxTipLength;

                m_stcBackupTemplateBlobLead.fMinPitch = m_stcBlobLead.fMinPitch;
                m_stcBackupTemplateBlobLead.fMaxPitch = m_stcBlobLead.fMaxPitch;
                m_stcBackupTemplateBlobLead.fMinGap = m_stcBlobLead.fMinGap;
                m_stcBackupTemplateBlobLead.fMaxGap = m_stcBlobLead.fMaxGap;

                m_stcBackupTemplateBlobLead.fMinStandOff = m_stcBlobLead.fMinStandOff;
                m_stcBackupTemplateBlobLead.fMaxStandOff = m_stcBlobLead.fMaxStandOff;

                m_stcBackupTemplateBlobLead.fMinSolderPadLength = m_stcBlobLead.fMinSolderPadLength;
                m_stcBackupTemplateBlobLead.fMaxSolderPadLength = m_stcBlobLead.fMaxSolderPadLength;

                m_stcBackupTemplateBlobLead.fMaxCoplan = m_stcBlobLead.fMaxCoplan;

                m_stcBackupTemplateBlobLead.fMinAGV = m_stcBlobLead.fMinAGV;
                m_stcBackupTemplateBlobLead.fMaxAGV = m_stcBlobLead.fMaxAGV;

                m_stcBackupTemplateBlobLead.intAGVROITolerance_Top = m_stcBlobLead.intAGVROITolerance_Top;
                m_stcBackupTemplateBlobLead.intAGVROITolerance_Bottom = m_stcBlobLead.intAGVROITolerance_Bottom;
                m_stcBackupTemplateBlobLead.intAGVROITolerance_Left = m_stcBlobLead.intAGVROITolerance_Left;
                m_stcBackupTemplateBlobLead.intAGVROITolerance_Right = m_stcBlobLead.intAGVROITolerance_Right;

                m_stcBackupTemplateBlobLead.fLeadLimitMinWidth = m_stcBlobLead.fLeadLimitMinWidth;
                m_stcBackupTemplateBlobLead.fLeadLimitMaxWidth = m_stcBlobLead.fLeadLimitMaxWidth;
                m_stcBackupTemplateBlobLead.fLeadMaxBurrWidth = m_stcBlobLead.fLeadMaxBurrWidth;

                m_stcBackupTemplateBlobLead.fWidthOffset = m_stcBlobLead.fWidthOffset;
                m_stcBackupTemplateBlobLead.fLengthOffset = m_stcBlobLead.fLengthOffset;
                m_stcBackupTemplateBlobLead.fPitchOffset = m_stcBlobLead.fPitchOffset;
                m_stcBackupTemplateBlobLead.fGapOffset = m_stcBlobLead.fGapOffset;
                m_stcBackupTemplateBlobLead.fStandOffOffset = m_stcBlobLead.fStandOffOffset;
                m_stcBackupTemplateBlobLead.fCoplanOffset = m_stcBlobLead.fCoplanOffset;

                m_arrBackupTemplateBlobLeads.Add(m_stcBackupTemplateBlobLead);
            }

            m_arrTolePitchGap.Clear();
            for (int i = 0; i < m_arrPitchGap.Count; i++)
            {
                m_stcTolePitchGap.fMinPitch = m_arrPitchGap[i].fMinPitch;
                m_stcTolePitchGap.fMaxPitch = m_arrPitchGap[i].fMaxPitch;
                m_stcTolePitchGap.fMinGap = m_arrPitchGap[i].fMinGap;
                m_stcTolePitchGap.fMaxGap = m_arrPitchGap[i].fMaxGap;
                m_arrTolePitchGap.Add(m_stcTolePitchGap);
            }

            m_arrBackupPitchGap.Clear();
            PitchGap stcPitchGap = new PitchGap();
            for (int i = 0; i < m_arrPitchGap.Count; i++)
            {
                stcPitchGap.intFromLeadNo = m_arrPitchGap[i].intFromLeadNo;
                stcPitchGap.intToLeadNo = m_arrPitchGap[i].intToLeadNo;
                stcPitchGap.intDirection = m_arrPitchGap[i].intDirection;
                stcPitchGap.fPitch = m_arrPitchGap[i].fPitch;
                stcPitchGap.fGap = m_arrPitchGap[i].fGap;
                stcPitchGap.fPitchMM = m_arrPitchGap[i].fPitchMM;
                stcPitchGap.fGapMM = m_arrPitchGap[i].fGapMM;
                stcPitchGap.fMinPitch = m_arrPitchGap[i].fMinPitch;
                stcPitchGap.fMaxPitch = m_arrPitchGap[i].fMaxPitch;
                stcPitchGap.fMinGap = m_arrPitchGap[i].fMinGap;
                stcPitchGap.fMaxGap = m_arrPitchGap[i].fMaxGap;
                stcPitchGap.intStartPointX = m_arrPitchGap[i].intStartPointX;
                stcPitchGap.intStartPointY = m_arrPitchGap[i].intStartPointY;
                stcPitchGap.intEndPointX = m_arrPitchGap[i].intEndPointX;
                stcPitchGap.intEndPointY = m_arrPitchGap[i].intEndPointY;
                stcPitchGap.intFailMask = m_arrPitchGap[i].intFailMask;

                m_arrBackupPitchGap.Add(stcPitchGap);
            }
        }

        /// <summary>
        /// Draw selected blob 
        /// </summary>
        /// <param name="g">destination image to be drawn</param>
        /// <param name="fScale">scale</param>
        /// <param name="intZoomImageEdgeX">translation factor for panning in the horizontal direction</param>
        /// <param name="intZoomImageEdgeY">translation factor for panning in the vertical direction</param>
        public void DrawObjects(Graphics g, float fDrawingScaleX, float fDrawingScaleY)
        {
            int intColorIndex = 0;
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                //m_objEBlobs.DrawSelectedBlob(g, fDrawingScaleX, fDrawingScaleY, intColorIndex, i);
                if (((BlobsFeatures)m_arrTemplateBlobLeads[i]).blnSelected)
                    m_objEBlobs.DrawSelectedBlob(g, fDrawingScaleX, fDrawingScaleY, intColorIndex, i);

                intColorIndex++;
            }

            for (int i = 0; i < m_arrTemplateBlobBodyLeads.Count; i++)
            {
                m_objEBlobs.DrawSelectedBlob(g, fDrawingScaleX, fDrawingScaleY, intColorIndex, i);
                //if (((BlobsFeatures)m_arrTemplateBlobLeads[i]).blnSelected)
                //m_objEBlobs.DrawSelectedBlob(g, fDrawingScaleX, fDrawingScaleY, intColorIndex, i, ((BlobsFeatures)m_arrTemplateBlobLeads[i]).arrSelectedBlob);

                intColorIndex++;
            }
        }

        public void DrawObjects_Lead3D(Graphics g, float fDrawingScaleX, float fDrawingScaleY)
        {
            int intColorIndex = 0;
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                if (((BlobsFeatures)m_arrTemplateBlobLeads[i]).blnSelected)
                    m_objEBlobs.DrawSelectedBlob(g, fDrawingScaleX, fDrawingScaleY, intColorIndex, i);

                intColorIndex++;
            }

            for (int i = 0; i < m_arrTemplateBlobBodyLeads.Count; i++)
            {
                if (((BlobsFeatures)m_arrTemplateBlobBodyLeads[i]).blnSelected)
                    m_objEBlobs.DrawSelectedBlob(g, fDrawingScaleX, fDrawingScaleY, intColorIndex, i);

                intColorIndex++;
            }

        }


        /// <summary>
        /// Draw pitch gap link
        /// </summary>
        /// <param name="g">destination image to be drawn</param>
        /// <param name="intRoiOrgX">ROI origin X</param>
        /// <param name="intRoiOrgY">ROI origin Y</param>
        /// <param name="fScale">scale</param>
        /// <param name="intZoomImageEdgeX">translation factor for panning in the horizontal direction</param>
        /// <param name="intZoomImageEdgeY">translation factor for panning in the vertical direction</param>
        public void DrawPitchGapLink(Graphics g, float fDrawingScaleX, float fDrawingScaleY, int intRoiOrgX, int intRoiOrgY, Color objColor)
        {
            for (int i = 0; i < m_arrPitchGap.Count; i++)
            {
                g.DrawLine(new Pen(objColor), (int)Math.Round((intRoiOrgX + m_arrPitchGap[i].intStartPointX) * fDrawingScaleX, 0, MidpointRounding.AwayFromZero),
                                               (int)Math.Round((intRoiOrgY + m_arrPitchGap[i].intStartPointY) * fDrawingScaleY, 0, MidpointRounding.AwayFromZero),
                                               (int)Math.Round((intRoiOrgX + m_arrPitchGap[i].intEndPointX) * fDrawingScaleX, 0, MidpointRounding.AwayFromZero),
                                               (int)Math.Round((intRoiOrgY + m_arrPitchGap[i].intEndPointY) * fDrawingScaleY, 0, MidpointRounding.AwayFromZero));
            }
        }

        /// <summary>
        /// Draw selected objects
        /// </summary>
        /// <param name="g">destination image to be drawn</param>
        /// <param name="fScale"></param>
        /// <param name="intZoomImageEdgeX">translation factor for panning in the horizontal direction</param>
        /// <param name="intZoomImageEdgeY">translation factor for panning in the vertical direction</param>
        public void DrawSelectedObjects(Graphics g, float fDrawingScaleX, float fDrawingScaleY)
        {
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                if (((BlobsFeatures)m_arrTemplateBlobLeads[i]).blnSelected)
                    m_objEBlobs.DrawSelectedBlob(g, fDrawingScaleX, fDrawingScaleY, Color.Lime, i);
                else
                    m_objEBlobs.DrawSelectedBlob(g, fDrawingScaleX, fDrawingScaleY, Color.Red, i);

                //    m_objEBlobs.DrawSelectedBlob(g, fDrawingScaleX, fDrawingScaleY, Color.Lime, i, ((BlobsFeatures)m_arrTemplateBlobLeads[i]).arrSelectedBlob);
                //else
                //    m_objEBlobs.DrawSelectedBlob(g, fDrawingScaleX, fDrawingScaleY, Color.Red, i, ((BlobsFeatures)m_arrTemplateBlobLeads[i]).arrSelectedBlob);
            }

            for (int i = 0; i < m_arrTemplateBlobBodyLeads.Count; i++)
            {
                if (((BlobsFeatures)m_arrTemplateBlobBodyLeads[i]).blnSelected)
                    m_objEBlobs.DrawSelectedBlob(g, fDrawingScaleX, fDrawingScaleY, Color.Lime, i);
                else
                    m_objEBlobs.DrawSelectedBlob(g, fDrawingScaleX, fDrawingScaleY, Color.Red, i);

                //    m_objEBlobs.DrawSelectedBlob(g, fDrawingScaleX, fDrawingScaleY, Color.Lime, i, ((BlobsFeatures)m_arrTemplateBlobLeads[i]).arrSelectedBlob);
                //else
                //    m_objEBlobs.DrawSelectedBlob(g, fDrawingScaleX, fDrawingScaleY, Color.Red, i, ((BlobsFeatures)m_arrTemplateBlobLeads[i]).arrSelectedBlob);
            }
        }

        /// <summary>
        /// Draw template objects
        /// </summary>
        /// <param name="g">destination image to be drawn</param>
        /// <param name="intRoiOrgX">ROI origin X</param>
        /// <param name="intRoiOrgY">ROI origin Y</param>
        /// <param name="fScale"></param>
        /// <param name="intZoomImageEdgeX">translation factor for panning in the horizontal direction</param>
        /// <param name="intZoomImageEdgeY">translation factor for panning in the vertical direction</param>
        public void DrawTemplateObjects(Graphics g, float fDrawingScaleX, float fDrawingScaleY, int intRoiOrgX, int intRoiOrgY)
        {

            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {

                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                System.Drawing.PointF p1 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fLimitCenterX - m_stcBlobLead.fWidth / 2, intRoiOrgY + m_stcBlobLead.fLimitCenterY - m_stcBlobLead.fHeight / 2);
                System.Drawing.PointF p2 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fLimitCenterX + m_stcBlobLead.fWidth / 2, intRoiOrgY + m_stcBlobLead.fLimitCenterY - m_stcBlobLead.fHeight / 2);
                System.Drawing.PointF p3 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fLimitCenterX - m_stcBlobLead.fWidth / 2, intRoiOrgY + m_stcBlobLead.fLimitCenterY + m_stcBlobLead.fHeight / 2);
                System.Drawing.PointF p4 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fLimitCenterX + m_stcBlobLead.fWidth / 2, intRoiOrgY + m_stcBlobLead.fLimitCenterY + m_stcBlobLead.fHeight / 2);

                if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                {
                    p1.X = p1.X * fDrawingScaleX;
                    p1.Y = p1.Y * fDrawingScaleY;
                    p2.X = p2.X * fDrawingScaleX;
                    p2.Y = p2.Y * fDrawingScaleY;
                    p3.X = p3.X * fDrawingScaleX;
                    p3.Y = p3.Y * fDrawingScaleY;
                    p4.X = p4.X * fDrawingScaleX;
                    p4.Y = p4.Y * fDrawingScaleY;
                }


                if (m_stcBlobLead.intLengthMode == 1)
                {
                    g.DrawLine(new Pen(Color.Blue, 2), p1, p2);
                    g.DrawLine(new Pen(Color.Lime, 2), p2, p4);
                    g.DrawLine(new Pen(Color.Blue, 2), p4, p3);
                    g.DrawLine(new Pen(Color.Lime, 2), p3, p1);
                }
                else
                {
                    g.DrawLine(new Pen(Color.Lime, 2), p1, p2);
                    g.DrawLine(new Pen(Color.Blue, 2), p2, p4);
                    g.DrawLine(new Pen(Color.Lime, 2), p4, p3);
                    g.DrawLine(new Pen(Color.Blue, 2), p3, p1);
                }
                g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                    ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCenterX + intRoiOrgX - 8) * fDrawingScaleX,
                    ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCenterY + intRoiOrgY - 8) * fDrawingScaleY);
            }
        }

        /// <summary>
        /// Draw template objects
        /// </summary>
        /// <param name="g">destination image to be drawn</param>
        /// <param name="intRoiOrgX">ROI origin X</param>
        /// <param name="intRoiOrgY">ROI origin Y</param>
        /// <param name="fScale"></param>
        /// <param name="intZoomImageEdgeX">translation factor for panning in the horizontal direction</param>
        /// <param name="intZoomImageEdgeY">translation factor for panning in the vertical direction</param>
        public void DrawTemplateObjects_Lead(Graphics g, float fDrawingScaleX, float fDrawingScaleY, int intRoiOrgX, int intRoiOrgY, int intLeadPosition)
        {
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                System.Drawing.PointF p1 = new PointF();
                System.Drawing.PointF p2 = new PointF();
                System.Drawing.PointF p3 = new PointF();
                System.Drawing.PointF p4 = new PointF();
                System.Drawing.PointF p5 = new PointF();
                System.Drawing.PointF p6 = new PointF();

                switch (intLeadPosition)
                {
                    case 1:
                        p1 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX - m_stcBlobLead.fTipWidth / 2, intRoiOrgY + m_stcBlobLead.fTipCenterY - (m_stcBlobLead.fHeight / 2) + m_intTipOffset);
                        p2 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX + m_stcBlobLead.fTipWidth / 2, intRoiOrgY + m_stcBlobLead.fTipCenterY - (m_stcBlobLead.fHeight / 2) + m_intTipOffset);
                        p3 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX - m_stcBlobLead.fBaseWidth / 2, intRoiOrgY + m_stcBlobLead.fBaseCenterY + (m_stcBlobLead.fHeight / 2) - m_intBaseOffset);
                        p4 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX + m_stcBlobLead.fBaseWidth / 2, intRoiOrgY + m_stcBlobLead.fBaseCenterY + (m_stcBlobLead.fHeight / 2) - m_intBaseOffset);
                        p5 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX, intRoiOrgY + m_stcBlobLead.fTipCenterY - (m_stcBlobLead.fHeight / 2));
                        p6 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX, intRoiOrgY + m_stcBlobLead.fBaseCenterY + (m_stcBlobLead.fHeight / 2));
                        break;
                    case 2:
                        p1 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX - m_stcBlobLead.fWidth / 2 + m_intBaseOffset, intRoiOrgY + m_stcBlobLead.fBaseCenterY - (m_stcBlobLead.fBaseLength / 2));
                        p2 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX + m_stcBlobLead.fWidth / 2 - m_intTipOffset, intRoiOrgY + m_stcBlobLead.fTipCenterY - (m_stcBlobLead.fTipLength / 2));
                        p3 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX - m_stcBlobLead.fWidth / 2 + m_intBaseOffset, intRoiOrgY + m_stcBlobLead.fBaseCenterY + (m_stcBlobLead.fBaseLength / 2));
                        p4 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX + m_stcBlobLead.fWidth / 2 - m_intTipOffset, intRoiOrgY + m_stcBlobLead.fTipCenterY + (m_stcBlobLead.fTipLength / 2));
                        p5 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX - (m_stcBlobLead.fWidth / 2), intRoiOrgY + m_stcBlobLead.fBaseCenterY);
                        p6 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX + (m_stcBlobLead.fWidth / 2), intRoiOrgY + m_stcBlobLead.fTipCenterY);
                        break;
                    case 3:
                        p1 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX - m_stcBlobLead.fBaseWidth / 2, intRoiOrgY + m_stcBlobLead.fBaseCenterY - (m_stcBlobLead.fHeight / 2) + m_intBaseOffset);
                        p2 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX + m_stcBlobLead.fBaseWidth / 2, intRoiOrgY + m_stcBlobLead.fBaseCenterY - (m_stcBlobLead.fHeight / 2) + m_intBaseOffset);
                        p3 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX - m_stcBlobLead.fTipWidth / 2, intRoiOrgY + m_stcBlobLead.fTipCenterY + (m_stcBlobLead.fHeight / 2) - m_intTipOffset);
                        p4 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX + m_stcBlobLead.fTipWidth / 2, intRoiOrgY + m_stcBlobLead.fTipCenterY + (m_stcBlobLead.fHeight / 2) - m_intTipOffset);
                        p5 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX, intRoiOrgY + m_stcBlobLead.fBaseCenterY - (m_stcBlobLead.fHeight / 2));
                        p6 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX, intRoiOrgY + m_stcBlobLead.fTipCenterY + (m_stcBlobLead.fHeight / 2));
                        break;
                    case 4:
                        p1 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX - m_stcBlobLead.fWidth / 2 + m_intTipOffset, intRoiOrgY + m_stcBlobLead.fTipCenterY - (m_stcBlobLead.fTipLength / 2));
                        p2 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX + m_stcBlobLead.fWidth / 2 - m_intBaseOffset, intRoiOrgY + m_stcBlobLead.fBaseCenterY - (m_stcBlobLead.fBaseLength / 2));
                        p3 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX - m_stcBlobLead.fWidth / 2 + m_intTipOffset, intRoiOrgY + m_stcBlobLead.fTipCenterY + (m_stcBlobLead.fTipLength / 2));
                        p4 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX + m_stcBlobLead.fWidth / 2 - m_intBaseOffset, intRoiOrgY + m_stcBlobLead.fBaseCenterY + (m_stcBlobLead.fBaseLength / 2));
                        p5 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX - (m_stcBlobLead.fWidth / 2), intRoiOrgY + m_stcBlobLead.fTipCenterY);
                        p6 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX + (m_stcBlobLead.fWidth / 2), intRoiOrgY + m_stcBlobLead.fBaseCenterY);
                        break;
                }

                if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                {
                    p1.X = p1.X * fDrawingScaleX;
                    p1.Y = p1.Y * fDrawingScaleY;
                    p2.X = p2.X * fDrawingScaleX;
                    p2.Y = p2.Y * fDrawingScaleY;
                    p3.X = p3.X * fDrawingScaleX;
                    p3.Y = p3.Y * fDrawingScaleY;
                    p4.X = p4.X * fDrawingScaleX;
                    p4.Y = p4.Y * fDrawingScaleY;
                    p5.X = p5.X * fDrawingScaleX;
                    p5.Y = p5.Y * fDrawingScaleY;
                    p6.X = p6.X * fDrawingScaleX;
                    p6.Y = p6.Y * fDrawingScaleY;
                }


                g.DrawLine(new Pen(Color.Red, 1), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                g.DrawLine(new Pen(Color.Red, 1), p1.X - 3, p1.Y, p1.X + 3, p1.Y);

                g.DrawLine(new Pen(Color.Red, 1), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                g.DrawLine(new Pen(Color.Red, 1), p2.X - 3, p2.Y, p2.X + 3, p2.Y);

                g.DrawLine(new Pen(Color.Red, 1), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                g.DrawLine(new Pen(Color.Red, 1), p3.X - 3, p3.Y, p3.X + 3, p3.Y);

                g.DrawLine(new Pen(Color.Red, 1), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                g.DrawLine(new Pen(Color.Red, 1), p4.X - 3, p4.Y, p4.X + 3, p4.Y);

                g.DrawLine(new Pen(Color.Red, 1), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                g.DrawLine(new Pen(Color.Red, 1), p5.X - 3, p5.Y, p5.X + 3, p5.Y);

                g.DrawLine(new Pen(Color.Red, 1), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                g.DrawLine(new Pen(Color.Red, 1), p6.X - 3, p6.Y, p6.X + 3, p6.Y);

                g.DrawLine(new Pen(Color.Blue, 1), p5.X, p5.Y, p6.X, p6.Y);

                switch (intLeadPosition)
                {
                    case 1:
                        g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCenterX + intRoiOrgX - 8) * fDrawingScaleX,
                                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCenterY + intRoiOrgY - 40) * fDrawingScaleY);
                        break;
                    case 2:
                        g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCenterX + intRoiOrgX + 27) * fDrawingScaleX,
                                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCenterY + intRoiOrgY - 8) * fDrawingScaleY);
                        break;
                    case 3:
                        g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCenterX + intRoiOrgX - 8) * fDrawingScaleX,
                                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCenterY + intRoiOrgY + 27) * fDrawingScaleY);
                        break;
                    case 4:
                        g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCenterX + intRoiOrgX - 40) * fDrawingScaleX,
                                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCenterY + intRoiOrgY - 8) * fDrawingScaleY);
                        break;
                }
            }

            if (m_fReferencePointEndX != 0 && m_fReferencePointEndY != 0)
            {
                System.Drawing.PointF pRefPoint1 = new PointF();
                System.Drawing.PointF pRefPoint2 = new PointF();
                pRefPoint1 = new System.Drawing.PointF(intRoiOrgX + m_fReferencePointStartX, intRoiOrgY + m_fReferencePointStartY);
                pRefPoint2 = new System.Drawing.PointF(intRoiOrgX + m_fReferencePointEndX, intRoiOrgY + m_fReferencePointEndY);

                if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                {
                    pRefPoint1.X = pRefPoint1.X * fDrawingScaleX;
                    pRefPoint1.Y = pRefPoint1.Y * fDrawingScaleY;
                    pRefPoint2.X = pRefPoint2.X * fDrawingScaleX;
                    pRefPoint2.Y = pRefPoint2.Y * fDrawingScaleY;
                }

                g.DrawLine(new Pen(Color.Lime, 1), pRefPoint1.X, pRefPoint1.Y - 3, pRefPoint1.X, pRefPoint1.Y + 3);
                g.DrawLine(new Pen(Color.Lime, 1), pRefPoint1.X - 3, pRefPoint1.Y, pRefPoint1.X + 3, pRefPoint1.Y);

                g.DrawLine(new Pen(Color.Lime, 1), pRefPoint2.X, pRefPoint2.Y - 3, pRefPoint2.X, pRefPoint2.Y + 3);
                g.DrawLine(new Pen(Color.Lime, 1), pRefPoint2.X - 3, pRefPoint2.Y, pRefPoint2.X + 3, pRefPoint2.Y);

                g.DrawLine(new Pen(Color.Lime, 1), pRefPoint1.X, pRefPoint1.Y, pRefPoint2.X, pRefPoint2.Y);
            }
        }

        public void DrawTemplateObjects_Lead3D_Side(Graphics g, float fDrawingScaleX, float fDrawingScaleY, int intRoiOrgX, int intRoiOrgY, int intLeadPosition)
        {
            if (m_intLeadROIDirection == 1 || m_intLeadROIDirection == 3)
            {
                int intLeftX = (int)Math.Round(m_pCornerPoint_Left.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                int intLeftY = (int)Math.Round(m_pCornerPoint_Left.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                int intRightX = (int)Math.Round(m_pCornerPoint_Right.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                int intRightY = (int)Math.Round(m_pCornerPoint_Right.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);

                m_objLineGauge.DrawResultLineGauge(g, Color.DarkViolet);
                //g.DrawLine(new Pen(Color.Lime, 1), intLeftX, intLeftY, intRightX, intRightY);
                //m_objBaseLine.DrawLineByPoints(g, fDrawingScaleX, fDrawingScaleY, m_pCornerPoint_Left.X, m_pCornerPoint_Right.X, Color.Lime, 1);

                g.DrawLine(new Pen(Color.DarkViolet, 1), intLeftX - 5, intLeftY, intLeftX + 5, intLeftY);
                g.DrawLine(new Pen(Color.DarkViolet, 1), intLeftX, intLeftY - 5, intLeftX, intLeftY + 5);
                g.DrawLine(new Pen(Color.DarkViolet, 1), intRightX - 5, intRightY, intRightX + 5, intRightY);
                g.DrawLine(new Pen(Color.DarkViolet, 1), intRightX, intRightY - 5, intRightX, intRightY + 5);
            }
            else
            {
                int intTopX = (int)Math.Round(m_pCornerPoint_Top.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                int intTopY = (int)Math.Round(m_pCornerPoint_Top.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                int intBottomX = (int)Math.Round(m_pCornerPoint_Bottom.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                int intBottomY = (int)Math.Round(m_pCornerPoint_Bottom.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);

                m_objLineGauge.DrawResultLineGauge(g, Color.DarkViolet);
                //g.DrawLine(new Pen(Color.Lime, 1), intTopX, intTopY, intBottomX, intBottomY);
                //m_objBaseLine.DrawLineByPoints(g, fDrawingScaleX, fDrawingScaleY, m_pCornerPoint_Top.X, m_pCornerPoint_Bottom.X, Color.Lime, 1);

                g.DrawLine(new Pen(Color.DarkViolet, 1), intTopX - 5, intTopY, intTopX + 5, intTopY);
                g.DrawLine(new Pen(Color.DarkViolet, 1), intTopX, intTopY - 5, intTopX, intTopY + 5);
                g.DrawLine(new Pen(Color.DarkViolet, 1), intBottomX - 5, intBottomY, intBottomX + 5, intBottomY);
                g.DrawLine(new Pen(Color.DarkViolet, 1), intBottomX, intBottomY - 5, intBottomX, intBottomY + 5);
            }

            // Draw center lead tip, base and, width and length.
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                if (m_intLeadDirection == 0)
                {
                    if (m_intLeadROIDirection == 1 || m_intLeadROIDirection == 3)
                    {
                        continue;
                    }
                }
                else
                {
                    if (m_intLeadROIDirection == 2 || m_intLeadROIDirection == 4)
                    {
                        continue;
                    }
                }
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                System.Drawing.PointF p1 = new PointF();
                System.Drawing.PointF p2 = new PointF();
                System.Drawing.PointF p3 = new PointF();

                switch (m_stcBlobLead.intDirection)
                {
                    case 4:
                        p1 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX, intRoiOrgY + m_stcBlobLead.fTipCenterY);
                        p2 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX - m_stcBlobLead.fTipWidth / 2, intRoiOrgY + m_stcBlobLead.fTipCenterY + m_intTipOffset);
                        p3 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX + m_stcBlobLead.fTipWidth / 2, intRoiOrgY + m_stcBlobLead.fTipCenterY + m_intTipOffset);
                        break;
                    case 2:
                        p1 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX, intRoiOrgY + m_stcBlobLead.fTipCenterY);
                        p2 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX - m_intTipOffset, intRoiOrgY + m_stcBlobLead.fTipCenterY - m_stcBlobLead.fTipWidth / 2);
                        p3 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX - m_intTipOffset, intRoiOrgY + m_stcBlobLead.fTipCenterY + m_stcBlobLead.fTipWidth / 2);

                        break;
                    case 8:
                        p1 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX, intRoiOrgY + m_stcBlobLead.fTipCenterY);
                        p2 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX - m_stcBlobLead.fTipWidth / 2, intRoiOrgY + m_stcBlobLead.fTipCenterY - m_intTipOffset);
                        p3 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX + m_stcBlobLead.fTipWidth / 2, intRoiOrgY + m_stcBlobLead.fTipCenterY - m_intTipOffset);
                        break;
                    case 1:
                        p1 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX, intRoiOrgY + m_stcBlobLead.fTipCenterY);
                        p2 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX + m_intTipOffset, intRoiOrgY + m_stcBlobLead.fTipCenterY - m_stcBlobLead.fTipWidth / 2);
                        p3 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX + m_intTipOffset, intRoiOrgY + m_stcBlobLead.fTipCenterY + m_stcBlobLead.fTipWidth / 2);
                        break;
                }

                if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                {
                    p1.X = p1.X * fDrawingScaleX;
                    p1.Y = p1.Y * fDrawingScaleY;
                    p2.X = p2.X * fDrawingScaleX;
                    p2.Y = p2.Y * fDrawingScaleY;
                    p3.X = p3.X * fDrawingScaleX;
                    p3.Y = p3.Y * fDrawingScaleY;
                }


                //g.DrawLine(new Pen(Color.Lime, 1), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                //g.DrawLine(new Pen(Color.Lime, 1), p1.X - 3, p1.Y, p1.X + 3, p1.Y);

                //g.DrawLine(new Pen(Color.Lime, 1), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                //g.DrawLine(new Pen(Color.Lime, 1), p2.X - 3, p2.Y, p2.X + 3, p2.Y);

                //g.DrawLine(new Pen(Color.Lime, 1), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                //g.DrawLine(new Pen(Color.Lime, 1), p3.X - 3, p3.Y, p3.X + 3, p3.Y);

                if (m_stcBlobLead.blnTipCenterFound)
                {
                    g.DrawLine(new Pen(Color.Lime, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                    g.DrawLine(new Pen(Color.Lime, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                }
                else
                {
                    g.DrawLine(new Pen(Color.Red, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                    g.DrawLine(new Pen(Color.Red, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                }

                if (m_stcBlobLead.blnTipStartFound)
                {
                    g.DrawLine(new Pen(Color.Lime, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                    g.DrawLine(new Pen(Color.Lime, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                }
                else
                {
                    g.DrawLine(new Pen(Color.Red, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                    g.DrawLine(new Pen(Color.Red, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                }

                if (m_stcBlobLead.blnTipEndFound)
                {
                    g.DrawLine(new Pen(Color.Lime, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                    g.DrawLine(new Pen(Color.Lime, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                }
                else
                {
                    g.DrawLine(new Pen(Color.Red, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                    g.DrawLine(new Pen(Color.Red, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                }
                // Draw lead lable.
                switch (m_stcBlobLead.intDirection)
                {
                    case 4: // Top
                        g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Blue),
                                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fTipCenterX + intRoiOrgX - 15) * fDrawingScaleX,
                                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fTipCenterY + intRoiOrgY - 40) * fDrawingScaleY);
                        break;
                    case 2: // Right
                        g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Blue),
                                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fTipCenterX + intRoiOrgX + 10) * fDrawingScaleX,
                                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fTipCenterY + intRoiOrgY - 15) * fDrawingScaleY);
                        break;
                    case 8: // Bottom
                        g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Blue),
                                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fTipCenterX + intRoiOrgX - 15) * fDrawingScaleX,
                                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fTipCenterY + intRoiOrgY + 10) * fDrawingScaleY);
                        break;
                    case 1: // Left
                        g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Blue),
                                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fTipCenterX + intRoiOrgX - 40) * fDrawingScaleX,
                                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fTipCenterY + intRoiOrgY - 15) * fDrawingScaleY);
                        break;
                }
            }
        }
        public void DrawTemplateObjects_Lead3D_CenterPkg(Graphics g, float fDrawingScaleX, float fDrawingScaleY, int intRoiOrgX, int intRoiOrgY, int intROIWidth, int intROIHeight, int intLeadPosition)
        {
            // Draw center unit package size
            int intTopLeftX = (int)Math.Round(m_pCornerPoint_TopLeft.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
            int intTopLeftY = (int)Math.Round(m_pCornerPoint_TopLeft.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
            int intTopRightX = (int)Math.Round(m_pCornerPoint_TopRight.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
            int intTopRightY = (int)Math.Round(m_pCornerPoint_TopRight.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
            int intBottomLeftX = (int)Math.Round(m_pCornerPoint_BottomLeft.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
            int intBottomleftY = (int)Math.Round(m_pCornerPoint_BottomLeft.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
            int intBottomRightX = (int)Math.Round(m_pCornerPoint_BottomRight.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
            int intBottomRightY = (int)Math.Round(m_pCornerPoint_BottomRight.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
            int intCenterX = (int)Math.Round((intRoiOrgX + intROIWidth / 2) * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
            int intCenterY = (int)Math.Round((intRoiOrgY + intROIHeight / 2) * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);

            float newTLX = intTopLeftX, newTLY = intTopLeftY, newTRX = intTopRightX, newTRY = intTopRightY, newBLX = intBottomLeftX, newBLY = intBottomleftY, newBRX = intBottomRightX, newBRY = intBottomRightY;
            //Math2.RotateWithAngleAccordingToReferencePoint(intCenterX, intCenterY, intTopLeftX, intTopLeftY, -m_fCenterUnitAngle, ref newTLX, ref newTLY);
            //Math2.RotateWithAngleAccordingToReferencePoint(intCenterX, intCenterY, intTopRightX, intTopRightY, -m_fCenterUnitAngle, ref newTRX, ref newTRY);
            //Math2.RotateWithAngleAccordingToReferencePoint(intCenterX, intCenterY, intBottomLeftX, intBottomleftY, -m_fCenterUnitAngle, ref newBLX, ref newBLY);
            //Math2.RotateWithAngleAccordingToReferencePoint(intCenterX, intCenterY, intBottomRightX, intBottomRightY, -m_fCenterUnitAngle, ref newBRX, ref newBRY);

            //g.DrawLine(new Pen(Color.Yellow, 1), intTopLeftX, intTopLeftY, intTopRightX, intTopRightY);
            //g.DrawLine(new Pen(Color.Yellow, 1), intTopRightX, intTopRightY, intBottomRightX, intBottomRightY);
            //g.DrawLine(new Pen(Color.Yellow, 1), intBottomRightX, intBottomRightY, intBottomLeftX, intBottomleftY);
            //g.DrawLine(new Pen(Color.Yellow, 1), intBottomLeftX, intBottomleftY, intTopLeftX, intTopLeftY);

            //g.DrawLine(new Pen(Color.Yellow, 1), newTLX, newTLY, newTRX, newTRY);
            //g.DrawLine(new Pen(Color.Yellow, 1), newTRX, newTRY, newBRX, newBRY);
            //g.DrawLine(new Pen(Color.Yellow, 1), newBRX, newBRY, newBLX, newBLY);
            //g.DrawLine(new Pen(Color.Yellow, 1), newBLX, newBLY, newTLX, newTLY);

            g.DrawLine(new Pen(Color.Yellow, 1), (newTRX + newBRX) / 2, (newTLY + newTRY) / 2, (newBLX + newTLX) / 2, (newTLY + newTRY) / 2);
            g.DrawLine(new Pen(Color.Yellow, 1), (newTRX + newBRX) / 2, (newTLY + newTRY) / 2, (newTRX + newBRX) / 2, (newBRY + newBLY) / 2);
            g.DrawLine(new Pen(Color.Yellow, 1), (newBLX + newTLX) / 2, (newBRY + newBLY) / 2, (newTRX + newBRX) / 2, (newBRY + newBLY) / 2);
            g.DrawLine(new Pen(Color.Yellow, 1), (newBLX + newTLX) / 2, (newBRY + newBLY) / 2, (newBLX + newTLX) / 2, (newTLY + newTRY) / 2);

        }
        public void DrawTemplateObjects_Lead3D_Center(Graphics g, float fDrawingScaleX, float fDrawingScaleY, int intRoiOrgX, int intRoiOrgY, int intROIWidth, int intROIHeight, int intLeadPosition, Color[][] arrColor)
        {
            // Draw center unit package size
            int intTopLeftX = (int)Math.Round(m_pCornerPoint_TopLeft.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
            int intTopLeftY = (int)Math.Round(m_pCornerPoint_TopLeft.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
            int intTopRightX = (int)Math.Round(m_pCornerPoint_TopRight.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
            int intTopRightY = (int)Math.Round(m_pCornerPoint_TopRight.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
            int intBottomLeftX = (int)Math.Round(m_pCornerPoint_BottomLeft.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
            int intBottomleftY = (int)Math.Round(m_pCornerPoint_BottomLeft.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
            int intBottomRightX = (int)Math.Round(m_pCornerPoint_BottomRight.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
            int intBottomRightY = (int)Math.Round(m_pCornerPoint_BottomRight.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
            int intCenterX = (int)Math.Round((intRoiOrgX + intROIWidth / 2) * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
            int intCenterY = (int)Math.Round((intRoiOrgY + intROIHeight / 2) * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);

            float newTLX = intTopLeftX, newTLY = intTopLeftY, newTRX = intTopRightX, newTRY = intTopRightY, newBLX = intBottomLeftX, newBLY = intBottomleftY, newBRX = intBottomRightX, newBRY = intBottomRightY;
            //Math2.RotateWithAngleAccordingToReferencePoint(intCenterX, intCenterY, intTopLeftX, intTopLeftY, -m_fCenterUnitAngle, ref newTLX, ref newTLY);
            //Math2.RotateWithAngleAccordingToReferencePoint(intCenterX, intCenterY, intTopRightX, intTopRightY, -m_fCenterUnitAngle, ref newTRX, ref newTRY);
            //Math2.RotateWithAngleAccordingToReferencePoint(intCenterX, intCenterY, intBottomLeftX, intBottomleftY, -m_fCenterUnitAngle, ref newBLX, ref newBLY);
            //Math2.RotateWithAngleAccordingToReferencePoint(intCenterX, intCenterY, intBottomRightX, intBottomRightY, -m_fCenterUnitAngle, ref newBRX, ref newBRY);

            //g.DrawLine(new Pen(Color.Yellow, 1), intTopLeftX, intTopLeftY, intTopRightX, intTopRightY);
            //g.DrawLine(new Pen(Color.Yellow, 1), intTopRightX, intTopRightY, intBottomRightX, intBottomRightY);
            //g.DrawLine(new Pen(Color.Yellow, 1), intBottomRightX, intBottomRightY, intBottomLeftX, intBottomleftY);
            //g.DrawLine(new Pen(Color.Yellow, 1), intBottomLeftX, intBottomleftY, intTopLeftX, intTopLeftY);

            //g.DrawLine(new Pen(Color.Yellow, 1), newTLX, newTLY, newTRX, newTRY);
            //g.DrawLine(new Pen(Color.Yellow, 1), newTRX, newTRY, newBRX, newBRY);
            //g.DrawLine(new Pen(Color.Yellow, 1), newBRX, newBRY, newBLX, newBLY);
            //g.DrawLine(new Pen(Color.Yellow, 1), newBLX, newBLY, newTLX, newTLY);

            g.DrawLine(new Pen(arrColor[7][0], 1), (newTRX + newBRX) / 2, (newTLY + newTRY) / 2, (newBLX + newTLX) / 2, (newTLY + newTRY) / 2);
            g.DrawLine(new Pen(arrColor[7][0], 1), (newTRX + newBRX) / 2, (newTLY + newTRY) / 2, (newTRX + newBRX) / 2, (newBRY + newBLY) / 2);
            g.DrawLine(new Pen(arrColor[7][0], 1), (newBLX + newTLX) / 2, (newBRY + newBLY) / 2, (newTRX + newBRX) / 2, (newBRY + newBLY) / 2);
            g.DrawLine(new Pen(arrColor[7][0], 1), (newBLX + newTLX) / 2, (newBRY + newBLY) / 2, (newBLX + newTLX) / 2, (newTLY + newTRY) / 2);

            // Draw center lead tip, base and, width and length.
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                System.Drawing.PointF p1 = new PointF();
                System.Drawing.PointF p2 = new PointF();
                System.Drawing.PointF p3 = new PointF();
                System.Drawing.PointF p4 = new PointF();
                System.Drawing.PointF p5 = new PointF();
                System.Drawing.PointF p6 = new PointF();

                switch (m_stcBlobLead.intDirection)
                {
                    case 4:// Top
                        p1 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX - m_stcBlobLead.fTipWidth / 2, intRoiOrgY + m_stcBlobLead.fTipCenterY + m_intTipOffset);
                        p2 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX, intRoiOrgY + m_stcBlobLead.fTipCenterY);
                        p3 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX + m_stcBlobLead.fTipWidth / 2, intRoiOrgY + m_stcBlobLead.fTipCenterY + m_intTipOffset);
                        p4 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX - m_stcBlobLead.fBaseWidth / 2, intRoiOrgY + m_stcBlobLead.fBaseCenterY - m_intBaseOffset);
                        p5 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX, intRoiOrgY + m_stcBlobLead.fBaseCenterY);
                        p6 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX + m_stcBlobLead.fBaseWidth / 2, intRoiOrgY + m_stcBlobLead.fBaseCenterY - m_intBaseOffset);
                        break;
                    case 2:// Right
                        p1 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX - m_intTipOffset, intRoiOrgY + m_stcBlobLead.fTipCenterY - m_stcBlobLead.fTipWidth / 2);
                        p2 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX, intRoiOrgY + m_stcBlobLead.fTipCenterY);
                        p3 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX - m_intTipOffset, intRoiOrgY + m_stcBlobLead.fTipCenterY + m_stcBlobLead.fTipWidth / 2);
                        p4 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX + m_intBaseOffset, intRoiOrgY + m_stcBlobLead.fBaseCenterY - m_stcBlobLead.fBaseWidth / 2);
                        p5 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX, intRoiOrgY + m_stcBlobLead.fBaseCenterY);
                        p6 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX + m_intBaseOffset, intRoiOrgY + m_stcBlobLead.fBaseCenterY + m_stcBlobLead.fBaseWidth / 2);
                        break;
                    case 8:// Bottom
                        p1 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX - m_stcBlobLead.fTipWidth / 2, intRoiOrgY + m_stcBlobLead.fTipCenterY - m_intTipOffset);
                        p2 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX, intRoiOrgY + m_stcBlobLead.fTipCenterY);
                        p3 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX + m_stcBlobLead.fTipWidth / 2, intRoiOrgY + m_stcBlobLead.fTipCenterY - m_intTipOffset);
                        p4 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX - m_stcBlobLead.fBaseWidth / 2, intRoiOrgY + m_stcBlobLead.fBaseCenterY + m_intBaseOffset);
                        p5 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX, intRoiOrgY + m_stcBlobLead.fBaseCenterY);
                        p6 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX + m_stcBlobLead.fBaseWidth / 2, intRoiOrgY + m_stcBlobLead.fBaseCenterY + m_intBaseOffset);
                        break;
                    case 1:// Left
                        p1 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX + m_intTipOffset, intRoiOrgY + m_stcBlobLead.fTipCenterY - m_stcBlobLead.fTipWidth / 2);
                        p2 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX, intRoiOrgY + m_stcBlobLead.fTipCenterY);
                        p3 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX + m_intTipOffset, intRoiOrgY + m_stcBlobLead.fTipCenterY + m_stcBlobLead.fTipWidth / 2);
                        p4 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX - m_intBaseOffset, intRoiOrgY + m_stcBlobLead.fBaseCenterY - m_stcBlobLead.fBaseWidth / 2);
                        p5 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX, intRoiOrgY + m_stcBlobLead.fBaseCenterY);
                        p6 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX - m_intBaseOffset, intRoiOrgY + m_stcBlobLead.fBaseCenterY + m_stcBlobLead.fBaseWidth / 2);
                        break;
                }

                //switch (m_stcBlobLead.intDirection)
                //{
                //    case 4:
                //        p1 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX - m_stcBlobLead.fTipWidth / 2, intRoiOrgY + m_stcBlobLead.fTipCenterY - (m_stcBlobLead.fHeight / 2) + m_intTipOffset);
                //        p2 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX + m_stcBlobLead.fTipWidth / 2, intRoiOrgY + m_stcBlobLead.fTipCenterY - (m_stcBlobLead.fHeight / 2) + m_intTipOffset);
                //        p3 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX - m_stcBlobLead.fBaseWidth / 2, intRoiOrgY + m_stcBlobLead.fBaseCenterY + (m_stcBlobLead.fHeight / 2) - m_intBaseOffset);
                //        p4 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX + m_stcBlobLead.fBaseWidth / 2, intRoiOrgY + m_stcBlobLead.fBaseCenterY + (m_stcBlobLead.fHeight / 2) - m_intBaseOffset);
                //        p5 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX, intRoiOrgY + m_stcBlobLead.fTipCenterY - (m_stcBlobLead.fHeight / 2));
                //        p6 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX, intRoiOrgY + m_stcBlobLead.fBaseCenterY + (m_stcBlobLead.fHeight / 2));
                //        break;
                //    case 2:
                //        p1 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX - m_stcBlobLead.fWidth / 2 + m_intBaseOffset, intRoiOrgY + m_stcBlobLead.fBaseCenterY - m_stcBlobLead.fBaseLength / 2);
                //        p2 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX + m_stcBlobLead.fWidth / 2 - m_intTipOffset, intRoiOrgY + m_stcBlobLead.fTipCenterY - m_stcBlobLead.fTipLength / 2);
                //        p3 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX - m_stcBlobLead.fWidth / 2 + m_intBaseOffset, intRoiOrgY + m_stcBlobLead.fBaseCenterY + m_stcBlobLead.fBaseLength / 2);
                //        p4 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX + m_stcBlobLead.fWidth / 2 - m_intTipOffset, intRoiOrgY + m_stcBlobLead.fTipCenterY + m_stcBlobLead.fTipLength / 2);
                //        p5 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX - m_stcBlobLead.fWidth / 2, intRoiOrgY + m_stcBlobLead.fBaseCenterY);
                //        p6 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX + m_stcBlobLead.fWidth / 2, intRoiOrgY + m_stcBlobLead.fTipCenterY);
                //        break;
                //    case 8:
                //        p1 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX - m_stcBlobLead.fBaseWidth / 2, intRoiOrgY + m_stcBlobLead.fBaseCenterY - m_stcBlobLead.fHeight / 2 + m_intBaseOffset);
                //        p2 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX + m_stcBlobLead.fBaseWidth / 2, intRoiOrgY + m_stcBlobLead.fBaseCenterY - m_stcBlobLead.fHeight / 2 + m_intBaseOffset);
                //        p3 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX - m_stcBlobLead.fTipWidth / 2, intRoiOrgY + m_stcBlobLead.fTipCenterY + m_stcBlobLead.fHeight / 2 - m_intTipOffset);
                //        p4 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX + m_stcBlobLead.fTipWidth / 2, intRoiOrgY + m_stcBlobLead.fTipCenterY + m_stcBlobLead.fHeight / 2 - m_intTipOffset);
                //        p5 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX, intRoiOrgY + m_stcBlobLead.fBaseCenterY - m_stcBlobLead.fHeight / 2);
                //        p6 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX, intRoiOrgY + m_stcBlobLead.fTipCenterY + m_stcBlobLead.fHeight / 2);
                //        break;
                //    case 1:
                //        p1 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX - m_stcBlobLead.fWidth / 2 + m_intTipOffset, intRoiOrgY + m_stcBlobLead.fTipCenterY - m_stcBlobLead.fTipLength / 2);
                //        p2 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX + m_stcBlobLead.fWidth / 2 - m_intBaseOffset, intRoiOrgY + m_stcBlobLead.fBaseCenterY - m_stcBlobLead.fBaseLength / 2);
                //        p3 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX - m_stcBlobLead.fWidth / 2 + m_intTipOffset, intRoiOrgY + m_stcBlobLead.fTipCenterY + m_stcBlobLead.fTipLength / 2);
                //        p4 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX + m_stcBlobLead.fWidth / 2 - m_intBaseOffset, intRoiOrgY + m_stcBlobLead.fBaseCenterY + m_stcBlobLead.fBaseLength / 2);
                //        p5 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX - m_stcBlobLead.fWidth / 2, intRoiOrgY + m_stcBlobLead.fTipCenterY);
                //        p6 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX + m_stcBlobLead.fWidth / 2, intRoiOrgY + m_stcBlobLead.fBaseCenterY);
                //        break;
                //}
                if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                {
                    p1.X = p1.X * fDrawingScaleX;
                    p1.Y = p1.Y * fDrawingScaleY;
                    p2.X = p2.X * fDrawingScaleX;
                    p2.Y = p2.Y * fDrawingScaleY;
                    p3.X = p3.X * fDrawingScaleX;
                    p3.Y = p3.Y * fDrawingScaleY;
                    p4.X = p4.X * fDrawingScaleX;
                    p4.Y = p4.Y * fDrawingScaleY;
                    p5.X = p5.X * fDrawingScaleX;
                    p5.Y = p5.Y * fDrawingScaleY;
                    p6.X = p6.X * fDrawingScaleX;
                    p6.Y = p6.Y * fDrawingScaleY;
                }


                //g.DrawLine(new Pen(Color.Lime, 1), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                //g.DrawLine(new Pen(Color.Lime, 1), p1.X - 3, p1.Y, p1.X + 3, p1.Y);

                //g.DrawLine(new Pen(Color.Lime, 1), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                //g.DrawLine(new Pen(Color.Lime, 1), p2.X - 3, p2.Y, p2.X + 3, p2.Y);

                //g.DrawLine(new Pen(Color.Lime, 1), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                //g.DrawLine(new Pen(Color.Lime, 1), p3.X - 3, p3.Y, p3.X + 3, p3.Y);

                //g.DrawLine(new Pen(Color.Lime, 1), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                //g.DrawLine(new Pen(Color.Lime, 1), p4.X - 3, p4.Y, p4.X + 3, p4.Y);

                //g.DrawLine(new Pen(Color.Lime, 1), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                //g.DrawLine(new Pen(Color.Lime, 1), p5.X - 3, p5.Y, p5.X + 3, p5.Y);

                //g.DrawLine(new Pen(Color.Lime, 1), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                //g.DrawLine(new Pen(Color.Lime, 1), p6.X - 3, p6.Y, p6.X + 3, p6.Y);

                //g.DrawLine(new Pen(Color.Blue, 1), p5.X, p5.Y, p6.X, p6.Y);

                if (m_stcBlobLead.blnTipStartFound)
                {
                    g.DrawLine(new Pen(Color.Lime, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                    g.DrawLine(new Pen(Color.Lime, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                }
                else
                {
                    g.DrawLine(new Pen(Color.Red, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                    g.DrawLine(new Pen(Color.Red, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                }

                if (m_stcBlobLead.blnTipCenterFound)
                {
                    g.DrawLine(new Pen(Color.Lime, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                    g.DrawLine(new Pen(Color.Lime, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                }
                else
                {
                    g.DrawLine(new Pen(Color.Red, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                    g.DrawLine(new Pen(Color.Red, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                }

                if (m_stcBlobLead.blnTipEndFound)
                {
                    g.DrawLine(new Pen(Color.Lime, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                    g.DrawLine(new Pen(Color.Lime, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                }
                else
                {
                    g.DrawLine(new Pen(Color.Red, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                    g.DrawLine(new Pen(Color.Red, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                }

                if (m_stcBlobLead.blnBaseStartFound)
                {
                    g.DrawLine(new Pen(Color.Lime, 2), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                    g.DrawLine(new Pen(Color.Lime, 2), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                }
                else
                {
                    g.DrawLine(new Pen(Color.Red, 2), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                    g.DrawLine(new Pen(Color.Red, 2), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                }

                if (m_stcBlobLead.blnBaseCenterFound)
                {
                    g.DrawLine(new Pen(Color.Lime, 1), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                    g.DrawLine(new Pen(Color.Lime, 1), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                }
                else
                {
                    g.DrawLine(new Pen(Color.Red, 1), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                    g.DrawLine(new Pen(Color.Red, 1), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                }

                if (m_stcBlobLead.blnBaseEndFound)
                {
                    g.DrawLine(new Pen(Color.Lime, 1), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                    g.DrawLine(new Pen(Color.Lime, 1), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                }
                else
                {
                    g.DrawLine(new Pen(Color.Red, 1), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                    g.DrawLine(new Pen(Color.Red, 1), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                }

                g.DrawLine(new Pen(Color.Blue, 1), p5.X, p5.Y, p2.X, p2.Y);


                // Draw lead lable.
                switch (m_stcBlobLead.intDirection)
                {
                    case 4: // Top
                        g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fTipCenterX + intRoiOrgX - 10) * fDrawingScaleX,
                                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fTipCenterY + intRoiOrgY - 40) * fDrawingScaleY);
                        break;
                    case 2: // Right
                        g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fTipCenterX + intRoiOrgX + 10) * fDrawingScaleX,
                                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fTipCenterY + intRoiOrgY - 15) * fDrawingScaleY);
                        break;
                    case 8: // Bottom
                        g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fTipCenterX + intRoiOrgX - 10) * fDrawingScaleX,
                                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fTipCenterY + intRoiOrgY + 5) * fDrawingScaleY);
                        break;
                    case 1: // Left
                        g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fTipCenterX + intRoiOrgX - 35) * fDrawingScaleX,
                                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fTipCenterY + intRoiOrgY - 15) * fDrawingScaleY);
                        break;
                }
            }

        }

        public void DrawTemplateObjects_Lead3D_Center_PkgToBase(Graphics g, float fDrawingScaleX, float fDrawingScaleY, int intRoiOrgX, int intRoiOrgY, int intROIWidth, int intROIHeight, int intLeadPosition, Color[][] arrColor)
        {
            // Draw center unit package size
            int intTopLeftX = (int)Math.Round(m_pCornerPoint_TopLeft.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
            int intTopLeftY = (int)Math.Round(m_pCornerPoint_TopLeft.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
            int intTopRightX = (int)Math.Round(m_pCornerPoint_TopRight.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
            int intTopRightY = (int)Math.Round(m_pCornerPoint_TopRight.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
            int intBottomLeftX = (int)Math.Round(m_pCornerPoint_BottomLeft.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
            int intBottomleftY = (int)Math.Round(m_pCornerPoint_BottomLeft.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
            int intBottomRightX = (int)Math.Round(m_pCornerPoint_BottomRight.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
            int intBottomRightY = (int)Math.Round(m_pCornerPoint_BottomRight.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
            int intCenterX = (int)Math.Round((intRoiOrgX + intROIWidth / 2) * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
            int intCenterY = (int)Math.Round((intRoiOrgY + intROIHeight / 2) * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);

            float newTLX = intTopLeftX, newTLY = intTopLeftY, newTRX = intTopRightX, newTRY = intTopRightY, newBLX = intBottomLeftX, newBLY = intBottomleftY, newBRX = intBottomRightX, newBRY = intBottomRightY;

            #region Drawing for center Pkg using corner method
            //Math2.RotateWithAngleAccordingToReferencePoint(intCenterX, intCenterY, intTopLeftX, intTopLeftY, -m_fCenterUnitAngle, ref newTLX, ref newTLY);
            //Math2.RotateWithAngleAccordingToReferencePoint(intCenterX, intCenterY, intTopRightX, intTopRightY, -m_fCenterUnitAngle, ref newTRX, ref newTRY);
            //Math2.RotateWithAngleAccordingToReferencePoint(intCenterX, intCenterY, intBottomLeftX, intBottomleftY, -m_fCenterUnitAngle, ref newBLX, ref newBLY);
            //Math2.RotateWithAngleAccordingToReferencePoint(intCenterX, intCenterY, intBottomRightX, intBottomRightY, -m_fCenterUnitAngle, ref newBRX, ref newBRY);

            //g.DrawLine(new Pen(Color.Yellow, 1), newTLX, newTLY, newTRX, newTRY);
            //g.DrawLine(new Pen(Color.Yellow, 1), newTRX, newTRY, newBRX, newBRY);
            //g.DrawLine(new Pen(Color.Yellow, 1), newBRX, newBRY, newBLX, newBLY);
            //g.DrawLine(new Pen(Color.Yellow, 1), newBLX, newBLY, newTLX, newTLY);

            //if (m_intLeadDirection == 0)
            //{
            //    g.DrawLine(new Pen(Color.Cyan, 1), (m_pCornerPoint_Center.X - (m_fCenterUnitWidth / 2) - m_intPkgToBaseTolerance_Left) * fDrawingScaleX,
            //                                       (m_pCornerPoint_Center.Y - (m_fCenterUnitHeight / 2)) * fDrawingScaleY,
            //                                       (m_pCornerPoint_Center.X - (m_fCenterUnitWidth / 2) - m_intPkgToBaseTolerance_Left) * fDrawingScaleX,
            //                                       (m_pCornerPoint_Center.Y + (m_fCenterUnitHeight / 2)) * fDrawingScaleY);

            //    g.DrawLine(new Pen(Color.Cyan, 1), (m_pCornerPoint_Center.X + (m_fCenterUnitWidth / 2) + m_intPkgToBaseTolerance_Right) * fDrawingScaleX,
            //                                     (m_pCornerPoint_Center.Y - (m_fCenterUnitHeight / 2)) * fDrawingScaleY,
            //                                     (m_pCornerPoint_Center.X + (m_fCenterUnitWidth / 2) + m_intPkgToBaseTolerance_Right) * fDrawingScaleX,
            //                                     (m_pCornerPoint_Center.Y + (m_fCenterUnitHeight / 2)) * fDrawingScaleY);
            //}
            //else
            //{
            //    g.DrawLine(new Pen(Color.Cyan, 1), (m_pCornerPoint_Center.X - (m_fCenterUnitWidth / 2)) * fDrawingScaleX,
            //                                       (m_pCornerPoint_Center.Y - (m_fCenterUnitHeight / 2) - m_intPkgToBaseTolerance_Top) * fDrawingScaleY,
            //                                       (m_pCornerPoint_Center.X + (m_fCenterUnitWidth / 2)) * fDrawingScaleX,
            //                                       (m_pCornerPoint_Center.Y - (m_fCenterUnitHeight / 2) - m_intPkgToBaseTolerance_Top) * fDrawingScaleY);

            //    g.DrawLine(new Pen(Color.Cyan, 1), (m_pCornerPoint_Center.X - (m_fCenterUnitWidth / 2)) * fDrawingScaleX,
            //                                       (m_pCornerPoint_Center.Y + (m_fCenterUnitHeight / 2) + m_intPkgToBaseTolerance_Bottom) * fDrawingScaleY,
            //                                       (m_pCornerPoint_Center.X + (m_fCenterUnitWidth / 2)) * fDrawingScaleX,
            //                                       (m_pCornerPoint_Center.Y + (m_fCenterUnitHeight / 2) + m_intPkgToBaseTolerance_Bottom) * fDrawingScaleY);
            //}
            #endregion

            #region Drawing for Center Pkg using pattern matching
            g.DrawLine(new Pen(arrColor[7][0], 1), (newTRX + newBRX) / 2, (newTLY + newTRY) / 2, (newBLX + newTLX) / 2, (newTLY + newTRY) / 2);
            g.DrawLine(new Pen(arrColor[7][0], 1), (newTRX + newBRX) / 2, (newTLY + newTRY) / 2, (newTRX + newBRX) / 2, (newBRY + newBLY) / 2);
            g.DrawLine(new Pen(arrColor[7][0], 1), (newBLX + newTLX) / 2, (newBRY + newBLY) / 2, (newTRX + newBRX) / 2, (newBRY + newBLY) / 2);
            g.DrawLine(new Pen(arrColor[7][0], 1), (newBLX + newTLX) / 2, (newBRY + newBLY) / 2, (newBLX + newTLX) / 2, (newTLY + newTRY) / 2);

            if (m_intLeadDirection == 0)
            {
                g.DrawLine(new Pen(arrColor[1][0], 1), (((m_pCornerPoint_BottomLeft.X + m_pCornerPoint_TopLeft.X) / 2) - m_intPkgToBaseTolerance_Left) * fDrawingScaleX,
                                                   ((m_pCornerPoint_TopLeft.Y + m_pCornerPoint_TopRight.Y) / 2) * fDrawingScaleY,
                                                   (((m_pCornerPoint_BottomLeft.X + m_pCornerPoint_TopLeft.X) / 2) - m_intPkgToBaseTolerance_Left) * fDrawingScaleX,
                                                   ((m_pCornerPoint_BottomRight.Y + m_pCornerPoint_BottomLeft.Y) / 2) * fDrawingScaleY);

                g.DrawLine(new Pen(arrColor[1][0], 1), (((m_pCornerPoint_TopRight.X + m_pCornerPoint_BottomRight.X) / 2) + m_intPkgToBaseTolerance_Right) * fDrawingScaleX,
                                                 ((m_pCornerPoint_TopLeft.Y + m_pCornerPoint_TopRight.Y) / 2) * fDrawingScaleY,
                                                 (((m_pCornerPoint_TopRight.X + m_pCornerPoint_BottomRight.X) / 2) + m_intPkgToBaseTolerance_Right) * fDrawingScaleX,
                                                 ((m_pCornerPoint_BottomRight.Y + m_pCornerPoint_BottomLeft.Y) / 2) * fDrawingScaleY);
            }
            else
            {
                g.DrawLine(new Pen(arrColor[1][0], 1), ((m_pCornerPoint_BottomLeft.X + m_pCornerPoint_TopLeft.X) / 2) * fDrawingScaleX,
                                                   (((m_pCornerPoint_TopLeft.Y + m_pCornerPoint_TopRight.Y) / 2) - m_intPkgToBaseTolerance_Top) * fDrawingScaleY,
                                                   ((m_pCornerPoint_TopRight.X + m_pCornerPoint_BottomRight.X) / 2) * fDrawingScaleX,
                                                   (((m_pCornerPoint_TopLeft.Y + m_pCornerPoint_TopRight.Y) / 2) - m_intPkgToBaseTolerance_Top) * fDrawingScaleY);

                g.DrawLine(new Pen(arrColor[1][0], 1), ((m_pCornerPoint_BottomLeft.X + m_pCornerPoint_TopLeft.X) / 2) * fDrawingScaleX,
                                                   (((m_pCornerPoint_BottomRight.Y + m_pCornerPoint_BottomLeft.Y) / 2) + m_intPkgToBaseTolerance_Bottom) * fDrawingScaleY,
                                                   ((m_pCornerPoint_TopRight.X + m_pCornerPoint_BottomRight.X) / 2) * fDrawingScaleX,
                                                   (((m_pCornerPoint_BottomRight.Y + m_pCornerPoint_BottomLeft.Y) / 2) + m_intPkgToBaseTolerance_Bottom) * fDrawingScaleY);
            }
            #endregion
            // Draw center lead tip, base and, width and length.
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                System.Drawing.PointF p1 = new PointF();
                System.Drawing.PointF p2 = new PointF();
                System.Drawing.PointF p3 = new PointF();
                System.Drawing.PointF p4 = new PointF();
                System.Drawing.PointF p5 = new PointF();
                System.Drawing.PointF p6 = new PointF();

                switch (m_stcBlobLead.intDirection)
                {
                    case 4:// Top
                        p1 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX - m_stcBlobLead.fTipWidth / 2, intRoiOrgY + m_stcBlobLead.fTipCenterY + m_intTipOffset);
                        p2 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX, intRoiOrgY + m_stcBlobLead.fTipCenterY);
                        p3 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX + m_stcBlobLead.fTipWidth / 2, intRoiOrgY + m_stcBlobLead.fTipCenterY + m_intTipOffset);
                        p4 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX - m_stcBlobLead.fBaseWidth / 2, intRoiOrgY + m_stcBlobLead.fBaseCenterY - m_intBaseOffset);
                        p5 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX, intRoiOrgY + m_stcBlobLead.fBaseCenterY);
                        p6 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX + m_stcBlobLead.fBaseWidth / 2, intRoiOrgY + m_stcBlobLead.fBaseCenterY - m_intBaseOffset);
                        break;
                    case 2:// Right
                        p1 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX - m_intTipOffset, intRoiOrgY + m_stcBlobLead.fTipCenterY - m_stcBlobLead.fTipWidth / 2);
                        p2 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX, intRoiOrgY + m_stcBlobLead.fTipCenterY);
                        p3 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX - m_intTipOffset, intRoiOrgY + m_stcBlobLead.fTipCenterY + m_stcBlobLead.fTipWidth / 2);
                        p4 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX + m_intBaseOffset, intRoiOrgY + m_stcBlobLead.fBaseCenterY - m_stcBlobLead.fBaseWidth / 2);
                        p5 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX, intRoiOrgY + m_stcBlobLead.fBaseCenterY);
                        p6 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX + m_intBaseOffset, intRoiOrgY + m_stcBlobLead.fBaseCenterY + m_stcBlobLead.fBaseWidth / 2);
                        break;
                    case 8:// Bottom
                        p1 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX - m_stcBlobLead.fTipWidth / 2, intRoiOrgY + m_stcBlobLead.fTipCenterY - m_intTipOffset);
                        p2 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX, intRoiOrgY + m_stcBlobLead.fTipCenterY);
                        p3 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX + m_stcBlobLead.fTipWidth / 2, intRoiOrgY + m_stcBlobLead.fTipCenterY - m_intTipOffset);
                        p4 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX - m_stcBlobLead.fBaseWidth / 2, intRoiOrgY + m_stcBlobLead.fBaseCenterY + m_intBaseOffset);
                        p5 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX, intRoiOrgY + m_stcBlobLead.fBaseCenterY);
                        p6 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX + m_stcBlobLead.fBaseWidth / 2, intRoiOrgY + m_stcBlobLead.fBaseCenterY + m_intBaseOffset);
                        break;
                    case 1:// Left
                        p1 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX + m_intTipOffset, intRoiOrgY + m_stcBlobLead.fTipCenterY - m_stcBlobLead.fTipWidth / 2);
                        p2 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX, intRoiOrgY + m_stcBlobLead.fTipCenterY);
                        p3 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX + m_intTipOffset, intRoiOrgY + m_stcBlobLead.fTipCenterY + m_stcBlobLead.fTipWidth / 2);
                        p4 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX - m_intBaseOffset, intRoiOrgY + m_stcBlobLead.fBaseCenterY - m_stcBlobLead.fBaseWidth / 2);
                        p5 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX, intRoiOrgY + m_stcBlobLead.fBaseCenterY);
                        p6 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX - m_intBaseOffset, intRoiOrgY + m_stcBlobLead.fBaseCenterY + m_stcBlobLead.fBaseWidth / 2);
                        break;
                }

                //switch (m_stcBlobLead.intDirection)
                //{
                //    case 4:
                //        p1 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX - m_stcBlobLead.fTipWidth / 2, intRoiOrgY + m_stcBlobLead.fTipCenterY - (m_stcBlobLead.fHeight / 2) + m_intTipOffset);
                //        p2 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX + m_stcBlobLead.fTipWidth / 2, intRoiOrgY + m_stcBlobLead.fTipCenterY - (m_stcBlobLead.fHeight / 2) + m_intTipOffset);
                //        p3 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX - m_stcBlobLead.fBaseWidth / 2, intRoiOrgY + m_stcBlobLead.fBaseCenterY + (m_stcBlobLead.fHeight / 2) - m_intBaseOffset);
                //        p4 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX + m_stcBlobLead.fBaseWidth / 2, intRoiOrgY + m_stcBlobLead.fBaseCenterY + (m_stcBlobLead.fHeight / 2) - m_intBaseOffset);
                //        p5 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX, intRoiOrgY + m_stcBlobLead.fTipCenterY - (m_stcBlobLead.fHeight / 2));
                //        p6 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX, intRoiOrgY + m_stcBlobLead.fBaseCenterY + (m_stcBlobLead.fHeight / 2));
                //        break;
                //    case 2:
                //        p1 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX - m_stcBlobLead.fWidth / 2 + m_intBaseOffset, intRoiOrgY + m_stcBlobLead.fBaseCenterY - m_stcBlobLead.fBaseLength / 2);
                //        p2 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX + m_stcBlobLead.fWidth / 2 - m_intTipOffset, intRoiOrgY + m_stcBlobLead.fTipCenterY - m_stcBlobLead.fTipLength / 2);
                //        p3 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX - m_stcBlobLead.fWidth / 2 + m_intBaseOffset, intRoiOrgY + m_stcBlobLead.fBaseCenterY + m_stcBlobLead.fBaseLength / 2);
                //        p4 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX + m_stcBlobLead.fWidth / 2 - m_intTipOffset, intRoiOrgY + m_stcBlobLead.fTipCenterY + m_stcBlobLead.fTipLength / 2);
                //        p5 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX - m_stcBlobLead.fWidth / 2, intRoiOrgY + m_stcBlobLead.fBaseCenterY);
                //        p6 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX + m_stcBlobLead.fWidth / 2, intRoiOrgY + m_stcBlobLead.fTipCenterY);
                //        break;
                //    case 8:
                //        p1 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX - m_stcBlobLead.fBaseWidth / 2, intRoiOrgY + m_stcBlobLead.fBaseCenterY - m_stcBlobLead.fHeight / 2 + m_intBaseOffset);
                //        p2 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX + m_stcBlobLead.fBaseWidth / 2, intRoiOrgY + m_stcBlobLead.fBaseCenterY - m_stcBlobLead.fHeight / 2 + m_intBaseOffset);
                //        p3 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX - m_stcBlobLead.fTipWidth / 2, intRoiOrgY + m_stcBlobLead.fTipCenterY + m_stcBlobLead.fHeight / 2 - m_intTipOffset);
                //        p4 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX + m_stcBlobLead.fTipWidth / 2, intRoiOrgY + m_stcBlobLead.fTipCenterY + m_stcBlobLead.fHeight / 2 - m_intTipOffset);
                //        p5 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX, intRoiOrgY + m_stcBlobLead.fBaseCenterY - m_stcBlobLead.fHeight / 2);
                //        p6 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX, intRoiOrgY + m_stcBlobLead.fTipCenterY + m_stcBlobLead.fHeight / 2);
                //        break;
                //    case 1:
                //        p1 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX - m_stcBlobLead.fWidth / 2 + m_intTipOffset, intRoiOrgY + m_stcBlobLead.fTipCenterY - m_stcBlobLead.fTipLength / 2);
                //        p2 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX + m_stcBlobLead.fWidth / 2 - m_intBaseOffset, intRoiOrgY + m_stcBlobLead.fBaseCenterY - m_stcBlobLead.fBaseLength / 2);
                //        p3 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX - m_stcBlobLead.fWidth / 2 + m_intTipOffset, intRoiOrgY + m_stcBlobLead.fTipCenterY + m_stcBlobLead.fTipLength / 2);
                //        p4 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX + m_stcBlobLead.fWidth / 2 - m_intBaseOffset, intRoiOrgY + m_stcBlobLead.fBaseCenterY + m_stcBlobLead.fBaseLength / 2);
                //        p5 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX - m_stcBlobLead.fWidth / 2, intRoiOrgY + m_stcBlobLead.fTipCenterY);
                //        p6 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX + m_stcBlobLead.fWidth / 2, intRoiOrgY + m_stcBlobLead.fBaseCenterY);
                //        break;
                //}
                if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                {
                    p1.X = p1.X * fDrawingScaleX;
                    p1.Y = p1.Y * fDrawingScaleY;
                    p2.X = p2.X * fDrawingScaleX;
                    p2.Y = p2.Y * fDrawingScaleY;
                    p3.X = p3.X * fDrawingScaleX;
                    p3.Y = p3.Y * fDrawingScaleY;
                    p4.X = p4.X * fDrawingScaleX;
                    p4.Y = p4.Y * fDrawingScaleY;
                    p5.X = p5.X * fDrawingScaleX;
                    p5.Y = p5.Y * fDrawingScaleY;
                    p6.X = p6.X * fDrawingScaleX;
                    p6.Y = p6.Y * fDrawingScaleY;
                }


                //g.DrawLine(new Pen(Color.Lime, 1), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                //g.DrawLine(new Pen(Color.Lime, 1), p1.X - 3, p1.Y, p1.X + 3, p1.Y);

                //g.DrawLine(new Pen(Color.Lime, 1), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                //g.DrawLine(new Pen(Color.Lime, 1), p2.X - 3, p2.Y, p2.X + 3, p2.Y);

                //g.DrawLine(new Pen(Color.Lime, 1), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                //g.DrawLine(new Pen(Color.Lime, 1), p3.X - 3, p3.Y, p3.X + 3, p3.Y);

                //g.DrawLine(new Pen(Color.Lime, 1), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                //g.DrawLine(new Pen(Color.Lime, 1), p4.X - 3, p4.Y, p4.X + 3, p4.Y);

                //g.DrawLine(new Pen(Color.Lime, 1), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                //g.DrawLine(new Pen(Color.Lime, 1), p5.X - 3, p5.Y, p5.X + 3, p5.Y);

                //g.DrawLine(new Pen(Color.Lime, 1), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                //g.DrawLine(new Pen(Color.Lime, 1), p6.X - 3, p6.Y, p6.X + 3, p6.Y);

                //g.DrawLine(new Pen(Color.Blue, 1), p5.X, p5.Y, p6.X, p6.Y);

                if (m_stcBlobLead.blnTipStartFound)
                {
                    g.DrawLine(new Pen(Color.Lime, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                    g.DrawLine(new Pen(Color.Lime, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                }
                else
                {
                    g.DrawLine(new Pen(Color.Red, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                    g.DrawLine(new Pen(Color.Red, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                }

                if (m_stcBlobLead.blnTipCenterFound)
                {
                    g.DrawLine(new Pen(Color.Lime, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                    g.DrawLine(new Pen(Color.Lime, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                }
                else
                {
                    g.DrawLine(new Pen(Color.Red, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                    g.DrawLine(new Pen(Color.Red, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                }

                if (m_stcBlobLead.blnTipEndFound)
                {
                    g.DrawLine(new Pen(Color.Lime, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                    g.DrawLine(new Pen(Color.Lime, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                }
                else
                {
                    g.DrawLine(new Pen(Color.Red, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                    g.DrawLine(new Pen(Color.Red, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                }

                if (m_stcBlobLead.blnBaseStartFound)
                {
                    g.DrawLine(new Pen(Color.Lime, 2), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                    g.DrawLine(new Pen(Color.Lime, 2), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                }
                else
                {
                    g.DrawLine(new Pen(Color.Red, 2), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                    g.DrawLine(new Pen(Color.Red, 2), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                }

                if (m_stcBlobLead.blnBaseCenterFound)
                {
                    g.DrawLine(new Pen(Color.Lime, 1), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                    g.DrawLine(new Pen(Color.Lime, 1), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                }
                else
                {
                    g.DrawLine(new Pen(Color.Red, 1), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                    g.DrawLine(new Pen(Color.Red, 1), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                }

                if (m_stcBlobLead.blnBaseEndFound)
                {
                    g.DrawLine(new Pen(Color.Lime, 1), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                    g.DrawLine(new Pen(Color.Lime, 1), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                }
                else
                {
                    g.DrawLine(new Pen(Color.Red, 1), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                    g.DrawLine(new Pen(Color.Red, 1), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                }

                g.DrawLine(new Pen(Color.Blue, 1), p5.X, p5.Y, p2.X, p2.Y);


                // Draw lead lable.
                switch (m_stcBlobLead.intDirection)
                {
                    case 4: // Top
                        g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fTipCenterX + intRoiOrgX - 10) * fDrawingScaleX,
                                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fTipCenterY + intRoiOrgY - 40) * fDrawingScaleY);
                        break;
                    case 2: // Right
                        g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fTipCenterX + intRoiOrgX + 10) * fDrawingScaleX,
                                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fTipCenterY + intRoiOrgY - 15) * fDrawingScaleY);
                        break;
                    case 8: // Bottom
                        g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fTipCenterX + intRoiOrgX - 10) * fDrawingScaleX,
                                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fTipCenterY + intRoiOrgY + 5) * fDrawingScaleY);
                        break;
                    case 1: // Left
                        g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fTipCenterX + intRoiOrgX - 35) * fDrawingScaleX,
                                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fTipCenterY + intRoiOrgY - 15) * fDrawingScaleY);
                        break;
                }
            }

        }
        public void DrawInspectionObjects_Lead3D_Center_PkgToBase(Graphics g, float fDrawingScaleX, float fDrawingScaleY, ROI objROI, int intLeadPosition, Color[][] arrColor)
        {

            lock (m_objLockBlobs)
            {
                if (!m_blnPatternMatchSuccess && !m_blnLock)
                {
                    objROI.DrawROI(g, fDrawingScaleX, fDrawingScaleY, false, 0, Color.Red);
                    return;
                }

                bool blnFail = false;
                int intRoiOrgX = objROI.ref_ROITotalX;
                int intRoiOrgY = objROI.ref_ROITotalY;
                int intROIWidth = objROI.ref_ROIWidth;
                int intROIHeight = objROI.ref_ROIHeight;
                // Draw center unit package size
                int intTopLeftX = (int)Math.Round(m_pCornerPoint_TopLeft.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                int intTopLeftY = (int)Math.Round(m_pCornerPoint_TopLeft.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                int intTopRightX = (int)Math.Round(m_pCornerPoint_TopRight.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                int intTopRightY = (int)Math.Round(m_pCornerPoint_TopRight.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                int intBottomLeftX = (int)Math.Round(m_pCornerPoint_BottomLeft.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                int intBottomleftY = (int)Math.Round(m_pCornerPoint_BottomLeft.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                int intBottomRightX = (int)Math.Round(m_pCornerPoint_BottomRight.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                int intBottomRightY = (int)Math.Round(m_pCornerPoint_BottomRight.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);

                int intCenterX = (int)Math.Round((intRoiOrgX + intROIWidth / 2) * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                int intCenterY = (int)Math.Round((intRoiOrgY + intROIHeight / 2) * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);

                float newTLX = intTopLeftX, newTLY = intTopLeftY, newTRX = intTopRightX, newTRY = intTopRightY, newBLX = intBottomLeftX, newBLY = intBottomleftY, newBRX = intBottomRightX, newBRY = intBottomRightY;

                #region Drawing for Center Pkg using corner method
                //Math2.RotateWithAngleAccordingToReferencePoint(intCenterX, intCenterY, intTopLeftX, intTopLeftY, -m_fCenterUnitAngle, ref newTLX, ref newTLY);
                //Math2.RotateWithAngleAccordingToReferencePoint(intCenterX, intCenterY, intTopRightX, intTopRightY, -m_fCenterUnitAngle, ref newTRX, ref newTRY);
                //Math2.RotateWithAngleAccordingToReferencePoint(intCenterX, intCenterY, intBottomLeftX, intBottomleftY, -m_fCenterUnitAngle, ref newBLX, ref newBLY);
                //Math2.RotateWithAngleAccordingToReferencePoint(intCenterX, intCenterY, intBottomRightX, intBottomRightY, -m_fCenterUnitAngle, ref newBRX, ref newBRY);

                //g.DrawLine(new Pen(Color.Yellow, 1), newTLX, newTLY, newTRX, newTRY);
                //g.DrawLine(new Pen(Color.Yellow, 1), newTRX, newTRY, newBRX, newBRY);
                //g.DrawLine(new Pen(Color.Yellow, 1), newBRX, newBRY, newBLX, newBLY);
                //g.DrawLine(new Pen(Color.Yellow, 1), newBLX, newBLY, newTLX, newTLY);

                //if (m_intLeadDirection == 0)
                //{
                //    g.DrawLine(new Pen(Color.Cyan, 1), (m_pCornerPoint_Center.X - (m_fCenterUnitWidth / 2) - m_intPkgToBaseTolerance_Left) * fDrawingScaleX,
                //                                       (m_pCornerPoint_Center.Y - (m_fCenterUnitHeight / 2)) * fDrawingScaleY,
                //                                       (m_pCornerPoint_Center.X - (m_fCenterUnitWidth / 2) - m_intPkgToBaseTolerance_Left) * fDrawingScaleX,
                //                                       (m_pCornerPoint_Center.Y + (m_fCenterUnitHeight / 2)) * fDrawingScaleY);

                //    g.DrawLine(new Pen(Color.Cyan, 1), (m_pCornerPoint_Center.X + (m_fCenterUnitWidth / 2) + m_intPkgToBaseTolerance_Right) * fDrawingScaleX,
                //                                     (m_pCornerPoint_Center.Y - (m_fCenterUnitHeight / 2)) * fDrawingScaleY,
                //                                     (m_pCornerPoint_Center.X + (m_fCenterUnitWidth / 2) + m_intPkgToBaseTolerance_Right) * fDrawingScaleX,
                //                                     (m_pCornerPoint_Center.Y + (m_fCenterUnitHeight / 2)) * fDrawingScaleY);
                //}
                //else
                //{
                //    g.DrawLine(new Pen(Color.Cyan, 1), (m_pCornerPoint_Center.X - (m_fCenterUnitWidth / 2)) * fDrawingScaleX,
                //                                       (m_pCornerPoint_Center.Y - (m_fCenterUnitHeight / 2) - m_intPkgToBaseTolerance_Top) * fDrawingScaleY,
                //                                       (m_pCornerPoint_Center.X + (m_fCenterUnitWidth / 2)) * fDrawingScaleX,
                //                                       (m_pCornerPoint_Center.Y - (m_fCenterUnitHeight / 2) - m_intPkgToBaseTolerance_Top) * fDrawingScaleY);

                //    g.DrawLine(new Pen(Color.Cyan, 1), (m_pCornerPoint_Center.X - (m_fCenterUnitWidth / 2)) * fDrawingScaleX,
                //                                       (m_pCornerPoint_Center.Y + (m_fCenterUnitHeight / 2) + m_intPkgToBaseTolerance_Bottom) * fDrawingScaleY,
                //                                       (m_pCornerPoint_Center.X + (m_fCenterUnitWidth / 2)) * fDrawingScaleX,
                //                                       (m_pCornerPoint_Center.Y + (m_fCenterUnitHeight / 2) + m_intPkgToBaseTolerance_Bottom) * fDrawingScaleY);
                //}
                #endregion
                #region Drawing for Center Pkg using pattern matching
                g.DrawLine(new Pen(arrColor[7][0], 1), (newTRX + newBRX) / 2, (newTLY + newTRY) / 2, (newBLX + newTLX) / 2, (newTLY + newTRY) / 2);
                g.DrawLine(new Pen(arrColor[7][0], 1), (newTRX + newBRX) / 2, (newTLY + newTRY) / 2, (newTRX + newBRX) / 2, (newBRY + newBLY) / 2);
                g.DrawLine(new Pen(arrColor[7][0], 1), (newBLX + newTLX) / 2, (newBRY + newBLY) / 2, (newTRX + newBRX) / 2, (newBRY + newBLY) / 2);
                g.DrawLine(new Pen(arrColor[7][0], 1), (newBLX + newTLX) / 2, (newBRY + newBLY) / 2, (newBLX + newTLX) / 2, (newTLY + newTRY) / 2);

                if (m_intLeadDirection == 0)
                {
                    g.DrawLine(new Pen(arrColor[1][0], 1), (((m_pCornerPoint_BottomLeft.X + m_pCornerPoint_TopLeft.X) / 2) - m_intPkgToBaseTolerance_Left) * fDrawingScaleX,
                                                       ((m_pCornerPoint_TopLeft.Y + m_pCornerPoint_TopRight.Y) / 2) * fDrawingScaleY,
                                                       (((m_pCornerPoint_BottomLeft.X + m_pCornerPoint_TopLeft.X) / 2) - m_intPkgToBaseTolerance_Left) * fDrawingScaleX,
                                                       ((m_pCornerPoint_BottomRight.Y + m_pCornerPoint_BottomLeft.Y) / 2) * fDrawingScaleY);

                    g.DrawLine(new Pen(arrColor[1][0], 1), (((m_pCornerPoint_TopRight.X + m_pCornerPoint_BottomRight.X) / 2) + m_intPkgToBaseTolerance_Right) * fDrawingScaleX,
                                                     ((m_pCornerPoint_TopLeft.Y + m_pCornerPoint_TopRight.Y) / 2) * fDrawingScaleY,
                                                     (((m_pCornerPoint_TopRight.X + m_pCornerPoint_BottomRight.X) / 2) + m_intPkgToBaseTolerance_Right) * fDrawingScaleX,
                                                     ((m_pCornerPoint_BottomRight.Y + m_pCornerPoint_BottomLeft.Y) / 2) * fDrawingScaleY);
                }
                else
                {
                    g.DrawLine(new Pen(arrColor[1][0], 1), ((m_pCornerPoint_BottomLeft.X + m_pCornerPoint_TopLeft.X) / 2) * fDrawingScaleX,
                                                       (((m_pCornerPoint_TopLeft.Y + m_pCornerPoint_TopRight.Y) / 2) - m_intPkgToBaseTolerance_Top) * fDrawingScaleY,
                                                       ((m_pCornerPoint_TopRight.X + m_pCornerPoint_BottomRight.X) / 2) * fDrawingScaleX,
                                                       (((m_pCornerPoint_TopLeft.Y + m_pCornerPoint_TopRight.Y) / 2) - m_intPkgToBaseTolerance_Top) * fDrawingScaleY);

                    g.DrawLine(new Pen(arrColor[1][0], 1), ((m_pCornerPoint_BottomLeft.X + m_pCornerPoint_TopLeft.X) / 2) * fDrawingScaleX,
                                                       (((m_pCornerPoint_BottomRight.Y + m_pCornerPoint_BottomLeft.Y) / 2) + m_intPkgToBaseTolerance_Bottom) * fDrawingScaleY,
                                                       ((m_pCornerPoint_TopRight.X + m_pCornerPoint_BottomRight.X) / 2) * fDrawingScaleX,
                                                       (((m_pCornerPoint_BottomRight.Y + m_pCornerPoint_BottomLeft.Y) / 2) + m_intPkgToBaseTolerance_Bottom) * fDrawingScaleY);
                }
                #endregion

                if (m_blnFailPosition)
                    return;

                // Draw center lead tip, base and, width and length.
                for (int i = 0; i < m_arrSampleBlobLeads.Length; i++)
                {
                    if (i >= m_arrTemplateBlobLeads.Count)
                        continue;

                    m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                    m_stcSampleBlobLead = (SampleBlobsFeatures)m_arrSampleBlobLeads[i];

                    System.Drawing.PointF p1 = new PointF();
                    System.Drawing.PointF p2 = new PointF();
                    System.Drawing.PointF p3 = new PointF();
                    System.Drawing.PointF p4 = new PointF();
                    System.Drawing.PointF p5 = new PointF();
                    System.Drawing.PointF p6 = new PointF();

                    switch (m_stcBlobLead.intDirection)
                    {
                        case 4: // Top
                            p1 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fTipCenterX - m_stcSampleBlobLead.fTipWidth / 2, intRoiOrgY + m_stcSampleBlobLead.fTipCenterY + m_intTipOffset);
                            p2 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fTipCenterX, intRoiOrgY + m_stcSampleBlobLead.fTipCenterY);
                            p3 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fTipCenterX + m_stcSampleBlobLead.fTipWidth / 2, intRoiOrgY + m_stcSampleBlobLead.fTipCenterY + m_intTipOffset);
                            p4 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fBaseCenterX - m_stcSampleBlobLead.fBaseWidth / 2, intRoiOrgY + m_stcSampleBlobLead.fBaseCenterY - m_intBaseOffset);
                            p5 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fBaseCenterX, intRoiOrgY + m_stcSampleBlobLead.fBaseCenterY);
                            p6 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fBaseCenterX + m_stcSampleBlobLead.fBaseWidth / 2, intRoiOrgY + m_stcSampleBlobLead.fBaseCenterY - m_intBaseOffset);
                            break;
                        case 2: // Right
                            p1 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fTipCenterX - m_intTipOffset, intRoiOrgY + m_stcSampleBlobLead.fTipCenterY - m_stcSampleBlobLead.fTipWidth / 2);
                            p2 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fTipCenterX, intRoiOrgY + m_stcSampleBlobLead.fTipCenterY);
                            p3 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fTipCenterX - m_intTipOffset, intRoiOrgY + m_stcSampleBlobLead.fTipCenterY + m_stcSampleBlobLead.fTipWidth / 2);
                            p4 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fBaseCenterX + m_intBaseOffset, intRoiOrgY + m_stcSampleBlobLead.fBaseCenterY - m_stcSampleBlobLead.fBaseWidth / 2);
                            p5 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fBaseCenterX, intRoiOrgY + m_stcSampleBlobLead.fBaseCenterY);
                            p6 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fBaseCenterX + m_intBaseOffset, intRoiOrgY + m_stcSampleBlobLead.fBaseCenterY + m_stcSampleBlobLead.fBaseWidth / 2);
                            break;
                        case 8: // Bottom
                            p1 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fTipCenterX - m_stcSampleBlobLead.fTipWidth / 2, intRoiOrgY + m_stcSampleBlobLead.fTipCenterY - m_intTipOffset);
                            p2 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fTipCenterX, intRoiOrgY + m_stcSampleBlobLead.fTipCenterY);
                            p3 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fTipCenterX + m_stcSampleBlobLead.fTipWidth / 2, intRoiOrgY + m_stcSampleBlobLead.fTipCenterY - m_intTipOffset);
                            p4 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fBaseCenterX - m_stcSampleBlobLead.fBaseWidth / 2, intRoiOrgY + m_stcSampleBlobLead.fBaseCenterY + m_intBaseOffset);
                            p5 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fBaseCenterX, intRoiOrgY + m_stcSampleBlobLead.fBaseCenterY);
                            p6 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fBaseCenterX + m_stcSampleBlobLead.fBaseWidth / 2, intRoiOrgY + m_stcSampleBlobLead.fBaseCenterY + m_intBaseOffset);
                            break;
                        case 1: // Left
                            p1 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fTipCenterX + m_intTipOffset, intRoiOrgY + m_stcSampleBlobLead.fTipCenterY - m_stcSampleBlobLead.fTipWidth / 2);
                            p2 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fTipCenterX, intRoiOrgY + m_stcSampleBlobLead.fTipCenterY);
                            p3 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fTipCenterX + m_intTipOffset, intRoiOrgY + m_stcSampleBlobLead.fTipCenterY + m_stcSampleBlobLead.fTipWidth / 2);
                            p4 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fBaseCenterX - m_intBaseOffset, intRoiOrgY + m_stcSampleBlobLead.fBaseCenterY - m_stcSampleBlobLead.fBaseWidth / 2);
                            p5 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fBaseCenterX, intRoiOrgY + m_stcSampleBlobLead.fBaseCenterY);
                            p6 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fBaseCenterX - m_intBaseOffset, intRoiOrgY + m_stcSampleBlobLead.fBaseCenterY + m_stcSampleBlobLead.fBaseWidth / 2);
                            break;
                    }

                    if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                    {
                        p1.X = p1.X * fDrawingScaleX;
                        p1.Y = p1.Y * fDrawingScaleY;
                        p2.X = p2.X * fDrawingScaleX;
                        p2.Y = p2.Y * fDrawingScaleY;
                        p3.X = p3.X * fDrawingScaleX;
                        p3.Y = p3.Y * fDrawingScaleY;
                        p4.X = p4.X * fDrawingScaleX;
                        p4.Y = p4.Y * fDrawingScaleY;
                        p5.X = p5.X * fDrawingScaleX;
                        p5.Y = p5.Y * fDrawingScaleY;
                        p6.X = p6.X * fDrawingScaleX;
                        p6.Y = p6.Y * fDrawingScaleY;
                    }

                    //Pen colorPen;
                    //if (m_arrSampleBlobLeads[i].intFailMask == 0)
                    //{
                    //    colorPen = new Pen(Color.Lime, 1);
                    //}
                    //else
                    //{
                    //    colorPen = new Pen(Color.Red, 1);
                    //}
                    //g.DrawLine(colorPen, p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                    //g.DrawLine(colorPen, p1.X - 3, p1.Y, p1.X + 3, p1.Y);

                    //g.DrawLine(colorPen, p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                    //g.DrawLine(colorPen, p2.X - 3, p2.Y, p2.X + 3, p2.Y);

                    //g.DrawLine(colorPen, p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                    //g.DrawLine(colorPen, p3.X - 3, p3.Y, p3.X + 3, p3.Y);

                    //g.DrawLine(colorPen, p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                    //g.DrawLine(colorPen, p4.X - 3, p4.Y, p4.X + 3, p4.Y);

                    //g.DrawLine(colorPen, p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                    //g.DrawLine(colorPen, p5.X - 3, p5.Y, p5.X + 3, p5.Y);

                    //g.DrawLine(colorPen, p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                    //g.DrawLine(colorPen, p6.X - 3, p6.Y, p6.X + 3, p6.Y);

                    //g.DrawLine(new Pen(Color.Blue, 1), p5.X, p5.Y, p6.X, p6.Y);

                    switch (m_stcSampleBlobLead.intDirection)
                    {
                        case 4: // Top
                            //if (m_stcSampleBlobLead.intFailMask > 0 && ((m_stcSampleBlobLead.intFailMask & 0x01) == 0) && ((m_stcSampleBlobLead.intFailMask & 0x02) == 0)) //((m_stcSampleBlobLead.intFailMask & 0x40) > 0)   
                            if (m_stcSampleBlobLead.intFailMask > 0 && ((m_stcSampleBlobLead.intFailMask & 0x01) == 0) && ((m_stcSampleBlobLead.intFailMask & 0x02) == 0) && ((m_stcSampleBlobLead.intFailMask & 0x400000) == 0) ||
                                ((m_arrFailResultMask[m_intLeadROIDirection] & 0x04) > 0) || ((m_arrFailResultMask[m_intLeadROIDirection] & 0x1000) > 0) || ((m_arrFailResultMask[m_intLeadROIDirection] & 0x2000) > 0) || ((m_arrFailResultMask[m_intLeadROIDirection] & 0x4000) > 0) || ((m_arrFailResultMask[m_intLeadROIDirection] & 0x800) > 0) ||
                                ((m_arrFailResultMask[1] & 0x04) > 0) || ((m_arrFailResultMask[1] & 0x1000) > 0) || ((m_arrFailResultMask[1] & 0x2000) > 0) || ((m_arrFailResultMask[1] & 0x4000) > 0) || ((m_arrFailResultMask[1] & 0x800) > 0))
                            {
                                g.DrawRectangle(new Pen(Color.Red, 1), p1.X - 5, p2.Y - 5, p3.X - p1.X + 10, Math.Max(p1.Y, p3.Y) - p2.Y + 10);
                                if (!blnFail)
                                    blnFail = true;
                            }
                            else
                            {
                                g.DrawRectangle(new Pen(Color.Lime, 1), p1.X - 5, p2.Y - 5, p3.X - p1.X + 10, Math.Max(p1.Y, p3.Y) - p2.Y + 10);
                            }
                            break;
                        case 2: // Right
                            //if (m_stcSampleBlobLead.intFailMask > 0 && ((m_stcSampleBlobLead.intFailMask & 0x01) == 0) && ((m_stcSampleBlobLead.intFailMask & 0x02) == 0)) //((m_stcSampleBlobLead.intFailMask & 0x40) > 0)
                            if (m_stcSampleBlobLead.intFailMask > 0 && ((m_stcSampleBlobLead.intFailMask & 0x01) == 0) && ((m_stcSampleBlobLead.intFailMask & 0x02) == 0) && ((m_stcSampleBlobLead.intFailMask & 0x400000) == 0) ||
                                ((m_arrFailResultMask[m_intLeadROIDirection] & 0x04) > 0) || ((m_arrFailResultMask[m_intLeadROIDirection] & 0x1000) > 0) || ((m_arrFailResultMask[m_intLeadROIDirection] & 0x2000) > 0) || ((m_arrFailResultMask[m_intLeadROIDirection] & 0x4000) > 0) || ((m_arrFailResultMask[m_intLeadROIDirection] & 0x800) > 0) ||
                                ((m_arrFailResultMask[2] & 0x04) > 0) || ((m_arrFailResultMask[2] & 0x1000) > 0) || ((m_arrFailResultMask[2] & 0x2000) > 0) || ((m_arrFailResultMask[2] & 0x4000) > 0) || ((m_arrFailResultMask[2] & 0x800) > 0))
                            {
                                g.DrawRectangle(new Pen(Color.Red, 1), Math.Min(p3.X, p1.X) - 5, p1.Y - 5, p2.X - Math.Min(p3.X, p1.X) + 10, p3.Y - p1.Y + 10);
                                if (!blnFail)
                                    blnFail = true;
                            }
                            else
                            {
                                g.DrawRectangle(new Pen(Color.Lime, 1), Math.Min(p3.X, p1.X) - 5, p1.Y - 5, p2.X - Math.Min(p3.X, p1.X) + 10, p3.Y - p1.Y + 10);
                            }
                            break;
                        case 8: // Bottom
                            //if (m_stcSampleBlobLead.intFailMask > 0 && ((m_stcSampleBlobLead.intFailMask & 0x01) == 0) && ((m_stcSampleBlobLead.intFailMask & 0x02) == 0)) //((m_stcSampleBlobLead.intFailMask & 0x40) > 0)
                            if (m_stcSampleBlobLead.intFailMask > 0 && ((m_stcSampleBlobLead.intFailMask & 0x01) == 0) && ((m_stcSampleBlobLead.intFailMask & 0x02) == 0) && ((m_stcSampleBlobLead.intFailMask & 0x400000) == 0) ||
                                ((m_arrFailResultMask[m_intLeadROIDirection] & 0x04) > 0) || ((m_arrFailResultMask[m_intLeadROIDirection] & 0x1000) > 0) || ((m_arrFailResultMask[m_intLeadROIDirection] & 0x2000) > 0) || ((m_arrFailResultMask[m_intLeadROIDirection] & 0x4000) > 0) || ((m_arrFailResultMask[m_intLeadROIDirection] & 0x800) > 0) ||
                                ((m_arrFailResultMask[3] & 0x04) > 0) || ((m_arrFailResultMask[3] & 0x1000) > 0) || ((m_arrFailResultMask[3] & 0x2000) > 0) || ((m_arrFailResultMask[3] & 0x4000) > 0) || ((m_arrFailResultMask[3] & 0x800) > 0))
                            {
                                g.DrawRectangle(new Pen(Color.Red, 1), p1.X - 5, Math.Min(p1.Y, p3.Y) - 5, p3.X - p1.X + 10, p2.Y - Math.Min(p1.Y, p3.Y) + 10);
                                if (!blnFail)
                                    blnFail = true;
                            }
                            else
                            {
                                g.DrawRectangle(new Pen(Color.Lime, 1), p1.X - 5, Math.Min(p1.Y, p3.Y) - 5, p3.X - p1.X + 10, p2.Y - Math.Min(p1.Y, p3.Y) + 10);
                            }
                            break;
                        case 1: // Left
                            //if (m_stcSampleBlobLead.intFailMask > 0 && ((m_stcSampleBlobLead.intFailMask & 0x01) == 0) && ((m_stcSampleBlobLead.intFailMask & 0x02) == 0)) //((m_stcSampleBlobLead.intFailMask & 0x40) > 0)
                            if (m_stcSampleBlobLead.intFailMask > 0 && ((m_stcSampleBlobLead.intFailMask & 0x01) == 0) && ((m_stcSampleBlobLead.intFailMask & 0x02) == 0) && ((m_stcSampleBlobLead.intFailMask & 0x400000) == 0) ||
                                ((m_arrFailResultMask[m_intLeadROIDirection] & 0x04) > 0) || ((m_arrFailResultMask[m_intLeadROIDirection] & 0x1000) > 0) || ((m_arrFailResultMask[m_intLeadROIDirection] & 0x2000) > 0) || ((m_arrFailResultMask[m_intLeadROIDirection] & 0x4000) > 0) || ((m_arrFailResultMask[m_intLeadROIDirection] & 0x800) > 0) ||
                                ((m_arrFailResultMask[4] & 0x04) > 0) || ((m_arrFailResultMask[4] & 0x1000) > 0) || ((m_arrFailResultMask[4] & 0x2000) > 0) || ((m_arrFailResultMask[4] & 0x4000) > 0) || ((m_arrFailResultMask[4] & 0x800) > 0))
                            {
                                g.DrawRectangle(new Pen(Color.Red, 1), p2.X - 5, p1.Y - 5, Math.Max(p3.X, p1.X) - p2.X + 10, p3.Y - p1.Y + 10);
                                if (!blnFail)
                                    blnFail = true;
                            }
                            else
                            {
                                g.DrawRectangle(new Pen(Color.Lime, 1), p2.X - 5, p1.Y - 5, Math.Max(p3.X, p1.X) - p2.X + 10, p3.Y - p1.Y + 10);
                            }
                            break;
                    }

                    if (m_stcSampleBlobLead.blnTipStartFound)
                    {
                        g.DrawLine(new Pen(Color.Lime, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                        g.DrawLine(new Pen(Color.Lime, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                    }
                    else
                    {
                        g.DrawLine(new Pen(Color.Red, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                        g.DrawLine(new Pen(Color.Red, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                    }

                    if (m_stcSampleBlobLead.blnTipCenterFound)
                    {
                        g.DrawLine(new Pen(Color.Lime, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                        g.DrawLine(new Pen(Color.Lime, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                    }
                    else
                    {
                        g.DrawLine(new Pen(Color.Red, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                        g.DrawLine(new Pen(Color.Red, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                    }

                    if (m_stcSampleBlobLead.blnTipEndFound)
                    {
                        g.DrawLine(new Pen(Color.Lime, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                        g.DrawLine(new Pen(Color.Lime, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                    }
                    else
                    {
                        g.DrawLine(new Pen(Color.Red, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                        g.DrawLine(new Pen(Color.Red, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                    }

                    if (m_stcSampleBlobLead.blnBaseStartFound)
                    {
                        g.DrawLine(new Pen(Color.Lime, 2), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                        g.DrawLine(new Pen(Color.Lime, 2), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                    }
                    else
                    {
                        if (!m_stcSampleBlobLead.blnBaseEndFound)
                        {
                            g.DrawLine(new Pen(Color.Red, 2), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                            g.DrawLine(new Pen(Color.Red, 2), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                        }
                    }

                    //if (m_stcSampleBlobLead.blnBaseCenterFound)
                    {
                        g.DrawLine(new Pen(Color.Lime, 1), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                        g.DrawLine(new Pen(Color.Lime, 1), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                    }
                    //else
                    //{
                    //    g.DrawLine(new Pen(Color.Red, 1), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                    //    g.DrawLine(new Pen(Color.Red, 1), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                    //}

                    if (m_stcSampleBlobLead.blnBaseEndFound)
                    {
                        g.DrawLine(new Pen(Color.Lime, 1), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                        g.DrawLine(new Pen(Color.Lime, 1), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                    }
                    else
                    {
                        if (!m_stcSampleBlobLead.blnBaseStartFound)
                        {
                            g.DrawLine(new Pen(Color.Red, 1), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                            g.DrawLine(new Pen(Color.Red, 1), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                        }
                    }

                    g.DrawLine(new Pen(Color.Blue, 1), p5.X, p5.Y, p2.X, p2.Y);


                    // Draw lead lable.
                    switch (m_stcSampleBlobLead.intDirection)
                    {
                        case 4: // Top
                            g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                                    (m_stcSampleBlobLead.fTipCenterX + intRoiOrgX - 15) * fDrawingScaleX,
                                    (m_stcSampleBlobLead.fTipCenterY + intRoiOrgY - 40) * fDrawingScaleY);
                            break;
                        case 2: // Right
                            g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                                    (m_stcSampleBlobLead.fTipCenterX + intRoiOrgX + 10) * fDrawingScaleX,
                                    (m_stcSampleBlobLead.fTipCenterY + intRoiOrgY - 15) * fDrawingScaleY);
                            break;
                        case 8: // Bottom
                            g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                                    (m_stcSampleBlobLead.fTipCenterX + intRoiOrgX - 15) * fDrawingScaleX,
                                    (m_stcSampleBlobLead.fTipCenterY + intRoiOrgY + 10) * fDrawingScaleY);
                            break;
                        case 1: // Left
                            g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                                    (m_stcSampleBlobLead.fTipCenterX + intRoiOrgX - 40) * fDrawingScaleX,
                                    (m_stcSampleBlobLead.fTipCenterY + intRoiOrgY - 15) * fDrawingScaleY);
                            break;
                    }
                    //switch (m_stcSampleBlobLead.intDirection)
                    //{
                    //    case 4: // Top
                    //        g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                    //                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCenterX + intRoiOrgX - 15) * fDrawingScaleX,
                    //                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCenterY + intRoiOrgY - 65) * fDrawingScaleY);
                    //        break;
                    //    case 2: // Right
                    //        g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                    //                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fEndX + intRoiOrgX + 10) * fDrawingScaleX,
                    //                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCenterY + intRoiOrgY - 15) * fDrawingScaleY);
                    //        break;
                    //    case 8: // Bottom
                    //        g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                    //                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCenterX + intRoiOrgX - 15) * fDrawingScaleX,
                    //                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCenterY + intRoiOrgY + 25) * fDrawingScaleY);
                    //        break;
                    //    case 1: // Left
                    //        g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                    //                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fStartX + intRoiOrgX - 40) * fDrawingScaleX,
                    //                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCenterY + intRoiOrgY - 15) * fDrawingScaleY);
                    //        break;
                    //}

                    // Average Gray Value ROI
                    if (m_blnWantUseAverageGrayValueMethod && (m_intFailOptionMask & 0x40000) > 0)
                    {
                        float fStartX = 0, fStartY = 0, fWidth = 0, fHeight = 0;
                        switch (m_stcSampleBlobLead.intDirection)
                        {
                            case 4: // Top
                                fStartX = (intRoiOrgX + m_stcSampleBlobLead.fTipCenterX - (m_stcSampleBlobLead.fTipWidth / 2) + m_stcBlobLead.intAGVROITolerance_Left) * fDrawingScaleX;
                                fStartY = (intRoiOrgY + m_stcSampleBlobLead.fTipCenterY + m_stcBlobLead.intAGVROITolerance_Top) * fDrawingScaleY;
                                fWidth = (m_stcSampleBlobLead.fTipWidth - m_stcBlobLead.intAGVROITolerance_Left - m_stcBlobLead.intAGVROITolerance_Right) * fDrawingScaleX;
                                fHeight = (m_stcSampleBlobLead.fTipLength - m_stcBlobLead.intAGVROITolerance_Top - m_stcBlobLead.intAGVROITolerance_Bottom) * fDrawingScaleY;
                                break;
                            case 8: // Bottom
                                fStartX = (intRoiOrgX + m_stcSampleBlobLead.fTipCenterX - (m_stcSampleBlobLead.fTipWidth / 2) + m_stcBlobLead.intAGVROITolerance_Left) * fDrawingScaleX;
                                fStartY = (intRoiOrgY + m_stcSampleBlobLead.fTipCenterY - m_stcSampleBlobLead.fTipLength + m_stcBlobLead.intAGVROITolerance_Top) * fDrawingScaleY;
                                fWidth = (m_stcSampleBlobLead.fTipWidth - m_stcBlobLead.intAGVROITolerance_Left - m_stcBlobLead.intAGVROITolerance_Right) * fDrawingScaleX;
                                fHeight = (m_stcSampleBlobLead.fTipLength - m_stcBlobLead.intAGVROITolerance_Top - m_stcBlobLead.intAGVROITolerance_Bottom) * fDrawingScaleY;
                                break;
                            case 1: // Left
                                fStartX = (intRoiOrgX + m_stcSampleBlobLead.fTipCenterX + m_stcBlobLead.intAGVROITolerance_Left) * fDrawingScaleX;
                                fStartY = (intRoiOrgY + m_stcSampleBlobLead.fTipCenterY - (m_stcSampleBlobLead.fTipWidth / 2) + m_stcBlobLead.intAGVROITolerance_Top) * fDrawingScaleY;
                                fWidth = (m_stcSampleBlobLead.fTipLength - m_stcBlobLead.intAGVROITolerance_Left - m_stcBlobLead.intAGVROITolerance_Right) * fDrawingScaleX;
                                fHeight = (m_stcSampleBlobLead.fTipWidth - m_stcBlobLead.intAGVROITolerance_Top - m_stcBlobLead.intAGVROITolerance_Bottom) * fDrawingScaleY;
                                break;
                            case 2: // Right
                                fStartX = (intRoiOrgX + m_stcSampleBlobLead.fTipCenterX - m_stcSampleBlobLead.fTipLength + m_stcBlobLead.intAGVROITolerance_Left) * fDrawingScaleX;
                                fStartY = (intRoiOrgY + m_stcSampleBlobLead.fTipCenterY - (m_stcSampleBlobLead.fTipWidth / 2) + m_stcBlobLead.intAGVROITolerance_Top) * fDrawingScaleY;
                                fWidth = (m_stcSampleBlobLead.fTipLength - m_stcBlobLead.intAGVROITolerance_Left - m_stcBlobLead.intAGVROITolerance_Right) * fDrawingScaleX;
                                fHeight = (m_stcSampleBlobLead.fTipWidth - m_stcBlobLead.intAGVROITolerance_Top - m_stcBlobLead.intAGVROITolerance_Bottom) * fDrawingScaleY;
                                break;
                        }
                        g.DrawRectangle(new Pen(Color.Turquoise, 1), fStartX, fStartY, fWidth, fHeight);
                    }

                    //Missing Lead
                    if (m_arrSampleBlobLeads[i].intFailMask == 0x20)//0x04
                    {
                        if (!blnFail)
                            blnFail = true;
                        System.Drawing.PointF pMissing1 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.intStartX, intRoiOrgY + m_stcBlobLead.intStartY);
                        System.Drawing.PointF pMissing2 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.intEndX, intRoiOrgY + m_stcBlobLead.intStartY);
                        System.Drawing.PointF pMissing3 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.intStartX, intRoiOrgY + m_stcBlobLead.intEndY);
                        System.Drawing.PointF pMissing4 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.intEndX, intRoiOrgY + m_stcBlobLead.intEndY);
                        if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                        {
                            pMissing1.X = pMissing1.X * fDrawingScaleX;
                            pMissing1.Y = pMissing1.Y * fDrawingScaleY;
                            pMissing2.X = pMissing2.X * fDrawingScaleX;
                            pMissing2.Y = pMissing2.Y * fDrawingScaleY;
                            pMissing3.X = pMissing3.X * fDrawingScaleX;
                            pMissing3.Y = pMissing3.Y * fDrawingScaleY;
                            pMissing4.X = pMissing4.X * fDrawingScaleX;
                            pMissing4.Y = pMissing4.Y * fDrawingScaleY;
                        }

                        g.DrawLine(new Pen(Color.Red), pMissing1, pMissing2);
                        g.DrawLine(new Pen(Color.Red), pMissing2, pMissing4);
                        g.DrawLine(new Pen(Color.Red), pMissing4, pMissing3);
                        g.DrawLine(new Pen(Color.Red), pMissing3, pMissing1);
                        g.DrawLine(new Pen(Color.Red), pMissing1, pMissing4);

                        // Draw lead lable.
                        switch (m_stcSampleBlobLead.intDirection)
                        {
                            case 4: // Top
                                g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                                        (m_stcSampleBlobLead.fTipCenterX + intRoiOrgX - 15) * fDrawingScaleX,
                                        (m_stcSampleBlobLead.fTipCenterY + intRoiOrgY - 40) * fDrawingScaleY);
                                break;
                            case 2: // Right
                                g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                                        (m_stcSampleBlobLead.fTipCenterX + intRoiOrgX + 10) * fDrawingScaleX,
                                        (m_stcSampleBlobLead.fTipCenterY + intRoiOrgY - 15) * fDrawingScaleY);
                                break;
                            case 8: // Bottom
                                g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                                        (m_stcSampleBlobLead.fTipCenterX + intRoiOrgX - 15) * fDrawingScaleX,
                                        (m_stcSampleBlobLead.fTipCenterY + intRoiOrgY + 10) * fDrawingScaleY);
                                break;
                            case 1: // Left
                                g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                                        (m_stcSampleBlobLead.fTipCenterX + intRoiOrgX - 40) * fDrawingScaleX,
                                        (m_stcSampleBlobLead.fTipCenterY + intRoiOrgY - 15) * fDrawingScaleY);
                                break;
                        }
                        //switch (m_stcBlobLead.intDirection)
                        //{
                        //    case 4: // Top
                        //        g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                        //                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCenterX + intRoiOrgX - 15) * fDrawingScaleX,
                        //                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCenterY + intRoiOrgY - 40) * fDrawingScaleY);
                        //        break;
                        //    case 2: // Right
                        //        g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                        //                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fEndX + intRoiOrgX + 10) * fDrawingScaleX,
                        //                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCenterY + intRoiOrgY - 15) * fDrawingScaleY);
                        //        break;
                        //    case 8: // Bottom
                        //        g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                        //                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCenterX + intRoiOrgX - 15) * fDrawingScaleX,
                        //                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCenterY + intRoiOrgY + 10) * fDrawingScaleY);
                        //        break;
                        //    case 1: // Left
                        //        g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                        //                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fStartX + intRoiOrgX - 40) * fDrawingScaleX,
                        //                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCenterY + intRoiOrgY - 15) * fDrawingScaleY);
                        //        break;
                        //}
                    }
                }
                //Extra, Join Lead, Excess Lead
                for (int i = 0; i < m_arrExtraBlobs.Count; i++)
                {
                    if (m_blnLock)
                        return;

                    //if (i == intLeadSelectingNumber)
                    //{
                    //    System.Drawing.PointF p1 = new System.Drawing.PointF(intRoiOrgX + m_arrExtraBlobs[i].fStartX, intRoiOrgY + m_arrExtraBlobs[i].fStartY);
                    //    System.Drawing.PointF p2 = new System.Drawing.PointF(intRoiOrgX + m_arrExtraBlobs[i].fEndX, intRoiOrgY + m_arrExtraBlobs[i].fStartY);
                    //    System.Drawing.PointF p3 = new System.Drawing.PointF(intRoiOrgX + m_arrExtraBlobs[i].fStartX, intRoiOrgY + m_arrExtraBlobs[i].fEndY);
                    //    System.Drawing.PointF p4 = new System.Drawing.PointF(intRoiOrgX + m_arrExtraBlobs[i].fEndX, intRoiOrgY + m_arrExtraBlobs[i].fEndY);

                    //    if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                    //    {
                    //        p1.X = p1.X * fDrawingScaleX;
                    //        p1.Y = p1.Y * fDrawingScaleY;
                    //        p2.X = p2.X * fDrawingScaleX;
                    //        p2.Y = p2.Y * fDrawingScaleY;
                    //        p3.X = p3.X * fDrawingScaleX;
                    //        p3.Y = p3.Y * fDrawingScaleY;
                    //        p4.X = p4.X * fDrawingScaleX;
                    //        p4.Y = p4.Y * fDrawingScaleY;
                    //    }

                    //    g.DrawLine(new Pen(Color.Lime), p1, p2);
                    //    g.DrawLine(new Pen(Color.Lime), p2, p4);
                    //    g.DrawLine(new Pen(Color.Lime), p4, p3);
                    //    g.DrawLine(new Pen(Color.Lime), p3, p1);
                    //    continue;
                    //}
                    //else
                    {
                        if (m_blnLock)
                            return;

                        System.Drawing.PointF p1 = new System.Drawing.PointF(intRoiOrgX + m_arrExtraBlobs[i].fStartX, intRoiOrgY + m_arrExtraBlobs[i].fStartY);
                        System.Drawing.PointF p2 = new System.Drawing.PointF(intRoiOrgX + m_arrExtraBlobs[i].fEndX, intRoiOrgY + m_arrExtraBlobs[i].fStartY);
                        System.Drawing.PointF p3 = new System.Drawing.PointF(intRoiOrgX + m_arrExtraBlobs[i].fStartX, intRoiOrgY + m_arrExtraBlobs[i].fEndY);
                        System.Drawing.PointF p4 = new System.Drawing.PointF(intRoiOrgX + m_arrExtraBlobs[i].fEndX, intRoiOrgY + m_arrExtraBlobs[i].fEndY);

                        if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                        {
                            p1.X = p1.X * fDrawingScaleX;
                            p1.Y = p1.Y * fDrawingScaleY;
                            p2.X = p2.X * fDrawingScaleX;
                            p2.Y = p2.Y * fDrawingScaleY;
                            p3.X = p3.X * fDrawingScaleX;
                            p3.Y = p3.Y * fDrawingScaleY;
                            p4.X = p4.X * fDrawingScaleX;
                            p4.Y = p4.Y * fDrawingScaleY;
                        }

                        if (m_arrFailResultMask[0] > 0)//m_arrExtraBlobs[i].ref_intFailCriteria 
                        {
                            if (!blnFail)
                                blnFail = true;
                            g.DrawLine(new Pen(Color.Red), p1, p2);
                            g.DrawLine(new Pen(Color.Red), p2, p4);
                            g.DrawLine(new Pen(Color.Red), p4, p3);
                            g.DrawLine(new Pen(Color.Red), p3, p1);
                            g.DrawLine(new Pen(Color.Red), p1, p4);
                        }
                        else
                        {
                            g.DrawLine(new Pen(Color.Lime), p1, p2);
                            g.DrawLine(new Pen(Color.Lime), p2, p4);
                            g.DrawLine(new Pen(Color.Lime), p4, p3);
                            g.DrawLine(new Pen(Color.Lime), p3, p1);
                            g.DrawLine(new Pen(Color.Lime), p1, p4);
                        }
                    }
                }

                for (int i = 0; i < m_arrFailPitchGapList.Count; i++)
                {
                    if (m_blnLock)
                        return;
                    if (!blnFail)
                        blnFail = true;
                    g.DrawLine(new Pen(Color.Red), (float)(m_arrFailPitchGapList[i].intStartPointX - 5) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intStartPointY - 5) * fDrawingScaleY,
                                       (float)(m_arrFailPitchGapList[i].intStartPointX + 5) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intStartPointY + 5) * fDrawingScaleY);
                    g.DrawLine(new Pen(Color.Red), (float)(m_arrFailPitchGapList[i].intStartPointX + 5) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intStartPointY - 5) * fDrawingScaleY,
                                       (float)(m_arrFailPitchGapList[i].intStartPointX - 5) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intStartPointY + 5) * fDrawingScaleY);
                    g.DrawLine(new Pen(Color.Red), (float)(m_arrFailPitchGapList[i].intEndPointX - 5) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intEndPointY - 5) * fDrawingScaleY,
                                       (float)(m_arrFailPitchGapList[i].intEndPointX + 5) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intEndPointY + 5) * fDrawingScaleY);
                    g.DrawLine(new Pen(Color.Red), (float)(m_arrFailPitchGapList[i].intEndPointX + 5) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intEndPointY - 5) * fDrawingScaleY,
                                       (float)(m_arrFailPitchGapList[i].intEndPointX - 5) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intEndPointY + 5) * fDrawingScaleY);
                    g.DrawLine(new Pen(Color.Red), (float)(m_arrFailPitchGapList[i].intStartPointX) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intStartPointY) * fDrawingScaleY,
                                       (float)(m_arrFailPitchGapList[i].intEndPointX) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intEndPointY) * fDrawingScaleY);
                }

                if (blnFail && !m_blnLock)
                {
                    objROI.DrawROI(g, fDrawingScaleX, fDrawingScaleY, false, 0, Color.Red);
                }
            }
        }
        public void DrawInspectionObjects_Lead3D_Center(Graphics g, float fDrawingScaleX, float fDrawingScaleY, ROI objROI, int intLeadPosition, Color[][] arrColor)
        {
            lock (m_objLockBlobs)
            {
                if (!m_blnPatternMatchSuccess && !m_blnLock)
                {
                    objROI.DrawROI(g, fDrawingScaleX, fDrawingScaleY, false, 0, Color.Red);
                    return;
                }

                bool blnFail = false;
                int intRoiOrgX = objROI.ref_ROITotalX;
                int intRoiOrgY = objROI.ref_ROITotalY;
                int intROIWidth = objROI.ref_ROIWidth;
                int intROIHeight = objROI.ref_ROIHeight;
                // Draw center unit package size
                int intTopLeftX = (int)Math.Round(m_pCornerPoint_TopLeft.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                int intTopLeftY = (int)Math.Round(m_pCornerPoint_TopLeft.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                int intTopRightX = (int)Math.Round(m_pCornerPoint_TopRight.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                int intTopRightY = (int)Math.Round(m_pCornerPoint_TopRight.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                int intBottomLeftX = (int)Math.Round(m_pCornerPoint_BottomLeft.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                int intBottomleftY = (int)Math.Round(m_pCornerPoint_BottomLeft.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                int intBottomRightX = (int)Math.Round(m_pCornerPoint_BottomRight.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                int intBottomRightY = (int)Math.Round(m_pCornerPoint_BottomRight.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);

                int intCenterX = (int)Math.Round((intRoiOrgX + intROIWidth / 2) * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                int intCenterY = (int)Math.Round((intRoiOrgY + intROIHeight / 2) * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);

                //int intCenterX = (int)Math.Round((intRoiOrgX + m_objMatcher.GetPosition(0).CenterX) * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                //int intCenterY = (int)Math.Round((intRoiOrgY + m_objMatcher.GetPosition(0).CenterY) * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);

                float newTLX = intTopLeftX, newTLY = intTopLeftY, newTRX = intTopRightX, newTRY = intTopRightY, newBLX = intBottomLeftX, newBLY = intBottomleftY, newBRX = intBottomRightX, newBRY = intBottomRightY;
                //Math2.RotateWithAngleAccordingToReferencePoint(intCenterX, intCenterY, intTopLeftX, intTopLeftY, -m_fCenterUnitAngle, ref newTLX, ref newTLY);
                //Math2.RotateWithAngleAccordingToReferencePoint(intCenterX, intCenterY, intTopRightX, intTopRightY, -m_fCenterUnitAngle, ref newTRX, ref newTRY);
                //Math2.RotateWithAngleAccordingToReferencePoint(intCenterX, intCenterY, intBottomLeftX, intBottomleftY, -m_fCenterUnitAngle, ref newBLX, ref newBLY);
                //Math2.RotateWithAngleAccordingToReferencePoint(intCenterX, intCenterY, intBottomRightX, intBottomRightY, -m_fCenterUnitAngle, ref newBRX, ref newBRY);

                //Math2.RotateWithAngleAccordingToReferencePoint(intCenterX, intCenterY, intTopLeftX, intTopLeftY, -m_objMatcher.GetPosition(0).Angle, ref newTLX, ref newTLY);
                //Math2.RotateWithAngleAccordingToReferencePoint(intCenterX, intCenterY, intTopRightX, intTopRightY, -m_objMatcher.GetPosition(0).Angle, ref newTRX, ref newTRY);
                //Math2.RotateWithAngleAccordingToReferencePoint(intCenterX, intCenterY, intBottomLeftX, intBottomleftY, -m_objMatcher.GetPosition(0).Angle, ref newBLX, ref newBLY);
                //Math2.RotateWithAngleAccordingToReferencePoint(intCenterX, intCenterY, intBottomRightX, intBottomRightY, -m_objMatcher.GetPosition(0).Angle, ref newBRX, ref newBRY);

                //g.DrawLine(new Pen(Color.Yellow, 1), intTopLeftX, intTopLeftY, intTopRightX, intTopRightY);
                //g.DrawLine(new Pen(Color.Yellow, 1), intTopRightX, intTopRightY, intBottomRightX, intBottomRightY);
                //g.DrawLine(new Pen(Color.Yellow, 1), intBottomRightX, intBottomRightY, intBottomLeftX, intBottomleftY);
                //g.DrawLine(new Pen(Color.Yellow, 1), intBottomLeftX, intBottomleftY, intTopLeftX, intTopLeftY);

                //g.DrawLine(new Pen(Color.Yellow, 1), newTLX, newTLY, newTRX, newTRY);
                //g.DrawLine(new Pen(Color.Yellow, 1), newTRX, newTRY, newBRX, newBRY);
                //g.DrawLine(new Pen(Color.Yellow, 1), newBRX, newBRY, newBLX, newBLY);
                //g.DrawLine(new Pen(Color.Yellow, 1), newBLX, newBLY, newTLX, newTLY);

                g.DrawLine(new Pen(arrColor[7][0], 1), (newTRX + newBRX) / 2, (newTLY + newTRY) / 2, (newBLX + newTLX) / 2, (newTLY + newTRY) / 2);
                g.DrawLine(new Pen(arrColor[7][0], 1), (newTRX + newBRX) / 2, (newTLY + newTRY) / 2, (newTRX + newBRX) / 2, (newBRY + newBLY) / 2);
                g.DrawLine(new Pen(arrColor[7][0], 1), (newBLX + newTLX) / 2, (newBRY + newBLY) / 2, (newTRX + newBRX) / 2, (newBRY + newBLY) / 2);
                g.DrawLine(new Pen(arrColor[7][0], 1), (newBLX + newTLX) / 2, (newBRY + newBLY) / 2, (newBLX + newTLX) / 2, (newTLY + newTRY) / 2);

                if (m_blnFailPosition)
                    return;

                // Draw center lead tip, base and, width and length.
                for (int i = 0; i < m_arrSampleBlobLeads.Length; i++)
                {
                    m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                    m_stcSampleBlobLead = (SampleBlobsFeatures)m_arrSampleBlobLeads[i];

                    System.Drawing.PointF p1 = new PointF();
                    System.Drawing.PointF p2 = new PointF();
                    System.Drawing.PointF p3 = new PointF();
                    System.Drawing.PointF p4 = new PointF();
                    System.Drawing.PointF p5 = new PointF();
                    System.Drawing.PointF p6 = new PointF();

                    switch (m_stcBlobLead.intDirection)
                    {
                        case 4: // Top
                            p1 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fTipCenterX - m_stcSampleBlobLead.fTipWidth / 2, intRoiOrgY + m_stcSampleBlobLead.fTipCenterY + m_intTipOffset);
                            p2 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fTipCenterX, intRoiOrgY + m_stcSampleBlobLead.fTipCenterY);
                            p3 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fTipCenterX + m_stcSampleBlobLead.fTipWidth / 2, intRoiOrgY + m_stcSampleBlobLead.fTipCenterY + m_intTipOffset);
                            p4 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fBaseCenterX - m_stcSampleBlobLead.fBaseWidth / 2, intRoiOrgY + m_stcSampleBlobLead.fBaseCenterY - m_intBaseOffset);
                            p5 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fBaseCenterX, intRoiOrgY + m_stcSampleBlobLead.fBaseCenterY);
                            p6 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fBaseCenterX + m_stcSampleBlobLead.fBaseWidth / 2, intRoiOrgY + m_stcSampleBlobLead.fBaseCenterY - m_intBaseOffset);
                            break;
                        case 2: // Right
                            p1 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fTipCenterX - m_intTipOffset, intRoiOrgY + m_stcSampleBlobLead.fTipCenterY - m_stcSampleBlobLead.fTipWidth / 2);
                            p2 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fTipCenterX, intRoiOrgY + m_stcSampleBlobLead.fTipCenterY);
                            p3 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fTipCenterX - m_intTipOffset, intRoiOrgY + m_stcSampleBlobLead.fTipCenterY + m_stcSampleBlobLead.fTipWidth / 2);
                            p4 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fBaseCenterX + m_intBaseOffset, intRoiOrgY + m_stcSampleBlobLead.fBaseCenterY - m_stcSampleBlobLead.fBaseWidth / 2);
                            p5 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fBaseCenterX, intRoiOrgY + m_stcSampleBlobLead.fBaseCenterY);
                            p6 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fBaseCenterX + m_intBaseOffset, intRoiOrgY + m_stcSampleBlobLead.fBaseCenterY + m_stcSampleBlobLead.fBaseWidth / 2);
                            break;
                        case 8: // Bottom
                            p1 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fTipCenterX - m_stcSampleBlobLead.fTipWidth / 2, intRoiOrgY + m_stcSampleBlobLead.fTipCenterY - m_intTipOffset);
                            p2 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fTipCenterX, intRoiOrgY + m_stcSampleBlobLead.fTipCenterY);
                            p3 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fTipCenterX + m_stcSampleBlobLead.fTipWidth / 2, intRoiOrgY + m_stcSampleBlobLead.fTipCenterY - m_intTipOffset);
                            p4 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fBaseCenterX - m_stcSampleBlobLead.fBaseWidth / 2, intRoiOrgY + m_stcSampleBlobLead.fBaseCenterY + m_intBaseOffset);
                            p5 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fBaseCenterX, intRoiOrgY + m_stcSampleBlobLead.fBaseCenterY);
                            p6 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fBaseCenterX + m_stcSampleBlobLead.fBaseWidth / 2, intRoiOrgY + m_stcSampleBlobLead.fBaseCenterY + m_intBaseOffset);
                            break;
                        case 1: // Left
                            p1 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fTipCenterX + m_intTipOffset, intRoiOrgY + m_stcSampleBlobLead.fTipCenterY - m_stcSampleBlobLead.fTipWidth / 2);
                            p2 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fTipCenterX, intRoiOrgY + m_stcSampleBlobLead.fTipCenterY);
                            p3 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fTipCenterX + m_intTipOffset, intRoiOrgY + m_stcSampleBlobLead.fTipCenterY + m_stcSampleBlobLead.fTipWidth / 2);
                            p4 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fBaseCenterX - m_intBaseOffset, intRoiOrgY + m_stcSampleBlobLead.fBaseCenterY - m_stcSampleBlobLead.fBaseWidth / 2);
                            p5 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fBaseCenterX, intRoiOrgY + m_stcSampleBlobLead.fBaseCenterY);
                            p6 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fBaseCenterX - m_intBaseOffset, intRoiOrgY + m_stcSampleBlobLead.fBaseCenterY + m_stcSampleBlobLead.fBaseWidth / 2);
                            break;
                    }

                    if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                    {
                        p1.X = p1.X * fDrawingScaleX;
                        p1.Y = p1.Y * fDrawingScaleY;
                        p2.X = p2.X * fDrawingScaleX;
                        p2.Y = p2.Y * fDrawingScaleY;
                        p3.X = p3.X * fDrawingScaleX;
                        p3.Y = p3.Y * fDrawingScaleY;
                        p4.X = p4.X * fDrawingScaleX;
                        p4.Y = p4.Y * fDrawingScaleY;
                        p5.X = p5.X * fDrawingScaleX;
                        p5.Y = p5.Y * fDrawingScaleY;
                        p6.X = p6.X * fDrawingScaleX;
                        p6.Y = p6.Y * fDrawingScaleY;
                    }

                    //Pen colorPen;
                    //if (m_arrSampleBlobLeads[i].intFailMask == 0)
                    //{
                    //    colorPen = new Pen(Color.Lime, 1);
                    //}
                    //else
                    //{
                    //    colorPen = new Pen(Color.Red, 1);
                    //}
                    //g.DrawLine(colorPen, p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                    //g.DrawLine(colorPen, p1.X - 3, p1.Y, p1.X + 3, p1.Y);

                    //g.DrawLine(colorPen, p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                    //g.DrawLine(colorPen, p2.X - 3, p2.Y, p2.X + 3, p2.Y);

                    //g.DrawLine(colorPen, p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                    //g.DrawLine(colorPen, p3.X - 3, p3.Y, p3.X + 3, p3.Y);

                    //g.DrawLine(colorPen, p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                    //g.DrawLine(colorPen, p4.X - 3, p4.Y, p4.X + 3, p4.Y);

                    //g.DrawLine(colorPen, p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                    //g.DrawLine(colorPen, p5.X - 3, p5.Y, p5.X + 3, p5.Y);

                    //g.DrawLine(colorPen, p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                    //g.DrawLine(colorPen, p6.X - 3, p6.Y, p6.X + 3, p6.Y);

                    //g.DrawLine(new Pen(Color.Blue, 1), p5.X, p5.Y, p6.X, p6.Y);

                    switch (m_stcSampleBlobLead.intDirection)
                    {
                        case 4: // Top
                            //if (m_stcSampleBlobLead.intFailMask > 0 && ((m_stcSampleBlobLead.intFailMask & 0x01) == 0) && ((m_stcSampleBlobLead.intFailMask & 0x02) == 0)) //((m_stcSampleBlobLead.intFailMask & 0x40) > 0)
                            if (m_stcSampleBlobLead.intFailMask > 0 && ((m_stcSampleBlobLead.intFailMask & 0x01) == 0) && ((m_stcSampleBlobLead.intFailMask & 0x02) == 0) && ((m_stcSampleBlobLead.intFailMask & 0x400000) == 0) ||
                                ((m_arrFailResultMask[m_intLeadROIDirection] & 0x04) > 0) || ((m_arrFailResultMask[m_intLeadROIDirection] & 0x1000) > 0) || ((m_arrFailResultMask[m_intLeadROIDirection] & 0x2000) > 0) || ((m_arrFailResultMask[m_intLeadROIDirection] & 0x4000) > 0) || ((m_arrFailResultMask[m_intLeadROIDirection] & 0x800) > 0) ||
                                ((m_arrFailResultMask[1] & 0x04) > 0) || ((m_arrFailResultMask[1] & 0x1000) > 0) || ((m_arrFailResultMask[1] & 0x2000) > 0) || ((m_arrFailResultMask[1] & 0x4000) > 0) || ((m_arrFailResultMask[1] & 0x800) > 0))
                            {
                                g.DrawRectangle(new Pen(Color.Red, 1), p1.X - 5, p2.Y - 5, p3.X - p1.X + 10, Math.Max(p1.Y, p3.Y) - p2.Y + 10);
                                if (!blnFail)
                                    blnFail = true;
                            }
                            else
                            {
                                g.DrawRectangle(new Pen(Color.Lime, 1), p1.X - 5, p2.Y - 5, p3.X - p1.X + 10, Math.Max(p1.Y, p3.Y) - p2.Y + 10);
                            }
                            break;
                        case 2: // Right
                            //if (m_stcSampleBlobLead.intFailMask > 0 && ((m_stcSampleBlobLead.intFailMask & 0x01) == 0) && ((m_stcSampleBlobLead.intFailMask & 0x02) == 0)) //((m_stcSampleBlobLead.intFailMask & 0x40) > 0)
                            if (m_stcSampleBlobLead.intFailMask > 0 && ((m_stcSampleBlobLead.intFailMask & 0x01) == 0) && ((m_stcSampleBlobLead.intFailMask & 0x02) == 0) && ((m_stcSampleBlobLead.intFailMask & 0x400000) == 0) ||
                                ((m_arrFailResultMask[m_intLeadROIDirection] & 0x04) > 0) || ((m_arrFailResultMask[m_intLeadROIDirection] & 0x1000) > 0) || ((m_arrFailResultMask[m_intLeadROIDirection] & 0x2000) > 0) || ((m_arrFailResultMask[m_intLeadROIDirection] & 0x4000) > 0) || ((m_arrFailResultMask[m_intLeadROIDirection] & 0x800) > 0) ||
                                ((m_arrFailResultMask[2] & 0x04) > 0) || ((m_arrFailResultMask[2] & 0x1000) > 0) || ((m_arrFailResultMask[2] & 0x2000) > 0) || ((m_arrFailResultMask[2] & 0x4000) > 0) || ((m_arrFailResultMask[2] & 0x800) > 0))
                            {
                                g.DrawRectangle(new Pen(Color.Red, 1), Math.Min(p3.X, p1.X) - 5, p1.Y - 5, p2.X - Math.Min(p3.X, p1.X) + 10, p3.Y - p1.Y + 10);
                                if (!blnFail)
                                    blnFail = true;
                            }
                            else
                            {
                                g.DrawRectangle(new Pen(Color.Lime, 1), Math.Min(p3.X, p1.X) - 5, p1.Y - 5, p2.X - Math.Min(p3.X, p1.X) + 10, p3.Y - p1.Y + 10);
                            }
                            break;
                        case 8: // Bottom
                            //if (m_stcSampleBlobLead.intFailMask > 0 && ((m_stcSampleBlobLead.intFailMask & 0x01) == 0) && ((m_stcSampleBlobLead.intFailMask & 0x02) == 0)) //((m_stcSampleBlobLead.intFailMask & 0x40) > 0)
                            if (m_stcSampleBlobLead.intFailMask > 0 && ((m_stcSampleBlobLead.intFailMask & 0x01) == 0) && ((m_stcSampleBlobLead.intFailMask & 0x02) == 0) && ((m_stcSampleBlobLead.intFailMask & 0x400000) == 0) ||
                                ((m_arrFailResultMask[m_intLeadROIDirection] & 0x04) > 0) || ((m_arrFailResultMask[m_intLeadROIDirection] & 0x1000) > 0) || ((m_arrFailResultMask[m_intLeadROIDirection] & 0x2000) > 0) || ((m_arrFailResultMask[m_intLeadROIDirection] & 0x4000) > 0) || ((m_arrFailResultMask[m_intLeadROIDirection] & 0x800) > 0) ||
                                ((m_arrFailResultMask[3] & 0x04) > 0) || ((m_arrFailResultMask[3] & 0x1000) > 0) || ((m_arrFailResultMask[3] & 0x2000) > 0) || ((m_arrFailResultMask[3] & 0x4000) > 0) || ((m_arrFailResultMask[3] & 0x800) > 0))
                            {
                                g.DrawRectangle(new Pen(Color.Red, 1), p1.X - 5, Math.Min(p1.Y, p3.Y) - 5, p3.X - p1.X + 10, p2.Y - Math.Min(p1.Y, p3.Y) + 10);
                                if (!blnFail)
                                    blnFail = true;
                            }
                            else
                            {
                                g.DrawRectangle(new Pen(Color.Lime, 1), p1.X - 5, Math.Min(p1.Y, p3.Y) - 5, p3.X - p1.X + 10, p2.Y - Math.Min(p1.Y, p3.Y) + 10);
                            }
                            break;
                        case 1: // Left
                            //if (m_stcSampleBlobLead.intFailMask > 0 && ((m_stcSampleBlobLead.intFailMask & 0x01) == 0) && ((m_stcSampleBlobLead.intFailMask & 0x02) == 0)) //((m_stcSampleBlobLead.intFailMask & 0x40) > 0)
                            if (m_stcSampleBlobLead.intFailMask > 0 && ((m_stcSampleBlobLead.intFailMask & 0x01) == 0) && ((m_stcSampleBlobLead.intFailMask & 0x02) == 0) && ((m_stcSampleBlobLead.intFailMask & 0x400000) == 0) ||
                                ((m_arrFailResultMask[m_intLeadROIDirection] & 0x04) > 0) || ((m_arrFailResultMask[m_intLeadROIDirection] & 0x1000) > 0) || ((m_arrFailResultMask[m_intLeadROIDirection] & 0x2000) > 0) || ((m_arrFailResultMask[m_intLeadROIDirection] & 0x4000) > 0) || ((m_arrFailResultMask[m_intLeadROIDirection] & 0x800) > 0) ||
                                ((m_arrFailResultMask[4] & 0x04) > 0) || ((m_arrFailResultMask[4] & 0x1000) > 0) || ((m_arrFailResultMask[4] & 0x2000) > 0) || ((m_arrFailResultMask[4] & 0x4000) > 0) || ((m_arrFailResultMask[4] & 0x800) > 0))
                            {
                                g.DrawRectangle(new Pen(Color.Red, 1), p2.X - 5, p1.Y - 5, Math.Max(p3.X, p1.X) - p2.X + 10, p3.Y - p1.Y + 10);
                                if (!blnFail)
                                    blnFail = true;
                            }
                            else
                            {
                                g.DrawRectangle(new Pen(Color.Lime, 1), p2.X - 5, p1.Y - 5, Math.Max(p3.X, p1.X) - p2.X + 10, p3.Y - p1.Y + 10);
                            }
                            break;
                    }

                    if (m_stcSampleBlobLead.blnTipStartFound)
                    {
                        g.DrawLine(new Pen(Color.Lime, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                        g.DrawLine(new Pen(Color.Lime, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                    }
                    else
                    {
                        g.DrawLine(new Pen(Color.Red, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                        g.DrawLine(new Pen(Color.Red, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                    }

                    if (m_stcSampleBlobLead.blnTipCenterFound)
                    {
                        g.DrawLine(new Pen(Color.Lime, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                        g.DrawLine(new Pen(Color.Lime, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                    }
                    else
                    {
                        g.DrawLine(new Pen(Color.Red, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                        g.DrawLine(new Pen(Color.Red, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                    }

                    if (m_stcSampleBlobLead.blnTipEndFound)
                    {
                        g.DrawLine(new Pen(Color.Lime, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                        g.DrawLine(new Pen(Color.Lime, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                    }
                    else
                    {
                        g.DrawLine(new Pen(Color.Red, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                        g.DrawLine(new Pen(Color.Red, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                    }

                    if (m_stcSampleBlobLead.blnBaseStartFound)
                    {
                        g.DrawLine(new Pen(Color.Lime, 2), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                        g.DrawLine(new Pen(Color.Lime, 2), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                    }
                    else
                    {
                        //g.DrawLine(new Pen(Color.Red, 2), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                        //g.DrawLine(new Pen(Color.Red, 2), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                        g.DrawLine(new Pen(Color.Green, 2), p4.X, p4.Y - 3, p4.X, p4.Y + 3);    // 2020 07 27 - CCENG: Base Start no function inspection currently, so no need to draw red color.
                        g.DrawLine(new Pen(Color.Green, 2), p4.X - 3, p4.Y, p4.X + 3, p4.Y);

                    }

                    if (m_stcSampleBlobLead.blnBaseCenterFound)
                    {
                        g.DrawLine(new Pen(Color.Lime, 1), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                        g.DrawLine(new Pen(Color.Lime, 1), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                    }
                    else
                    {
                        g.DrawLine(new Pen(Color.Red, 1), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                        g.DrawLine(new Pen(Color.Red, 1), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                    }

                    if (m_stcSampleBlobLead.blnBaseEndFound)
                    {
                        g.DrawLine(new Pen(Color.Lime, 1), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                        g.DrawLine(new Pen(Color.Lime, 1), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                    }
                    else
                    {
                        //g.DrawLine(new Pen(Color.Red, 1), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                        //g.DrawLine(new Pen(Color.Red, 1), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                        g.DrawLine(new Pen(Color.Green, 1), p6.X, p6.Y - 3, p6.X, p6.Y + 3);    // 2020 07 27 - CCENG: Base End no function inspection currently, so no need to draw red color.
                        g.DrawLine(new Pen(Color.Green, 1), p6.X - 3, p6.Y, p6.X + 3, p6.Y);

                    }

                    g.DrawLine(new Pen(Color.Blue, 1), p5.X, p5.Y, p2.X, p2.Y);


                    // Draw lead lable.
                    switch (m_stcSampleBlobLead.intDirection)
                    {
                        case 4: // Top
                            g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                                    (m_stcSampleBlobLead.fTipCenterX + intRoiOrgX - 15) * fDrawingScaleX,
                                    (m_stcSampleBlobLead.fTipCenterY + intRoiOrgY - 40) * fDrawingScaleY);
                            break;
                        case 2: // Right
                            g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                                    (m_stcSampleBlobLead.fTipCenterX + intRoiOrgX + 10) * fDrawingScaleX,
                                    (m_stcSampleBlobLead.fTipCenterY + intRoiOrgY - 15) * fDrawingScaleY);
                            break;
                        case 8: // Bottom
                            g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                                    (m_stcSampleBlobLead.fTipCenterX + intRoiOrgX - 15) * fDrawingScaleX,
                                    (m_stcSampleBlobLead.fTipCenterY + intRoiOrgY + 10) * fDrawingScaleY);
                            break;
                        case 1: // Left
                            g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                                    (m_stcSampleBlobLead.fTipCenterX + intRoiOrgX - 40) * fDrawingScaleX,
                                    (m_stcSampleBlobLead.fTipCenterY + intRoiOrgY - 15) * fDrawingScaleY);
                            break;
                    }
                    //switch (m_stcSampleBlobLead.intDirection)
                    //{
                    //    case 4: // Top
                    //        g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                    //                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCenterX + intRoiOrgX - 15) * fDrawingScaleX,
                    //                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCenterY + intRoiOrgY - 65) * fDrawingScaleY);
                    //        break;
                    //    case 2: // Right
                    //        g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                    //                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fEndX + intRoiOrgX + 10) * fDrawingScaleX,
                    //                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCenterY + intRoiOrgY - 15) * fDrawingScaleY);
                    //        break;
                    //    case 8: // Bottom
                    //        g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                    //                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCenterX + intRoiOrgX - 15) * fDrawingScaleX,
                    //                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCenterY + intRoiOrgY + 25) * fDrawingScaleY);
                    //        break;
                    //    case 1: // Left
                    //        g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                    //                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fStartX + intRoiOrgX - 40) * fDrawingScaleX,
                    //                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCenterY + intRoiOrgY - 15) * fDrawingScaleY);
                    //        break;
                    //}

                    // Average Gray Value ROI
                    if (m_blnWantUseAverageGrayValueMethod && (m_intFailOptionMask & 0x40000) > 0)
                    {
                        float fStartX = 0, fStartY = 0, fWidth = 0, fHeight = 0;
                        switch (m_stcSampleBlobLead.intDirection)
                        {
                            case 4: // Top
                                fStartX = (intRoiOrgX + m_stcSampleBlobLead.fTipCenterX - (m_stcSampleBlobLead.fTipWidth / 2) + m_stcBlobLead.intAGVROITolerance_Left) * fDrawingScaleX;
                                fStartY = (intRoiOrgY + m_stcSampleBlobLead.fTipCenterY + m_stcBlobLead.intAGVROITolerance_Top) * fDrawingScaleY;
                                fWidth = (m_stcSampleBlobLead.fTipWidth - m_stcBlobLead.intAGVROITolerance_Left - m_stcBlobLead.intAGVROITolerance_Right) * fDrawingScaleX;
                                fHeight = (m_stcSampleBlobLead.fTipLength - m_stcBlobLead.intAGVROITolerance_Top - m_stcBlobLead.intAGVROITolerance_Bottom) * fDrawingScaleY;
                                break;
                            case 8: // Bottom
                                fStartX = (intRoiOrgX + m_stcSampleBlobLead.fTipCenterX - (m_stcSampleBlobLead.fTipWidth / 2) + m_stcBlobLead.intAGVROITolerance_Left) * fDrawingScaleX;
                                fStartY = (intRoiOrgY + m_stcSampleBlobLead.fTipCenterY - m_stcSampleBlobLead.fTipLength + m_stcBlobLead.intAGVROITolerance_Top) * fDrawingScaleY;
                                fWidth = (m_stcSampleBlobLead.fTipWidth - m_stcBlobLead.intAGVROITolerance_Left - m_stcBlobLead.intAGVROITolerance_Right) * fDrawingScaleX;
                                fHeight = (m_stcSampleBlobLead.fTipLength - m_stcBlobLead.intAGVROITolerance_Top - m_stcBlobLead.intAGVROITolerance_Bottom) * fDrawingScaleY;
                                break;
                            case 1: // Left
                                fStartX = (intRoiOrgX + m_stcSampleBlobLead.fTipCenterX + m_stcBlobLead.intAGVROITolerance_Left) * fDrawingScaleX;
                                fStartY = (intRoiOrgY + m_stcSampleBlobLead.fTipCenterY - (m_stcSampleBlobLead.fTipWidth / 2) + m_stcBlobLead.intAGVROITolerance_Top) * fDrawingScaleY;
                                fWidth = (m_stcSampleBlobLead.fTipLength - m_stcBlobLead.intAGVROITolerance_Left - m_stcBlobLead.intAGVROITolerance_Right) * fDrawingScaleX;
                                fHeight = (m_stcSampleBlobLead.fTipWidth - m_stcBlobLead.intAGVROITolerance_Top - m_stcBlobLead.intAGVROITolerance_Bottom) * fDrawingScaleY;
                                break;
                            case 2: // Right
                                fStartX = (intRoiOrgX + m_stcSampleBlobLead.fTipCenterX - m_stcSampleBlobLead.fTipLength + m_stcBlobLead.intAGVROITolerance_Left) * fDrawingScaleX;
                                fStartY = (intRoiOrgY + m_stcSampleBlobLead.fTipCenterY - (m_stcSampleBlobLead.fTipWidth / 2) + m_stcBlobLead.intAGVROITolerance_Top) * fDrawingScaleY;
                                fWidth = (m_stcSampleBlobLead.fTipLength - m_stcBlobLead.intAGVROITolerance_Left - m_stcBlobLead.intAGVROITolerance_Right) * fDrawingScaleX;
                                fHeight = (m_stcSampleBlobLead.fTipWidth - m_stcBlobLead.intAGVROITolerance_Top - m_stcBlobLead.intAGVROITolerance_Bottom) * fDrawingScaleY;
                                break;
                        }
                        g.DrawRectangle(new Pen(Color.Turquoise, 1), fStartX, fStartY, fWidth, fHeight);
                    }

                    //Missing Lead
                    if (m_arrSampleBlobLeads[i].intFailMask == 0x20)//0x04
                    {
                        if (!blnFail)
                            blnFail = true;
                        System.Drawing.PointF pMissing1 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.intStartX, intRoiOrgY + m_stcBlobLead.intStartY);
                        System.Drawing.PointF pMissing2 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.intEndX, intRoiOrgY + m_stcBlobLead.intStartY);
                        System.Drawing.PointF pMissing3 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.intStartX, intRoiOrgY + m_stcBlobLead.intEndY);
                        System.Drawing.PointF pMissing4 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.intEndX, intRoiOrgY + m_stcBlobLead.intEndY);
                        if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                        {
                            pMissing1.X = pMissing1.X * fDrawingScaleX;
                            pMissing1.Y = pMissing1.Y * fDrawingScaleY;
                            pMissing2.X = pMissing2.X * fDrawingScaleX;
                            pMissing2.Y = pMissing2.Y * fDrawingScaleY;
                            pMissing3.X = pMissing3.X * fDrawingScaleX;
                            pMissing3.Y = pMissing3.Y * fDrawingScaleY;
                            pMissing4.X = pMissing4.X * fDrawingScaleX;
                            pMissing4.Y = pMissing4.Y * fDrawingScaleY;
                        }

                        g.DrawLine(new Pen(Color.Red), pMissing1, pMissing2);
                        g.DrawLine(new Pen(Color.Red), pMissing2, pMissing4);
                        g.DrawLine(new Pen(Color.Red), pMissing4, pMissing3);
                        g.DrawLine(new Pen(Color.Red), pMissing3, pMissing1);
                        g.DrawLine(new Pen(Color.Red), pMissing1, pMissing4);

                        // Draw lead lable.
                        switch (m_stcSampleBlobLead.intDirection)
                        {
                            case 4: // Top
                                g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                                        (m_stcSampleBlobLead.fTipCenterX + intRoiOrgX - 15) * fDrawingScaleX,
                                        (m_stcSampleBlobLead.fTipCenterY + intRoiOrgY - 40) * fDrawingScaleY);
                                break;
                            case 2: // Right
                                g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                                        (m_stcSampleBlobLead.fTipCenterX + intRoiOrgX + 10) * fDrawingScaleX,
                                        (m_stcSampleBlobLead.fTipCenterY + intRoiOrgY - 15) * fDrawingScaleY);
                                break;
                            case 8: // Bottom
                                g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                                        (m_stcSampleBlobLead.fTipCenterX + intRoiOrgX - 15) * fDrawingScaleX,
                                        (m_stcSampleBlobLead.fTipCenterY + intRoiOrgY + 10) * fDrawingScaleY);
                                break;
                            case 1: // Left
                                g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                                        (m_stcSampleBlobLead.fTipCenterX + intRoiOrgX - 40) * fDrawingScaleX,
                                        (m_stcSampleBlobLead.fTipCenterY + intRoiOrgY - 15) * fDrawingScaleY);
                                break;
                        }
                        //switch (m_stcBlobLead.intDirection)
                        //{
                        //    case 4: // Top
                        //        g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                        //                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCenterX + intRoiOrgX - 15) * fDrawingScaleX,
                        //                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCenterY + intRoiOrgY - 40) * fDrawingScaleY);
                        //        break;
                        //    case 2: // Right
                        //        g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                        //                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fEndX + intRoiOrgX + 10) * fDrawingScaleX,
                        //                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCenterY + intRoiOrgY - 15) * fDrawingScaleY);
                        //        break;
                        //    case 8: // Bottom
                        //        g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                        //                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCenterX + intRoiOrgX - 15) * fDrawingScaleX,
                        //                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCenterY + intRoiOrgY + 10) * fDrawingScaleY);
                        //        break;
                        //    case 1: // Left
                        //        g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                        //                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fStartX + intRoiOrgX - 40) * fDrawingScaleX,
                        //                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCenterY + intRoiOrgY - 15) * fDrawingScaleY);
                        //        break;
                        //}
                    }
                }
                //Extra, Join Lead, Excess Lead
                for (int i = 0; i < m_arrExtraBlobs.Count; i++)
                {
                    if (m_blnLock)
                        return;

                    //if (i == intLeadSelectingNumber)
                    //{
                    //    System.Drawing.PointF p1 = new System.Drawing.PointF(intRoiOrgX + m_arrExtraBlobs[i].fStartX, intRoiOrgY + m_arrExtraBlobs[i].fStartY);
                    //    System.Drawing.PointF p2 = new System.Drawing.PointF(intRoiOrgX + m_arrExtraBlobs[i].fEndX, intRoiOrgY + m_arrExtraBlobs[i].fStartY);
                    //    System.Drawing.PointF p3 = new System.Drawing.PointF(intRoiOrgX + m_arrExtraBlobs[i].fStartX, intRoiOrgY + m_arrExtraBlobs[i].fEndY);
                    //    System.Drawing.PointF p4 = new System.Drawing.PointF(intRoiOrgX + m_arrExtraBlobs[i].fEndX, intRoiOrgY + m_arrExtraBlobs[i].fEndY);

                    //    if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                    //    {
                    //        p1.X = p1.X * fDrawingScaleX;
                    //        p1.Y = p1.Y * fDrawingScaleY;
                    //        p2.X = p2.X * fDrawingScaleX;
                    //        p2.Y = p2.Y * fDrawingScaleY;
                    //        p3.X = p3.X * fDrawingScaleX;
                    //        p3.Y = p3.Y * fDrawingScaleY;
                    //        p4.X = p4.X * fDrawingScaleX;
                    //        p4.Y = p4.Y * fDrawingScaleY;
                    //    }

                    //    g.DrawLine(new Pen(Color.Lime), p1, p2);
                    //    g.DrawLine(new Pen(Color.Lime), p2, p4);
                    //    g.DrawLine(new Pen(Color.Lime), p4, p3);
                    //    g.DrawLine(new Pen(Color.Lime), p3, p1);
                    //    continue;
                    //}
                    //else
                    {
                        if (m_blnLock)
                            return;

                        System.Drawing.PointF p1 = new System.Drawing.PointF(intRoiOrgX + m_arrExtraBlobs[i].fStartX, intRoiOrgY + m_arrExtraBlobs[i].fStartY);
                        System.Drawing.PointF p2 = new System.Drawing.PointF(intRoiOrgX + m_arrExtraBlobs[i].fEndX, intRoiOrgY + m_arrExtraBlobs[i].fStartY);
                        System.Drawing.PointF p3 = new System.Drawing.PointF(intRoiOrgX + m_arrExtraBlobs[i].fStartX, intRoiOrgY + m_arrExtraBlobs[i].fEndY);
                        System.Drawing.PointF p4 = new System.Drawing.PointF(intRoiOrgX + m_arrExtraBlobs[i].fEndX, intRoiOrgY + m_arrExtraBlobs[i].fEndY);

                        if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                        {
                            p1.X = p1.X * fDrawingScaleX;
                            p1.Y = p1.Y * fDrawingScaleY;
                            p2.X = p2.X * fDrawingScaleX;
                            p2.Y = p2.Y * fDrawingScaleY;
                            p3.X = p3.X * fDrawingScaleX;
                            p3.Y = p3.Y * fDrawingScaleY;
                            p4.X = p4.X * fDrawingScaleX;
                            p4.Y = p4.Y * fDrawingScaleY;
                        }

                        if (m_arrFailResultMask[0] > 0)//m_arrExtraBlobs[i].ref_intFailCriteria 
                        {
                            if (!blnFail)
                                blnFail = true;
                            g.DrawLine(new Pen(Color.Red), p1, p2);
                            g.DrawLine(new Pen(Color.Red), p2, p4);
                            g.DrawLine(new Pen(Color.Red), p4, p3);
                            g.DrawLine(new Pen(Color.Red), p3, p1);
                            g.DrawLine(new Pen(Color.Red), p1, p4);
                        }
                        else
                        {
                            g.DrawLine(new Pen(Color.Lime), p1, p2);
                            g.DrawLine(new Pen(Color.Lime), p2, p4);
                            g.DrawLine(new Pen(Color.Lime), p4, p3);
                            g.DrawLine(new Pen(Color.Lime), p3, p1);
                            g.DrawLine(new Pen(Color.Lime), p1, p4);
                        }
                    }
                }

                for (int i = 0; i < m_arrFailPitchGapList.Count; i++)
                {
                    if (m_blnLock)
                        return;
                    if (!blnFail)
                        blnFail = true;
                    g.DrawLine(new Pen(Color.Red), (float)(m_arrFailPitchGapList[i].intStartPointX - 5) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intStartPointY - 5) * fDrawingScaleY,
                                       (float)(m_arrFailPitchGapList[i].intStartPointX + 5) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intStartPointY + 5) * fDrawingScaleY);
                    g.DrawLine(new Pen(Color.Red), (float)(m_arrFailPitchGapList[i].intStartPointX + 5) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intStartPointY - 5) * fDrawingScaleY,
                                       (float)(m_arrFailPitchGapList[i].intStartPointX - 5) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intStartPointY + 5) * fDrawingScaleY);
                    g.DrawLine(new Pen(Color.Red), (float)(m_arrFailPitchGapList[i].intEndPointX - 5) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intEndPointY - 5) * fDrawingScaleY,
                                       (float)(m_arrFailPitchGapList[i].intEndPointX + 5) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intEndPointY + 5) * fDrawingScaleY);
                    g.DrawLine(new Pen(Color.Red), (float)(m_arrFailPitchGapList[i].intEndPointX + 5) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intEndPointY - 5) * fDrawingScaleY,
                                       (float)(m_arrFailPitchGapList[i].intEndPointX - 5) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intEndPointY + 5) * fDrawingScaleY);
                    g.DrawLine(new Pen(Color.Red), (float)(m_arrFailPitchGapList[i].intStartPointX) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intStartPointY) * fDrawingScaleY,
                                       (float)(m_arrFailPitchGapList[i].intEndPointX) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intEndPointY) * fDrawingScaleY);

                }

                if (blnFail && !m_blnLock)
                {
                    objROI.DrawROI(g, fDrawingScaleX, fDrawingScaleY, false, 0, Color.Red);
                }
            }
        }

        public void DrawInspectionObjects_Lead3D_Side(Graphics g, float fDrawingScaleX, float fDrawingScaleY, ROI objROI, int intLeadPosition)
        {

            lock (m_objLockBlobs)
            {
                bool blnFail = false;
                int intRoiOrgX = objROI.ref_ROITotalX;
                int intRoiOrgY = objROI.ref_ROITotalY;
                if (m_intLeadROIDirection == 1 || m_intLeadROIDirection == 3)
                {
                    int intLeftX = (int)Math.Round(m_pCornerPoint_Left.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                    int intLeftY = (int)Math.Round(m_pCornerPoint_Left.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                    int intRightX = (int)Math.Round(m_pCornerPoint_Right.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                    int intRightY = (int)Math.Round(m_pCornerPoint_Right.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);

                    m_objLineGauge.DrawResultLineGauge(g, Color.DarkViolet);
                    //m_objBaseLine.DrawLineByPoints(g, fDrawingScaleX, fDrawingScaleY, m_pCornerPoint_Left.X, m_pCornerPoint_Right.X, Color.Lime, 1);

                    g.DrawLine(new Pen(Color.DarkViolet, 1), intLeftX - 5, intLeftY, intLeftX + 5, intLeftY);
                    g.DrawLine(new Pen(Color.DarkViolet, 1), intLeftX, intLeftY - 5, intLeftX, intLeftY + 5);
                    g.DrawLine(new Pen(Color.DarkViolet, 1), intRightX - 5, intRightY, intRightX + 5, intRightY);
                    g.DrawLine(new Pen(Color.DarkViolet, 1), intRightX, intRightY - 5, intRightX, intRightY + 5);
                }
                else
                {
                    int intTopX = (int)Math.Round(m_pCornerPoint_Top.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                    int intTopY = (int)Math.Round(m_pCornerPoint_Top.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                    int intBottomX = (int)Math.Round(m_pCornerPoint_Bottom.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                    int intBottomY = (int)Math.Round(m_pCornerPoint_Bottom.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);

                    m_objLineGauge.DrawResultLineGauge(g, Color.DarkViolet);
                    //m_objBaseLine.DrawLineByPoints(g, fDrawingScaleX, fDrawingScaleY, m_pCornerPoint_Top.X, m_pCornerPoint_Bottom.X, Color.Lime, 1);

                    g.DrawLine(new Pen(Color.DarkViolet, 1), intTopX - 5, intTopY, intTopX + 5, intTopY);
                    g.DrawLine(new Pen(Color.DarkViolet, 1), intTopX, intTopY - 5, intTopX, intTopY + 5);
                    g.DrawLine(new Pen(Color.DarkViolet, 1), intBottomX - 5, intBottomY, intBottomX + 5, intBottomY);
                    g.DrawLine(new Pen(Color.DarkViolet, 1), intBottomX, intBottomY - 5, intBottomX, intBottomY + 5);
                }

                // Draw center lead tip, base and, width and length.
                for (int i = 0; i < m_arrSampleBlobLeads.Length; i++)
                {
                    if (m_intLeadDirection == 0)
                    {
                        if (m_intLeadROIDirection == 1 || m_intLeadROIDirection == 3)
                        {
                            continue;
                        }
                    }
                    else
                    {
                        if (m_intLeadROIDirection == 2 || m_intLeadROIDirection == 4)
                        {
                            continue;
                        }
                    }
                    m_stcSampleBlobLead = m_arrSampleBlobLeads[i];

                    System.Drawing.PointF p1 = new PointF();
                    System.Drawing.PointF p2 = new PointF();
                    System.Drawing.PointF p3 = new PointF();

                    switch (m_stcSampleBlobLead.intDirection)
                    {
                        case 4:
                            p1 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fTipCenterX, intRoiOrgY + m_stcSampleBlobLead.fTipCenterY);
                            p2 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fTipCenterX - m_stcSampleBlobLead.fTipWidth / 2, intRoiOrgY + m_stcSampleBlobLead.fTipCenterY + m_intTipOffset);
                            p3 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fTipCenterX + m_stcSampleBlobLead.fTipWidth / 2, intRoiOrgY + m_stcSampleBlobLead.fTipCenterY + m_intTipOffset);
                            break;
                        case 2:
                            p1 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fTipCenterX, intRoiOrgY + m_stcSampleBlobLead.fTipCenterY);
                            p2 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fTipCenterX - m_intTipOffset, intRoiOrgY + m_stcSampleBlobLead.fTipCenterY - m_stcSampleBlobLead.fTipWidth / 2);
                            p3 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fTipCenterX - m_intTipOffset, intRoiOrgY + m_stcSampleBlobLead.fTipCenterY + m_stcSampleBlobLead.fTipWidth / 2);

                            break;
                        case 8:
                            p1 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fTipCenterX, intRoiOrgY + m_stcSampleBlobLead.fTipCenterY);
                            p2 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fTipCenterX - m_stcSampleBlobLead.fTipWidth / 2, intRoiOrgY + m_stcSampleBlobLead.fTipCenterY - m_intTipOffset);
                            p3 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fTipCenterX + m_stcSampleBlobLead.fTipWidth / 2, intRoiOrgY + m_stcSampleBlobLead.fTipCenterY - m_intTipOffset);
                            break;
                        case 1:
                            p1 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fTipCenterX, intRoiOrgY + m_stcSampleBlobLead.fTipCenterY);
                            p2 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fTipCenterX + m_intTipOffset, intRoiOrgY + m_stcSampleBlobLead.fTipCenterY - m_stcSampleBlobLead.fTipWidth / 2);
                            p3 = new System.Drawing.PointF(intRoiOrgX + m_stcSampleBlobLead.fTipCenterX + m_intTipOffset, intRoiOrgY + m_stcSampleBlobLead.fTipCenterY + m_stcSampleBlobLead.fTipWidth / 2);
                            break;
                    }

                    if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                    {
                        p1.X = p1.X * fDrawingScaleX;
                        p1.Y = p1.Y * fDrawingScaleY;
                        p2.X = p2.X * fDrawingScaleX;
                        p2.Y = p2.Y * fDrawingScaleY;
                        p3.X = p3.X * fDrawingScaleX;
                        p3.Y = p3.Y * fDrawingScaleY;
                    }

                    switch (m_stcSampleBlobLead.intDirection)
                    {
                        // Draw Red Rectangle on side tip when fail stand off or coplanarity 
                        case 4: // Top
                            //if (((m_stcSampleBlobLead.intFailMask & 0x01) > 0) || ((m_stcSampleBlobLead.intFailMask & 0x02) > 0))
                            if (((m_stcSampleBlobLead.intFailMask & 0x01) > 0) || ((m_stcSampleBlobLead.intFailMask & 0x02) > 0) || ((m_stcSampleBlobLead.intFailMask & 0x400000) > 0))
                            {
                                g.DrawRectangle(new Pen(Color.Red, 1), p2.X - 5, p1.Y - 5, p3.X - p2.X + 10, Math.Max(p2.Y, p3.Y) - p1.Y + 10);
                                if (!blnFail)
                                    blnFail = true;
                            }
                            else
                            {
                                g.DrawRectangle(new Pen(Color.Lime, 1), p2.X - 5, p1.Y - 5, p3.X - p2.X + 10, Math.Max(p2.Y, p3.Y) - p1.Y + 10);
                            }
                            break;
                        case 2: // Right
                            //if (((m_stcSampleBlobLead.intFailMask & 0x01) > 0) || ((m_stcSampleBlobLead.intFailMask & 0x02) > 0))
                            if (((m_stcSampleBlobLead.intFailMask & 0x01) > 0) || ((m_stcSampleBlobLead.intFailMask & 0x02) > 0) || ((m_stcSampleBlobLead.intFailMask & 0x400000) > 0))
                            {
                                g.DrawRectangle(new Pen(Color.Red, 1), Math.Min(p3.X, p2.X) - 5, p2.Y - 5, p1.X - Math.Min(p3.X, p2.X) + 10, p3.Y - p2.Y + 10);
                                if (!blnFail)
                                    blnFail = true;
                            }
                            else
                            {
                                g.DrawRectangle(new Pen(Color.Lime, 1), Math.Min(p3.X, p2.X) - 5, p2.Y - 5, p1.X - Math.Min(p3.X, p2.X) + 10, p3.Y - p2.Y + 10);
                            }
                            break;
                        case 8: // Bottom
                            //if (((m_stcSampleBlobLead.intFailMask & 0x01) > 0) || ((m_stcSampleBlobLead.intFailMask & 0x02) > 0))
                            if (((m_stcSampleBlobLead.intFailMask & 0x01) > 0) || ((m_stcSampleBlobLead.intFailMask & 0x02) > 0) || ((m_stcSampleBlobLead.intFailMask & 0x400000) > 0))
                            {
                                g.DrawRectangle(new Pen(Color.Red, 1), p2.X - 5, Math.Min(p2.Y, p3.Y) - 5, p3.X - p2.X + 10, p1.Y - Math.Min(p2.Y, p3.Y) + 10);
                                if (!blnFail)
                                    blnFail = true;
                            }
                            else
                            {
                                g.DrawRectangle(new Pen(Color.Lime, 1), p2.X - 5, Math.Min(p2.Y, p3.Y) - 5, p3.X - p2.X + 10, p1.Y - Math.Min(p2.Y, p3.Y) + 10);
                            }
                            break;
                        case 1: // Left
                            //if (((m_stcSampleBlobLead.intFailMask & 0x01) > 0) || ((m_stcSampleBlobLead.intFailMask & 0x02) > 0))
                            if (((m_stcSampleBlobLead.intFailMask & 0x01) > 0) || ((m_stcSampleBlobLead.intFailMask & 0x02) > 0) || ((m_stcSampleBlobLead.intFailMask & 0x400000) > 0))
                            {
                                g.DrawRectangle(new Pen(Color.Red, 1), p1.X - 5, p2.Y - 5, Math.Max(p3.X, p2.X) - p1.X + 10, p3.Y - p2.Y + 10);
                                if (!blnFail)
                                    blnFail = true;
                            }
                            else
                            {
                                g.DrawRectangle(new Pen(Color.Lime, 1), p1.X - 5, p2.Y - 5, Math.Max(p3.X, p2.X) - p1.X + 10, p3.Y - p2.Y + 10);
                            }
                            break;
                    }

                    //g.DrawLine(new Pen(Color.Lime, 1), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                    //g.DrawLine(new Pen(Color.Lime, 1), p1.X - 3, p1.Y, p1.X + 3, p1.Y);

                    //g.DrawLine(new Pen(Color.Lime, 1), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                    //g.DrawLine(new Pen(Color.Lime, 1), p2.X - 3, p2.Y, p2.X + 3, p2.Y);

                    //g.DrawLine(new Pen(Color.Lime, 1), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                    //g.DrawLine(new Pen(Color.Lime, 1), p3.X - 3, p3.Y, p3.X + 3, p3.Y);

                    if (m_stcSampleBlobLead.blnTipCenterFound)
                    {
                        g.DrawLine(new Pen(Color.Lime, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                        g.DrawLine(new Pen(Color.Lime, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                    }
                    else
                    {
                        g.DrawLine(new Pen(Color.Red, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                        g.DrawLine(new Pen(Color.Red, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                    }

                    if (m_stcSampleBlobLead.blnTipStartFound)
                    {
                        g.DrawLine(new Pen(Color.Lime, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                        g.DrawLine(new Pen(Color.Lime, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                    }
                    else
                    {
                        if (m_stcSampleBlobLead.blnTipCenterFound)
                        {
                            g.DrawLine(new Pen(Color.Yellow, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                            g.DrawLine(new Pen(Color.Yellow, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                        }
                        else
                        {
                            g.DrawLine(new Pen(Color.Red, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                            g.DrawLine(new Pen(Color.Red, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                        }
                    }

                    if (m_stcSampleBlobLead.blnTipEndFound)
                    {
                        g.DrawLine(new Pen(Color.Lime, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                        g.DrawLine(new Pen(Color.Lime, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                    }
                    else
                    {
                        if (m_stcSampleBlobLead.blnTipCenterFound)
                        {
                            g.DrawLine(new Pen(Color.Yellow, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                            g.DrawLine(new Pen(Color.Yellow, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                        }
                        else
                        {
                            g.DrawLine(new Pen(Color.Red, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                            g.DrawLine(new Pen(Color.Red, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                        }
                    }

                    // Draw lead lable.
                    switch (m_stcSampleBlobLead.intDirection)
                    {
                        case 4: // Top
                            g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Blue),
                                    (m_stcSampleBlobLead.fTipCenterX + intRoiOrgX - 15) * fDrawingScaleX,
                                    (m_stcSampleBlobLead.fTipCenterY + intRoiOrgY - 40) * fDrawingScaleY);
                            break;
                        case 2: // Right
                            g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Blue),
                                    (m_stcSampleBlobLead.fTipCenterX + intRoiOrgX + 10) * fDrawingScaleX,
                                    (m_stcSampleBlobLead.fTipCenterY + intRoiOrgY - 15) * fDrawingScaleY);
                            break;
                        case 8: // Bottom
                            g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Blue),
                                    (m_stcSampleBlobLead.fTipCenterX + intRoiOrgX - 15) * fDrawingScaleX,
                                    (m_stcSampleBlobLead.fTipCenterY + intRoiOrgY + 10) * fDrawingScaleY);
                            break;
                        case 1: // Left
                            g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Blue),
                                    (m_stcSampleBlobLead.fTipCenterX + intRoiOrgX - 40) * fDrawingScaleX,
                                    (m_stcSampleBlobLead.fTipCenterY + intRoiOrgY - 15) * fDrawingScaleY);
                            break;
                    }
                    //switch (m_stcSampleBlobLead.intDirection)
                    //{
                    //    case 4: // Top
                    //        g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Blue),
                    //                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fTipCenterX + intRoiOrgX - 15) * fDrawingScaleX,
                    //                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fTipCenterY + intRoiOrgY - 40) * fDrawingScaleY);
                    //        break;
                    //    case 2: // Right
                    //        g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Blue),
                    //                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fTipCenterX + intRoiOrgX + 10) * fDrawingScaleX,
                    //                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fTipCenterY + intRoiOrgY - 15) * fDrawingScaleY);
                    //        break;
                    //    case 8: // Bottom
                    //        g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Blue),
                    //                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fTipCenterX + intRoiOrgX - 15) * fDrawingScaleX,
                    //                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fTipCenterY + intRoiOrgY + 10) * fDrawingScaleY);
                    //        break;
                    //    case 1: // Left
                    //        g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Blue),
                    //                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fTipCenterX + intRoiOrgX - 40) * fDrawingScaleX,
                    //                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fTipCenterY + intRoiOrgY - 15) * fDrawingScaleY);
                    //        break;
                    //}
                }
                if ((blnFail || !m_blnBuildSideLeadSuccess) && !m_blnLock)
                {
                    objROI.DrawROI(g, fDrawingScaleX, fDrawingScaleY, false, 0, Color.Red);
                }
            }
        }

        /// <summary>
        /// Draw Lead display result
        /// </summary>
        /// <param name="g">destination image to be drawn</param>
        /// <param name="intLeadSelectingNumber">Lead selecting no</param>
        /// <param name="intRoiOrgX">ROI origin X</param>
        /// <param name="intRoiOrgY">ROI origin Y</param>
        /// <param name="fScale"></param>
        /// <param name="intZoomImageEdgeX">translation factor for panning in the horizontal direction</param>
        /// <param name="intZoomImageEdgeY">translation factor for panning in the vertical direction</param>
        public void DrawLeadDisplayResult(Graphics g, float fDrawingScaleX, float fDrawingScaleY, int intLeadSelectingNumber, int intRoiOrgX, int intRoiOrgY, int intLeadPosition)
        {
            lock (m_objLockBlobs)
            {
                if (m_blnLock)
                    return;

                Pen redPen = new Pen(Color.Red);
                Pen limePen = new Pen(Color.Lime);
                Pen bluePen = new Pen(Color.Blue);
                if (m_arrSampleBlobLeads.Length != 0 && m_arrSampleBlobLeads[0].fArea == 0)
                {
                    for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
                    {
                        if (m_blnLock)
                            return;

                        m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                        System.Drawing.PointF p1 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.intStartX, intRoiOrgY + m_stcBlobLead.intStartY);
                        System.Drawing.PointF p2 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.intEndX, intRoiOrgY + m_stcBlobLead.intStartY);
                        System.Drawing.PointF p3 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.intStartX, intRoiOrgY + m_stcBlobLead.intEndY);
                        System.Drawing.PointF p4 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.intEndX, intRoiOrgY + m_stcBlobLead.intEndY);

                        if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                        {
                            p1.X = p1.X * fDrawingScaleX;
                            p1.Y = p1.Y * fDrawingScaleY;
                            p2.X = p2.X * fDrawingScaleX;
                            p2.Y = p2.Y * fDrawingScaleY;
                            p3.X = p3.X * fDrawingScaleX;
                            p3.Y = p3.Y * fDrawingScaleY;
                            p4.X = p4.X * fDrawingScaleX;
                            p4.Y = p4.Y * fDrawingScaleY;
                        }

                        g.DrawLine(redPen, p1, p2);
                        g.DrawLine(redPen, p2, p4);
                        g.DrawLine(redPen, p4, p3);
                        g.DrawLine(redPen, p3, p1);
                        g.DrawLine(redPen, p1, p4);
                        g.DrawString(m_stcBlobLead.intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                            (float)(m_stcBlobLead.fCenterX + intRoiOrgX - 8) * fDrawingScaleX,
                            (float)(m_stcBlobLead.fCenterY + intRoiOrgY - 8) * fDrawingScaleY);
                    }
                }
                else
                {
                    //Extra, Join Lead, Excess Lead
                    for (int i = 0; i < m_arrExtraBlobs.Count; i++)
                    {
                        if (m_blnLock)
                            return;

                        if (i == intLeadSelectingNumber)
                        {
                            System.Drawing.PointF p1 = new System.Drawing.PointF(intRoiOrgX + m_arrExtraBlobs[i].fStartX, intRoiOrgY + m_arrExtraBlobs[i].fStartY);
                            System.Drawing.PointF p2 = new System.Drawing.PointF(intRoiOrgX + m_arrExtraBlobs[i].fEndX, intRoiOrgY + m_arrExtraBlobs[i].fStartY);
                            System.Drawing.PointF p3 = new System.Drawing.PointF(intRoiOrgX + m_arrExtraBlobs[i].fStartX, intRoiOrgY + m_arrExtraBlobs[i].fEndY);
                            System.Drawing.PointF p4 = new System.Drawing.PointF(intRoiOrgX + m_arrExtraBlobs[i].fEndX, intRoiOrgY + m_arrExtraBlobs[i].fEndY);

                            if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                            {
                                p1.X = p1.X * fDrawingScaleX;
                                p1.Y = p1.Y * fDrawingScaleY;
                                p2.X = p2.X * fDrawingScaleX;
                                p2.Y = p2.Y * fDrawingScaleY;
                                p3.X = p3.X * fDrawingScaleX;
                                p3.Y = p3.Y * fDrawingScaleY;
                                p4.X = p4.X * fDrawingScaleX;
                                p4.Y = p4.Y * fDrawingScaleY;
                            }

                            g.DrawLine(new Pen(Color.Lime), p1, p2);
                            g.DrawLine(new Pen(Color.Lime), p2, p4);
                            g.DrawLine(new Pen(Color.Lime), p4, p3);
                            g.DrawLine(new Pen(Color.Lime), p3, p1);
                            continue;
                        }
                        else
                        {
                            if (m_blnLock)
                                return;

                            System.Drawing.PointF p1 = new System.Drawing.PointF(intRoiOrgX + m_arrExtraBlobs[i].fStartX, intRoiOrgY + m_arrExtraBlobs[i].fStartY);
                            System.Drawing.PointF p2 = new System.Drawing.PointF(intRoiOrgX + m_arrExtraBlobs[i].fEndX, intRoiOrgY + m_arrExtraBlobs[i].fStartY);
                            System.Drawing.PointF p3 = new System.Drawing.PointF(intRoiOrgX + m_arrExtraBlobs[i].fStartX, intRoiOrgY + m_arrExtraBlobs[i].fEndY);
                            System.Drawing.PointF p4 = new System.Drawing.PointF(intRoiOrgX + m_arrExtraBlobs[i].fEndX, intRoiOrgY + m_arrExtraBlobs[i].fEndY);

                            if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                            {
                                p1.X = p1.X * fDrawingScaleX;
                                p1.Y = p1.Y * fDrawingScaleY;
                                p2.X = p2.X * fDrawingScaleX;
                                p2.Y = p2.Y * fDrawingScaleY;
                                p3.X = p3.X * fDrawingScaleX;
                                p3.Y = p3.Y * fDrawingScaleY;
                                p4.X = p4.X * fDrawingScaleX;
                                p4.Y = p4.Y * fDrawingScaleY;
                            }

                            g.DrawLine(redPen, p1, p2);
                            g.DrawLine(redPen, p2, p4);
                            g.DrawLine(redPen, p4, p3);
                            g.DrawLine(redPen, p3, p1);
                            g.DrawLine(redPen, p1, p4);
                        }
                    }

                    for (int i = 0; i < m_arrSampleBlobLeads.Length; i++)
                    {
                        if (m_blnLock)
                            return;
                        /*if (i == intLeadSelectingNumber)
                        {
                            m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                            System.Drawing.Point p1 = new System.Drawing.Point(intRoiOrgX + m_stcBlobLead.intStartX, intRoiOrgY + m_stcBlobLead.intStartY);
                            System.Drawing.Point p2 = new System.Drawing.Point(intRoiOrgX + m_stcBlobLead.intEndX, intRoiOrgY + m_stcBlobLead.intStartY);
                            System.Drawing.Point p3 = new System.Drawing.Point(intRoiOrgX + m_stcBlobLead.intStartX, intRoiOrgY + m_stcBlobLead.intEndY);
                            System.Drawing.Point p4 = new System.Drawing.Point(intRoiOrgX + m_stcBlobLead.intEndX, intRoiOrgY + m_stcBlobLead.intEndY);
                            g.DrawLine(new Pen(Color.Lime), p1, p2);
                            g.DrawLine(new Pen(Color.Lime), p2, p4);
                            g.DrawLine(new Pen(Color.Lime), p4, p3);
                            g.DrawLine(new Pen(Color.Lime), p3, p1);
                            g.DrawString(m_stcBlobLead.intNoID.ToString(), m_Font, new SolidBrush(Color.Red), (float)(m_stcBlobLead.fCenterX + intRoiOrgX - 8), (float)(m_stcBlobLead.fCenterY + intRoiOrgY - 8));
                            continue;
                        }*/

                        //Missing Lead
                        if (m_arrSampleBlobLeads[i].intFailMask == 0x20)//0x04
                        {
                            m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                            System.Drawing.PointF p1 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.intStartX, intRoiOrgY + m_stcBlobLead.intStartY);
                            System.Drawing.PointF p2 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.intEndX, intRoiOrgY + m_stcBlobLead.intStartY);
                            System.Drawing.PointF p3 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.intStartX, intRoiOrgY + m_stcBlobLead.intEndY);
                            System.Drawing.PointF p4 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.intEndX, intRoiOrgY + m_stcBlobLead.intEndY);
                            if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                            {
                                p1.X = p1.X * fDrawingScaleX;
                                p1.Y = p1.Y * fDrawingScaleY;
                                p2.X = p2.X * fDrawingScaleX;
                                p2.Y = p2.Y * fDrawingScaleY;
                                p3.X = p3.X * fDrawingScaleX;
                                p3.Y = p3.Y * fDrawingScaleY;
                                p4.X = p4.X * fDrawingScaleX;
                                p4.Y = p4.Y * fDrawingScaleY;
                            }

                            g.DrawLine(redPen, p1, p2);
                            g.DrawLine(redPen, p2, p4);
                            g.DrawLine(redPen, p4, p3);
                            g.DrawLine(redPen, p3, p1);
                            g.DrawLine(redPen, p1, p4);

                            switch (intLeadPosition)
                            {
                                case 1:
                                    g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                                            ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCenterX + intRoiOrgX) * fDrawingScaleX,
                                            ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCenterY + intRoiOrgY - 40) * fDrawingScaleY);
                                    break;
                                case 2:
                                    g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                                            ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCenterX + intRoiOrgX + 27) * fDrawingScaleX,
                                            ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCenterY + intRoiOrgY - 8) * fDrawingScaleY);
                                    break;
                                case 3:
                                    g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                                            ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCenterX + intRoiOrgX) * fDrawingScaleX,
                                            ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCenterY + intRoiOrgY + 27) * fDrawingScaleY);
                                    break;
                                case 4:
                                    g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                                            ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCenterX + intRoiOrgX - 40) * fDrawingScaleX,
                                            ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCenterY + intRoiOrgY - 8) * fDrawingScaleY);
                                    break;
                            }
                        }
                        //Valid Lead
                        else if (m_arrSampleBlobLeads[i].intFailMask == 0)
                        {
                            System.Drawing.PointF p1 = new PointF();
                            System.Drawing.PointF p2 = new PointF();
                            System.Drawing.PointF p3 = new PointF();
                            System.Drawing.PointF p4 = new PointF();
                            System.Drawing.PointF p5 = new PointF();
                            System.Drawing.PointF p6 = new PointF();

                            if ((intLeadSelectingNumber == -1) || (i == intLeadSelectingNumber))
                            {

                                switch (intLeadPosition)
                                {
                                    case 1:
                                        p1 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX - m_arrSampleBlobLeads[i].fTipWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY - (m_arrSampleBlobLeads[i].fHeight / 2) + m_intTipOffset);
                                        p2 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX + m_arrSampleBlobLeads[i].fTipWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY - (m_arrSampleBlobLeads[i].fHeight / 2) + m_intTipOffset);
                                        p3 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX - m_arrSampleBlobLeads[i].fBaseWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY + (m_arrSampleBlobLeads[i].fHeight / 2) - m_intBaseOffset);
                                        p4 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX + m_arrSampleBlobLeads[i].fBaseWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY + (m_arrSampleBlobLeads[i].fHeight / 2) - m_intBaseOffset);
                                        p5 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY - (m_arrSampleBlobLeads[i].fHeight / 2));
                                        p6 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY + (m_arrSampleBlobLeads[i].fHeight / 2));
                                        break;
                                    case 2:
                                        p1 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX - m_arrSampleBlobLeads[i].fWidth / 2 + m_intBaseOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY - (m_arrSampleBlobLeads[i].fBaseLength / 2));
                                        p2 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX + m_arrSampleBlobLeads[i].fWidth / 2 - m_intTipOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY - (m_arrSampleBlobLeads[i].fTipLength / 2));
                                        p3 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX - m_arrSampleBlobLeads[i].fWidth / 2 + m_intBaseOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY + (m_arrSampleBlobLeads[i].fBaseLength / 2));
                                        p4 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX + m_arrSampleBlobLeads[i].fWidth / 2 - m_intTipOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY + (m_arrSampleBlobLeads[i].fTipLength / 2));
                                        p5 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX - (m_arrSampleBlobLeads[i].fWidth / 2), intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY);
                                        p6 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX + (m_arrSampleBlobLeads[i].fWidth / 2), intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY);
                                        break;
                                    case 3:
                                        p1 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX - m_arrSampleBlobLeads[i].fBaseWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY - (m_arrSampleBlobLeads[i].fHeight / 2) + m_intBaseOffset);
                                        p2 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX + m_arrSampleBlobLeads[i].fBaseWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY - (m_arrSampleBlobLeads[i].fHeight / 2) + m_intBaseOffset);
                                        p3 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX - m_arrSampleBlobLeads[i].fTipWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY + (m_arrSampleBlobLeads[i].fHeight / 2) - m_intTipOffset);
                                        p4 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX + m_arrSampleBlobLeads[i].fTipWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY + (m_arrSampleBlobLeads[i].fHeight / 2) - m_intTipOffset);
                                        p5 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY - (m_arrSampleBlobLeads[i].fHeight / 2));
                                        p6 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY + (m_arrSampleBlobLeads[i].fHeight / 2));
                                        break;
                                    case 4:
                                        p1 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX - m_arrSampleBlobLeads[i].fWidth / 2 + m_intTipOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY - (m_arrSampleBlobLeads[i].fTipLength / 2));
                                        p2 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX + m_arrSampleBlobLeads[i].fWidth / 2 - m_intBaseOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY - (m_arrSampleBlobLeads[i].fBaseLength / 2));
                                        p3 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX - m_arrSampleBlobLeads[i].fWidth / 2 + m_intTipOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY + (m_arrSampleBlobLeads[i].fTipLength / 2));
                                        p4 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX + m_arrSampleBlobLeads[i].fWidth / 2 - m_intBaseOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY + (m_arrSampleBlobLeads[i].fBaseLength / 2));
                                        p5 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX - (m_arrSampleBlobLeads[i].fWidth / 2), intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY);
                                        p6 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX + (m_arrSampleBlobLeads[i].fWidth / 2), intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY);
                                        break;
                                }

                                if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                                {
                                    p1.X = p1.X * fDrawingScaleX;
                                    p1.Y = p1.Y * fDrawingScaleY;
                                    p2.X = p2.X * fDrawingScaleX;
                                    p2.Y = p2.Y * fDrawingScaleY;
                                    p3.X = p3.X * fDrawingScaleX;
                                    p3.Y = p3.Y * fDrawingScaleY;
                                    p4.X = p4.X * fDrawingScaleX;
                                    p4.Y = p4.Y * fDrawingScaleY;
                                    p5.X = p5.X * fDrawingScaleX;
                                    p5.Y = p5.Y * fDrawingScaleY;
                                    p6.X = p6.X * fDrawingScaleX;
                                    p6.Y = p6.Y * fDrawingScaleY;
                                }

                                g.DrawLine(new Pen(Color.Red, 1), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                                g.DrawLine(new Pen(Color.Red, 1), p1.X - 3, p1.Y, p1.X + 3, p1.Y);

                                g.DrawLine(new Pen(Color.Red, 1), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                                g.DrawLine(new Pen(Color.Red, 1), p2.X - 3, p2.Y, p2.X + 3, p2.Y);

                                g.DrawLine(new Pen(Color.Red, 1), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                                g.DrawLine(new Pen(Color.Red, 1), p3.X - 3, p3.Y, p3.X + 3, p3.Y);

                                g.DrawLine(new Pen(Color.Red, 1), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                                g.DrawLine(new Pen(Color.Red, 1), p4.X - 3, p4.Y, p4.X + 3, p4.Y);

                                g.DrawLine(new Pen(Color.Red, 1), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                                g.DrawLine(new Pen(Color.Red, 1), p5.X - 3, p5.Y, p5.X + 3, p5.Y);

                                g.DrawLine(new Pen(Color.Red, 1), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                                g.DrawLine(new Pen(Color.Red, 1), p6.X - 3, p6.Y, p6.X + 3, p6.Y);

                                g.DrawLine(new Pen(Color.Blue, 1), p5.X, p5.Y, p6.X, p6.Y);
                            }
                            else
                            {

                                if (intLeadPosition == 0 || intLeadPosition == 2) //For top and bottom ROI
                                {
                                    g.DrawLine(redPen, p1.X - 2, p1.Y + 2, p1.X + 2, p1.Y + 6);
                                    g.DrawLine(redPen, p1.X - 2, p1.Y + 6, p1.X + 2, p1.Y + 2);

                                    g.DrawLine(redPen, p2.X - 2, p2.Y + 2, p2.X + 2, p2.Y + 6);
                                    g.DrawLine(redPen, p2.X - 2, p2.Y + 6, p2.X + 2, p2.Y + 2);

                                    g.DrawLine(redPen, p3.X - 2, p3.Y - 2, p3.X + 2, p3.Y - 6);
                                    g.DrawLine(redPen, p3.X - 2, p3.Y - 6, p3.X + 2, p3.Y - 2);

                                    g.DrawLine(redPen, p4.X - 2, p4.Y - 2, p4.X + 2, p4.Y - 6);
                                    g.DrawLine(redPen, p4.X - 2, p4.Y - 6, p4.X + 2, p4.Y - 2);

                                    if (intLeadPosition == 0)
                                    {
                                        if (i == 0)
                                        {
                                            g.DrawLine(bluePen, p3.X - 2, p3.Y - 2, p3.X + 2, p3.Y + 2);
                                            g.DrawLine(bluePen, p3.X - 2, p3.Y + 2, p3.X + 2, p3.Y - 2);
                                        }
                                        if (i == m_arrTemplateBlobLeads.Count - 1)
                                        {
                                            g.DrawLine(bluePen, p4.X - 2, p4.Y - 2, p4.X + 2, p4.Y + 2);
                                            g.DrawLine(bluePen, p4.X - 2, p4.Y + 2, p4.X + 2, p4.Y - 2);
                                        }
                                    }
                                    else if (intLeadPosition == 2)
                                    {
                                        if (i == 0)
                                        {
                                            g.DrawLine(bluePen, p1.X - 2, p1.Y - 2, p1.X + 2, p1.Y + 2);
                                            g.DrawLine(bluePen, p1.X - 2, p1.Y + 2, p1.X + 2, p1.Y - 2);
                                        }

                                        if (i == m_arrTemplateBlobLeads.Count - 1)
                                        {
                                            g.DrawLine(bluePen, p2.X - 2, p2.Y - 2, p2.X + 2, p2.Y + 2);
                                            g.DrawLine(bluePen, p2.X - 2, p2.Y + 2, p2.X + 2, p2.Y - 2);
                                        }
                                    }
                                }
                                else //For left and right ROI
                                {
                                    g.DrawLine(redPen, p1.X + 2, p1.Y - 2, p1.X + 6, p1.Y + 2);
                                    g.DrawLine(redPen, p1.X + 6, p1.Y - 2, p1.X + 2, p1.Y + 2);

                                    g.DrawLine(redPen, p2.X - 2, p2.Y - 2, p2.X - 6, p2.Y + 2);
                                    g.DrawLine(redPen, p2.X - 6, p2.Y - 2, p2.X - 2, p2.Y + 2);

                                    g.DrawLine(redPen, p3.X + 2, p3.Y + 2, p3.X + 6, p3.Y - 2);
                                    g.DrawLine(redPen, p3.X + 6, p3.Y + 2, p3.X + 2, p3.Y - 2);

                                    g.DrawLine(redPen, p4.X - 2, p4.Y + 2, p4.X - 6, p4.Y - 2);
                                    g.DrawLine(redPen, p4.X - 6, p4.Y + 2, p4.X - 2, p4.Y - 2);

                                    if (intLeadPosition == 1)
                                    {
                                        if (i == 0)
                                        {
                                            g.DrawLine(bluePen, p1.X - 2, p1.Y - 2, p1.X + 2, p1.Y + 2);
                                            g.DrawLine(bluePen, p1.X - 2, p1.Y + 2, p1.X + 2, p1.Y - 2);
                                        }
                                        if (i == m_arrTemplateBlobLeads.Count - 1)
                                        {
                                            g.DrawLine(bluePen, p3.X - 2, p3.Y - 2, p3.X + 2, p3.Y + 2);
                                            g.DrawLine(bluePen, p3.X - 2, p3.Y + 2, p3.X + 2, p3.Y - 2);
                                        }
                                    }
                                    else if (intLeadPosition == 3)
                                    {
                                        if (i == 0)
                                        {
                                            g.DrawLine(bluePen, p2.X - 2, p2.Y - 2, p2.X + 2, p2.Y + 2);
                                            g.DrawLine(bluePen, p2.X - 2, p2.Y + 2, p2.X + 2, p2.Y - 2);
                                        }

                                        if (i == m_arrTemplateBlobLeads.Count - 1)
                                        {
                                            g.DrawLine(bluePen, p4.X - 2, p4.Y - 2, p4.X + 2, p4.Y + 2);
                                            g.DrawLine(bluePen, p4.X - 2, p4.Y + 2, p4.X + 2, p4.Y - 2);
                                        }
                                    }
                                }
                            }

                            switch (intLeadPosition)
                            {
                                case 1:
                                    g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                                            (m_arrSampleBlobLeads[i].fCenterX + intRoiOrgX) * fDrawingScaleX,
                                            (m_arrSampleBlobLeads[i].fCenterY + intRoiOrgY - 40) * fDrawingScaleY);
                                    break;
                                case 2:
                                    g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                                            (m_arrSampleBlobLeads[i].fCenterX + intRoiOrgX + 27) * fDrawingScaleX,
                                            (m_arrSampleBlobLeads[i].fCenterY + intRoiOrgY - 8) * fDrawingScaleY);
                                    break;
                                case 3:
                                    g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                                            (m_arrSampleBlobLeads[i].fCenterX + intRoiOrgX) * fDrawingScaleX,
                                            (m_arrSampleBlobLeads[i].fCenterY + intRoiOrgY + 27) * fDrawingScaleY);
                                    break;
                                case 4:
                                    g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                                            (m_arrSampleBlobLeads[i].fCenterX + intRoiOrgX - 40) * fDrawingScaleX,
                                            (m_arrSampleBlobLeads[i].fCenterY + intRoiOrgY - 8) * fDrawingScaleY);
                                    break;
                            }

                            //Draw reference point here
                            if (m_fSampleReferencePointEndX != 0 && m_fSampleReferencePointEndY != 0)
                            {
                                System.Drawing.PointF pRefPoint1 = new PointF();
                                System.Drawing.PointF pRefPoint2 = new PointF();
                                pRefPoint1 = new System.Drawing.PointF(intRoiOrgX + m_fSampleReferencePointStartX, intRoiOrgY + m_fSampleReferencePointStartY);
                                pRefPoint2 = new System.Drawing.PointF(intRoiOrgX + m_fSampleReferencePointEndX, intRoiOrgY + m_fSampleReferencePointEndY);

                                if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                                {
                                    pRefPoint1.X = pRefPoint1.X * fDrawingScaleX;
                                    pRefPoint1.Y = pRefPoint1.Y * fDrawingScaleY;
                                    pRefPoint2.X = pRefPoint2.X * fDrawingScaleX;
                                    pRefPoint2.Y = pRefPoint2.Y * fDrawingScaleY;
                                }

                                g.DrawLine(new Pen(Color.Lime, 1), pRefPoint1.X, pRefPoint1.Y - 3, pRefPoint1.X, pRefPoint1.Y + 3);
                                g.DrawLine(new Pen(Color.Lime, 1), pRefPoint1.X - 3, pRefPoint1.Y, pRefPoint1.X + 3, pRefPoint1.Y);

                                g.DrawLine(new Pen(Color.Lime, 1), pRefPoint2.X, pRefPoint2.Y - 3, pRefPoint2.X, pRefPoint2.Y + 3);
                                g.DrawLine(new Pen(Color.Lime, 1), pRefPoint2.X - 3, pRefPoint2.Y, pRefPoint2.X + 3, pRefPoint2.Y);

                                g.DrawLine(new Pen(Color.Lime, 1), pRefPoint1.X, pRefPoint1.Y, pRefPoint2.X, pRefPoint2.Y);
                            }
                        }
                        else
                        {
                            System.Drawing.PointF p1 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fStartX, intRoiOrgY + m_arrSampleBlobLeads[i].fStartY);
                            System.Drawing.PointF p2 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fEndX, intRoiOrgY + m_arrSampleBlobLeads[i].fStartY);
                            System.Drawing.PointF p3 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fStartX, intRoiOrgY + m_arrSampleBlobLeads[i].fEndY);
                            System.Drawing.PointF p4 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fEndX, intRoiOrgY + m_arrSampleBlobLeads[i].fEndY);

                            if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                            {
                                p1.X = p1.X * fDrawingScaleX;
                                p1.Y = p1.Y * fDrawingScaleY;
                                p2.X = p2.X * fDrawingScaleX;
                                p2.Y = p2.Y * fDrawingScaleY;
                                p3.X = p3.X * fDrawingScaleX;
                                p3.Y = p3.Y * fDrawingScaleY;
                                p4.X = p4.X * fDrawingScaleX;
                                p4.Y = p4.Y * fDrawingScaleY;
                            }

                            if (i == intLeadSelectingNumber)
                            {
                                g.DrawLine(limePen, p1, p2);
                                g.DrawLine(limePen, p2, p4);
                                g.DrawLine(limePen, p4, p3);
                                g.DrawLine(limePen, p3, p1);
                                g.DrawLine(limePen, p1, p4);
                            }
                            else
                            {
                                g.DrawLine(redPen, p1, p2);
                                g.DrawLine(redPen, p2, p4);
                                g.DrawLine(redPen, p4, p3);
                                g.DrawLine(redPen, p3, p1);
                                g.DrawLine(redPen, p1, p4);
                            }

                            if (m_blnLock)
                                return;

                            switch (intLeadPosition)
                            {
                                case 1:
                                    g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                                            (m_arrSampleBlobLeads[i].fCenterX + intRoiOrgX) * fDrawingScaleX,
                                            (m_arrSampleBlobLeads[i].fCenterY + intRoiOrgY - 40) * fDrawingScaleY);
                                    break;
                                case 2:
                                    g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                                            (m_arrSampleBlobLeads[i].fCenterX + intRoiOrgX + 27) * fDrawingScaleX,
                                            (m_arrSampleBlobLeads[i].fCenterY + intRoiOrgY - 8) * fDrawingScaleY);
                                    break;
                                case 3:
                                    g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                                            (m_arrSampleBlobLeads[i].fCenterX + intRoiOrgX) * fDrawingScaleX,
                                            (m_arrSampleBlobLeads[i].fCenterY + intRoiOrgY + 27) * fDrawingScaleY);
                                    break;
                                case 4:
                                    g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Yellow),
                                            (m_arrSampleBlobLeads[i].fCenterX + intRoiOrgX - 40) * fDrawingScaleX,
                                            (m_arrSampleBlobLeads[i].fCenterY + intRoiOrgY - 8) * fDrawingScaleY);
                                    break;
                            }

                        }
                    }
                }

                //for (int i = 0; i < m_arrLeadDefectList.Count; i++)
                //{
                //    if (m_blnLock)
                //        return;

                //    g.DrawRectangle(redPen, (m_arrLeadDefectList[i].ref_fCenterX - m_arrLeadDefectList[i].ref_fWidth / 2) * fDrawingScaleX,
                //                            (m_arrLeadDefectList[i].ref_fCenterY - m_arrLeadDefectList[i].ref_fHeight / 2) * fDrawingScaleY,
                //                            m_arrLeadDefectList[i].ref_fWidth * fDrawingScaleX, m_arrLeadDefectList[i].ref_fHeight * fDrawingScaleY);
                //}

                for (int i = 0; i < m_arrFailPitchGapList.Count; i++)
                {
                    if (m_blnLock)
                        return;

                    g.DrawLine(redPen, (float)(m_arrFailPitchGapList[i].intStartPointX - 5) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intStartPointY - 5) * fDrawingScaleY,
                                       (float)(m_arrFailPitchGapList[i].intStartPointX + 5) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intStartPointY + 5) * fDrawingScaleY);
                    g.DrawLine(redPen, (float)(m_arrFailPitchGapList[i].intStartPointX + 5) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intStartPointY - 5) * fDrawingScaleY,
                                       (float)(m_arrFailPitchGapList[i].intStartPointX - 5) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intStartPointY + 5) * fDrawingScaleY);
                    g.DrawLine(redPen, (float)(m_arrFailPitchGapList[i].intEndPointX - 5) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intEndPointY - 5) * fDrawingScaleY,
                                       (float)(m_arrFailPitchGapList[i].intEndPointX + 5) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intEndPointY + 5) * fDrawingScaleY);
                    g.DrawLine(redPen, (float)(m_arrFailPitchGapList[i].intEndPointX + 5) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intEndPointY - 5) * fDrawingScaleY,
                                       (float)(m_arrFailPitchGapList[i].intEndPointX - 5) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intEndPointY + 5) * fDrawingScaleY);
                    g.DrawLine(redPen, (float)(m_arrFailPitchGapList[i].intStartPointX) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intStartPointY) * fDrawingScaleY,
                                       (float)(m_arrFailPitchGapList[i].intEndPointX) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intEndPointY) * fDrawingScaleY);
                }
            }
        }

        /// <summary>
        /// Rearrange selected blobs 
        /// </summary>
        public void RearrangeBlobs()
        {
            int intBlobsFeatureCount = m_arrTemplateBlobLeads.Count;
            BlobsFeatures[] arrBlobsFeatures = new BlobsFeatures[intBlobsFeatureCount];
            int intNoID;

            // Copy selected blobs from global list (keep previous record) into temporary list
            for (int i = 0; i < intBlobsFeatureCount; i++)
            {
                if (!((BlobsFeatures)m_arrTemplateBlobLeads[i]).blnSelected)
                    continue;

                intNoID = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID - 1;
                if (intNoID >= 0 && intNoID < arrBlobsFeatures.Length)
                    arrBlobsFeatures[intNoID] = (BlobsFeatures)m_arrTemplateBlobLeads[i];
            }

            // delete global list 
            m_arrTemplateBlobLeads = new ArrayList();

            // Copy selected blobs from temporary list into global list.
            for (int i = 0; i < arrBlobsFeatures.Length; i++)
            {
                if (arrBlobsFeatures[i].blnSelected)
                {
                    m_stcBlobLead = (BlobsFeatures)arrBlobsFeatures[i];
                    m_arrTemplateBlobLeads.Add(m_stcBlobLead);
                }
            }
        }

        public void RearrangeBlobs(int intLeadCurrNo)
        {
            int intBlobsFeatureCount = m_arrTemplateBlobLeads.Count;
            BlobsFeatures[] arrBlobsFeatures = new BlobsFeatures[intBlobsFeatureCount];
            int intNoID;

            // Copy selected blobs from global list (keep previous record) into temporary list
            for (int i = 0; i < intBlobsFeatureCount; i++)
            {
                if (!((BlobsFeatures)m_arrTemplateBlobLeads[i]).blnSelected)
                    continue;

                intNoID = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID - (intLeadCurrNo - arrBlobsFeatures.Length);
                if (intNoID >= 0 && intNoID < arrBlobsFeatures.Length)
                    arrBlobsFeatures[intNoID] = (BlobsFeatures)m_arrTemplateBlobLeads[i];
            }

            // delete global list 
            m_arrTemplateBlobLeads = new ArrayList();

            // Copy selected blobs from temporary list into global list.
            for (int i = 0; i < arrBlobsFeatures.Length; i++)
            {
                if (arrBlobsFeatures[i].blnSelected)
                {
                    m_stcBlobLead = (BlobsFeatures)arrBlobsFeatures[i];
                    m_arrTemplateBlobLeads.Add(m_stcBlobLead);
                }
            }
        }

        /// <summary>
        /// Initialize sample data by init m_arrSampleBlobLeads and m_arrExtraBlobs
        /// </summary>
        public void ResetInspectionData()
        {
            lock (m_objLockBlobs)
            {
                m_blnPatternMatchSuccess = true;
                m_blnBuildSideLeadSuccess = true;
                m_blnViewLeadResultDrawing = false;
                m_blnFindLeadCenterPointsDone = false;
                m_pUnitCenterPoint.X = 0;
                m_pUnitCenterPoint.Y = 0;

                m_fPitchVarianceTopResult = -999;
                m_fPitchVarianceBottomResult = -999;
                m_fPitchVarianceLeftResult = -999;
                m_fPitchVarianceRightResult = -999;

                m_fLengthVarianceOverallResult = -999;
                m_fLengthVarianceTopResult = -999;
                m_fLengthVarianceBottomResult = -999;
                m_fLengthVarianceLeftResult = -999;
                m_fLengthVarianceRightResult = -999;

                m_fStandOffVarianceUnitResult = -999;
                m_fStandOffVarianceTopResult = -999;
                m_fStandOffVarianceBottomResult = -999;
                m_fStandOffVarianceLeftResult = -999;
                m_fStandOffVarianceRightResult = -999;

                m_fLeadSweepVarianceTopResult = -999;
                m_fLeadSweepVarianceBottomResult = -999;
                m_fLeadSweepVarianceLeftResult = -999;
                m_fLeadSweepVarianceRightResult = -999;

                m_fSpanOverallResult = -999;
                m_fSpanTopResult = -999;
                m_fSpanBottomResult = -999;
                m_fSpanLeftResult = -999;
                m_fSpanRightResult = -999;

                m_intFailPkgResultMask = 0;
                m_arrPkgDefectList = new List<Defect>();
                m_fResultBrightFieldTotalArea = -1;
                m_fResultDarkFieldTotalArea = -1;

                m_intExtraBlobID = 0;
                for (int i = 0; i < m_arrFailResultMask.Length; i++)
                    m_arrFailResultMask[i] = 0;

                m_arrSampleBlobLeads = new SampleBlobsFeatures[m_arrTemplateBlobLeads.Count];
                m_arrExtraBlobs = new List<SampleExtraBlobsFeatures>();
                //m_arrLeadDefectList = new List<Defect>();
                m_arrFailPitchGapList = new List<PitchGap>();
                m_intTemplateMatchStatus = new int[0];
                m_intSampleMatchNumber = new int[0];
                m_arrSampleMatchNumber.Clear();
                for (int i = 0; i < m_arrPitchGap.Count; i++)
                {
                    m_stcPitchGap = m_arrPitchGap[i];
                    m_stcPitchGap.intFailMask = 0;
                    //m_stcPitchGap.fPitch = 0.0f; //2021-05-31 ZJYEOH : Dont set to 0 because it will only used in learning, reset it to 0 will cause the tolerance get wrong setting after learn
                    m_stcPitchGap.fPitchMM = -999;
                    //m_stcPitchGap.fGap = 0.0f; //2021-05-31 ZJYEOH : Dont set to 0 because it will only used in learning, reset it to 0 will cause the tolerance get wrong setting after learn
                    m_stcPitchGap.fGapMM = -999;
                    m_arrPitchGap.RemoveAt(i);
                    m_arrPitchGap.Insert(i, m_stcPitchGap);
                }
                //m_arrPkgDefectList.Clear();

                m_blnViewPkgSizeDrawing = false;
            }
        }

        /// <summary>
        /// Assign all data from previous backup m_arrTemporaryBlobLeads to m_arrTemplateBlobLeads (current template)
        /// </summary>
        public void ReverseBlobs()
        {
            BlobsFeatures stcBlobLead;
            BlobsFeatures stcTemporaryBlobLead;
            m_arrTemplateBlobLeads = new ArrayList();
            for (int i = 0; i < m_arrTemporaryBlobLeads.Count; i++)
            {
                stcBlobLead = new BlobsFeatures();
                stcTemporaryBlobLead = (BlobsFeatures)m_arrTemporaryBlobLeads[i];

                stcBlobLead.fArea = stcTemporaryBlobLead.fArea;
                stcBlobLead.fCenterX = stcTemporaryBlobLead.fCenterX;
                stcBlobLead.fCenterY = stcTemporaryBlobLead.fCenterY;
                stcBlobLead.fLimitCenterX = stcTemporaryBlobLead.fLimitCenterX;
                stcBlobLead.fLimitCenterY = stcTemporaryBlobLead.fLimitCenterY;
                stcBlobLead.fWidth = stcTemporaryBlobLead.fWidth;
                stcBlobLead.fHeight = stcTemporaryBlobLead.fHeight;
                stcBlobLead.intLengthMode = stcTemporaryBlobLead.intLengthMode;
                stcBlobLead.intContourX = stcTemporaryBlobLead.intContourX;
                stcBlobLead.intContourY = stcTemporaryBlobLead.intContourY;
                stcBlobLead.arrContourX = stcTemporaryBlobLead.arrContourX;
                stcBlobLead.arrContourY = stcTemporaryBlobLead.arrContourY;
                stcBlobLead.intObjNo = stcTemporaryBlobLead.intObjNo;
                stcBlobLead.fStartX = stcTemporaryBlobLead.fStartX;
                stcBlobLead.fEndX = stcTemporaryBlobLead.fEndX;
                stcBlobLead.fStartY = stcTemporaryBlobLead.fStartY;
                stcBlobLead.fEndY = stcTemporaryBlobLead.fEndY;
                stcBlobLead.intStartX = stcTemporaryBlobLead.intStartX;
                stcBlobLead.intEndX = stcTemporaryBlobLead.intEndX;
                stcBlobLead.intStartY = stcTemporaryBlobLead.intStartY;
                stcBlobLead.intEndY = stcTemporaryBlobLead.intEndY;
                stcBlobLead.blnSelected = stcTemporaryBlobLead.blnSelected;
                stcBlobLead.blnCheckSkew = stcTemporaryBlobLead.blnCheckSkew;
                stcBlobLead.intDirection = stcTemporaryBlobLead.intDirection;
                stcBlobLead.intGroupID = stcTemporaryBlobLead.intGroupID;
                stcBlobLead.fPitch = stcTemporaryBlobLead.fPitch;
                stcBlobLead.fGap = stcTemporaryBlobLead.fGap;
                stcBlobLead.intNoID = stcTemporaryBlobLead.intNoID;
                stcBlobLead.intSelectedBlob = stcTemporaryBlobLead.intSelectedBlob;
                stcBlobLead.arrSelectedBlob = stcTemporaryBlobLead.arrSelectedBlob;
                m_arrTemplateBlobLeads.Add(stcBlobLead);
            }
        }

        /// <summary>
        /// Select template objects
        /// </summary>
        /// <param name="p1">rectangle start point</param>
        /// <param name="p2">rectangle stop point</param>
        /// <param name="intROIX">total offset X</param>
        /// <param name="intROIY">total offset Y</param>
        public void SelectTemplateObjects(System.Drawing.Point p1, System.Drawing.Point p2, int intROIX, int intROIY)
        {
            int intOrgX, intOrgY, intWidth, intHeight;

            if (p1.X < p2.X)
            {
                intOrgX = p1.X;
                intWidth = p2.X - p1.X;
            }
            else
            {
                intOrgX = p2.X;
                intWidth = p1.X - p2.X;
            }
            if (p1.Y < p2.Y)
            {
                intOrgY = p1.Y;
                intHeight = p2.Y - p1.Y;
            }
            else
            {
                intOrgY = p2.Y;
                intHeight = p1.Y - p2.Y;
            }

            intOrgX -= intROIX;
            intOrgY -= intROIY;

            // new method
            p1 = new System.Drawing.Point(p1.X - intROIX, p1.Y - intROIY);
            p2 = new System.Drawing.Point(p2.X - intROIX, p2.Y - intROIY);

            List<int> arrSelectedIndex = new List<int>();
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                //if ((m_stcBlobLead.fCenterX >= intOrgX) &&
                //    (m_stcBlobLead.fCenterX <= (intOrgX + intWidth)) &&
                //    (m_stcBlobLead.fCenterY >= intOrgY) &&
                //    (m_stcBlobLead.fCenterY <= (intOrgY + intHeight)))
                //{
                //    m_stcBlobLead.blnSelected = true;
                //}
                bool blnFound = false;
                for (int x = p1.X; x < p2.X; x++)
                {
                    for (int y = p1.Y; y < p2.Y; y++)
                    {
                        if ((x >= m_stcBlobLead.fStartX) &&
                               (x <= m_stcBlobLead.fEndX) &&
                               (y >= m_stcBlobLead.fStartY) &&
                               (y <= m_stcBlobLead.fEndY))
                        {
                            m_stcBlobLead.blnSelected = true;
                            blnFound = true;
                            break;
                        }
                    }

                    if (blnFound)
                        break;
                }

                if (blnFound)
                    arrSelectedIndex.Add(i);
                //m_arrTemplateBlobLeads.RemoveAt(i);
                //m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
            }

            for (int i = 0; i < arrSelectedIndex.Count; i++)
            {
                bool blnOverlap = false;
                bool blnSmall = false;
                for (int j = 0; j < arrSelectedIndex.Count; j++)
                {
                    if (i == j)
                        continue;

                    BlobsFeatures objBlob1 = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                    BlobsFeatures objBlob2 = (BlobsFeatures)m_arrTemplateBlobLeads[j];

                    // check is blob overlap with other blobs (using 4 corner points matching methodology)?
                    if ((((objBlob1.fStartX > objBlob2.fStartX) &&
                        (objBlob1.fStartX < objBlob2.fEndX) &&
                        (objBlob1.fStartY > objBlob2.fStartY) &&
                        (objBlob1.fStartY < objBlob2.fEndY)) ||
                        ((objBlob1.fStartX > objBlob2.fStartX) &&
                        (objBlob1.fStartX < objBlob2.fEndX) &&
                        (objBlob1.fEndY > objBlob2.fStartY) &&
                        (objBlob1.fEndY < objBlob2.fEndY)) ||
                        ((objBlob1.fEndX > objBlob2.fStartX) &&
                        (objBlob1.fEndX < objBlob2.fEndX) &&
                        (objBlob1.fStartY > objBlob2.fStartY) &&
                        (objBlob1.fStartY < objBlob2.fEndY)) ||
                        ((objBlob1.fEndX > objBlob2.fStartX) &&
                        (objBlob1.fEndX < objBlob2.fEndX) &&
                        (objBlob1.fEndY > objBlob2.fStartY) &&
                        (objBlob1.fEndY < objBlob2.fEndY))) ||

                        (((objBlob2.fStartX > objBlob1.fStartX) &&
                        (objBlob2.fStartX < objBlob1.fEndX) &&
                        (objBlob2.fStartY > objBlob1.fStartY) &&
                        (objBlob2.fStartY < objBlob1.fEndY)) ||
                        ((objBlob2.fStartX > objBlob1.fStartX) &&
                        (objBlob2.fStartX < objBlob1.fEndX) &&
                        (objBlob2.fEndY > objBlob1.fStartY) &&
                        (objBlob2.fEndY < objBlob1.fEndY)) ||
                        ((objBlob2.fEndX > objBlob1.fStartX) &&
                        (objBlob2.fEndX < objBlob1.fEndX) &&
                        (objBlob2.fStartY > objBlob1.fStartY) &&
                        (objBlob2.fStartY < objBlob1.fEndY)) ||
                        ((objBlob2.fEndX > objBlob1.fStartX) &&
                        (objBlob2.fEndX < objBlob1.fEndX) &&
                        (objBlob2.fEndY > objBlob1.fStartY) &&
                        (objBlob2.fEndY < objBlob1.fEndY))))

                    {
                        // check is blob1 size smaller than blob2
                        if (((objBlob1.fEndX - objBlob1.fStartX) * (objBlob1.fEndY - objBlob1.fStartY)) >
                            ((objBlob2.fEndX - objBlob2.fStartX) * (objBlob2.fEndY - objBlob2.fStartY)))
                        {
                            blnOverlap = true;  // no select
                            break;
                        }
                    }
                }

                if (!blnOverlap)
                {
                    m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[arrSelectedIndex[i]];
                    m_stcBlobLead.blnSelected = true;
                    m_arrTemplateBlobLeads.RemoveAt(arrSelectedIndex[i]);
                    m_arrTemplateBlobLeads.Insert(arrSelectedIndex[i], m_stcBlobLead);
                }
            }
        }

        /// <summary>
        /// Compare to find new selected blobs and replace new selected blobs data into m_arrTemplateBlobLeads
        /// </summary>
        public void CompareSelectedBlobs()
        {
            float fCenterX, fCenterY, fStartX, fStartY, fEndX, fEndY;
            bool blnSelect;

            for (int i = 0; i < m_arrTemporaryBlobLeads.Count; i++)
            {
                fCenterX = ((BlobsFeatures)m_arrTemporaryBlobLeads[i]).fLimitCenterX;
                fCenterY = ((BlobsFeatures)m_arrTemporaryBlobLeads[i]).fLimitCenterY;

                for (int j = 0; j < m_arrTemplateBlobLeads.Count; j++)
                {
                    fStartX = ((BlobsFeatures)m_arrTemplateBlobLeads[j]).fStartX;
                    fStartY = ((BlobsFeatures)m_arrTemplateBlobLeads[j]).fStartY;

                    fEndX = ((BlobsFeatures)m_arrTemplateBlobLeads[j]).fEndX;
                    fEndY = ((BlobsFeatures)m_arrTemplateBlobLeads[j]).fEndY;

                    blnSelect = ((BlobsFeatures)m_arrTemplateBlobLeads[j]).blnSelected;

                    if ((fCenterX >= fStartX && fCenterX <= fEndX) && (fCenterY >= fStartY && fCenterY <= fEndY) && blnSelect)
                    {
                        BlobsFeatures objBlobsFeatures = (BlobsFeatures)m_arrTemporaryBlobLeads[i];
                        objBlobsFeatures.blnSelected = true;
                        m_arrTemporaryBlobLeads.RemoveAt(i);
                        m_arrTemporaryBlobLeads.Insert(i, objBlobsFeatures);
                    }
                }
            }

            m_arrTemplateBlobLeads.Clear();

            for (int v = 0; v < m_arrTemporaryBlobLeads.Count; v++)
            {
                BlobsFeatures stcBlobsFeatures = new BlobsFeatures();

                stcBlobsFeatures.fArea = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).fArea;
                stcBlobsFeatures.fCenterX = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).fCenterX;
                stcBlobsFeatures.fCenterY = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).fCenterY;
                stcBlobsFeatures.fLimitCenterX = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).fLimitCenterX;
                stcBlobsFeatures.fLimitCenterY = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).fLimitCenterY;
                stcBlobsFeatures.fWidth = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).fWidth;
                stcBlobsFeatures.fHeight = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).fHeight;
                stcBlobsFeatures.intLengthMode = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).intLengthMode;
                stcBlobsFeatures.intContourX = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).intContourX;
                stcBlobsFeatures.intContourY = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).intContourY;
                stcBlobsFeatures.arrContourX = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).arrContourX;
                stcBlobsFeatures.arrContourY = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).arrContourY;
                stcBlobsFeatures.intObjNo = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).intObjNo;
                stcBlobsFeatures.fStartX = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).fStartX;
                stcBlobsFeatures.fEndX = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).fEndX;
                stcBlobsFeatures.fStartY = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).fStartY;
                stcBlobsFeatures.fEndY = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).fEndY;
                stcBlobsFeatures.intStartX = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).intStartX;
                stcBlobsFeatures.intEndX = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).intEndX;
                stcBlobsFeatures.intStartY = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).intStartY;
                stcBlobsFeatures.intEndY = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).intEndY;
                stcBlobsFeatures.blnSelected = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).blnSelected;
                stcBlobsFeatures.blnCheckSkew = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).blnCheckSkew;
                stcBlobsFeatures.intDirection = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).intDirection;
                stcBlobsFeatures.intGroupID = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).intGroupID;
                stcBlobsFeatures.fPitch = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).fPitch;
                stcBlobsFeatures.fGap = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).fGap;
                stcBlobsFeatures.intNoID = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).intNoID;
                stcBlobsFeatures.intSelectedBlob = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).intSelectedBlob;
                stcBlobsFeatures.arrSelectedBlob = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).arrSelectedBlob;
                m_arrTemplateBlobLeads.Add(stcBlobsFeatures);
            }
        }

        public void SetTemplateBlobsFeatures(int intNoID, int intGroupID, float fArea, int intLengthMode,
            int intContourX, int intContourY, int[] arrContourX, int[] arrContourY,
            int intStartX, int intStartY, int intEndX, int intEndY,
            float fStartX, float fStartY, float fEndX, float fEndY,
            int intDirection, int intSide,
            float fCenterX, float fCenterY, float fLimitCenterX, float fLimitCenterY,
            float fWidth, float fHeight,
            float fBaseWidth, float fBaseLength, float fBaseCenterX, float fBaseCenterY,
            float fTipWidth, float fTipLength, float fTipCenterX, float fTipCenterY,
            bool blnSelected, bool blnCheckSkew,
            float fSweepLeftReference, float fSweepRightReference, float fSweepTopReference, float fSweepBottomReference,
            float fLeftDistance, float fRightDistance, float fTopDistance, float fBottomDistance,
            float fXDistance, float fYDistance,
            float fPitch, float fGap, float fSkew, float fOffSet,
            float fMinBaseWidth, float fMaxBaseWidth, float fMinBaseLength, float fMaxBaseLength,
            float fMinTipWidth, float fMaxTipWidth, float fMinTipLength, float fMaxTipLength,
            float fMinPitch, float fMaxPitch, float fMinGap, float fMaxGap,
            float fMinStandOff, float fMaxStandOff,
            float fMinSolderPadLength, float fMaxSolderPadLength,
            float fMaxCoplan, float fMinAGV, float fMaxAGV, int intAGVROITolerance_Top, int intAGVROITolerance_Right, int intAGVROITolerance_Bottom, int intAGVROITolerance_Left,
            float fLimitMinWidth, float fLimitMaxWidth, float fMaxBurrWidth,
            float fWidthOffset, float fLengthOffset, float fPitchOffset, float fGapOffset, float fStandOffOffset, float fCoplanOffset)
        {
            m_stcBlobLead.intNoID = intNoID;
            m_stcBlobLead.intGroupID = intGroupID;
            m_stcBlobLead.fArea = fArea;
            m_stcBlobLead.intLengthMode = intLengthMode;
            m_stcBlobLead.intContourX = intContourX;
            m_stcBlobLead.intContourY = intContourY;
            m_stcBlobLead.arrContourX = arrContourX;
            m_stcBlobLead.arrContourY = arrContourY;
            m_stcBlobLead.intStartX = intStartX;
            m_stcBlobLead.intStartY = intStartY;
            m_stcBlobLead.intEndX = intEndX;
            m_stcBlobLead.intEndY = intEndY;
            m_stcBlobLead.fStartX = fStartX;
            m_stcBlobLead.fStartY = fStartY;
            m_stcBlobLead.fEndX = fEndX;
            m_stcBlobLead.fEndY = fEndY;
            m_stcBlobLead.intDirection = intDirection;
            m_stcBlobLead.intSide = intSide;
            m_stcBlobLead.fCenterX = fCenterX;
            m_stcBlobLead.fCenterY = fCenterY;
            m_stcBlobLead.fLimitCenterX = fLimitCenterX;
            m_stcBlobLead.fLimitCenterY = fLimitCenterY;
            m_stcBlobLead.fWidth = fWidth;
            m_stcBlobLead.fHeight = fHeight;
            m_stcBlobLead.fBaseWidth = fBaseWidth;
            m_stcBlobLead.fBaseLength = fBaseLength;
            m_stcBlobLead.fBaseCenterX = fBaseCenterX;
            m_stcBlobLead.fBaseCenterY = fBaseCenterY;
            m_stcBlobLead.fTipWidth = fTipWidth;
            m_stcBlobLead.fTipLength = fTipLength;
            m_stcBlobLead.fTipCenterX = fTipCenterX;
            m_stcBlobLead.fTipCenterY = fTipCenterY;
            m_stcBlobLead.blnSelected = blnSelected;
            m_stcBlobLead.blnCheckSkew = blnCheckSkew;
            m_stcBlobLead.fSweepLeftReference = fSweepLeftReference;
            m_stcBlobLead.fSweepRightReference = fSweepRightReference;
            m_stcBlobLead.fSweepTopReference = fSweepTopReference;
            m_stcBlobLead.fSweepBottomReference = fSweepBottomReference;
            m_stcBlobLead.fLeftDistance = fLeftDistance;
            m_stcBlobLead.fRightDistance = fRightDistance;
            m_stcBlobLead.fTopDistance = fTopDistance;
            m_stcBlobLead.fBottomDistance = fBottomDistance;
            m_stcBlobLead.fXDistance = fXDistance;
            m_stcBlobLead.fYDistance = fYDistance;
            m_stcBlobLead.fPitch = fPitch;
            m_stcBlobLead.fGap = fGap;

            m_stcBlobLead.fSkew = fSkew;
            m_stcBlobLead.fOffSet = fOffSet;

            m_stcBlobLead.fMinBaseWidth = fMinBaseWidth;
            m_stcBlobLead.fMaxBaseWidth = fMaxBaseWidth;
            m_stcBlobLead.fMinBaseLength = fMinBaseLength;
            m_stcBlobLead.fMaxBaseLength = fMaxBaseLength;
            m_stcBlobLead.fMinTipWidth = fMinTipWidth;
            m_stcBlobLead.fMaxTipWidth = fMaxTipWidth;
            m_stcBlobLead.fMinTipLength = fMinTipLength;
            m_stcBlobLead.fMaxTipLength = fMaxTipLength;

            m_stcBlobLead.fMinPitch = fMinPitch;
            m_stcBlobLead.fMaxPitch = fMaxPitch;
            m_stcBlobLead.fMinGap = fMinGap;
            m_stcBlobLead.fMaxGap = fMaxGap;

            m_stcBlobLead.fMinStandOff = fMinStandOff;
            m_stcBlobLead.fMaxStandOff = fMaxStandOff;

            m_stcBlobLead.fMinSolderPadLength = fMinSolderPadLength;
            m_stcBlobLead.fMaxSolderPadLength = fMaxSolderPadLength;

            m_stcBlobLead.fMaxCoplan = fMaxCoplan;

            m_stcBlobLead.fMinAGV = fMinAGV;
            m_stcBlobLead.fMaxAGV = fMaxAGV;

            m_stcBlobLead.intAGVROITolerance_Top = intAGVROITolerance_Top;
            m_stcBlobLead.intAGVROITolerance_Right = intAGVROITolerance_Right;
            m_stcBlobLead.intAGVROITolerance_Bottom = intAGVROITolerance_Bottom;
            m_stcBlobLead.intAGVROITolerance_Left = intAGVROITolerance_Left;

            m_stcBlobLead.fLeadLimitMinWidth = fLimitMinWidth;
            m_stcBlobLead.fLeadLimitMaxWidth = fLimitMaxWidth;
            m_stcBlobLead.fLeadMaxBurrWidth = fMaxBurrWidth;

            m_stcBlobLead.fWidthOffset = fWidthOffset;
            m_stcBlobLead.fLengthOffset = fLengthOffset;
            m_stcBlobLead.fPitchOffset = fPitchOffset;
            m_stcBlobLead.fGapOffset = fGapOffset;
            m_stcBlobLead.fStandOffOffset = fStandOffOffset;
            m_stcBlobLead.fCoplanOffset = fCoplanOffset;

            m_arrTemplateBlobLeads.Add(m_stcBlobLead);
        }
        public float Get2DXinMM(float fPixelValue)
        {
            if (fPixelValue <= m_f2DCenterPixelCountX1)
            {
                return m_obj2DCenterCalibrateLineX1.GetPointX(fPixelValue);
            }
            else if (fPixelValue >= m_f2DCenterPixelCountX1 && fPixelValue <= m_f2DCenterPixelCountX2)
            {
                return m_obj2DCenterCalibrateLineX2.GetPointX(fPixelValue);
            }
            else if (fPixelValue >= m_f2DCenterPixelCountX2 && fPixelValue <= m_f2DCenterPixelCountX3)
            {
                return m_obj2DCenterCalibrateLineX3.GetPointX(fPixelValue);
            }
            else if (fPixelValue >= m_f2DCenterPixelCountX3 && fPixelValue <= m_f2DCenterPixelCountX4)
            {
                return m_obj2DCenterCalibrateLineX4.GetPointX(fPixelValue);
            }
            else //if (fPixelValue >= m_f2DCenterPixelCountX4)// && fPixelValue <= m_f2DCenterPixelCountX5)
            {
                return m_obj2DCenterCalibrateLineX5.GetPointX(fPixelValue);
            }
        }
        public float Get2DXinPixel(float fMMValue)
        {
            if (fMMValue <= m_f2DCenterMMX1)
            {
                return m_obj2DCenterCalibrateLineX1.GetPointY(fMMValue);
            }
            else if (fMMValue >= m_f2DCenterMMX1 && fMMValue <= m_f2DCenterMMX2)
            {
                return m_obj2DCenterCalibrateLineX2.GetPointY(fMMValue);
            }
            else if (fMMValue >= m_f2DCenterMMX2 && fMMValue <= m_f2DCenterMMX3)
            {
                return m_obj2DCenterCalibrateLineX3.GetPointY(fMMValue);
            }
            else if (fMMValue >= m_f2DCenterMMX3 && fMMValue <= m_f2DCenterMMX4)
            {
                return m_obj2DCenterCalibrateLineX4.GetPointY(fMMValue);
            }
            else //if (fMMValue >= m_f2DCenterMMX4 && fMMValue <= m_f2DCenterMMX5)
            {
                return m_obj2DCenterCalibrateLineX5.GetPointY(fMMValue);
            }
        }
        public float Get2DYinMM(float fPixelValue)
        {
            if (fPixelValue <= m_f2DCenterPixelCountY1)
            {
                return m_obj2DCenterCalibrateLineY1.GetPointX(fPixelValue);
            }
            else if (fPixelValue >= m_f2DCenterPixelCountY1 && fPixelValue <= m_f2DCenterPixelCountY2)
            {
                return m_obj2DCenterCalibrateLineY2.GetPointX(fPixelValue);
            }
            else if (fPixelValue >= m_f2DCenterPixelCountY2 && fPixelValue <= m_f2DCenterPixelCountY3)
            {
                return m_obj2DCenterCalibrateLineY3.GetPointX(fPixelValue);
            }
            else if (fPixelValue >= m_f2DCenterPixelCountY3 && fPixelValue <= m_f2DCenterPixelCountY4)
            {
                return m_obj2DCenterCalibrateLineY4.GetPointX(fPixelValue);
            }
            else //if (fPixelValue >= m_f2DCenterPixelCountY4 && fPixelValue <= m_f2DCenterPixelCountY5)
            {
                return m_obj2DCenterCalibrateLineY5.GetPointX(fPixelValue);
            }
        }
        public float Get2DYinPixel(float fMMValue)
        {
            if (fMMValue <= m_f2DCenterMMY1)
            {
                return m_obj2DCenterCalibrateLineY1.GetPointY(fMMValue);
            }
            else if (fMMValue >= m_f2DCenterMMY1 && fMMValue <= m_f2DCenterMMY2)
            {
                return m_obj2DCenterCalibrateLineY2.GetPointY(fMMValue);
            }
            else if (fMMValue >= m_f2DCenterMMY2 && fMMValue <= m_f2DCenterMMY3)
            {
                return m_obj2DCenterCalibrateLineY3.GetPointY(fMMValue);
            }
            else if (fMMValue >= m_f2DCenterMMY3 && fMMValue <= m_f2DCenterMMY4)
            {
                return m_obj2DCenterCalibrateLineY4.GetPointY(fMMValue);
            }
            else //if (fMMValue >= m_f2DCenterMMY4 && fMMValue <= m_f2DCenterMMY5)
            {
                return m_obj2DCenterCalibrateLineY5.GetPointY(fMMValue);
            }
        }
        public float Get3DinMM(float fPixelValue)
        {
            if (fPixelValue <= m_f3DPixelCount1)
            {
                return m_obj3DCalibrateLine1.GetPointX(fPixelValue);
            }
            else //if (fPixelValue >= m_f3DPixelCount1 && fPixelValue <= m_f3DPixelCount2)
            {
                return m_obj3DCalibrateLine2.GetPointX(fPixelValue);
            }
        }
        public float Get3DinPixel(float fMMValue)
        {
            if (fMMValue <= m_f3DMM1)
            {
                return m_obj3DCalibrateLine1.GetPointY(fMMValue);
            }
            else //if (fMMValue >= m_f3DMM1 && fMMValue <= m_f3DMM2)
            {
                return m_obj3DCalibrateLine2.GetPointY(fMMValue);
            }
        }

        public void Set2DCalibrationDataToFormLine(PointF pCenterX1, PointF pCenterX2, PointF pCenterX3, PointF pCenterX4, PointF pCenterX5,
            PointF pCenterY1, PointF pCenterY2, PointF pCenterY3, PointF pCenterY4, PointF pCenterY5, int intUnitMode)
        {
            m_obj2DCenterCalibrateLineX1.CalculateStraightLine(new PointF(0, 0), pCenterX1);
            m_obj2DCenterCalibrateLineX2.CalculateStraightLine(pCenterX1, pCenterX2);
            m_obj2DCenterCalibrateLineX3.CalculateStraightLine(pCenterX2, pCenterX3);
            m_obj2DCenterCalibrateLineX4.CalculateStraightLine(pCenterX3, pCenterX4);
            m_obj2DCenterCalibrateLineX5.CalculateStraightLine(pCenterX4, pCenterX5);

            m_obj2DCenterCalibrateLineY1.CalculateStraightLine(new PointF(0, 0), pCenterY1);
            m_obj2DCenterCalibrateLineY2.CalculateStraightLine(pCenterY1, pCenterY2);
            m_obj2DCenterCalibrateLineY3.CalculateStraightLine(pCenterY2, pCenterY3);
            m_obj2DCenterCalibrateLineY4.CalculateStraightLine(pCenterY3, pCenterY4);
            m_obj2DCenterCalibrateLineY5.CalculateStraightLine(pCenterY4, pCenterY5);

            float fPixelPerMMX = (pCenterX3.Y / pCenterX3.X);
            float fPixelPerMMY = (pCenterY3.Y / pCenterY3.X);
            //m_fMMPerPixelX = 1 / fPixelPerMMX;
            //m_fMMPerPixelY = 1 / fPixelPerMMY;
            m_fAreaMMPerPixel = 1 / (fPixelPerMMX * fPixelPerMMY);

            //// MM to Pixel formula
            //m_fMMToPixelXValue = fPixelPerMMX;
            //m_fMMToPixelYValue = fPixelPerMMY;
            m_fMMtoPixelAreaValue = fPixelPerMMX * fPixelPerMMY;

            // MM to Micron or Mil formula
            switch (intUnitMode)
            {
                case 1: // mm
                    m_fMMToUnitValue = 1;
                    m_fMMToUnitValueArea = 1;
                    m_intDecimal = 4;
                    m_intDecimal2 = 6;
                    break;
                case 2: // mil
                    m_fMMToUnitValue = 1 / 0.0254f;
                    m_fMMToUnitValueArea = 1 / (0.0254f * 0.0254f);
                    m_intDecimal = 4;
                    m_intDecimal2 = 6;
                    break;
                case 3: // micron
                    m_fMMToUnitValue = 1000;
                    m_fMMToUnitValueArea = 1000000;
                    m_intDecimal = 2;
                    m_intDecimal2 = 2;
                    break;
            }
        }

        public void Set3DCalibrationDataToFormLine(PointF p1, PointF p2, int intUnitMode)
        {

            m_obj3DCalibrateLine1.CalculateStraightLine(new PointF(0, 0), p1);
            m_obj3DCalibrateLine2.CalculateStraightLine(p1, p2);

            float fPixelPerMMX = (p2.Y / p2.X);
            float fPixelPerMMY = (p2.Y / p2.X);

            //m_fMMPerPixelX = 1 / fPixelPerMMX;
            //m_fMMPerPixelY = 1 / fPixelPerMMY;
            m_fAreaMMPerPixel = 1 / (fPixelPerMMX * fPixelPerMMY);

            //// MM to Pixel formula
            //m_fMMToPixelXValue = fPixelPerMMX;
            //m_fMMToPixelYValue = fPixelPerMMY;
            m_fMMtoPixelAreaValue = fPixelPerMMX * fPixelPerMMY;

            // MM to Micron or Mil formula
            switch (intUnitMode)
            {
                case 1: // mm
                    m_fMMToUnitValue = 1;
                    m_fMMToUnitValueArea = 1;
                    m_intDecimal = 4;
                    m_intDecimal2 = 6;
                    break;
                case 2: // mil
                    m_fMMToUnitValue = 1 / 0.0254f;
                    m_fMMToUnitValueArea = 1 / (0.0254f * 0.0254f);
                    m_intDecimal = 4;
                    m_intDecimal2 = 6;
                    break;
                case 3: // micron
                    m_fMMToUnitValue = 1000;
                    m_fMMToUnitValueArea = 1000000;
                    m_intDecimal = 2;
                    m_intDecimal2 = 2;
                    break;
            }
        }
        public void SetCalibrationData(float fPixelPerMMX, float fPixelPerMMY,
            float fSizeOffSetX, float fSizeOffSetY, int intUnitMode)
        {
            //m_fMMPerPixelX = 1 / fPixelPerMMX;
            //m_fMMPerPixelY = 1 / fPixelPerMMY;
            //m_fAreaMMPerPixel = 1 / (fPixelPerMMX * fPixelPerMMY);

            //m_fSizeOffSetX = fSizeOffSetX;
            //m_fSizeOffSetY = fSizeOffSetY;

            //// MM to Pixel formula
            //m_fMMToPixelXValue = fPixelPerMMX;
            //m_fMMToPixelYValue = fPixelPerMMY;
            //m_fMMtoPixelAreaValue = fPixelPerMMX * fPixelPerMMY;

            // MM to Micron or Mil formula
            switch (intUnitMode)
            {
                case 1: // mm
                    m_fMMToUnitValue = 1;
                    m_fMMToUnitValueArea = 1;
                    m_intDecimal = 4;
                    m_intDecimal2 = 6;
                    break;
                case 2: // mil
                    m_fMMToUnitValue = 1 / 0.0254f;
                    m_fMMToUnitValueArea = 1 / (0.0254f * 0.0254f);
                    m_intDecimal = 4;
                    m_intDecimal2 = 6;
                    break;
                case 3: // micron
                    m_fMMToUnitValue = 1000;
                    m_fMMToUnitValueArea = 1000000;
                    m_intDecimal = 2;
                    m_intDecimal2 = 2;
                    break;
            }
        }

        /// <summary>
        /// Define pitch gap
        /// </summary>
        /// <param name="intPitchGapIndex">pitch gap index</param>
        /// <param name="intFromLeadNo">from Lead no</param>
        /// <param name="intToLeadNo">to Lead no</param>
        public void SetPitchGap(int intPitchGapIndex, int intFromLeadNo, int intToLeadNo)
        {
            int intFromNo, intToNo;
            if (intFromLeadNo < intToLeadNo)
            {
                intFromNo = intFromLeadNo;
                intToNo = intToLeadNo;
            }
            else
            {
                intFromNo = intToLeadNo;
                intToNo = intFromLeadNo;
            }

            if (DefinePitchGap(intPitchGapIndex, intFromNo, intToNo))
            {

                if ((intFromLeadNo > intToLeadNo) && !CheckPitchGapLinkInLeadAlready(intToLeadNo))
                {
                    m_stcPitchGap.intFromLeadNo = intToLeadNo;
                    m_stcPitchGap.intToLeadNo = intFromLeadNo;
                }
                else
                {
                    m_stcPitchGap.intFromLeadNo = intFromLeadNo;
                    m_stcPitchGap.intToLeadNo = intToLeadNo;
                }

                if (intPitchGapIndex < m_arrPitchGap.Count)
                {
                    m_arrPitchGap.RemoveAt(intPitchGapIndex);
                    m_arrPitchGap.Insert(intPitchGapIndex, m_stcPitchGap);
                }
                else
                {
                    m_arrPitchGap.Insert(intPitchGapIndex, m_stcPitchGap);
                }
            }

        }
        public void SetPitchGap(int intFromLeadNo, int intToLeadNo)
        {
            int intPitchGapIndex = -1;
            for (int i = 0; i < m_arrPitchGap.Count; i++)
            {
                if (intFromLeadNo == m_arrPitchGap[i].intFromLeadNo)
                    intPitchGapIndex = i;
            }

            if (intToLeadNo < 0) // Mean User set to NA 
            {
                if (intPitchGapIndex >= 0 && intPitchGapIndex < m_arrPitchGap.Count)
                    m_arrPitchGap.RemoveAt(intPitchGapIndex);
            }
            else
            {

                int intFromNo, intToNo;
                if (intFromLeadNo < intToLeadNo)
                {
                    intFromNo = intFromLeadNo;
                    intToNo = intToLeadNo;
                }
                else
                {
                    intFromNo = intToLeadNo;
                    intToNo = intFromLeadNo;
                }

                if (DefinePitchGap(m_arrPitchGap.Count, intFromNo, intToNo))//intPitchGapIndex
                {

                    if ((intFromLeadNo > intToLeadNo) && !CheckPitchGapLinkInLeadAlready(intToLeadNo))
                    {
                        m_stcPitchGap.intFromLeadNo = intToLeadNo;
                        m_stcPitchGap.intToLeadNo = intFromLeadNo;
                    }
                    else
                    {
                        m_stcPitchGap.intFromLeadNo = intFromLeadNo;
                        m_stcPitchGap.intToLeadNo = intToLeadNo;
                    }

                    //if (intPitchGapIndex < m_arrPitchGap.Count)
                    if (intPitchGapIndex < 0)
                    {
                        m_arrPitchGap.Insert(m_arrPitchGap.Count, m_stcPitchGap);
                    }
                    else
                    {
                        m_arrPitchGap.RemoveAt(intPitchGapIndex);
                        m_arrPitchGap.Insert(intPitchGapIndex, m_stcPitchGap);
                    }
                }
            }
        }
        /// <summary>
        /// Set min pitch, max pitch, min gap, max gap into certain pitch gap
        /// </summary>
        /// <param name="intPitchGapIndex">pitch gap index</param>
        /// <param name="fMinPitch">min pitch</param>
        /// <param name="fMaxPitch">max pitch</param>
        /// <param name="fMinGap">min gap</param>
        /// <param name="fMaxGap">max gap</param>
        public void SetPitchGapData(int intPitchGapIndex, int intFromLeadNo, int intToLeadNo, float fMinPitch, float fMaxPitch, float fMinGap, float fMaxGap)
        {
            // Get pitch gap array index. (Note: Pitch gap array not sequential with template array)
            int i;
            for (i = 0; i < m_arrPitchGap.Count; i++)
            {
                //if (m_arrPitchGap[intPitchGapIndex].intFromLeadNo == intPitchGapIndex)
                if (m_arrPitchGap[i].intFromLeadNo == intFromLeadNo &&
                    m_arrPitchGap[i].intToLeadNo == intToLeadNo)
                {
                    intPitchGapIndex = i;
                    break;
                }
            }

            // return if index not found
            if (i == m_arrPitchGap.Count)
                return;

            // Update pitch gap with latest information
            m_stcPitchGap = m_arrPitchGap[intPitchGapIndex];
            m_stcPitchGap.fMinPitch = fMinPitch / m_fMMToUnitValue;
            m_stcPitchGap.fMaxPitch = fMaxPitch / m_fMMToUnitValue;
            m_stcPitchGap.fMinGap = fMinGap / m_fMMToUnitValue;
            m_stcPitchGap.fMaxGap = fMaxGap / m_fMMToUnitValue;
            m_arrPitchGap.RemoveAt(i);
            m_arrPitchGap.Insert(i, m_stcPitchGap);

        }

        /// <summary>
        /// Set min pitch, max pitch, min gap, max gap into certain pitch gap
        /// </summary>
        /// <param name="intPitchGapIndex">pitch gap index</param>
        /// <param name="fMinPitch">min pitch</param>
        /// <param name="fMaxPitch">max pitch</param>
        /// <param name="fMinGap">min gap</param>
        /// <param name="fMaxGap">max gap</param>
        public void SetPitchGapDataFrom(int intPitchGapIndex, float fMinPitch, float fMaxPitch, float fMinGap, float fMaxGap)
        {
            if (!GetLeadArrayIndexFromNoID(intPitchGapIndex, ref intPitchGapIndex))
                return;

            for (int i = 0; i < m_arrPitchGap.Count; i++)
            {
                if (intPitchGapIndex == m_arrPitchGap[i].intFromLeadNo)
                {
                    m_stcPitchGap = m_arrPitchGap[i];
                    m_stcPitchGap.fMinPitch = fMinPitch / m_fMMToUnitValue;
                    m_stcPitchGap.fMaxPitch = fMaxPitch / m_fMMToUnitValue;
                    m_stcPitchGap.fMinGap = fMinGap / m_fMMToUnitValue;
                    m_stcPitchGap.fMaxGap = fMaxGap / m_fMMToUnitValue;

                    m_arrPitchGap.RemoveAt(i);
                    m_arrPitchGap.Insert(i, m_stcPitchGap);

                }
            }
        }

        public void SaveLead3D(string strPath, bool blnNewFile, string strSectionName, bool blnNewSection)
        {
            XmlParser objFile = new XmlParser(strPath, blnNewFile);

            objFile.WriteSectionElement(strSectionName, blnNewSection);

            ////objFile.WriteElement1Value("OrientSetting", true);
            ////objFile.WriteElement2Value("MatchMinScore", m_smVisionInfo.g_arrLeadOrient[i].ref_fMinScore);

            // Save LeadSetting
            objFile.WriteElement1Value("LeadSetting", "");
            objFile.WriteElement2Value("GaugeSizeImageIndex", m_intGaugeSizeImageIndex);
            objFile.WriteElement2Value("CheckLeadDimensionImageIndex", m_intCheckLeadDimensionImageIndex);
            objFile.WriteElement2Value("ThresholdValue", m_intThresholdValue);
            objFile.WriteElement2Value("LeadDirection", m_intLeadDirection);
            objFile.WriteElement2Value("NumberOfLead", m_intNumberOfLead);
            objFile.WriteElement2Value("NumberOfLead_Top", m_intNumberOfLead_Top);
            objFile.WriteElement2Value("NumberOfLead_Bottom", m_intNumberOfLead_Bottom);
            objFile.WriteElement2Value("NumberOfLead_Left", m_intNumberOfLead_Left);
            objFile.WriteElement2Value("NumberOfLead_Right", m_intNumberOfLead_Right);
            objFile.WriteElement2Value("LeadSelected", m_blnSelected);
            objFile.WriteElement2Value("MinArea", m_intFilterMinArea);
            objFile.WriteElement2Value("FailMask", m_intFailOptionMask);
            objFile.WriteElement2Value("LeadStartX", m_fLeadRangeStartX);
            objFile.WriteElement2Value("LeadStartY", m_fLeadRangeStartY);
            objFile.WriteElement2Value("LeadEndX", m_fLeadRangeEndX);
            objFile.WriteElement2Value("LeadEndY", m_fLeadRangeEndY);
            objFile.WriteElement2Value("ReferencePointStartX", m_fReferencePointStartX);
            objFile.WriteElement2Value("ReferencePointStartY", m_fReferencePointStartY);
            objFile.WriteElement2Value("ReferencePointEndX", m_fReferencePointEndX);
            objFile.WriteElement2Value("ReferencePointEndY", m_fReferencePointEndX);
            objFile.WriteElement2Value("BaseOffset", m_intBaseOffset);
            objFile.WriteElement2Value("TipOffset", m_intTipOffset);
            objFile.WriteElement2Value("ClockWise", m_blnClockWise);
            objFile.WriteElement2Value("Lead1", m_intFirstLead);
            objFile.WriteElement2Value("BaseLineTrimFromEdge", m_intBaseLineTrimFromEdge);
            objFile.WriteElement2Value("BaseLineSteps", m_intBaseLineSteps);
            objFile.WriteElement2Value("WhiteOnBlack", m_blnWhiteOnBlack);
            objFile.WriteElement2Value("TemplateMatcher_CenterX", m_fTemplateMatcher_CenterX);
            objFile.WriteElement2Value("TemplateMatcher_CenterY", m_fTemplateMatcher_CenterY);
            objFile.WriteElement2Value("TemplateCornerPoint_CenterX", m_fTemplateCornerPoint_CenterX);
            objFile.WriteElement2Value("TemplateCornerPoint_CenterY", m_fTemplateCornerPoint_CenterY);
            objFile.WriteElement2Value("AngleTolerance", m_fAngleTolerance);
            objFile.WriteElement2Value("XTolerance", m_fXTolerance);
            objFile.WriteElement2Value("YTolerance", m_fYTolerance);
            objFile.WriteElement2Value("WantUsePkgToBaseTolerance", m_blnWantUsePkgToBaseTolerance);
            objFile.WriteElement2Value("WantUseGaugeMeasureBase", m_blnWantUseGaugeMeasureBase);
            objFile.WriteElement2Value("ImageRotateOption", m_intImageRotateOption);
            objFile.WriteElement2Value("WantUseAGVMasking", m_blnWantUseAGVMasking);
            objFile.WriteElement2Value("WantUseAverageGrayValueMethod", m_blnWantUseAverageGrayValueMethod);
            objFile.WriteElement2Value("LeadWidthDisplayOption", m_intLeadWidthDisplayOption);
            objFile.WriteElement2Value("LeadLengthVarianceMethod", m_intLeadLengthVarianceMethod);
            objFile.WriteElement2Value("LeadSpanMethod", m_intLeadSpanMethod);
            objFile.WriteElement2Value("LeadContaminationRegion", m_intLeadContaminationRegion);
            objFile.WriteElement2Value("LeadStandOffMethod", m_intLeadStandOffMethod);
            objFile.WriteElement2Value("LeadWidthRangeSelection", m_intLeadWidthRangeSelection);
            objFile.WriteElement2Value("LeadWidthRange", m_intLeadWidthRange);
            objFile.WriteElement2Value("MatchingXTolerance", m_intMatchingXTolerance); 
            objFile.WriteElement2Value("MatchingYTolerance", m_intMatchingYTolerance); 
            objFile.WriteElement2Value("MeasureCenterPkgSizeUsingCorner", m_blnMeasureCenterPkgSizeUsingCorner);

            objFile.WriteElement2Value("PkgToBaseTolerance_Top", m_intPkgToBaseTolerance_Top);
            objFile.WriteElement2Value("PkgToBaseTolerance_Right", m_intPkgToBaseTolerance_Right);
            objFile.WriteElement2Value("PkgToBaseTolerance_Bottom", m_intPkgToBaseTolerance_Bottom);
            objFile.WriteElement2Value("PkgToBaseTolerance_Left", m_intPkgToBaseTolerance_Left);

            objFile.WriteElement2Value("TipBuildAreaTolerance_Top", m_intTipBuildAreaTolerance_Top);
            objFile.WriteElement2Value("TipBuildAreaTolerance_Right", m_intTipBuildAreaTolerance_Right);
            objFile.WriteElement2Value("TipBuildAreaTolerance_Bottom", m_intTipBuildAreaTolerance_Bottom);
            objFile.WriteElement2Value("TipBuildAreaTolerance_Left", m_intTipBuildAreaTolerance_Left);

            objFile.WriteElement2Value("CornerSearchingTolerance_Top1", m_arrCornerSearchingTolerance_Top[0]);
            objFile.WriteElement2Value("CornerSearchingTolerance_Top2", m_arrCornerSearchingTolerance_Top[1]);
            objFile.WriteElement2Value("CornerSearchingTolerance_Right1", m_arrCornerSearchingTolerance_Right[0]);
            objFile.WriteElement2Value("CornerSearchingTolerance_Right2", m_arrCornerSearchingTolerance_Right[1]);
            objFile.WriteElement2Value("CornerSearchingTolerance_Bottom1", m_arrCornerSearchingTolerance_Bottom[0]);
            objFile.WriteElement2Value("CornerSearchingTolerance_Bottom2", m_arrCornerSearchingTolerance_Bottom[1]);
            objFile.WriteElement2Value("CornerSearchingTolerance_Left1", m_arrCornerSearchingTolerance_Left[0]);
            objFile.WriteElement2Value("CornerSearchingTolerance_Left2", m_arrCornerSearchingTolerance_Left[1]);
            objFile.WriteElement2Value("CornerSearchingLength1", m_arrCornerSearchingLength[0]);
            objFile.WriteElement2Value("CornerSearchingLength2", m_arrCornerSearchingLength[1]);

            objFile.WriteElement2Value("PitchVarianceLeftMaxSetting", m_fPitchVarianceLeftMaxSetting);
            objFile.WriteElement2Value("PitchVarianceRightMaxSetting", m_fPitchVarianceRightMaxSetting);
            objFile.WriteElement2Value("PitchVarianceTopMaxSetting", m_fPitchVarianceTopMaxSetting);
            objFile.WriteElement2Value("PitchVarianceBottomMaxSetting", m_fPitchVarianceBottomMaxSetting);
            objFile.WriteElement2Value("StandOffVarianceUnitMaxSetting", m_fStandOffVarianceUnitMaxSetting);
            objFile.WriteElement2Value("LeadSweepVarianceLeftMinSetting", m_fLeadSweepVarianceLeftMinSetting);
            objFile.WriteElement2Value("LeadSweepVarianceRightMinSetting", m_fLeadSweepVarianceRightMinSetting);
            objFile.WriteElement2Value("LeadSweepVarianceTopMinSetting", m_fLeadSweepVarianceTopMinSetting);
            objFile.WriteElement2Value("LeadSweepVarianceBottomMinSetting", m_fLeadSweepVarianceBottomMinSetting);
            objFile.WriteElement2Value("LeadSweepVarianceLeftMaxSetting", m_fLeadSweepVarianceLeftMaxSetting);
            objFile.WriteElement2Value("LeadSweepVarianceRightMaxSetting", m_fLeadSweepVarianceRightMaxSetting);
            objFile.WriteElement2Value("LeadSweepVarianceTopMaxSetting", m_fLeadSweepVarianceTopMaxSetting);
            objFile.WriteElement2Value("LeadSweepVarianceBottomMaxSetting", m_fLeadSweepVarianceBottomMaxSetting);
            objFile.WriteElement2Value("LengthVarianceOverallMaxSetting", m_fLengthVarianceOverallMaxSetting);
            objFile.WriteElement2Value("LengthVarianceLeftMaxSetting", m_fLengthVarianceLeftMaxSetting);
            objFile.WriteElement2Value("LengthVarianceRightMaxSetting", m_fLengthVarianceRightMaxSetting);
            objFile.WriteElement2Value("LengthVarianceTopMaxSetting", m_fLengthVarianceTopMaxSetting);
            objFile.WriteElement2Value("LengthVarianceBottomMaxSetting", m_fLengthVarianceBottomMaxSetting);
            objFile.WriteElement2Value("StandOffVarianceLeftMaxSetting", m_fStandOffVarianceLeftMaxSetting);
            objFile.WriteElement2Value("StandOffVarianceRightMaxSetting", m_fStandOffVarianceRightMaxSetting);
            objFile.WriteElement2Value("StandOffVarianceTopMaxSetting", m_fStandOffVarianceTopMaxSetting);
            objFile.WriteElement2Value("StandOffVarianceBottomMaxSetting", m_fStandOffVarianceBottomMaxSetting);
            objFile.WriteElement2Value("StandOffVarianceUnitMaxSetting", m_fStandOffVarianceUnitMaxSetting);
            objFile.WriteElement2Value("SpanOverallMinSetting", m_fSpanOverallMinSetting);
            objFile.WriteElement2Value("SpanOverallMaxSetting", m_fSpanOverallMaxSetting);
            objFile.WriteElement2Value("SpanTopMinSetting", m_fSpanTopMinSetting);
            objFile.WriteElement2Value("SpanTopMaxSetting", m_fSpanTopMaxSetting);
            objFile.WriteElement2Value("SpanBottomMinSetting", m_fSpanBottomMinSetting);
            objFile.WriteElement2Value("SpanBottomMaxSetting", m_fSpanBottomMaxSetting);
            objFile.WriteElement2Value("SpanLeftMinSetting", m_fSpanLeftMinSetting);
            objFile.WriteElement2Value("SpanLeftMaxSetting", m_fSpanLeftMaxSetting);
            objFile.WriteElement2Value("SpanRightMinSetting", m_fSpanRightMinSetting);
            objFile.WriteElement2Value("SpanRightMaxSetting", m_fSpanRightMaxSetting);
            objFile.WriteElement2Value("ExtraLeadSetArea", m_fExtraLeadSetArea);
            objFile.WriteElement2Value("TotalExtraLeadSetArea", m_fTotalExtraLeadSetArea);
            objFile.WriteElement2Value("BaseLineMaxAngle", m_fBaseLineMaxAngle);
            objFile.WriteElement2Value("ExtraLeadSetLength", m_fExtraLeadSetLength);
            objFile.WriteElement2Value("WantCheckExtraLeadLength", m_blnWantCheckExtraLeadLength);
            objFile.WriteElement2Value("WantCheckExtraLeadArea", m_blnWantCheckExtraLeadArea);

            // Save BlobsFeatures
            string strBlobsFeatures = GetBlobsFeaturesAllData();
            string[] strFeature = strBlobsFeatures.Split('#');
            int intBlobsCount = GetBlobsFeaturesNumber();
            int intFeatureIndex = 0;
            int intContourLength = 0;
            objFile.WriteElement2Value("BlobsFeaturesCount", intBlobsCount);
            for (int v = 0; v < intBlobsCount; v++)
            {
                objFile.WriteElement1Value("BlobsFeatures" + v, "");
                objFile.WriteElement2Value("NoID", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("GroupNo", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("Area", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("LengthMode", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("ContourX", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("ContourY", strFeature[intFeatureIndex++]);

                intContourLength = Convert.ToInt32(strFeature[intFeatureIndex]);
                objFile.WriteElement2Value("ContourLength", strFeature[intFeatureIndex++]);

                for (int j = 0; j < intContourLength; j++)
                {
                    objFile.WriteElement2Value("ContourX" + j.ToString(), strFeature[intFeatureIndex++]);
                    objFile.WriteElement2Value("ContourY" + j.ToString(), strFeature[intFeatureIndex++]);
                }

                objFile.WriteElement2Value("StartX", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("StartY", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("EndX", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("EndY", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("fStartX", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("fStartY", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("fEndX", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("fEndY", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("Direction", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("LeadSide", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("GravityCenterX", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("GravityCenterY", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("LimitCenterX", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("LimitCenterY", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("Width", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("Height", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("BaseWidth", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("BaseLength", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("BaseCenterX", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("BaseCenterY", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("TipWidth", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("TipHeight", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("TipCenterX", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("TipCenterY", strFeature[intFeatureIndex++]);
                if (strFeature[intFeatureIndex++] == "True")
                    objFile.WriteElement2Value("Selected", true);
                else
                    objFile.WriteElement2Value("Selected", false);
                objFile.WriteElement2Value("SweepLeftReference", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("SweepRightReference", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("SweepTopReference", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("SweepBottomReference", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("LeftDistance", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("RightDistance", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("TopDistance", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("BottomDistance", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("XDistance", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("YDistance", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("Pitch", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("Gap", strFeature[intFeatureIndex++]);

                objFile.WriteElement2Value("Skew", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("OffSet", strFeature[intFeatureIndex++]);

                objFile.WriteElement2Value("MinBaseWidth", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("MaxBaseWidth", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("MinBaseLength", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("MaxBaseLength", strFeature[intFeatureIndex++]);

                objFile.WriteElement2Value("MinTipWidth", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("MaxTipWidth", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("MinTipHeight", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("MaxTipHeight", strFeature[intFeatureIndex++]);

                objFile.WriteElement2Value("MinPitch", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("MaxPitch", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("MinGap", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("MaxGap", strFeature[intFeatureIndex++]);

                objFile.WriteElement2Value("MinStandOff", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("MaxStandOff", strFeature[intFeatureIndex++]);

                objFile.WriteElement2Value("MinSolderPadLength", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("MaxSolderPadLength", strFeature[intFeatureIndex++]);

                objFile.WriteElement2Value("MaxCoplan", strFeature[intFeatureIndex++]);

                objFile.WriteElement2Value("MinAGV", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("MaxAGV", strFeature[intFeatureIndex++]);

                objFile.WriteElement2Value("AGVROITolerance_Top", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("AGVROITolerance_Right", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("AGVROITolerance_Bottom", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("AGVROITolerance_Left", strFeature[intFeatureIndex++]);

                objFile.WriteElement2Value("LimitMinWidth", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("LimitMaxWidth", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("LimitBurrWidth", strFeature[intFeatureIndex++]);

                objFile.WriteElement2Value("WidthOffset", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("LengthOffset", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("PitchOffset", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("GapOffset", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("StandOffOffset", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("CoplanOffset", strFeature[intFeatureIndex++]);
            }

            int intIndex = 0;
            string strPitchGapData;
            string[] strPitchGapDataRow;
            int intTotalPitchGap = GetTotalPitchGap();
            objFile.WriteElement2Value("PitchGapCount", intTotalPitchGap);
            for (int q = 0; q < intTotalPitchGap; q++)
            {
                intIndex = 0;
                strPitchGapData = GetMicronPitchGapData(q);
                strPitchGapDataRow = strPitchGapData.Split('#');

                objFile.WriteElement1Value("PitchGap" + q, "");
                objFile.WriteElement2Value("FromLeadNo", strPitchGapDataRow[intIndex++]);
                objFile.WriteElement2Value("ToLeadNo", strPitchGapDataRow[intIndex++]);
                objFile.WriteElement2Value("MinPitch", strPitchGapDataRow[intIndex++]);
                objFile.WriteElement2Value("MaxPitch", strPitchGapDataRow[intIndex++]);
                objFile.WriteElement2Value("MinGap", strPitchGapDataRow[intIndex++]);
                objFile.WriteElement2Value("MaxGap", strPitchGapDataRow[intIndex++]);
                objFile.WriteElement2Value("Pitch", strPitchGapDataRow[intIndex++]);
                objFile.WriteElement2Value("Gap", strPitchGapDataRow[intIndex++]);
                objFile.WriteElement2Value("StartX", strPitchGapDataRow[intIndex++]);
                objFile.WriteElement2Value("StartY", strPitchGapDataRow[intIndex++]);
                objFile.WriteElement2Value("EndX", strPitchGapDataRow[intIndex++]);
                objFile.WriteElement2Value("EndY", strPitchGapDataRow[intIndex++]);
                objFile.WriteElement2Value("Direction", strPitchGapDataRow[intIndex++]);
            }

            // Save Package Setting
            objFile.WriteElement1Value("PackageSetting", "");
            objFile.WriteElement2Value("FailPkgMask", m_intFailPkgOptionMask);
            objFile.WriteElement2Value("WantInspectPackage", m_blnInspectPackage);
            objFile.WriteElement2Value("ChipStartPixelFromEdge", m_fChipStartPixelFromEdge);
            objFile.WriteElement2Value("ChipStartPixelFromRight", m_fChipStartPixelFromRight);
            objFile.WriteElement2Value("ChipStartPixelFromBottom", m_fChipStartPixelFromBottom);
            objFile.WriteElement2Value("ChipStartPixelFromLeft", m_fChipStartPixelFromLeft);
            objFile.WriteElement2Value("MoldStartPixelFromEdge", m_fMoldStartPixelFromEdge);
            objFile.WriteElement2Value("MoldStartPixelFromRight", m_fMoldStartPixelFromRight);
            objFile.WriteElement2Value("MoldStartPixelFromBottom", m_fMoldStartPixelFromBottom);
            objFile.WriteElement2Value("MoldStartPixelFromLeft", m_fMoldStartPixelFromLeft);
            objFile.WriteElement2Value("PkgStartPixelFromEdge", m_fPkgStartPixelFromEdge);
            objFile.WriteElement2Value("PkgStartPixelFromRight", m_fPkgStartPixelFromRight);
            objFile.WriteElement2Value("PkgStartPixelFromBottom", m_fPkgStartPixelFromBottom);
            objFile.WriteElement2Value("PkgStartPixelFromLeft", m_fPkgStartPixelFromLeft);
            objFile.WriteElement2Value("PkgImage1HighPadThreshold", m_intPkgImage1HighPadThreshold);
            objFile.WriteElement2Value("PkgImage1LowPadThreshold", m_intPkgImage1LowPadThreshold);
            objFile.WriteElement2Value("PkgImage1HighSurfaceThreshold", m_intPkgImage1HighSurfaceThreshold);
            objFile.WriteElement2Value("PkgImage1LowSurfaceThreshold", m_intPkgImage1LowSurfaceThreshold);
            objFile.WriteElement2Value("PkgImage1Gain", m_fPkgImage1Gain);
            objFile.WriteElement2Value("PkgImage2HighPadThreshold", m_intPkgImage2HighThreshold);
            objFile.WriteElement2Value("PkgImage2LowPadThreshold", m_intPkgImage2LowThreshold);
            objFile.WriteElement2Value("PkgImage3HighPadThreshold", m_intPkgImage3HighThreshold);
            objFile.WriteElement2Value("PkgImage3LowPadThreshold", m_intPkgImage3LowThreshold);
            objFile.WriteElement2Value("PkgImage1MoldFlashThreshold", m_intPkgImage1MoldFlashThreshold);
            objFile.WriteElement2Value("PkgImage2VoidThreshold", m_intPkgImage2VoidThreshold);
            objFile.WriteElement2Value("PkgImage2HighCrackThreshold", m_intPkgImage2HighCrackThreshold);
            objFile.WriteElement2Value("PkgImage2LowCrackThreshold", m_intPkgImage2LowCrackThreshold);
            objFile.WriteElement2Value("PkgImage1ChippedThreshold", m_intPkgImage1ChippedThreshold);
            objFile.WriteElement2Value("BrightFieldLowThreshold", m_intBrightFieldLowThreshold);
            objFile.WriteElement2Value("BrightFieldHighThreshold", m_intBrightFieldHighThreshold);
            objFile.WriteElement2Value("DarkFieldLowThreshold", m_intDarkFieldLowThreshold);
            objFile.WriteElement2Value("DarkFieldImageGain", m_fDarkFieldImageGain);
            objFile.WriteElement2Value("DarkFieldHighThreshold", m_intDarkFieldHighThreshold);

            //PackageSize Offset
            //objFile.WriteElement2Value("PackageWidthOffsetMM", m_fPackageWidthOffsetMM);
            //objFile.WriteElement2Value("PackageHeightOffsetMM", m_fPackageHeightOffsetMM);
            //objFile.WriteElement2Value("PackageThicknessOffsetMM", m_fPackageThicknessOffsetMM);

            objFile.WriteElement2Value("UnitWidth", m_fUnitWidth);
            objFile.WriteElement2Value("UnitHeight", m_fUnitHeight);
            objFile.WriteElement2Value("UnitThickness", m_fUnitThickness);
            objFile.WriteElement2Value("UnitWidthMin", m_fUnitWidthMin);
            objFile.WriteElement2Value("UnitWidthMax", m_fUnitWidthMax);
            objFile.WriteElement2Value("UnitHeightMin", m_fUnitHeightMin);
            objFile.WriteElement2Value("UnitHeightMax", m_fUnitHeightMax);
            objFile.WriteElement2Value("UnitThicknessMin", m_fUnitThicknessMin);
            objFile.WriteElement2Value("UnitThicknessMax", m_fUnitThicknessMax);

            objFile.WriteElement2Value("UnitSizeLength", m_fUnitSizeLength);
            objFile.WriteElement2Value("CrackLength", m_fCrackLength);
            objFile.WriteElement2Value("ScratchLength", m_fScratchLength);
            objFile.WriteElement2Value("ScratchArea", m_fScratchArea);
            objFile.WriteElement2Value("ChipArea", m_fChipArea);
            objFile.WriteElement2Value("ContaminationLength", m_fContaminationLength);
            objFile.WriteElement2Value("SolderMeltLength", m_fSolderMeltLength);
            objFile.WriteElement2Value("VoidLength", m_fVoidLength);
            objFile.WriteElement2Value("VoidArea", m_fVoidArea);
            objFile.WriteElement2Value("CrackLength", m_fCrackLength);
            objFile.WriteElement2Value("CrackArea", m_fCrackArea);
            objFile.WriteElement2Value("MoldFlashArea", m_fMoldFlashArea);
            objFile.WriteElement2Value("InCompletePlateLength", m_fInCompletePlateLength);
            objFile.WriteElement2Value("LeadBrokenLength", m_fLeadBrokenLength);

            objFile.WriteElement2Value("BrightLength", m_fBrightLength);
            objFile.WriteElement2Value("BrightWidth", m_fBrightWidth);
            objFile.WriteElement2Value("BrightArea", m_fBrightArea);
            objFile.WriteElement2Value("BrightTotalArea", m_fBrightTotalArea);
            objFile.WriteElement2Value("DarkLength", m_fDarkLength);
            objFile.WriteElement2Value("DarkWidth", m_fDarkWidth);
            objFile.WriteElement2Value("DarkArea", m_fDarkArea);
            objFile.WriteElement2Value("DarkTotalArea", m_fDarkTotalArea);
            objFile.WriteElement2Value("BrightChippedOffArea", m_fBrightChippedOffArea);
            objFile.WriteElement2Value("DarkChippedOffArea", m_fDarkChippedOffArea);
            objFile.WriteElement2Value("DarkVerticalCrack", m_fDarkVerticalCrack);
            objFile.WriteElement2Value("DarkHorizontalCrack", m_fDarkHorizontalCrack);

            //objFile.WriteElement2Value("UnitWidth", m_fUnitWidth);
            //objFile.WriteElement2Value("UnitHeight", m_fUnitHeight);
            //objFile.WriteElement2Value("UnitThickness", m_fUnitThickness);
            //objFile.WriteElement2Value("UnitWidthMin", m_fUnitWidthMin);
            //objFile.WriteElement2Value("UnitWidthMax", m_fUnitWidthMax);
            //objFile.WriteElement2Value("UnitHeightMin", m_fUnitHeightMin);
            //objFile.WriteElement2Value("UnitHeightMax", m_fUnitHeightMax);
            //objFile.WriteElement2Value("UnitThicknessMin", m_fUnitThicknessMin);
            //objFile.WriteElement2Value("UnitThicknessMax", m_fUnitThicknessMax);

            //objFile.WriteElement2Value("UnitSizeLength", m_fUnitSizeLength);
            //objFile.WriteElement2Value("CrackLength", m_fCrackLength);
            //objFile.WriteElement2Value("ScratchLength", m_fScratchLength);
            //objFile.WriteElement2Value("ContaminationLength", m_fContaminationLength);
            //objFile.WriteElement2Value("SolderMeltLength", m_fSolderMeltLength);
            //objFile.WriteElement2Value("VoidLength", m_fVoidLength);
            //objFile.WriteElement2Value("MoldFlashLength", m_fMoldFlashLength);
            //objFile.WriteElement2Value("InCompletePlateLength", m_fInCompletePlateLength);
            //objFile.WriteElement2Value("LeadBrokenLength", m_fLeadBrokenLength);

            objFile.WriteElement2Value("MPTolerance", m_intMPTolerance);

            // Grab image index
            objFile.WriteElement2Value("GrabImageIndexCount", m_arrGrabImageIndex.Count);
            for (int j = 0; j < m_arrGrabImageIndex.Count; j++)
                objFile.WriteElement2Value("GrabImageIndex" + j.ToString(), m_arrGrabImageIndex[j]);

            objFile.WriteEndElement();
        }

        public void SaveLead3D_SECSGEM(string strPath, string strSectionName, string strVisionName, bool blnSECSGEMFileExist, int intSECSGEMMaxNoOfCoplanPad)
        {
            //XmlParser objFile = new XmlParser(strPath, blnNewFile);

            //objFile.WriteSectionElement(strSectionName, blnNewSection);

            ////objFile.WriteElement1Value("OrientSetting", true);
            ////objFile.WriteElement2Value("MatchMinScore", m_smVisionInfo.g_arrLeadOrient[i].ref_fMinScore);

            XmlParser objFile = new XmlParser(strPath, "SECSGEMData");
            objFile.WriteRootElement("SECSGEMData");

            // Save LeadSetting
            //objFile.WriteElementValue("LeadSetting", "");
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_ThresholdValue", m_intThresholdValue);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_LeadDirection", m_intLeadDirection);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_NumberOfLead", m_intNumberOfLead);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_NumberOfLead_Top", m_intNumberOfLead_Top);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_NumberOfLead_Bottom", m_intNumberOfLead_Bottom);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_NumberOfLead_Left", m_intNumberOfLead_Left);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_NumberOfLead_Right", m_intNumberOfLead_Right);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_LeadSelected", m_blnSelected);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_MinArea", m_intFilterMinArea);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_FailMask", m_intFailOptionMask);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_LeadStartX", m_fLeadRangeStartX);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_LeadStartY", m_fLeadRangeStartY);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_LeadEndX", m_fLeadRangeEndX);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_LeadEndY", m_fLeadRangeEndY);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_ReferencePointStartX", m_fReferencePointStartX);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_ReferencePointStartY", m_fReferencePointStartY);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_ReferencePointEndX", m_fReferencePointEndX);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_ReferencePointEndY", m_fReferencePointEndX);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_BaseOffset", m_intBaseOffset);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_TipOffset", m_intTipOffset);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_ClockWise", m_blnClockWise);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_Lead1", m_intFirstLead);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_BaseLineTrimFromEdge", m_intBaseLineTrimFromEdge);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_BaseLineSteps", m_intBaseLineSteps);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_WhiteOnBlack", m_blnWhiteOnBlack);

            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_CornerSearchingTolerance_Top1", m_arrCornerSearchingTolerance_Top[0]);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_CornerSearchingTolerance_Top2", m_arrCornerSearchingTolerance_Top[1]);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_CornerSearchingTolerance_Right1", m_arrCornerSearchingTolerance_Right[0]);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_CornerSearchingTolerance_Right2", m_arrCornerSearchingTolerance_Right[1]);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_CornerSearchingTolerance_Bottom1", m_arrCornerSearchingTolerance_Bottom[0]);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_CornerSearchingTolerance_Bottom2", m_arrCornerSearchingTolerance_Bottom[1]);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_CornerSearchingTolerance_Left1", m_arrCornerSearchingTolerance_Left[0]);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_CornerSearchingTolerance_Left2", m_arrCornerSearchingTolerance_Left[1]);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_CornerSearchingLength1", m_arrCornerSearchingLength[0]);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_CornerSearchingLength2", m_arrCornerSearchingLength[1]);

            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_PitchVarianceLeftMaxSetting", m_fPitchVarianceLeftMaxSetting);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_PitchVarianceRightMaxSetting", m_fPitchVarianceRightMaxSetting);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_PitchVarianceTopMaxSetting", m_fPitchVarianceTopMaxSetting);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_PitchVarianceBottomMaxSetting", m_fPitchVarianceBottomMaxSetting);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_StandOffVarianceUnitMaxSetting", m_fStandOffVarianceUnitMaxSetting);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_LeadSweepVarianceLeftMinSetting", m_fLeadSweepVarianceLeftMinSetting);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_LeadSweepVarianceRightMinSetting", m_fLeadSweepVarianceRightMinSetting);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_LeadSweepVarianceTopMinSetting", m_fLeadSweepVarianceTopMinSetting);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_LeadSweepVarianceBottomMinSetting", m_fLeadSweepVarianceBottomMinSetting);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_LeadSweepVarianceLeftMaxSetting", m_fLeadSweepVarianceLeftMaxSetting);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_LeadSweepVarianceRightMaxSetting", m_fLeadSweepVarianceRightMaxSetting);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_LeadSweepVarianceTopMaxSetting", m_fLeadSweepVarianceTopMaxSetting);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_LeadSweepVarianceBottomMaxSetting", m_fLeadSweepVarianceBottomMaxSetting);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_LengthVarianceOverallMaxSetting", m_fLengthVarianceOverallMaxSetting);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_LengthVarianceLeftMaxSetting", m_fLengthVarianceLeftMaxSetting);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_LengthVarianceRightMaxSetting", m_fLengthVarianceRightMaxSetting);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_LengthVarianceTopMaxSetting", m_fLengthVarianceTopMaxSetting);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_LengthVarianceBottomMaxSetting", m_fLengthVarianceBottomMaxSetting);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_StandOffVarianceLeftMaxSetting", m_fStandOffVarianceLeftMaxSetting);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_StandOffVarianceRightMaxSetting", m_fStandOffVarianceRightMaxSetting);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_StandOffVarianceTopMaxSetting", m_fStandOffVarianceTopMaxSetting);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_StandOffVarianceBottomMaxSetting", m_fStandOffVarianceBottomMaxSetting);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_StandOffVarianceUnitMaxSetting", m_fStandOffVarianceUnitMaxSetting);

            // Save BlobsFeatures
            string strBlobsFeatures = GetBlobsFeaturesAllData();
            string[] strFeature = strBlobsFeatures.Split('#');
            int intBlobsCount = GetBlobsFeaturesNumber();
            int intFeatureIndex = 0;
            int intContourLength = 0;
            objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeaturesCount", intBlobsCount);
            for (int v = 0; v < intSECSGEMMaxNoOfCoplanPad; v++)
            {
                if (intBlobsCount > v)
                {
                    //objFile.WriteElementValue("BlobsFeatures" + v, "");
                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_NoID", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_GroupNo", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_Area", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_LengthMode", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_ContourX", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_ContourY", strFeature[intFeatureIndex++]);

                    //intContourLength = Convert.ToInt32(strFeature[intFeatureIndex]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_ContourLength", strFeature[intFeatureIndex++]);

                    //for (int j = 0; j < 10; j++)
                    //{
                    //    if (intContourLength > j)
                    //    {
                    //        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_ContourX" + j.ToString(), strFeature[intFeatureIndex++]);
                    //        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_ContourY" + j.ToString(), strFeature[intFeatureIndex++]);
                    //    }
                    //    else
                    //    {
                    //        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_ContourX" + j.ToString(), "NA");
                    //        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_ContourY" + j.ToString(), "NA");
                    //    }
                    //}

                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_StartX", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_StartY", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_EndX", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_EndY", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_fStartX", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_fStartY", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_fEndX", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_fEndY", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_Direction", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_LeadSide", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_GravityCenterX", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_GravityCenterY", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_LimitCenterX", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_LimitCenterY", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_Width", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_Height", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_BaseWidth", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_BaseLength", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_BaseCenterX", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_BaseCenterY", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_TipWidth", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_TipHeight", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_TipCenterX", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_TipCenterY", strFeature[intFeatureIndex++]);
                    if (strFeature[intFeatureIndex++] == "True")
                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_Selected", true);
                    else
                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_Selected", false);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_LeftDistance", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_RightDistance", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_TopDistance", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_BottomDistance", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_XDistance", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_YDistance", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_Pitch", strFeature[intFeatureIndex++]);

                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_OffSet", strFeature[intFeatureIndex++]);

                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinBaseWidth", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxBaseWidth", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinBaseLength", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxBaseLength", strFeature[intFeatureIndex++]);

                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinTipWidth", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxTipWidth", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinTipHeight", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxTipHeight", strFeature[intFeatureIndex++]);

                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinPitch", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxPitch", strFeature[intFeatureIndex++]);

                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinStandOff", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxStandOff", strFeature[intFeatureIndex++]);

                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinSolderPadLength", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxSolderPadLength", strFeature[intFeatureIndex++]);

                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxCoplan", strFeature[intFeatureIndex++]);

                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinAGV", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxAGV", strFeature[intFeatureIndex++]);

                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_AGVROITolerance_Top", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_AGVROITolerance_Right", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_AGVROITolerance_Bottom", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_AGVROITolerance_Left", strFeature[intFeatureIndex++]);

                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_LimitMinWidth", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_LimitMaxWidth", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_LimitBurrWidth", strFeature[intFeatureIndex++]);

                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_WidthOffset", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_LengthOffset", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PitchOffset", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_GapOffset", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_StandOffOffset", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_CoplanOffset", strFeature[intFeatureIndex++]);

                }
                else
                {
                    if (!blnSECSGEMFileExist)
                    {
                        //objFile.WriteElementValue("BlobsFeatures" + v, "");
                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_NoID", "NA");
                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_GroupNo", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_Area", "NA");
                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_LengthMode", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_ContourX", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_ContourY", "NA");

                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_ContourLength", "NA");

                        //for (int j = 0; j < 10; j++)
                        //{
                        //    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_ContourX" + j.ToString(), "NA");
                        //    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_ContourY" + j.ToString(), "NA");
                        //}

                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_StartX", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_StartY", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_EndX", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_EndY", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_fStartX", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_fStartY", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_fEndX", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_fEndY", "NA");
                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_Direction", "NA");
                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_LeadSide", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_GravityCenterX", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_GravityCenterY", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_LimitCenterX", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_LimitCenterY", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_Width", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_Height", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_BaseWidth", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_BaseLength", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_BaseCenterX", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_BaseCenterY", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_TipWidth", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_TipHeight", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_TipCenterX", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_TipCenterY", "NA");

                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_Selected", "NA");

                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_LeftDistance", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_RightDistance", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_TopDistance", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_BottomDistance", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_XDistance", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_YDistance", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_Pitch", "NA");

                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_OffSet", "NA");

                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinBaseWidth", "NA");
                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxBaseWidth", "NA");
                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinBaseLength", "NA");
                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxBaseLength", "NA");

                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinTipWidth", "NA");
                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxTipWidth", "NA");
                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinTipHeight", "NA");
                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxTipHeight", "NA");

                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinPitch", "NA");
                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxPitch", "NA");

                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinStandOff", "NA");
                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxStandOff", "NA");

                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinSolderPadLength", "NA");
                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxSolderPadLength", "NA");

                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxCoplan", "NA");

                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinAGV", "NA");
                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxAGV", "NA");

                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_AGVROITolerance_Top", "NA");
                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_AGVROITolerance_Right", "NA");
                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_AGVROITolerance_Bottom", "NA");
                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_AGVROITolerance_Left", "NA");

                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_LimitMinWidth", "NA");
                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_LimitMaxWidth", "NA");
                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_LimitBurrWidth", "NA");

                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_WidthOffset", "NA");
                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_LengthOffset", "NA");
                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PitchOffset", "NA");
                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_GapOffset", "NA");
                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_StandOffOffset", "NA");
                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_CoplanOffset", "NA");

                    }
                }
            }

            //int intIndex = 0;
            //string strPitchGapData;
            //string[] strPitchGapDataRow;
            int intTotalPitchGap = GetTotalPitchGap();
            objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_PitchGapCount", intTotalPitchGap);
            //for (int q = 0; q < 10; q++)
            //{
            //    if (intTotalPitchGap > q)
            //    {
            //        intIndex = 0;
            //        strPitchGapData = GetMicronPitchGapData(q);
            //        strPitchGapDataRow = strPitchGapData.Split('#');

            //        //objFile.WriteElementValue("PitchGap" + q, "");
            //        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_PitchGap" + q + "_FromLeadNo", strPitchGapDataRow[intIndex++]);
            //        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_PitchGap" + q + "_ToLeadNo", strPitchGapDataRow[intIndex++]);
            //        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_PitchGap" + q + "_MinPitch", strPitchGapDataRow[intIndex++]);
            //        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_PitchGap" + q + "_MaxPitch", strPitchGapDataRow[intIndex++]);
            //        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_PitchGap" + q + "_MinGap", strPitchGapDataRow[intIndex++]);
            //        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_PitchGap" + q + "_MaxGap", strPitchGapDataRow[intIndex++]);
            //        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_PitchGap" + q + "_Gap", strPitchGapDataRow[intIndex++]);
            //        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_PitchGap" + q + "_Pitch", strPitchGapDataRow[intIndex++]);
            //        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_PitchGap" + q + "_StartX", strPitchGapDataRow[intIndex++]);
            //        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_PitchGap" + q + "_StartY", strPitchGapDataRow[intIndex++]);
            //        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_PitchGap" + q + "_EndX", strPitchGapDataRow[intIndex++]);
            //        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_PitchGap" + q + "_EndY", strPitchGapDataRow[intIndex++]);
            //        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_PitchGap" + q + "_Direction", strPitchGapDataRow[intIndex++]);
            //    }
            //    else
            //    {
            //        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_PitchGap" + q + "_FromLeadNo", "NA");
            //        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_PitchGap" + q + "_ToLeadNo", "NA");
            //        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_PitchGap" + q + "_MinPitch", "NA");
            //        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_PitchGap" + q + "_MaxPitch", "NA");
            //        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_PitchGap" + q + "_Pitch", "NA");
            //        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_PitchGap" + q + "_StartX", "NA");
            //        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_PitchGap" + q + "_StartY", "NA");
            //        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_PitchGap" + q + "_EndX", "NA");
            //        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_PitchGap" + q + "_EndY", "NA");
            //        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_PitchGap" + q + "_Direction", "NA");
            //    }
            //}

            objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_UnitWidth", m_fUnitWidth);
            objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_UnitHeight", m_fUnitHeight);
            objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_UnitThickness", m_fUnitThickness);
            objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_UnitWidthMin", m_fUnitWidthMin);
            objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_UnitWidthMax", m_fUnitWidthMax);
            objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_UnitHeightMin", m_fUnitHeightMin);
            objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_UnitHeightMax", m_fUnitHeightMax);
            objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_UnitThicknessMin", m_fUnitThicknessMin);
            objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_UnitThicknessMax", m_fUnitThicknessMax);

            objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_UnitSizeLength", m_fUnitSizeLength);
            objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_CrackLength", m_fCrackLength);
            objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_ScratchLength", m_fScratchLength);
            objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_ContaminationLength", m_fContaminationLength);
            objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_SolderMeltLength", m_fSolderMeltLength);
            objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_VoidLength", m_fVoidLength);
            objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_MoldFlashLength", m_fMoldFlashLength);
            objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_InCompletePlateLength", m_fInCompletePlateLength);
            objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_LeadBrokenLength", m_fLeadBrokenLength);


            objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_MPTolerance", m_intMPTolerance);

            objFile.WriteEndElement();
        }

        public void SaveLeadTemplateImage(string strFolderPath, ImageDrawing objLearnRotatedImage, List<ROI> arrLeadROIs, int intLeadIndex)
        {
            // Save Template Search ROI Image
            //arrLeadROIs[0].SaveImage(strFolderPath + "SearchROITemplate" + intLeadIndex + ".bmp");
            //arrLeadROIs[2].SaveImage(strFolderPath + "PackageROITemplate" + intLeadIndex + ".bmp");

            // ---------------------- Save Image for package inspection used ----------------------------------------------------------------------------------------------------

            //// Copy learn image to a temporary image memory so that the temporary image can be modified without bother the
            //ImageDrawing objImage = new ImageDrawing();
            //objLearnRotatedImage.CopyTo(ref objImage);
            //ROI objTempROI = new ROI();
            //objTempROI.LoadROISetting(
            //arrLeadROIs[0].ref_ROITotalX,
            //arrLeadROIs[0].ref_ROITotalY,
            //arrLeadROIs[0].ref_ROIWidth,
            //arrLeadROIs[0].ref_ROIHeight);
            //objTempROI.AttachImage(objImage);

            ////Save Dilate Image
            //ImageDrawing.DilateImage(arrLeadROIs[0], ref objTempROI, 2);
            //for (int q = 1; q < arrLeadROIs.Count; q++)
            //{
            //    ROI objDunCare = new ROI();
            //    objDunCare.LoadROISetting(arrLeadROIs[q].ref_ROIPositionX, arrLeadROIs[q].ref_ROIPositionY,
            //                              arrLeadROIs[q].ref_ROIWidth, arrLeadROIs[q].ref_ROIHeight);
            //    objDunCare.AttachImage(objTempROI);
            //    objDunCare.FillROI(255);

            //    objDunCare.Dispose();
            //}

            //SaveLeadIndividualImage(strFolderPath, objLearnRotatedImage, arrLeadROIs, intLeadIndex);

            ROI objUnitROI = new ROI();

            objUnitROI.LoadROISetting(
            arrLeadROIs[0].ref_ROITotalX,
            arrLeadROIs[0].ref_ROITotalY,
            arrLeadROIs[0].ref_ROIWidth,
            arrLeadROIs[0].ref_ROIHeight);

            //objUnitROI.LoadROISetting((int)Math.Round(arrLeadROIs[0].ref_ROITotalX + m_fLeadRangeStartX, 0, MidpointRounding.AwayFromZero), (int)Math.Round(arrLeadROIs[0].ref_ROITotalY + m_fLeadRangeStartY, 0, MidpointRounding.AwayFromZero),
            //            (int)Math.Round(m_fLeadRangeEndX - m_fLeadRangeStartX, 0, MidpointRounding.AwayFromZero), (int)Math.Round(m_fLeadRangeEndY - m_fLeadRangeStartY, 0, MidpointRounding.AwayFromZero));
            objUnitROI.AttachImage(objLearnRotatedImage);

            objUnitROI.SaveImage(strFolderPath + "UnitTemplate" + intLeadIndex + ".bmp");
            SaveUnitPattern(objUnitROI, strFolderPath, intLeadIndex, "UnitMatcher");

            objUnitROI.Dispose();
            //objTempROI.Dispose();
            //objImage.Dispose();
        }

        public void SavePattern(string strFolderPath, ImageDrawing objLearnRotatedImage, List<ROI> arrLeadROIs, int intLeadIndex)
        {
            int intMinX = int.MaxValue, intMinY = int.MaxValue, intMaxX = int.MinValue, intMaxY = int.MinValue;

            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                if (m_intLeadDirection == 0)
                {
                    if (intMinX > (int)m_stcBlobLead.fTipCenterX)
                        intMinX = (int)m_stcBlobLead.fTipCenterX - 10;

                    if (intMinY > (int)(m_stcBlobLead.fTipCenterY - m_stcBlobLead.fTipWidth / 2))
                        intMinY = (int)(m_stcBlobLead.fTipCenterY - m_stcBlobLead.fTipWidth / 2) - 10;

                    if (intMaxX < (int)m_stcBlobLead.fTipCenterX)
                        intMaxX = (int)m_stcBlobLead.fTipCenterX + 10;

                    if (intMaxY < (int)(m_stcBlobLead.fTipCenterY + m_stcBlobLead.fTipWidth / 2))
                        intMaxY = (int)(m_stcBlobLead.fTipCenterY + m_stcBlobLead.fTipWidth / 2) + 10;
                }
                else
                {
                    if (intMinX > (int)(m_stcBlobLead.fTipCenterX - m_stcBlobLead.fTipWidth / 2))
                        intMinX = (int)(m_stcBlobLead.fTipCenterX - m_stcBlobLead.fTipWidth / 2) - 10;

                    if (intMinY > (int)(m_stcBlobLead.fTipCenterY))
                        intMinY = (int)(m_stcBlobLead.fTipCenterY) - 10;

                    if (intMaxX < (int)(m_stcBlobLead.fTipCenterX + m_stcBlobLead.fTipWidth / 2))
                        intMaxX = (int)(m_stcBlobLead.fTipCenterX + m_stcBlobLead.fTipWidth / 2) + 10;

                    if (intMaxY < (int)(m_stcBlobLead.fTipCenterY))
                        intMaxY = (int)(m_stcBlobLead.fTipCenterY) + 10;
                }
            }


            ROI objUnitROI = new ROI();

            objUnitROI.LoadROISetting(
            arrLeadROIs[0].ref_ROITotalX + intMinX,
            arrLeadROIs[0].ref_ROITotalY + intMinY,
            intMaxX - intMinX,
            intMaxY - intMinY);

            //objUnitROI.LoadROISetting((int)Math.Round(arrLeadROIs[0].ref_ROITotalX + m_fLeadRangeStartX, 0, MidpointRounding.AwayFromZero), (int)Math.Round(arrLeadROIs[0].ref_ROITotalY + m_fLeadRangeStartY, 0, MidpointRounding.AwayFromZero),
            //            (int)Math.Round(m_fLeadRangeEndX - m_fLeadRangeStartX, 0, MidpointRounding.AwayFromZero), (int)Math.Round(m_fLeadRangeEndY - m_fLeadRangeStartY, 0, MidpointRounding.AwayFromZero));
            objUnitROI.AttachImage(objLearnRotatedImage);

            objUnitROI.SaveImage(strFolderPath + "PatternTemplate" + intLeadIndex + ".bmp");
            SaveUnitPattern(objUnitROI, strFolderPath, intLeadIndex, "PatternMatcher");

            objUnitROI.Dispose();
        }

        public void SaveUnitPattern(ROI objUnitROI, string strFolderPath, int intLeadIndex, string PatternName)
        {

            if (objUnitROI.ref_ROIWidth == 0 || objUnitROI.ref_ROIHeight == 0)
                return;

            try
            {
#if (Debug_2_12 || Release_2_12)
                m_objMatcher.AdvancedLearning = false; // 2020-09-23 ZJYEOH : If set to true when MIN MAX angle both are same sign(++/--) then will have error
#endif
                m_objMatcher.DontCareThreshold = 1;
                m_objMatcher.LearnPattern(objUnitROI.ref_ROI);
                //m_objFinder.Learn(objUnitROI.ref_ROI);
            }
            catch (Exception ex)
            {

            }

            m_objMatcher.Save(strFolderPath + PatternName + intLeadIndex.ToString() + ".mch");
            //m_objFinder.Save(strFolderPath + "UnitFinder" + intLeadIndex.ToString() + ".fnd");
        }

        private bool IsPixelInBlobContourArea(int intBlobIndex, int intPixelX, int intPixelY)
        {
            if (intBlobIndex >= m_arrTemplateContour.Length)
                return false;

            bool blnAboveX1 = false, blnBelowX2 = false, blnAboveY1 = false, blnBelowY2 = false;
            for (int j = 0; j < m_arrTemplateContour[intBlobIndex].ref_pvContourList.Count; j++)
            {
                EBW8PathVector pv = m_arrTemplateContour[intBlobIndex].ref_pvContourList[j];
                int intNumElements = (int)pv.NumElements;

                for (int i = 0; i < intNumElements; i++)
                {
                    if (intPixelX == pv.GetElement(i).X)
                    {
                        if (intPixelY >= pv.GetElement(i).Y)
                            blnAboveY1 = true;

                        if (intPixelY <= pv.GetElement(i).Y)
                            blnBelowY2 = true;
                    }

                    if (intPixelY == pv.GetElement(i).Y)
                    {
                        if (intPixelX >= pv.GetElement(i).X)
                            blnAboveX1 = true;

                        if (intPixelX <= pv.GetElement(i).X)
                            blnBelowX2 = true;
                    }
                }

                if (blnAboveX1 && blnBelowX2 && blnAboveY1 && blnBelowY2)
                    return true;
                else
                    blnAboveX1 = blnBelowX2 = blnAboveY1 = blnBelowY2 = false;
            }

            return false;
        }

        private void SaveLeadIndividualImage(string strFolderPath, ImageDrawing objLearnRotatedImage, List<ROI> arrLeadROIs, int intLeadIndex)
        {
            if (m_arrTemplateContour == null)
                return;

            if (m_arrTemplateContour.Length == 0)
                return;

            int intBlobsCount = GetBlobsFeaturesNumber();   // Get number of pad

            if (intBlobsCount <= 0)
                return;

            // Clear all previous template pad individual image 
            string[] strFileList = Directory.GetFiles(strFolderPath, "Lead3D" + intLeadIndex.ToString() + "_*.bmp");
            foreach (string strFile in strFileList)
            {
                if (File.Exists(strFile))
                {
                    File.Delete(strFile);
                }
            }

            ImageDrawing objUnitImage = new ImageDrawing(true);
            ROI objUnitROI = new ROI();
            int intBlobStartX = 0;
            int intBlobStartY = 0;
            int intBlobEndX = 0;
            int intBlobEndY = 0;
            EBW8 px = new EBW8();
            px.Value = 255; // White color pixel value

            List<List<int>> arrElementX = new List<List<int>>();
            List<List<int>> arrElementY = new List<List<int>>();
            for (int intBlobIndex = 0; intBlobIndex < intBlobsCount; intBlobIndex++)
            {
                arrElementX.Add(new List<int>());
                arrElementY.Add(new List<int>());

                if (intBlobIndex >= m_arrTemplateContour[0].ref_pvContourList.Count)
                    continue;


                EBW8PathVector pv = m_arrTemplateContour[0].ref_pvContourList[intBlobIndex];
                int intNumElements = (int)pv.NumElements;

                for (int i = 0; i < intNumElements; i++)
                {
                    arrElementX[intBlobIndex].Add(pv.GetElement(i).X);
                    arrElementY[intBlobIndex].Add(pv.GetElement(i).Y);
                }
            }

            // Scan other blobs
            for (int j = 0; j < intBlobsCount; j++)
            {
                arrLeadROIs[0].CopyToImage(ref objUnitImage);
                objUnitROI.AttachImage(objUnitImage);
                objUnitROI.LoadROISetting(
                                    0, 0,
                                    arrLeadROIs[0].ref_ROIWidth,
                                    arrLeadROIs[0].ref_ROIHeight);

                EasyImage.GainOffset(objUnitROI.ref_ROI, objUnitROI.ref_ROI, 1f, -255f);

                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[j];
                intBlobStartX = m_stcBlobLead.intStartX;
                intBlobStartY = m_stcBlobLead.intStartY;
                intBlobEndX = m_stcBlobLead.intEndX;
                intBlobEndY = m_stcBlobLead.intEndY;

                // Scan blobs (rectangle limit size) each pixel
                for (int x = intBlobStartX; x < intBlobEndX; x++)
                {
                    for (int y = intBlobStartY; y < intBlobEndY; y++)
                    {
                        bool blnAboveX1 = false, blnBelowX2 = false, blnAboveY1 = false, blnBelowY2 = false;
                        int intNumElements = arrElementX[j].Count;
                        for (int i = 0; i < intNumElements; i++)
                        {
                            if (x == arrElementX[j][i])
                            {
                                if (y >= arrElementY[j][i])
                                    blnAboveY1 = true;

                                if (y <= arrElementY[j][i])
                                    blnBelowY2 = true;
                            }

                            if (y == arrElementY[j][i])
                            {
                                if (x >= arrElementX[j][i])
                                    blnAboveX1 = true;

                                if (x <= arrElementX[j][i])
                                    blnBelowX2 = true;
                            }
                        }

                        // Make sure the pixel is in the blob contour area
                        if (blnAboveX1 && blnBelowX2 && blnAboveY1 && blnBelowY2)
                        {
                            // change the pixel value to white
                            objUnitImage.ref_objMainImage.SetPixel(px, x, y);
                        }
                    }
                }

                objUnitImage.SaveImage(strFolderPath + "Lead3D" + intLeadIndex + "_" + j.ToString() + ".bmp");
            }
            objUnitImage.Dispose();

        }

        public void LoadUnitPattern(string strPath)
        {
            if (File.Exists(strPath))
                m_objMatcher.Load(strPath);
        }

        public void LoadUnitFinder(string strPath)
        {
            //if (File.Exists(strPath))
            //    m_objFinder.Load(strPath);
        }

        public bool FindUnitUsingPRS(ROI objSearchROI, int intAngleTolerance, bool blnFastMode, int intLeadIndex)
        {
            /*
             * Accuracy is not good when FastMode is true
             */

            if (!m_objMatcher.PatternLearnt)
                return false;

            m_objMatcher.MinAngle = -intAngleTolerance;
            m_objMatcher.MaxAngle = intAngleTolerance;

            m_objMatcher.MaxPositions = 2;
            if (blnFastMode)
                m_objMatcher.FinalReduction = 2;
            else
                m_objMatcher.FinalReduction = 1;
            m_objMatcher.Interpolate = true;

            m_objMatcher.Match(objSearchROI.ref_ROI);

            if (m_objMatcher.NumPositions > 0)
            {
#if (Debug_2_12 || Release_2_12)
                for (uint i = 0; i < m_objMatcher.NumPositions; i++)
                {
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                for (int i = 0; i < m_objMatcher.NumPositions; i++)
                {
#endif

                    if (m_objMatcher.GetPosition(i).Score > 0.5)
                    {
                        switch (intLeadIndex)
                        {
                            case 1:
                                if (m_pUnitCenterPoint.X == 0 && m_pUnitCenterPoint.Y == 0)
                                {
                                    m_pUnitCenterPoint = new PointF(objSearchROI.ref_ROITotalX + m_objMatcher.GetPosition(i).CenterX,
                                        objSearchROI.ref_ROITotalY + m_objMatcher.GetPosition(i).CenterY);

                                    m_fUnitAngle = m_objMatcher.GetPosition(i).Angle;
                                }
                                else
                                {
                                    if (m_pUnitCenterPoint.Y > objSearchROI.ref_ROITotalY + m_objMatcher.GetPosition(i).CenterY)
                                    {
                                        m_pUnitCenterPoint = new PointF(objSearchROI.ref_ROITotalX + m_objMatcher.GetPosition(i).CenterX,
                                            objSearchROI.ref_ROITotalY + m_objMatcher.GetPosition(i).CenterY);
                                        m_fUnitAngle = m_objMatcher.GetPosition(i).Angle;
                                    }
                                }
                                break;
                            case 2:
                                if (m_pUnitCenterPoint.X == 0 && m_pUnitCenterPoint.Y == 0)
                                {
                                    m_pUnitCenterPoint = new PointF(objSearchROI.ref_ROITotalX + m_objMatcher.GetPosition(i).CenterX,
                                        objSearchROI.ref_ROITotalY + m_objMatcher.GetPosition(i).CenterY);

                                    m_fUnitAngle = m_objMatcher.GetPosition(i).Angle;
                                }
                                else
                                {
                                    if (m_pUnitCenterPoint.X < objSearchROI.ref_ROITotalX + m_objMatcher.GetPosition(i).CenterX)
                                    {
                                        m_pUnitCenterPoint = new PointF(objSearchROI.ref_ROITotalX + m_objMatcher.GetPosition(i).CenterX,
                                            objSearchROI.ref_ROITotalY + m_objMatcher.GetPosition(i).CenterY);
                                        m_fUnitAngle = m_objMatcher.GetPosition(i).Angle;
                                    }
                                }
                                break;
                            case 3:
                                if (m_pUnitCenterPoint.X == 0 && m_pUnitCenterPoint.Y == 0)
                                {
                                    m_pUnitCenterPoint = new PointF(objSearchROI.ref_ROITotalX + m_objMatcher.GetPosition(i).CenterX,
                                        objSearchROI.ref_ROITotalY + m_objMatcher.GetPosition(i).CenterY);

                                    m_fUnitAngle = m_objMatcher.GetPosition(i).Angle;
                                }
                                else
                                {
                                    if (m_pUnitCenterPoint.Y < objSearchROI.ref_ROITotalY + m_objMatcher.GetPosition(i).CenterY)
                                    {
                                        m_pUnitCenterPoint = new PointF(objSearchROI.ref_ROITotalX + m_objMatcher.GetPosition(i).CenterX,
                                            objSearchROI.ref_ROITotalY + m_objMatcher.GetPosition(i).CenterY);
                                        m_fUnitAngle = m_objMatcher.GetPosition(i).Angle;
                                    }
                                }
                                break;
                            case 4:
                                if (m_pUnitCenterPoint.X == 0 && m_pUnitCenterPoint.Y == 0)
                                {
                                    m_pUnitCenterPoint = new PointF(objSearchROI.ref_ROITotalX + m_objMatcher.GetPosition(i).CenterX,
                                        objSearchROI.ref_ROITotalY + m_objMatcher.GetPosition(i).CenterY);

                                    m_fUnitAngle = m_objMatcher.GetPosition(i).Angle;
                                }
                                else
                                {
                                    if (m_pUnitCenterPoint.X > objSearchROI.ref_ROITotalX + m_objMatcher.GetPosition(i).CenterX)
                                    {
                                        m_pUnitCenterPoint = new PointF(objSearchROI.ref_ROITotalX + m_objMatcher.GetPosition(i).CenterX,
                                            objSearchROI.ref_ROITotalY + m_objMatcher.GetPosition(i).CenterY);
                                        m_fUnitAngle = m_objMatcher.GetPosition(i).Angle;
                                    }
                                }
                                break;
                        }
                    }
                }

                if (m_pUnitCenterPoint.X != 0 || m_pUnitCenterPoint.Y != 0)
                    return true;
            }
            return false;
        }

        public void LoadLead3D(string strPath, string strSectionName)
        {
            XmlParser objFile = new XmlParser(strPath);

            objFile.GetFirstSection(strSectionName);

            // Load Lead General Setting
            objFile.GetSecondSection("LeadSetting");
            m_intGaugeSizeImageIndex = objFile.GetValueAsInt("GaugeSizeImageIndex", 0, 2);
            m_intCheckLeadDimensionImageIndex = objFile.GetValueAsInt("CheckLeadDimensionImageIndex", 0, 2);
            m_intThresholdValue = objFile.GetValueAsInt("ThresholdValue", -4, 2);
            m_intLeadDirection = objFile.GetValueAsInt("LeadDirection", 0, 2);   // 0=Horizontal, 1=Vertical
            m_intNumberOfLead = objFile.GetValueAsInt("NumberOfLead", 0, 2);
            m_intNumberOfLead_Top = objFile.GetValueAsInt("NumberOfLead_Top", 0, 2);
            m_intNumberOfLead_Bottom = objFile.GetValueAsInt("NumberOfLead_Bottom", 0, 2);
            m_intNumberOfLead_Left = objFile.GetValueAsInt("NumberOfLead_Left", 0, 2);
            m_intNumberOfLead_Right = objFile.GetValueAsInt("NumberOfLead_Right", 0, 2);
            m_blnSelected = objFile.GetValueAsBoolean("LeadSelected", true, 2);
            m_intBaseOffset = objFile.GetValueAsInt("BaseOffset", 0, 2);
            m_blnWantUsePkgToBaseTolerance = objFile.GetValueAsBoolean("WantUsePkgToBaseTolerance", false, 2);
            m_blnWantUseGaugeMeasureBase = objFile.GetValueAsBoolean("WantUseGaugeMeasureBase", false, 2);
            m_intImageRotateOption = objFile.GetValueAsInt("ImageRotateOption", 0, 2);
            m_blnWantUseAverageGrayValueMethod = objFile.GetValueAsBoolean("WantUseAverageGrayValueMethod", false, 2);
            m_blnWantUseAGVMasking = objFile.GetValueAsBoolean("WantUseAGVMasking", false, 2);
            m_intLeadWidthDisplayOption = objFile.GetValueAsInt("LeadWidthDisplayOption", 0, 2);
            m_intLeadLengthVarianceMethod = objFile.GetValueAsInt("LeadLengthVarianceMethod", 0, 2);
            m_intLeadSpanMethod = objFile.GetValueAsInt("LeadSpanMethod", 0, 2);
            m_intLeadContaminationRegion = objFile.GetValueAsInt("LeadContaminationRegion", 0, 2);
            m_intLeadStandOffMethod = objFile.GetValueAsInt("LeadStandOffMethod", 0, 2);
            m_intLeadWidthRangeSelection = objFile.GetValueAsInt("LeadWidthRangeSelection", 0, 2);
            m_intLeadWidthRange = objFile.GetValueAsInt("LeadWidthRange", 10, 2);
            m_intMatchingXTolerance = objFile.GetValueAsInt("MatchingXTolerance", 10, 2);
            m_intMatchingYTolerance = objFile.GetValueAsInt("MatchingYTolerance", 10, 2);
            m_blnMeasureCenterPkgSizeUsingCorner = objFile.GetValueAsBoolean("MeasureCenterPkgSizeUsingCorner", false, 2);

            m_fTemplateMatcher_CenterX = objFile.GetValueAsFloat("TemplateMatcher_CenterX", 0, 2);
            m_fTemplateMatcher_CenterY = objFile.GetValueAsFloat("TemplateMatcher_CenterY", 0, 2);
            m_fTemplateCornerPoint_CenterX = objFile.GetValueAsFloat("TemplateCornerPoint_CenterX", 0, 2);
            m_fTemplateCornerPoint_CenterY = objFile.GetValueAsFloat("TemplateCornerPoint_CenterY", 0, 2);

            m_fAngleTolerance = objFile.GetValueAsFloat("AngleTolerance", 2, 2);
            m_fXTolerance = objFile.GetValueAsFloat("XTolerance", 2, 2);
            m_fYTolerance = objFile.GetValueAsFloat("YTolerance", 2, 2);

            m_intPkgToBaseTolerance_Top = objFile.GetValueAsInt("PkgToBaseTolerance_Top", 0, 2);
            m_intPkgToBaseTolerance_Right = objFile.GetValueAsInt("PkgToBaseTolerance_Right", 0, 2);
            m_intPkgToBaseTolerance_Bottom = objFile.GetValueAsInt("PkgToBaseTolerance_Bottom", 0, 2);
            m_intPkgToBaseTolerance_Left = objFile.GetValueAsInt("PkgToBaseTolerance_Left", 0, 2);

            m_intTipBuildAreaTolerance_Top = objFile.GetValueAsInt("TipBuildAreaTolerance_Top", 0, 2);
            m_intTipBuildAreaTolerance_Right = objFile.GetValueAsInt("TipBuildAreaTolerance_Right", 0, 2);
            m_intTipBuildAreaTolerance_Bottom = objFile.GetValueAsInt("TipBuildAreaTolerance_Bottom", 0, 2);
            m_intTipBuildAreaTolerance_Left = objFile.GetValueAsInt("TipBuildAreaTolerance_Left", 0, 2);

            m_arrCornerSearchingTolerance_Top[0] = objFile.GetValueAsInt("CornerSearchingTolerance_Top1", objFile.GetValueAsInt("CornerSearchingTolerance_Top", 0, 2), 2);
            m_arrCornerSearchingTolerance_Top[1] = objFile.GetValueAsInt("CornerSearchingTolerance_Top2", objFile.GetValueAsInt("CornerSearchingTolerance_Top", 0, 2), 2);
            m_arrCornerSearchingTolerance_Right[0] = objFile.GetValueAsInt("CornerSearchingTolerance_Right1", objFile.GetValueAsInt("CornerSearchingTolerance_Right", 0, 2), 2);
            m_arrCornerSearchingTolerance_Right[1] = objFile.GetValueAsInt("CornerSearchingTolerance_Right2", objFile.GetValueAsInt("CornerSearchingTolerance_Right", 0, 2), 2);
            m_arrCornerSearchingTolerance_Bottom[0] = objFile.GetValueAsInt("CornerSearchingTolerance_Bottom1", objFile.GetValueAsInt("CornerSearchingTolerance_Bottom", 0, 2), 2);
            m_arrCornerSearchingTolerance_Bottom[1] = objFile.GetValueAsInt("CornerSearchingTolerance_Bottom2", objFile.GetValueAsInt("CornerSearchingTolerance_Bottom", 0, 2), 2);
            m_arrCornerSearchingTolerance_Left[0] = objFile.GetValueAsInt("CornerSearchingTolerance_Left1", objFile.GetValueAsInt("CornerSearchingTolerance_Left", 0, 2), 2);
            m_arrCornerSearchingTolerance_Left[1] = objFile.GetValueAsInt("CornerSearchingTolerance_Left2", objFile.GetValueAsInt("CornerSearchingTolerance_Left", 0, 2), 2);
            m_arrCornerSearchingLength[0] = objFile.GetValueAsInt("CornerSearchingLength1", objFile.GetValueAsInt("CornerSearchingLength", 0, 2), 2);
            m_arrCornerSearchingLength[1] = objFile.GetValueAsInt("CornerSearchingLength2", objFile.GetValueAsInt("CornerSearchingLength", 0, 2), 2);

            m_intTipOffset = objFile.GetValueAsInt("TipOffset", 0, 2);
            m_intBaseLineTrimFromEdge = objFile.GetValueAsInt("BaseLineTrimFromEdge", 6, 2);
            m_intBaseLineSteps = objFile.GetValueAsInt("BaseLineSteps", 1, 2);
            m_blnWhiteOnBlack = objFile.GetValueAsBoolean("WhiteOnBlack", true, 2);
            m_intFilterMinArea = objFile.GetValueAsInt("MinArea", 20, 2);
            m_intFailOptionMask = objFile.GetValueAsInt("FailMask", 0, 2);
            m_fLeadRangeStartX = objFile.GetValueAsFloat("LeadStartX", 0, 2);
            m_fLeadRangeStartY = objFile.GetValueAsFloat("LeadStartY", 0, 2);
            m_fLeadRangeEndX = objFile.GetValueAsFloat("LeadEndX", 0, 2);
            m_fLeadRangeEndY = objFile.GetValueAsFloat("LeadEndY", 0, 2);
            m_fReferencePointStartX = objFile.GetValueAsFloat("ReferencePointStartX", 0, 2);
            m_fReferencePointStartY = objFile.GetValueAsFloat("ReferencePointStartY", 0, 2);
            m_fReferencePointEndX = objFile.GetValueAsFloat("ReferencePointEndX", 0, 2);
            m_fReferencePointEndY = objFile.GetValueAsFloat("ReferencePointEndY", 0, 2);
            m_blnClockWise = objFile.GetValueAsBoolean("ClockWise", true, 2);
            m_intFirstLead = objFile.GetValueAsInt("Lead1", 1, 2);

            m_fPitchVarianceLeftMaxSetting = objFile.GetValueAsFloat("PitchVarianceLeftMaxSetting", 0, 2);
            m_fPitchVarianceRightMaxSetting = objFile.GetValueAsFloat("PitchVarianceRightMaxSetting", 0, 2);
            m_fPitchVarianceTopMaxSetting = objFile.GetValueAsFloat("PitchVarianceTopMaxSetting", 0, 2);
            m_fPitchVarianceBottomMaxSetting = objFile.GetValueAsFloat("PitchVarianceBottomMaxSetting", 0, 2);
            m_fStandOffVarianceUnitMaxSetting = objFile.GetValueAsFloat("StandOffVarianceUnitMaxSetting", 0, 2);
            m_fLeadSweepVarianceLeftMinSetting = objFile.GetValueAsFloat("LeadSweepVarianceLeftMinSetting", 0, 2);
            m_fLeadSweepVarianceRightMinSetting = objFile.GetValueAsFloat("LeadSweepVarianceRightMinSetting", 0, 2);
            m_fLeadSweepVarianceTopMinSetting = objFile.GetValueAsFloat("LeadSweepVarianceTopMinSetting", 0, 2);
            m_fLeadSweepVarianceBottomMinSetting = objFile.GetValueAsFloat("LeadSweepVarianceBottomMinSetting", 0, 2);
            m_fLeadSweepVarianceLeftMaxSetting = objFile.GetValueAsFloat("LeadSweepVarianceLeftMaxSetting", 0, 2);
            m_fLeadSweepVarianceRightMaxSetting = objFile.GetValueAsFloat("LeadSweepVarianceRightMaxSetting", 0, 2);
            m_fLeadSweepVarianceTopMaxSetting = objFile.GetValueAsFloat("LeadSweepVarianceTopMaxSetting", 0, 2);
            m_fLeadSweepVarianceBottomMaxSetting = objFile.GetValueAsFloat("LeadSweepVarianceBottomMaxSetting", 0, 2);
            m_fLengthVarianceOverallMaxSetting = objFile.GetValueAsFloat("LengthVarianceOverallMaxSetting", 0, 2);
            m_fLengthVarianceLeftMaxSetting = objFile.GetValueAsFloat("LengthVarianceLeftMaxSetting", 0, 2);
            m_fLengthVarianceRightMaxSetting = objFile.GetValueAsFloat("LengthVarianceRightMaxSetting", 0, 2);
            m_fLengthVarianceTopMaxSetting = objFile.GetValueAsFloat("LengthVarianceTopMaxSetting", 0, 2);
            m_fLengthVarianceBottomMaxSetting = objFile.GetValueAsFloat("LengthVarianceBottomMaxSetting", 0, 2);
            m_fStandOffVarianceLeftMaxSetting = objFile.GetValueAsFloat("StandOffVarianceLeftMaxSetting", 0, 2);
            m_fStandOffVarianceRightMaxSetting = objFile.GetValueAsFloat("StandOffVarianceRightMaxSetting", 0, 2);
            m_fStandOffVarianceTopMaxSetting = objFile.GetValueAsFloat("StandOffVarianceTopMaxSetting", 0, 2);
            m_fStandOffVarianceBottomMaxSetting = objFile.GetValueAsFloat("StandOffVarianceBottomMaxSetting", 0, 2);
            m_fStandOffVarianceUnitMaxSetting = objFile.GetValueAsFloat("StandOffVarianceUnitMaxSetting", 0, 2);
            m_fSpanOverallMinSetting = objFile.GetValueAsFloat("SpanOverallMinSetting", 0, 2);
            m_fSpanOverallMaxSetting = objFile.GetValueAsFloat("SpanOverallMaxSetting", 0, 2);
            m_fSpanTopMinSetting = objFile.GetValueAsFloat("SpanTopMinSetting", 0, 2);
            m_fSpanTopMaxSetting = objFile.GetValueAsFloat("SpanTopMaxSetting", 0, 2);
            m_fSpanBottomMinSetting = objFile.GetValueAsFloat("SpanBottomMinSetting", 0, 2);
            m_fSpanBottomMaxSetting = objFile.GetValueAsFloat("SpanBottomMaxSetting", 0, 2);
            m_fSpanLeftMinSetting = objFile.GetValueAsFloat("SpanLeftMinSetting", 0, 2);
            m_fSpanLeftMaxSetting = objFile.GetValueAsFloat("SpanLeftMaxSetting", 0, 2);
            m_fSpanRightMinSetting = objFile.GetValueAsFloat("SpanRightMinSetting", 0, 2);
            m_fSpanRightMaxSetting = objFile.GetValueAsFloat("SpanRightMaxSetting", 0, 2);
            m_fExtraLeadSetArea = objFile.GetValueAsFloat("ExtraLeadSetArea", 0, 2);
            m_fTotalExtraLeadSetArea = objFile.GetValueAsFloat("TotalExtraLeadSetArea", 0, 2);
            m_fBaseLineMaxAngle = objFile.GetValueAsFloat("BaseLineMaxAngle", 0, 2);
            m_fExtraLeadSetLength = objFile.GetValueAsFloat("ExtraLeadSetLength", 0, 2);
            m_blnWantCheckExtraLeadLength = objFile.GetValueAsBoolean("WantCheckExtraLeadLength", false, 2);
            m_blnWantCheckExtraLeadArea = objFile.GetValueAsBoolean("WantCheckExtraLeadArea", false, 2);
            // Load lead Blobs Features
            int intBlobsCount = objFile.GetValueAsInt("BlobsFeaturesCount", 0, 2);
            int intContourLength = 0;
            int[] arrContourX;
            int[] arrContourY;
            ClearTemplateBlobsFeatures();
            for (int intBlobIndex = 0; intBlobIndex < intBlobsCount; intBlobIndex++)
            {
                objFile.GetSecondSection("BlobsFeatures" + intBlobIndex);

                intContourLength = objFile.GetValueAsInt("ContourLength", 0, 2);

                arrContourX = new int[intContourLength];
                arrContourY = new int[intContourLength];

                for (int j = 0; j < intContourLength; j++)
                {
                    arrContourX[j] = objFile.GetValueAsInt("ContourX" + j.ToString(), 0, 2);
                    arrContourY[j] = objFile.GetValueAsInt("ContourY" + j.ToString(), 0, 2);
                }

                SetTemplateBlobsFeatures(
                    objFile.GetValueAsInt("NoID", 0, 2),
                    objFile.GetValueAsInt("GroupNo", 0, 2),
                    objFile.GetValueAsFloat("Area", 0, 2),
                    objFile.GetValueAsInt("LengthMode", 0, 2),
                    objFile.GetValueAsInt("ContourX", 0, 2),
                    objFile.GetValueAsInt("ContourY", 0, 2),
                    arrContourX,
                    arrContourY,
                    objFile.GetValueAsInt("StartX", 0, 2),
                    objFile.GetValueAsInt("StartY", 0, 2),
                    objFile.GetValueAsInt("EndX", 0, 2),
                    objFile.GetValueAsInt("EndY", 0, 2),
                    objFile.GetValueAsFloat("fStartX", 0, 2),
                    objFile.GetValueAsFloat("fStartY", 0, 2),
                    objFile.GetValueAsFloat("fEndX", 0, 2),
                    objFile.GetValueAsFloat("fEndY", 0, 2),
                    objFile.GetValueAsInt("Direction", 0, 2),
                    objFile.GetValueAsInt("LeadSide", 0, 2),
                    objFile.GetValueAsFloat("GravityCenterX", 0, 2),
                    objFile.GetValueAsFloat("GravityCenterY", 0, 2),
                    objFile.GetValueAsFloat("LimitCenterX", 0, 2),
                    objFile.GetValueAsFloat("LimitCenterY", 0, 2),
                    objFile.GetValueAsFloat("Width", 0, 2),
                    objFile.GetValueAsFloat("Height", 0, 2),
                    objFile.GetValueAsFloat("BaseWidth", 0, 2),
                    objFile.GetValueAsFloat("BaseLength", 0, 2),
                    objFile.GetValueAsFloat("BaseCenterX", 0, 2),
                    objFile.GetValueAsFloat("BaseCenterY", 0, 2),
                    objFile.GetValueAsFloat("TipWidth", 0, 2),
                    objFile.GetValueAsFloat("TipHeight", 0, 2),
                    objFile.GetValueAsFloat("TipCenterX", 0, 2),
                    objFile.GetValueAsFloat("TipCenterY", 0, 2),
                    objFile.GetValueAsBoolean("Selected", false, 2),
                    objFile.GetValueAsBoolean("CheckSkew", true, 2),
                    objFile.GetValueAsFloat("SweepLeftReference", 0, 2),
                    objFile.GetValueAsFloat("SweepRightReference", 0, 2),
                    objFile.GetValueAsFloat("SweepTopReference", 0, 2),
                    objFile.GetValueAsFloat("SweepBottomReference", 0, 2),
                    objFile.GetValueAsFloat("LeftDistance", 0, 2),
                    objFile.GetValueAsFloat("RightDistance", 0, 2),
                    objFile.GetValueAsFloat("TopDistance", 0, 2),
                    objFile.GetValueAsFloat("BottomDistance", 0, 2),
                    objFile.GetValueAsFloat("XDistance", 0, 2),
                    objFile.GetValueAsFloat("YDistance", 0, 2),
                    objFile.GetValueAsFloat("Pitch", 0, 2),
                    objFile.GetValueAsFloat("Gap", 0, 2),
                    objFile.GetValueAsFloat("Skew", 0, 2),
                    objFile.GetValueAsFloat("OffSet", 0, 2),
                    objFile.GetValueAsFloat("MinBaseWidth", 0, 2),
                    objFile.GetValueAsFloat("MaxBaseWidth", 0, 2),
                    objFile.GetValueAsFloat("MinBaseLength", 0, 2),
                    objFile.GetValueAsFloat("MaxBaseLength", 0, 2),
                    objFile.GetValueAsFloat("MinTipWidth", 0, 2),
                    objFile.GetValueAsFloat("MaxTipWidth", 0, 2),
                    objFile.GetValueAsFloat("MinTipHeight", 0, 2),
                    objFile.GetValueAsFloat("MaxTipHeight", 0, 2),
                    objFile.GetValueAsFloat("MinPitch", 0, 2),
                    objFile.GetValueAsFloat("MaxPitch", 0, 2),
                    objFile.GetValueAsFloat("MinGap", 0, 2),
                    objFile.GetValueAsFloat("MaxGap", 0, 2),
                    objFile.GetValueAsFloat("MinStandOff", 0, 2),
                    objFile.GetValueAsFloat("MaxStandOff", 0, 2),
                    objFile.GetValueAsFloat("MinSolderPadLength", 0, 2),
                    objFile.GetValueAsFloat("MaxSolderPadLength", 0, 2),
                    objFile.GetValueAsFloat("MaxCoplan", 0, 2),
                    objFile.GetValueAsFloat("MinAGV", 0, 2),
                    objFile.GetValueAsFloat("MaxAGV", 0, 2),
                    objFile.GetValueAsInt("AGVROITolerance_Top", 0, 2),
                    objFile.GetValueAsInt("AGVROITolerance_Right", 0, 2),
                    objFile.GetValueAsInt("AGVROITolerance_Bottom", 0, 2),
                    objFile.GetValueAsInt("AGVROITolerance_Left", 0, 2),
                    objFile.GetValueAsFloat("LimitMinWidth", 0, 2),
                    objFile.GetValueAsFloat("LimitMaxWidth", 0, 2),
                    objFile.GetValueAsFloat("LimitBurrWidth", 0, 2),
                    objFile.GetValueAsFloat("WidthOffset", 0, 2),
                    objFile.GetValueAsFloat("LengthOffset", 0, 2),
                    objFile.GetValueAsFloat("PitchOffset", 0, 2),
                    objFile.GetValueAsFloat("GapOffset", 0, 2),
                    objFile.GetValueAsFloat("StandOffOffset", 0, 2),
                    objFile.GetValueAsFloat("CoplanOffset", 0, 2)
                    );
            }

            // Load Pitch Gap
            int intPitchGapCount = objFile.GetValueAsInt("PitchGapCount", 0, 2);
            ClearTemplatePitchGap();
            for (int intPitchGapIndex = 0; intPitchGapIndex < intPitchGapCount; intPitchGapIndex++)
            {
                objFile.GetSecondSection("PitchGap" + intPitchGapIndex);

                //float gg = objFile.GetValueAsFloat("Gap", 0, 2);
                float pp = objFile.GetValueAsFloat("Pitch", 0, 2);
                SetPitchGapData(
                    objFile.GetValueAsInt("FromLeadNo", 0, 2),
                    objFile.GetValueAsInt("ToLeadNo", 0, 2),
                    objFile.GetValueAsFloat("MinPitch", 0, 2),
                    objFile.GetValueAsFloat("MaxPitch", 0, 2),
                    objFile.GetValueAsFloat("MinGap", 0, 2),
                    objFile.GetValueAsFloat("MaxGap", 0, 2),
                    objFile.GetValueAsFloat("Pitch", 0, 2),
                    objFile.GetValueAsFloat("Gap", 0, 2),
                    objFile.GetValueAsInt("StartX", 0, 2),
                    objFile.GetValueAsInt("StartY", 0, 2),
                    objFile.GetValueAsInt("EndX", 0, 2),
                    objFile.GetValueAsInt("EndY", 0, 2),
                    objFile.GetValueAsInt("Direction", 0, 2));
            }

            // Load Package
            objFile.GetSecondSection("PackageSetting");
            m_intFailPkgOptionMask = objFile.GetValueAsInt("FailPkgMask", 0, 2);
            m_blnInspectPackage = objFile.GetValueAsBoolean("WantInspectPackage", false, 2);
            m_fChipStartPixelFromEdge = objFile.GetValueAsFloat("ChipStartPixelFromEdge", 2, 2);
            m_fChipStartPixelFromRight = objFile.GetValueAsFloat("ChipStartPixelFromRight", 2, 2);
            m_fChipStartPixelFromBottom = objFile.GetValueAsFloat("ChipStartPixelFromBottom", 2, 2);
            m_fChipStartPixelFromLeft = objFile.GetValueAsFloat("ChipStartPixelFromLeft", 2, 2);
            m_fMoldStartPixelFromEdge = objFile.GetValueAsFloat("MoldStartPixelFromEdge", 2, 2);
            m_fMoldStartPixelFromRight = objFile.GetValueAsFloat("MoldStartPixelFromRight", 2, 2);
            m_fMoldStartPixelFromBottom = objFile.GetValueAsFloat("MoldStartPixelFromBottom", 2, 2);
            m_fMoldStartPixelFromLeft = objFile.GetValueAsFloat("MoldStartPixelFromLeft", 2, 2);
            m_fPkgStartPixelFromEdge = objFile.GetValueAsFloat("PkgStartPixelFromEdge", 0, 2);
            m_fPkgStartPixelFromRight = objFile.GetValueAsFloat("PkgStartPixelFromRight", 0, 2);
            m_fPkgStartPixelFromBottom = objFile.GetValueAsFloat("PkgStartPixelFromBottom", 0, 2);
            m_fPkgStartPixelFromLeft = objFile.GetValueAsFloat("PkgStartPixelFromLeft", 0, 2);
            m_intPkgImage1HighPadThreshold = objFile.GetValueAsInt("PkgImage1HighPadThreshold", 255, 2);
            m_intPkgImage1LowPadThreshold = objFile.GetValueAsInt("PkgImage1LowPadThreshold", 0, 2);
            m_intPkgImage1HighSurfaceThreshold = objFile.GetValueAsInt("PkgImage1HighSurfaceThreshold", 255, 2);
            m_intPkgImage1LowSurfaceThreshold = objFile.GetValueAsInt("PkgImage1LowSurfaceThreshold", 0, 2);
            m_fPkgImage1Gain = objFile.GetValueAsFloat("PkgImage1Gain", 1f, 2);
            m_intPkgImage2HighThreshold = objFile.GetValueAsInt("PkgImage2HighPadThreshold", 255, 2);
            m_intPkgImage2LowThreshold = objFile.GetValueAsInt("PkgImage2LowPadThreshold", 0, 2);
            m_intPkgImage3HighThreshold = objFile.GetValueAsInt("PkgImage3HighPadThreshold", 255, 2);
            m_intPkgImage3LowThreshold = objFile.GetValueAsInt("PkgImage3LowPadThreshold", 0, 2);
            m_intPkgImage1MoldFlashThreshold = objFile.GetValueAsInt("PkgImage1MoldFlashThreshold", 125, 2);
            m_intPkgImage2VoidThreshold = objFile.GetValueAsInt("PkgImage2VoidThreshold", 125, 2);
            m_intPkgImage2HighCrackThreshold = objFile.GetValueAsInt("PkgImage2HighCrackThreshold", 255, 2);
            m_intPkgImage2LowCrackThreshold = objFile.GetValueAsInt("PkgImage2LowCrackThreshold", 0, 2);
            m_intPkgImage1ChippedThreshold = objFile.GetValueAsInt("PkgImage1ChippedThreshold", 125, 2);
            m_intBrightFieldLowThreshold = objFile.GetValueAsInt("BrightFieldLowThreshold", 50, 2);
            m_intBrightFieldHighThreshold = objFile.GetValueAsInt("BrightFieldHighThreshold", 255, 2);
            m_intDarkFieldLowThreshold = objFile.GetValueAsInt("DarkFieldLowThreshold", 50, 2);
            m_fDarkFieldImageGain = objFile.GetValueAsFloat("DarkFieldImageGain", 1f, 2);
            m_intDarkFieldHighThreshold = objFile.GetValueAsInt("DarkFieldHighThreshold", 255, 2);

            ////PackageSize Offset
            //m_fPackageWidthOffsetMM = objFile.GetValueAsFloat("PackageWidthOffsetMM", 0, 2);
            //m_fPackageHeightOffsetMM = objFile.GetValueAsFloat("PackageHeightOffsetMM", 0, 2);
            //m_fPackageThicknessOffsetMM = objFile.GetValueAsFloat("PackageThicknessOffsetMM", 0, 2);

            m_fUnitWidth = objFile.GetValueAsFloat("UnitWidth", 0, 2);
            m_fUnitHeight = objFile.GetValueAsFloat("UnitHeight", 0, 2);
            m_fUnitThickness = objFile.GetValueAsFloat("UnitThickness", 0, 2);
            m_fUnitWidthMin = objFile.GetValueAsFloat("UnitWidthMin", 0, 2);
            m_fUnitWidthMax = objFile.GetValueAsFloat("UnitWidthMax", 0, 2);
            m_fUnitHeightMin = objFile.GetValueAsFloat("UnitHeightMin", 0, 2);
            m_fUnitHeightMax = objFile.GetValueAsFloat("UnitHeightMax", 0, 2);
            m_fUnitThicknessMin = objFile.GetValueAsFloat("UnitThicknessMin", 0, 2);
            m_fUnitThicknessMax = objFile.GetValueAsFloat("UnitThicknessMax", 0, 2);

            m_fUnitSizeLength = objFile.GetValueAsFloat("UnitSizeLength", 0, 2);
            m_fCrackLength = objFile.GetValueAsFloat("CrackLength", 0, 2);
            m_fScratchLength = objFile.GetValueAsFloat("ScratchLength", 0, 2);
            m_fScratchArea = objFile.GetValueAsFloat("ScratchArea", 0, 2);
            m_fChipArea = objFile.GetValueAsFloat("ChipArea", 0, 2);
            m_fContaminationLength = objFile.GetValueAsFloat("ContaminationLength", 0, 2);
            m_fSolderMeltLength = objFile.GetValueAsFloat("SolderMeltLength", 0, 2);
            m_fVoidLength = objFile.GetValueAsFloat("VoidLength", 0, 2);
            m_fVoidArea = objFile.GetValueAsFloat("VoidArea", 0, 2);
            m_fCrackLength = objFile.GetValueAsFloat("CrackLength", 0, 2);
            m_fCrackArea = objFile.GetValueAsFloat("CrackArea", 0, 2);
            m_fMoldFlashArea = objFile.GetValueAsFloat("MoldFlashArea", 0, 2);
            m_fInCompletePlateLength = objFile.GetValueAsFloat("InCompletePlateLength", 0, 2);
            m_fLeadBrokenLength = objFile.GetValueAsFloat("LeadBrokenLength", 0, 2);

            m_fBrightLength = objFile.GetValueAsFloat("BrightLength", 0, 2);
            m_fBrightWidth = objFile.GetValueAsFloat("BrightWidth", 0, 2);
            m_fBrightArea = objFile.GetValueAsFloat("BrightArea", 0, 2);
            m_fBrightTotalArea = objFile.GetValueAsFloat("BrightTotalArea", 0, 2);
            m_fDarkLength = objFile.GetValueAsFloat("DarkLength", 0, 2);
            m_fDarkWidth = objFile.GetValueAsFloat("DarkWidth", 0, 2);
            m_fDarkArea = objFile.GetValueAsFloat("DarkArea", 0, 2);
            m_fDarkTotalArea = objFile.GetValueAsFloat("DarkTotalArea", 0, 2);
            m_fBrightChippedOffArea = objFile.GetValueAsFloat("BrightChippedOffArea", 0, 2);
            m_fDarkChippedOffArea = objFile.GetValueAsFloat("DarkChippedOffArea", 0, 2);
            m_fDarkVerticalCrack = objFile.GetValueAsFloat("DarkVerticalCrack", 0, 2);
            m_fDarkHorizontalCrack = objFile.GetValueAsFloat("DarkHorizontalCrack", 0, 2);

            //m_fUnitWidth = objFile.GetValueAsFloat("UnitWidth", 0, 2);
            //m_fUnitHeight = objFile.GetValueAsFloat("UnitHeight", 0, 2);
            //m_fUnitThickness = objFile.GetValueAsFloat("UnitThickness", 0, 2);
            //m_fUnitWidthMin = objFile.GetValueAsFloat("UnitWidthMin", 0, 2);
            //m_fUnitWidthMax = objFile.GetValueAsFloat("UnitWidthMax", 0, 2);
            //m_fUnitHeightMin = objFile.GetValueAsFloat("UnitHeightMin", 0, 2);
            //m_fUnitHeightMax = objFile.GetValueAsFloat("UnitHeightMax", 0, 2);
            //m_fUnitThicknessMin = objFile.GetValueAsFloat("UnitThicknessMin", 0, 2);
            //m_fUnitThicknessMax = objFile.GetValueAsFloat("UnitThicknessMax", 0, 2);

            //m_fUnitSizeLength = objFile.GetValueAsFloat("UnitSizeLength", 0, 2);
            //m_fCrackLength = objFile.GetValueAsFloat("CrackLength", 0, 2);
            //m_fScratchLength = objFile.GetValueAsFloat("ScratchLength", 0, 2);
            //m_fContaminationLength = objFile.GetValueAsFloat("ContaminationLength", 0, 2);
            //m_fSolderMeltLength = objFile.GetValueAsFloat("SolderMeltLength", 0, 2);
            //m_fVoidLength = objFile.GetValueAsFloat("VoidLength", 0, 2);
            //m_fMoldFlashLength = objFile.GetValueAsFloat("MoldFlashLength", 0, 2);
            //m_fInCompletePlateLength = objFile.GetValueAsFloat("InCompletePlateLength", 0, 2);
            //m_fLeadBrokenLength = objFile.GetValueAsFloat("LeadBrokenLength", 0, 2);

            m_intMPTolerance = objFile.GetValueAsInt("MPTolerance", 3, 2);

            // Grab image index
            int intGrabImageIndexCount = objFile.GetValueAsInt("GrabImageIndexCount", 0, 2);
            m_arrGrabImageIndex.Clear();
            for (int j = 0; j < intGrabImageIndexCount; j++)
                m_arrGrabImageIndex.Add(objFile.GetValueAsInt("GrabImageIndex" + j.ToString(), 0, 2));
        }
        public void LoadPitchGapLinkTemporary()
        {
            m_arrPitchGap.Clear();
            
            for (int i = 0; i < m_arrBackupPitchGap.Count; i++)
            {
                PitchGap stcPitchGapPrev = (PitchGap)m_arrBackupPitchGap[i];

                if (stcPitchGapPrev.intFromLeadNo >= m_arrTemplateBlobLeads.Count || stcPitchGapPrev.intToLeadNo >= m_arrTemplateBlobLeads.Count)
                    continue;

                int intFormLeadNo = stcPitchGapPrev.intFromLeadNo;

                bool blnAllowChange = true;
                int intToLeadNo = stcPitchGapPrev.intToLeadNo;

                if (intFormLeadNo == intToLeadNo)
                {

                    blnAllowChange = false;
                }
                else if (CheckPitchGapLinkExist(intFormLeadNo, intToLeadNo))
                {
                    blnAllowChange = false;
                }
                else if (CheckPitchGapLinkInLeadAlready(intFormLeadNo))
                {
                    //blnAllowChange = false;
                }
                else if (!CheckPitchGapLinkAvailable(intFormLeadNo, intToLeadNo))
                {
                    blnAllowChange = false;
                }

                if (blnAllowChange)
                {
                    SetPitchGap(intFormLeadNo, intToLeadNo);
                }
            }
        }
        public void LoadLeadTemplateImage(string strFolderPath, int intLeadIndex)
        {
            ROI objROI = new ROI();

            if (File.Exists(strFolderPath + "UnitTemplate" + intLeadIndex + ".bmp"))
            {
                if (!objROI.LoadImage(strFolderPath + "UnitTemplate" + intLeadIndex + ".bmp", false))
                    return;

                DefineTemplateLeadContour2(objROI);
            }

            //if (File.Exists(strFolderPath + "UnitTemplate" + intLeadIndex + ".bmp"))
            //    AddTemplateImage(strFolderPath + "UnitTemplate" + intLeadIndex + ".bmp");

            for (int i = 0; i < m_arrImgLeadImage.Count; i++)
            {
                if (m_arrImgLeadImage != null)
                    m_arrImgLeadImage[i].Dispose();
            }

            m_arrImgLeadImage.Clear();
            int intBlobsCount = GetBlobsFeaturesNumber();
            for (int i = 0; i < intBlobsCount; i++)
            {
                if (File.Exists(strFolderPath + "Lead" + intLeadIndex.ToString() + "_" + i.ToString() + ".bmp"))
                {
                    m_arrImgLeadImage.Add(new EImageBW8());
                    m_arrImgLeadImage[i].Load(strFolderPath + "Lead" + intLeadIndex.ToString() + "_" + i.ToString() + ".bmp");
                }
            }

            LoadUnitPattern(strFolderPath + "UnitMatcher" + intLeadIndex.ToString() + ".mch");
            //LoadUnitFinder(strFolderPath + "UnitFinder" + intLeadIndex.ToString() + ".fnd");


            if (File.Exists(strFolderPath + "DontCareImage" + intLeadIndex.ToString() + "_0.bmp"))
                m_objLead3DDontCareImage.LoadImage(strFolderPath + "DontCareImage" + intLeadIndex.ToString() + "_0.bmp");


            objROI.Dispose();
        }
        public void SaveLeadPackageTemplateImage(string strFolderPath, ImageDrawing objLearnRotatedImage, List<ROI> arrLeadROIs, int intLeadIndex)
        {
            ROI objUnitTemplateROI = new ROI();

            objUnitTemplateROI.AttachImage(objLearnRotatedImage);

            objUnitTemplateROI.LoadROISetting(
                arrLeadROIs[0].ref_ROITotalX, arrLeadROIs[0].ref_ROITotalY,
                arrLeadROIs[0].ref_ROIWidth, arrLeadROIs[0].ref_ROIHeight);

            // Save Template Unit Image
            arrLeadROIs[0].SaveImage(strFolderPath + "UnitPackageTemplate" + intLeadIndex + ".bmp");

            // ---------------------- Save Image for package inspection used ----------------------------------------------------------------------------------------------------

            // Copy learn image to a temporary image memory so that the temporary image can be modified without bother the
            ImageDrawing objImage = new ImageDrawing();
            objLearnRotatedImage.CopyTo(ref objImage);
            ROI objTempROI = new ROI();
            objTempROI.LoadROISetting(
            arrLeadROIs[0].ref_ROITotalX,
            arrLeadROIs[0].ref_ROITotalY,
            arrLeadROIs[0].ref_ROIWidth,
            arrLeadROIs[0].ref_ROIHeight);
            objTempROI.AttachImage(objImage);

            //Save Erode Image
            ImageDrawing.ErodeImage(arrLeadROIs[0], ref objTempROI, 2);
            objUnitTemplateROI.AttachImage(objImage);
            objUnitTemplateROI.SaveImage(strFolderPath + "PkgImage" + intLeadIndex + "_0.bmp");

            //Save Dilate Image
            ImageDrawing.DilateImage(arrLeadROIs[0], ref objTempROI, 2);

            objUnitTemplateROI.SaveImage(strFolderPath + "PkgImage" + intLeadIndex + "_1.bmp");

            //SaveUnitPattern(arrPadROIs[2], strFolderPath, intPadIndex); // Pad ROI index 2 is unit roi, index 1 is gauge roi

            objUnitTemplateROI.Dispose();
            objTempROI.Dispose();
            objImage.Dispose();
        }
        public bool AddPackageTemplateImage(string strTemplateImagePath)
        {
            m_ImgUnitTemplateImagePkg.Load(strTemplateImagePath);

            // Get threshold value
            int intThresholdValue;
            if (m_intThresholdValue < 0)
            {
                EBW8 objBW8 = EasyImage.AutoThreshold(m_ImgUnitTemplateImagePkg, EThresholdMode.MinResidue);
                intThresholdValue = objBW8.Value;
            }
            else
                intThresholdValue = m_intThresholdValue;

            // Get whole white background unit template image
            m_ImgWhiteUnitTemplateImagePkg.Load(strTemplateImagePath);
            m_ImgBlackUnitTemplateImagePkg.Load(strTemplateImagePath);
            EBW8 pixelWhite = new EBW8();
            EBW8 pixelBlack = new EBW8();
            pixelWhite.Value = 255;
            pixelBlack.Value = 0;
            for (int x = 0; x < m_ImgBlackUnitTemplateImagePkg.Width; x++)
            {
                for (int y = 0; y < m_ImgBlackUnitTemplateImagePkg.Height; y++)
                {
                    m_ImgWhiteUnitTemplateImagePkg.SetPixel(pixelWhite, x, y);
                    m_ImgBlackUnitTemplateImagePkg.SetPixel(pixelBlack, x, y);
                }
            }

            return true;
        }
        public void LoadLeadPackageTemplateImage(string strFolderPath, int intLeadIndex)
        {
            if (File.Exists(strFolderPath + "UnitPackageTemplate" + intLeadIndex + ".bmp"))
                AddPackageTemplateImage(strFolderPath + "UnitPackageTemplate" + intLeadIndex + ".bmp");

        }
        /// <summary>
        /// Define template tolerance either use default tolerance or use previous tolerance
        /// </summary>
        /// <param name="blnUseDefault">true = use default tolerance, false = use previous tolerance</param>
        public void DefineTolerance(bool blnUseDefault)
        {
            if (blnUseDefault)
                DefineLeadDefaultTolerance();
            else
                UpdatePreviousToleranceToTemplate();
        }

        public void DefineLeadDefaultTolerance()
        {
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                // Use Pixel to calculate default setting
                m_stcBlobLead.fSkew = 0.030f;
                m_stcBlobLead.fOffSet = 0.030f;

                switch (m_stcBlobLead.intDirection)
                {
                    case 4: //Top
                    case 8: //Bottom
                        m_stcBlobLead.fMinBaseWidth = Math.Max(0, Get2DXinMM(m_stcBlobLead.fBaseWidth) - 0.030f);//m_fMMToPixelXValue
                        m_stcBlobLead.fMaxBaseWidth = Get2DXinMM(m_stcBlobLead.fBaseWidth) + 0.030f;//m_fMMToPixelXValue

                        m_stcBlobLead.fMinBaseLength = Math.Max(0, Get2DYinMM(m_stcBlobLead.fBaseLength) - 0.030f);//m_fMMToPixelXValue
                        m_stcBlobLead.fMaxBaseLength = Get2DYinMM(m_stcBlobLead.fBaseLength) + 0.030f;//m_fMMToPixelXValue

                        m_stcBlobLead.fMinTipWidth = Math.Max(0, Get2DXinMM(m_stcBlobLead.fTipWidth) - 0.030f);//m_fMMToPixelXValue
                        m_stcBlobLead.fMaxTipWidth = Get2DXinMM(m_stcBlobLead.fTipWidth) + 0.030f;//m_fMMToPixelXValue

                        m_stcBlobLead.fMinTipLength = Math.Max(0, Get2DYinMM(m_stcBlobLead.fTipLength) - 0.030f);//m_fMMToPixelXValue
                        m_stcBlobLead.fMaxTipLength = Get2DYinMM(m_stcBlobLead.fTipLength) + 0.030f;//m_fMMToPixelXValue
                        break;
                    case 1: //Left
                    case 2: //Right
                        m_stcBlobLead.fMinBaseWidth = Math.Max(0, Get2DYinMM(m_stcBlobLead.fBaseWidth) - 0.030f);//m_fMMToPixelXValue
                        m_stcBlobLead.fMaxBaseWidth = Get2DYinMM(m_stcBlobLead.fBaseWidth) + 0.030f;//m_fMMToPixelXValue

                        m_stcBlobLead.fMinBaseLength = Math.Max(0, Get2DXinMM(m_stcBlobLead.fBaseLength) - 0.030f);//m_fMMToPixelXValue
                        m_stcBlobLead.fMaxBaseLength = Get2DXinMM(m_stcBlobLead.fBaseLength) + 0.030f;//m_fMMToPixelXValue

                        m_stcBlobLead.fMinTipWidth = Math.Max(0, Get2DYinMM(m_stcBlobLead.fTipWidth) - 0.030f);//m_fMMToPixelXValue
                        m_stcBlobLead.fMaxTipWidth = Get2DYinMM(m_stcBlobLead.fTipWidth) + 0.030f;//m_fMMToPixelXValue

                        m_stcBlobLead.fMinTipLength = Math.Max(0, Get2DXinMM(m_stcBlobLead.fTipLength) - 0.030f);//m_fMMToPixelXValue
                        m_stcBlobLead.fMaxTipLength = Get2DXinMM(m_stcBlobLead.fTipLength) + 0.030f;//m_fMMToPixelXValue
                        break;
                }

                m_stcBlobLead.fMinPitch = 0;
                m_stcBlobLead.fMaxPitch = 1;
                m_stcBlobLead.fMinGap = 0;
                m_stcBlobLead.fMaxGap = 1;

                m_arrTemplateBlobLeads.RemoveAt(i);
                m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
            }
        }

        /// <summary>
        /// Define pitch gap
        /// </summary>
        /// <param name="intPitchGapIndex">pitch gap index</param>
        /// <param name="intFromLeadNo">from Lead no</param>
        /// <param name="intToLeadNo">to Lead no</param>
        private bool DefinePitchGap(int intPitchGapIndex, int intFromLeadNo, int intToLeadNo)
        {
            if ((intFromLeadNo < m_arrTemplateBlobLeads.Count) && (intToLeadNo < m_arrTemplateBlobLeads.Count))
            {
                int intDrawPoint;
                bool blnUpDownFound = false;
                bool blnLeftRightFound = false;
                BlobsFeatures stcFromBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobLeads[intFromLeadNo];
                BlobsFeatures stcToBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobLeads[intToLeadNo];

                if (stcFromBlobsFeatures.intDirection != stcToBlobsFeatures.intDirection)
                    return false;

                int intStartX_From = 0, intStartY_From = 0, intEndX_From = 0, intEndY_From = 0;
                int intStartX_To = 0, intStartY_To = 0, intEndX_To = 0, intEndY_To = 0;

                switch (stcFromBlobsFeatures.intDirection)
                {
                    case 4: //Top
                        intStartX_From = (int)(stcFromBlobsFeatures.fTipCenterX - stcFromBlobsFeatures.fTipWidth / 2);

                        intEndX_From = (int)(stcFromBlobsFeatures.fTipCenterX + stcFromBlobsFeatures.fTipWidth / 2);

                        intStartY_From = (int)(stcFromBlobsFeatures.fTipCenterY);

                        intEndY_From = (int)(stcFromBlobsFeatures.fTipCenterY + stcFromBlobsFeatures.fTipLength);
                        break;
                    case 2: //Right
                        intStartX_From = (int)(stcFromBlobsFeatures.fTipCenterX - stcFromBlobsFeatures.fTipLength);

                        intEndX_From = (int)(stcFromBlobsFeatures.fTipCenterX);

                        intStartY_From = (int)(stcFromBlobsFeatures.fTipCenterY - stcFromBlobsFeatures.fTipWidth / 2);

                        intEndY_From = (int)(stcFromBlobsFeatures.fTipCenterY + stcFromBlobsFeatures.fTipWidth / 2);
                        break;
                    case 8: //Bottom
                        intStartX_From = (int)(stcFromBlobsFeatures.fTipCenterX - stcFromBlobsFeatures.fTipWidth / 2);

                        intEndX_From = (int)(stcFromBlobsFeatures.fTipCenterX + stcFromBlobsFeatures.fTipWidth / 2);

                        intStartY_From = (int)(stcFromBlobsFeatures.fTipCenterY - stcFromBlobsFeatures.fTipLength);

                        intEndY_From = (int)(stcFromBlobsFeatures.fTipCenterY);
                        break;
                    case 1: //Left
                        intStartX_From = (int)(stcFromBlobsFeatures.fTipCenterX);

                        intEndX_From = (int)(stcFromBlobsFeatures.fTipCenterX + stcFromBlobsFeatures.fTipLength);

                        intStartY_From = (int)(stcFromBlobsFeatures.fTipCenterY - stcFromBlobsFeatures.fTipWidth / 2);

                        intEndY_From = (int)(stcFromBlobsFeatures.fTipCenterY + stcFromBlobsFeatures.fTipWidth / 2);
                        break;
                }

                switch (stcToBlobsFeatures.intDirection)
                {
                    case 4: //Top
                        intStartX_To = (int)(stcToBlobsFeatures.fTipCenterX - stcToBlobsFeatures.fTipWidth / 2);

                        intEndX_To = (int)(stcToBlobsFeatures.fTipCenterX + stcToBlobsFeatures.fTipWidth / 2);

                        intStartY_To = (int)(stcToBlobsFeatures.fTipCenterY);

                        intEndY_To = (int)(stcToBlobsFeatures.fTipCenterY + stcToBlobsFeatures.fTipLength);
                        break;
                    case 2: //Right
                        intStartX_To = (int)(stcToBlobsFeatures.fTipCenterX - stcToBlobsFeatures.fTipLength);

                        intEndX_To = (int)(stcToBlobsFeatures.fTipCenterX);

                        intStartY_To = (int)(stcToBlobsFeatures.fTipCenterY - stcToBlobsFeatures.fTipWidth / 2);

                        intEndY_To = (int)(stcToBlobsFeatures.fTipCenterY + stcToBlobsFeatures.fTipWidth / 2);
                        break;
                    case 8: //Bottom
                        intStartX_To = (int)(stcToBlobsFeatures.fTipCenterX - stcToBlobsFeatures.fTipWidth / 2);

                        intEndX_To = (int)(stcToBlobsFeatures.fTipCenterX + stcToBlobsFeatures.fTipWidth / 2);

                        intStartY_To = (int)(stcToBlobsFeatures.fTipCenterY - stcToBlobsFeatures.fTipLength);

                        intEndY_To = (int)(stcToBlobsFeatures.fTipCenterY);
                        break;
                    case 1: //Left
                        intStartX_To = (int)(stcToBlobsFeatures.fTipCenterX);

                        intEndX_To = (int)(stcToBlobsFeatures.fTipCenterX + stcToBlobsFeatures.fTipLength);

                        intStartY_To = (int)(stcToBlobsFeatures.fTipCenterY - stcToBlobsFeatures.fTipWidth / 2);

                        intEndY_To = (int)(stcToBlobsFeatures.fTipCenterY + stcToBlobsFeatures.fTipWidth / 2);
                        break;
                }

                // Check pitch available between up and down Leads
                if ((intStartX_From >= intStartX_To) && (intStartX_From <= intEndX_To) ||
                    (intEndX_From >= intStartX_To) && (intEndX_From <= intEndX_To) ||
                    (intStartX_To >= intStartX_From) && (intEndX_To <= intEndX_From) ||
                    (intEndX_To >= intStartX_From) && (intEndX_To <= intEndX_From))
                {
                    blnUpDownFound = true;
                }

                // Check pitch available between left and right Leads
                if ((intStartY_From >= intStartY_To) && (intStartY_From <= intEndY_To) ||
                    (intEndY_From >= intStartY_To) && (intEndY_From <= intEndY_To) ||
                    (intStartY_To >= intStartY_From) && (intEndY_To <= intEndY_From) ||
                    (intEndY_To >= intStartY_From) && (intEndY_To <= intEndY_From))
                {
                    blnLeftRightFound = true;
                }

                // Pitch only available in up down or left right only
                if ((blnLeftRightFound && !blnUpDownFound) || (!blnLeftRightFound && blnUpDownFound))
                {
                    if (blnUpDownFound)
                    {
                        // Pitch only available if distance gap between Leads > 1 pixel
                        if ((intStartY_To - intEndY_From) > 1)
                        {
                            intDrawPoint = GetDrawPoint(intStartX_From, intEndX_From, intStartX_To, intEndX_To);
                            m_stcPitchGap.intStartPointX = intDrawPoint;
                            m_stcPitchGap.intEndPointX = intDrawPoint;
                            m_stcPitchGap.intStartPointY = intEndY_From;
                            m_stcPitchGap.intEndPointY = intStartY_To;
                            m_stcPitchGap.fGap = intStartY_To - intEndY_From;
                            m_stcPitchGap.fPitch = stcToBlobsFeatures.fTipCenterY - stcFromBlobsFeatures.fTipCenterY;
                            m_stcPitchGap.intDirection = 180;
                            //DefinePitchGapTolerance();
                            UpdatePreviousPitchToleranceToTemplate(intPitchGapIndex);//UpdatePreviousPitchToleranceToTemplate(); // 2021-06-02 ZJYEOH : Assign previous tolerance according to intPitchGapIndex
                            return true;
                        }
                        else if ((intStartY_From - intEndY_To) > 1)
                        {
                            intDrawPoint = GetDrawPoint(intStartX_From, intEndX_From, intStartX_To, intEndX_To);
                            m_stcPitchGap.intStartPointX = intDrawPoint;
                            m_stcPitchGap.intEndPointX = intDrawPoint;
                            m_stcPitchGap.intStartPointY = intStartY_From;
                            m_stcPitchGap.intEndPointY = intEndY_To;
                            m_stcPitchGap.fGap = intStartY_From - intEndY_To;
                            m_stcPitchGap.fPitch = stcFromBlobsFeatures.fTipCenterY - stcToBlobsFeatures.fTipCenterY;
                            m_stcPitchGap.intDirection = 0;
                            //DefinePitchGapTolerance();
                            UpdatePreviousPitchToleranceToTemplate(intPitchGapIndex);//UpdatePreviousPitchToleranceToTemplate(); // 2021-06-02 ZJYEOH : Assign previous tolerance according to intPitchGapIndex
                            return true;
                        }
                        else
                        {
                            return false;
                        }
                    }
                    else
                    {
                        // Pitch only available if distance gap between Leads > 1 pixel
                        if ((intStartX_To - intEndX_From) > 1)
                        {
                            intDrawPoint = GetDrawPoint(intStartY_From, intEndY_From, intStartY_To, intEndY_To);
                            m_stcPitchGap.intStartPointX = intEndX_From;
                            m_stcPitchGap.intEndPointX = intStartX_To;
                            m_stcPitchGap.intStartPointY = intDrawPoint;
                            m_stcPitchGap.intEndPointY = intDrawPoint;
                            m_stcPitchGap.fGap = intStartX_To - intEndX_From;
                            m_stcPitchGap.fPitch = stcToBlobsFeatures.fTipCenterX - stcFromBlobsFeatures.fTipCenterX;
                            m_stcPitchGap.intDirection = 90;
                            //DefinePitchGapTolerance();
                            UpdatePreviousPitchToleranceToTemplate(intPitchGapIndex);//UpdatePreviousPitchToleranceToTemplate(); // 2021-06-02 ZJYEOH : Assign previous tolerance according to intPitchGapIndex
                            return true;
                        }
                        else if ((intStartX_From - intEndX_To) > 1)
                        {
                            intDrawPoint = GetDrawPoint(intStartY_From, intEndY_From, intStartY_To, intEndY_To);
                            m_stcPitchGap.intStartPointX = intStartX_From;
                            m_stcPitchGap.intEndPointX = intEndX_To;
                            m_stcPitchGap.intStartPointY = intDrawPoint;
                            m_stcPitchGap.intEndPointY = intDrawPoint;
                            m_stcPitchGap.fGap = intStartX_From - intEndX_To;
                            m_stcPitchGap.fPitch = stcFromBlobsFeatures.fTipCenterX - stcToBlobsFeatures.fTipCenterX;
                            //DefinePitchGapTolerance();
                            UpdatePreviousPitchToleranceToTemplate(intPitchGapIndex);//UpdatePreviousPitchToleranceToTemplate(); // 2021-06-02 ZJYEOH : Assign previous tolerance according to intPitchGapIndex
                            m_stcPitchGap.intDirection = 270;
                            return true;
                        }
                        else
                        {
                            return false;
                        }
                    }
                }
                else
                    return false;
            }
            return true;
        }

        /// <summary>
        /// Define default pitch gap tolerance
        /// </summary>
        private void DefinePitchGapTolerance()
        {
            if (m_stcPitchGap.intDirection == 0 || m_stcPitchGap.intDirection == 180)
            {
                m_stcPitchGap.fMinGap = Get2DYinMM(m_stcPitchGap.fGap - m_fDefaultPixelTolerance);//m_fMMToPixelXValue
                m_stcPitchGap.fMaxGap = Get2DYinMM(m_stcPitchGap.fGap + m_fDefaultPixelTolerance);//m_fMMToPixelXValue
                m_stcPitchGap.fMinPitch = Get2DYinMM(m_stcPitchGap.fPitch - m_fDefaultPixelTolerance);//m_fMMToPixelXValue
                m_stcPitchGap.fMaxPitch = Get2DYinMM(m_stcPitchGap.fPitch + m_fDefaultPixelTolerance);//m_fMMToPixelXValue
            }
            else
            {
                m_stcPitchGap.fMinGap = Get2DXinMM(m_stcPitchGap.fGap - m_fDefaultPixelTolerance);//m_fMMToPixelXValue
                m_stcPitchGap.fMaxGap = Get2DXinMM(m_stcPitchGap.fGap + m_fDefaultPixelTolerance);//m_fMMToPixelXValue
                m_stcPitchGap.fMinPitch = Get2DXinMM(m_stcPitchGap.fPitch - m_fDefaultPixelTolerance);//m_fMMToPixelXValue
                m_stcPitchGap.fMaxPitch = Get2DXinMM(m_stcPitchGap.fPitch + m_fDefaultPixelTolerance);//m_fMMToPixelXValue
            }
        }

        private void InitLeadInspectionData(ROI objROI, int intNumSelectedObject)
        {
            m_intTemplateMatchStatus = new int[m_arrTemplateBlobLeads.Count];
            m_intSampleMatchNumber = new int[intNumSelectedObject];
            m_fSampleLeadRangeStartX = objROI.ref_ROIWidth;
            m_fSampleLeadRangeStartY = objROI.ref_ROIHeight;
            m_fSampleLeadRangeEndX = 0;
            m_fSampleLeadRangeEndY = 0;
            m_fSampleReferencePointStartX = objROI.ref_ROIWidth;
            m_fSampleReferencePointStartY = objROI.ref_ROIHeight;
            m_fSampleReferencePointEndX = 0;
            m_fSampleReferencePointEndY = 0;
            m_fSampleLeadMinSpanStart = -999;
            m_fSampleLeadMaxSpanStart = -999;
            m_fSampleLeadMinSpanEnd = -999;
            m_fSampleLeadMaxSpanEnd = -999;

            for (int k = 0; k < intNumSelectedObject; k++)
            {
                m_intSampleMatchNumber[k] = -1;
            }

            for (int i = 0; i < m_arrSampleBlobLeads.Length; i++)
            {
                m_arrSampleBlobLeads[i].fSkew = -999;
                m_arrSampleBlobLeads[i].fOffSet = -999;
                m_arrSampleBlobLeads[i].fArea = -999;
                m_arrSampleBlobLeads[i].fWidth = -999;
                m_arrSampleBlobLeads[i].fHeight = -999;
                m_arrSampleBlobLeads[i].fPitch = -999;
                m_arrSampleBlobLeads[i].fGap = -999;
                m_arrSampleBlobLeads[i].intFailMask = 0;
                m_arrSampleBlobLeads[i].fStartX = -999;
                m_arrSampleBlobLeads[i].fStartY = -999;
                m_arrSampleBlobLeads[i].fEndX = -999;
                m_arrSampleBlobLeads[i].fEndY = -999;
                m_arrSampleBlobLeads[i].fCenterX = -999;
                m_arrSampleBlobLeads[i].fCenterY = -999;
                m_arrSampleBlobLeads[i].intContourIndex = -1;

                m_arrSampleBlobLeads[i].fSkewMM = -999;
                m_arrSampleBlobLeads[i].fOffSetMM = -999;
                m_arrSampleBlobLeads[i].fAreaMM = -999;
                m_arrSampleBlobLeads[i].fWidthMM = -999;
                m_arrSampleBlobLeads[i].fHeightMM = -999;
                m_arrSampleBlobLeads[i].fBaseWidthMM = -999;
                m_arrSampleBlobLeads[i].fBaseLengthMM = -999;
                m_arrSampleBlobLeads[i].fTipWidthMM = -999;
                m_arrSampleBlobLeads[i].fTipLengthMM = -999;
                m_arrSampleBlobLeads[i].fPitchMM = -999;
                m_arrSampleBlobLeads[i].fGapMM = -999;

                m_arrSampleBlobLeads[i].fBaseCenterX = -999;
                m_arrSampleBlobLeads[i].fBaseCenterY = -999;
                m_arrSampleBlobLeads[i].fTipCenterX = -999;
                m_arrSampleBlobLeads[i].fTipCenterY = -999;
                m_arrSampleBlobLeads[i].fTipMaxX = -999;
                m_arrSampleBlobLeads[i].fTipMaxY = -999;
                m_arrSampleBlobLeads[i].fBaseWidth = -999;
                m_arrSampleBlobLeads[i].fBaseLength = -999;
                m_arrSampleBlobLeads[i].fTipWidth = -999;
                m_arrSampleBlobLeads[i].fTipLength = -999;
            }
        }

        private void InitLeadInspectionData_Lead3D(ROI objROI)
        {
            m_intTemplateMatchStatus = new int[m_arrTemplateBlobLeads.Count];
            m_fSampleLeadRangeStartX = objROI.ref_ROIWidth;
            m_fSampleLeadRangeStartY = objROI.ref_ROIHeight;
            m_fSampleLeadRangeEndX = 0;
            m_fSampleLeadRangeEndY = 0;
            m_fSampleReferencePointStartX = objROI.ref_ROIWidth;
            m_fSampleReferencePointStartY = objROI.ref_ROIHeight;
            m_fSampleReferencePointEndX = 0;
            m_fSampleReferencePointEndY = 0;

            for (int i = 0; i < m_arrSampleBlobLeads.Length; i++)
            {
                m_arrSampleBlobLeads[i].fSkew = -999;
                m_arrSampleBlobLeads[i].fOffSet = -999;
                m_arrSampleBlobLeads[i].fArea = -999;
                m_arrSampleBlobLeads[i].fWidth = -999;
                m_arrSampleBlobLeads[i].fHeight = -999;
                m_arrSampleBlobLeads[i].fPitch = -999;
                m_arrSampleBlobLeads[i].fGap = -999;
                m_arrSampleBlobLeads[i].intFailMask = 0;
                m_arrSampleBlobLeads[i].fStartX = -999;
                m_arrSampleBlobLeads[i].fStartY = -999;
                m_arrSampleBlobLeads[i].fEndX = -999;
                m_arrSampleBlobLeads[i].fEndY = -999;
                m_arrSampleBlobLeads[i].fCenterX = -999;
                m_arrSampleBlobLeads[i].fCenterY = -999;
                m_arrSampleBlobLeads[i].intContourIndex = -1;

                m_arrSampleBlobLeads[i].fSkewMM = -999;
                m_arrSampleBlobLeads[i].fOffSetMM = -999;
                m_arrSampleBlobLeads[i].fAreaMM = -999;
                m_arrSampleBlobLeads[i].fWidthMM = -999;
                m_arrSampleBlobLeads[i].fHeightMM = -999;
                m_arrSampleBlobLeads[i].fPitchMM = -999;
                m_arrSampleBlobLeads[i].fGapMM = -999;
                //m_arrSampleBlobLeads[i].fBaseWidthMM = -999;
                //m_arrSampleBlobLeads[i].fBaseLengthMM = -999;
                //m_arrSampleBlobLeads[i].fTipWidthMM = -999;
                //m_arrSampleBlobLeads[i].fTipLengthMM = -999;
                m_arrSampleBlobLeads[i].fBaseWidthMM = -999;
                m_arrSampleBlobLeads[i].fBaseLengthMM = -999;
                m_arrSampleBlobLeads[i].fTipWidthMM = -999;
                m_arrSampleBlobLeads[i].fTipLengthMM = -999;
                m_arrSampleBlobLeads[i].fStandOffMM = -999;
                m_arrSampleBlobLeads[i].fCoplanMM = -999;
                m_arrSampleBlobLeads[i].fSolderPadLengthMM = -999;


                m_arrSampleBlobLeads[i].fBaseCenterX = -999;
                m_arrSampleBlobLeads[i].fBaseCenterY = -999;
                m_arrSampleBlobLeads[i].fTipCenterX = -999;
                m_arrSampleBlobLeads[i].fTipCenterY = -999;
                m_arrSampleBlobLeads[i].fTipMaxX = -999;
                m_arrSampleBlobLeads[i].fTipMaxY = -999;
                m_arrSampleBlobLeads[i].fBaseWidth = -999;
                m_arrSampleBlobLeads[i].fBaseLength = -999;
                m_arrSampleBlobLeads[i].fTipWidth = -999;
                m_arrSampleBlobLeads[i].fTipLength = -999;

                m_arrSampleBlobLeads[i].fAGV = -999;
                m_arrSampleBlobLeads[i].fLeadMinWidthMM = -999;
                m_arrSampleBlobLeads[i].fLeadMaxWidthMM = -999;
                m_arrSampleBlobLeads[i].fLeadBurrWidthMM = -999;

                m_arrSampleBlobLeads[i].fLeadMinWidth = -999;
                m_arrSampleBlobLeads[i].fLeadMaxWidth = -999;
                m_arrSampleBlobLeads[i].fLeadBurrWidth = -999;
            }
        
        }

        /// <summary>
        /// Undo selected object or deselect m_arrTemplateBlobLeads object
        /// </summary>
        public void UndoSelectedObject()
        {
            UndoSelectedObject(m_arrTemplateBlobLeads);
        }

        /// <summary>
        /// Undo selected object or deselect object
        /// </summary>
        /// <param name="arrBlobsFeatures">blobs features</param>
        public void UndoSelectedObject(ArrayList arrBlobsFeatures)
        {
            for (int i = 0; i < arrBlobsFeatures.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)arrBlobsFeatures[i];
                m_stcBlobLead.blnSelected = false;
                arrBlobsFeatures.RemoveAt(i);
                arrBlobsFeatures.Insert(i, m_stcBlobLead);
            }
        }

        /// <summary>
        /// Update previous tolerance to current template
        /// </summary>
        public void UpdatePreviousToleranceToTemplate()
        {
            // check is count tally? if tally, then read template index by sequence. If no tally, then then look for closest area blobs first.
            bool blnTally = m_arrBackupTemplateBlobLeads.Count == GetSelectedObjectNumber();

            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                if (!((BlobsFeatures)m_arrTemplateBlobLeads[i]).blnSelected)
                    continue;

                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                int intSelectedIndex;
                if (blnTally)
                {
                    intSelectedIndex = i;
                }
                else
                {
                    //Loop to look for tolerance setting that have previous blob learn area closest to current blob learn area.
                    intSelectedIndex = -1;
                    float fDiffSmallestArea = float.MaxValue;
                    for (int j = 0; j < m_arrBackupTemplateBlobLeads.Count; j++)  // Loop previous blobs tolerance list
                    {
                        m_stcBackupTemplateBlobLead = (ToleranceBlobsFeatures)m_arrBackupTemplateBlobLeads[j];

                        // Get smallest different area between current and previous learn blob area.
                        if (Math.Abs(m_stcBlobLead.fArea - m_stcBackupTemplateBlobLead.fLearnArea) < fDiffSmallestArea)
                        {
                            fDiffSmallestArea = Math.Abs(m_stcBlobLead.fArea - m_stcBackupTemplateBlobLead.fLearnArea);
                            intSelectedIndex = j;
                        }
                    }
                }

                if (intSelectedIndex >= 0)  // If found the closest area blob
                {
                    // Copy the previous tolerance setting into current learn blob tolerance setting
                    m_stcBackupTemplateBlobLead = (ToleranceBlobsFeatures)m_arrBackupTemplateBlobLeads[intSelectedIndex];

                    m_stcBlobLead.blnCheckSkew = m_stcBackupTemplateBlobLead.blnCheckSkew;
                    m_stcBlobLead.fSkew = m_stcBackupTemplateBlobLead.fSkew;
                    m_stcBlobLead.fOffSet = m_stcBackupTemplateBlobLead.fOffSet;

                    m_stcBlobLead.fMinBaseWidth = m_stcBackupTemplateBlobLead.fMinBaseWidth;
                    m_stcBlobLead.fMaxBaseWidth = m_stcBackupTemplateBlobLead.fMaxBaseWidth;
                    m_stcBlobLead.fMinBaseLength = m_stcBackupTemplateBlobLead.fMinBaseLength;
                    m_stcBlobLead.fMaxBaseLength = m_stcBackupTemplateBlobLead.fMaxBaseLength;

                    m_stcBlobLead.fMinTipWidth = m_stcBackupTemplateBlobLead.fMinTipWidth;
                    m_stcBlobLead.fMaxTipWidth = m_stcBackupTemplateBlobLead.fMaxTipWidth;
                    m_stcBlobLead.fMinTipLength = m_stcBackupTemplateBlobLead.fMinTipLength;
                    m_stcBlobLead.fMaxTipLength = m_stcBackupTemplateBlobLead.fMaxTipLength;

                    m_stcBlobLead.fMinPitch = m_stcBackupTemplateBlobLead.fMinPitch;
                    m_stcBlobLead.fMaxPitch = m_stcBackupTemplateBlobLead.fMaxPitch;
                    m_stcBlobLead.fMinGap = m_stcBackupTemplateBlobLead.fMinGap;
                    m_stcBlobLead.fMaxGap = m_stcBackupTemplateBlobLead.fMaxGap;

                    m_stcBlobLead.fMinStandOff = m_stcBackupTemplateBlobLead.fMinStandOff;
                    m_stcBlobLead.fMaxStandOff = m_stcBackupTemplateBlobLead.fMaxStandOff;

                    m_stcBlobLead.fMinSolderPadLength = m_stcBackupTemplateBlobLead.fMinSolderPadLength;
                    m_stcBlobLead.fMaxSolderPadLength = m_stcBackupTemplateBlobLead.fMaxSolderPadLength;

                    m_stcBlobLead.fMaxCoplan = m_stcBackupTemplateBlobLead.fMaxCoplan;

                    m_stcBlobLead.fMinAGV = m_stcBackupTemplateBlobLead.fMinAGV;
                    m_stcBlobLead.fMaxAGV = m_stcBackupTemplateBlobLead.fMaxAGV;

                    m_stcBlobLead.intAGVROITolerance_Top = m_stcBackupTemplateBlobLead.intAGVROITolerance_Top;
                    m_stcBlobLead.intAGVROITolerance_Right = m_stcBackupTemplateBlobLead.intAGVROITolerance_Right;
                    m_stcBlobLead.intAGVROITolerance_Bottom = m_stcBackupTemplateBlobLead.intAGVROITolerance_Bottom;
                    m_stcBlobLead.intAGVROITolerance_Left = m_stcBackupTemplateBlobLead.intAGVROITolerance_Left;

                    m_stcBlobLead.fLeadLimitMinWidth = m_stcBackupTemplateBlobLead.fLeadLimitMinWidth;
                    m_stcBlobLead.fLeadLimitMaxWidth = m_stcBackupTemplateBlobLead.fLeadLimitMaxWidth;
                    m_stcBlobLead.fLeadMaxBurrWidth = m_stcBackupTemplateBlobLead.fLeadMaxBurrWidth;

                    m_stcBlobLead.fWidthOffset = m_stcBackupTemplateBlobLead.fWidthOffset;
                    m_stcBlobLead.fLengthOffset = m_stcBackupTemplateBlobLead.fLengthOffset;
                    m_stcBlobLead.fPitchOffset = m_stcBackupTemplateBlobLead.fPitchOffset;
                    m_stcBlobLead.fGapOffset = m_stcBackupTemplateBlobLead.fGapOffset;
                    m_stcBlobLead.fStandOffOffset = m_stcBackupTemplateBlobLead.fStandOffOffset;
                    m_stcBlobLead.fCoplanOffset = m_stcBackupTemplateBlobLead.fCoplanOffset;

                }

                m_arrTemplateBlobLeads.RemoveAt(i);
                m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
            }
        }
        public void SetPreviousToleranceToTemplate()
        {
           
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                if (!((BlobsFeatures)m_arrTemplateBlobLeads[i]).blnSelected)
                    continue;

                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                
                if (i >= 0)  // If found the closest area blob
                {
                    // Copy the previous tolerance setting into current learn blob tolerance setting
                    m_stcBackupTemplateBlobLead = (ToleranceBlobsFeatures)m_arrBackupTemplateBlobLeads[i];

                    m_stcBlobLead.blnCheckSkew = m_stcBackupTemplateBlobLead.blnCheckSkew;
                    m_stcBlobLead.fSkew = m_stcBackupTemplateBlobLead.fSkew;
                    m_stcBlobLead.fOffSet = m_stcBackupTemplateBlobLead.fOffSet;

                    m_stcBlobLead.fMinBaseWidth = m_stcBackupTemplateBlobLead.fMinBaseWidth;
                    m_stcBlobLead.fMaxBaseWidth = m_stcBackupTemplateBlobLead.fMaxBaseWidth;
                    m_stcBlobLead.fMinBaseLength = m_stcBackupTemplateBlobLead.fMinBaseLength;
                    m_stcBlobLead.fMaxBaseLength = m_stcBackupTemplateBlobLead.fMaxBaseLength;

                    m_stcBlobLead.fMinTipWidth = m_stcBackupTemplateBlobLead.fMinTipWidth;
                    m_stcBlobLead.fMaxTipWidth = m_stcBackupTemplateBlobLead.fMaxTipWidth;
                    m_stcBlobLead.fMinTipLength = m_stcBackupTemplateBlobLead.fMinTipLength;
                    m_stcBlobLead.fMaxTipLength = m_stcBackupTemplateBlobLead.fMaxTipLength;

                    m_stcBlobLead.fMinPitch = m_stcBackupTemplateBlobLead.fMinPitch;
                    m_stcBlobLead.fMaxPitch = m_stcBackupTemplateBlobLead.fMaxPitch;
                    m_stcBlobLead.fMinGap = m_stcBackupTemplateBlobLead.fMinGap;
                    m_stcBlobLead.fMaxGap = m_stcBackupTemplateBlobLead.fMaxGap;

                    m_stcBlobLead.fMinStandOff = m_stcBackupTemplateBlobLead.fMinStandOff;
                    m_stcBlobLead.fMaxStandOff = m_stcBackupTemplateBlobLead.fMaxStandOff;

                    m_stcBlobLead.fMinSolderPadLength = m_stcBackupTemplateBlobLead.fMinSolderPadLength;
                    m_stcBlobLead.fMaxSolderPadLength = m_stcBackupTemplateBlobLead.fMaxSolderPadLength;

                    m_stcBlobLead.fMaxCoplan = m_stcBackupTemplateBlobLead.fMaxCoplan;

                    m_stcBlobLead.fMinAGV = m_stcBackupTemplateBlobLead.fMinAGV;
                    m_stcBlobLead.fMaxAGV = m_stcBackupTemplateBlobLead.fMaxAGV;

                    m_stcBlobLead.intAGVROITolerance_Top = m_stcBackupTemplateBlobLead.intAGVROITolerance_Top;
                    m_stcBlobLead.intAGVROITolerance_Right = m_stcBackupTemplateBlobLead.intAGVROITolerance_Right;
                    m_stcBlobLead.intAGVROITolerance_Bottom = m_stcBackupTemplateBlobLead.intAGVROITolerance_Bottom;
                    m_stcBlobLead.intAGVROITolerance_Left = m_stcBackupTemplateBlobLead.intAGVROITolerance_Left;

                    m_stcBlobLead.fLeadLimitMinWidth = m_stcBackupTemplateBlobLead.fLeadLimitMinWidth;
                    m_stcBlobLead.fLeadLimitMaxWidth = m_stcBackupTemplateBlobLead.fLeadLimitMaxWidth;
                    m_stcBlobLead.fLeadMaxBurrWidth = m_stcBackupTemplateBlobLead.fLeadMaxBurrWidth;

                    m_stcBlobLead.fWidthOffset = m_stcBackupTemplateBlobLead.fWidthOffset;
                    m_stcBlobLead.fLengthOffset = m_stcBackupTemplateBlobLead.fLengthOffset;
                    m_stcBlobLead.fPitchOffset = m_stcBackupTemplateBlobLead.fPitchOffset;
                    m_stcBlobLead.fGapOffset = m_stcBackupTemplateBlobLead.fGapOffset;
                    m_stcBlobLead.fStandOffOffset = m_stcBackupTemplateBlobLead.fStandOffOffset;
                    m_stcBlobLead.fCoplanOffset = m_stcBackupTemplateBlobLead.fCoplanOffset;

                }

                m_arrTemplateBlobLeads.RemoveAt(i);
                m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
            }
        }
        /// <summary>
        /// Update previous pitch gap tolerance into current template
        /// </summary>
        /// <param name="intIndex">m_arrTolePitchGap index</param>
        private void UpdatePreviousPitchToleranceToTemplate()
        {
            PitchGap stcBackupPitchGap = new PitchGap();

            int intSelectedIndex = -1;
            float fDiffSmallestArea = float.MaxValue;
            for (int i = 0; i < m_arrBackupPitchGap.Count; i++)
            {
                stcBackupPitchGap = (PitchGap)m_arrBackupPitchGap[i];

                // Get smallest different pitch size between current and previous learn pitch size.
                if (Math.Abs(m_stcPitchGap.fPitch - ((PitchGap)stcBackupPitchGap).fPitch) < fDiffSmallestArea)
                {
                    fDiffSmallestArea = Math.Abs(m_stcPitchGap.fPitch - ((PitchGap)stcBackupPitchGap).fPitch);
                    intSelectedIndex = i;
                }

            }
            if (intSelectedIndex >= 0)
            {
                m_stcTolePitchGap = (TolerancePitchGap)m_arrTolePitchGap[intSelectedIndex];

                m_stcPitchGap.fMinGap = m_stcTolePitchGap.fMinGap;
                m_stcPitchGap.fMaxGap = m_stcTolePitchGap.fMaxGap;
                m_stcPitchGap.fMinPitch = m_stcTolePitchGap.fMinPitch;
                m_stcPitchGap.fMaxPitch = m_stcTolePitchGap.fMaxPitch;
            }
        }
        private void UpdatePreviousPitchToleranceToTemplate(int intSelectedIndex)
        {
            if (intSelectedIndex >= 0 && intSelectedIndex < m_arrTolePitchGap.Count)
            {
                m_stcTolePitchGap = (TolerancePitchGap)m_arrTolePitchGap[intSelectedIndex];

                m_stcPitchGap.fMinGap = m_stcTolePitchGap.fMinGap;
                m_stcPitchGap.fMaxGap = m_stcTolePitchGap.fMaxGap;
                m_stcPitchGap.fMinPitch = m_stcTolePitchGap.fMinPitch;
                m_stcPitchGap.fMaxPitch = m_stcTolePitchGap.fMaxPitch;
            }
        }

        /// <summary>
        /// Update data(mm) in blobs features
        /// </summary>
        /// <param name="intSelectedIndex">blobs feature index</param>
        /// <param name="fSkew">Skew</param>
        /// <param name="fOffSet">offset</param>
        /// <param name="fMinArea">min area</param>
        /// <param name="fMaxArea">max area</param>
        /// <param name="fMinWidth">min width</param>
        /// <param name="fMaxWidth">max width</param>
        /// <param name="fMinHeight">min height</param>
        /// <param name="fMaxHeight">max height</param>
        /// <param name="fMinPitch">min pitch</param>
        /// <param name="fMaxPitch">max pitch</param>
        /// <param name="fMinGap">min gap</param>
        /// <param name="fMaxGap">max gap</param>
        /// <param name="fMaxBroken">max hole</param>
        public void UpdateBlobFeatureToPixel(int intSelectedIndex, float fOffSet, float fSkew,
            float fMinTipWidth, float fMaxTipWidth, float fMinTipLength, float fMaxTipLength,
            float fMinPitch, float fMaxPitch, float fMinGap, float fMaxGap, float fMinStandOff, float fMaxStandOff,
            float fMinSolderPadLength, float fMaxSolderPadLength, float fMaxCoplan, float fMinAGV, float fMaxAGV,
            float fLimitMinWidth, float fLimitMaxWidth, float fMaxBurrWidth)//,
            //float fWidthOffset, float fLengthOffset, float fPitchOffset, float fGapOffset, float fStandOffOffset, float fCoplanOffset)
        {
            if (!GetLeadArrayIndexFromNoID(intSelectedIndex, ref intSelectedIndex))
                return;

            m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[intSelectedIndex];

            if (fSkew != -999)
                m_stcBlobLead.fSkew = fSkew / m_fMMToUnitValue;

            m_stcBlobLead.fOffSet = fOffSet / m_fMMToUnitValue;

            m_stcBlobLead.fMinTipWidth = fMinTipWidth / m_fMMToUnitValue;
            m_stcBlobLead.fMaxTipWidth = fMaxTipWidth / m_fMMToUnitValue;
            m_stcBlobLead.fMinTipLength = fMinTipLength / m_fMMToUnitValue;
            m_stcBlobLead.fMaxTipLength = fMaxTipLength / m_fMMToUnitValue;

            m_stcBlobLead.fMinPitch = fMinPitch / m_fMMToUnitValue;
            m_stcBlobLead.fMaxPitch = fMaxPitch / m_fMMToUnitValue;
            m_stcBlobLead.fMinGap = fMinGap / m_fMMToUnitValue;
            m_stcBlobLead.fMaxGap = fMaxGap / m_fMMToUnitValue;

            m_stcBlobLead.fMinStandOff = fMinStandOff / m_fMMToUnitValue;
            m_stcBlobLead.fMaxStandOff = fMaxStandOff / m_fMMToUnitValue;

            m_stcBlobLead.fMinSolderPadLength = fMinSolderPadLength / m_fMMToUnitValue;
            m_stcBlobLead.fMaxSolderPadLength = fMaxSolderPadLength / m_fMMToUnitValue;

            m_stcBlobLead.fMaxCoplan = fMaxCoplan / m_fMMToUnitValue;

            m_stcBlobLead.fMinAGV = fMinAGV;
            m_stcBlobLead.fMaxAGV = fMaxAGV;

            m_stcBlobLead.fLeadLimitMinWidth = fLimitMinWidth;
            m_stcBlobLead.fLeadLimitMaxWidth = fLimitMaxWidth;
            m_stcBlobLead.fLeadMaxBurrWidth = fMaxBurrWidth;

            //m_stcBlobLead.fWidthOffset = fWidthOffset;
            //m_stcBlobLead.fLengthOffset = fLengthOffset;
            //m_stcBlobLead.fPitchOffset = fPitchOffset;
            //m_stcBlobLead.fGapOffset = fGapOffset;
            //m_stcBlobLead.fStandOffOffset = fStandOffOffset;
            //m_stcBlobLead.fCoplanOffset = fCoplanOffset;

            m_arrTemplateBlobLeads.RemoveAt(intSelectedIndex);
            m_arrTemplateBlobLeads.Insert(intSelectedIndex, m_stcBlobLead);
        }
        public void UpdateLeadOffsetSettingValueToPixel(int intSelectedIndex, float fWidthOffset, float fLengthOffset, float fPitchOffset, float fGapOffset, float fStandOffOffset, float fCoplanOffset)
        {
            if (!GetLeadArrayIndexFromNoID(intSelectedIndex, ref intSelectedIndex))
                return;

            m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[intSelectedIndex];

            m_stcBlobLead.fWidthOffset = fWidthOffset;
            m_stcBlobLead.fLengthOffset = fLengthOffset;
            m_stcBlobLead.fPitchOffset = fPitchOffset;
            m_stcBlobLead.fGapOffset = fGapOffset;
            m_stcBlobLead.fStandOffOffset = fStandOffOffset;
            m_stcBlobLead.fCoplanOffset = fCoplanOffset;

            m_arrTemplateBlobLeads.RemoveAt(intSelectedIndex);
            m_arrTemplateBlobLeads.Insert(intSelectedIndex, m_stcBlobLead);
        }
        public void UpdateLeadOffsetSettingValueToPixel(int intSelectedIndex, int intFeature, float fValue)
        {
            if (!GetLeadArrayIndexFromNoID(intSelectedIndex, ref intSelectedIndex))
                return;

            m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[intSelectedIndex];

            switch (intFeature)
            {
                case 0:
                    m_stcBlobLead.fWidthOffset = fValue;
                    break;
                case 1:
                    m_stcBlobLead.fLengthOffset = fValue;
                    break;
                case 2:
                    m_stcBlobLead.fPitchOffset = fValue;
                    break;
                case 3:
                    m_stcBlobLead.fGapOffset = fValue;
                    break;
                case 4:
                    m_stcBlobLead.fStandOffOffset = fValue;
                    break;
                case 5:
                    m_stcBlobLead.fCoplanOffset = fValue;
                    break;
            }

            m_arrTemplateBlobLeads.RemoveAt(intSelectedIndex);
            m_arrTemplateBlobLeads.Insert(intSelectedIndex, m_stcBlobLead);
        }
        public void UpdateBlobFeatureCheckSkew(int intSelectedIndex, bool blnCheckSkew)
        {
            if (!GetLeadArrayIndexFromNoID(intSelectedIndex, ref intSelectedIndex))
                return;

            m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[intSelectedIndex];

            m_stcBlobLead.blnCheckSkew = blnCheckSkew;
          
            m_arrTemplateBlobLeads.RemoveAt(intSelectedIndex);
            m_arrTemplateBlobLeads.Insert(intSelectedIndex, m_stcBlobLead);
        }
        ///// <summary>
        ///// Define Lead side - top, right, bottom, left
        ///// </summary>
        ///// <param name="intSideTolerance"></param>
        //public void DefineSideLead(int intSideTolerance)
        //{
        //    for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
        //    {
        //        m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

        //        m_stcBlobLead.intSide = 0;

        //        //Top side
        //        if ((m_stcBlobLead.fStartX - m_fLeadRangeStartX) <= intSideTolerance)
        //        {
        //            m_stcBlobLead.intSide |= 0x01;
        //        }
        //        //Right side
        //        if ((m_fLeadRangeEndX - m_stcBlobLead.fEndX) <= intSideTolerance)
        //        {
        //            m_stcBlobLead.intSide |= 0x02;
        //        }
        //        //Bottom side
        //        if ((m_stcBlobLead.fStartY - m_fLeadRangeStartY) <= intSideTolerance)
        //        {
        //            m_stcBlobLead.intSide |= 0x04;
        //        }
        //        //Left side
        //        if ((m_fLeadRangeEndY - m_stcBlobLead.fEndY) <= intSideTolerance)
        //        {
        //            m_stcBlobLead.intSide |= 0x08;
        //        }

        //        m_arrTemplateBlobLeads.RemoveAt(i);
        //        m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
        //    }
        //}

        ///// <summary>
        ///// Define template Lead contour
        ///// </summary>
        ///// <param name="objROI">ROI</param>
        //public void DefineTemplateLeadContour(ROI objROI)
        //{
        //    int intThresholdValue;
        //    if (m_intThresholdValue == -4)
        //        intThresholdValue = ROI.GetAutoThresholdValue(objROI, 3);
        //    else
        //        intThresholdValue = m_intThresholdValue;

        //    m_objTemplateContour.ClearContour();
        //    for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
        //    {
        //        m_objTemplateContour.BuildContour(objROI, ((BlobsFeatures)m_arrTemplateBlobLeads[i]).intContourX,
        //                                         ((BlobsFeatures)m_arrTemplateBlobLeads[i]).intContourY,
        //                                         intThresholdValue, m_objEBlobs.ref_intConnexity);
        //    }
        //}

        /// <summary>
        /// Define template Lead contour
        /// </summary>
        /// <param name="objROI">ROI</param>
        public void DefineTemplateLeadContour2(ROI objROI)
        {
            int intThresholdValue;
            if (m_intThresholdValue == -4)
                intThresholdValue = ROI.GetAutoThresholdValue(objROI, 3);
            else
                intThresholdValue = m_intThresholdValue;

            m_arrTemplateContour = new Contour[m_arrTemplateBlobLeads.Count];
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_arrTemplateContour[i] = new Contour();
                for (int j = 0; j < ((BlobsFeatures)m_arrTemplateBlobLeads[i]).arrContourX.Length; j++)
                {
                    m_arrTemplateContour[i].BuildContour(objROI, ((BlobsFeatures)m_arrTemplateBlobLeads[i]).arrContourX[j],
                                                     ((BlobsFeatures)m_arrTemplateBlobLeads[i]).arrContourY[j],
                                                     intThresholdValue, m_objEBlobs.ref_intConnexity);
                }
            }
        }

        /// <summary>
        /// Match sample objects with m_arrTemplateBlobLeads
        /// </summary>
        /// <param name="fStartX">start X position</param>
        /// <param name="fStartY">start Y position</param>
        /// <param name="fEndX">end X position</param>
        /// <param name="fEndY">end Y position</param>
        /// <param name="fCenterX">center X position</param>
        /// <param name="fCenterY">center Y position</param>
        /// <returns>m_arrTemplateBlobLeads object match index</returns>
        private List<int> MatchTemplateObjects(float fStartX, float fStartY, float fEndX, float fEndY, float fCenterX, float fCenterY)
        {
            /*
             * Template and sample Leads will easily match each other when intToleranceOffSet is high.
             * Template may match with wrong sample Leads when intToleranceOffSet is high. 
             */

            List<int> arrMatch = new List<int>();
            int intToleranceOffSet = 15;
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                // Check is sample gravity center point in template area or not
                if ((fCenterX >= m_stcBlobLead.intStartX - intToleranceOffSet) &&
                    (fCenterX <= m_stcBlobLead.intEndX + intToleranceOffSet) &&
                    (fCenterY >= m_stcBlobLead.intStartY - intToleranceOffSet) &&
                    (fCenterY <= m_stcBlobLead.intEndY + intToleranceOffSet))
                {
                    arrMatch.Add(i);
                }
                // Check is template gravity center point in sample area or not
                else if ((m_stcBlobLead.fCenterX >= fStartX - intToleranceOffSet) &&
                    (m_stcBlobLead.fCenterX <= fEndX + intToleranceOffSet) &&
                    (m_stcBlobLead.fCenterY >= fStartY - intToleranceOffSet) &&
                    (m_stcBlobLead.fCenterY <= fEndY + intToleranceOffSet))
                {
                    arrMatch.Add(i);
                }
            }

            return arrMatch;
        }

        private int MatchTemplateObjects_BasedOnPositionAndSize(float fStartX, float fStartY, float fEndX, float fEndY, float fCenterX, float fCenterY, float fWidth, float fHeight)
        {
            int intToleranceOffSet = 15;
            bool blnMatch = false;
            float fClosestSize = float.MaxValue;
            int intClosestSizeIndex = -1;

            for (int i = 0; i < m_arrBackupTemplateBlobLeads.Count; i++)
            {
                if (blnMatch)
                    blnMatch = false;

                m_stcBackupTemplateBlobLead = (ToleranceBlobsFeatures)m_arrBackupTemplateBlobLeads[i];

                // Check is sample gravity center point in template area or not
                if ((fCenterX >= m_stcBackupTemplateBlobLead.fStartX - intToleranceOffSet) &&
                    (fCenterX <= m_stcBackupTemplateBlobLead.fEndX + intToleranceOffSet) &&
                    (fCenterY >= m_stcBackupTemplateBlobLead.fStartY - intToleranceOffSet) &&
                    (fCenterY <= m_stcBackupTemplateBlobLead.fEndY + intToleranceOffSet))
                {
                    blnMatch = true;
                }
                // Check is template gravity center point in sample area or not
                else
                {
                    float fCenterX2 = (m_stcBackupTemplateBlobLead.fStartX + m_stcBackupTemplateBlobLead.fEndX) / 2;
                    float fCenterY2 = (m_stcBackupTemplateBlobLead.fStartY + m_stcBackupTemplateBlobLead.fEndY) / 2;

                    if ((fCenterX2 >= fStartX - intToleranceOffSet) &&
                    (fCenterX2 <= fEndX + intToleranceOffSet) &&
                    (fCenterY2 >= fStartY - intToleranceOffSet) &&
                    (fCenterY2 <= fEndY + intToleranceOffSet))
                    {
                        blnMatch = true;
                    }
                }

                if (blnMatch)
                {
                    if ((Math.Abs(fWidth - m_stcBackupTemplateBlobLead.fLearnWidth) / m_stcBackupTemplateBlobLead.fLearnWidth < 0.2) &&
                        (Math.Abs(fHeight - m_stcBackupTemplateBlobLead.fLearnWidth) / m_stcBackupTemplateBlobLead.fLearnHeight < 0.2))
                    {
                        return i;
                    }
                }

                float fDiffSize = Math.Abs(fWidth - m_stcBackupTemplateBlobLead.fLearnWidth) + Math.Abs(fHeight - m_stcBackupTemplateBlobLead.fLearnHeight);

                if (fDiffSize < fClosestSize)
                {
                    fClosestSize = fDiffSize;
                    intClosestSizeIndex = i;
                }
            }

            return intClosestSizeIndex;
        }

        /// <summary>
        /// Check whether all previous blobs are matched with current selected blobs
        /// </summary>
        /// <returns>true = all previous blobs match, false = otherwise</returns>
        public bool MatchPrevSettings()
        {
            float fStartX, fStartY, fEndX, fEndY, fCenterX, fCenterY;
            int intCount = 0, intNo;

            for (int i = 0; i < m_arrBackupTemplateBlobLeads.Count; i++)
            {
                m_stcBackupTemplateBlobLead = (ToleranceBlobsFeatures)m_arrBackupTemplateBlobLeads[i];

                fStartX = m_stcBackupTemplateBlobLead.fStartX;
                fStartY = m_stcBackupTemplateBlobLead.fStartY;
                fEndX = m_stcBackupTemplateBlobLead.fEndX;
                fEndY = m_stcBackupTemplateBlobLead.fEndY;
                fCenterX = m_stcBackupTemplateBlobLead.fLimitCenterX;
                fCenterY = m_stcBackupTemplateBlobLead.fLimitCenterY;

                // Get current blobs number
                List<int> arrMatch = MatchTemplateObjects(fStartX, fStartY, fEndX, fEndY, fCenterX, fCenterY);

                if (arrMatch.Count == 0)
                    continue;
                else if (arrMatch.Count > 1)
                    intNo = -2;
                else
                    intNo = arrMatch[0];

                if (intNo >= 0)
                {
                    m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[intNo];
                    m_stcBackupTemplateBlobLead = (ToleranceBlobsFeatures)m_arrBackupTemplateBlobLeads[i];

                    m_stcBlobLead.intDirection = m_stcBackupTemplateBlobLead.intDirection;
                    m_stcBlobLead.intNoID = m_stcBackupTemplateBlobLead.intNoID;
                    m_stcBlobLead.intLengthMode = m_stcBackupTemplateBlobLead.intLengthMode;
                    m_stcBlobLead.blnCheckSkew = m_stcBackupTemplateBlobLead.blnCheckSkew;
                    m_arrTemplateBlobLeads.RemoveAt(intNo);
                    m_arrTemplateBlobLeads.Insert(intNo, m_stcBlobLead);
                    intCount++;
                }
            }

            // All previous blobs are matched with current selected blobs
            if (intCount == m_arrBackupTemplateBlobLeads.Count)
                return true;

            return false;
        }

        public void MatchPrevSettings_AutoGenerate()
        {
            float fStartX, fStartY, fEndX, fEndY, fCenterX, fCenterY, fWidth, fHeight;
            int intCount = 0, intNo;

            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                if (!((BlobsFeatures)m_arrTemplateBlobLeads[i]).blnSelected)
                    continue;

                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                fStartX = m_stcBlobLead.fStartX;
                fStartY = m_stcBlobLead.fStartY;
                fEndX = m_stcBlobLead.fEndX;
                fEndY = m_stcBlobLead.fEndY;
                fCenterX = m_stcBlobLead.fLimitCenterX;
                fCenterY = m_stcBlobLead.fLimitCenterY;
                fWidth = m_stcBlobLead.fWidth;

                // Get current blobs number
                int intMatchTemplateBlobLeadIndex = MatchTemplateObjects_BasedOnPositionAndSize(m_stcBlobLead.fStartX, m_stcBlobLead.fStartY,
                                                                                m_stcBlobLead.fEndX, m_stcBlobLead.fEndY,
                                                                                fCenterX, fCenterY,
                                                                                m_stcBlobLead.fWidth, m_stcBlobLead.fHeight);

                if (intMatchTemplateBlobLeadIndex >= 0)
                {
                    m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                    m_stcBackupTemplateBlobLead = (ToleranceBlobsFeatures)m_arrBackupTemplateBlobLeads[intMatchTemplateBlobLeadIndex];

                    m_stcBlobLead.intDirection = m_stcBackupTemplateBlobLead.intDirection;
                    m_stcBlobLead.intNoID = m_stcBackupTemplateBlobLead.intNoID;
                    m_stcBlobLead.intGroupID = m_stcBackupTemplateBlobLead.intGroupID;
                    m_stcBlobLead.fSkew = m_stcBackupTemplateBlobLead.fSkew;
                    m_stcBlobLead.fOffSet = m_stcBackupTemplateBlobLead.fOffSet;

                    m_stcBlobLead.fMinBaseWidth = m_stcBackupTemplateBlobLead.fMinBaseWidth;
                    m_stcBlobLead.fMaxBaseWidth = m_stcBackupTemplateBlobLead.fMaxBaseWidth;
                    m_stcBlobLead.fMinBaseLength = m_stcBackupTemplateBlobLead.fMinBaseLength;
                    m_stcBlobLead.fMaxBaseLength = m_stcBackupTemplateBlobLead.fMaxBaseLength;

                    m_stcBlobLead.fMinTipWidth = m_stcBackupTemplateBlobLead.fMinTipWidth;
                    m_stcBlobLead.fMaxTipWidth = m_stcBackupTemplateBlobLead.fMaxTipWidth;
                    m_stcBlobLead.fMinTipLength = m_stcBackupTemplateBlobLead.fMinTipLength;
                    m_stcBlobLead.fMaxTipLength = m_stcBackupTemplateBlobLead.fMaxTipLength;


                    m_stcBlobLead.blnSelected = true;
                    m_stcBlobLead.blnCheckSkew = m_stcBackupTemplateBlobLead.blnCheckSkew;

                    m_arrTemplateBlobLeads.RemoveAt(i);
                    m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
                }
                else
                {
                    // Generate default setting


                }

            }
        }

        private bool MatchTemplateObjectsSkew(int intBlobsFeatureIndex, float fSkew)
        {
            m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[intBlobsFeatureIndex];

            if (!m_stcBlobLead.blnCheckSkew)
                return true;

            if (m_blnWantTightSetting)
            {
                if (fSkew <= Math.Round(m_stcBlobLead.fSkew - m_fTightSettingTolerance, 4))
                    return true;
                else
                    return false;
            }
            else
            {

                if (fSkew <= Math.Round(m_stcBlobLead.fSkew, 4))
                    return true;
                else
                    return false;
            }
        }

        private bool MatchTemplateObjectsOffset(int intBlobsFeatureIndex, float fOffset)
        {
            m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[intBlobsFeatureIndex];

            if (m_blnWantTightSetting)
            {
                if (fOffset <= Math.Round(m_stcBlobLead.fOffSet - m_fTightSettingTolerance, 4))
                    return true;
                else
                    return false;
            }
            else
            {

                if (fOffset <= Math.Round(m_stcBlobLead.fOffSet, 4))
                    return true;
                else
                    return false;
            }
        }
        /// <summary>
        /// Check whether sample object width fall within template width settings 
        /// </summary>
        /// <param name="intBlobsFeatureIndex">blobs feature index</param>
        /// <param name="fBaseWidth">Base width</param>
        /// <param name="fTipWidth">Tip width</param>
        /// <returns>true = valid width, false = invalid width</returns>
        private bool MatchTemplateObjectsWidth(int intBlobsFeatureIndex, float fTipWidth)
        {
            m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[intBlobsFeatureIndex];

            if (m_blnWantTightSetting)
            {
                if ((fTipWidth >= Math.Round(m_stcBlobLead.fMinTipWidth + m_fTightSettingTolerance, 4)) && (fTipWidth <= Math.Round(m_stcBlobLead.fMaxTipWidth - m_fTightSettingTolerance, 4)))
                    return true;
                else
                    return false;
            }
            else
            {

                if ((fTipWidth >= Math.Round(m_stcBlobLead.fMinTipWidth, 4)) && (fTipWidth <= Math.Round(m_stcBlobLead.fMaxTipWidth, 4)))
                    return true;
                else
                    return false;
            }
        }

        private bool MatchTemplateObjectsBurrWidth(int intBlobsFeatureIndex, float fBurrWidth)
        {
            m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[intBlobsFeatureIndex];

            if (m_blnWantTightSetting)
            {
                if (fBurrWidth <= Math.Round(m_stcBlobLead.fLeadMaxBurrWidth - m_fTightSettingTolerance, 4))
                    return true;
                else
                    return false;
            }
            else
            {
                if (fBurrWidth <= Math.Round(m_stcBlobLead.fLeadMaxBurrWidth, 4))

                    return true;
                else
                    return false;
            }
        }

        private bool MatchTemplateObjectsMinMaxWidth(int intBlobsFeatureIndex, float fMinWidth, float fMaxWidth)
        {
            m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[intBlobsFeatureIndex];

            if (m_blnWantTightSetting)
            {
                if ((fMinWidth >= Math.Round(m_stcBlobLead.fLeadLimitMinWidth + m_fTightSettingTolerance, 4)) && (fMinWidth <= Math.Round(m_stcBlobLead.fLeadLimitMaxWidth - m_fTightSettingTolerance, 4)))
                {
                    if ((fMaxWidth >= Math.Round(m_stcBlobLead.fLeadLimitMinWidth + m_fTightSettingTolerance, 4)) && (fMaxWidth <= Math.Round(m_stcBlobLead.fLeadLimitMaxWidth - m_fTightSettingTolerance, 4)))
                        return true;
                    else
                        return false;
                }
                else
                    return false;
            }
            else
            {

                if ((fMinWidth >= Math.Round(m_stcBlobLead.fLeadLimitMinWidth, 4)) && (fMinWidth <= Math.Round(m_stcBlobLead.fLeadLimitMaxWidth, 4)))
                {
                    if ((fMaxWidth >= Math.Round(m_stcBlobLead.fLeadLimitMinWidth, 4)) && (fMaxWidth <= Math.Round(m_stcBlobLead.fLeadLimitMaxWidth, 4)))
                        return true;
                    else
                        return false;
                }
                else
                    return false;
            }
        }


        private bool MatchTemplateObjectsStandOff(int intBlobsFeatureIndex, float fStandOff)
        {
            m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[intBlobsFeatureIndex];

            if (m_blnWantTightSetting)
            {
                if ((fStandOff >= Math.Round(m_stcBlobLead.fMinStandOff + m_fTightSettingTolerance, 4)) && (fStandOff <= Math.Round(m_stcBlobLead.fMaxStandOff - m_fTightSettingTolerance, 4)))
                    return true;
                else
                    return false;
            }
            else
            {

                if ((fStandOff >= Math.Round(m_stcBlobLead.fMinStandOff, 4)) && (fStandOff <= Math.Round(m_stcBlobLead.fMaxStandOff, 4)))
                    return true;
                else
                    return false;
            }
        }

        private bool MatchTemplateObjectsCoplan(int intBlobsFeatureIndex, float fCoplan)
        {
            m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[intBlobsFeatureIndex];

            if (m_blnWantTightSetting)
            {
                if (fCoplan <= Math.Round(m_stcBlobLead.fMaxCoplan - m_fTightSettingTolerance, 4))
                    return true;
                else
                    return false;
            }
            else
            {

                if (fCoplan <= Math.Round(m_stcBlobLead.fMaxCoplan, 4))
                    return true;
                else
                    return false;
            }
        }

        private bool MatchTemplateObjectsAverageGrayValue(int intBlobsFeatureIndex, float fAGV)
        {
            m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[intBlobsFeatureIndex];

            if (fAGV >= Math.Round(m_stcBlobLead.fMinAGV, 4) && fAGV <= Math.Round(m_stcBlobLead.fMaxAGV, 4))
                return true;
            else
                return false;

        }
        /// <summary>
        /// Check whether sample object width fall within template width settings 
        /// </summary>
        /// <param name="intBlobsFeatureIndex">blobs feature index</param>
        /// <param name="fBaseWidth">Base width</param>
        /// <param name="fTipWidth">Tip width</param>
        /// <returns>true = valid width, false = invalid width</returns>
        private bool MatchTemplateObjectsWidth(int intBlobsFeatureIndex, float fBaseWidth, float fTipWidth)
        {
            m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[intBlobsFeatureIndex];

            if (m_blnWantTightSetting)
            {
                if ((fBaseWidth >= Math.Round(m_stcBlobLead.fMinBaseWidth + m_fTightSettingTolerance, 4)) && (fBaseWidth <= Math.Round(m_stcBlobLead.fMaxBaseWidth - m_fTightSettingTolerance, 4)) &&
                    (fTipWidth >= Math.Round(m_stcBlobLead.fMinTipWidth + m_fTightSettingTolerance, 4)) && (fTipWidth <= Math.Round(m_stcBlobLead.fMaxTipWidth - m_fTightSettingTolerance, 4)))
                    return true;
                else
                    return false;
            }
            else
            {

                if ((fBaseWidth >= Math.Round(m_stcBlobLead.fMinBaseWidth, 4)) && (fBaseWidth <= Math.Round(m_stcBlobLead.fMaxBaseWidth, 4)) &&
                    (fTipWidth >= Math.Round(m_stcBlobLead.fMinTipWidth, 4)) && (fTipWidth <= Math.Round(m_stcBlobLead.fMaxTipWidth, 4)))
                    return true;
                else
                    return false;
            }
        }

        /// <summary>
        /// Check whether sample object height fall within template height settings 
        /// </summary>
        /// <param name="intBlobsFeatureIndex">blobs feature index</param>
        /// <param name="fHeight">height</param>
        /// <returns>true = valid height, false = invalid height</returns>
        private bool MatchTemplateObjectsHeight(int intBlobsFeatureIndex, float fBaseLength, float fTipLength)
        {
            m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[intBlobsFeatureIndex];

            if (m_blnWantTightSetting)
            {
                if ((fBaseLength >= Math.Round(m_stcBlobLead.fMinBaseLength + m_fTightSettingTolerance, 4)) && (fBaseLength <= Math.Round(m_stcBlobLead.fMaxBaseLength - m_fTightSettingTolerance, 4)) &&
                    (fTipLength >= Math.Round(m_stcBlobLead.fMinTipLength + m_fTightSettingTolerance, 4)) && (fTipLength <= Math.Round(m_stcBlobLead.fMaxTipLength - m_fTightSettingTolerance, 4)))
                    return true;
                else
                    return false;
            }
            else
            {
                if ((fBaseLength >= Math.Round(m_stcBlobLead.fMinBaseLength, 4)) && (fBaseLength <= Math.Round(m_stcBlobLead.fMaxBaseLength, 4)) &&
                    (fTipLength >= Math.Round(m_stcBlobLead.fMinTipLength, 4)) && (fTipLength <= Math.Round(m_stcBlobLead.fMaxTipLength, 4)))

                    return true;
                else
                    return false;
            }
        }


        /// <summary>
        /// Check whether sample object height fall within template height settings 
        /// </summary>
        /// <param name="intBlobsFeatureIndex">blobs feature index</param>
        /// <param name="fHeight">height</param>
        /// <returns>true = valid height, false = invalid height</returns>
        private bool MatchTemplateObjectsHeight(int intBlobsFeatureIndex, float fTipLength)
        {
            m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[intBlobsFeatureIndex];

            if (m_blnWantTightSetting)
            {
                if ((fTipLength >= Math.Round(m_stcBlobLead.fMinTipLength + m_fTightSettingTolerance, 4)) && (fTipLength <= Math.Round(m_stcBlobLead.fMaxTipLength - m_fTightSettingTolerance, 4)))
                    return true;
                else
                    return false;
            }
            else
            {
                if ((fTipLength >= Math.Round(m_stcBlobLead.fMinTipLength, 4)) && (fTipLength <= Math.Round(m_stcBlobLead.fMaxTipLength, 4)))

                    return true;
                else
                    return false;
            }
        }

        /// <summary>
        /// Check whether sample object reference point fall within template reference point tolerance
        /// </summary>
        /// <returns>true = valid reference point, false = invalid reference point</returns>
        private bool MatchTemplateObjectsReferencePoint()
        {
            //Define a condition for tolerance
            int intToleranceOffSet = 10;

            if (m_fSampleReferencePointStartX == m_fSampleReferencePointEndX)
            {
                if (m_blnWantTightSetting)
                {
                    if ((m_fSampleReferencePointStartX >= Math.Round(m_fReferencePointStartX - intToleranceOffSet + m_fTightSettingTolerance, 4, MidpointRounding.AwayFromZero)) && (m_fSampleReferencePointStartX <= Math.Round(m_fReferencePointStartX + intToleranceOffSet - m_fTightSettingTolerance, 4, MidpointRounding.AwayFromZero)) &&
                        (m_fSampleReferencePointStartY >= Math.Round(m_fReferencePointStartY - intToleranceOffSet + m_fTightSettingTolerance, 4, MidpointRounding.AwayFromZero)) && (m_fSampleReferencePointStartY <= Math.Round(m_fReferencePointStartY + intToleranceOffSet - m_fTightSettingTolerance, 4, MidpointRounding.AwayFromZero)) &&
                        (m_fSampleReferencePointEndY >= Math.Round(m_fReferencePointEndY - intToleranceOffSet + m_fTightSettingTolerance, 4, MidpointRounding.AwayFromZero)) && (m_fSampleReferencePointEndY <= Math.Round(m_fReferencePointEndY + intToleranceOffSet - m_fTightSettingTolerance, 4, MidpointRounding.AwayFromZero)))
                        return true;
                    else
                        return false;
                }
                else
                {
                    if ((m_fSampleReferencePointStartX >= Math.Round(m_fReferencePointStartX - intToleranceOffSet, 4, MidpointRounding.AwayFromZero)) && (m_fSampleReferencePointStartX <= Math.Round(m_fReferencePointStartX + intToleranceOffSet, 4, MidpointRounding.AwayFromZero)) &&
                        (m_fSampleReferencePointStartY >= Math.Round(m_fReferencePointStartY - intToleranceOffSet, 4, MidpointRounding.AwayFromZero)) && (m_fSampleReferencePointStartY <= Math.Round(m_fReferencePointStartY + intToleranceOffSet, 4, MidpointRounding.AwayFromZero)) &&
                        (m_fSampleReferencePointEndY >= Math.Round(m_fReferencePointEndY - intToleranceOffSet, 4, MidpointRounding.AwayFromZero)) && (m_fSampleReferencePointEndY <= Math.Round(m_fReferencePointEndY + intToleranceOffSet, 4, MidpointRounding.AwayFromZero)))
                        return true;
                    else
                        return false;
                }
            }
            else
            {
                if (m_blnWantTightSetting)
                {
                    if ((m_fSampleReferencePointStartY >= Math.Round(m_fReferencePointStartY - intToleranceOffSet + m_fTightSettingTolerance, 4, MidpointRounding.AwayFromZero)) && (m_fSampleReferencePointStartY <= Math.Round(m_fReferencePointStartY + intToleranceOffSet - m_fTightSettingTolerance, 4, MidpointRounding.AwayFromZero)) &&
                        (m_fSampleReferencePointStartX >= Math.Round(m_fReferencePointStartX - intToleranceOffSet + m_fTightSettingTolerance, 4, MidpointRounding.AwayFromZero)) && (m_fSampleReferencePointStartX <= Math.Round(m_fReferencePointStartX + intToleranceOffSet - m_fTightSettingTolerance, 4, MidpointRounding.AwayFromZero)) &&
                        (m_fSampleReferencePointEndX >= Math.Round(m_fReferencePointEndX - intToleranceOffSet + m_fTightSettingTolerance, 4, MidpointRounding.AwayFromZero)) && (m_fSampleReferencePointEndX <= Math.Round(m_fReferencePointEndX + intToleranceOffSet - m_fTightSettingTolerance, 4, MidpointRounding.AwayFromZero)))
                        return true;
                    else
                        return false;
                }
                else
                {
                    if ((m_fSampleReferencePointStartY >= Math.Round(m_fReferencePointStartY - intToleranceOffSet, 4, MidpointRounding.AwayFromZero)) && (m_fSampleReferencePointStartY <= Math.Round(m_fReferencePointStartY + intToleranceOffSet, 4, MidpointRounding.AwayFromZero)) &&
                        (m_fSampleReferencePointStartX >= Math.Round(m_fReferencePointStartX - intToleranceOffSet, 4, MidpointRounding.AwayFromZero)) && (m_fSampleReferencePointStartX <= Math.Round(m_fReferencePointStartX + intToleranceOffSet, 4, MidpointRounding.AwayFromZero)) &&
                        (m_fSampleReferencePointEndX >= Math.Round(m_fReferencePointEndX - intToleranceOffSet, 4, MidpointRounding.AwayFromZero)) && (m_fSampleReferencePointEndX <= Math.Round(m_fReferencePointEndX + intToleranceOffSet, 4, MidpointRounding.AwayFromZero)))
                        return true;
                    else
                        return false;
                }
            }
        }
        private List<int> MatchTemplateObjects_Inspection(ROI objROI, float fStartX, float fStartY,
          float fEndX, float fEndY, float fWidth, float fHeight,
          float fBaseWidth, float fBaseLength,
          float fTipWidth, float fTipLength,
          float fCenterX, float fCenterY, int intArea, int intDirection)
        {
            int intToleranceOffSet = 10;
            List<int> arrMatch = new List<int>();
            bool blnDoubleCheck = false;
            try
            {
                //for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
                //{
                //    m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                //    if (m_stcBlobLead.fWidth < 20 || m_stcBlobLead.fHeight < 20)
                //        intToleranceOffSet = 10;
                //    else
                //        intToleranceOffSet = 0;

                //    // Check is sample gravity center point in template area or not
                //    if ((fCenterX >= m_stcBlobLead.intStartX - intToleranceOffSet) && // Use center point check the matching btw sample and template is not enough especially when size is small. Miss matching may happen.
                //        (fCenterX <= m_stcBlobLead.intEndX + intToleranceOffSet) &&
                //        (fCenterY >= m_stcBlobLead.intStartY - intToleranceOffSet) &&
                //        (fCenterY <= m_stcBlobLead.intEndY + intToleranceOffSet))
                //    {
                //        arrMatch.Add(i);

                //        if (!blnDoubleCheck)
                //            if ((Math.Abs(fCenterX - m_stcBlobLead.fCenterX) > 10) ||
                //                (Math.Abs(fCenterY - m_stcBlobLead.fCenterY) > 10) ||
                //                (Math.Abs(fWidth - m_stcBlobLead.fWidth) > 10) ||
                //                (Math.Abs(fHeight - m_stcBlobLead.fHeight) > 10))
                //            {
                //                blnDoubleCheck = true;
                //            }
                //    }
                //    // Check is template gravity center point in sample area or not
                //    else if ((m_stcBlobLead.fCenterX >= fStartX - intToleranceOffSet) &&
                //        (m_stcBlobLead.fCenterX <= fEndX + intToleranceOffSet) &&
                //        (m_stcBlobLead.fCenterY >= fStartY - intToleranceOffSet) &&
                //        (m_stcBlobLead.fCenterY <= fEndY + intToleranceOffSet))
                //    {
                //        arrMatch.Add(i);

                //        if (!blnDoubleCheck)
                //            if ((Math.Abs(fCenterX - m_stcBlobLead.fCenterX) > 5) ||
                //                (Math.Abs(fCenterY - m_stcBlobLead.fCenterY) > 5) ||
                //                (Math.Abs(fWidth - m_stcBlobLead.fWidth) > 5) ||
                //                (Math.Abs(fHeight - m_stcBlobLead.fHeight) > 5))
                //            {
                //                blnDoubleCheck = true;
                //            }
                //    }
                //}

                //int intBuildAreaTolerance = 0;
                //if (m_intLeadDirection == 0)
                //{
                //    if (intDirection == 0)
                //    {
                //        intBuildAreaTolerance = m_intTipBuildAreaTolerance_Left;
                //    }
                //    else
                //    {
                //        intBuildAreaTolerance = m_intTipBuildAreaTolerance_Right;
                //    }
                //}
                //else
                //{
                //    if (intDirection == 0)
                //    {
                //        intBuildAreaTolerance = m_intTipBuildAreaTolerance_Top;
                //    }
                //    else
                //    {
                //        intBuildAreaTolerance = m_intTipBuildAreaTolerance_Bottom;
                //    }
                //}

                //---------------------------- Check Tip and base ----------------------------
                for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
                {
                    m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                    //if (m_stcBlobLead.fTipWidth < 20 || m_stcBlobLead.fTipLength < 20 || m_stcBlobLead.fBaseWidth < 20 || m_stcBlobLead.fBaseLength < 20)
                    //    intToleranceOffSet = 10;
                    //else
                    //    intToleranceOffSet = 0;
                    
                    //if (m_blnWantUsePkgToBaseTolerance)
                    //    intToleranceOffSet += intBuildAreaTolerance;



                    // Check is sample gravity center point in template area or not
                    if ((fCenterX >= m_stcBlobLead.intStartX - m_intMatchingXTolerance) && // Use center point check the matching btw sample and template is not enough especially when size is small. Miss matching may happen.
                        (fCenterX <= m_stcBlobLead.intEndX + m_intMatchingXTolerance) &&
                        (fCenterY >= m_stcBlobLead.intStartY - m_intMatchingYTolerance) &&
                        (fCenterY <= m_stcBlobLead.intEndY + m_intMatchingYTolerance))
                    {
                        arrMatch.Add(i);

                        if (!blnDoubleCheck)
                            if ((Math.Abs(fCenterX - m_stcBlobLead.fCenterX) > 10) ||
                                (Math.Abs(fCenterY - m_stcBlobLead.fCenterY) > 10) ||
                                (Math.Abs(fTipWidth - m_stcBlobLead.fTipWidth) > 10) ||
                                (Math.Abs(fTipLength - m_stcBlobLead.fTipLength) > 10) ||
                                (Math.Abs(fBaseWidth - m_stcBlobLead.fBaseWidth) > 10) ||
                                (Math.Abs(fBaseLength - m_stcBlobLead.fBaseLength) > 10))
                            {
                                blnDoubleCheck = true;
                            }
                    }
                    // Check is template gravity center point in sample area or not
                    else if ((m_stcBlobLead.fCenterX >= fStartX - m_intMatchingXTolerance) &&
                        (m_stcBlobLead.fCenterX <= fEndX + m_intMatchingXTolerance) &&
                        (m_stcBlobLead.fCenterY >= fStartY - m_intMatchingYTolerance) &&
                        (m_stcBlobLead.fCenterY <= fEndY + m_intMatchingYTolerance))
                    {
                        arrMatch.Add(i);

                        if (!blnDoubleCheck)
                            if ((Math.Abs(fCenterX - m_stcBlobLead.fCenterX) > 5) ||
                                (Math.Abs(fCenterY - m_stcBlobLead.fCenterY) > 5) ||
                                (Math.Abs(fTipWidth - m_stcBlobLead.fTipWidth) > 5) ||
                                (Math.Abs(fTipLength - m_stcBlobLead.fTipLength) > 5) ||
                                (Math.Abs(fBaseWidth - m_stcBlobLead.fBaseWidth) > 5) ||
                                (Math.Abs(fBaseLength - m_stcBlobLead.fBaseLength) > 5))
                            {
                                blnDoubleCheck = true;
                            }
                    }
                }
            }
            catch (Exception ex)
            {
                TrackLog objTL = new TrackLog();
                objTL.WriteLine("MatchTemplateObjects3 Exception Error: " + ex.ToString());
            }


            bool blnDebugImage = false;

            // Double check
            if (blnDoubleCheck)
            {
                ROI objSampBlobROI = new ROI();
                objSampBlobROI.AttachImage(objROI);
                objSampBlobROI.LoadROISetting((int)fStartX, (int)fStartY, (int)(fEndX - fStartX), (int)(fEndY - fStartY));

                if (blnDebugImage)
                {
                    objSampBlobROI.SaveImage("D:\\TS\\objSampleBlobROI.bmp");// debug
                }

                ROI objTempBlobROI = new ROI();

                // Double check is match index correct or not by using sample and templete blobs subtraction
                for (int i = 0; i < arrMatch.Count; i++)
                {
                    //m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[arrMatch[i]];
                    //objTempBlobROI.ref_ROI.Detach();
                    //objTempBlobROI.ref_ROI.Attach(m_arrImgLeadImage[arrMatch[i]]);
                    //objTempBlobROI.LoadROISetting(m_stcBlobLead.intStartX, m_stcBlobLead.intStartY,
                    //                              (m_stcBlobLead.intEndX - m_stcBlobLead.intStartX),
                    //                              (m_stcBlobLead.intEndY - m_stcBlobLead.intStartY));

                    if (blnDebugImage)
                    {
                        m_arrImgLeadImage[arrMatch[i]].Save("D:\\TS\\m_arrImgLeadImage" + arrMatch[i].ToString() + ".bmp");// debug
                        objTempBlobROI.SaveImage("D:\\TS\\objTempBlobROI.bmp");// debug
                    }

                    //if (!IsObjectStickTogether(objROI, objSampBlobROI, objTempBlobROI, intArea, fCenterX, fCenterY))
                    //{
                    //    // Remove from list if no stick together
                    //    arrMatch.RemoveAt(i);
                    //    i--;
                    //}
                }
                objSampBlobROI.Dispose();
                objTempBlobROI.Dispose();
            }

            return arrMatch;
        }
        private List<int> MatchTemplateObjects_Inspection(ROI objROI, float fStartX, float fStartY,
            float fEndX, float fEndY, float fWidth, float fHeight,
            float fBaseWidth, float fBaseLength,
            float fTipWidth, float fTipLength,
            float fCenterX, float fCenterY, int intArea)
        {
            int intToleranceOffSet = 10;
            List<int> arrMatch = new List<int>();
            bool blnDoubleCheck = false;
            try
            {
                //for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
                //{
                //    m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                //    if (m_stcBlobLead.fWidth < 20 || m_stcBlobLead.fHeight < 20)
                //        intToleranceOffSet = 10;
                //    else
                //        intToleranceOffSet = 0;

                //    // Check is sample gravity center point in template area or not
                //    if ((fCenterX >= m_stcBlobLead.intStartX - intToleranceOffSet) && // Use center point check the matching btw sample and template is not enough especially when size is small. Miss matching may happen.
                //        (fCenterX <= m_stcBlobLead.intEndX + intToleranceOffSet) &&
                //        (fCenterY >= m_stcBlobLead.intStartY - intToleranceOffSet) &&
                //        (fCenterY <= m_stcBlobLead.intEndY + intToleranceOffSet))
                //    {
                //        arrMatch.Add(i);

                //        if (!blnDoubleCheck)
                //            if ((Math.Abs(fCenterX - m_stcBlobLead.fCenterX) > 10) ||
                //                (Math.Abs(fCenterY - m_stcBlobLead.fCenterY) > 10) ||
                //                (Math.Abs(fWidth - m_stcBlobLead.fWidth) > 10) ||
                //                (Math.Abs(fHeight - m_stcBlobLead.fHeight) > 10))
                //            {
                //                blnDoubleCheck = true;
                //            }
                //    }
                //    // Check is template gravity center point in sample area or not
                //    else if ((m_stcBlobLead.fCenterX >= fStartX - intToleranceOffSet) &&
                //        (m_stcBlobLead.fCenterX <= fEndX + intToleranceOffSet) &&
                //        (m_stcBlobLead.fCenterY >= fStartY - intToleranceOffSet) &&
                //        (m_stcBlobLead.fCenterY <= fEndY + intToleranceOffSet))
                //    {
                //        arrMatch.Add(i);

                //        if (!blnDoubleCheck)
                //            if ((Math.Abs(fCenterX - m_stcBlobLead.fCenterX) > 5) ||
                //                (Math.Abs(fCenterY - m_stcBlobLead.fCenterY) > 5) ||
                //                (Math.Abs(fWidth - m_stcBlobLead.fWidth) > 5) ||
                //                (Math.Abs(fHeight - m_stcBlobLead.fHeight) > 5))
                //            {
                //                blnDoubleCheck = true;
                //            }
                //    }
                //}

                //---------------------------- Check Tip and base ----------------------------
                for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
                {
                    m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                    if (m_stcBlobLead.fTipWidth < 20 || m_stcBlobLead.fTipLength < 20 || m_stcBlobLead.fBaseWidth < 20 || m_stcBlobLead.fBaseLength < 20)
                        intToleranceOffSet = 10;
                    else
                        intToleranceOffSet = 0;

                    // Check is sample gravity center point in template area or not
                    if ((fCenterX >= m_stcBlobLead.intStartX - intToleranceOffSet) && // Use center point check the matching btw sample and template is not enough especially when size is small. Miss matching may happen.
                        (fCenterX <= m_stcBlobLead.intEndX + intToleranceOffSet) &&
                        (fCenterY >= m_stcBlobLead.intStartY - intToleranceOffSet) &&
                        (fCenterY <= m_stcBlobLead.intEndY + intToleranceOffSet))
                    {
                        arrMatch.Add(i);

                        if (!blnDoubleCheck)
                            if ((Math.Abs(fCenterX - m_stcBlobLead.fCenterX) > 10) ||
                                (Math.Abs(fCenterY - m_stcBlobLead.fCenterY) > 10) ||
                                (Math.Abs(fTipWidth - m_stcBlobLead.fTipWidth) > 10) ||
                                (Math.Abs(fTipLength - m_stcBlobLead.fTipLength) > 10) ||
                                (Math.Abs(fBaseWidth - m_stcBlobLead.fBaseWidth) > 10) ||
                                (Math.Abs(fBaseLength - m_stcBlobLead.fBaseLength) > 10))
                            {
                                blnDoubleCheck = true;
                            }
                    }
                    // Check is template gravity center point in sample area or not
                    else if ((m_stcBlobLead.fCenterX >= fStartX - intToleranceOffSet) &&
                        (m_stcBlobLead.fCenterX <= fEndX + intToleranceOffSet) &&
                        (m_stcBlobLead.fCenterY >= fStartY - intToleranceOffSet) &&
                        (m_stcBlobLead.fCenterY <= fEndY + intToleranceOffSet))
                    {
                        arrMatch.Add(i);

                        if (!blnDoubleCheck)
                            if ((Math.Abs(fCenterX - m_stcBlobLead.fCenterX) > 5) ||
                                (Math.Abs(fCenterY - m_stcBlobLead.fCenterY) > 5) ||
                                (Math.Abs(fTipWidth - m_stcBlobLead.fTipWidth) > 5) ||
                                (Math.Abs(fTipLength - m_stcBlobLead.fTipLength) > 5) ||
                                (Math.Abs(fBaseWidth - m_stcBlobLead.fBaseWidth) > 5) ||
                                (Math.Abs(fBaseLength - m_stcBlobLead.fBaseLength) > 5))
                            {
                                blnDoubleCheck = true;
                            }
                    }
                }
            }
            catch (Exception ex)
            {
                TrackLog objTL = new TrackLog();
                objTL.WriteLine("MatchTemplateObjects3 Exception Error: " + ex.ToString());
            }


            bool blnDebugImage = false;

            // Double check
            if (blnDoubleCheck)
            {
                ROI objSampBlobROI = new ROI();
                objSampBlobROI.AttachImage(objROI);
                objSampBlobROI.LoadROISetting((int)fStartX, (int)fStartY, (int)(fEndX - fStartX), (int)(fEndY - fStartY));

                if (blnDebugImage)
                {
                    objSampBlobROI.SaveImage("D:\\TS\\objSampleBlobROI.bmp");// debug
                }

                ROI objTempBlobROI = new ROI();

                // Double check is match index correct or not by using sample and templete blobs subtraction
                for (int i = 0; i < arrMatch.Count; i++)
                {
                    //m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[arrMatch[i]];
                    //objTempBlobROI.ref_ROI.Detach();
                    //objTempBlobROI.ref_ROI.Attach(m_arrImgLeadImage[arrMatch[i]]);
                    //objTempBlobROI.LoadROISetting(m_stcBlobLead.intStartX, m_stcBlobLead.intStartY,
                    //                              (m_stcBlobLead.intEndX - m_stcBlobLead.intStartX),
                    //                              (m_stcBlobLead.intEndY - m_stcBlobLead.intStartY));

                    if (blnDebugImage)
                    {
                        m_arrImgLeadImage[arrMatch[i]].Save("D:\\TS\\m_arrImgLeadImage" + arrMatch[i].ToString() + ".bmp");// debug
                        objTempBlobROI.SaveImage("D:\\TS\\objTempBlobROI.bmp");// debug
                    }

                    //if (!IsObjectStickTogether(objROI, objSampBlobROI, objTempBlobROI, intArea, fCenterX, fCenterY))
                    //{
                    //    // Remove from list if no stick together
                    //    arrMatch.RemoveAt(i);
                    //    i--;
                    //}
                }
                objSampBlobROI.Dispose();
                objTempBlobROI.Dispose();
            }

            return arrMatch;
        }

        /// <summary>
        /// Remove certain pitch gap 
        /// </summary>
        /// <param name="intPitchGapIndex">pitch gap index</param>
        public void DeletePitchGap(int intPitchGapIndex)
        {
            if (intPitchGapIndex >= m_arrPitchGap.Count)
                return;

            m_arrPitchGap.RemoveAt(intPitchGapIndex);
        }

        public bool InspectCenterLeads(ROI objROI, bool blnCheckContamination)
        {

            m_blnLock = true;

            lock (m_objLockBlobs)
            {

                bool blnWantDebug = false;
                if (blnWantDebug)
                {
                    objROI.SaveImage("D:\\TS\\objROI.bmp");
                }
                // Define actual threshold value
                m_intThresholdValuePrev = m_intThresholdValue;
                if (m_intThresholdValue == -4)
                    m_intThresholdValue = GetAutoThresholdValue(objROI, 3);

                ROI objInspectROI = new ROI();
                objInspectROI.LoadROISetting(objROI.ref_ROIPositionX, objROI.ref_ROIPositionY, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
                ImageDrawing objImg = new ImageDrawing(true, objROI.ref_ROI.TopParent.Width, objROI.ref_ROI.TopParent.Height);
                objImg.SetImageToBlack();
                objInspectROI.AttachImage(objImg);
                objROI.CopyImage_Bigger(ref objInspectROI);

                //Subtract Dont Care Area
                if (m_blnWantDontCareArea_Lead3D)
                {
                    //objInspectROI.SaveImage("D:\\objROI.bmp");
                    ROI objDontCareROI = new ROI();
                    objDontCareROI.LoadROISetting(0, 0, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
                    objDontCareROI.AttachImage(m_objLead3DDontCareImage);
                    ROI.SubtractROI(objInspectROI, objDontCareROI);
                    objDontCareROI.Dispose();
                    //objInspectROI.SaveImage("D:\\objROI.bmp");
                }

                InitLeadInspectionData_Lead3D(objROI);

                m_arrLead3DCenterPointGaugeStartX.Clear();
                m_arrLead3DCenterPointGaugeStartY.Clear();
                m_arrLead3DCenterPointGaugeTolerance.Clear();
                m_arrLead3DCenterPointGaugeAngle.Clear();
                m_arrLead3DEdgeCenterGaugePoints.Clear();
                m_arrLead3DEdgeCenterGaugePointsFound.Clear();
                m_arrLead3DEdgeCenterGaugePointsPosition.Clear();

                for (int p = m_arrLead3DEdgeCenterGaugePoints.Count; p < m_arrTemplateBlobLeads.Count; p++)
                {
                    m_arrLead3DEdgeCenterGaugePoints.Add(new List<PointF>());
                    m_arrLead3DEdgeCenterGaugePointsFound.Add(new List<bool>());
                    m_arrLead3DEdgeCenterGaugePointsPosition.Add(0);
                    m_arrLead3DCenterPointGaugeStartX.Add(new List<float>());
                    m_arrLead3DCenterPointGaugeStartY.Add(new List<float>());
                    m_arrLead3DCenterPointGaugeTolerance.Add(new List<float>());
                    m_arrLead3DCenterPointGaugeAngle.Add(new List<float>());
                }

                m_fTotalExtraArea = 0;
                m_blnFailForeignMaterialLength = false;
                m_blnFailForeignMaterialArea = false;
                m_blnFailForeignMaterialTotalArea = false;
                for (int r = 0; r < 2; r++) // Loop 2 to check top left or right bottom
                {
                    int intNumberOfLeads = 0;
                    if (m_intLeadDirection == 0)    // Horizontal Leads
                    {
                        m_objLocalROI.AttachImage(objInspectROI);

                        if (r == 0)
                        {
                            // Set single leads ROI
                            if (m_blnWantUsePkgToBaseTolerance)
                                m_objLocalROI.LoadROISetting(0, 0,
                                                     (int)Math.Round(m_pCornerPoint_Center.X - m_fCenterUnitWidth / 2 - m_intTipBuildAreaTolerance_Left - objROI.ref_ROITotalX, 0, MidpointRounding.AwayFromZero),
                                                     objROI.ref_ROIHeight);
                            else
                                m_objLocalROI.LoadROISetting(0, 0,
                                                       (int)Math.Round(m_pCornerPoint_Center.X - m_fCenterUnitWidth / 2 - objROI.ref_ROITotalX, 0, MidpointRounding.AwayFromZero),
                                                       objROI.ref_ROIHeight);

                            intNumberOfLeads = m_intNumberOfLead_Left;
                        }
                        else
                        {
                            // Set single leads ROI
                            if (m_blnWantUsePkgToBaseTolerance)
                                m_objLocalROI.LoadROISetting((int)Math.Round(m_pCornerPoint_Center.X + m_fCenterUnitWidth / 2 + m_intTipBuildAreaTolerance_Right - objROI.ref_ROITotalX, 0, MidpointRounding.AwayFromZero),
                                                          0,
                                                          objROI.ref_ROIWidth - (int)Math.Round(m_pCornerPoint_Center.X + m_fCenterUnitWidth / 2 + m_intTipBuildAreaTolerance_Right - objROI.ref_ROITotalX, 0, MidpointRounding.AwayFromZero),
                                                          objROI.ref_ROIHeight);
                            else
                                m_objLocalROI.LoadROISetting((int)Math.Round(m_pCornerPoint_Center.X + m_fCenterUnitWidth / 2 - objROI.ref_ROITotalX, 0, MidpointRounding.AwayFromZero),
                                                         0,
                                                         objROI.ref_ROIWidth - (int)Math.Round(m_pCornerPoint_Center.X + m_fCenterUnitWidth / 2 - objROI.ref_ROITotalX, 0, MidpointRounding.AwayFromZero),
                                                         objROI.ref_ROIHeight);

                            intNumberOfLeads = m_intNumberOfLead_Right;
                        }
                    }
                    else // Vertical leads
                    {
                        m_objLocalROI.AttachImage(objInspectROI);

                        if (r == 0)
                        {
                            // Set single leads ROI
                            if (m_blnWantUsePkgToBaseTolerance)
                                m_objLocalROI.LoadROISetting(0, 0,
                                                       objROI.ref_ROIWidth,
                                                       (int)Math.Round(m_pCornerPoint_Center.Y - m_fCenterUnitHeight / 2 - m_intTipBuildAreaTolerance_Top - objROI.ref_ROITotalY, 0, MidpointRounding.AwayFromZero));
                            else
                                m_objLocalROI.LoadROISetting(0, 0,
                                                       objROI.ref_ROIWidth,
                                                       (int)Math.Round(m_pCornerPoint_Center.Y - m_fCenterUnitHeight / 2 - objROI.ref_ROITotalY, 0, MidpointRounding.AwayFromZero));

                            intNumberOfLeads = m_intNumberOfLead_Top;
                        }
                        else
                        {
                            // Set single leads ROI
                            if (m_blnWantUsePkgToBaseTolerance)
                                m_objLocalROI.LoadROISetting(0,
                                                       (int)Math.Round(m_pCornerPoint_Center.Y + m_intTipBuildAreaTolerance_Bottom + m_fCenterUnitHeight / 2 - objROI.ref_ROITotalY, 0, MidpointRounding.AwayFromZero),
                                                        objROI.ref_ROIWidth,
                                                        objROI.ref_ROIHeight - (int)Math.Round(m_pCornerPoint_Center.Y + m_intTipBuildAreaTolerance_Bottom + m_fCenterUnitHeight / 2 - objROI.ref_ROITotalY, 0, MidpointRounding.AwayFromZero));
                            else
                                m_objLocalROI.LoadROISetting(0,
                                                        (int)Math.Round(m_pCornerPoint_Center.Y + m_fCenterUnitHeight / 2 - objROI.ref_ROITotalY, 0, MidpointRounding.AwayFromZero),
                                                         objROI.ref_ROIWidth,
                                                         objROI.ref_ROIHeight - (int)Math.Round(m_pCornerPoint_Center.Y + m_fCenterUnitHeight / 2 - objROI.ref_ROITotalY, 0, MidpointRounding.AwayFromZero));

                            intNumberOfLeads = m_intNumberOfLead_Bottom;
                        }
                    }

                    if (blnWantDebug)
                    {
                        m_objLocalROI.SaveImage("D:\\TS\\1. m_objLocalROI.bmp");
                    }

                    m_objEBlobs.BuildObjects_Filter_GetElement(m_objLocalROI, !m_blnWhiteOnBlack, true, 0, m_intThresholdValue,
                       (int)Math.Floor(m_fBlobsMinArea), m_intMaxArea, false, 0x0F);

                    // Check blobs is empty
                    int intNumSelectedObject = m_objEBlobs.ref_intNumSelectedObject;

                    //This missing is totally no blob built at all
                    if (intNumSelectedObject == 0 && intNumberOfLeads > 0)   // Missing pad if template got pads but sample is empty
                    {
                        for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
                        {
                            m_arrFailResultMask[0] |= 0x20;
                            m_arrSampleBlobLeads[i].intFailMask |= 0x20;
                        }
                        m_blnLock = false;
                        objImg.Dispose();
                        objInspectROI.Dispose();
                        return false;
                    }

                    if (m_blnWantUsePkgToBaseTolerance)
                        MeasureDimension_CenterLeads_UsingPkgToBaseTolerance(objROI, m_objLocalROI, intNumberOfLeads, r);
                    else
                        MeasureDimension_CenterLeads_UsingPointGauge(objROI, m_objLocalROI, intNumberOfLeads, r);

                }

                if ((((m_intFailOptionMask & 0x8000) > 0) || ((m_intFailOptionMask & 0x10000) > 0)) && blnCheckContamination && m_intLeadContaminationRegion != 0)
                {
                    // extra area for center pkg
                    ROI objExtraAreaROI = new ROI();
                    objExtraAreaROI.AttachImage(objROI);
                    float fStartX, fStartY, fEndX, fEndY, fWidth, fHeight;
                    int intArea;
                    fStartX = m_pCornerPoint_Center.X - (m_fCenterUnitWidth / 2) - objROI.ref_ROIPositionX;
                    fStartY = m_pCornerPoint_Center.Y - (m_fCenterUnitHeight / 2) - objROI.ref_ROIPositionY;
                    fEndX = m_pCornerPoint_Center.X + (m_fCenterUnitWidth / 2) - objROI.ref_ROIPositionX;
                    fEndY = m_pCornerPoint_Center.Y + (m_fCenterUnitHeight / 2) - objROI.ref_ROIPositionY;
                    objExtraAreaROI.LoadROISetting((int)Math.Ceiling(fStartX + m_fPkgStartPixelFromLeft), (int)Math.Ceiling(fStartY + m_fPkgStartPixelFromEdge),
                        (int)Math.Floor(fEndX - fStartX - (m_fPkgStartPixelFromLeft + m_fPkgStartPixelFromRight)),
                        (int)Math.Floor(fEndY - fStartY - (m_fPkgStartPixelFromEdge + m_fPkgStartPixelFromBottom)));
                    //objExtraAreaROI.SaveImage("D:\\objExtraAreaROI.bmp");
                    if (objExtraAreaROI.ref_ROIWidth > 0 && objExtraAreaROI.ref_ROIHeight > 0)
                    {
                        m_objExtraLeadEBlobs.BuildObjects_Filter_GetElement(objExtraAreaROI, false, true, 0, m_objEBlobs.ref_intAbsoluteThreshold,
                           m_intFilterMinArea, objExtraAreaROI.ref_ROIHeight * objExtraAreaROI.ref_ROIWidth, false, 0x0F);

                        if (m_objExtraLeadEBlobs.ref_intNumSelectedObject > 0)
                        {

                            float fLimitCenterX2 = 0, fLimitCenterY2 = 0;
                            float fFinalLimitCenterX = 0, fFinalLimitCenterY = 0;
                            for (int k = 0; k < m_objExtraLeadEBlobs.ref_intNumSelectedObject; k++)
                            {
                                m_intExtraBlobID++;
                                fLimitCenterX2 = m_objExtraLeadEBlobs.ref_arrLimitCenterX[k];
                                fLimitCenterY2 = m_objExtraLeadEBlobs.ref_arrLimitCenterY[k];


                                fFinalLimitCenterX = fLimitCenterX2;
                                fFinalLimitCenterY = fLimitCenterY2;
                                fWidth = m_objExtraLeadEBlobs.ref_arrWidth[k];
                                fHeight = m_objExtraLeadEBlobs.ref_arrHeight[k];
                                intArea = m_objExtraLeadEBlobs.ref_arrArea[k];

                                // Reposition so that it offset to objROI
                                fFinalLimitCenterX += objExtraAreaROI.ref_ROIPositionX;
                                fFinalLimitCenterY += objExtraAreaROI.ref_ROIPositionY;

                                // Get object start point and end point
                                fStartX = fFinalLimitCenterX - (fWidth / 2);
                                fStartY = fFinalLimitCenterY - (fHeight / 2);
                                fEndX = fFinalLimitCenterX + (fWidth / 2);
                                fEndY = fFinalLimitCenterY + (fHeight / 2);
                                //m_blnFailForeignMaterialLength = false;
                                //m_blnFailForeignMaterialArea = false;
                                //m_blnFailForeignMaterialTotalArea = false;
                                SampleExtraBlobsFeatures extra = new SampleExtraBlobsFeatures();
                                extra.fStartX = fStartX;
                                extra.fEndX = fEndX;
                                extra.fStartY = fStartY;
                                extra.fEndY = fEndY;
                                extra.fWidth = fWidth;
                                extra.fHeight = fHeight;
                                extra.fCenterX = (fStartX + fEndX) / 2;
                                extra.fCenterY = (fStartY + fEndY) / 2;
                                extra.ref_intExtraBlobID = m_intExtraBlobID;
                                float fWidthInMM = Get2DXinMM(fWidth);//fWidth / m_fMMToPixelXValue;
                                float fHeightInMM = Get2DYinMM(fHeight);//fHeight / m_fMMToPixelXValue;

                                float fArea = intArea * m_fAreaMMPerPixel;

                                if (m_blnWantCheckExtraLeadLength)
                                {
                                    //////////////// Check extra Lead using length limit setting ////////////////////
                                    extra.ref_fWidthFailValue = fWidthInMM;
                                    extra.ref_fHeightFailValue = fHeightInMM;

                                    if ((fWidthInMM > m_fExtraLeadSetLength) ||
                                        (fHeightInMM > m_fExtraLeadSetLength))
                                    {

                                        if (fWidthInMM > m_fExtraLeadSetLength)
                                        {
                                            extra.ref_intFailCriteria |= 0x01;
                                            m_arrFailResultMask[0] |= 0x8000;
                                        }

                                        if (fHeightInMM > m_fExtraLeadSetLength)
                                        {
                                            extra.ref_intFailCriteria |= 0x02;
                                            m_arrFailResultMask[0] |= 0x8000;
                                        }
                                        m_blnFailForeignMaterialLength = true;
                                        // Collect extra Lead min and max area for display error message
                                        //if ((fWidthInMM > m_fExtraLeadSetLength) &&
                                        //(fHeightInMM > m_fExtraLeadSetLength))
                                        //{
                                        //    float fMin = Math.Min(fWidthInMM, fHeightInMM);
                                        //    if ((m_fResultExtraLeadMinArea == -1) || (fMin < m_fResultExtraLeadMinArea))
                                        //        m_fResultExtraLeadMinArea = fMin;

                                        //    float fMax = Math.Max(fWidthInMM, fHeightInMM);
                                        //    if ((m_fResultExtraLeadMaxArea == -1) || (fMax > m_fResultExtraLeadMaxArea))
                                        //        m_fResultExtraLeadMaxArea = fMax;
                                        //}
                                        //else if (fWidthInMM > m_fExtraLeadSetLength)
                                        //{
                                        //    if ((m_fResultExtraLeadMinArea == -1) || (fWidthInMM < m_fResultExtraLeadMinArea))
                                        //        m_fResultExtraLeadMinArea = fWidthInMM;
                                        //    if ((m_fResultExtraLeadMaxArea == -1) || (fWidthInMM > m_fResultExtraLeadMaxArea))
                                        //        m_fResultExtraLeadMaxArea = fWidthInMM;
                                        //}
                                        //else if (fHeightInMM > m_fExtraLeadSetLength)
                                        //{
                                        //    if ((m_fResultExtraLeadMinArea == -1) || (fHeightInMM < m_fResultExtraLeadMinArea))
                                        //        m_fResultExtraLeadMinArea = fHeightInMM;
                                        //    if ((m_fResultExtraLeadMaxArea == -1) || (fHeightInMM > m_fResultExtraLeadMaxArea))
                                        //        m_fResultExtraLeadMaxArea = fHeightInMM;
                                        //}
                                    }

                                }

                                if (m_blnWantCheckExtraLeadArea)
                                {
                                    //////////////// Check extra Lead using area limit setting ////////////////////
                                    // Change unit pixel to mm
                                    extra.ref_fAreaFailValue = fArea;
                                    if (fArea > m_fExtraLeadSetArea)
                                    {
                                        m_blnFailForeignMaterialArea = true;
                                        extra.ref_intFailCriteria |= 0x04;

                                        m_arrFailResultMask[0] |= 0x8000;
                                        //// Collect extra Lead min and max area for display error message
                                        //if ((m_fResultExtraLeadMinArea == -1) || (fArea < m_fResultExtraLeadMinArea))
                                        //    m_fResultExtraLeadMinArea = fArea;
                                        //if ((m_fResultExtraLeadMaxArea == -1) || (fArea > m_fResultExtraLeadMaxArea))
                                        //    m_fResultExtraLeadMaxArea = fArea;
                                    }
                                    //////////////////////////////////////////////////////////////////////
                                }

                                //////////////// Get Total Extra pad unit area ///////////////////////////////
                                if ((m_intFailOptionMask & 0x10000) > 0)
                                {
                                    m_fTotalExtraArea += fArea;
                                }
                                if (m_blnWantCheckExtraLeadLength || m_blnWantCheckExtraLeadArea || ((m_intFailOptionMask & 0x10000) > 0))
                                    m_arrExtraBlobs.Add(extra);
                            }
                        }
                    }

                    objExtraAreaROI.Dispose();
                }

                if (((m_intFailOptionMask & 0x10000) > 0) && !m_blnFailForeignMaterialLength && !m_blnFailForeignMaterialArea)
                {
                    if (m_fTotalExtraArea > 0)
                    {
                        m_intExtraBlobID++;
                        //////////////// Check Total Extra pad unit area ///////////////////////////////
                        SampleExtraBlobsFeatures extra = new SampleExtraBlobsFeatures();
                        extra.ref_intExtraBlobID = m_intExtraBlobID;
                        extra.ref_fWidthFailValue = -999;
                        extra.ref_fHeightFailValue = -999;
                        extra.ref_fAreaFailValue = m_fTotalExtraArea;
                        if (m_fTotalExtraArea > m_fTotalExtraLeadSetArea)
                        {
                            m_blnFailForeignMaterialTotalArea = true;
                            for (int i = 0; i < m_arrExtraBlobs.Count; i++)
                            {
                                SampleExtraBlobsFeatures objExtraBlob = m_arrExtraBlobs[i];
                                objExtraBlob.ref_intFailCriteria |= 0x08;
                                m_arrExtraBlobs[i] = objExtraBlob;
                            }
                            extra.ref_intFailCriteria |= 0x04;
                            m_arrFailResultMask[0] |= 0x10000;
                        }
                        m_arrExtraBlobs.Add(extra);
                    }
                }

                // Missing Lead if template got Leads but sample is empty
                for (int i = 0; i < m_arrSampleBlobLeads.Length; i++)
                {
                    if (m_arrSampleBlobLeads[i].fArea == -999 && ((m_arrSampleBlobLeads[i].intFailMask & 0x10) == 0))
                    {
                        m_arrFailResultMask[0] |= 0x20;
                        m_arrSampleBlobLeads[i].intFailMask |= 0x20;
                    }
                }

                // Check Dimension
                CheckDimension_CenterLeads(objROI);

                CheckAverageGrayValue_CenterLeads(objROI);

                CheckPitchGap(objROI);

                //m_blnFindLeadCenterPointsDone = true;     // 2020 11 05 - CCENG: cannot set the event here. Need to walk m_eInspectionResult_Center only can set. 

                m_intThresholdValue = m_intThresholdValuePrev;

                m_blnLock = false;

                for (int i = 0; i < m_arrFailResultMask.Length; i++)
                {
                    if (m_arrFailResultMask[i] > 0)
                    {
                        objImg.Dispose();
                        objInspectROI.Dispose();
                        return false;
                    }
                }
                objImg.Dispose();
                objInspectROI.Dispose();
                return true;
            }
        }

        public bool InspectSideUnitBaseLine(ROI objROI)
        {
            ROI objInspectROI = new ROI();
            objInspectROI.LoadROISetting(objROI.ref_ROIPositionX, objROI.ref_ROIPositionY, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
            ImageDrawing objImg = new ImageDrawing(true, objROI.ref_ROI.TopParent.Width, objROI.ref_ROI.TopParent.Height);
            objImg.SetImageToBlack();
            objInspectROI.AttachImage(objImg);
            objROI.CopyImage_Bigger(ref objInspectROI);

            //Subtract Dont Care Area
            if (m_blnWantDontCareArea_Lead3D)
            {
                //objInspectROI.SaveImage("D:\\objROI.bmp");
                ROI objDontCareROI = new ROI();
                objDontCareROI.LoadROISetting(0, 0, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
                objDontCareROI.AttachImage(m_objLead3DDontCareImage);
                ROI.LogicOperationAddROI(objInspectROI, objDontCareROI);
                objDontCareROI.Dispose();
                //objInspectROI.SaveImage("D:\\objROI.bmp");
            }


            // Build blobs
            BuildOnlySideLeadObjects_BlackObject(objInspectROI);

            m_arrSampleBlobBodyLeads.Clear();

            int intSelectedObjectNum = 0;
            float fBorderDistanceX, fBorderDistanceY;

            if (m_objEBlobs.ref_intNumSelectedObject > 0)
                intSelectedObjectNum = 1;

            //If more than 1 blob is found
            if (intSelectedObjectNum > 0)
            {
                //if there are more than 1 blob
                //Combine all the blob within the range
                float fLimitCenterX;
                float fLimitCenterY;
                float fWidth;
                float fHeight;
                float fOrgX;
                float fOrgY;
                int intTotalBlobCount;
                int intSelectedBlob = 0;
                int intTotalArea;
                float fTotalCenterX;
                float fTotalCenterY;
                float fTotalLimitCenterX;
                float fTotalLimitCenterY;
                float fStartX;
                float fStartY;
                float fEndX;
                float fEndY;
                List<int> arrSkipNo = new List<int>();
                bool blnSkipToNextObject = false;

                for (int i = 0; i < intSelectedObjectNum; i++)
                {
                    for (int k = 0; k < arrSkipNo.Count; k++)
                    {
                        if (i == arrSkipNo[k])
                        {
                            blnSkipToNextObject = true;
                            break;
                        }
                    }

                    if (blnSkipToNextObject)
                    {
                        blnSkipToNextObject = false;
                        continue;
                    }

                    // Get the biggest blob. Consider biggest blob is the side body
                    fLimitCenterX = m_objEBlobs.ref_arrLimitCenterX[i];
                    fLimitCenterY = m_objEBlobs.ref_arrLimitCenterY[i];
                    fWidth = m_objEBlobs.ref_arrWidth[i];
                    fHeight = m_objEBlobs.ref_arrHeight[i];
                    fOrgX = fLimitCenterX - fWidth / 2;
                    fOrgY = fLimitCenterY - fHeight / 2;
                    intTotalArea = 0;
                    fTotalCenterX = 0;
                    fTotalCenterY = 0;
                    fTotalLimitCenterX = 0;
                    fTotalLimitCenterY = 0;
                    fStartX = fOrgX;
                    fStartY = fOrgY;
                    fEndX = fOrgX + fWidth;
                    fEndY = fOrgY + fHeight;
                    intSelectedBlob = 0;
                    intTotalBlobCount = 0;

                    //2021-08-28 ZJYEOH: Use largest blob as Side Lead body, no need to consider other blob to filter noise build near mirror edge
                    //for (int j = i; j < m_objEBlobs.ref_intNumSelectedObject; j++)
                    //{

                    //    if (m_intLeadDirection == 0)
                    //    {
                    //        //Horizontal lead
                    //        if (m_objEBlobs.ref_arrLimitCenterY[j] < fOrgY || m_objEBlobs.ref_arrLimitCenterY[j] > (fOrgY + fHeight))
                    //            continue;
                    //    }
                    //    else
                    //    {
                    //        //Vertical lead
                    //        if (m_objEBlobs.ref_arrLimitCenterX[j] < fOrgX || m_objEBlobs.ref_arrLimitCenterX[j] > (fOrgX + fWidth))
                    //            continue;
                    //    }

                    //    // This segment is to handle the case when the largest blob builded is from the same lead
                    //    // Since the number of lead is predefined, each blob data collected must be from different lead
                    //    if (intSelectedObjectNum >= j && i != j)
                    //    {
                    //        if (m_objEBlobs.ref_intNumSelectedObject > intSelectedObjectNum)
                    //            intSelectedObjectNum++;
                    //        arrSkipNo.Add(j);
                    //    }

                    //    intTotalArea += m_objEBlobs.ref_arrArea[j];
                    //    fTotalCenterX += m_objEBlobs.ref_arrGravityCenterX[j] * m_objEBlobs.ref_arrArea[j];
                    //    fTotalCenterY += m_objEBlobs.ref_arrGravityCenterY[j] * m_objEBlobs.ref_arrArea[j];
                    //    //fTotalLimitCenterX += objEBlobs.ref_arrLimitCenterX[j] * objEBlobs.ref_arrArea[j];
                    //    //fTotalLimitCenterY += objEBlobs.ref_arrLimitCenterY[j] * objEBlobs.ref_arrArea[j];

                    //    if (fStartX > m_objEBlobs.ref_arrLimitCenterX[j] - (m_objEBlobs.ref_arrWidth[j] / 2))
                    //    {
                    //        fStartX = m_objEBlobs.ref_arrLimitCenterX[j] - (m_objEBlobs.ref_arrWidth[j] / 2);
                    //    }

                    //    if (fStartY > m_objEBlobs.ref_arrLimitCenterY[j] - (m_objEBlobs.ref_arrHeight[j] / 2))
                    //    {
                    //        fStartY = m_objEBlobs.ref_arrLimitCenterY[j] - (m_objEBlobs.ref_arrHeight[j] / 2);
                    //    }

                    //    if (fEndX < m_objEBlobs.ref_arrLimitCenterX[j] + (m_objEBlobs.ref_arrWidth[j] / 2))
                    //    {
                    //        fEndX = m_objEBlobs.ref_arrLimitCenterX[j] + (m_objEBlobs.ref_arrWidth[j] / 2);
                    //    }

                    //    if (fEndY < m_objEBlobs.ref_arrLimitCenterY[j] + (m_objEBlobs.ref_arrHeight[j] / 2))
                    //    {
                    //        fEndY = m_objEBlobs.ref_arrLimitCenterY[j] + (m_objEBlobs.ref_arrHeight[j] / 2);
                    //    }

                    //    intSelectedBlob |= (1 << j);
                    //    intTotalBlobCount++;
                    //}
                    
                    m_stcBlobLead = new BlobsFeatures();
                    m_stcBlobLead.fArea = m_objEBlobs.ref_arrArea[i]; //intTotalArea;
                    m_stcBlobLead.fCenterX = (fEndX + fStartX) / 2; //fTotalCenterX / intTotalArea;
                    m_stcBlobLead.fCenterY = (fEndY + fStartY) / 2; //fTotalCenterY / intTotalArea;
                    m_stcBlobLead.fLimitCenterX = (fEndX + fStartX) / 2; //fTotalLimitCenterX / intTotalArea;
                    m_stcBlobLead.fLimitCenterY = (fEndY + fStartY) / 2; //fTotalLimitCenterY / intTotalArea;
                    m_stcBlobLead.fWidth = fEndX - fStartX;
                    m_stcBlobLead.fHeight = fEndY - fStartY;

                    fBorderDistanceX = Math.Min(m_stcBlobLead.fLimitCenterX, objROI.ref_ROIWidth - m_stcBlobLead.fLimitCenterX);
                    fBorderDistanceY = Math.Min(m_stcBlobLead.fLimitCenterY, objROI.ref_ROIHeight - m_stcBlobLead.fLimitCenterY);

                    if ((fBorderDistanceX / fBorderDistanceY) < 0.7) // point x closer to border compare with point y
                    {
                        m_stcBlobLead.intLengthMode = 2;   // 2 mean length == width OR set Width == fHeight, Length == fWidth
                    }
                    else if ((fBorderDistanceY / fBorderDistanceX) < 0.7)   // point y closer to border compare with point x
                    {
                        m_stcBlobLead.intLengthMode = 1;   // 1 mean length == height OR set Width == fWidth, Length == fHeight
                    }
                    else
                    {
                        if (m_stcBlobLead.fWidth < m_stcBlobLead.fHeight)  // width shorter then height
                        {
                            m_stcBlobLead.intLengthMode = 1;   // 1 mean length == height
                        }
                        else
                        {
                            m_stcBlobLead.intLengthMode = 2;   // 2 mean length == width
                        }
                    }

                    m_stcBlobLead.intContourX = m_objEBlobs.ref_arrContourX[0];
                    m_stcBlobLead.intContourY = m_objEBlobs.ref_arrContourY[0];
                    m_stcBlobLead.intObjNo = 0;
                    m_stcBlobLead.fStartX = (float)Math.Round(fStartX, 4);
                    m_stcBlobLead.fEndX = (float)Math.Round(fEndX, 4);
                    m_stcBlobLead.fStartY = (float)Math.Round(fStartY, 4);
                    m_stcBlobLead.fEndY = (float)Math.Round(fEndY, 4);
                    m_stcBlobLead.intStartX = (int)Math.Round(fStartX, 0, MidpointRounding.AwayFromZero);
                    m_stcBlobLead.intEndX = (int)Math.Round(fEndX, 0, MidpointRounding.AwayFromZero);
                    m_stcBlobLead.intStartY = (int)Math.Round(fStartY, 0, MidpointRounding.AwayFromZero);
                    m_stcBlobLead.intEndY = (int)Math.Round(fEndY, 0, MidpointRounding.AwayFromZero);
                    m_stcBlobLead.blnSelected = true;
                    m_stcBlobLead.intDirection = -1;
                    m_stcBlobLead.intGroupID = 0;
                    //m_stcBlobLead.fPitch = -1;
                    m_stcBlobLead.intNoID = 0;
                    m_stcBlobLead.intSelectedBlob = intSelectedBlob;
                    m_arrSampleBlobBodyLeads.Add(m_stcBlobLead);
                }
            }
            objImg.Dispose();
            objInspectROI.Dispose();
            return FindUnitBaseLine(objROI, false);
        }
        public bool BuildSideLead(ROI objROI, List<int> arrLeadID, List<PointF> arrLeadCenterPoints, List<SizeF> arrLeadSizeF, List<int> arrLeadDirection)
        {
            bool blnWantDebug = false;
            ROI objInspectROI = new ROI();
            objInspectROI.LoadROISetting(objROI.ref_ROIPositionX, objROI.ref_ROIPositionY, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
            ImageDrawing objImg = new ImageDrawing(true, objROI.ref_ROI.TopParent.Width, objROI.ref_ROI.TopParent.Height);
            objImg.SetImageToBlack();
            objInspectROI.AttachImage(objImg);
            objROI.CopyImage_Bigger(ref objInspectROI);

            //Subtract Dont Care Area
            if (m_blnWantDontCareArea_Lead3D)
            {
                if (blnWantDebug)
                {
                    objInspectROI.SaveImage("D:\\TS\\objROI.bmp");
                }
                ROI objDontCareROI = new ROI();
                objDontCareROI.LoadROISetting(0, 0, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
                objDontCareROI.AttachImage(m_objLead3DDontCareImage);
                ROI.LogicOperationAddROI(objInspectROI, objDontCareROI);
                objDontCareROI.Dispose();

                if (blnWantDebug)
                {
                    objInspectROI.SaveImage("D:\\TS\\objROI2.bmp");
                    objInspectROI.ref_ROI.TopParent.Save("D:\\TS\\Topparent.bmp");
                }
            }

            ROI objTempROI = new ROI();
            bool[] arrLeadFound = new bool[arrLeadID.Count];
            int intPixelOffsetFromBase = 5;
            m_arrSampleBlobSideLeads.Clear();

            do
            {

                objTempROI.AttachROITopParrent(objInspectROI);

                switch (m_intLeadROIDirection)
                {
                    case 1:
                        objTempROI.LoadROISetting(objROI.ref_ROIPositionX, objROI.ref_ROIPositionY, objROI.ref_ROIWidth, objROI.ref_ROIHeight - (int)(objROI.ref_ROIPositionY + objROI.ref_ROIHeight - (m_objLineGauge.ref_ObjectCenterY - intPixelOffsetFromBase)));
                        break;
                    case 3:
                        objTempROI.LoadROISetting(objROI.ref_ROIPositionX, (int)m_objLineGauge.ref_ObjectCenterY + intPixelOffsetFromBase, objROI.ref_ROIWidth, objROI.ref_ROIHeight - (int)((m_objLineGauge.ref_ObjectCenterY + intPixelOffsetFromBase) - objROI.ref_ROIPositionY));
                        break;
                    case 4:
                        objTempROI.LoadROISetting(objROI.ref_ROIPositionX, objROI.ref_ROIPositionY, objROI.ref_ROIWidth - (int)(objROI.ref_ROIPositionX + objROI.ref_ROIWidth - (m_objLineGauge.ref_ObjectCenterX - intPixelOffsetFromBase)), objROI.ref_ROIHeight);
                        break;
                    case 2:
                        objTempROI.LoadROISetting((int)m_objLineGauge.ref_ObjectCenterX + intPixelOffsetFromBase, objROI.ref_ROIPositionY, objROI.ref_ROIWidth - (int)((m_objLineGauge.ref_ObjectCenterX + intPixelOffsetFromBase) - objROI.ref_ROIPositionX), objROI.ref_ROIHeight);
                        break;
                }

                if (blnWantDebug)
                {
                    objTempROI.SaveImage("D:\\TS\\objTempROI" + intPixelOffsetFromBase.ToString() + ".bmp");
                }
                
                // Build blobs
                BuildOnlySideLeadObjects_BlackObject(objTempROI, 10);

                //if (m_objEBlobs.ref_intNumSelectedObject > 0 && m_objEBlobs.ref_intNumSelectedObject == arrLeadID.Count)
                if (m_objEBlobs.ref_intNumSelectedObject > 0)
                {
                    float fCenterX;
                    float fCenterY;
                    float fWidth;
                    float fHeight;
                    int intSelectedBlob = 0;
                    float fStartX;
                    float fStartY;
                    float fEndX;
                    float fEndY;

                    for (int i = 0; i < m_objEBlobs.ref_intNumSelectedObject; i++)
                    {
                        m_stcBlobLead = new BlobsFeatures();
                        fCenterX = objTempROI.ref_ROIPositionX + m_objEBlobs.ref_arrLimitCenterX[i];
                        fCenterY = objTempROI.ref_ROIPositionY + m_objEBlobs.ref_arrLimitCenterY[i];
                        fWidth = m_objEBlobs.ref_arrWidth[i];
                        fHeight = m_objEBlobs.ref_arrHeight[i];
                        fStartX = fCenterX - (fWidth / 2);
                        fStartY = fCenterY - (fHeight / 2);
                        fEndX = fStartX + fWidth;
                        fEndY = fStartY + fHeight;
                        intSelectedBlob = 0;
                        bool blnFound = false;
                        for (int j = 0; j < arrLeadID.Count; j++)
                        {

                            switch (arrLeadDirection[j])
                            {
                                case 4:
                                    if (m_intLeadROIDirection == 1)
                                    {
                                        if (fCenterX > (arrLeadCenterPoints[j].X - (arrLeadSizeF[j].Width / 2)) &&
                                     fCenterX < (arrLeadCenterPoints[j].X + (arrLeadSizeF[j].Width / 2)))
                                        {
                                            m_stcBlobLead.intNoID = arrLeadID[j];
                                            blnFound = true;
                                            goto Skip;
                                        }
                                    }
                                    break;
                                case 8:
                                    if (m_intLeadROIDirection == 3)
                                    {
                                        if (fCenterX > (arrLeadCenterPoints[j].X - (arrLeadSizeF[j].Width / 2)) &&
                                           fCenterX < (arrLeadCenterPoints[j].X + (arrLeadSizeF[j].Width / 2)))
                                        {
                                            m_stcBlobLead.intNoID = arrLeadID[j];
                                            blnFound = true;
                                            goto Skip;
                                        }
                                    }
                                    break;
                                case 1:
                                    if (m_intLeadROIDirection == 4)
                                    {
                                        if (fCenterY > (arrLeadCenterPoints[j].Y - (arrLeadSizeF[j].Height / 2)) &&
                                       fCenterY < (arrLeadCenterPoints[j].Y + (arrLeadSizeF[j].Height / 2)))
                                        {
                                            //if (!arrLeadFound[j])
                                            {
                                                //arrLeadFound[j] = true;
                                                m_stcBlobLead.intNoID = arrLeadID[j];
                                                blnFound = true;
                                                goto Skip;
                                            }
                                        }
                                    }
                                    break;
                                case 2:
                                    if (m_intLeadROIDirection == 2)
                                    {
                                        if (fCenterY > (arrLeadCenterPoints[j].Y - (arrLeadSizeF[j].Height / 2)) &&
                                            fCenterY < (arrLeadCenterPoints[j].Y + (arrLeadSizeF[j].Height / 2)))
                                        {
                                            m_stcBlobLead.intNoID = arrLeadID[j];
                                            blnFound = true;
                                            goto Skip;
                                        }
                                    }
                                    break;
                            }

                        }

                        Skip:
                        if (!blnFound)
                        {
                            //objImg.Dispose();
                            //objInspectROI.Dispose();
                            //objTempROI.Dispose();
                            //return false;
                        }
                        else
                        {
                            // check if already exist
                            bool blnAlreadyExist = false;
                            int k;
                            for (k = 0; k < m_arrSampleBlobSideLeads.Count; k++)
                            {
                                if (m_arrSampleBlobSideLeads[k].intNoID == m_stcBlobLead.intNoID)
                                {
                                    blnAlreadyExist = true;
                                    break;
                                }
                            }

                            if (blnAlreadyExist)
                            {
                                BlobsFeatures objSelectedBlobFeatures = m_arrSampleBlobSideLeads[k];
                                if (objSelectedBlobFeatures.fStartX > (float)Math.Round(fStartX, 4))
                                {
                                    objSelectedBlobFeatures.fStartX = (float)Math.Round(fStartX, 4);
                                }
                                if (objSelectedBlobFeatures.fStartY > (float)Math.Round(fStartY, 4))
                                {
                                    objSelectedBlobFeatures.fStartY = (float)Math.Round(fStartY, 4);
                                }
                                if (objSelectedBlobFeatures.fEndX > (float)Math.Round(fEndX, 4))
                                {
                                    objSelectedBlobFeatures.fEndX = (float)Math.Round(fEndX, 4);
                                }
                                if (objSelectedBlobFeatures.fEndX > (float)Math.Round(fEndX, 4))
                                {
                                    objSelectedBlobFeatures.fEndX = (float)Math.Round(fEndX, 4);
                                }
                                int intValue = (int)Math.Round(fStartX, 0, MidpointRounding.AwayFromZero);
                                if (objSelectedBlobFeatures.intStartX > intValue)
                                {
                                    objSelectedBlobFeatures.intStartX = intValue;
                                }
                                intValue = (int)Math.Round(fStartY, 0, MidpointRounding.AwayFromZero);
                                if (objSelectedBlobFeatures.intStartY > intValue)
                                {
                                    objSelectedBlobFeatures.intStartY = intValue;
                                }
                                intValue = (int)Math.Round(fEndX, 0, MidpointRounding.AwayFromZero);
                                if (objSelectedBlobFeatures.intEndX > intValue)
                                {
                                    objSelectedBlobFeatures.intEndX = intValue;
                                }
                                intValue = (int)Math.Round(fEndY, 0, MidpointRounding.AwayFromZero);
                                if (objSelectedBlobFeatures.intEndY > intValue)
                                {
                                    objSelectedBlobFeatures.intEndY = intValue;
                                }
                                objSelectedBlobFeatures.fWidth = objSelectedBlobFeatures.fEndX - objSelectedBlobFeatures.fStartX;
                                objSelectedBlobFeatures.fHeight = objSelectedBlobFeatures.fEndY - objSelectedBlobFeatures.fStartY;
                                objSelectedBlobFeatures.fCenterX = (objSelectedBlobFeatures.fEndX + objSelectedBlobFeatures.fStartX) / 2;
                                objSelectedBlobFeatures.fCenterY = (objSelectedBlobFeatures.fEndY + objSelectedBlobFeatures.fStartY) / 2;

                                objSelectedBlobFeatures.blnSelected = true;
                                m_arrSampleBlobSideLeads[k] = objSelectedBlobFeatures;
                            }
                            else
                            {
                                m_stcBlobLead.fCenterX = fCenterX;
                                m_stcBlobLead.fCenterY = fCenterY;
                                m_stcBlobLead.fWidth = fWidth;
                                m_stcBlobLead.fHeight = fHeight;
                                m_stcBlobLead.fStartX = (float)Math.Round(fStartX, 4);
                                m_stcBlobLead.fEndX = (float)Math.Round(fEndX, 4);
                                m_stcBlobLead.fStartY = (float)Math.Round(fStartY, 4);
                                m_stcBlobLead.fEndY = (float)Math.Round(fEndY, 4);
                                m_stcBlobLead.intStartX = (int)Math.Round(fStartX, 0, MidpointRounding.AwayFromZero);
                                m_stcBlobLead.intEndX = (int)Math.Round(fEndX, 0, MidpointRounding.AwayFromZero);
                                m_stcBlobLead.intStartY = (int)Math.Round(fStartY, 0, MidpointRounding.AwayFromZero);
                                m_stcBlobLead.intEndY = (int)Math.Round(fEndY, 0, MidpointRounding.AwayFromZero);

                                m_stcBlobLead.blnSelected = true;

                                m_stcBlobLead.intSelectedBlob = intSelectedBlob;
                                m_arrSampleBlobSideLeads.Add(m_stcBlobLead);
                            }
                        }
                    }

                    if (m_arrSampleBlobSideLeads.Count == arrLeadID.Count)
                    {
                        objImg.Dispose();
                        objInspectROI.Dispose();
                        objTempROI.Dispose();
                        return true;
                    }
                }

                intPixelOffsetFromBase--;

            } while (intPixelOffsetFromBase >= 1);

            objImg.Dispose();
            objInspectROI.Dispose();
            objTempROI.Dispose();
            m_blnBuildSideLeadSuccess = false;
            return false;

        }
        private void AddCornerPointGaugePlacementToArray(float fCenterX, float fCenterY, float fTolerance, float fAngle)
        {
            //    Left = 0
            //    Right = 1

            m_arrLead3DCornerPointGaugeStartX.Add(new List<float>());
            m_arrLead3DCornerPointGaugeStartX[m_arrLead3DCornerPointGaugeStartX.Count - 1].Add(fCenterX);
            m_arrLead3DCornerPointGaugeStartX[m_arrLead3DCornerPointGaugeStartX.Count - 1].Add(-1);

            m_arrLead3DCornerPointGaugeStartY.Add(new List<float>());
            m_arrLead3DCornerPointGaugeStartY[m_arrLead3DCornerPointGaugeStartY.Count - 1].Add(fCenterY);
            m_arrLead3DCornerPointGaugeStartY[m_arrLead3DCornerPointGaugeStartY.Count - 1].Add(-1);

            m_arrLead3DCornerPointGaugeTolerance.Add(new List<float>());
            m_arrLead3DCornerPointGaugeTolerance[m_arrLead3DCornerPointGaugeTolerance.Count - 1].Add(fTolerance);
            m_arrLead3DCornerPointGaugeTolerance[m_arrLead3DCornerPointGaugeTolerance.Count - 1].Add(-1);

            m_arrLead3DCornerPointGaugeAngle.Add(new List<float>());
            m_arrLead3DCornerPointGaugeAngle[m_arrLead3DCornerPointGaugeAngle.Count - 1].Add(fAngle);
            m_arrLead3DCornerPointGaugeAngle[m_arrLead3DCornerPointGaugeAngle.Count - 1].Add(-1);
        }
        private void SetCornerPointGaugePlacementToArray(float fCenterX, float fCenterY, float fTolerance, float fAngle, int intPosition)
        {
            //    Left = 0
            //    Right = 1

            m_arrLead3DCornerPointGaugeStartX[m_arrLead3DCornerPointGaugeStartX.Count - 1][intPosition] = fCenterX;
            m_arrLead3DCornerPointGaugeStartY[m_arrLead3DCornerPointGaugeStartY.Count - 1][intPosition] = fCenterY;
            m_arrLead3DCornerPointGaugeTolerance[m_arrLead3DCornerPointGaugeTolerance.Count - 1][intPosition] = fTolerance;
            m_arrLead3DCornerPointGaugeAngle[m_arrLead3DCornerPointGaugeAngle.Count - 1][intPosition] = fAngle;
        }
        public bool FindUnitBaseLine(ROI objSearchROI, bool blnUseTemplateBlobBodyLeads)
        {
            /* Top ROI for example:
             * 1. Get center point of base line. 
             *      - Attach line guage on unit base line with line gauge position at center of ROI width, guage length 20 only.
             * 2. After get the center point, get the center blob
             *      - attach a small ROI base line based on the center point. 
             *      - The small ROI width size same as Top search ROI. 
             *      - The small ROI height is around 10 pixels only. Height must not over than unit side line height.
             *      - build blob and get the center blob.
             * 3. Get base line angle.
             * 4. 
             */

            //2020-07-27 ZJYEOH : Threshold the image to filter noise come from lead reflect in body
            ImageDrawing objModifiedImage = new ImageDrawing(true, objSearchROI.ref_ROI.TopParent.Width, objSearchROI.ref_ROI.TopParent.Height);
            objModifiedImage.SetImageToBlack();
            ROI objROI = new ROI();
            objROI.LoadROISetting(objSearchROI.ref_ROIPositionX, objSearchROI.ref_ROIPositionY,
            objSearchROI.ref_ROIWidth, objSearchROI.ref_ROIHeight);
            objROI.AttachImage(objModifiedImage);
            objSearchROI.CopyImage_Bigger(ref objROI);

            //Subtract Dont Care Area
            if (m_blnWantDontCareArea_Lead3D)
            {
                //objInspectROI.SaveImage("D:\\objROI.bmp");
                ROI objDontCareROI = new ROI();
                objDontCareROI.LoadROISetting(0, 0, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
                objDontCareROI.AttachImage(m_objLead3DDontCareImage);
                ROI.LogicOperationAddROI(objROI, objDontCareROI);
                objDontCareROI.Dispose();
                //objInspectROI.SaveImage("D:\\objROI.bmp");
            }

            //objROI.SaveImage("D:\\TS\\objROI1.bmp");

            //objROI.ThresholdTo_ROIToROISamePosition_Bigger(ref objModifiedImage, m_intThresholdValue);

            //objROI.SaveImage("D:\\TS\\objROI2.bmp");

            m_arrLead3DCornerPointGaugeStartX.Clear();
            m_arrLead3DCornerPointGaugeStartY.Clear();
            m_arrLead3DCornerPointGaugeTolerance.Clear();
            m_arrLead3DCornerPointGaugeAngle.Clear();
            m_arrLead3DEdgeCornerGaugePoints.Clear();
            m_arrLead3DEdgeCornerGaugePointsFound.Clear();

            //if (m_objCornerPointGauge.ref_GaugeTransType != 1)
            //    m_objCornerPointGauge.ref_GaugeTransType = 1;     // white to black

            // Constant Variables
            int intBodyEdgeOffsetFromBase = 20;

            if (m_blnWhiteOnBlack)
                m_blnWhiteOnBlack = false;  // Side base line image is always black on white

            BlobsFeatures stcBlobsFeatures;
            if (blnUseTemplateBlobBodyLeads)
            {
                if (m_arrTemplateBlobBodyLeads.Count == 0)
                {
                    m_strErrorMessage = "*Fail to Find Base Line.";
                    objModifiedImage.Dispose();
                    objROI.Dispose();

                    return false;
                }
                stcBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobBodyLeads[0];  // First blob is the side ROI unit blob.
            }
            else
            {
                if (m_arrSampleBlobBodyLeads.Count == 0)
                {
                    m_strErrorMessage = "*Fail to Find Base Line.";
                    objModifiedImage.Dispose();
                    objROI.Dispose();

                    return false;
                }
                stcBlobsFeatures = m_arrSampleBlobBodyLeads[0];
            }

            bool blnGetBaselinePointOK = false;
            PointF pBaselinePoint = new PointF();
            float fStartX = 0, fStartY = 0, fEndX = 0, fEndY = 0, fCenterX = 0, fCenterY = 0, fWidth = 0, fHeight = 0;
            int intLocalROITolerance = 5;
            if (m_intLeadDirection == 0)    // Horizontal
            {

                switch (m_intLeadROIDirection)
                {
                    case 1: // Top ROI
                        {
                            // ------- Get outer point ------------------------
                            m_objLineGauge.SetGaugePlacement(objROI.ref_ROITotalX + stcBlobsFeatures.fLimitCenterX,
                                                    objROI.ref_ROITotalY + stcBlobsFeatures.fStartY,
                                                    stcBlobsFeatures.fHeight, 20, 0);
                            m_objLineGauge.ref_GaugeThreshold = (m_arrCornerPointGauge[(int)PointIndex_Corner.Corner1].ref_GaugeThreshold + m_arrCornerPointGauge[(int)PointIndex_Corner.Corner2].ref_GaugeThreshold) / 2; //20
                            m_objLineGauge.ref_GaugeThickness = 20;
                            m_objLineGauge.Measure(objROI);

                            blnGetBaselinePointOK = m_objLineGauge.GetMeasurementSampleCenterPoints(objROI, 10, ref pBaselinePoint);

                            // -------- Get center blob --------------------------------------
                            m_objLocalROI.AttachImage(objROI);
                            m_objLocalROI.LoadROISetting(0, (int)pBaselinePoint.Y - intLocalROITolerance - objROI.ref_ROITotalY, objROI.ref_ROIWidth, intBodyEdgeOffsetFromBase + intLocalROITolerance);

                            BuildOnlySideLeadObjects_BlackObject(m_objLocalROI);

                            if (m_objEBlobs.ref_intNumSelectedObject > 0)
                            {
                                // Get center blobs information
                                if (m_objEBlobs.ref_intNumSelectedObject == 1)
                                {
                                    fStartX = m_objEBlobs.ref_arrLimitCenterX[0] - m_objEBlobs.ref_arrWidth[0] / 2;
                                    fStartY = m_objEBlobs.ref_arrLimitCenterY[0] - m_objEBlobs.ref_arrHeight[0] / 2;
                                    fEndX = m_objEBlobs.ref_arrLimitCenterX[0] + m_objEBlobs.ref_arrWidth[0] / 2;
                                    fEndY = m_objEBlobs.ref_arrLimitCenterY[0] + m_objEBlobs.ref_arrHeight[0] / 2;
                                    fCenterX = m_objEBlobs.ref_arrLimitCenterX[0];
                                    fCenterY = m_objEBlobs.ref_arrLimitCenterY[0];
                                    fWidth = m_objEBlobs.ref_arrWidth[0];
                                    fHeight = m_objEBlobs.ref_arrHeight[0];
                                }
                                else
                                {
                                    float fMinStartX = float.MaxValue;
                                    float fMaxEndX = float.MinValue;
                                    for (int i = 0; i < m_objEBlobs.ref_intNumSelectedObject; i++)
                                    {
                                        fStartX = m_objEBlobs.ref_arrLimitCenterX[i] - m_objEBlobs.ref_arrWidth[i] / 2;
                                        fEndX = m_objEBlobs.ref_arrLimitCenterX[i] + m_objEBlobs.ref_arrWidth[i] / 2;

                                        if (fMinStartX > fStartX)
                                            fMinStartX = fStartX;   // get smallest start x

                                        if (fMaxEndX < fEndX)
                                            fMaxEndX = fEndX;       // get biggest end x
                                    }

                                    int intSelectedObjectInddex = -1;
                                    float fNearestCenter = float.MaxValue;
                                    float fNorminalCenterX = (fMinStartX + fMaxEndX) / 2;
                                    for (int i = 0; i < m_objEBlobs.ref_intNumSelectedObject; i++)
                                    {
                                        if (fNearestCenter > Math.Abs(m_objEBlobs.ref_arrLimitCenterX[i] - fNorminalCenterX))
                                        {
                                            fNearestCenter = Math.Abs(m_objEBlobs.ref_arrLimitCenterX[i] - fNorminalCenterX);
                                            intSelectedObjectInddex = i;
                                        }
                                    }

                                    fStartX = m_objEBlobs.ref_arrLimitCenterX[intSelectedObjectInddex] - m_objEBlobs.ref_arrWidth[intSelectedObjectInddex] / 2;
                                    fStartY = m_objEBlobs.ref_arrLimitCenterY[intSelectedObjectInddex] - m_objEBlobs.ref_arrHeight[intSelectedObjectInddex] / 2;
                                    fEndX = m_objEBlobs.ref_arrLimitCenterX[intSelectedObjectInddex] + m_objEBlobs.ref_arrWidth[intSelectedObjectInddex] / 2;
                                    fEndY = m_objEBlobs.ref_arrLimitCenterY[intSelectedObjectInddex] + m_objEBlobs.ref_arrHeight[intSelectedObjectInddex] / 2;
                                    fCenterX = m_objEBlobs.ref_arrLimitCenterX[intSelectedObjectInddex];
                                    fCenterY = m_objEBlobs.ref_arrLimitCenterY[intSelectedObjectInddex];
                                    fWidth = m_objEBlobs.ref_arrWidth[intSelectedObjectInddex];
                                    fHeight = m_objEBlobs.ref_arrHeight[intSelectedObjectInddex];

                                }

                                // Remeasure on center blob to get base line.
                                m_objLineGauge.SetGaugePlacement(m_objLocalROI.ref_ROITotalX + fCenterX,
                                                        pBaselinePoint.Y, 10, fWidth, 0);

                                m_objLineGauge.Measure(m_objLocalROI);

                                pBaselinePoint = new PointF(m_objLineGauge.ref_ObjectCenterX, m_objLineGauge.ref_ObjectCenterY);

                                blnGetBaselinePointOK = true;
                            }
                        }
                        break;
                    case 2: // Right ROI
                        {
                            m_objLineGauge.ref_GaugeThreshold = (m_arrCornerPointGauge[(int)PointIndex_Corner.Corner1].ref_GaugeThreshold + m_arrCornerPointGauge[(int)PointIndex_Corner.Corner2].ref_GaugeThreshold) / 2; //20
                            m_objLineGauge.ref_GaugeThickness = 20;
                            m_objLineGauge.SetGaugePlacement(objROI.ref_ROITotalX + stcBlobsFeatures.fEndX,
                                                                                objROI.ref_ROITotalY + stcBlobsFeatures.fLimitCenterY,
                                                                                stcBlobsFeatures.fWidth, stcBlobsFeatures.fHeight - m_intBaseLineTrimFromEdge * 2, 90);

                            m_objLineGauge.Measure(objROI);

                            bool blnResetToPrevious = false;
                            for (int i = 0; i < m_intBaseLineSteps; i++)
                            {
                                float fBaseLineReferencePointX = m_objLineGauge.ref_ObjectCenterX;
                                float fLineGaugeTolerance = (fBaseLineReferencePointX - objROI.ref_ROITotalX + stcBlobsFeatures.fStartX) / 2;
                                m_objLineGauge.SetGaugePlacement(fBaseLineReferencePointX - fLineGaugeTolerance,
                                                                                    objROI.ref_ROITotalY + stcBlobsFeatures.fLimitCenterY,
                                                                                    fLineGaugeTolerance, stcBlobsFeatures.fHeight - m_intBaseLineTrimFromEdge * 2, 90);

                                //m_objLineGauge.Measure(objROI);
                                m_objLineGauge.Measure_SubGaugePoints_UsingMainLineGauge(objROI);//2021-09-08 ZJYEOH: Use sub gauge measurement to find closest sample point

                                if (m_objLineGauge.ref_ObjectScore < 30)
                                {
                                    blnResetToPrevious = true;
                                    break;
                                }
                            }

                            if (blnResetToPrevious)
                            {
                                m_objLineGauge.SetGaugePlacement(objROI.ref_ROITotalX + stcBlobsFeatures.fEndX,
                                                                                objROI.ref_ROITotalY + stcBlobsFeatures.fLimitCenterY,
                                                                                stcBlobsFeatures.fWidth, stcBlobsFeatures.fHeight - m_intBaseLineTrimFromEdge * 2, 90);

                                m_objLineGauge.Measure(objROI);
                            }
                            pBaselinePoint = new PointF(m_objLineGauge.ref_ObjectCenterX, m_objLineGauge.ref_ObjectCenterY);

                            blnGetBaselinePointOK = true;
                        }
                        break;
                    case 3: // Bottom ROI
                        {
                            // ------- Get outer point ------------------------
                            m_objLineGauge.SetGaugePlacement(objROI.ref_ROITotalX + stcBlobsFeatures.fLimitCenterX,
                                                    objROI.ref_ROITotalY + stcBlobsFeatures.fEndY,
                                                    stcBlobsFeatures.fHeight, 20, 180);
                            m_objLineGauge.ref_GaugeThreshold = (m_arrCornerPointGauge[(int)PointIndex_Corner.Corner1].ref_GaugeThreshold + m_arrCornerPointGauge[(int)PointIndex_Corner.Corner2].ref_GaugeThreshold) / 2; //20
                            m_objLineGauge.ref_GaugeThickness = 20;
                            m_objLineGauge.Measure(objROI);

                            blnGetBaselinePointOK = m_objLineGauge.GetMeasurementSampleCenterPoints(objROI, 10, ref pBaselinePoint);

                            // -------- Get center blob --------------------------------------
                            m_objLocalROI.AttachImage(objROI);
                            m_objLocalROI.LoadROISetting(0, (int)pBaselinePoint.Y - intBodyEdgeOffsetFromBase - objROI.ref_ROITotalY,
                                                        objROI.ref_ROIWidth, intBodyEdgeOffsetFromBase + intLocalROITolerance);

                            BuildOnlySideLeadObjects_BlackObject(m_objLocalROI);

                            if (m_objEBlobs.ref_intNumSelectedObject > 0)
                            {
                                // Get center blobs information
                                if (m_objEBlobs.ref_intNumSelectedObject == 1)
                                {
                                    fStartX = m_objEBlobs.ref_arrLimitCenterX[0] - m_objEBlobs.ref_arrWidth[0] / 2;
                                    fStartY = m_objEBlobs.ref_arrLimitCenterY[0] - m_objEBlobs.ref_arrHeight[0] / 2;
                                    fEndX = m_objEBlobs.ref_arrLimitCenterX[0] + m_objEBlobs.ref_arrWidth[0] / 2;
                                    fEndY = m_objEBlobs.ref_arrLimitCenterY[0] + m_objEBlobs.ref_arrHeight[0] / 2;
                                    fCenterX = m_objEBlobs.ref_arrLimitCenterX[0];
                                    fCenterY = m_objEBlobs.ref_arrLimitCenterY[0];
                                    fWidth = m_objEBlobs.ref_arrWidth[0];
                                    fHeight = m_objEBlobs.ref_arrHeight[0];
                                }
                                else
                                {
                                    float fMinStartX = float.MaxValue;
                                    float fMaxEndX = float.MinValue;
                                    for (int i = 0; i < m_objEBlobs.ref_intNumSelectedObject; i++)
                                    {
                                        fStartX = m_objEBlobs.ref_arrLimitCenterX[i] - m_objEBlobs.ref_arrWidth[i] / 2;
                                        fEndX = m_objEBlobs.ref_arrLimitCenterX[i] + m_objEBlobs.ref_arrWidth[i] / 2;

                                        if (fMinStartX > fStartX)
                                            fMinStartX = fStartX;   // get smallest start x

                                        if (fMaxEndX < fEndX)
                                            fMaxEndX = fEndX;       // get biggest end x
                                    }

                                    int intSelectedObjectInddex = -1;
                                    float fNearestCenter = float.MaxValue;
                                    float fNorminalCenterX = (fMinStartX + fMaxEndX) / 2;
                                    for (int i = 0; i < m_objEBlobs.ref_intNumSelectedObject; i++)
                                    {
                                        if (fNearestCenter > Math.Abs(m_objEBlobs.ref_arrLimitCenterX[i] - fNorminalCenterX))
                                        {
                                            fNearestCenter = Math.Abs(m_objEBlobs.ref_arrLimitCenterX[i] - fNorminalCenterX);
                                            intSelectedObjectInddex = i;
                                        }
                                    }

                                    fStartX = m_objEBlobs.ref_arrLimitCenterX[intSelectedObjectInddex] - m_objEBlobs.ref_arrWidth[intSelectedObjectInddex] / 2;
                                    fStartY = m_objEBlobs.ref_arrLimitCenterY[intSelectedObjectInddex] - m_objEBlobs.ref_arrHeight[intSelectedObjectInddex] / 2;
                                    fEndX = m_objEBlobs.ref_arrLimitCenterX[intSelectedObjectInddex] + m_objEBlobs.ref_arrWidth[intSelectedObjectInddex] / 2;
                                    fEndY = m_objEBlobs.ref_arrLimitCenterY[intSelectedObjectInddex] + m_objEBlobs.ref_arrHeight[intSelectedObjectInddex] / 2;
                                    fCenterX = m_objEBlobs.ref_arrLimitCenterX[intSelectedObjectInddex];
                                    fCenterY = m_objEBlobs.ref_arrLimitCenterY[intSelectedObjectInddex];
                                    fWidth = m_objEBlobs.ref_arrWidth[intSelectedObjectInddex];
                                    fHeight = m_objEBlobs.ref_arrHeight[intSelectedObjectInddex];

                                }

                                // Remeasure to get base line
                                m_objLineGauge.SetGaugePlacement(m_objLocalROI.ref_ROITotalX + fCenterX,
                                                        pBaselinePoint.Y, 10, fWidth, 180);

                                m_objLineGauge.Measure(m_objLocalROI);

                                pBaselinePoint = new PointF(m_objLineGauge.ref_ObjectCenterX, m_objLineGauge.ref_ObjectCenterY);

                                blnGetBaselinePointOK = true;
                            }
                        }
                        break;
                    case 4: // Left ROI
                        {
                            m_objLineGauge.ref_GaugeThreshold = (m_arrCornerPointGauge[(int)PointIndex_Corner.Corner1].ref_GaugeThreshold + m_arrCornerPointGauge[(int)PointIndex_Corner.Corner2].ref_GaugeThreshold) / 2; //20
                            m_objLineGauge.ref_GaugeThickness = 20;
                            // Gauge center at lead blob start point
                            // Gauge Tolerance == lead blob width
                            m_objLineGauge.SetGaugePlacement(objROI.ref_ROITotalX + stcBlobsFeatures.fStartX,
                                                                                objROI.ref_ROITotalY + stcBlobsFeatures.fLimitCenterY,
                                                                                    stcBlobsFeatures.fWidth, stcBlobsFeatures.fHeight - m_intBaseLineTrimFromEdge * 2, -90);


                            m_objLineGauge.Measure(objROI);

                            bool blnResetToPrevious = false;
                            for (int i = 0; i < m_intBaseLineSteps; i++)
                            {
                                float fBaseLineReferencePointX = m_objLineGauge.ref_ObjectCenterX;
                                // Gauge Range from previous base line center point until lead blob end point.
                                float fLineGaugeTolerance = (objROI.ref_ROITotalX + stcBlobsFeatures.fEndX - fBaseLineReferencePointX) / 2;
                                m_objLineGauge.SetGaugePlacement(fBaseLineReferencePointX + fLineGaugeTolerance,
                                                                                    objROI.ref_ROITotalY + stcBlobsFeatures.fLimitCenterY,
                                                                                    fLineGaugeTolerance, stcBlobsFeatures.fHeight - m_intBaseLineTrimFromEdge * 2, -90);

                                //m_objLineGauge.Measure(objROI);
                                m_objLineGauge.Measure_SubGaugePoints_UsingMainLineGauge(objROI);//2021-09-08 ZJYEOH: Use sub gauge measurement to find closest sample point

                                // 2020 11 10 - Gauge valid score fail mean cannot find the base edge
                                if (m_objLineGauge.ref_ObjectScore < 30)
                                {
                                    blnResetToPrevious = true;
                                    break;
                                }
                            }

                            // 2020 11 10 - if not able to find the base adge, then need to reset to the first one. (this code applicable for m_intBaseLineSteps = 1. Need to double check this sequence if m_intBaseLineSteps > 1)
                            if (blnResetToPrevious)
                            {
                                m_objLineGauge.SetGaugePlacement(objROI.ref_ROITotalX + stcBlobsFeatures.fStartX,
                                                                                    objROI.ref_ROITotalY + stcBlobsFeatures.fLimitCenterY,
                                                                                        stcBlobsFeatures.fWidth, stcBlobsFeatures.fHeight - m_intBaseLineTrimFromEdge * 2, -90);

                                m_objLineGauge.Measure(objROI);
                            }

                            pBaselinePoint = new PointF(m_objLineGauge.ref_ObjectCenterX, m_objLineGauge.ref_ObjectCenterY);

                            blnGetBaselinePointOK = true;
                        }
                        break;
                    default:
                        objModifiedImage.Dispose();
                        objROI.Dispose();

                        return false;   // no center ROI because no base line measurement for center ROI.
                }
            }
            else
            {

                switch (m_intLeadROIDirection)
                {
                    case 1: // Top ROI
                        {
                            m_objLineGauge.ref_GaugeThreshold = (m_arrCornerPointGauge[(int)PointIndex_Corner.Corner1].ref_GaugeThreshold + m_arrCornerPointGauge[(int)PointIndex_Corner.Corner2].ref_GaugeThreshold) / 2; //20
                            m_objLineGauge.ref_GaugeThickness = 20;
                            m_objLineGauge.SetGaugePlacement(objROI.ref_ROITotalX + stcBlobsFeatures.fLimitCenterX,
                                                             objROI.ref_ROITotalY + stcBlobsFeatures.fStartY,
                                                             stcBlobsFeatures.fHeight, stcBlobsFeatures.fWidth - m_intBaseLineTrimFromEdge * 2, 0);

                            m_objLineGauge.Measure(objROI);

                            bool blnResetToPrevious = false;
                            for (int i = 0; i < m_intBaseLineSteps; i++)
                            {
                                float fBaseLineReferencePointY = m_objLineGauge.ref_ObjectCenterY;
                                float fLineGaugeTolerance = (objROI.ref_ROITotalY + stcBlobsFeatures.fEndY - fBaseLineReferencePointY) / 2;
                                m_objLineGauge.SetGaugePlacement(objROI.ref_ROITotalX + stcBlobsFeatures.fLimitCenterX,
                                                                 fBaseLineReferencePointY + fLineGaugeTolerance,
                                                                 fLineGaugeTolerance, stcBlobsFeatures.fWidth - m_intBaseLineTrimFromEdge * 2, 0);

                                //m_objLineGauge.Measure(objROI);
                                m_objLineGauge.Measure_SubGaugePoints_UsingMainLineGauge(objROI);//2021-09-08 ZJYEOH: Use sub gauge measurement to find closest sample point

                                // 2020 11 10 - Gauge valid score fail mean cannot find the base edge
                                if (m_objLineGauge.ref_ObjectScore < 30)
                                {
                                    blnResetToPrevious = true;
                                    break;
                                }
                            }

                            // 2020 11 10 - if not able to find the base adge, then need to reset to the first one. (this code applicable for m_intBaseLineSteps = 1. Need to double check this sequence if m_intBaseLineSteps > 1)
                            if (blnResetToPrevious)
                            {
                                m_objLineGauge.SetGaugePlacement(objROI.ref_ROITotalX + stcBlobsFeatures.fLimitCenterX,
                                                                 objROI.ref_ROITotalY + stcBlobsFeatures.fStartY,
                                                                 stcBlobsFeatures.fHeight, stcBlobsFeatures.fWidth - m_intBaseLineTrimFromEdge * 2, 0);

                                m_objLineGauge.Measure(objROI);
                            }

                            pBaselinePoint = new PointF(m_objLineGauge.ref_ObjectCenterX, m_objLineGauge.ref_ObjectCenterY);

                            blnGetBaselinePointOK = true;
                        }
                        break;

                    case 2: // Right ROI
                        {
                            // ------- Get outer point ------------------------
                            m_objLineGauge.SetGaugePlacement(objROI.ref_ROITotalX + stcBlobsFeatures.fEndX,
                                                             objROI.ref_ROITotalY + stcBlobsFeatures.fLimitCenterY,
                                                             stcBlobsFeatures.fWidth, 20, 90);

                            m_objLineGauge.ref_GaugeThreshold = (m_arrCornerPointGauge[(int)PointIndex_Corner.Corner1].ref_GaugeThreshold + m_arrCornerPointGauge[(int)PointIndex_Corner.Corner2].ref_GaugeThreshold) / 2; //20
                            m_objLineGauge.ref_GaugeThickness = 20;
                            m_objLineGauge.Measure(objROI);

                            blnGetBaselinePointOK = m_objLineGauge.GetMeasurementSampleCenterPoints(objROI, 10, ref pBaselinePoint);

                            // -------- Get center blob --------------------------------------
                            m_objLocalROI.AttachImage(objROI);
                            m_objLocalROI.LoadROISetting((int)pBaselinePoint.X - intBodyEdgeOffsetFromBase - objROI.ref_ROITotalX, 0,
                                                        intBodyEdgeOffsetFromBase + intLocalROITolerance, objROI.ref_ROIHeight);

                            BuildOnlySideLeadObjects_BlackObject(m_objLocalROI);

                            if (m_objEBlobs.ref_intNumSelectedObject > 0)
                            {
                                // Get center blobs information
                                if (m_objEBlobs.ref_intNumSelectedObject == 1)
                                {
                                    fStartX = m_objEBlobs.ref_arrLimitCenterX[0] - m_objEBlobs.ref_arrWidth[0] / 2;
                                    fStartY = m_objEBlobs.ref_arrLimitCenterY[0] - m_objEBlobs.ref_arrHeight[0] / 2;
                                    fEndX = m_objEBlobs.ref_arrLimitCenterX[0] + m_objEBlobs.ref_arrWidth[0] / 2;
                                    fEndY = m_objEBlobs.ref_arrLimitCenterY[0] + m_objEBlobs.ref_arrHeight[0] / 2;
                                    fCenterX = m_objEBlobs.ref_arrLimitCenterX[0];
                                    fCenterY = m_objEBlobs.ref_arrLimitCenterY[0];
                                    fWidth = m_objEBlobs.ref_arrWidth[0];
                                    fHeight = m_objEBlobs.ref_arrHeight[0];
                                }
                                else
                                {
                                    float fMinStartY = float.MaxValue;
                                    float fMaxEndY = float.MinValue;
                                    for (int i = 0; i < m_objEBlobs.ref_intNumSelectedObject; i++)
                                    {
                                        fStartY = m_objEBlobs.ref_arrLimitCenterY[i] - m_objEBlobs.ref_arrHeight[i] / 2;
                                        fEndY = m_objEBlobs.ref_arrLimitCenterY[i] + m_objEBlobs.ref_arrHeight[i] / 2;

                                        if (fMinStartY > fStartY)
                                            fMinStartY = fStartY;   // get smallest start x

                                        if (fMaxEndY < fEndY)
                                            fMaxEndY = fEndY;       // get biggest end x
                                    }

                                    int intSelectedObjectInddex = -1;
                                    float fNearestCenter = float.MaxValue;
                                    float fNorminalCenterY = (fMinStartY + fMaxEndY) / 2;
                                    for (int i = 0; i < m_objEBlobs.ref_intNumSelectedObject; i++)
                                    {
                                        if (fNearestCenter > Math.Abs(m_objEBlobs.ref_arrLimitCenterY[i] - fNorminalCenterY))
                                        {
                                            fNearestCenter = Math.Abs(m_objEBlobs.ref_arrLimitCenterY[i] - fNorminalCenterY);
                                            intSelectedObjectInddex = i;
                                        }
                                    }

                                    fStartX = m_objEBlobs.ref_arrLimitCenterX[intSelectedObjectInddex] - m_objEBlobs.ref_arrWidth[intSelectedObjectInddex] / 2;
                                    fStartY = m_objEBlobs.ref_arrLimitCenterY[intSelectedObjectInddex] - m_objEBlobs.ref_arrHeight[intSelectedObjectInddex] / 2;
                                    fEndX = m_objEBlobs.ref_arrLimitCenterX[intSelectedObjectInddex] + m_objEBlobs.ref_arrWidth[intSelectedObjectInddex] / 2;
                                    fEndY = m_objEBlobs.ref_arrLimitCenterY[intSelectedObjectInddex] + m_objEBlobs.ref_arrHeight[intSelectedObjectInddex] / 2;
                                    fCenterX = m_objEBlobs.ref_arrLimitCenterX[intSelectedObjectInddex];
                                    fCenterY = m_objEBlobs.ref_arrLimitCenterY[intSelectedObjectInddex];
                                    fWidth = m_objEBlobs.ref_arrWidth[intSelectedObjectInddex];
                                    fHeight = m_objEBlobs.ref_arrHeight[intSelectedObjectInddex];

                                }

                                // Remeasure to get base line
                                m_objLineGauge.SetGaugePlacement(pBaselinePoint.X,
                                                                 m_objLocalROI.ref_ROITotalY + fCenterY,
                                                                 10, fHeight, 90);

                                m_objLineGauge.Measure(m_objLocalROI);

                                pBaselinePoint = new PointF(m_objLineGauge.ref_ObjectCenterX, m_objLineGauge.ref_ObjectCenterY);

                                blnGetBaselinePointOK = true;
                            }
                        }
                        break;
                    case 3: // Bottom ROI
                        {
                            m_objLineGauge.ref_GaugeThreshold = (m_arrCornerPointGauge[(int)PointIndex_Corner.Corner1].ref_GaugeThreshold + m_arrCornerPointGauge[(int)PointIndex_Corner.Corner2].ref_GaugeThreshold) / 2; //20
                            m_objLineGauge.ref_GaugeThickness = 20;
                            m_objLineGauge.SetGaugePlacement(objROI.ref_ROITotalX + stcBlobsFeatures.fLimitCenterX,
                                                             objROI.ref_ROITotalY + stcBlobsFeatures.fEndY,
                                                             stcBlobsFeatures.fHeight, stcBlobsFeatures.fWidth - m_intBaseLineTrimFromEdge * 2, 180);

                            m_objLineGauge.Measure(objROI);

                            bool blnResetToPrevious = false;
                            for (int i = 0; i < m_intBaseLineSteps; i++)
                            {
                                float fBaseLineReferencePointY = m_objLineGauge.ref_ObjectCenterY;
                                float fLineGaugeTolerance = (fBaseLineReferencePointY - objROI.ref_ROITotalY + stcBlobsFeatures.fStartY) / 2;
                                m_objLineGauge.SetGaugePlacement(objROI.ref_ROITotalX + stcBlobsFeatures.fLimitCenterX,
                                                                fBaseLineReferencePointY - fLineGaugeTolerance,
                                                                fLineGaugeTolerance, stcBlobsFeatures.fWidth - m_intBaseLineTrimFromEdge * 2, 180);

                                //m_objLineGauge.Measure(objROI);
                                m_objLineGauge.Measure_SubGaugePoints_UsingMainLineGauge(objROI);//2021-09-08 ZJYEOH: Use sub gauge measurement to find closest sample point

                                // 2020 11 10 - Gauge valid score fail mean cannot find the base edge
                                if (m_objLineGauge.ref_ObjectScore < 30)
                                {
                                    blnResetToPrevious = true;
                                    break;
                                }
                            }

                            // 2020 11 10 - if not able to find the base adge, then need to reset to the first one. (this code applicable for m_intBaseLineSteps = 1. Need to double check this sequence if m_intBaseLineSteps > 1)
                            if (blnResetToPrevious)
                            {
                                m_objLineGauge.SetGaugePlacement(objROI.ref_ROITotalX + stcBlobsFeatures.fLimitCenterX,
                                                                 objROI.ref_ROITotalY + stcBlobsFeatures.fEndY,
                                                                 stcBlobsFeatures.fHeight, stcBlobsFeatures.fWidth - m_intBaseLineTrimFromEdge * 2, 180);

                                m_objLineGauge.Measure(objROI);
                            }

                            pBaselinePoint = new PointF(m_objLineGauge.ref_ObjectCenterX, m_objLineGauge.ref_ObjectCenterY);

                            blnGetBaselinePointOK = true;
                        }
                        break;
                    case 4: // Left ROI
                        {
                            // ------- Get outer point ------------------------
                            m_objLineGauge.SetGaugePlacement(objROI.ref_ROITotalX + stcBlobsFeatures.fStartX,
                                                             objROI.ref_ROITotalY + stcBlobsFeatures.fLimitCenterY,
                                                             stcBlobsFeatures.fWidth, 20, -90);
                            m_objLineGauge.ref_GaugeThreshold = (m_arrCornerPointGauge[(int)PointIndex_Corner.Corner1].ref_GaugeThreshold + m_arrCornerPointGauge[(int)PointIndex_Corner.Corner2].ref_GaugeThreshold) / 2; //20
                            m_objLineGauge.ref_GaugeThickness = 20;
                            m_objLineGauge.Measure(objROI);

                            blnGetBaselinePointOK = m_objLineGauge.GetMeasurementSampleCenterPoints(objROI, 10, ref pBaselinePoint);

                            // -------- Get center blob --------------------------------------
                            m_objLocalROI.AttachImage(objROI);
                            m_objLocalROI.LoadROISetting((int)pBaselinePoint.X - intLocalROITolerance - objROI.ref_ROITotalX, 0, intBodyEdgeOffsetFromBase + intLocalROITolerance, objROI.ref_ROIHeight);

                            BuildOnlySideLeadObjects_BlackObject(m_objLocalROI);

                            if (m_objEBlobs.ref_intNumSelectedObject > 0)
                            {
                                // Get center blobs information
                                if (m_objEBlobs.ref_intNumSelectedObject == 1)
                                {
                                    fStartX = m_objEBlobs.ref_arrLimitCenterX[0] - m_objEBlobs.ref_arrWidth[0] / 2;
                                    fStartY = m_objEBlobs.ref_arrLimitCenterY[0] - m_objEBlobs.ref_arrHeight[0] / 2;
                                    fEndX = m_objEBlobs.ref_arrLimitCenterX[0] + m_objEBlobs.ref_arrWidth[0] / 2;
                                    fEndY = m_objEBlobs.ref_arrLimitCenterY[0] + m_objEBlobs.ref_arrHeight[0] / 2;
                                    fCenterX = m_objEBlobs.ref_arrLimitCenterX[0];
                                    fCenterY = m_objEBlobs.ref_arrLimitCenterY[0];
                                    fWidth = m_objEBlobs.ref_arrWidth[0];
                                    fHeight = m_objEBlobs.ref_arrHeight[0];
                                }
                                else
                                {
                                    float fMinStartY = float.MaxValue;
                                    float fMaxEndY = float.MinValue;
                                    for (int i = 0; i < m_objEBlobs.ref_intNumSelectedObject; i++)
                                    {
                                        fStartY = m_objEBlobs.ref_arrLimitCenterY[i] - m_objEBlobs.ref_arrHeight[i] / 2;
                                        fEndY = m_objEBlobs.ref_arrLimitCenterY[i] + m_objEBlobs.ref_arrHeight[i] / 2;

                                        if (fMinStartY > fStartY)
                                            fMinStartY = fStartY;   // get smallest start x

                                        if (fMaxEndY < fEndY)
                                            fMaxEndY = fEndY;       // get biggest end x
                                    }

                                    int intSelectedObjectInddex = -1;
                                    float fNearestCenter = float.MaxValue;
                                    float fNorminalCenterY = (fMinStartY + fMaxEndY) / 2;
                                    for (int i = 0; i < m_objEBlobs.ref_intNumSelectedObject; i++)
                                    {
                                        if (fNearestCenter > Math.Abs(m_objEBlobs.ref_arrLimitCenterY[i] - fNorminalCenterY))
                                        {
                                            fNearestCenter = Math.Abs(m_objEBlobs.ref_arrLimitCenterY[i] - fNorminalCenterY);
                                            intSelectedObjectInddex = i;
                                        }
                                    }

                                    fStartX = m_objEBlobs.ref_arrLimitCenterX[intSelectedObjectInddex] - m_objEBlobs.ref_arrWidth[intSelectedObjectInddex] / 2;
                                    fStartY = m_objEBlobs.ref_arrLimitCenterY[intSelectedObjectInddex] - m_objEBlobs.ref_arrHeight[intSelectedObjectInddex] / 2;
                                    fEndX = m_objEBlobs.ref_arrLimitCenterX[intSelectedObjectInddex] + m_objEBlobs.ref_arrWidth[intSelectedObjectInddex] / 2;
                                    fEndY = m_objEBlobs.ref_arrLimitCenterY[intSelectedObjectInddex] + m_objEBlobs.ref_arrHeight[intSelectedObjectInddex] / 2;
                                    fCenterX = m_objEBlobs.ref_arrLimitCenterX[intSelectedObjectInddex];
                                    fCenterY = m_objEBlobs.ref_arrLimitCenterY[intSelectedObjectInddex];
                                    fWidth = m_objEBlobs.ref_arrWidth[intSelectedObjectInddex];
                                    fHeight = m_objEBlobs.ref_arrHeight[intSelectedObjectInddex];

                                }

                                // Remeasure on center blob to get base line.
                                m_objLineGauge.SetGaugePlacement(pBaselinePoint.X,
                                                                 m_objLocalROI.ref_ROITotalY + fCenterY,
                                                                 10, fHeight, -90);

                                m_objLineGauge.Measure(m_objLocalROI);

                                pBaselinePoint = new PointF(m_objLineGauge.ref_ObjectCenterX, m_objLineGauge.ref_ObjectCenterY);

                                blnGetBaselinePointOK = true;
                            }
                        }
                        break;
                    default:
                        objModifiedImage.Dispose();
                        objROI.Dispose();

                        return false;   // no center ROI because no base line measurement for center ROI.
                }
            }

            if (blnGetBaselinePointOK)
            {
                float PGaugeCenterX;
                float PGaugeCenterY;

                switch (m_intLeadROIDirection)
                {
                    case 1: // Top ROI
                        {
                            // 2020 07 24 - CCENG: Find side point from base line using blob
                            ROI objLocalROI = new ROI();
                            objLocalROI.AttachImage(objROI);
                            objLocalROI.LoadROISetting(objROI.ref_ROIOriPositionX, objROI.ref_ROIOriPositionY,
                                objROI.ref_ROIWidth,
                                (int)Math.Round(pBaselinePoint.Y - objLocalROI.ref_ROITotalY + m_intBaseLineTrimFromEdge, 0, MidpointRounding.AwayFromZero));

                            if (m_blnWantDebug)
                                objLocalROI.SaveImage("D:\\TS\\objLocalROI_Top.bmp");

                            PointF pStartPoint = new PointF(0, 0);
                            PointF pEndPoint = new PointF(0, 0);
                            if (!FindBaseLineSidePoints(objLocalROI, objLocalROI.ref_ROITotalX, objLocalROI.ref_ROITotalY, ref pStartPoint, ref pEndPoint))
                            {
                                objLocalROI.Dispose();
                                objLocalROI = null;
                                return false;
                            }

                            objLocalROI.Dispose();
                            objLocalROI = null;

                            m_arrLead3DEdgeCornerGaugePoints.Add(new List<PointF>());
                            m_arrLead3DEdgeCornerGaugePointsFound.Add(new List<bool>());

                            m_objBaseLine.CalculateStraightLine(new PointF(m_objLineGauge.ref_ObjectCenterX,
                                                                           m_objLineGauge.ref_ObjectCenterY),
                                                                           m_objLineGauge.ref_ObjectAngle + 90);   // The CalculateStraightLine need angle parameter start from straight line Y, but the line gauge start from straight line X. So need to add 90deg.

                            //m_objEdgeLine_Left.CalculateStraightLine(new PointF(m_objLineGauge.ref_GaugeCenterX -
                            //                                                   m_objLineGauge.ref_GaugeLength / 2,
                            //                                                   m_objLineGauge.ref_GaugeCenterY), 
                            //                                                   0);

                            //m_objEdgeLine_Right.CalculateStraightLine(new PointF(m_objLineGauge.ref_GaugeCenterX +
                            //                                                      m_objLineGauge.ref_GaugeLength / 2,
                            //                                                      m_objLineGauge.ref_GaugeCenterY),
                            //                                                      0);

                            m_objEdgeLine_Left.CalculateStraightLine(pStartPoint, 0);
                            m_objEdgeLine_Right.CalculateStraightLine(pEndPoint, 0);

                            m_fBaseLineAngle = m_objLineGauge.ref_ObjectAngle;
                            m_pCornerPoint_Left = Line.GetCrossPoint(m_objBaseLine, m_objEdgeLine_Left);
                            m_pCornerPoint_Right = Line.GetCrossPoint(m_objBaseLine, m_objEdgeLine_Right);

                            float AngleLeft = Math2.GetAngle(m_objBaseLine, m_objEdgeLine_Left);
                            float AngleReferenceTop = 180 - AngleLeft - ((180 - AngleLeft) / 2);
                            Line objReferenceLineTop = new Line();
                            objReferenceLineTop.CalculateStraightLine_ForLead3D(m_pCornerPoint_Left, AngleReferenceTop);

                            PGaugeCenterX = objReferenceLineTop.GetPointX(m_pCornerPoint_Left.Y + m_arrCornerSearchingTolerance_Top[(int)PointIndex_Corner.Corner1]);
                            if (float.IsInfinity(PGaugeCenterX) || float.IsNaN(PGaugeCenterX) || PGaugeCenterX <= 0)//|| PGaugeCenterX > m_objLineGauge.ref_ObjectCenterX + m_objLineGauge.ref_GaugeLength)
                            {
                                PGaugeCenterX = m_pCornerPoint_Left.X + m_arrCornerSearchingTolerance_Top[(int)PointIndex_Corner.Corner1];
                                PGaugeCenterY = objReferenceLineTop.GetPointY(m_pCornerPoint_Left.X + m_arrCornerSearchingTolerance_Top[(int)PointIndex_Corner.Corner1]);
                                if (float.IsInfinity(PGaugeCenterY) || float.IsNaN(PGaugeCenterY) || PGaugeCenterY <= 0)// || PGaugeCenterY > m_objLineGauge.ref_ObjectCenterY + m_objLineGauge.ref_GaugeLength)
                                {
                                    PGaugeCenterY = m_pCornerPoint_Left.Y + m_arrCornerSearchingTolerance_Top[(int)PointIndex_Corner.Corner1];
                                }
                            }
                            else
                            {
                                PGaugeCenterY = objReferenceLineTop.GetPointY(PGaugeCenterX);
                                if (float.IsInfinity(PGaugeCenterY) || float.IsNaN(PGaugeCenterY) || PGaugeCenterY <= 0)//|| PGaugeCenterY > m_objLineGauge.ref_ObjectCenterY + m_objLineGauge.ref_GaugeLength)
                                {
                                    PGaugeCenterY = m_pCornerPoint_Left.Y + m_arrCornerSearchingTolerance_Top[(int)PointIndex_Corner.Corner1];
                                }
                            }

                            if (m_arrCornerPointGauge[(int)PointIndex_Corner.Corner1].ref_GaugeTransType != 1)
                                m_arrCornerPointGauge[(int)PointIndex_Corner.Corner1].ref_GaugeTransType = 1;

                            m_arrCornerPointGauge[(int)PointIndex_Corner.Corner1].SetGaugePlacement(PGaugeCenterX,//m_pCornerPoint_Left.X,
                                                                PGaugeCenterY,//m_pCornerPoint_Left.Y,
                                                               m_arrCornerSearchingLength[(int)PointIndex_Corner.Corner1], AngleLeft / 2);
                            AddCornerPointGaugePlacementToArray(PGaugeCenterX,//m_pCornerPoint_Left.X,
                                                                PGaugeCenterY,//m_pCornerPoint_Left.Y,
                                                               m_arrCornerSearchingLength[(int)PointIndex_Corner.Corner1], AngleLeft / 2);
                            m_arrCornerPointGauge[(int)PointIndex_Corner.Corner1].Measure(objROI);

                            if (m_arrCornerPointGauge[(int)PointIndex_Corner.Corner1].ref_intMeasuredPointCount > 0)
                            {
                                m_pCornerPoint_Left = m_arrCornerPointGauge[(int)PointIndex_Corner.Corner1].GetMeasurePoint(0);
                                m_arrLead3DEdgeCornerGaugePoints[m_arrLead3DEdgeCornerGaugePoints.Count - 1].Add(new PointF(m_pCornerPoint_Left.X, m_pCornerPoint_Left.Y));
                                m_arrLead3DEdgeCornerGaugePointsFound[m_arrLead3DEdgeCornerGaugePoints.Count - 1].Add(true);
                            }
                            else
                            {
                                m_arrLead3DEdgeCornerGaugePoints[m_arrLead3DEdgeCornerGaugePoints.Count - 1].Add(new PointF(PGaugeCenterX, PGaugeCenterY));
                                m_arrLead3DEdgeCornerGaugePointsFound[m_arrLead3DEdgeCornerGaugePoints.Count - 1].Add(false);
                            }

                            float AngleRight = Math2.GetAngle(m_objBaseLine, m_objEdgeLine_Right);
                            AngleReferenceTop = 180 - AngleRight - ((180 - AngleRight) / 2);
                            objReferenceLineTop.CalculateStraightLine_ForLead3D(m_pCornerPoint_Right, -AngleReferenceTop);

                            PGaugeCenterX = objReferenceLineTop.GetPointX(m_pCornerPoint_Right.Y + m_arrCornerSearchingTolerance_Top[(int)PointIndex_Corner.Corner2]);
                            if (float.IsInfinity(PGaugeCenterX) || float.IsNaN(PGaugeCenterX) || PGaugeCenterX <= 0)// || PGaugeCenterX > m_objLineGauge.ref_ObjectCenterX + m_objLineGauge.ref_GaugeLength)
                            {
                                PGaugeCenterX = m_pCornerPoint_Right.X + m_arrCornerSearchingTolerance_Top[(int)PointIndex_Corner.Corner2];
                                PGaugeCenterY = objReferenceLineTop.GetPointY(m_pCornerPoint_Right.X + m_arrCornerSearchingTolerance_Top[(int)PointIndex_Corner.Corner2]);
                                if (float.IsInfinity(PGaugeCenterY) || float.IsNaN(PGaugeCenterY) || PGaugeCenterY <= 0)//|| PGaugeCenterY > m_objLineGauge.ref_ObjectCenterY + m_objLineGauge.ref_GaugeLength)
                                {
                                    PGaugeCenterY = m_pCornerPoint_Right.Y + m_arrCornerSearchingTolerance_Top[(int)PointIndex_Corner.Corner2];
                                }
                            }
                            else
                            {
                                PGaugeCenterY = objReferenceLineTop.GetPointY(PGaugeCenterX);
                                if (float.IsInfinity(PGaugeCenterY) || float.IsNaN(PGaugeCenterY) || PGaugeCenterY <= 0)//|| PGaugeCenterY > m_objLineGauge.ref_ObjectCenterY + m_objLineGauge.ref_GaugeLength)
                                {
                                    PGaugeCenterY = m_pCornerPoint_Right.Y + m_arrCornerSearchingTolerance_Top[(int)PointIndex_Corner.Corner2];
                                }
                            }

                            if (m_arrCornerPointGauge[(int)PointIndex_Corner.Corner2].ref_GaugeTransType != 1)
                                m_arrCornerPointGauge[(int)PointIndex_Corner.Corner2].ref_GaugeTransType = 1;

                            m_arrCornerPointGauge[(int)PointIndex_Corner.Corner2].SetGaugePlacement(PGaugeCenterX,//m_pCornerPoint_Right.X,
                                                                PGaugeCenterY,//m_pCornerPoint_Right.Y,
                                                               m_arrCornerSearchingLength[(int)PointIndex_Corner.Corner2], (AngleRight / 2) + 90);
                            SetCornerPointGaugePlacementToArray(PGaugeCenterX,//m_pCornerPoint_Right.X,
                                                                PGaugeCenterY,//m_pCornerPoint_Right.Y,
                                                               m_arrCornerSearchingLength[(int)PointIndex_Corner.Corner2], (AngleRight / 2) + 90, 1);
                            m_arrCornerPointGauge[(int)PointIndex_Corner.Corner2].Measure(objROI);

                            if (m_arrCornerPointGauge[(int)PointIndex_Corner.Corner2].ref_intMeasuredPointCount > 0)
                            {
                                m_pCornerPoint_Right = m_arrCornerPointGauge[(int)PointIndex_Corner.Corner2].GetMeasurePoint(0);
                                m_arrLead3DEdgeCornerGaugePoints[m_arrLead3DEdgeCornerGaugePoints.Count - 1].Add(new PointF(m_pCornerPoint_Right.X, m_pCornerPoint_Right.Y));
                                m_arrLead3DEdgeCornerGaugePointsFound[m_arrLead3DEdgeCornerGaugePoints.Count - 1].Add(true);
                            }
                            else
                            {
                                m_arrLead3DEdgeCornerGaugePoints[m_arrLead3DEdgeCornerGaugePoints.Count - 1].Add(new PointF(PGaugeCenterX, PGaugeCenterY));
                                m_arrLead3DEdgeCornerGaugePointsFound[m_arrLead3DEdgeCornerGaugePoints.Count - 1].Add(false);
                            }

                        }
                        break;
                    case 2: // Right ROI
                        {
                            // 2020 07 24 - CCENG: Find side point from base line using blob
                            ROI objLocalROI = new ROI();
                            objLocalROI.AttachImage(objROI);
                            int intStartX = (int)Math.Round(pBaselinePoint.X - objLocalROI.ref_ROITotalX - m_intBaseLineTrimFromEdge, 0, MidpointRounding.AwayFromZero);
                            objLocalROI.LoadROISetting(intStartX,
                                objROI.ref_ROIOriPositionY,
                                objROI.ref_ROIWidth - intStartX,
                                objROI.ref_ROIHeight);

                            if (m_blnWantDebug)
                                objLocalROI.SaveImage("D:\\TS\\objLocalROI_Right.bmp");

                            PointF pStartPoint = new PointF(0, 0);
                            PointF pEndPoint = new PointF(0, 0);
                            if (!FindBaseLineSidePoints(objLocalROI, objLocalROI.ref_ROITotalX, objLocalROI.ref_ROITotalY, ref pStartPoint, ref pEndPoint))
                            {
                                objLocalROI.Dispose();
                                objLocalROI = null;
                                return false;
                            }

                            objLocalROI.Dispose();
                            objLocalROI = null;

                            m_arrLead3DEdgeCornerGaugePoints.Add(new List<PointF>());
                            m_arrLead3DEdgeCornerGaugePointsFound.Add(new List<bool>());

                            m_objBaseLine.CalculateStraightLine(new PointF(m_objLineGauge.ref_ObjectCenterX,
                                                                           m_objLineGauge.ref_ObjectCenterY),
                                                                           m_objLineGauge.ref_ObjectAngle);

                            //m_objEdgeLine_Top.CalculateStraightLine(new PointF(m_objLineGauge.ref_GaugeCenterX,
                            //                                                   m_objLineGauge.ref_GaugeCenterY -
                            //                                                   m_objLineGauge.ref_GaugeLength / 2), 
                            //                                                   90);

                            //m_objEdgeLine_Bottom.CalculateStraightLine(new PointF(m_objLineGauge.ref_GaugeCenterX,
                            //                                                   m_objLineGauge.ref_GaugeCenterY +
                            //                                                   m_objLineGauge.ref_GaugeLength / 2), 
                            //                                                   90);

                            m_objEdgeLine_Top.CalculateStraightLine(pStartPoint, 90);
                            m_objEdgeLine_Bottom.CalculateStraightLine(pEndPoint, 90);

                            m_fBaseLineAngle = m_objLineGauge.ref_ObjectAngle;
                            m_pCornerPoint_Top = Line.GetCrossPoint(m_objBaseLine, m_objEdgeLine_Top);
                            m_pCornerPoint_Bottom = Line.GetCrossPoint(m_objBaseLine, m_objEdgeLine_Bottom);

                            float AngleTop = Math2.GetAngle(m_objBaseLine, m_objEdgeLine_Top);
                            float AngleReferenceRight = 180 - AngleTop - ((180 - AngleTop) / 2);
                            Line objReferenceLineRight = new Line();
                            objReferenceLineRight.CalculateStraightLine_ForLead3D(m_pCornerPoint_Top, -AngleReferenceRight);

                            PGaugeCenterX = objReferenceLineRight.GetPointX(m_pCornerPoint_Top.Y + m_arrCornerSearchingTolerance_Right[(int)PointIndex_Corner.Corner1]);
                            if (float.IsInfinity(PGaugeCenterX) || float.IsNaN(PGaugeCenterX) || PGaugeCenterX <= 0)//|| PGaugeCenterX > m_objLineGauge.ref_ObjectCenterX + m_objLineGauge.ref_GaugeLength)
                            {
                                PGaugeCenterX = m_pCornerPoint_Top.X + m_arrCornerSearchingTolerance_Right[(int)PointIndex_Corner.Corner1];
                                PGaugeCenterY = objReferenceLineRight.GetPointY(m_pCornerPoint_Top.X + m_arrCornerSearchingTolerance_Right[(int)PointIndex_Corner.Corner1]);
                                if (float.IsInfinity(PGaugeCenterY) || float.IsNaN(PGaugeCenterY) || PGaugeCenterY <= 0)//|| PGaugeCenterY > m_objLineGauge.ref_ObjectCenterY + m_objLineGauge.ref_GaugeLength)
                                {
                                    PGaugeCenterY = m_pCornerPoint_Top.Y + m_arrCornerSearchingTolerance_Right[(int)PointIndex_Corner.Corner1];
                                }
                            }
                            else
                            {
                                PGaugeCenterY = objReferenceLineRight.GetPointY(PGaugeCenterX);
                                if (float.IsInfinity(PGaugeCenterY) || float.IsNaN(PGaugeCenterY) || PGaugeCenterY <= 0)//|| PGaugeCenterY > m_objLineGauge.ref_ObjectCenterY + m_objLineGauge.ref_GaugeLength)
                                {
                                    PGaugeCenterY = m_pCornerPoint_Top.Y + m_arrCornerSearchingTolerance_Right[(int)PointIndex_Corner.Corner1];
                                }
                            }

                            if (m_arrCornerPointGauge[(int)PointIndex_Corner.Corner1].ref_GaugeTransType != 1)
                                m_arrCornerPointGauge[(int)PointIndex_Corner.Corner1].ref_GaugeTransType = 1;

                            m_arrCornerPointGauge[(int)PointIndex_Corner.Corner1].SetGaugePlacement(PGaugeCenterX,//m_pCornerPoint_Top.X,
                                                                PGaugeCenterY,//m_pCornerPoint_Top.Y,
                                                               m_arrCornerSearchingLength[(int)PointIndex_Corner.Corner1], (AngleTop / 2) + 90);
                            AddCornerPointGaugePlacementToArray(PGaugeCenterX,//m_pCornerPoint_Top.X,
                                                                PGaugeCenterY,//m_pCornerPoint_Top.Y,
                                                               m_arrCornerSearchingLength[(int)PointIndex_Corner.Corner1], (AngleTop / 2) + 90);
                            m_arrCornerPointGauge[(int)PointIndex_Corner.Corner1].Measure(objROI);

                            if (m_arrCornerPointGauge[(int)PointIndex_Corner.Corner1].ref_intMeasuredPointCount > 0)
                            {
                                m_pCornerPoint_Top = m_arrCornerPointGauge[(int)PointIndex_Corner.Corner1].GetMeasurePoint(0);
                                m_arrLead3DEdgeCornerGaugePoints[m_arrLead3DEdgeCornerGaugePoints.Count - 1].Add(new PointF(m_pCornerPoint_Top.X, m_pCornerPoint_Top.Y));
                                m_arrLead3DEdgeCornerGaugePointsFound[m_arrLead3DEdgeCornerGaugePoints.Count - 1].Add(true);
                            }
                            else
                            {
                                m_arrLead3DEdgeCornerGaugePoints[m_arrLead3DEdgeCornerGaugePoints.Count - 1].Add(new PointF(PGaugeCenterX, PGaugeCenterY));
                                m_arrLead3DEdgeCornerGaugePointsFound[m_arrLead3DEdgeCornerGaugePoints.Count - 1].Add(false);
                            }

                            float AngleBottom = Math2.GetAngle(m_objBaseLine, m_objEdgeLine_Bottom);
                            AngleReferenceRight = 180 - AngleBottom - ((180 - AngleBottom) / 2);
                            objReferenceLineRight.CalculateStraightLine_ForLead3D(m_pCornerPoint_Bottom, AngleReferenceRight);

                            PGaugeCenterX = objReferenceLineRight.GetPointX(m_pCornerPoint_Bottom.Y - m_arrCornerSearchingTolerance_Right[(int)PointIndex_Corner.Corner2]);
                            if (float.IsInfinity(PGaugeCenterX) || float.IsNaN(PGaugeCenterX) || PGaugeCenterX <= 0)//|| PGaugeCenterX > m_objLineGauge.ref_ObjectCenterX + m_objLineGauge.ref_GaugeLength)
                            {
                                PGaugeCenterX = m_pCornerPoint_Bottom.X - m_arrCornerSearchingTolerance_Right[(int)PointIndex_Corner.Corner2];
                                PGaugeCenterY = objReferenceLineRight.GetPointY(m_pCornerPoint_Bottom.X - m_arrCornerSearchingTolerance_Right[(int)PointIndex_Corner.Corner2]);
                                if (float.IsInfinity(PGaugeCenterY) || float.IsNaN(PGaugeCenterY) || PGaugeCenterY <= 0)//|| PGaugeCenterY > m_objLineGauge.ref_ObjectCenterY + m_objLineGauge.ref_GaugeLength)
                                {
                                    PGaugeCenterY = m_pCornerPoint_Bottom.Y - m_arrCornerSearchingTolerance_Right[(int)PointIndex_Corner.Corner2];
                                }
                            }
                            else
                            {
                                PGaugeCenterY = objReferenceLineRight.GetPointY(PGaugeCenterX);
                                if (float.IsInfinity(PGaugeCenterY) || float.IsNaN(PGaugeCenterY) || PGaugeCenterY <= 0)//|| PGaugeCenterY > m_objLineGauge.ref_ObjectCenterY + m_objLineGauge.ref_GaugeLength)
                                {
                                    PGaugeCenterY = m_pCornerPoint_Bottom.Y - m_arrCornerSearchingTolerance_Right[(int)PointIndex_Corner.Corner2];
                                }
                            }

                            if (m_arrCornerPointGauge[(int)PointIndex_Corner.Corner2].ref_GaugeTransType != 1)
                                m_arrCornerPointGauge[(int)PointIndex_Corner.Corner2].ref_GaugeTransType = 1;

                            m_arrCornerPointGauge[(int)PointIndex_Corner.Corner2].SetGaugePlacement(PGaugeCenterX,//m_pCornerPoint_Bottom.X,
                                                                PGaugeCenterY,//m_pCornerPoint_Bottom.Y,
                                                               m_arrCornerSearchingLength[(int)PointIndex_Corner.Corner2], (AngleBottom / 2) - 180);
                            SetCornerPointGaugePlacementToArray(PGaugeCenterX,//m_pCornerPoint_Bottom.X,
                                                                PGaugeCenterY,//m_pCornerPoint_Bottom.Y,
                                                               m_arrCornerSearchingLength[(int)PointIndex_Corner.Corner2], (AngleBottom / 2) - 180, 1);
                            m_arrCornerPointGauge[(int)PointIndex_Corner.Corner2].Measure(objROI);

                            if (m_arrCornerPointGauge[(int)PointIndex_Corner.Corner2].ref_intMeasuredPointCount > 0)
                            {
                                m_pCornerPoint_Bottom = m_arrCornerPointGauge[(int)PointIndex_Corner.Corner2].GetMeasurePoint(0);
                                m_arrLead3DEdgeCornerGaugePoints[m_arrLead3DEdgeCornerGaugePoints.Count - 1].Add(new PointF(m_pCornerPoint_Bottom.X, m_pCornerPoint_Bottom.Y));
                                m_arrLead3DEdgeCornerGaugePointsFound[m_arrLead3DEdgeCornerGaugePoints.Count - 1].Add(true);
                            }
                            else
                            {
                                m_arrLead3DEdgeCornerGaugePoints[m_arrLead3DEdgeCornerGaugePoints.Count - 1].Add(new PointF(PGaugeCenterX, PGaugeCenterY));
                                m_arrLead3DEdgeCornerGaugePointsFound[m_arrLead3DEdgeCornerGaugePoints.Count - 1].Add(false);
                            }
                        }
                        break;
                    case 3: // Bottom ROI
                        {
                            // 2020 07 24 - CCENG: Find side point from base line using blob
                            ROI objLocalROI = new ROI();
                            objLocalROI.AttachImage(objROI);
                            int intStartY = (int)Math.Round(pBaselinePoint.Y - objLocalROI.ref_ROITotalY - m_intBaseLineTrimFromEdge, 0, MidpointRounding.AwayFromZero);
                            objLocalROI.LoadROISetting(objROI.ref_ROIOriPositionX,
                                intStartY,
                                objROI.ref_ROIWidth,
                                objROI.ref_ROIHeight - intStartY);

                            if (m_blnWantDebug)
                                objLocalROI.SaveImage("D:\\TS\\objLocalROI_Bottom.bmp");

                            PointF pStartPoint = new PointF(0, 0);
                            PointF pEndPoint = new PointF(0, 0);
                            if (!FindBaseLineSidePoints(objLocalROI, objLocalROI.ref_ROITotalX, objLocalROI.ref_ROITotalY, ref pStartPoint, ref pEndPoint))
                            {
                                objLocalROI.Dispose();
                                objLocalROI = null;
                                return false;
                            }

                            objLocalROI.Dispose();
                            objLocalROI = null;

                            m_arrLead3DEdgeCornerGaugePoints.Add(new List<PointF>());
                            m_arrLead3DEdgeCornerGaugePointsFound.Add(new List<bool>());

                            m_objBaseLine.CalculateStraightLine(new PointF(m_objLineGauge.ref_ObjectCenterX,
                                                                           m_objLineGauge.ref_ObjectCenterY),
                                                                           m_objLineGauge.ref_ObjectAngle + 90);   // The CalculateStraightLine need angle parameter start from straight line Y, but the line gauge start from straight line X. So need to add 90deg.

                            //m_objEdgeLine_Left.CalculateStraightLine(new PointF(m_objLineGauge.ref_GaugeCenterX -
                            //                                                   m_objLineGauge.ref_GaugeLength / 2,
                            //                                                   m_objLineGauge.ref_GaugeCenterY),
                            //                                                   0);

                            //m_objEdgeLine_Right.CalculateStraightLine(new PointF(m_objLineGauge.ref_GaugeCenterX +
                            //                                                      m_objLineGauge.ref_GaugeLength / 2,
                            //                                                      m_objLineGauge.ref_GaugeCenterY),
                            //                                                      0);

                            m_objEdgeLine_Left.CalculateStraightLine(pStartPoint, 0);
                            m_objEdgeLine_Right.CalculateStraightLine(pEndPoint, 0);

                            m_fBaseLineAngle = m_objLineGauge.ref_ObjectAngle;
                            m_pCornerPoint_Left = Line.GetCrossPoint(m_objBaseLine, m_objEdgeLine_Left);
                            m_pCornerPoint_Right = Line.GetCrossPoint(m_objBaseLine, m_objEdgeLine_Right);

                            float AngleLeft = Math2.GetAngle(m_objBaseLine, m_objEdgeLine_Left);
                            float AngleReferenceBottom = 180 - AngleLeft - ((180 - AngleLeft) / 2);
                            Line objReferenceLineBottom = new Line();
                            objReferenceLineBottom.CalculateStraightLine_ForLead3D(m_pCornerPoint_Left, -AngleReferenceBottom);

                            PGaugeCenterX = objReferenceLineBottom.GetPointX(m_pCornerPoint_Left.Y + m_arrCornerSearchingTolerance_Bottom[(int)PointIndex_Corner.Corner1]);
                            if (float.IsInfinity(PGaugeCenterX) || float.IsNaN(PGaugeCenterX) || PGaugeCenterX <= 0)//|| PGaugeCenterX > m_objLineGauge.ref_ObjectCenterX + m_objLineGauge.ref_GaugeLength)
                            {
                                PGaugeCenterX = m_pCornerPoint_Left.X + m_arrCornerSearchingTolerance_Bottom[(int)PointIndex_Corner.Corner1];
                                PGaugeCenterY = objReferenceLineBottom.GetPointY(m_pCornerPoint_Left.X + m_arrCornerSearchingTolerance_Bottom[(int)PointIndex_Corner.Corner1]);
                                if (float.IsInfinity(PGaugeCenterY) || float.IsNaN(PGaugeCenterY) || PGaugeCenterY <= 0)//|| PGaugeCenterY > m_objLineGauge.ref_ObjectCenterY + m_objLineGauge.ref_GaugeLength)
                                {
                                    PGaugeCenterY = m_pCornerPoint_Left.Y + m_arrCornerSearchingTolerance_Bottom[(int)PointIndex_Corner.Corner1];
                                }
                            }
                            else
                            {
                                PGaugeCenterY = objReferenceLineBottom.GetPointY(PGaugeCenterX);
                                if (float.IsInfinity(PGaugeCenterY) || float.IsNaN(PGaugeCenterY) || PGaugeCenterY <= 0)//|| PGaugeCenterY > m_objLineGauge.ref_ObjectCenterY + m_objLineGauge.ref_GaugeLength)
                                {
                                    PGaugeCenterY = m_pCornerPoint_Left.Y + m_arrCornerSearchingTolerance_Bottom[(int)PointIndex_Corner.Corner1];
                                }
                            }

                            if (m_arrCornerPointGauge[(int)PointIndex_Corner.Corner1].ref_GaugeTransType != 1)
                                m_arrCornerPointGauge[(int)PointIndex_Corner.Corner1].ref_GaugeTransType = 1;

                            m_arrCornerPointGauge[(int)PointIndex_Corner.Corner1].SetGaugePlacement(PGaugeCenterX,//m_pCornerPoint_Left.X,
                                                                PGaugeCenterY,//m_pCornerPoint_Left.Y,
                                                               m_arrCornerSearchingLength[(int)PointIndex_Corner.Corner1], (AngleLeft / 2) - 90);
                            AddCornerPointGaugePlacementToArray(PGaugeCenterX,//m_pCornerPoint_Left.X,
                                                                PGaugeCenterY,//m_pCornerPoint_Left.Y,
                                                               m_arrCornerSearchingLength[(int)PointIndex_Corner.Corner1], (AngleLeft / 2) - 90);
                            m_arrCornerPointGauge[(int)PointIndex_Corner.Corner1].Measure(objROI);

                            if (m_arrCornerPointGauge[(int)PointIndex_Corner.Corner1].ref_intMeasuredPointCount > 0)
                            {
                                m_pCornerPoint_Left = m_arrCornerPointGauge[(int)PointIndex_Corner.Corner1].GetMeasurePoint(0);
                                m_arrLead3DEdgeCornerGaugePoints[m_arrLead3DEdgeCornerGaugePoints.Count - 1].Add(new PointF(m_pCornerPoint_Left.X, m_pCornerPoint_Left.Y));
                                m_arrLead3DEdgeCornerGaugePointsFound[m_arrLead3DEdgeCornerGaugePoints.Count - 1].Add(true);
                            }
                            else
                            {
                                m_arrLead3DEdgeCornerGaugePoints[m_arrLead3DEdgeCornerGaugePoints.Count - 1].Add(new PointF(PGaugeCenterX, PGaugeCenterY));
                                m_arrLead3DEdgeCornerGaugePointsFound[m_arrLead3DEdgeCornerGaugePoints.Count - 1].Add(false);
                            }

                            float AngleRight = Math2.GetAngle(m_objBaseLine, m_objEdgeLine_Right);
                            AngleReferenceBottom = 180 - AngleRight - ((180 - AngleRight) / 2);
                            objReferenceLineBottom.CalculateStraightLine_ForLead3D(m_pCornerPoint_Right, AngleReferenceBottom);

                            PGaugeCenterX = objReferenceLineBottom.GetPointX(m_pCornerPoint_Right.Y + m_arrCornerSearchingTolerance_Bottom[(int)PointIndex_Corner.Corner2]);
                            if (float.IsInfinity(PGaugeCenterX) || float.IsNaN(PGaugeCenterX) || PGaugeCenterX <= 0)//|| PGaugeCenterX > m_objLineGauge.ref_ObjectCenterX + m_objLineGauge.ref_GaugeLength)
                            {
                                PGaugeCenterX = m_pCornerPoint_Right.X + m_arrCornerSearchingTolerance_Bottom[(int)PointIndex_Corner.Corner2];
                                PGaugeCenterY = objReferenceLineBottom.GetPointY(m_pCornerPoint_Right.X + m_arrCornerSearchingTolerance_Bottom[(int)PointIndex_Corner.Corner2]);
                                if (float.IsInfinity(PGaugeCenterY) || float.IsNaN(PGaugeCenterY) || PGaugeCenterY <= 0)// || PGaugeCenterY > m_objLineGauge.ref_ObjectCenterY + m_objLineGauge.ref_GaugeLength)
                                {
                                    PGaugeCenterY = m_pCornerPoint_Right.Y + m_arrCornerSearchingTolerance_Bottom[(int)PointIndex_Corner.Corner2];
                                }
                            }
                            else
                            {
                                PGaugeCenterY = objReferenceLineBottom.GetPointY(PGaugeCenterX);
                                if (float.IsInfinity(PGaugeCenterY) || float.IsNaN(PGaugeCenterY) || PGaugeCenterY <= 0)// || PGaugeCenterY > m_objLineGauge.ref_ObjectCenterY + m_objLineGauge.ref_GaugeLength)
                                {
                                    PGaugeCenterY = m_pCornerPoint_Right.Y + m_arrCornerSearchingTolerance_Bottom[(int)PointIndex_Corner.Corner2];
                                }
                            }

                            if (m_arrCornerPointGauge[(int)PointIndex_Corner.Corner2].ref_GaugeTransType != 1)
                                m_arrCornerPointGauge[(int)PointIndex_Corner.Corner2].ref_GaugeTransType = 1;

                            m_arrCornerPointGauge[(int)PointIndex_Corner.Corner2].SetGaugePlacement(PGaugeCenterX,//m_pCornerPoint_Right.X,
                                                                PGaugeCenterY,//m_pCornerPoint_Right.Y,
                                                               m_arrCornerSearchingLength[(int)PointIndex_Corner.Corner2], (AngleRight / 2) - 180);
                            SetCornerPointGaugePlacementToArray(PGaugeCenterX,//m_pCornerPoint_Right.X,
                                                                PGaugeCenterY,//m_pCornerPoint_Right.Y,
                                                               m_arrCornerSearchingLength[(int)PointIndex_Corner.Corner2], (AngleRight / 2) - 180, 1);
                            m_arrCornerPointGauge[(int)PointIndex_Corner.Corner2].Measure(objROI);

                            if (m_arrCornerPointGauge[(int)PointIndex_Corner.Corner2].ref_intMeasuredPointCount > 0)
                            {
                                m_pCornerPoint_Right = m_arrCornerPointGauge[(int)PointIndex_Corner.Corner2].GetMeasurePoint(0);
                                m_arrLead3DEdgeCornerGaugePoints[m_arrLead3DEdgeCornerGaugePoints.Count - 1].Add(new PointF(m_pCornerPoint_Right.X, m_pCornerPoint_Right.Y));
                                m_arrLead3DEdgeCornerGaugePointsFound[m_arrLead3DEdgeCornerGaugePoints.Count - 1].Add(true);
                            }
                            else
                            {
                                m_arrLead3DEdgeCornerGaugePoints[m_arrLead3DEdgeCornerGaugePoints.Count - 1].Add(new PointF(PGaugeCenterX, PGaugeCenterY));
                                m_arrLead3DEdgeCornerGaugePointsFound[m_arrLead3DEdgeCornerGaugePoints.Count - 1].Add(false);
                            }

                        }
                        break;
                    case 4: // Left ROI
                        {
                            // 2020 07 24 - CCENG: Find side point from base line 
                            ROI objLocalROI = new ROI();
                            objLocalROI.AttachImage(objROI);
                            objLocalROI.LoadROISetting(objROI.ref_ROIOriPositionX, objROI.ref_ROIOriPositionY,
                                (int)Math.Round(pBaselinePoint.X - objLocalROI.ref_ROITotalX + m_intBaseLineTrimFromEdge, 0, MidpointRounding.AwayFromZero),
                                objROI.ref_ROIHeight);

                            if (m_blnWantDebug)
                                objLocalROI.SaveImage("D:\\TS\\objLocalROI_Left.bmp");

                            PointF pStartPoint = new PointF(0, 0);
                            PointF pEndPoint = new PointF(0, 0);
                            if (!FindBaseLineSidePoints(objLocalROI, objLocalROI.ref_ROITotalX, objLocalROI.ref_ROITotalY, ref pStartPoint, ref pEndPoint))
                            {
                                objLocalROI.Dispose();
                                objLocalROI = null;
                                return false;
                            }

                            objLocalROI.Dispose();
                            objLocalROI = null;

                            m_arrLead3DEdgeCornerGaugePoints.Add(new List<PointF>());
                            m_arrLead3DEdgeCornerGaugePointsFound.Add(new List<bool>());

                            m_objBaseLine.CalculateStraightLine(new PointF(m_objLineGauge.ref_ObjectCenterX,
                                                                           m_objLineGauge.ref_ObjectCenterY),
                                                                           m_objLineGauge.ref_ObjectAngle);   // The CalculateStraightLine need angle parameter start from straight line Y, but the line gauge start from straight line X. So need to add 90deg.

                            //m_objEdgeLine_Top.CalculateStraightLine(new PointF(m_objLineGauge.ref_GaugeCenterX,
                            //                                                   m_objLineGauge.ref_GaugeCenterY -
                            //                                                   m_objLineGauge.ref_GaugeLength / 2), 90);

                            //m_objEdgeLine_Top.CalculateStraightLine(new PointF(m_objLineGauge.ref_GaugeCenterX,
                            //                                                   m_objLineGauge.ref_GaugeCenterY -
                            //                                                   m_objLineGauge.ref_GaugeLength / 2), 90);

                            //m_objEdgeLine_Bottom.CalculateStraightLine(new PointF(m_objLineGauge.ref_GaugeCenterX,
                            //                       m_objLineGauge.ref_GaugeCenterY +
                            //                       m_objLineGauge.ref_GaugeLength / 2), 90);

                            m_objEdgeLine_Top.CalculateStraightLine(pStartPoint, 90);
                            m_objEdgeLine_Bottom.CalculateStraightLine(pEndPoint, 90);

                            m_fBaseLineAngle = m_objLineGauge.ref_ObjectAngle;
                            m_pCornerPoint_Top = Line.GetCrossPoint(m_objBaseLine, m_objEdgeLine_Top);
                            m_pCornerPoint_Bottom = Line.GetCrossPoint(m_objBaseLine, m_objEdgeLine_Bottom);

                            float AngleTop = Math2.GetAngle(m_objBaseLine, m_objEdgeLine_Top);
                            float AngleReferenceLeft = 180 - AngleTop - ((180 - AngleTop) / 2);
                            Line objReferenceLineLeft = new Line();
                            objReferenceLineLeft.CalculateStraightLine_ForLead3D(m_pCornerPoint_Top, AngleReferenceLeft);

                            PGaugeCenterX = objReferenceLineLeft.GetPointX(m_pCornerPoint_Top.Y - m_arrCornerSearchingTolerance_Left[(int)PointIndex_Corner.Corner1]);
                            if (float.IsInfinity(PGaugeCenterX) || float.IsNaN(PGaugeCenterX) || PGaugeCenterX <= 0)//|| PGaugeCenterX > m_objLineGauge.ref_ObjectCenterX + m_objLineGauge.ref_GaugeLength)
                            {
                                PGaugeCenterX = m_pCornerPoint_Top.X - m_arrCornerSearchingTolerance_Left[(int)PointIndex_Corner.Corner1];
                                PGaugeCenterY = objReferenceLineLeft.GetPointY(m_pCornerPoint_Top.X - m_arrCornerSearchingTolerance_Left[(int)PointIndex_Corner.Corner1]);
                                if (float.IsInfinity(PGaugeCenterY) || float.IsNaN(PGaugeCenterY) || PGaugeCenterY <= 0)// || PGaugeCenterY > m_objLineGauge.ref_ObjectCenterY + m_objLineGauge.ref_GaugeLength)
                                {
                                    PGaugeCenterY = m_pCornerPoint_Top.Y - m_arrCornerSearchingTolerance_Left[(int)PointIndex_Corner.Corner1];
                                }
                            }
                            else
                            {
                                PGaugeCenterY = objReferenceLineLeft.GetPointY(PGaugeCenterX);
                                if (float.IsInfinity(PGaugeCenterY) || float.IsNaN(PGaugeCenterY) || PGaugeCenterY <= 0)//|| PGaugeCenterY > m_objLineGauge.ref_ObjectCenterY + m_objLineGauge.ref_GaugeLength)
                                {
                                    PGaugeCenterY = m_pCornerPoint_Top.Y - m_arrCornerSearchingTolerance_Left[(int)PointIndex_Corner.Corner1];
                                }
                            }

                            if (m_arrCornerPointGauge[(int)PointIndex_Corner.Corner1].ref_GaugeTransType != 1)
                                m_arrCornerPointGauge[(int)PointIndex_Corner.Corner1].ref_GaugeTransType = 1;

                            m_arrCornerPointGauge[(int)PointIndex_Corner.Corner1].SetGaugePlacement(PGaugeCenterX,//m_pCornerPoint_Top.X,
                                                                PGaugeCenterY,//m_pCornerPoint_Top.Y,
                                                               m_arrCornerSearchingLength[(int)PointIndex_Corner.Corner1], AngleTop / 2);
                            AddCornerPointGaugePlacementToArray(PGaugeCenterX,//m_pCornerPoint_Top.X,
                                                                PGaugeCenterY,//m_pCornerPoint_Top.Y,
                                                               m_arrCornerSearchingLength[(int)PointIndex_Corner.Corner1], AngleTop / 2);
                            m_arrCornerPointGauge[(int)PointIndex_Corner.Corner1].Measure(objROI);

                            if (m_arrCornerPointGauge[(int)PointIndex_Corner.Corner1].ref_intMeasuredPointCount > 0)
                            {
                                m_pCornerPoint_Top = m_arrCornerPointGauge[(int)PointIndex_Corner.Corner1].GetMeasurePoint(0);
                                m_arrLead3DEdgeCornerGaugePoints[m_arrLead3DEdgeCornerGaugePoints.Count - 1].Add(new PointF(m_pCornerPoint_Top.X, m_pCornerPoint_Top.Y));
                                m_arrLead3DEdgeCornerGaugePointsFound[m_arrLead3DEdgeCornerGaugePoints.Count - 1].Add(true);
                            }
                            else
                            {
                                m_arrLead3DEdgeCornerGaugePoints[m_arrLead3DEdgeCornerGaugePoints.Count - 1].Add(new PointF(PGaugeCenterX, PGaugeCenterY));
                                m_arrLead3DEdgeCornerGaugePointsFound[m_arrLead3DEdgeCornerGaugePoints.Count - 1].Add(false);
                            }

                            float AngleBottom = Math2.GetAngle(m_objBaseLine, m_objEdgeLine_Bottom);
                            AngleReferenceLeft = 180 - AngleBottom - ((180 - AngleBottom) / 2);
                            objReferenceLineLeft.CalculateStraightLine_ForLead3D(m_pCornerPoint_Bottom, -AngleReferenceLeft);

                            PGaugeCenterX = objReferenceLineLeft.GetPointX(m_pCornerPoint_Bottom.Y + m_arrCornerSearchingTolerance_Left[(int)PointIndex_Corner.Corner2]);
                            if (float.IsInfinity(PGaugeCenterX) || float.IsNaN(PGaugeCenterX) || PGaugeCenterX <= 0)// || PGaugeCenterX > m_objLineGauge.ref_ObjectCenterX + m_objLineGauge.ref_GaugeLength)
                            {
                                PGaugeCenterX = m_pCornerPoint_Bottom.X + m_arrCornerSearchingTolerance_Left[(int)PointIndex_Corner.Corner2];
                                PGaugeCenterY = objReferenceLineLeft.GetPointY(m_pCornerPoint_Bottom.X + m_arrCornerSearchingTolerance_Left[(int)PointIndex_Corner.Corner2]);
                                if (float.IsInfinity(PGaugeCenterY) || float.IsNaN(PGaugeCenterY) || PGaugeCenterY <= 0)// || PGaugeCenterY > m_objLineGauge.ref_ObjectCenterY + m_objLineGauge.ref_GaugeLength)
                                {
                                    PGaugeCenterY = m_pCornerPoint_Bottom.Y + m_arrCornerSearchingTolerance_Left[(int)PointIndex_Corner.Corner2];
                                }
                            }
                            else
                            {
                                PGaugeCenterY = objReferenceLineLeft.GetPointY(PGaugeCenterX);
                                if (float.IsInfinity(PGaugeCenterY) || float.IsNaN(PGaugeCenterY) || PGaugeCenterY <= 0)//|| PGaugeCenterY > m_objLineGauge.ref_ObjectCenterY + m_objLineGauge.ref_GaugeLength)
                                {
                                    PGaugeCenterY = m_pCornerPoint_Bottom.Y + m_arrCornerSearchingTolerance_Left[(int)PointIndex_Corner.Corner2];
                                }
                            }

                            if (m_arrCornerPointGauge[(int)PointIndex_Corner.Corner2].ref_GaugeTransType != 1)
                                m_arrCornerPointGauge[(int)PointIndex_Corner.Corner2].ref_GaugeTransType = 1;

                            m_arrCornerPointGauge[(int)PointIndex_Corner.Corner2].SetGaugePlacement(PGaugeCenterX,//m_pCornerPoint_Bottom.X,
                                                                PGaugeCenterY,//m_pCornerPoint_Bottom.Y,
                                                               m_arrCornerSearchingLength[(int)PointIndex_Corner.Corner2], (AngleBottom / 2) - 90);
                            SetCornerPointGaugePlacementToArray(PGaugeCenterX,//m_pCornerPoint_Bottom.X,
                                                                PGaugeCenterY,//m_pCornerPoint_Bottom.Y,
                                                               m_arrCornerSearchingLength[(int)PointIndex_Corner.Corner2], (AngleBottom / 2) - 90, 1);
                            m_arrCornerPointGauge[(int)PointIndex_Corner.Corner2].Measure(objROI);

                            if (m_arrCornerPointGauge[(int)PointIndex_Corner.Corner2].ref_intMeasuredPointCount > 0)
                            {
                                m_pCornerPoint_Bottom = m_arrCornerPointGauge[(int)PointIndex_Corner.Corner2].GetMeasurePoint(0);
                                m_arrLead3DEdgeCornerGaugePoints[m_arrLead3DEdgeCornerGaugePoints.Count - 1].Add(new PointF(m_pCornerPoint_Bottom.X, m_pCornerPoint_Bottom.Y));
                                m_arrLead3DEdgeCornerGaugePointsFound[m_arrLead3DEdgeCornerGaugePoints.Count - 1].Add(true);
                            }
                            else
                            {
                                m_arrLead3DEdgeCornerGaugePoints[m_arrLead3DEdgeCornerGaugePoints.Count - 1].Add(new PointF(PGaugeCenterX, PGaugeCenterY));
                                m_arrLead3DEdgeCornerGaugePointsFound[m_arrLead3DEdgeCornerGaugePoints.Count - 1].Add(false);
                            }
                        }
                        break;
                    default:
                        objModifiedImage.Dispose();
                        objROI.Dispose();
                        return false;   // no center ROI because no base line measurement for center ROI.
                }

                bool blnFailBaseLineAngle = false;
                if (Math.Abs(m_fBaseLineAngle) > m_fBaseLineMaxAngle)
                {
                    blnFailBaseLineAngle = true;
                    m_strErrorMessage = "*Fail Base Line Angle. Set = " + m_fBaseLineMaxAngle + "deg, Result=" + m_fBaseLineAngle.ToString("F" + m_intDecimal) + "deg.";
                    objModifiedImage.Dispose();
                    objROI.Dispose();
                    return false;
                }


            }
            else
            {
                m_strErrorMessage = "*Fail to Find Base Line.";
                objModifiedImage.Dispose();
                objROI.Dispose();
                return false;
            }
            objModifiedImage.Dispose();
            objROI.Dispose();
            return true;
        }

        public bool FindBaseLineSidePoints(ROI objROI, int intOffsetX, int intOffsetY, ref PointF pLeftPoint, ref PointF pRightPoint)
        {
            BuildOnlySideLeadObjects_BlackObject(objROI);

            float fLimitCenterX = 0, fLimitCenterY = 0;
            float fWidth = 0, fHeight = 0;

            if (m_objEBlobs.ref_intNumSelectedObject == 0)
                return false;
            //2021-08-28 ZJYEOH: Use largest blob as Side Lead body, no need to consider other blob to filter noise build near mirror edge
            // 2020 10 14 - CCENG: Use first blob center if only one blob. If more than 1 blob, then define which object nearest to total center X.
            //if (m_objEBlobs.ref_intNumSelectedObject == 1)
            {
                fLimitCenterX = m_objEBlobs.ref_arrLimitCenterX[0];
                fLimitCenterY = m_objEBlobs.ref_arrLimitCenterY[0];
                fWidth = m_objEBlobs.ref_arrWidth[0];
                fHeight = m_objEBlobs.ref_arrHeight[0];

                pLeftPoint = new PointF(intOffsetX + fLimitCenterX - fWidth / 2, intOffsetY + fLimitCenterY - fHeight / 2);
                pRightPoint = new PointF(intOffsetX + fLimitCenterX + fWidth / 2, intOffsetY + fLimitCenterY + fHeight / 2);
                return true;
            }
            //else if (m_objEBlobs.ref_intNumSelectedObject > 1)
            //{
            //    switch (m_intLeadROIDirection)
            //    {
            //        case 1: // Top ROI
            //        case 3:
            //            {
            //                float fMinStartX = float.MaxValue;
            //                float fMaxEndX = float.MinValue;
            //                float fStartX, fEndX;
            //                for (int i = 0; i < m_objEBlobs.ref_intNumSelectedObject; i++)
            //                {
            //                    fStartX = m_objEBlobs.ref_arrLimitCenterX[i] - m_objEBlobs.ref_arrWidth[i] / 2;
            //                    fEndX = m_objEBlobs.ref_arrLimitCenterX[i] + m_objEBlobs.ref_arrWidth[i] / 2;

            //                    if (fMinStartX > fStartX)
            //                        fMinStartX = fStartX;   // get smallest start x

            //                    if (fMaxEndX < fEndX)
            //                        fMaxEndX = fEndX;       // get biggest end x
            //                }

            //                int intSelectedObjectInddex = -1;
            //                float fNearestCenter = float.MaxValue;
            //                float fNorminalCenterX = (fMinStartX + fMaxEndX) / 2;
            //                for (int i = 0; i < m_objEBlobs.ref_intNumSelectedObject; i++)
            //                {
            //                    if (fNearestCenter > Math.Abs(m_objEBlobs.ref_arrLimitCenterX[i] - fNorminalCenterX))
            //                    {
            //                        fNearestCenter = Math.Abs(m_objEBlobs.ref_arrLimitCenterX[i] - fNorminalCenterX);
            //                        intSelectedObjectInddex = i;
            //                    }
            //                }

            //                fLimitCenterX = m_objEBlobs.ref_arrLimitCenterX[intSelectedObjectInddex];
            //                fLimitCenterY = m_objEBlobs.ref_arrLimitCenterY[intSelectedObjectInddex];
            //                fWidth = m_objEBlobs.ref_arrWidth[intSelectedObjectInddex];
            //                fHeight = m_objEBlobs.ref_arrHeight[intSelectedObjectInddex];

            //                pLeftPoint = new PointF(intOffsetX + fLimitCenterX - fWidth / 2, intOffsetY + fLimitCenterY - fHeight / 2);
            //                pRightPoint = new PointF(intOffsetX + fLimitCenterX + fWidth / 2, intOffsetY + fLimitCenterY + fHeight / 2);
            //            }
            //            break;
            //        case 2:
            //        case 4:
            //            {
            //                float fMinStartY = float.MaxValue;
            //                float fMaxEndY = float.MinValue;
            //                float fStartY, fEndY;
            //                for (int i = 0; i < m_objEBlobs.ref_intNumSelectedObject; i++)
            //                {
            //                    fStartY = m_objEBlobs.ref_arrLimitCenterY[i] - m_objEBlobs.ref_arrHeight[i] / 2;
            //                    fEndY = m_objEBlobs.ref_arrLimitCenterY[i] + m_objEBlobs.ref_arrHeight[i] / 2;

            //                    if (fMinStartY > fStartY)
            //                        fMinStartY = fStartY;   // get smallest start x

            //                    if (fMaxEndY < fEndY)
            //                        fMaxEndY = fEndY;       // get biggest end x
            //                }

            //                int intSelectedObjectInddex = -1;
            //                float fNearestCenter = float.MaxValue;
            //                float fNorminalCenterY = (fMinStartY + fMaxEndY) / 2;
            //                for (int i = 0; i < m_objEBlobs.ref_intNumSelectedObject; i++)
            //                {
            //                    if (fNearestCenter > Math.Abs(m_objEBlobs.ref_arrLimitCenterY[i] - fNorminalCenterY))
            //                    {
            //                        fNearestCenter = Math.Abs(m_objEBlobs.ref_arrLimitCenterY[i] - fNorminalCenterY);
            //                        intSelectedObjectInddex = i;
            //                    }
            //                }

            //                fLimitCenterX = m_objEBlobs.ref_arrLimitCenterX[intSelectedObjectInddex];
            //                fLimitCenterY = m_objEBlobs.ref_arrLimitCenterY[intSelectedObjectInddex];
            //                fWidth = m_objEBlobs.ref_arrWidth[intSelectedObjectInddex];
            //                fHeight = m_objEBlobs.ref_arrHeight[intSelectedObjectInddex];

            //                pLeftPoint = new PointF(intOffsetX + fLimitCenterX - fWidth / 2, intOffsetY + fLimitCenterY - fHeight / 2);
            //                pRightPoint = new PointF(intOffsetX + fLimitCenterX + fWidth / 2, intOffsetY + fLimitCenterY + fHeight / 2);
            //            }
            //            break;
            //    }
            //    return true;
            //}



            return false;
        }

        public void DefineCenterUnitEdge(PointF pTopLeftCorner, PointF pTopRightCorner,
                                         PointF pRightTopCorner, PointF pRightBottomCorner,
                                         PointF pBottomLeftCorner, PointF pBottomRightCorner,
                                         PointF pLeftTopCorner, PointF pLeftBottomCorner)
        {
            m_blnFailPosition = false;

            Line objTopLeftLine = new Line();
            objTopLeftLine.CalculateStraightLine(pTopLeftCorner, 0);
            Line objLeftTopLine = new Line();
            objLeftTopLine.CalculateStraightLine(pLeftTopCorner, 90);
            m_pCornerPoint_TopLeft = Line.GetCrossPoint(objTopLeftLine, objLeftTopLine);

            Line objTopRightLine = new Line();
            objTopRightLine.CalculateStraightLine(pTopRightCorner, 0);
            Line objRightTopLine = new Line();
            objRightTopLine.CalculateStraightLine(pRightTopCorner, 90);
            m_pCornerPoint_TopRight = Line.GetCrossPoint(objTopRightLine, objRightTopLine);

            Line objBottomLeftLine = new Line();
            objBottomLeftLine.CalculateStraightLine(pBottomLeftCorner, 0);
            Line objLeftBottomLine = new Line();
            objLeftBottomLine.CalculateStraightLine(pLeftBottomCorner, 90);
            m_pCornerPoint_BottomLeft = Line.GetCrossPoint(objBottomLeftLine, objLeftBottomLine);

            Line objBottomRightLine = new Line();
            objBottomRightLine.CalculateStraightLine(pBottomRightCorner, 0);
            Line objRightBottomLine = new Line();
            objRightBottomLine.CalculateStraightLine(pRightBottomCorner, 90);
            m_pCornerPoint_BottomRight = Line.GetCrossPoint(objBottomRightLine, objRightBottomLine);

            /*
             * Refer Formula 1.docx from server
             */
            Line objTopLine = new Line();
            objTopLine.CalculateStraightLine(m_pCornerPoint_TopLeft, m_pCornerPoint_TopRight);
            float fTopAngle;
            if (objTopLine.ref_dAngle > 0)
                fTopAngle = -90 + (float)objTopLine.ref_dAngle; // Convert angle from negative value to positive value
            else
                fTopAngle = 90 + (float)objTopLine.ref_dAngle; //-(float)objTopLine.ref_dAngle;     // Convert angle from positive value to negative value

            Line objBottomLine = new Line();
            objBottomLine.CalculateStraightLine(m_pCornerPoint_BottomLeft, m_pCornerPoint_BottomRight);
            float fBottomAngle;
            if (objBottomLine.ref_dAngle > 0)
                fBottomAngle = -90 + (float)objBottomLine.ref_dAngle; // Convert angle from negative value to positive value
            else
                fBottomAngle = 90 + (float)objBottomLine.ref_dAngle; //-(float)objBottomLine.ref_dAngle;     // Convert angle from positive value to negative value

            //if (objBottomLine.ref_dAngle < 0)
            //    fBottomAngle = -90 - (float)objBottomLine.ref_dAngle;
            //else
            //    fBottomAngle = 90 - (float)objBottomLine.ref_dAngle;

            Line objLeftLine = new Line();
            objLeftLine.CalculateStraightLine(m_pCornerPoint_TopLeft, m_pCornerPoint_BottomLeft);
            float fLeftAngle = (float)objLeftLine.ref_dAngle;
            Line objRightLine = new Line();
            objRightLine.CalculateStraightLine(m_pCornerPoint_TopRight, m_pCornerPoint_BottomRight);
            float fRightAngle = (float)objRightLine.ref_dAngle;

            m_fCenterUnitAngle = (fTopAngle + fBottomAngle + fLeftAngle + fRightAngle) / 4;
            m_fCenterUnitWidth = (Math2.GetDistanceBtw2Points(m_pCornerPoint_TopLeft, m_pCornerPoint_TopRight) +
                                  Math2.GetDistanceBtw2Points(m_pCornerPoint_BottomLeft, m_pCornerPoint_BottomRight)) / 2;
            m_fCenterUnitHeight = (Math2.GetDistanceBtw2Points(m_pCornerPoint_TopLeft, m_pCornerPoint_BottomLeft) +
                                   Math2.GetDistanceBtw2Points(m_pCornerPoint_TopRight, m_pCornerPoint_BottomRight)) / 2;

            Line objLine1 = new Line();
            objLine1.CalculateStraightLine(m_pCornerPoint_TopLeft, m_pCornerPoint_BottomRight);
            Line objLine2 = new Line();
            objLine2.CalculateStraightLine(m_pCornerPoint_TopRight, m_pCornerPoint_BottomLeft);

            m_pCornerPoint_Center = Line.GetCrossPoint(objLine1, objLine2);

        }

        public void DefineCenterLeadsRange(ref float fStartX, ref float fStartY, ref float fEndX, ref float fEndY)
        {
            BlobsFeatures stcBlobsFeatures;
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                stcBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                if (fStartX > stcBlobsFeatures.fStartX)
                    fStartX = stcBlobsFeatures.fStartX;

                if (fStartY > stcBlobsFeatures.fStartY)
                    fStartY = stcBlobsFeatures.fStartY;

                if (fEndX < stcBlobsFeatures.fEndX)
                    fEndX = stcBlobsFeatures.fEndX;

                if (fEndY < stcBlobsFeatures.fEndY)
                    fEndY = stcBlobsFeatures.fEndY;
            }
        }

        public void FindLeads(ROI objROI)
        {
            //#if (DEBUG)
            //            objROI.SaveImage("D:\\TS\\objROI.bmp");
            //#endif


            m_arrTemplateBlobLeads.Clear();

            if (m_intLeadDirection == 0)    // Horizontal Leads
            {
                m_objLocalROI.AttachImage(objROI);
                if (m_blnWantUsePkgToBaseTolerance)
                    m_objLocalROI.LoadROISetting(0, 0,
                                         (int)Math.Round(m_pCornerPoint_Center.X - m_fCenterUnitWidth / 2 - m_intTipBuildAreaTolerance_Left - objROI.ref_ROITotalX, 0, MidpointRounding.AwayFromZero),
                                         objROI.ref_ROIHeight);
                else
                    m_objLocalROI.LoadROISetting(0, 0,
                                            (int)Math.Max(m_pCornerPoint_TopLeft.X, m_pCornerPoint_BottomLeft.X) - objROI.ref_ROITotalX,
                                            objROI.ref_ROIHeight);

                BuildOnlyLeadObjects(m_objLocalROI);
                SetBlobsFeaturesToArray_CenterLead3D_SingleSide(m_objEBlobs, m_arrTemplateBlobLeads, m_objLocalROI, m_intNumberOfLead_Left, m_intLeadDirection, 1);     // Left
                FilterBlob();

                if (m_blnWantUsePkgToBaseTolerance)
                    m_objLocalROI.LoadROISetting((int)Math.Round(m_pCornerPoint_Center.X + m_fCenterUnitWidth / 2 + m_intTipBuildAreaTolerance_Right - objROI.ref_ROITotalX, 0, MidpointRounding.AwayFromZero),
                                              0,
                                              objROI.ref_ROIWidth - (int)Math.Round(m_pCornerPoint_Center.X + m_fCenterUnitWidth / 2 + m_intTipBuildAreaTolerance_Right - objROI.ref_ROITotalX, 0, MidpointRounding.AwayFromZero),
                                              objROI.ref_ROIHeight);
                else
                    m_objLocalROI.LoadROISetting((int)Math.Min(m_pCornerPoint_TopRight.X, m_pCornerPoint_BottomRight.X) - objROI.ref_ROITotalX,
                                              0,
                                              objROI.ref_ROITotalX + objROI.ref_ROIWidth - (int)Math.Min(m_pCornerPoint_TopRight.X, m_pCornerPoint_BottomRight.X),
                                              objROI.ref_ROIHeight);
                BuildOnlyLeadObjects(m_objLocalROI);
                SetBlobsFeaturesToArray_CenterLead3D_SingleSide(m_objEBlobs, m_arrTemplateBlobLeads, m_objLocalROI, m_intNumberOfLead_Right, m_intLeadDirection, 2);    // Right
                FilterBlob();

            }
            else
            {
                m_objLocalROI.AttachImage(objROI);
                if (m_blnWantUsePkgToBaseTolerance)
                    m_objLocalROI.LoadROISetting(0, 0,
                                           objROI.ref_ROIWidth,
                                           (int)Math.Round(m_pCornerPoint_Center.Y - m_fCenterUnitHeight / 2 - m_intTipBuildAreaTolerance_Top - objROI.ref_ROITotalY, 0, MidpointRounding.AwayFromZero));
                else
                    m_objLocalROI.LoadROISetting(0, 0,
                                             objROI.ref_ROIWidth,
                                            (int)Math.Max(m_pCornerPoint_TopLeft.Y, m_pCornerPoint_TopRight.Y) - objROI.ref_ROITotalY);

                BuildOnlyLeadObjects(m_objLocalROI);
                SetBlobsFeaturesToArray_CenterLead3D_SingleSide(m_objEBlobs, m_arrTemplateBlobLeads, m_objLocalROI, m_intNumberOfLead_Top, m_intLeadDirection, 4);     // Top
                FilterBlob();

                if (m_blnWantUsePkgToBaseTolerance)
                    m_objLocalROI.LoadROISetting(0,
                                           (int)Math.Round(m_pCornerPoint_Center.Y + m_intTipBuildAreaTolerance_Bottom + m_fCenterUnitHeight / 2 - objROI.ref_ROITotalY, 0, MidpointRounding.AwayFromZero),
                                            objROI.ref_ROIWidth,
                                            objROI.ref_ROIHeight - (int)Math.Round(m_pCornerPoint_Center.Y + m_fCenterUnitHeight / 2 + m_intTipBuildAreaTolerance_Bottom - objROI.ref_ROITotalY, 0, MidpointRounding.AwayFromZero));
                else
                    m_objLocalROI.LoadROISetting(0,
                                            (int)Math.Min(m_pCornerPoint_BottomLeft.Y, m_pCornerPoint_BottomRight.Y) - objROI.ref_ROITotalY,
                                              objROI.ref_ROIWidth,
                                              objROI.ref_ROITotalY + objROI.ref_ROIHeight - (int)Math.Min(m_pCornerPoint_BottomLeft.Y, m_pCornerPoint_BottomRight.Y));
                BuildOnlyLeadObjects(m_objLocalROI);
                SetBlobsFeaturesToArray_CenterLead3D_SingleSide(m_objEBlobs, m_arrTemplateBlobLeads, m_objLocalROI, m_intNumberOfLead_Bottom, m_intLeadDirection, 8);    // Bottom
                FilterBlob();

            }
        }

        public void SortObjectNumber_Lead3D()
        {
            int intNoID = 1;
            BlobsFeatures stcBlobsFeatures = new BlobsFeatures();
            int[] intDirectionOrder = { -1, -1, -1, -1, -1, -1, -1, -1, -1 };

            #region Set Direction Sequence
            bool blnTopFound = false;
            bool blnBottomFound = false;
            bool blnLeftFound = false;
            bool blnRightFound = false;
            int intOneColumn = 0;
            int intOneRow = 0;
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                if (!m_stcBlobLead.blnSelected)
                    continue;

                if (m_stcBlobLead.intDirection == 1)
                    blnLeftFound = true;

                if (m_stcBlobLead.intDirection == 2)
                    blnRightFound = true;

                if (m_stcBlobLead.intDirection == 4)
                    blnTopFound = true;

                if (m_stcBlobLead.intDirection == 8)
                    blnBottomFound = true;

                if (m_stcBlobLead.intDirection == 5)
                {
                    blnTopFound = true;
                    blnLeftFound = true;
                }

                if (m_stcBlobLead.intDirection == 9)
                {
                    blnBottomFound = true;
                    blnLeftFound = true;
                }

                if (m_stcBlobLead.intDirection == 6)
                {
                    blnTopFound = true;
                    blnRightFound = true;
                }

                if (m_stcBlobLead.intDirection == 10)
                {
                    blnBottomFound = true;
                    blnRightFound = true;
                }

            }

            int intIndex = 0;
            //switch (m_intFirstLead)
            //{
            //    case 0: // Top
            //        {
            //            if (m_blnClockWise)
            //            {
            //                intDirectionOrder[intIndex++] = 4;
            //                intDirectionOrder[intIndex++] = 2;
            //                intDirectionOrder[intIndex++] = 8;
            //                intDirectionOrder[intIndex++] = 1;
            //            }
            //            else
            //            {
            //                intDirectionOrder[intIndex++] = 4;
            //                intDirectionOrder[intIndex++] = 1;
            //                intDirectionOrder[intIndex++] = 8;
            //                intDirectionOrder[intIndex++] = 2;
            //            }
            //        }
            //        break;
            //    case 1: // Right
            //        {
            //            if (m_blnClockWise)
            //            {
            //                intDirectionOrder[intIndex++] = 2;
            //                intDirectionOrder[intIndex++] = 8;
            //                intDirectionOrder[intIndex++] = 1;
            //                intDirectionOrder[intIndex++] = 4;
            //            }
            //            else
            //            {
            //                intDirectionOrder[intIndex++] = 2;
            //                intDirectionOrder[intIndex++] = 4;
            //                intDirectionOrder[intIndex++] = 1;
            //                intDirectionOrder[intIndex++] = 8;
            //            }
            //        }
            //        break;
            //    case 2: //Bottom
            //        {
            //            if (m_blnClockWise)
            //            {
            //                intDirectionOrder[intIndex++] = 8;
            //                intDirectionOrder[intIndex++] = 1;
            //                intDirectionOrder[intIndex++] = 4;
            //                intDirectionOrder[intIndex++] = 2;
            //            }
            //            else
            //            {
            //                intDirectionOrder[intIndex++] = 8;
            //                intDirectionOrder[intIndex++] = 2;
            //                intDirectionOrder[intIndex++] = 4;
            //                intDirectionOrder[intIndex++] = 1;
            //            }
            //        }
            //        break;
            //    case 3: // Right
            //        {
            //            if (m_blnClockWise)
            //            {
            //                intDirectionOrder[intIndex++] = 1;
            //                intDirectionOrder[intIndex++] = 4;
            //                intDirectionOrder[intIndex++] = 2;
            //                intDirectionOrder[intIndex++] = 8;
            //            }
            //            else
            //            {
            //                intDirectionOrder[intIndex++] = 1;
            //                intDirectionOrder[intIndex++] = 8;
            //                intDirectionOrder[intIndex++] = 2;
            //                intDirectionOrder[intIndex++] = 4;
            //            }
            //        }
            //        break;
            //}
            {
                switch (m_intFirstLead)
                {
                    case 1:
                        {
                            if (m_blnClockWise)
                            {
                                if (blnTopFound || !blnLeftFound && !blnRightFound)
                                {
                                    intDirectionOrder[intIndex++] = 5;

                                }

                                intDirectionOrder[intIndex++] = 4;
                                intDirectionOrder[intIndex++] = 6;
                                intDirectionOrder[intIndex++] = 2;
                                intDirectionOrder[intIndex++] = 10;
                                intDirectionOrder[intIndex++] = 8;
                                intDirectionOrder[intIndex++] = 9;
                                intDirectionOrder[intIndex++] = 1;

                                if (!blnTopFound && (blnLeftFound || blnRightFound))
                                    intDirectionOrder[intIndex++] = 5;

                                intDirectionOrder[intIndex] = 0;
                            }
                            else
                            {
                                if (blnLeftFound || !blnTopFound && !blnBottomFound)
                                {
                                    intDirectionOrder[intIndex++] = 5;
                                }

                                intDirectionOrder[intIndex++] = 1;
                                intDirectionOrder[intIndex++] = 9;
                                intDirectionOrder[intIndex++] = 8;
                                intDirectionOrder[intIndex++] = 10;
                                intDirectionOrder[intIndex++] = 2;
                                intDirectionOrder[intIndex++] = 6;
                                intDirectionOrder[intIndex++] = 4;

                                if (!blnLeftFound && (blnTopFound || blnBottomFound))
                                    intDirectionOrder[intIndex++] = 5;

                                intDirectionOrder[intIndex] = 0;
                            }
                        }
                        break;
                    case 2:
                        {
                            if (m_blnClockWise)
                            {
                                if (blnRightFound || !blnTopFound && !blnBottomFound)
                                {
                                    intDirectionOrder[intIndex++] = 6;

                                }

                                intDirectionOrder[intIndex++] = 2;
                                intDirectionOrder[intIndex++] = 10;
                                intDirectionOrder[intIndex++] = 8;
                                intDirectionOrder[intIndex++] = 9;
                                intDirectionOrder[intIndex++] = 1;
                                intDirectionOrder[intIndex++] = 5;
                                intDirectionOrder[intIndex++] = 4;

                                if (!blnRightFound && (blnTopFound || blnBottomFound))
                                    intDirectionOrder[intIndex++] = 6;

                                intDirectionOrder[intIndex] = 0;
                            }
                            else
                            {
                                if (blnTopFound || !blnLeftFound && !blnRightFound)
                                {
                                    intDirectionOrder[intIndex++] = 6;

                                }

                                intDirectionOrder[intIndex++] = 4;
                                intDirectionOrder[intIndex++] = 5;
                                intDirectionOrder[intIndex++] = 1;
                                intDirectionOrder[intIndex++] = 9;
                                intDirectionOrder[intIndex++] = 8;
                                intDirectionOrder[intIndex++] = 10;
                                intDirectionOrder[intIndex++] = 2;

                                if (!blnTopFound && (blnLeftFound || blnRightFound))
                                    intDirectionOrder[intIndex++] = 6;

                                intDirectionOrder[intIndex] = 0;
                            }
                        }
                        break;
                    case 3: // Bottom Left
                        {
                            if (m_blnClockWise)
                            {
                                if (blnLeftFound || !blnTopFound && !blnBottomFound)
                                {
                                    intDirectionOrder[intIndex++] = 9;

                                }

                                intDirectionOrder[intIndex++] = 1;
                                intDirectionOrder[intIndex++] = 5;
                                intDirectionOrder[intIndex++] = 4;
                                intDirectionOrder[intIndex++] = 6;
                                intDirectionOrder[intIndex++] = 2;
                                intDirectionOrder[intIndex++] = 10;
                                intDirectionOrder[intIndex++] = 8;

                                if (!blnLeftFound && (blnTopFound || blnBottomFound))
                                    intDirectionOrder[intIndex++] = 9;

                                intDirectionOrder[intIndex] = 0;
                            }
                            else
                            {
                                if (blnBottomFound || !blnLeftFound && !blnRightFound)
                                {
                                    intDirectionOrder[intIndex++] = 9;

                                }

                                intDirectionOrder[intIndex++] = 8;
                                intDirectionOrder[intIndex++] = 10;
                                intDirectionOrder[intIndex++] = 2;
                                intDirectionOrder[intIndex++] = 6;
                                intDirectionOrder[intIndex++] = 4;
                                intDirectionOrder[intIndex++] = 5;
                                intDirectionOrder[intIndex++] = 1;

                                if (!blnBottomFound && (blnLeftFound || blnRightFound))
                                    intDirectionOrder[intIndex++] = 9;

                                intDirectionOrder[intIndex] = 0;
                            }
                        }
                        break;
                    case 4: // Bottom Right
                        {
                            if (m_blnClockWise)
                            {
                                if (blnBottomFound || !blnLeftFound && !blnRightFound)
                                {
                                    intDirectionOrder[intIndex++] = 10;

                                }

                                intDirectionOrder[intIndex++] = 8;
                                intDirectionOrder[intIndex++] = 9;
                                intDirectionOrder[intIndex++] = 1;
                                intDirectionOrder[intIndex++] = 5;
                                intDirectionOrder[intIndex++] = 4;
                                intDirectionOrder[intIndex++] = 6;
                                intDirectionOrder[intIndex++] = 2;

                                if (!blnBottomFound && (blnLeftFound || blnRightFound))
                                    intDirectionOrder[intIndex++] = 10;

                                intDirectionOrder[intIndex] = 0;
                            }
                            else
                            {
                                if (blnRightFound || !blnTopFound && !blnBottomFound)
                                {
                                    intDirectionOrder[intIndex++] = 10;

                                }

                                intDirectionOrder[intIndex++] = 2;
                                intDirectionOrder[intIndex++] = 6;
                                intDirectionOrder[intIndex++] = 4;
                                intDirectionOrder[intIndex++] = 5;
                                intDirectionOrder[intIndex++] = 1;
                                intDirectionOrder[intIndex++] = 9;
                                intDirectionOrder[intIndex++] = 8;

                                if (!blnRightFound && (blnTopFound || blnBottomFound))
                                    intDirectionOrder[intIndex++] = 10;

                                intDirectionOrder[intIndex] = 0;
                            }
                        }
                        break;
                }
            }
            #endregion

            #region Known Direction
            for (int d = 0; d < intDirectionOrder.Length; d++)
            {
                if (intDirectionOrder[d] == -1)
                    continue;

                for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)

                {
                    m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                    if (!m_stcBlobLead.blnSelected)
                        continue;

                    if (m_stcBlobLead.intDirection == intDirectionOrder[d])
                    {
                        m_stcBlobLead.intNoID = intNoID;

                        for (int j = 0; j < i; j++)
                        {
                            stcBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobLeads[j];

                            if (!stcBlobsFeatures.blnSelected)
                                continue;

                            if (stcBlobsFeatures.intDirection == intDirectionOrder[d])
                            {
                                if ((intDirectionOrder[d] == 5) || (intDirectionOrder[d] == 4) || (intDirectionOrder[d] == 6) || (intDirectionOrder[d] == 12) || (intDirectionOrder[d] == 13) || (intDirectionOrder[d] == 14))
                                {
                                    if (m_blnClockWise)
                                    {
                                        if (m_stcBlobLead.intStartX < stcBlobsFeatures.intStartX)
                                        {
                                            if (m_stcBlobLead.intNoID > stcBlobsFeatures.intNoID)
                                                m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                        }
                                    }
                                    else
                                    {
                                        if (m_stcBlobLead.intStartX > stcBlobsFeatures.intStartX)
                                        {
                                            if (m_stcBlobLead.intNoID > stcBlobsFeatures.intNoID)
                                                m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                        }
                                    }
                                }
                                else if ((intDirectionOrder[d] == 2) || (intDirectionOrder[d] == 0) || (intDirectionOrder[d] == 7) || (intDirectionOrder[d] == 3) || (intDirectionOrder[d] == 11))
                                {
                                    if (m_blnClockWise)
                                    {
                                        if (m_stcBlobLead.intStartY < stcBlobsFeatures.intStartY)
                                        {
                                            if (m_stcBlobLead.intNoID > stcBlobsFeatures.intNoID)
                                                m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                        }
                                    }
                                    else
                                    {
                                        if (m_stcBlobLead.intStartY > stcBlobsFeatures.intStartY)
                                        {
                                            if (m_stcBlobLead.intNoID > stcBlobsFeatures.intNoID)
                                                m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                        }
                                    }
                                }
                                else if ((intDirectionOrder[d] == 10) || (intDirectionOrder[d] == 8) || (intDirectionOrder[d] == 9))
                                {
                                    if (m_blnClockWise)
                                    {
                                        if (m_stcBlobLead.intStartX > stcBlobsFeatures.intStartX)
                                        {
                                            if (m_stcBlobLead.intNoID > stcBlobsFeatures.intNoID)
                                                m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                        }
                                    }
                                    else
                                    {
                                        if (m_stcBlobLead.intStartX < stcBlobsFeatures.intStartX)
                                        {
                                            if (m_stcBlobLead.intNoID > stcBlobsFeatures.intNoID)
                                                m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                        }
                                    }
                                }
                                else
                                {
                                    if (m_blnClockWise)
                                    {
                                        if (m_stcBlobLead.intStartY > stcBlobsFeatures.intStartY)
                                        {
                                            if (m_stcBlobLead.intNoID > stcBlobsFeatures.intNoID)
                                                m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                        }
                                    }
                                    else
                                    {
                                        if (m_stcBlobLead.intStartY < stcBlobsFeatures.intStartY)
                                        {
                                            if (m_stcBlobLead.intNoID > stcBlobsFeatures.intNoID)
                                                m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                        }
                                    }
                                }
                            }
                        }

                        for (int j = 0; j < i; j++)
                        {
                            stcBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobLeads[j];
                            if (stcBlobsFeatures.intDirection == intDirectionOrder[d])
                            {
                                if (m_stcBlobLead.intNoID <= stcBlobsFeatures.intNoID)
                                {
                                    stcBlobsFeatures.intNoID++;
                                    m_arrTemplateBlobLeads.RemoveAt(j);
                                    m_arrTemplateBlobLeads.Insert(j, stcBlobsFeatures);
                                }
                            }
                        }
                        intNoID++;

                        m_arrTemplateBlobLeads.RemoveAt(i);
                        m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
                    }
                }
            }
            #endregion

            #region Unknown Direction

            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                if (!m_stcBlobLead.blnSelected)
                    continue;

                if (m_stcBlobLead.intNoID == 0)
                {
                    m_stcBlobLead.intNoID = intNoID;
                    m_arrTemplateBlobLeads.RemoveAt(i);
                    m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
                    intNoID++;
                }
            }

            List<string> arrData = new List<string>();
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                arrData.Add(m_stcBlobLead.fLimitCenterX.ToString() + ", " + m_stcBlobLead.fLimitCenterY.ToString() + ", " + m_stcBlobLead.intDirection.ToString() + ", " + m_stcBlobLead.intNoID.ToString());
            }

            #endregion

            #region Sort m_arrTemplateBlobLeads according to lable 

            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                int intSelectedIndex = -1;
                int intSmallestID = m_arrTemplateBlobLeads.Count;
                for (int j = i; j < m_arrTemplateBlobLeads.Count; j++)
                {
                    m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[j];

                    if (intSmallestID > m_stcBlobLead.intNoID)
                    {
                        intSelectedIndex = j;
                        intSmallestID = m_stcBlobLead.intNoID;
                    }
                }

                if (intSelectedIndex >= 0)
                {
                    m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[intSelectedIndex];
                    m_arrTemplateBlobLeads.RemoveAt(intSelectedIndex);
                    m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
                }
            }

            #endregion
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                if (m_intLeadDirection == 0)
                {
                    if (m_stcBlobLead.intDirection == 5 || m_stcBlobLead.intDirection == 9 || m_stcBlobLead.intDirection == 14)
                        m_stcBlobLead.intDirection = 1;

                    if (m_stcBlobLead.intDirection == 6 || m_stcBlobLead.intDirection == 10 || m_stcBlobLead.intDirection == 13)
                        m_stcBlobLead.intDirection = 2;
                }
                else
                {
                    if (m_stcBlobLead.intDirection == 5 || m_stcBlobLead.intDirection == 6 || m_stcBlobLead.intDirection == 11)
                        m_stcBlobLead.intDirection = 4;

                    if (m_stcBlobLead.intDirection == 9 || m_stcBlobLead.intDirection == 10 || m_stcBlobLead.intDirection == 7)
                        m_stcBlobLead.intDirection = 8;
                }

                m_arrTemplateBlobLeads.RemoveAt(i);
                m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);

            }
        }

        public void SaveLeadToleranceToFile(string strPath, bool blnNewFile, string strSectionName, bool blnNewSection)
        {
            XmlParser objFile = new XmlParser(strPath, blnNewFile);

            objFile.WriteSectionElement(strSectionName, blnNewSection);

            objFile.WriteElement1Value("LeadMinSpanLimit", m_fTemplateLeadMinSpanLimit);
            objFile.WriteElement1Value("LeadMaxSpanLimit", m_fTemplateLeadMaxSpanLimit);
            objFile.WriteElement1Value("TotalLeads", m_arrTemplateBlobLeads.Count);

            for (int p = 0; p < m_arrTemplateBlobLeads.Count; p++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[p];

                objFile.WriteElement1Value("Lead" + p.ToString(), "");
                objFile.WriteElement2Value("Skew", m_stcBlobLead.fSkew);
                objFile.WriteElement2Value("Offset", m_stcBlobLead.fOffSet);
                objFile.WriteElement2Value("MinTipWidth", m_stcBlobLead.fMinTipWidth);
                objFile.WriteElement2Value("MaxTipWidth", m_stcBlobLead.fMaxTipWidth);
                objFile.WriteElement2Value("MinTipHeight", m_stcBlobLead.fMinTipLength);
                objFile.WriteElement2Value("MaxTipHeight", m_stcBlobLead.fMaxTipLength);
                objFile.WriteElement2Value("MinPitch", m_stcBlobLead.fMinPitch);
                objFile.WriteElement2Value("MaxPitch", m_stcBlobLead.fMaxPitch);
                objFile.WriteElement2Value("MinGap", m_stcBlobLead.fMinGap);
                objFile.WriteElement2Value("MaxGap", m_stcBlobLead.fMaxGap);
                objFile.WriteElement2Value("MinStandOff", m_stcBlobLead.fMinStandOff);
                objFile.WriteElement2Value("MaxStandOff", m_stcBlobLead.fMaxStandOff);         
                objFile.WriteElement2Value("MaxCoplan", m_stcBlobLead.fMaxCoplan);
                objFile.WriteElement2Value("MinAGV", m_stcBlobLead.fMinAGV);
                objFile.WriteElement2Value("MaxAGV", m_stcBlobLead.fMaxAGV);
                objFile.WriteElement2Value("LimitMinWidth", m_stcBlobLead.fLeadLimitMinWidth);
                objFile.WriteElement2Value("LimitMaxWidth", m_stcBlobLead.fLeadLimitMaxWidth);
                objFile.WriteElement2Value("LimitBurrWidth", m_stcBlobLead.fLeadMaxBurrWidth);
                objFile.WriteElement2Value("PitchVarianceLeftMaxSetting", m_fPitchVarianceLeftMaxSetting);
                objFile.WriteElement2Value("PitchVarianceRightMaxSetting", m_fPitchVarianceRightMaxSetting);
                objFile.WriteElement2Value("PitchVarianceTopMaxSetting", m_fPitchVarianceTopMaxSetting);
                objFile.WriteElement2Value("PitchVarianceBottomMaxSetting", m_fPitchVarianceBottomMaxSetting);
                objFile.WriteElement2Value("StandOffVarianceUnitMaxSetting", m_fStandOffVarianceUnitMaxSetting);
                objFile.WriteElement2Value("LeadSweepVarianceLeftMinSetting", m_fLeadSweepVarianceLeftMinSetting);
                objFile.WriteElement2Value("LeadSweepVarianceRightMinSetting", m_fLeadSweepVarianceRightMinSetting);
                objFile.WriteElement2Value("LeadSweepVarianceTopMinSetting", m_fLeadSweepVarianceTopMinSetting);
                objFile.WriteElement2Value("LeadSweepVarianceBottomMinSetting", m_fLeadSweepVarianceBottomMinSetting);
                objFile.WriteElement2Value("LeadSweepVarianceLeftMaxSetting", m_fLeadSweepVarianceLeftMaxSetting);
                objFile.WriteElement2Value("LeadSweepVarianceRightMaxSetting", m_fLeadSweepVarianceRightMaxSetting);
                objFile.WriteElement2Value("LeadSweepVarianceTopMaxSetting", m_fLeadSweepVarianceTopMaxSetting);
                objFile.WriteElement2Value("LeadSweepVarianceBottomMaxSetting", m_fLeadSweepVarianceBottomMaxSetting);
                objFile.WriteElement2Value("LengthVarianceOverallMaxSetting", m_fLengthVarianceOverallMaxSetting);
                objFile.WriteElement2Value("LengthVarianceLeftMaxSetting", m_fLengthVarianceLeftMaxSetting);
                objFile.WriteElement2Value("LengthVarianceRightMaxSetting", m_fLengthVarianceRightMaxSetting);
                objFile.WriteElement2Value("LengthVarianceTopMaxSetting", m_fLengthVarianceTopMaxSetting);
                objFile.WriteElement2Value("LengthVarianceBottomMaxSetting", m_fLengthVarianceBottomMaxSetting);
                objFile.WriteElement2Value("StandOffVarianceLeftMaxSetting", m_fStandOffVarianceLeftMaxSetting);
                objFile.WriteElement2Value("StandOffVarianceRightMaxSetting", m_fStandOffVarianceRightMaxSetting);
                objFile.WriteElement2Value("StandOffVarianceTopMaxSetting", m_fStandOffVarianceTopMaxSetting);
                objFile.WriteElement2Value("StandOffVarianceBottomMaxSetting", m_fStandOffVarianceBottomMaxSetting);
                objFile.WriteElement2Value("StandOffVarianceUnitMaxSetting", m_fStandOffVarianceUnitMaxSetting);
                objFile.WriteElement2Value("SpanOverallMinSetting", m_fSpanOverallMinSetting);
                objFile.WriteElement2Value("SpanOverallMaxSetting", m_fSpanOverallMaxSetting);
                objFile.WriteElement2Value("SpanTopMinSetting", m_fSpanTopMinSetting);
                objFile.WriteElement2Value("SpanTopMaxSetting", m_fSpanTopMaxSetting);
                objFile.WriteElement2Value("SpanBottomMinSetting", m_fSpanBottomMinSetting);
                objFile.WriteElement2Value("SpanBottomMaxSetting", m_fSpanBottomMaxSetting);
                objFile.WriteElement2Value("SpanLeftMinSetting", m_fSpanLeftMinSetting);
                objFile.WriteElement2Value("SpanLeftMaxSetting", m_fSpanLeftMaxSetting);
                objFile.WriteElement2Value("SpanRightMinSetting", m_fSpanRightMinSetting);
                objFile.WriteElement2Value("SpanRightMaxSetting", m_fSpanRightMaxSetting);
                objFile.WriteElement2Value("ExtraLeadSetArea", m_fExtraLeadSetArea);
                objFile.WriteElement2Value("TotalExtraLeadSetArea", m_fTotalExtraLeadSetArea);
                objFile.WriteElement2Value("ExtraLeadSetLength", m_fExtraLeadSetLength);
            }


            objFile.WriteEndElement();
        }

        public void LoadLeadToleranceFromFile(string strFilePath, string strSectionName)
        {
            XmlParser objFile = new XmlParser(strFilePath);

            objFile.GetFirstSection(strSectionName);

            m_fTemplateLeadMinSpanLimit = objFile.GetValueAsFloat("LeadMinSpanLimit", 3f, 1);
            m_fTemplateLeadMaxSpanLimit = objFile.GetValueAsFloat("LeadMaxSpanLimit", 4f, 1);

            int intTotalLeads = objFile.GetValueAsInt("TotalLeads", 0, 1);

            if (m_arrTemplateBlobLeads.Count == intTotalLeads)
            {
                for (int p = 0; p < intTotalLeads; p++)
                {
                    m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[p];

                    objFile.GetSecondSection("Lead" + p.ToString());
                    m_stcBlobLead.fSkew = objFile.GetValueAsFloat("Skew", 0, 2);
                    m_stcBlobLead.fOffSet = objFile.GetValueAsFloat("Offset", 0, 2);
                    m_stcBlobLead.fMinTipWidth = objFile.GetValueAsFloat("MinTipWidth", 0, 2);
                    m_stcBlobLead.fMaxTipWidth = objFile.GetValueAsFloat("MaxTipWidth", 0, 2);
                    m_stcBlobLead.fMinTipLength = objFile.GetValueAsFloat("MinTipHeight", 0, 2);
                    m_stcBlobLead.fMaxTipLength = objFile.GetValueAsFloat("MaxTipHeight", 0, 2);
                    m_stcBlobLead.fMinPitch = objFile.GetValueAsFloat("MinPitch", 0, 2);
                    m_stcBlobLead.fMaxPitch = objFile.GetValueAsFloat("MaxPitch", 0, 2);
                    m_stcBlobLead.fMinGap = objFile.GetValueAsFloat("MinGap", 0, 2);
                    m_stcBlobLead.fMaxGap = objFile.GetValueAsFloat("MaxGap", 0, 2);
                    m_stcBlobLead.fMinStandOff = objFile.GetValueAsFloat("MinStandOff", 0, 2);
                    m_stcBlobLead.fMaxStandOff = objFile.GetValueAsFloat("MaxStandOff", 0, 2);
                    m_stcBlobLead.fMaxCoplan = objFile.GetValueAsFloat("MaxCoplan", 0, 2);
                    m_stcBlobLead.fMinAGV = objFile.GetValueAsFloat("MinAGV", 0, 2);
                    m_stcBlobLead.fMaxAGV = objFile.GetValueAsFloat("MaxAGV", 0, 2);
                    m_stcBlobLead.fLeadLimitMinWidth = objFile.GetValueAsFloat("LimitMinWidth", 0, 2);
                    m_stcBlobLead.fLeadLimitMaxWidth = objFile.GetValueAsFloat("LimitMaxWidth", 0, 2);
                    m_stcBlobLead.fLeadMaxBurrWidth = objFile.GetValueAsFloat("LimitBurrWidth", 0, 2);
                    m_fPitchVarianceLeftMaxSetting = objFile.GetValueAsFloat("PitchVarianceLeftMaxSetting", 0, 2);
                    m_fPitchVarianceRightMaxSetting = objFile.GetValueAsFloat("PitchVarianceRightMaxSetting", 0, 2);
                    m_fPitchVarianceTopMaxSetting = objFile.GetValueAsFloat("PitchVarianceTopMaxSetting", 0, 2);
                    m_fPitchVarianceBottomMaxSetting = objFile.GetValueAsFloat("PitchVarianceBottomMaxSetting", 0, 2);
                    m_fStandOffVarianceUnitMaxSetting = objFile.GetValueAsFloat("StandOffVarianceUnitMaxSetting", 0, 2);
                    m_fLeadSweepVarianceLeftMinSetting = objFile.GetValueAsFloat("LeadSweepVarianceLeftMinSetting", 0, 2);
                    m_fLeadSweepVarianceRightMinSetting = objFile.GetValueAsFloat("LeadSweepVarianceRightMinSetting", 0, 2);
                    m_fLeadSweepVarianceTopMinSetting = objFile.GetValueAsFloat("LeadSweepVarianceTopMinSetting", 0, 2);
                    m_fLeadSweepVarianceBottomMinSetting = objFile.GetValueAsFloat("LeadSweepVarianceBottomMinSetting", 0, 2);
                    m_fLeadSweepVarianceLeftMaxSetting = objFile.GetValueAsFloat("LeadSweepVarianceLeftMaxSetting", 0, 2);
                    m_fLeadSweepVarianceRightMaxSetting = objFile.GetValueAsFloat("LeadSweepVarianceRightMaxSetting", 0, 2);
                    m_fLeadSweepVarianceTopMaxSetting = objFile.GetValueAsFloat("LeadSweepVarianceTopMaxSetting", 0, 2);
                    m_fLeadSweepVarianceBottomMaxSetting = objFile.GetValueAsFloat("LeadSweepVarianceBottomMaxSetting", 0, 2);
                    m_fLengthVarianceOverallMaxSetting = objFile.GetValueAsFloat("LengthVarianceOverallMaxSetting", 0, 2);
                    m_fLengthVarianceLeftMaxSetting = objFile.GetValueAsFloat("LengthVarianceLeftMaxSetting", 0, 2);
                    m_fLengthVarianceRightMaxSetting = objFile.GetValueAsFloat("LengthVarianceRightMaxSetting", 0, 2);
                    m_fLengthVarianceTopMaxSetting = objFile.GetValueAsFloat("LengthVarianceTopMaxSetting", 0, 2);
                    m_fLengthVarianceBottomMaxSetting = objFile.GetValueAsFloat("LengthVarianceBottomMaxSetting", 0, 2);
                    m_fStandOffVarianceLeftMaxSetting = objFile.GetValueAsFloat("StandOffVarianceLeftMaxSetting", 0, 2);
                    m_fStandOffVarianceRightMaxSetting = objFile.GetValueAsFloat("StandOffVarianceRightMaxSetting", 0, 2);
                    m_fStandOffVarianceTopMaxSetting = objFile.GetValueAsFloat("StandOffVarianceTopMaxSetting", 0, 2);
                    m_fStandOffVarianceBottomMaxSetting = objFile.GetValueAsFloat("StandOffVarianceBottomMaxSetting", 0, 2);
                    m_fStandOffVarianceUnitMaxSetting = objFile.GetValueAsFloat("StandOffVarianceUnitMaxSetting", 0, 2);
                    m_fSpanOverallMinSetting = objFile.GetValueAsFloat("SpanOverallMinSetting", 0, 2);
                    m_fSpanOverallMaxSetting = objFile.GetValueAsFloat("SpanOverallMaxSetting", 0, 2);
                    m_fSpanTopMinSetting = objFile.GetValueAsFloat("SpanTopMinSetting", 0, 2);
                    m_fSpanTopMaxSetting = objFile.GetValueAsFloat("SpanTopMaxSetting", 0, 2);
                    m_fSpanBottomMinSetting = objFile.GetValueAsFloat("SpanBottomMinSetting", 0, 2);
                    m_fSpanBottomMaxSetting = objFile.GetValueAsFloat("SpanBottomMaxSetting", 0, 2);
                    m_fSpanLeftMinSetting = objFile.GetValueAsFloat("SpanLeftMinSetting", 0, 2);
                    m_fSpanLeftMaxSetting = objFile.GetValueAsFloat("SpanLeftMaxSetting", 0, 2);
                    m_fSpanRightMinSetting = objFile.GetValueAsFloat("SpanRightMinSetting", 0, 2);
                    m_fSpanRightMaxSetting = objFile.GetValueAsFloat("SpanRightMaxSetting", 0, 2);
                    m_fExtraLeadSetArea = objFile.GetValueAsFloat("ExtraLeadSetArea", 0, 2);
                    m_fTotalExtraLeadSetArea = objFile.GetValueAsFloat("TotalExtraLeadSetArea", 0, 2);
                    m_fExtraLeadSetLength = objFile.GetValueAsFloat("ExtraLeadSetLength", 0, 2);


                    m_arrTemplateBlobLeads[p] = m_stcBlobLead;
                }
            }
            else
                SRMMessageBox.Show("Total leads are different","",MessageBoxButtons.OK,MessageBoxIcon.Error);
        }

        public void GetTemplateLeadCenterPointsAndSize(int intLeadBorderDirection, ref List<int> arrLeadID, ref List<PointF> arrLeadCenterPoints, ref List<SizeF> arrLeadSizeF)
        {
            arrLeadCenterPoints.Clear();
            arrLeadSizeF.Clear();
            arrLeadID.Clear();

            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                if (m_stcBlobLead.intDirection == intLeadBorderDirection)
                {
                    arrLeadID.Add(m_stcBlobLead.intNoID);
                    arrLeadCenterPoints.Add(new PointF(m_stcBlobLead.fCenterX, m_stcBlobLead.fCenterY));
                    arrLeadSizeF.Add(new SizeF(m_stcBlobLead.fWidth, m_stcBlobLead.fHeight));
                }

            }
        }

        public void GetSampleLeadCenterPointsAndSize(int intLeadBorderDirection, ref List<int> arrLeadID, ref List<PointF> arrLeadCenterPoints, ref List<SizeF> arrLeadSizeF)
        {
            arrLeadCenterPoints.Clear();
            arrLeadSizeF.Clear();
            arrLeadID.Clear();

            for (int i = 0; i < m_arrSampleBlobLeads.Length; i++)
            {
                if (i < m_arrTemplateBlobLeads.Count)
                {
                    if (((BlobsFeatures)m_arrTemplateBlobLeads[i]).intDirection == intLeadBorderDirection)  // Use m_arrTemplateBlobLeads to check border direction because m_arrSampleBlobLeads and m_arrTemplateBlobLeads are same identity array.
                    {
                        arrLeadID.Add(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID);
                        arrLeadCenterPoints.Add(new PointF(m_arrSampleBlobLeads[i].fCenterX, m_arrSampleBlobLeads[i].fCenterY));
                        arrLeadSizeF.Add(new SizeF(m_arrSampleBlobLeads[i].fWidth, m_arrSampleBlobLeads[i].fHeight));
                    }
                }
            }
        }
        public void GetSampleLeadCenterPointsAndSize(int intLeadBorderDirection, ref List<int> arrLeadID, ref List<PointF> arrLeadCenterPoints, ref List<SizeF> arrLeadSizeF, ref List<int> arrLeadDirection, ref List<float> arrTipLength, ref List<float> arrWidthOffset, ref List<float> arrStandOffOffset, ref List<float> arrCoplanOffset)
        {
            arrLeadCenterPoints.Clear();
            arrLeadSizeF.Clear();
            arrLeadID.Clear();
            arrTipLength.Clear();

            for (int i = 0; i < m_arrSampleBlobLeads.Length; i++)
            {
                if (i < m_arrTemplateBlobLeads.Count)
                {
                    if (((BlobsFeatures)m_arrTemplateBlobLeads[i]).intDirection == intLeadBorderDirection)  // Use m_arrTemplateBlobLeads to check border direction because m_arrSampleBlobLeads and m_arrTemplateBlobLeads are same identity array.
                    {
                        arrLeadID.Add(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID);
                        arrLeadCenterPoints.Add(new PointF(m_arrSampleBlobLeads[i].fCenterX, m_arrSampleBlobLeads[i].fCenterY));
                        arrLeadSizeF.Add(new SizeF(m_arrSampleBlobLeads[i].fWidth, m_arrSampleBlobLeads[i].fHeight));
                        arrLeadDirection.Add(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intDirection);
                        arrTipLength.Add(m_arrSampleBlobLeads[i].fTipLength);
                        arrWidthOffset.Add(((BlobsFeatures)m_arrTemplateBlobLeads[i]).fWidthOffset);
                        arrStandOffOffset.Add(((BlobsFeatures)m_arrTemplateBlobLeads[i]).fStandOffOffset);
                        arrCoplanOffset.Add(((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCoplanOffset);
                    }
                }
            }
        }
        public void GetSampleLeadData(ref List<int> arrLeadID, ref List<float> arrLeadStandOff, ref List<float> arrLeadWidth)
        {
            arrLeadWidth.Clear();
            arrLeadStandOff.Clear();
            arrLeadID.Clear();

            for (int i = 0; i < m_arrSampleBlobLeads.Length; i++)
            {
                arrLeadID.Add(m_arrSampleBlobLeads[i].intNoID);
                arrLeadStandOff.Add(m_arrSampleBlobLeads[i].fStandOffMM);
                arrLeadWidth.Add(m_arrSampleBlobLeads[i].fTipWidthMM);
            }
        }
        private void AddSidePointGaugePlacementToArray(float fCenterX, float fCenterY, float fTolerance, float fAngle, int intLeadIndex)
        {
            //    TipCenter = 0
            //    TipStart = 1
            //    TipEnd = 2

            //m_arrLead3DSidePointGaugeStartX.Add(new List<float>());
            m_arrLead3DSidePointGaugeStartX[intLeadIndex].Add(fCenterX);
            m_arrLead3DSidePointGaugeStartX[intLeadIndex].Add(-1);
            m_arrLead3DSidePointGaugeStartX[intLeadIndex].Add(-1);

            //m_arrLead3DSidePointGaugeStartY.Add(new List<float>());
            m_arrLead3DSidePointGaugeStartY[intLeadIndex].Add(fCenterY);
            m_arrLead3DSidePointGaugeStartY[intLeadIndex].Add(-1);
            m_arrLead3DSidePointGaugeStartY[intLeadIndex].Add(-1);

            //m_arrLead3DSidePointGaugeTolerance.Add(new List<float>());
            m_arrLead3DSidePointGaugeTolerance[intLeadIndex].Add(fTolerance);
            m_arrLead3DSidePointGaugeTolerance[intLeadIndex].Add(-1);
            m_arrLead3DSidePointGaugeTolerance[intLeadIndex].Add(-1);

            //m_arrLead3DSidePointGaugeAngle.Add(new List<float>());
            m_arrLead3DSidePointGaugeAngle[intLeadIndex].Add(fAngle);
            m_arrLead3DSidePointGaugeAngle[intLeadIndex].Add(-1);
            m_arrLead3DSidePointGaugeAngle[intLeadIndex].Add(-1);
        }
        private void SetSidePointGaugePlacementToArray(float fCenterX, float fCenterY, float fTolerance, float fAngle, int intPosition, int intLeadIndex)
        {
            //    TipCenter = 0
            //    TipStart = 1
            //    TipEnd = 2

            m_arrLead3DSidePointGaugeStartX[intLeadIndex][intPosition] = fCenterX;
            m_arrLead3DSidePointGaugeStartY[intLeadIndex][intPosition] = fCenterY;
            m_arrLead3DSidePointGaugeTolerance[intLeadIndex][intPosition] = fTolerance;
            m_arrLead3DSidePointGaugeAngle[intLeadIndex][intPosition] = fAngle;
        }
        public void FindSideLeads(ROI objROI, List<int> arrLeadID, List<PointF> arrLeadCenterPoints, List<SizeF> arrLeadSize)
        {
            m_arrLead3DSidePointGaugeStartX.Clear();
            m_arrLead3DSidePointGaugeStartY.Clear();
            m_arrLead3DSidePointGaugeTolerance.Clear();
            m_arrLead3DSidePointGaugeAngle.Clear();
            m_arrLead3DEdgeSideGaugePoints.Clear();
            m_arrLead3DEdgeSideGaugePointsFound.Clear();
            m_arrLead3DEdgeSideGaugePointsPosition.Clear();
            m_arrTemplateBlobLeads.Clear();

            for (int p = m_arrLead3DEdgeSideGaugePoints.Count; p < arrLeadCenterPoints.Count; p++)
            {
                m_arrLead3DEdgeSideGaugePoints.Add(new List<PointF>());
                m_arrLead3DEdgeSideGaugePointsFound.Add(new List<bool>());
                m_arrLead3DEdgeSideGaugePointsPosition.Add(0);
                m_arrLead3DSidePointGaugeStartX.Add(new List<float>());
                m_arrLead3DSidePointGaugeStartY.Add(new List<float>());
                m_arrLead3DSidePointGaugeTolerance.Add(new List<float>());
                m_arrLead3DSidePointGaugeAngle.Add(new List<float>());
            }

            //2021-05-07 ZJYEOH : in case build extra blob during learn then need assign extra PGauge object
            for (int i = m_arrSidePointGauge.Count; i < arrLeadCenterPoints.Count; i++)
            {
                if (i >= m_arrSidePointGauge.Count)
                {
                    m_arrSidePointGauge.Add(new List<PGauge>());
                }

                for (int j = 0; j < 3; j++)
                {
                    if (j >= m_arrSidePointGauge[i].Count)
                    {
                        m_arrSidePointGauge[i].Add(new PGauge());
                    }

                    m_arrSidePointGauge[i][j].ref_GaugeMinAmplitude = 0;
                    m_arrSidePointGauge[i][j].ref_GaugeMinArea = 0;
                    m_arrSidePointGauge[i][j].ref_GaugeFilter = 2;

                    m_arrSidePointGauge[i][j].ref_objPointGauge.SetCenterXY(m_arrSidePointGauge[i - 1][j].ref_objPointGauge.CenterX, m_arrSidePointGauge[i - 1][j].ref_objPointGauge.CenterY);
                    m_arrSidePointGauge[i][j].ref_objPointGauge.MinAmplitude = m_arrSidePointGauge[i - 1][j].ref_objPointGauge.MinAmplitude;
                    m_arrSidePointGauge[i][j].ref_objPointGauge.MinArea = m_arrSidePointGauge[i - 1][j].ref_objPointGauge.MinArea;
                    m_arrSidePointGauge[i][j].ref_objPointGauge.Smoothing = m_arrSidePointGauge[i - 1][j].ref_objPointGauge.Smoothing;
                    m_arrSidePointGauge[i][j].ref_objPointGauge.Thickness = m_arrSidePointGauge[i - 1][j].ref_objPointGauge.Thickness;
                    m_arrSidePointGauge[i][j].ref_objPointGauge.Threshold = m_arrSidePointGauge[i - 1][j].ref_objPointGauge.Threshold;
                    m_arrSidePointGauge[i][j].ref_objPointGauge.TransitionType = m_arrSidePointGauge[i - 1][j].ref_objPointGauge.TransitionType;
                    m_arrSidePointGauge[i][j].ref_objPointGauge.TransitionChoice = m_arrSidePointGauge[i - 1][j].ref_objPointGauge.TransitionChoice;
                    m_arrSidePointGauge[i][j].ref_objPointGauge.Tolerance = m_arrSidePointGauge[i - 1][j].ref_objPointGauge.Tolerance;
                    m_arrSidePointGauge[i][j].ref_objPointGauge.Angle = m_arrSidePointGauge[i - 1][j].ref_objPointGauge.Angle;

                }
            }

            if (m_intLeadDirection == 0)    // Horizontal Leads 
            {
                //if (m_objSidePointGauge.ref_GaugeTransChoice != 2)
                //    m_objSidePointGauge.ref_GaugeTransChoice = 2;   // Use Largest Amplitude

                //if (m_objSidePointGauge.ref_GaugeTransType != 0)
                //    m_objSidePointGauge.ref_GaugeTransType = 0;     // Black to white

                int intPointGaugeAngle_Tip, intPointGaugeAngle_WidthStart, intPointGaugeAngle_WidthEnd;
                int intLeadBorderDirection;

                switch (m_intLeadROIDirection)
                {
                    default:
                    case 1: // Top
                        {
                            intPointGaugeAngle_Tip = -90;
                            intPointGaugeAngle_WidthStart = 180;
                            intPointGaugeAngle_WidthEnd = 0;
                            intLeadBorderDirection = 4;

                            for (int i = 0; i < arrLeadCenterPoints.Count; i++)
                            {
                                for (int p = m_arrLead3DEdgeSideGaugePoints.Count; p <= i; p++)
                                {
                                    m_arrLead3DEdgeSideGaugePoints.Add(new List<PointF>());
                                    m_arrLead3DEdgeSideGaugePointsFound.Add(new List<bool>());
                                }
                                m_arrLead3DEdgeSideGaugePointsPosition.Add(m_intLeadROIDirection);
                                // ------- Find Tip Point X -----------------------------------------
                                float fStartX = objROI.ref_ROITotalX;
                                float fEndX = m_objLineGauge.ref_ObjectCenterX;

                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].ref_GaugeTransType != 0)
                                    m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].ref_GaugeTransType = 0;

                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].SetGaugePlacement((fEndX + fStartX) / 2,
                                                                  arrLeadCenterPoints[i].Y,
                                                                  (fEndX - fStartX) / 2, intPointGaugeAngle_Tip);
                                AddSidePointGaugePlacementToArray((fEndX + fStartX) / 2,
                                                                  arrLeadCenterPoints[i].Y,
                                                                  (fEndX - fStartX) / 2, intPointGaugeAngle_Tip, i);
                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].Measure(objROI);

                                m_stcBlobLead = new BlobsFeatures();
                                m_stcBlobLead.intDirection = intLeadBorderDirection;    // Indicate this lead is from which border direction.
                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].ref_intMeasuredPointCount > 0)
                                {
                                    m_stcBlobLead.fTipCenterX = m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].GetMeasurePointX(0);
                                    m_stcBlobLead.fTipCenterY = m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].GetMeasurePointY(0);
                                    m_stcBlobLead.blnTipCenterFound = true;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(true);
                                }
                                else
                                {
                                    m_stcBlobLead.fTipCenterX = (fEndX + fStartX) / 2;
                                    m_stcBlobLead.fTipCenterY = arrLeadCenterPoints[i].Y;
                                    m_stcBlobLead.blnTipCenterFound = false;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(false);
                                }

                                // ------- Find lead width start point -----------------------------------------
                                float fStartY = m_stcBlobLead.fTipCenterY;
                                float fEndY = m_stcBlobLead.fTipCenterY - arrLeadSize[i].Height;
                                float fFixPointX = m_stcBlobLead.fTipCenterX + m_intTipOffset;

                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].ref_GaugeTransType != 0)
                                    m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].ref_GaugeTransType = 0;

                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].SetGaugePlacement(fFixPointX,
                                                                  (fEndY + fStartY) / 2,
                                                                 (fEndX - fStartX) / 2, intPointGaugeAngle_WidthStart);
                                SetSidePointGaugePlacementToArray(fFixPointX,
                                                                  (fEndY + fStartY) / 2,
                                                                 (fEndX - fStartX) / 2, intPointGaugeAngle_WidthStart, (int)PointIndex_Side.TipStart, i);
                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].Measure(objROI);

                                PointF pStart;
                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].ref_intMeasuredPointCount > 0)
                                {
                                    pStart = m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].GetMeasurePoint(0);
                                    m_stcBlobLead.blnTipStartFound = true;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(pStart.X, pStart.Y));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(true);
                                }
                                else
                                {
                                    pStart = new PointF(fFixPointX, (fEndY + fStartY) / 2);
                                    m_stcBlobLead.blnTipStartFound = false;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(pStart.X, pStart.Y));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(false);
                                }

                                // ------- Find lead width end point -----------------------------------------
                                fStartY = m_stcBlobLead.fTipCenterY;
                                fEndY = m_stcBlobLead.fTipCenterY + arrLeadSize[i].Height;
                                fFixPointX = m_stcBlobLead.fTipCenterX + m_intTipOffset;

                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].ref_GaugeTransType != 0)
                                    m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].ref_GaugeTransType = 0;

                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].SetGaugePlacement(fFixPointX,
                                                                  (fEndY + fStartY) / 2,
                                                                 (fEndX - fStartX) / 2, intPointGaugeAngle_WidthEnd);
                                SetSidePointGaugePlacementToArray(fFixPointX,
                                                                  (fEndY + fStartY) / 2,
                                                                 (fEndX - fStartX) / 2, intPointGaugeAngle_WidthEnd, (int)PointIndex_Side.TipEnd, i);
                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].Measure(objROI);

                                PointF pEnd;
                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].ref_intMeasuredPointCount > 0)
                                {
                                    pEnd = m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].GetMeasurePoint(0);
                                    m_stcBlobLead.blnTipEndFound = true;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(pEnd.X, pEnd.Y));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(true);
                                }
                                else
                                {
                                    pEnd = new PointF(fFixPointX, (fEndY + fStartY) / 2);
                                    m_stcBlobLead.blnTipEndFound = false;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(pEnd.X, pEnd.Y));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(false);
                                }
                                // Calculate the lead width
                                m_stcBlobLead.fTipWidth = pEnd.Y - pStart.Y;

                                m_arrTemplateBlobLeads.Add(m_stcBlobLead);

                                //if (m_objPointGauge.ref_intMeasuredPointCount > 0)
                                //{
                                //    m_arrPadEdgeGaugePoints[i].Add(new PointF(objROI.ref_ROI.TotalOrgX + pfStart[0].X, objROI.ref_ROI.TotalOrgY + pfStart[0].Y));
                                //    m_arrPadEdgeGaugePointsFound[i].Add(true);
                                //}
                                //else
                                //{
                                //    m_arrPadEdgeGaugePoints[i].Add(new PointF(m_arrPadPointGaugeStartX[i][0], m_arrPadPointGaugeStartY[i][0])); //objROI.ref_ROI.TotalOrgX + fLimitCenterX, objROI.ref_ROI.TotalOrgY + fLimitCenterY - fHeight / 2
                                //    m_arrPadEdgeGaugePointsFound[i].Add(false);
                                //}
                            }
                        }
                        break;
                    case 2: // Right
                        {
                            intPointGaugeAngle_Tip = 0;
                            intPointGaugeAngle_WidthStart = -90;
                            intPointGaugeAngle_WidthEnd = 90;
                            intLeadBorderDirection = 2;

                            for (int i = 0; i < arrLeadCenterPoints.Count; i++)
                            {
                                for (int p = m_arrLead3DEdgeSideGaugePoints.Count; p <= i; p++)
                                {
                                    m_arrLead3DEdgeSideGaugePoints.Add(new List<PointF>());
                                    m_arrLead3DEdgeSideGaugePointsFound.Add(new List<bool>());
                                }
                                m_arrLead3DEdgeSideGaugePointsPosition.Add(m_intLeadROIDirection);
                                // ------- Find Tip Point X -----------------------------------------
                                float fStartX = m_objLineGauge.ref_ObjectCenterX;
                                float fEndX = objROI.ref_ROITotalX + objROI.ref_ROIWidth;

                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].ref_GaugeTransType != 0)
                                    m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].ref_GaugeTransType = 0;

                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].SetGaugePlacement((fEndX + fStartX) / 2,
                                                                  arrLeadCenterPoints[i].Y,
                                                                  (fEndX - fStartX) / 2, intPointGaugeAngle_Tip);
                                AddSidePointGaugePlacementToArray((fEndX + fStartX) / 2,
                                                                  arrLeadCenterPoints[i].Y,
                                                                  (fEndX - fStartX) / 2, intPointGaugeAngle_Tip, i);
                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].Measure(objROI);

                                m_stcBlobLead = new BlobsFeatures();
                                m_stcBlobLead.intDirection = intLeadBorderDirection;    // Indicate this lead is from which border direction.
                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].ref_intMeasuredPointCount > 0)
                                {
                                    m_stcBlobLead.fTipCenterX = m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].GetMeasurePointX(0);
                                    m_stcBlobLead.fTipCenterY = m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].GetMeasurePointY(0);
                                    m_stcBlobLead.blnTipCenterFound = true;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(true);
                                }
                                else
                                {
                                    m_stcBlobLead.fTipCenterX = (fEndX + fStartX) / 2;
                                    m_stcBlobLead.fTipCenterY = arrLeadCenterPoints[i].Y;
                                    m_stcBlobLead.blnTipCenterFound = false;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(false);
                                }

                                // ------- Find lead width start point -----------------------------------------
                                float fStartY = m_stcBlobLead.fTipCenterY;
                                float fEndY = m_stcBlobLead.fTipCenterY - arrLeadSize[i].Height;
                                float fFixPointX = m_stcBlobLead.fTipCenterX - m_intTipOffset;

                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].ref_GaugeTransType != 0)
                                    m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].ref_GaugeTransType = 0;

                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].SetGaugePlacement(fFixPointX,
                                                                  (fEndY + fStartY) / 2,
                                                                 (fEndX - fStartX) / 2, intPointGaugeAngle_WidthStart);
                                SetSidePointGaugePlacementToArray(fFixPointX,
                                                                  (fEndY + fStartY) / 2,
                                                                 (fEndX - fStartX) / 2, intPointGaugeAngle_WidthStart, (int)PointIndex_Side.TipStart, i);
                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].Measure(objROI);

                                PointF pStart;
                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].ref_intMeasuredPointCount > 0)
                                {
                                    pStart = m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].GetMeasurePoint(0);
                                    m_stcBlobLead.blnTipStartFound = true;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(pStart.X, pStart.Y));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(true);
                                }
                                else
                                {
                                    pStart = new PointF(fFixPointX, (fEndY + fStartY) / 2);
                                    m_stcBlobLead.blnTipStartFound = false;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(pStart.X, pStart.Y));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(false);
                                }

                                // ------- Find lead width end point -----------------------------------------
                                fStartY = m_stcBlobLead.fTipCenterY;
                                fEndY = m_stcBlobLead.fTipCenterY + arrLeadSize[i].Height;

                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].ref_GaugeTransType != 0)
                                    m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].ref_GaugeTransType = 0;

                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].SetGaugePlacement(fFixPointX,
                                                                  (fEndY + fStartY) / 2,
                                                                 (fEndX - fStartX) / 2, intPointGaugeAngle_WidthEnd);
                                SetSidePointGaugePlacementToArray(fFixPointX,
                                                                  (fEndY + fStartY) / 2,
                                                                 (fEndX - fStartX) / 2, intPointGaugeAngle_WidthEnd, (int)PointIndex_Side.TipEnd, i);
                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].Measure(objROI);

                                PointF pEnd;
                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].ref_intMeasuredPointCount > 0)
                                {
                                    pEnd = m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].GetMeasurePoint(0);
                                    m_stcBlobLead.blnTipEndFound = true;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(pEnd.X, pEnd.Y));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(true);
                                }
                                else
                                {
                                    pEnd = new PointF(fFixPointX, (fEndY + fStartY) / 2);
                                    m_stcBlobLead.blnTipEndFound = false;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(pEnd.X, pEnd.Y));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(false);
                                }

                                // Calculate the lead width
                                m_stcBlobLead.fTipWidth = pEnd.Y - pStart.Y;
                                m_stcBlobLead.fTipCenterX = m_stcBlobLead.fTipCenterX - objROI.ref_ROITotalX;
                                m_stcBlobLead.fTipCenterY = (pEnd.Y + pStart.Y) / 2 - objROI.ref_ROITotalY;
                                m_stcBlobLead.intNoID = arrLeadID[i];

                                m_arrTemplateBlobLeads.Add(m_stcBlobLead);
                            }

                        }
                        break;
                    case 3: // Bottom 
                        {
                            intPointGaugeAngle_Tip = 90;
                            intPointGaugeAngle_WidthStart = 180;
                            intPointGaugeAngle_WidthEnd = 0;
                            intLeadBorderDirection = 8;

                            for (int i = 0; i < arrLeadCenterPoints.Count; i++)
                            {
                                for (int p = m_arrLead3DEdgeSideGaugePoints.Count; p <= i; p++)
                                {
                                    m_arrLead3DEdgeSideGaugePoints.Add(new List<PointF>());
                                    m_arrLead3DEdgeSideGaugePointsFound.Add(new List<bool>());
                                }
                                m_arrLead3DEdgeSideGaugePointsPosition.Add(m_intLeadROIDirection);
                                // ------- Find Tip Point X -----------------------------------------
                                float fStartX = objROI.ref_ROITotalX;
                                float fEndX = m_objLineGauge.ref_ObjectCenterX;

                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].ref_GaugeTransType != 0)
                                    m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].ref_GaugeTransType = 0;

                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].SetGaugePlacement((fEndX + fStartX) / 2,
                                                                  arrLeadCenterPoints[i].Y,
                                                                  (fEndX - fStartX) / 2, intPointGaugeAngle_Tip);
                                AddSidePointGaugePlacementToArray((fEndX + fStartX) / 2,
                                                                  arrLeadCenterPoints[i].Y,
                                                                  (fEndX - fStartX) / 2, intPointGaugeAngle_Tip, i);
                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].Measure(objROI);

                                m_stcBlobLead = new BlobsFeatures();
                                m_stcBlobLead.intDirection = intLeadBorderDirection;    // Indicate this lead is from which border direction.
                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].ref_intMeasuredPointCount > 0)
                                {
                                    m_stcBlobLead.fTipCenterX = m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].GetMeasurePointX(0);
                                    m_stcBlobLead.fTipCenterY = m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].GetMeasurePointY(0);
                                    m_stcBlobLead.blnTipCenterFound = true;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(true);
                                }
                                else
                                {
                                    m_stcBlobLead.fTipCenterX = (fEndX + fStartX) / 2;
                                    m_stcBlobLead.fTipCenterY = arrLeadCenterPoints[i].Y;
                                    m_stcBlobLead.blnTipCenterFound = false;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(false);
                                }
                                // ------- Find lead width start point -----------------------------------------
                                float fStartY = m_stcBlobLead.fTipCenterY;
                                float fEndY = m_stcBlobLead.fTipCenterY - arrLeadSize[i].Height;
                                float fFixPointX = m_stcBlobLead.fTipCenterX + m_intTipOffset;

                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].ref_GaugeTransType != 0)
                                    m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].ref_GaugeTransType = 0;

                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].SetGaugePlacement(fFixPointX,
                                                                  (fEndY + fStartY) / 2,
                                                                 (fEndX - fStartX) / 2, intPointGaugeAngle_WidthStart);
                                SetSidePointGaugePlacementToArray(fFixPointX,
                                                                  (fEndY + fStartY) / 2,
                                                                 (fEndX - fStartX) / 2, intPointGaugeAngle_WidthStart, (int)PointIndex_Side.TipStart, i);
                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].Measure(objROI);

                                PointF pStart;
                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].ref_intMeasuredPointCount > 0)
                                {
                                    pStart = m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].GetMeasurePoint(0);
                                    m_stcBlobLead.blnTipStartFound = true;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(pStart.X, pStart.Y));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(true);
                                }
                                else
                                {
                                    pStart = new PointF(fFixPointX, (fEndY + fStartY) / 2);
                                    m_stcBlobLead.blnTipStartFound = false;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(pStart.X, pStart.Y));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(false);
                                }
                                // ------- Find lead width end point -----------------------------------------
                                fStartY = m_stcBlobLead.fTipCenterY;
                                fEndY = m_stcBlobLead.fTipCenterY + arrLeadSize[i].Height;
                                fFixPointX = m_stcBlobLead.fTipCenterX + m_intTipOffset;

                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].ref_GaugeTransType != 0)
                                    m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].ref_GaugeTransType = 0;

                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].SetGaugePlacement(fFixPointX,
                                                                  (fEndY + fStartY) / 2,
                                                                 (fEndX - fStartX) / 2, intPointGaugeAngle_WidthEnd);
                                SetSidePointGaugePlacementToArray(fFixPointX,
                                                                  (fEndY + fStartY) / 2,
                                                                 (fEndX - fStartX) / 2, intPointGaugeAngle_WidthEnd, (int)PointIndex_Side.TipEnd, i);
                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].Measure(objROI);

                                PointF pEnd;
                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].ref_intMeasuredPointCount > 0)
                                {
                                    pEnd = m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].GetMeasurePoint(0);
                                    m_stcBlobLead.blnTipEndFound = true;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(pEnd.X, pEnd.Y));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(true);
                                }
                                else
                                {
                                    pEnd = new PointF(fFixPointX, (fEndY + fStartY) / 2);
                                    m_stcBlobLead.blnTipEndFound = false;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(pEnd.X, pEnd.Y));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(false);
                                }
                                // Calculate the lead width
                                m_stcBlobLead.fTipWidth = pEnd.Y - pStart.Y;

                                m_arrTemplateBlobLeads.Add(m_stcBlobLead);
                            }
                        }
                        break;
                    case 4: // Left
                        {
                            intPointGaugeAngle_Tip = 180;
                            intPointGaugeAngle_WidthStart = -90;
                            intPointGaugeAngle_WidthEnd = 90;
                            intLeadBorderDirection = 1;

                            for (int i = 0; i < arrLeadCenterPoints.Count; i++)
                            {
                                for (int p = m_arrLead3DEdgeSideGaugePoints.Count; p <= i; p++)
                                {
                                    m_arrLead3DEdgeSideGaugePoints.Add(new List<PointF>());
                                    m_arrLead3DEdgeSideGaugePointsFound.Add(new List<bool>());
                                }
                                m_arrLead3DEdgeSideGaugePointsPosition.Add(m_intLeadROIDirection);
                                // ------- Find Tip Point X -----------------------------------------
                                float fStartX = objROI.ref_ROITotalX;
                                float fEndX = m_objLineGauge.ref_ObjectCenterX;

                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].ref_GaugeTransType != 0)
                                    m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].ref_GaugeTransType = 0;

                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].SetGaugePlacement((fEndX + fStartX) / 2,
                                                                  arrLeadCenterPoints[i].Y,
                                                                  (fEndX - fStartX) / 2, intPointGaugeAngle_Tip);
                                AddSidePointGaugePlacementToArray((fEndX + fStartX) / 2,
                                                                  arrLeadCenterPoints[i].Y,
                                                                  (fEndX - fStartX) / 2, intPointGaugeAngle_Tip, i);
                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].Measure(objROI);

                                m_stcBlobLead = new BlobsFeatures();
                                m_stcBlobLead.intDirection = intLeadBorderDirection;    // Indicate this lead is from which border direction.
                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].ref_intMeasuredPointCount > 0)
                                {
                                    m_stcBlobLead.fTipCenterX = m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].GetMeasurePointX(0);
                                    m_stcBlobLead.fTipCenterY = m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].GetMeasurePointY(0);
                                    m_stcBlobLead.blnTipCenterFound = true;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(true);
                                }
                                else
                                {
                                    m_stcBlobLead.fTipCenterX = (fEndX + fStartX) / 2;
                                    m_stcBlobLead.fTipCenterY = arrLeadCenterPoints[i].Y;
                                    m_stcBlobLead.blnTipCenterFound = false;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(false);
                                }
                                // ------- Find lead width start point -----------------------------------------
                                float fStartY = m_stcBlobLead.fTipCenterY;
                                float fEndY = m_stcBlobLead.fTipCenterY - arrLeadSize[i].Height;
                                float fFixPointX = m_stcBlobLead.fTipCenterX + m_intTipOffset;

                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].ref_GaugeTransType != 0)
                                    m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].ref_GaugeTransType = 0;

                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].SetGaugePlacement(fFixPointX,
                                                                  (fEndY + fStartY) / 2,
                                                                 (fEndX - fStartX) / 2, intPointGaugeAngle_WidthStart);
                                SetSidePointGaugePlacementToArray(fFixPointX,
                                                                  (fEndY + fStartY) / 2,
                                                                 (fEndX - fStartX) / 2, intPointGaugeAngle_WidthStart, (int)PointIndex_Side.TipStart, i);
                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].Measure(objROI);

                                PointF pStart;
                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].ref_intMeasuredPointCount > 0)
                                {
                                    pStart = m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].GetMeasurePoint(0);
                                    m_stcBlobLead.blnTipStartFound = true;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(pStart.X, pStart.Y));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(true);
                                }
                                else
                                {
                                    pStart = new PointF(fFixPointX, (fEndY + fStartY) / 2);
                                    m_stcBlobLead.blnTipStartFound = false;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(pStart.X, pStart.Y));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(false);
                                }
                                // ------- Find lead width end point -----------------------------------------
                                fStartY = m_stcBlobLead.fTipCenterY;
                                fEndY = m_stcBlobLead.fTipCenterY + arrLeadSize[i].Height;
                                fFixPointX = m_stcBlobLead.fTipCenterX + m_intTipOffset;

                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].ref_GaugeTransType != 0)
                                    m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].ref_GaugeTransType = 0;

                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].SetGaugePlacement(fFixPointX,
                                                                  (fEndY + fStartY) / 2,
                                                                 (fEndX - fStartX) / 2, intPointGaugeAngle_WidthEnd);
                                SetSidePointGaugePlacementToArray(fFixPointX,
                                                                  (fEndY + fStartY) / 2,
                                                                 (fEndX - fStartX) / 2, intPointGaugeAngle_WidthEnd, (int)PointIndex_Side.TipEnd, i);
                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].Measure(objROI);

                                PointF pEnd;
                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].ref_intMeasuredPointCount > 0)
                                {
                                    pEnd = m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].GetMeasurePoint(0);
                                    m_stcBlobLead.blnTipEndFound = true;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(pEnd.X, pEnd.Y));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(true);
                                }
                                else
                                {
                                    pEnd = new PointF(fFixPointX, (fEndY + fStartY) / 2);
                                    m_stcBlobLead.blnTipEndFound = false;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(pEnd.X, pEnd.Y));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(false);
                                }
                                // Calculate the lead width
                                m_stcBlobLead.fTipWidth = pEnd.Y - pStart.Y;
                                m_stcBlobLead.fTipCenterX = m_stcBlobLead.fTipCenterX - objROI.ref_ROITotalX;
                                m_stcBlobLead.fTipCenterY = (pEnd.Y + pStart.Y) / 2 - objROI.ref_ROITotalY;
                                m_stcBlobLead.intNoID = arrLeadID[i];

                                m_arrTemplateBlobLeads.Add(m_stcBlobLead);
                            }
                        }
                        break;
                }


            }
            else
            {
                //if (m_objSidePointGauge.ref_GaugeTransChoice != 2)
                //    m_objSidePointGauge.ref_GaugeTransChoice = 2;   // Use Largest Amplitude

                //if (m_objSidePointGauge.ref_GaugeTransType != 0)
                //    m_objSidePointGauge.ref_GaugeTransType = 0;     // Black to white

                int intPointGaugeAngle_Tip, intPointGaugeAngle_WidthStart, intPointGaugeAngle_WidthEnd;
                int intLeadBorderDirection;
                switch (m_intLeadROIDirection)
                {
                    default:
                    case 1: // Top
                        {
                            intPointGaugeAngle_Tip = -90;
                            intPointGaugeAngle_WidthStart = 180;
                            intPointGaugeAngle_WidthEnd = 0;
                            intLeadBorderDirection = 4;

                            for (int i = 0; i < arrLeadCenterPoints.Count; i++)
                            {
                                for (int p = m_arrLead3DEdgeSideGaugePoints.Count; p <= i; p++)
                                {
                                    m_arrLead3DEdgeSideGaugePoints.Add(new List<PointF>());
                                    m_arrLead3DEdgeSideGaugePointsFound.Add(new List<bool>());
                                }
                                m_arrLead3DEdgeSideGaugePointsPosition.Add(m_intLeadROIDirection);
                                // ------- Find Tip Point Y -----------------------------------------
                                float fStartY = objROI.ref_ROITotalY;
                                float fEndY = m_objLineGauge.ref_ObjectCenterY;

                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].ref_GaugeTransType != 0)
                                    m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].ref_GaugeTransType = 0;

                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].SetGaugePlacement(arrLeadCenterPoints[i].X,
                                                                 (fEndY + fStartY) / 2,
                                                                 (fEndY - fStartY) / 2, intPointGaugeAngle_Tip);
                                AddSidePointGaugePlacementToArray(arrLeadCenterPoints[i].X,
                                                                 (fEndY + fStartY) / 2,
                                                                 (fEndY - fStartY) / 2, intPointGaugeAngle_Tip, i);
                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].Measure(objROI);

                                m_stcBlobLead = new BlobsFeatures();
                                m_stcBlobLead.intDirection = intLeadBorderDirection;    // Indicate this lead is from which border direction.
                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].ref_intMeasuredPointCount > 0)
                                {
                                    m_stcBlobLead.fTipCenterX = m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].GetMeasurePointX(0);
                                    m_stcBlobLead.fTipCenterY = m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].GetMeasurePointY(0);
                                    m_stcBlobLead.blnTipCenterFound = true;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(true);
                                }
                                else
                                {
                                    m_stcBlobLead.fTipCenterX = arrLeadCenterPoints[i].X;
                                    m_stcBlobLead.fTipCenterY = (fEndY + fStartY) / 2;
                                    m_stcBlobLead.blnTipCenterFound = false;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(false);
                                }
                                // ------- Find lead width start point -----------------------------------------
                                float fStartX = m_stcBlobLead.fTipCenterX;
                                float fEndX = m_stcBlobLead.fTipCenterX - arrLeadSize[i].Width;
                                float fFixPointY = m_stcBlobLead.fTipCenterY + m_intTipOffset;

                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].ref_GaugeTransType != 0)
                                    m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].ref_GaugeTransType = 0;

                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].SetGaugePlacement((fEndX + fStartX) / 2,
                                                                  fFixPointY,
                                                                  (fEndY - fStartY) / 2, intPointGaugeAngle_WidthStart);
                                SetSidePointGaugePlacementToArray((fEndX + fStartX) / 2,
                                                                  fFixPointY,
                                                                  (fEndY - fStartY) / 2, intPointGaugeAngle_WidthStart, (int)PointIndex_Side.TipStart, i);
                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].Measure(objROI);

                                PointF pStart;
                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].ref_intMeasuredPointCount > 0)
                                {
                                    pStart = m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].GetMeasurePoint(0);
                                    m_stcBlobLead.blnTipStartFound = true;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(pStart.X, pStart.Y));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(true);
                                }
                                else
                                {
                                    pStart = new PointF((fEndX + fStartX) / 2, fFixPointY);
                                    m_stcBlobLead.blnTipStartFound = false;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(pStart.X, pStart.Y));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(false);
                                }
                                // ------- Find lead width end point -----------------------------------------
                                fStartX = m_stcBlobLead.fTipCenterX;
                                fEndX = m_stcBlobLead.fTipCenterX + arrLeadSize[i].Width;
                                fFixPointY = m_stcBlobLead.fTipCenterY + m_intTipOffset;

                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].ref_GaugeTransType != 0)
                                    m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].ref_GaugeTransType = 0;

                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].SetGaugePlacement((fEndX + fStartX) / 2,
                                                                   fFixPointY,
                                                                   (fEndY - fStartY) / 2, intPointGaugeAngle_WidthEnd);
                                SetSidePointGaugePlacementToArray((fEndX + fStartX) / 2,
                                                                   fFixPointY,
                                                                   (fEndY - fStartY) / 2, intPointGaugeAngle_WidthEnd, (int)PointIndex_Side.TipEnd, i);
                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].Measure(objROI);

                                PointF pEnd;
                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].ref_intMeasuredPointCount > 0)
                                {
                                    pEnd = m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].GetMeasurePoint(0);
                                    m_stcBlobLead.blnTipEndFound = true;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(pEnd.X, pEnd.Y));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(true);
                                }
                                else
                                {
                                    pEnd = new PointF((fEndX + fStartX) / 2, fFixPointY);
                                    m_stcBlobLead.blnTipEndFound = false;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(pEnd.X, pEnd.Y));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(false);
                                }
                                // Calculate the lead width
                                m_stcBlobLead.fTipWidth = pEnd.X - pStart.X;
                                m_stcBlobLead.fTipCenterX = (pEnd.X + pStart.X) / 2 - objROI.ref_ROITotalX;
                                m_stcBlobLead.fTipCenterY = m_stcBlobLead.fTipCenterY - objROI.ref_ROITotalY;
                                m_stcBlobLead.intNoID = arrLeadID[i];

                                m_arrTemplateBlobLeads.Add(m_stcBlobLead);
                            }
                        }
                        break;
                    case 2: // Right
                        {
                            intPointGaugeAngle_Tip = 0;
                            intPointGaugeAngle_WidthStart = -90;
                            intPointGaugeAngle_WidthEnd = 90;
                            intLeadBorderDirection = 2;

                            for (int i = 0; i < arrLeadCenterPoints.Count; i++)
                            {
                                for (int p = m_arrLead3DEdgeSideGaugePoints.Count; p <= i; p++)
                                {
                                    m_arrLead3DEdgeSideGaugePoints.Add(new List<PointF>());
                                    m_arrLead3DEdgeSideGaugePointsFound.Add(new List<bool>());
                                }
                                m_arrLead3DEdgeSideGaugePointsPosition.Add(m_intLeadROIDirection);
                                // ------- Find Tip Point Y -----------------------------------------
                                float fStartY = objROI.ref_ROITotalY;
                                float fEndY = m_objLineGauge.ref_ObjectCenterY;

                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].ref_GaugeTransType != 0)
                                    m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].ref_GaugeTransType = 0;

                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].SetGaugePlacement(arrLeadCenterPoints[i].X,
                                                                  (fEndY + fStartY) / 2,
                                                                  intPointGaugeAngle_Tip,
                                                                  (fEndY - fStartY) / 2);
                                AddSidePointGaugePlacementToArray(arrLeadCenterPoints[i].X,
                                                               (fEndY + fStartY) / 2,
                                                               (fEndY - fStartY) / 2, intPointGaugeAngle_Tip, i);
                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].Measure(objROI);

                                m_stcBlobLead = new BlobsFeatures();
                                m_stcBlobLead.intDirection = intLeadBorderDirection;    // Indicate this lead is from which border direction.
                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].ref_intMeasuredPointCount > 0)
                                {
                                    m_stcBlobLead.fTipCenterX = m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].GetMeasurePointX(0);
                                    m_stcBlobLead.fTipCenterY = m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].GetMeasurePointY(0);
                                    m_stcBlobLead.blnTipCenterFound = true;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(true);
                                }
                                else
                                {
                                    m_stcBlobLead.fTipCenterX = arrLeadCenterPoints[i].X;
                                    m_stcBlobLead.fTipCenterY = (fEndY + fStartY) / 2;
                                    m_stcBlobLead.blnTipCenterFound = false;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(false);
                                }

                                // ------- Find lead width start point -----------------------------------------
                                float fStartX = m_stcBlobLead.fTipCenterX;
                                float fEndX = m_stcBlobLead.fTipCenterX - arrLeadSize[i].Width;
                                float fFixPointY = m_stcBlobLead.fTipCenterY + m_intTipOffset;

                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].ref_GaugeTransType != 0)
                                    m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].ref_GaugeTransType = 0;

                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].SetGaugePlacement((fEndX + fStartX) / 2,
                                                                    fFixPointY,
                                                                    intPointGaugeAngle_WidthStart, (fEndY - fStartY) / 2);
                                SetSidePointGaugePlacementToArray((fEndX + fStartX) / 2,
                                                                fFixPointY,
                                                                (fEndY - fStartY) / 2, intPointGaugeAngle_WidthStart, (int)PointIndex_Side.TipStart, i);
                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].Measure(objROI);

                                PointF pStart;
                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].ref_intMeasuredPointCount > 0)
                                {
                                    pStart = m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].GetMeasurePoint(0);
                                    m_stcBlobLead.blnTipStartFound = true;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(pStart.X, pStart.Y));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(true);
                                }
                                else
                                {
                                    pStart = new PointF((fEndX + fStartX) / 2, fFixPointY);
                                    m_stcBlobLead.blnTipStartFound = false;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(pStart.X, pStart.Y));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(false);
                                }
                                // ------- Find lead width end point -----------------------------------------
                                fStartX = m_stcBlobLead.fTipCenterX;
                                fEndX = m_stcBlobLead.fTipCenterX + arrLeadSize[i].Width;
                                fFixPointY = m_stcBlobLead.fTipCenterY + m_intTipOffset;

                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].ref_GaugeTransType != 0)
                                    m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].ref_GaugeTransType = 0;

                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].SetGaugePlacement((fEndX + fStartX) / 2,
                                                                   fFixPointY,
                                                                  intPointGaugeAngle_WidthEnd, (fEndY - fStartY) / 2);
                                SetSidePointGaugePlacementToArray((fEndX + fStartX) / 2,
                                                                   fFixPointY,
                                                                   (fEndY - fStartY) / 2, intPointGaugeAngle_WidthEnd, (int)PointIndex_Side.TipEnd, i);
                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].Measure(objROI);

                                PointF pEnd;
                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].ref_intMeasuredPointCount > 0)
                                {
                                    pEnd = m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].GetMeasurePoint(0);
                                    m_stcBlobLead.blnTipEndFound = true;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(pEnd.X, pEnd.Y));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(true);
                                }
                                else
                                {
                                    pEnd = new PointF((fEndX + fStartX) / 2, fFixPointY);
                                    m_stcBlobLead.blnTipEndFound = false;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(pEnd.X, pEnd.Y));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(false);
                                }
                                // Calculate the lead width
                                m_stcBlobLead.fTipWidth = pEnd.X - pStart.X;

                                m_arrTemplateBlobLeads.Add(m_stcBlobLead);
                            }
                        }
                        break;
                    case 3: // Bottom
                        {
                            intPointGaugeAngle_Tip = 90;
                            intPointGaugeAngle_WidthStart = 180;
                            intPointGaugeAngle_WidthEnd = 0;
                            intLeadBorderDirection = 8;

                            for (int i = 0; i < arrLeadCenterPoints.Count; i++)
                            {
                                for (int p = m_arrLead3DEdgeSideGaugePoints.Count; p <= i; p++)
                                {
                                    m_arrLead3DEdgeSideGaugePoints.Add(new List<PointF>());
                                    m_arrLead3DEdgeSideGaugePointsFound.Add(new List<bool>());
                                }
                                m_arrLead3DEdgeSideGaugePointsPosition.Add(m_intLeadROIDirection);
                                // ------- Find Tip Point Y -----------------------------------------
                                float fStartY = m_objLineGauge.ref_ObjectCenterY;
                                float fEndY = objROI.ref_ROITotalY + objROI.ref_ROIHeight;

                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].ref_GaugeTransType != 0)
                                    m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].ref_GaugeTransType = 0;

                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].SetGaugePlacement(arrLeadCenterPoints[i].X,
                                                                  (fEndY + fStartY) / 2,
                                                                  (fEndY - fStartY) / 2, intPointGaugeAngle_Tip);
                                AddSidePointGaugePlacementToArray(arrLeadCenterPoints[i].X,
                                                             (fEndY + fStartY) / 2,
                                                             (fEndY - fStartY) / 2, intPointGaugeAngle_Tip, i);
                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].Measure(objROI);

                                m_stcBlobLead = new BlobsFeatures();
                                m_stcBlobLead.intDirection = intLeadBorderDirection;    // Indicate this lead is from which border direction.
                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].ref_intMeasuredPointCount > 0)
                                {
                                    m_stcBlobLead.fTipCenterX = m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].GetMeasurePointX(0);
                                    m_stcBlobLead.fTipCenterY = m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].GetMeasurePointY(0);
                                    m_stcBlobLead.blnTipCenterFound = true;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(true);
                                }
                                else
                                {
                                    m_stcBlobLead.fTipCenterX = arrLeadCenterPoints[i].X;
                                    m_stcBlobLead.fTipCenterY = (fEndY + fStartY) / 2;
                                    m_stcBlobLead.blnTipCenterFound = false;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(false);
                                }

                                // ------- Find lead width start point -----------------------------------------
                                float fStartX = m_stcBlobLead.fTipCenterX;
                                float fEndX = m_stcBlobLead.fTipCenterX - arrLeadSize[i].Width;
                                float fFixPointY = m_stcBlobLead.fTipCenterY - m_intTipOffset;

                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].ref_GaugeTransType != 0)
                                    m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].ref_GaugeTransType = 0;

                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].SetGaugePlacement((fEndX + fStartX) / 2,
                                                                   fFixPointY,
                                                                   (fEndY - fStartY) / 2, intPointGaugeAngle_WidthStart);
                                SetSidePointGaugePlacementToArray((fEndX + fStartX) / 2,
                                                               fFixPointY,
                                                               (fEndY - fStartY) / 2, intPointGaugeAngle_WidthStart, (int)PointIndex_Side.TipStart, i);
                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].Measure(objROI);

                                PointF pStart;
                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].ref_intMeasuredPointCount > 0)
                                {
                                    pStart = m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].GetMeasurePoint(0);
                                    m_stcBlobLead.blnTipStartFound = true;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(pStart.X, pStart.Y));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(true);
                                }
                                else
                                {
                                    pStart = new PointF((fEndX + fStartX) / 2, fFixPointY);
                                    m_stcBlobLead.blnTipStartFound = false;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(pStart.X, pStart.Y));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(false);
                                }
                                // ------- Find lead width end point -----------------------------------------
                                fStartX = m_stcBlobLead.fTipCenterX;
                                fEndX = m_stcBlobLead.fTipCenterX + arrLeadSize[i].Width;

                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].ref_GaugeTransType != 0)
                                    m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].ref_GaugeTransType = 0;

                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].SetGaugePlacement((fEndX + fStartX) / 2,
                                                                  fFixPointY,
                                                                  (fEndY - fStartY) / 2, intPointGaugeAngle_WidthEnd);

                                SetSidePointGaugePlacementToArray((fEndX + fStartX) / 2,
                                                                    fFixPointY,
                                                                    (fEndY - fStartY) / 2, intPointGaugeAngle_WidthEnd, (int)PointIndex_Side.TipEnd, i);
                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].Measure(objROI);

                                PointF pEnd;
                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].ref_intMeasuredPointCount > 0)
                                {
                                    pEnd = m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].GetMeasurePoint(0);
                                    m_stcBlobLead.blnTipEndFound = true;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(pEnd.X, pEnd.Y));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(true);
                                }
                                else
                                {
                                    pEnd = new PointF((fEndX + fStartX) / 2, fFixPointY);
                                    m_stcBlobLead.blnTipEndFound = false;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(pEnd.X, pEnd.Y));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(false);
                                }

                                // Calculate the lead width
                                m_stcBlobLead.fTipWidth = pEnd.X - pStart.X;
                                m_stcBlobLead.fTipCenterX = (pEnd.X + pStart.X) / 2 - objROI.ref_ROITotalX;
                                m_stcBlobLead.fTipCenterY = m_stcBlobLead.fTipCenterY - objROI.ref_ROITotalY;
                                m_stcBlobLead.intNoID = arrLeadID[i];

                                m_arrTemplateBlobLeads.Add(m_stcBlobLead);
                            }
                        }
                        break;
                    case 4: // Left
                        {
                            intPointGaugeAngle_Tip = 180;
                            intPointGaugeAngle_WidthStart = -90;
                            intPointGaugeAngle_WidthEnd = 90;
                            intLeadBorderDirection = 1;

                            for (int i = 0; i < arrLeadCenterPoints.Count; i++)
                            {
                                for (int p = m_arrLead3DEdgeSideGaugePoints.Count; p <= i; p++)
                                {
                                    m_arrLead3DEdgeSideGaugePoints.Add(new List<PointF>());
                                    m_arrLead3DEdgeSideGaugePointsFound.Add(new List<bool>());
                                }
                                m_arrLead3DEdgeSideGaugePointsPosition.Add(m_intLeadROIDirection);
                                // ------- Find Tip Point Y -----------------------------------------
                                float fStartY = objROI.ref_ROITotalY;
                                float fEndY = m_objLineGauge.ref_ObjectCenterY;
                                
                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].ref_GaugeTransType != 0)
                                    m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].ref_GaugeTransType = 0;

                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].SetGaugePlacement(arrLeadCenterPoints[i].X,
                                                                  (fEndY + fStartY) / 2,
                                                                  intPointGaugeAngle_Tip, (fEndY - fStartY) / 2);
                                AddSidePointGaugePlacementToArray(arrLeadCenterPoints[i].X,
                                                             (fEndY + fStartY) / 2,
                                                             (fEndY - fStartY) / 2, intPointGaugeAngle_Tip, i);
                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].Measure(objROI);

                                m_stcBlobLead = new BlobsFeatures();
                                m_stcBlobLead.intDirection = intLeadBorderDirection;    // Indicate this lead is from which border direction.
                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].ref_intMeasuredPointCount > 0)
                                {
                                    m_stcBlobLead.fTipCenterX = m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].GetMeasurePointX(0);
                                    m_stcBlobLead.fTipCenterY = m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].GetMeasurePointY(0);
                                    m_stcBlobLead.blnTipCenterFound = true;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(true);
                                }
                                else
                                {
                                    m_stcBlobLead.fTipCenterX = arrLeadCenterPoints[i].X;
                                    m_stcBlobLead.fTipCenterY = (fEndY + fStartY) / 2;
                                    m_stcBlobLead.blnTipCenterFound = false;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(false);
                                }
                                // ------- Find lead width start point -----------------------------------------
                                float fStartX = m_stcBlobLead.fTipCenterX;
                                float fEndX = m_stcBlobLead.fTipCenterX - arrLeadSize[i].Width;
                                float fFixPointY = m_stcBlobLead.fTipCenterY + m_intTipOffset;

                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].ref_GaugeTransType != 0)
                                    m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].ref_GaugeTransType = 0;

                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].SetGaugePlacement((fEndX + fStartX) / 2,
                                                                  fFixPointY,
                                                                  intPointGaugeAngle_WidthStart, (fEndY - fStartY) / 2);

                                SetSidePointGaugePlacementToArray((fEndX + fStartX) / 2,
                                                              fFixPointY,
                                                              (fEndY - fStartY) / 2, intPointGaugeAngle_WidthStart, (int)PointIndex_Side.TipStart, i);
                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].Measure(objROI);

                                PointF pStart;
                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].ref_intMeasuredPointCount > 0)
                                {
                                    pStart = m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].GetMeasurePoint(0);
                                    m_stcBlobLead.blnTipStartFound = true;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(pStart.X, pStart.Y));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(true);
                                }
                                else
                                {
                                    pStart = new PointF((fEndX + fStartX) / 2, fFixPointY);
                                    m_stcBlobLead.blnTipStartFound = false;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(pStart.X, pStart.Y));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(false);
                                }

                                // ------- Find lead width end point -----------------------------------------
                                fStartX = m_stcBlobLead.fTipCenterX;
                                fEndX = m_stcBlobLead.fTipCenterX + arrLeadSize[i].Width;
                                fFixPointY = m_stcBlobLead.fTipCenterY + m_intTipOffset;

                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].ref_GaugeTransType != 0)
                                    m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].ref_GaugeTransType = 0;

                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].SetGaugePlacement((fEndX + fStartX) / 2,
                                                                  fFixPointY,
                                                                  intPointGaugeAngle_WidthEnd, (fEndY - fStartY) / 2);
                                SetSidePointGaugePlacementToArray((fEndX + fStartX) / 2,
                                                             fFixPointY,
                                                             (fEndY - fStartY) / 2, intPointGaugeAngle_WidthEnd, (int)PointIndex_Side.TipEnd, i);
                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].Measure(objROI);

                                PointF pEnd;
                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].ref_intMeasuredPointCount > 0)
                                {
                                    pEnd = m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].GetMeasurePoint(0);
                                    m_stcBlobLead.blnTipEndFound = true;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(pEnd.X, pEnd.Y));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(true);
                                }
                                else
                                {
                                    pEnd = new PointF((fEndX + fStartX) / 2, fFixPointY);
                                    m_stcBlobLead.blnTipEndFound = false;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(pEnd.X, pEnd.Y));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(false);
                                }

                                // Calculate the lead width
                                m_stcBlobLead.fTipWidth = pEnd.X - pStart.X;

                                m_arrTemplateBlobLeads.Add(m_stcBlobLead);
                            }
                        }
                        break;
                }


            }

        }

        public bool InspectSideLeads(ROI objROI, List<int> arrLeadID, List<PointF> arrLeadCenterPoints, List<SizeF> arrLeadSize, List<float> arrTipLength, List<float> arrWidthOffset, List<float> arrStandOffOffset, List<float> arrCoplanOffset)
        {
            m_blnLock = true;

            lock (m_objLockBlobs)
            {
                InitLeadInspectionData_Lead3D(objROI);

                MeasureDimension_SideLeads(objROI, arrLeadID, arrLeadCenterPoints, arrLeadSize, arrTipLength, arrWidthOffset, arrStandOffOffset, arrCoplanOffset);

                // 2018 12 13 - CCENG: Dimension For side leads will be checked in Center Leads. Measurement data will transfer to center lead then check the dimension there.
                //                     The reason checking in center lead is because the side lead need to compare with lead from other side also. 
                //CheckDimension_SideLeads();   
            }

            m_blnLock = false;

            if (m_arrFailResultMask[m_intLeadROIDirection] == 0)
                return true;
            else
                return false;
        }

        public bool CheckDimension_AllSideLeads(List<int> arrAllLeadID, List<float> arrAllLeadStandOff, List<float> arrAllLeadWidth)
        {
            float fMinStandOffMM = float.MaxValue;
            float fMaxStandOffMM = 0;
            float fMinStandOffTLMM = float.MaxValue;
            float fMinStandOffBRMM = float.MaxValue;
            float fMaxStandOffTLMM = 0;
            float fMaxStandOffBRMM = 0;

            for (int i = 0; i < m_arrSampleBlobLeads.Length; i++)
            {
                if (i >= arrAllLeadID.Count || i >= arrAllLeadStandOff.Count || i >= arrAllLeadWidth.Count)
                    continue;

                m_arrSampleBlobLeads[i].fStandOffMM = arrAllLeadStandOff[i];
                if (fMinStandOffMM > arrAllLeadStandOff[i])
                {
                    fMinStandOffMM = arrAllLeadStandOff[i];
                }
                if (fMaxStandOffMM < arrAllLeadStandOff[i])
                {
                    fMaxStandOffMM = arrAllLeadStandOff[i];
                }

                if (m_arrSampleBlobLeads[i].intDirection == 0x01 || m_arrSampleBlobLeads[i].intDirection == 0x04)
                {
                    if (fMinStandOffTLMM > arrAllLeadStandOff[i])
                    {
                        fMinStandOffTLMM = arrAllLeadStandOff[i];
                    }
                    if (fMaxStandOffTLMM < arrAllLeadStandOff[i])
                    {
                        fMaxStandOffTLMM = arrAllLeadStandOff[i];
                    }
                }
                else if (m_arrSampleBlobLeads[i].intDirection == 0x02 || m_arrSampleBlobLeads[i].intDirection == 0x08)
                {
                    if (fMinStandOffBRMM > arrAllLeadStandOff[i])
                    {
                        fMinStandOffBRMM = arrAllLeadStandOff[i];
                    }
                    if (fMaxStandOffBRMM < arrAllLeadStandOff[i])
                    {
                        fMaxStandOffBRMM = arrAllLeadStandOff[i];
                    }
                }

                if ((m_intFailOptionMask & 0x01) > 0)
                {
                    // ---------- Check Stand Off ----------------------------------------------
                    if (!MatchTemplateObjectsStandOff(i, m_arrSampleBlobLeads[i].fStandOffMM))
                    {
                        m_arrSampleBlobLeads[i].intFailMask |= 0x01;
                        m_arrFailResultMask[0] |= 0x01;
                    }
                }

                //2020-07-20 ZJYEOH : Check Width again if user not select display 2D Width
                if (m_intLeadWidthDisplayOption != 0)
                {
                    // Check base/tip Width
                    if ((m_intFailOptionMask & 0x40) > 0)
                    {
                        // Reset Fail Mask for Width
                        m_arrSampleBlobLeads[i].intFailMask &= ~0x400000;// ~0x40; 
                        m_arrFailResultMask[0] &= ~0x400000;//~0x40;

                        if (m_intLeadWidthDisplayOption == 1) // Display 3D Width
                        {
                            m_arrSampleBlobLeads[i].fTipWidthMM = arrAllLeadWidth[i];
                        }
                        else if (m_intLeadWidthDisplayOption == 2) // Display Max of 2D or 3D Width
                        {
                            m_arrSampleBlobLeads[i].fTipWidthMM = Math.Max(m_arrSampleBlobLeads[i].fTipWidthMM, arrAllLeadWidth[i]);
                        }

                        if (!MatchTemplateObjectsWidth(i, m_arrSampleBlobLeads[i].fTipWidthMM))
                        {
                            m_arrSampleBlobLeads[i].intFailMask |= 0x400000;// 0x40;
                            m_arrFailResultMask[0] |= 0x400000;// 0x40;
                        }
                    }
                }
            }

            // -------- Check Whole Side Leads Stand off Variances ----------------------------------------------
            if (m_intLeadDirection == 0)    // Horizontal
            {
                m_fStandOffVarianceLeftResult = fMaxStandOffTLMM - fMinStandOffTLMM;
                m_fStandOffVarianceRightResult = fMaxStandOffBRMM - fMinStandOffBRMM;

                if ((m_intFailOptionMask & 0x4000) > 0)
                {
                    if (m_fStandOffVarianceLeftResult > m_fStandOffVarianceLeftMaxSetting)
                    {
                        m_arrFailResultMask[4] |= 0x4000;
                    }

                    if (m_fStandOffVarianceRightResult > m_fStandOffVarianceRightMaxSetting)
                    {
                        m_arrFailResultMask[2] |= 0x4000;
                    }
                }
            }
            else
            {
                m_fStandOffVarianceTopResult = fMaxStandOffTLMM - fMinStandOffTLMM;
                m_fStandOffVarianceBottomResult = fMaxStandOffBRMM - fMinStandOffBRMM;

                if ((m_intFailOptionMask & 0x4000) > 0)
                {
                    if (m_fStandOffVarianceTopResult > m_fStandOffVarianceTopMaxSetting)
                    {
                        m_arrFailResultMask[1] |= 0x4000;
                    }

                    if (m_fStandOffVarianceBottomResult > m_fStandOffVarianceBottomMaxSetting)
                    {
                        m_arrFailResultMask[3] |= 0x4000;
                    }
                }
            }

            m_fStandOffVarianceUnitResult = fMaxStandOffMM - fMinStandOffMM;

            if ((m_intFailOptionMask & 0x4000) > 0)
            {

                if (m_fStandOffVarianceUnitResult > m_fStandOffVarianceUnitMaxSetting)
                {
                    m_arrFailResultMask[0] |= 0x4000;
                }
            }

            // -------- Check Coplan ----------------------------------------------
            for (int i = 0; i < m_arrSampleBlobLeads.Length; i++)
            {
                //m_arrSampleBlobLeads[i].fCoplanMM = fMaxStandOffMM - m_arrSampleBlobLeads[i].fStandOffMM;

                if (m_arrSampleBlobLeads[i].intDirection == 0x01 || m_arrSampleBlobLeads[i].intDirection == 0x04)
                {
                    m_arrSampleBlobLeads[i].fCoplanMM = fMaxStandOffMM - m_arrSampleBlobLeads[i].fStandOffMM + ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCoplanOffset;//fMaxStandOffTLMM 2020-07-29 ZJYEOH : Use max standoff to minus all so that only one zero value
                }
                else if (m_arrSampleBlobLeads[i].intDirection == 0x02 || m_arrSampleBlobLeads[i].intDirection == 0x08)
                {
                    m_arrSampleBlobLeads[i].fCoplanMM = fMaxStandOffMM - m_arrSampleBlobLeads[i].fStandOffMM + ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCoplanOffset; //fMaxStandOffBRMM 2020-07-29 ZJYEOH : Use max standoff to minus all so that only one zero value
                }

                if ((m_intFailOptionMask & 0x02) > 0)
                {
                    // Check Coplan
                    if (!MatchTemplateObjectsCoplan(i, m_arrSampleBlobLeads[i].fCoplanMM))
                    {
                        m_arrSampleBlobLeads[i].intFailMask |= 0x02;
                        m_arrFailResultMask[0] |= 0x02;
                    }
                }
            }

            for (int i = 0; i < m_arrFailResultMask.Length; i++)
            {
                if (m_arrFailResultMask[i] > 0)
                    return false;
            }

            return true;
        }

        private void CheckDimension_SideLeads()
        {
            for (int i = 0; i < m_arrSampleBlobLeads.Length; i++)
            {
                ////Skip if fail reference point
                if ((m_arrSampleBlobLeads[i].intFailMask & 0x01) > 0)
                    continue;

                ////Skip if join Lead
                if ((m_arrSampleBlobLeads[i].intFailMask & 0x10) > 0) // 0x02
                    continue;

                ////Skip if missing Lead
                if ((m_arrSampleBlobLeads[i].intFailMask & 0x20) > 0) // 0x04
                    continue;
            }
        }
        
        private void MeasureDimension_SideLeads(ROI objROI, List<int> arrLeadID, List<PointF> arrLeadCenterPoints, List<SizeF> arrLeadSize, List<float> arrTipLength, List<float> arrWidthOffset, List<float> arrStandOffOffset, List<float> arrCoplanOffset)
        {
            m_arrLead3DSidePointGaugeStartX.Clear();
            m_arrLead3DSidePointGaugeStartY.Clear();
            m_arrLead3DSidePointGaugeTolerance.Clear();
            m_arrLead3DSidePointGaugeAngle.Clear();
            m_arrLead3DEdgeSideGaugePoints.Clear();
            m_arrLead3DEdgeSideGaugePointsFound.Clear();
            m_arrLead3DEdgeSideGaugePointsPosition.Clear();

            for (int p = m_arrLead3DEdgeSideGaugePoints.Count; p < arrLeadCenterPoints.Count; p++)
            {
                m_arrLead3DEdgeSideGaugePoints.Add(new List<PointF>());
                m_arrLead3DEdgeSideGaugePointsFound.Add(new List<bool>());
                m_arrLead3DEdgeSideGaugePointsPosition.Add(0);
                m_arrLead3DSidePointGaugeStartX.Add(new List<float>());
                m_arrLead3DSidePointGaugeStartY.Add(new List<float>());
                m_arrLead3DSidePointGaugeTolerance.Add(new List<float>());
                m_arrLead3DSidePointGaugeAngle.Add(new List<float>());
            }

            //if (m_intLeadDirection == 0)    // Horizontal Leads
            {
                //if (m_objSidePointGauge.ref_GaugeTransChoice != 2)
                //    m_objSidePointGauge.ref_GaugeTransChoice = 2;   // Use Largest Amplitude

                //if (m_objSidePointGauge.ref_GaugeTransType != 0)
                //    m_objSidePointGauge.ref_GaugeTransType = 0;     // Black to white

                int intPointGaugeAngle_Tip, intPointGaugeAngle_WidthStart, intPointGaugeAngle_WidthEnd;
                int intLeadBorderDirection;
                switch (m_intLeadROIDirection)
                {
                    default:
                    case 1: // Top
                        if (m_intLeadDirection == 1) // Vertical Leads
                        {
                            intPointGaugeAngle_Tip = -90;
                            intPointGaugeAngle_WidthStart = 180;
                            intPointGaugeAngle_WidthEnd = 0;
                            intLeadBorderDirection = 4;

                            float fMaxStandOffMM = 0;
                            for (int i = 0; i < arrLeadCenterPoints.Count; i++)
                            {
                                for (int p = m_arrLead3DEdgeSideGaugePoints.Count; p <= i; p++)
                                {
                                    m_arrLead3DEdgeSideGaugePoints.Add(new List<PointF>());
                                    m_arrLead3DEdgeSideGaugePointsFound.Add(new List<bool>());
                                }
                                m_arrLead3DEdgeSideGaugePointsPosition.Add(m_intLeadROIDirection);
                                // ------- Find Tip Point Y -----------------------------------------
                                float fStartY = objROI.ref_ROITotalY;
                                float fEndY = m_objLineGauge.ref_ObjectCenterY + 5; // put point gauge 5 pixels deeper after base line

                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].ref_GaugeTransType != 0)
                                    m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].ref_GaugeTransType = 0;

                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].SetGaugePlacement(arrLeadCenterPoints[i].X,
                                                                        (fEndY + fStartY) / 2,
                                                                        (fEndY - fStartY) / 2, intPointGaugeAngle_Tip);
                                AddSidePointGaugePlacementToArray(arrLeadCenterPoints[i].X,
                                                                  (fEndY + fStartY) / 2,
                                                                  (fEndY - fStartY) / 2, intPointGaugeAngle_Tip, i);

                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].Measure(objROI);

                                m_stcSampleBlobLead = m_arrSampleBlobLeads[i];
                                m_stcSampleBlobLead.intDirection = intLeadBorderDirection;    // Indicate this lead is from which border direction.
                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].ref_intMeasuredPointCount > 0)
                                {
                                    m_stcSampleBlobLead.fTipCenterX = m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].GetMeasurePointX(0);
                                    m_stcSampleBlobLead.fTipCenterY = m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].GetMeasurePointY(0);
                                    m_stcSampleBlobLead.blnTipCenterFound = true;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(m_stcSampleBlobLead.fTipCenterX, m_stcSampleBlobLead.fTipCenterY));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(true);
                                }
                                else
                                {
                                    m_stcSampleBlobLead.fTipCenterX = arrLeadCenterPoints[i].X;
                                    m_stcSampleBlobLead.fTipCenterY = (fEndY + fStartY) / 2;
                                    m_stcSampleBlobLead.blnTipCenterFound = false;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(m_stcSampleBlobLead.fTipCenterX, m_stcSampleBlobLead.fTipCenterY));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(false);
                                }

                                if (m_intLeadStandOffMethod == 0)
                                {
                                    ScanMaxUsingGaugePoint(m_arrSampleBlobSideLeads[i].fCenterX, m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].ref_GaugeCenterY,
                                                                m_arrSampleBlobSideLeads[i].fWidth, m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].ref_GaugeTolerance, m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].ref_GaugeAngle,
                                                                objROI, ref m_stcSampleBlobLead.fTipMaxX, ref m_stcSampleBlobLead.fTipMaxY, i);

                                    //2021-04-13 ZJYEOH : reassign tip center point
                                    if (m_stcSampleBlobLead.fTipMaxX != -999)
                                        m_stcSampleBlobLead.fTipCenterX = m_stcSampleBlobLead.fTipMaxX;
                                    if (m_stcSampleBlobLead.fTipMaxY != -999)
                                        m_stcSampleBlobLead.fTipCenterY = m_stcSampleBlobLead.fTipMaxY;
                                    if (m_stcSampleBlobLead.fTipMaxX != -999 && m_stcSampleBlobLead.fTipMaxY != -999)
                                        m_stcSampleBlobLead.blnTipCenterFound = true;
                                }

                                // ------- Find lead width start point -----------------------------------------
                                float fStartX = m_stcSampleBlobLead.fTipCenterX;
                                float fEndX = m_stcSampleBlobLead.fTipCenterX - arrLeadSize[i].Width;
                                float fFixPointY = m_stcSampleBlobLead.fTipCenterY + m_intTipOffset;

                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].ref_GaugeTransType != 0)
                                    m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].ref_GaugeTransType = 0;

                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].SetGaugePlacement((fEndX + fStartX) / 2,
                                                            fFixPointY,
                                                            (fEndY - fStartY) / 2, intPointGaugeAngle_WidthStart);
                                SetSidePointGaugePlacementToArray((fEndX + fStartX) / 2,
                                                                  fFixPointY,
                                                                  (fEndY - fStartY) / 2, intPointGaugeAngle_WidthStart, (int)PointIndex_Side.TipStart, i);
                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].Measure(objROI);

                                PointF pStart;
                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].ref_intMeasuredPointCount > 0)
                                {
                                    pStart = m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].GetMeasurePoint(0);
                                    m_stcSampleBlobLead.blnTipStartFound = true;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(pStart.X, pStart.Y));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(true);
                                }
                                else
                                {
                                    pStart = new PointF((fEndX + fStartX) / 2, fFixPointY);
                                    m_stcSampleBlobLead.blnTipStartFound = false;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(pStart.X, pStart.Y));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(false);
                                }
                                // ------- Find lead width end point -----------------------------------------
                                fStartX = m_stcSampleBlobLead.fTipCenterX;
                                fEndX = m_stcSampleBlobLead.fTipCenterX + arrLeadSize[i].Width;

                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].ref_GaugeTransType != 0)
                                    m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].ref_GaugeTransType = 0;

                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].SetGaugePlacement((fEndX + fStartX) / 2,
                                                                   fFixPointY,
                                                                   (fEndY - fStartY) / 2, intPointGaugeAngle_WidthEnd);
                                SetSidePointGaugePlacementToArray((fEndX + fStartX) / 2,
                                                                   fFixPointY,
                                                                   (fEndY - fStartY) / 2, intPointGaugeAngle_WidthEnd, (int)PointIndex_Side.TipEnd, i);
                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].Measure(objROI);

                                PointF pEnd;
                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].ref_intMeasuredPointCount > 0)
                                {
                                    pEnd = m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].GetMeasurePoint(0);
                                    m_stcSampleBlobLead.blnTipEndFound = true;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(pEnd.X, pEnd.Y));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(true);
                                }
                                else
                                {
                                    pEnd = new PointF((fEndX + fStartX) / 2, fFixPointY);
                                    m_stcSampleBlobLead.blnTipEndFound = false;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(pEnd.X, pEnd.Y));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(false);
                                }

                                // Calculate the lead width, recenter tip
                                m_stcSampleBlobLead.fTipWidth = pEnd.X - pStart.X;
                                float fStandOff;
                                //2020-08-04 ZJYEOH : Default use max point
                                if (m_intLeadStandOffMethod == 0)
                                {
                                    //fStandOff = m_objLineGauge.ref_ObjectCenterY - m_arrSampleBlobSideLeads[i].fStartY;
                                    m_objLineGauge.GetObjectLine();
                                    //fStandOff = m_objLineGauge.ref_ObjectLine.GetPointY(m_stcSampleBlobLead.fTipCenterX) - m_arrSampleBlobSideLeads[i].fStartY;
                                    fStandOff = m_objLineGauge.ref_ObjectLine.GetPointY(m_stcSampleBlobLead.fTipCenterX) - m_stcSampleBlobLead.fTipMaxY;

                                }
                                else
                                {
                                    //fStandOff = m_objLineGauge.ref_ObjectCenterY - m_stcSampleBlobLead.fTipCenterY;
                                    m_objLineGauge.GetObjectLine();
                                    fStandOff = m_objLineGauge.ref_ObjectLine.GetPointY(m_stcSampleBlobLead.fTipCenterX) - m_stcSampleBlobLead.fTipCenterY;

                                }

                                //2020-09-03 ZJYEOH : Consider angle viewing offset
                                //2020-10-14 CCENG  : Dont use LeadSize (from blob size) bcos not stable)
                                float fStandOffOrigin = 0;
                                //if (m_intLeadStandOffMethod == 0)
                                //    fStandOffOrigin = arrLeadSize[i].Height * (float)Math.Sin(m_f3DAngle * Math.PI / 180);
                                //else
                                fStandOffOrigin = arrTipLength[i] * (float)Math.Sin(m_f3DAngle * Math.PI / 180);
                                fStandOff -= fStandOffOrigin;

                                m_stcSampleBlobLead.fTipCenterX = (pEnd.X + pStart.X) / 2 - objROI.ref_ROITotalX;
                                m_stcSampleBlobLead.fTipCenterY = m_stcSampleBlobLead.fTipCenterY - objROI.ref_ROITotalY;
                                m_stcSampleBlobLead.intNoID = arrLeadID[i];

                                m_stcSampleBlobLead.fTipWidthMM = Get3DinMM(m_stcSampleBlobLead.fTipWidth) + arrWidthOffset[i]/*((BlobsFeatures)m_arrTemplateBlobLeads[i]).fWidthOffset*/;//m_fMMToPixelXValue
                                m_stcSampleBlobLead.fStandOffMM = Get3DinMM(fStandOff) + arrStandOffOffset[i]/*((BlobsFeatures)m_arrTemplateBlobLeads[i]).fStandOffOffset*/;// / m_fMMToPixelYValue;
                                if (fMaxStandOffMM < m_stcSampleBlobLead.fStandOffMM)
                                {
                                    fMaxStandOffMM = m_stcSampleBlobLead.fStandOffMM;
                                }

                                m_arrSampleBlobLeads[i] = m_stcSampleBlobLead;
                            }

                            for (int i = 0; i < arrLeadCenterPoints.Count; i++)
                            {
                                m_stcSampleBlobLead = m_arrSampleBlobLeads[i];

                                m_stcSampleBlobLead.fCoplanMM = fMaxStandOffMM - m_stcSampleBlobLead.fStandOffMM + arrCoplanOffset[i]/*((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCoplanOffset*/;

                                m_arrSampleBlobLeads[i] = m_stcSampleBlobLead;
                            }

                        }
                        break;
                    case 2: // Right
                        if (m_intLeadDirection == 0) // Horizontal Leads
                        {
                            intPointGaugeAngle_Tip = 0;
                            intPointGaugeAngle_WidthStart = -90;
                            intPointGaugeAngle_WidthEnd = 90;
                            intLeadBorderDirection = 2;

                            float fMaxStandOffMM = 0;
                            for (int i = 0; i < arrLeadCenterPoints.Count; i++)
                            {
                                for (int p = m_arrLead3DEdgeSideGaugePoints.Count; p <= i; p++)
                                {
                                    m_arrLead3DEdgeSideGaugePoints.Add(new List<PointF>());
                                    m_arrLead3DEdgeSideGaugePointsFound.Add(new List<bool>());
                                }
                                m_arrLead3DEdgeSideGaugePointsPosition.Add(m_intLeadROIDirection);
                                // ------- Find Tip Point X -----------------------------------------
                                float fStartX = m_objLineGauge.ref_ObjectCenterX - 5; // put point gauge 5 pixels deeper after base line
                                float fEndX = objROI.ref_ROITotalX + objROI.ref_ROIWidth;

                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].ref_GaugeTransType != 0)
                                    m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].ref_GaugeTransType = 0;

                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].SetGaugePlacement((fEndX + fStartX) / 2,
                                                                  arrLeadCenterPoints[i].Y,
                                                                  (fEndX - fStartX) / 2, intPointGaugeAngle_Tip);
                                AddSidePointGaugePlacementToArray((fEndX + fStartX) / 2,
                                                           arrLeadCenterPoints[i].Y,
                                                           (fEndX - fStartX) / 2, intPointGaugeAngle_Tip, i);
                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].Measure(objROI);

                                m_stcSampleBlobLead = m_arrSampleBlobLeads[i];
                                m_stcSampleBlobLead.intDirection = intLeadBorderDirection;    // Indicate this lead is from which border direction.
                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].ref_intMeasuredPointCount > 0)
                                {
                                    m_stcSampleBlobLead.fTipCenterX = m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].GetMeasurePointX(0);
                                    m_stcSampleBlobLead.fTipCenterY = m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].GetMeasurePointY(0);
                                    m_stcSampleBlobLead.blnTipCenterFound = true;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(m_stcSampleBlobLead.fTipCenterX, m_stcSampleBlobLead.fTipCenterY));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(true);
                                }
                                else
                                {
                                    m_stcSampleBlobLead.fTipCenterX = (fEndX + fStartX) / 2;
                                    m_stcSampleBlobLead.fTipCenterY = arrLeadCenterPoints[i].Y;
                                    m_stcSampleBlobLead.blnTipCenterFound = false;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(m_stcSampleBlobLead.fTipCenterX, m_stcSampleBlobLead.fTipCenterY));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(false);
                                }

                                if (m_intLeadStandOffMethod == 0)
                                {
                                    ScanMaxUsingGaugePoint(m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].ref_GaugeCenterX, m_arrSampleBlobSideLeads[i].fCenterY,
                                                                m_arrSampleBlobSideLeads[i].fHeight, m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].ref_GaugeTolerance, m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].ref_GaugeAngle,
                                                                objROI, ref m_stcSampleBlobLead.fTipMaxX, ref m_stcSampleBlobLead.fTipMaxY, i);

                                    //2021-04-13 ZJYEOH : reassign tip center point
                                    if (m_stcSampleBlobLead.fTipMaxX != -999)
                                        m_stcSampleBlobLead.fTipCenterX = m_stcSampleBlobLead.fTipMaxX;
                                    if (m_stcSampleBlobLead.fTipMaxY != -999)
                                        m_stcSampleBlobLead.fTipCenterY = m_stcSampleBlobLead.fTipMaxY;
                                    if (m_stcSampleBlobLead.fTipMaxX != -999 && m_stcSampleBlobLead.fTipMaxY != -999)
                                        m_stcSampleBlobLead.blnTipCenterFound = true;
                                }

                                // ------- Find lead width start point -----------------------------------------
                                float fStartY = m_stcSampleBlobLead.fTipCenterY;
                                float fEndY = m_stcSampleBlobLead.fTipCenterY - arrLeadSize[i].Height;
                                float fFixPointX = m_stcSampleBlobLead.fTipCenterX - m_intTipOffset;

                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].ref_GaugeTransType != 0)
                                    m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].ref_GaugeTransType = 0;

                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].SetGaugePlacement(fFixPointX,
                                                                  (fEndY + fStartY) / 2,
                                                                 (fEndX - fStartX) / 2, intPointGaugeAngle_WidthStart);
                                SetSidePointGaugePlacementToArray(fFixPointX,
                                                                  (fEndY + fStartY) / 2,
                                                                 (fEndX - fStartX) / 2, intPointGaugeAngle_WidthStart, (int)PointIndex_Side.TipStart, i);
                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].Measure(objROI);

                                PointF pStart;
                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].ref_intMeasuredPointCount > 0)
                                {
                                    pStart = m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].GetMeasurePoint(0);
                                    m_stcSampleBlobLead.blnTipStartFound = true;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(pStart.X, pStart.Y));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(true);
                                }
                                else
                                {
                                    pStart = new PointF(fFixPointX, (fEndY + fStartY) / 2);
                                    m_stcSampleBlobLead.blnTipStartFound = false;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(pStart.X, pStart.Y));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(false);
                                }
                                // ------- Find lead width end point -----------------------------------------
                                fStartY = m_stcSampleBlobLead.fTipCenterY;
                                fEndY = m_stcSampleBlobLead.fTipCenterY + arrLeadSize[i].Height;

                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].ref_GaugeTransType != 0)
                                    m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].ref_GaugeTransType = 0;

                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].SetGaugePlacement(fFixPointX,
                                                                  (fEndY + fStartY) / 2,
                                                                 (fEndX - fStartX) / 2, intPointGaugeAngle_WidthEnd);
                                SetSidePointGaugePlacementToArray(fFixPointX,
                                                                (fEndY + fStartY) / 2,
                                                               (fEndX - fStartX) / 2, intPointGaugeAngle_WidthEnd, (int)PointIndex_Side.TipEnd, i);
                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].Measure(objROI);

                                PointF pEnd;
                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].ref_intMeasuredPointCount > 0)
                                {
                                    pEnd = m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].GetMeasurePoint(0);
                                    m_stcSampleBlobLead.blnTipEndFound = true;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(pEnd.X, pEnd.Y));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(true);
                                }
                                else
                                {
                                    pEnd = new PointF(fFixPointX, (fEndY + fStartY) / 2);
                                    m_stcSampleBlobLead.blnTipEndFound = false;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(pEnd.X, pEnd.Y));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(false);
                                }

                                // Calculate the lead width, recenter tip
                                m_stcSampleBlobLead.fTipWidth = pEnd.Y - pStart.Y;
                                float fStandOff;
                                //2020-08-04 ZJYEOH : Default use max point
                                if (m_intLeadStandOffMethod == 0)
                                {

                                    //fStandOff = m_arrSampleBlobSideLeads[i].fEndX - m_objLineGauge.ref_ObjectCenterX;
                                    m_objLineGauge.GetObjectLine();
                                    //fStandOff = m_arrSampleBlobSideLeads[i].fEndX - m_objLineGauge.ref_ObjectLine.GetPointX(m_stcSampleBlobLead.fTipCenterY);
                                    fStandOff = m_stcSampleBlobLead.fTipMaxX - m_objLineGauge.ref_ObjectLine.GetPointX(m_stcSampleBlobLead.fTipCenterY);
                                }
                                else
                                {
                                    //fStandOff = m_stcSampleBlobLead.fTipCenterX - m_objLineGauge.ref_ObjectCenterX;
                                    m_objLineGauge.GetObjectLine();
                                    fStandOff = m_stcSampleBlobLead.fTipCenterX - m_objLineGauge.ref_ObjectLine.GetPointX(m_stcSampleBlobLead.fTipCenterY);
                                }

                                //2020-09-03 ZJYEOH : Consider angle viewing offset
                                //2020-10-14 CCENG  : Dont use LeadSize (from blob size) bcos not stable)
                                float fStandOffOrigin = 0;
                                //if (m_intLeadStandOffMethod == 0)
                                //    fStandOffOrigin = arrLeadSize[i].Width * (float)Math.Sin(m_f3DAngle * Math.PI / 180);
                                //else
                                fStandOffOrigin = arrTipLength[i] * (float)Math.Sin(m_f3DAngle * Math.PI / 180);
                                fStandOff -= fStandOffOrigin;

                                m_stcSampleBlobLead.fTipCenterX = m_stcSampleBlobLead.fTipCenterX - objROI.ref_ROITotalX;
                                m_stcSampleBlobLead.fTipCenterY = (pEnd.Y + pStart.Y) / 2 - objROI.ref_ROITotalY;
                                m_stcSampleBlobLead.intNoID = arrLeadID[i];

                                m_stcSampleBlobLead.fTipWidthMM = Get3DinMM(m_stcSampleBlobLead.fTipWidth) + arrWidthOffset[i]/*((BlobsFeatures)m_arrTemplateBlobLeads[i]).fWidthOffset*/;// / m_fMMToPixelYValue;
                                m_stcSampleBlobLead.fStandOffMM = Get3DinMM(fStandOff) + arrStandOffOffset[i]/*((BlobsFeatures)m_arrTemplateBlobLeads[i]).fStandOffOffset*/;//m_fMMToPixelXValue
                                if (fMaxStandOffMM < m_stcSampleBlobLead.fStandOffMM)
                                {
                                    fMaxStandOffMM = m_stcSampleBlobLead.fStandOffMM;
                                }

                                m_arrSampleBlobLeads[i] = m_stcSampleBlobLead;
                            }

                            for (int i = 0; i < arrLeadCenterPoints.Count; i++)
                            {
                                m_stcSampleBlobLead = m_arrSampleBlobLeads[i];

                                m_stcSampleBlobLead.fCoplanMM = fMaxStandOffMM - m_stcSampleBlobLead.fStandOffMM + arrCoplanOffset[i]/*((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCoplanOffset*/;

                                m_arrSampleBlobLeads[i] = m_stcSampleBlobLead;
                            }

                        }
                        break;
                    case 3: // Bottom 
                        if (m_intLeadDirection == 1) // Vertical Leads
                        {
                            intPointGaugeAngle_Tip = 90;
                            intPointGaugeAngle_WidthStart = 180;
                            intPointGaugeAngle_WidthEnd = 0;
                            intLeadBorderDirection = 8;

                            float fMaxStandOffMM = 0;
                            for (int i = 0; i < arrLeadCenterPoints.Count; i++)
                            {
                                for (int p = m_arrLead3DEdgeSideGaugePoints.Count; p <= i; p++)
                                {
                                    m_arrLead3DEdgeSideGaugePoints.Add(new List<PointF>());
                                    m_arrLead3DEdgeSideGaugePointsFound.Add(new List<bool>());
                                }
                                m_arrLead3DEdgeSideGaugePointsPosition.Add(m_intLeadROIDirection);
                                // ------- Find Tip Point X -----------------------------------------
                                float fStartY = m_objLineGauge.ref_ObjectCenterY - 5;   // put point gauge 5 pixels deeper after base line
                                float fEndY = objROI.ref_ROITotalY + objROI.ref_ROIHeight;

                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].ref_GaugeTransType != 0)
                                    m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].ref_GaugeTransType = 0;

                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].SetGaugePlacement(arrLeadCenterPoints[i].X,
                                                            (fEndY + fStartY) / 2,
                                                            (fEndY - fStartY) / 2, intPointGaugeAngle_Tip);
                                AddSidePointGaugePlacementToArray(arrLeadCenterPoints[i].X,
                                                             (fEndY + fStartY) / 2,
                                                             (fEndY - fStartY) / 2, intPointGaugeAngle_Tip, i);
                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].Measure(objROI);

                                m_stcSampleBlobLead = m_arrSampleBlobLeads[i];
                                m_stcSampleBlobLead.intDirection = intLeadBorderDirection;    // Indicate this lead is from which border direction.
                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].ref_intMeasuredPointCount > 0)
                                {
                                    m_stcSampleBlobLead.fTipCenterX = m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].GetMeasurePointX(0);
                                    m_stcSampleBlobLead.fTipCenterY = m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].GetMeasurePointY(0);
                                    m_stcSampleBlobLead.blnTipCenterFound = true;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(m_stcSampleBlobLead.fTipCenterX, m_stcSampleBlobLead.fTipCenterY));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(true);
                                }
                                else
                                {
                                    m_stcSampleBlobLead.fTipCenterX = arrLeadCenterPoints[i].X;
                                    m_stcSampleBlobLead.fTipCenterY = (fEndY + fStartY) / 2;
                                    m_stcSampleBlobLead.blnTipCenterFound = false;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(m_stcSampleBlobLead.fTipCenterX, m_stcSampleBlobLead.fTipCenterY));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(false);
                                }

                                if (m_intLeadStandOffMethod == 0)
                                {
                                    ScanMaxUsingGaugePoint(m_arrSampleBlobSideLeads[i].fCenterX, m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].ref_GaugeCenterY,
                                                                m_arrSampleBlobSideLeads[i].fWidth, m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].ref_GaugeTolerance, m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].ref_GaugeAngle,
                                                                objROI, ref m_stcSampleBlobLead.fTipMaxX, ref m_stcSampleBlobLead.fTipMaxY, i);

                                    //2021-04-13 ZJYEOH : reassign tip center point
                                    if (m_stcSampleBlobLead.fTipMaxX != -999)
                                        m_stcSampleBlobLead.fTipCenterX = m_stcSampleBlobLead.fTipMaxX;
                                    if (m_stcSampleBlobLead.fTipMaxY != -999)
                                        m_stcSampleBlobLead.fTipCenterY = m_stcSampleBlobLead.fTipMaxY;
                                    if (m_stcSampleBlobLead.fTipMaxX != -999 && m_stcSampleBlobLead.fTipMaxY != -999)
                                        m_stcSampleBlobLead.blnTipCenterFound = true;
                                }

                                // ------- Find lead width start point -----------------------------------------
                                float fStartX = m_stcSampleBlobLead.fTipCenterX;
                                float fEndX = m_stcSampleBlobLead.fTipCenterX - arrLeadSize[i].Width;
                                float fFixPointY = m_stcSampleBlobLead.fTipCenterY - m_intTipOffset;

                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].ref_GaugeTransType != 0)
                                    m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].ref_GaugeTransType = 0;

                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].SetGaugePlacement((fEndX + fStartX) / 2,
                                                                  fFixPointY,
                                                                  (fEndY - fStartY) / 2, intPointGaugeAngle_WidthStart);
                                SetSidePointGaugePlacementToArray((fEndX + fStartX) / 2,
                                                               fFixPointY,
                                                               (fEndY - fStartY) / 2, intPointGaugeAngle_WidthStart, (int)PointIndex_Side.TipStart, i);
                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].Measure(objROI);

                                PointF pStart;
                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].ref_intMeasuredPointCount > 0)
                                {
                                    pStart = m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].GetMeasurePoint(0);
                                    m_stcSampleBlobLead.blnTipStartFound = true;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(pStart.X, pStart.Y));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(true);
                                }
                                else
                                {
                                    pStart = new PointF((fEndX + fStartX) / 2, fFixPointY);
                                    m_stcSampleBlobLead.blnTipStartFound = false;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(pStart.X, pStart.Y));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(false);
                                }
                                // ------- Find lead width end point -----------------------------------------
                                fStartX = m_stcSampleBlobLead.fTipCenterX;
                                fEndX = m_stcSampleBlobLead.fTipCenterX + arrLeadSize[i].Width;
                                fFixPointY = m_stcSampleBlobLead.fTipCenterY - m_intTipOffset;

                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].ref_GaugeTransType != 0)
                                    m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].ref_GaugeTransType = 0;

                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].SetGaugePlacement((fEndX + fStartX) / 2,
                                                                   fFixPointY,
                                                                   (fEndY - fStartY) / 2, intPointGaugeAngle_WidthEnd);
                                SetSidePointGaugePlacementToArray((fEndX + fStartX) / 2,
                                                                    fFixPointY,
                                                                    (fEndY - fStartY) / 2, intPointGaugeAngle_WidthEnd, (int)PointIndex_Side.TipEnd, i);
                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].Measure(objROI);

                                PointF pEnd;
                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].ref_intMeasuredPointCount > 0)
                                {
                                    pEnd = m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].GetMeasurePoint(0);
                                    m_stcSampleBlobLead.blnTipEndFound = true;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(pEnd.X, pEnd.Y));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(true);
                                }
                                else
                                {
                                    pEnd = new PointF((fEndX + fStartX) / 2, fFixPointY);
                                    m_stcSampleBlobLead.blnTipEndFound = false;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(pEnd.X, pEnd.Y));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(false);
                                }
                                // Calculate the lead width
                                m_stcSampleBlobLead.fTipWidth = pEnd.X - pStart.X;
                                float fStandOff;
                                //2020-08-04 ZJYEOH : Default use max point
                                if (m_intLeadStandOffMethod == 0)
                                {

                                    //fStandOff = m_arrSampleBlobSideLeads[i].fEndY - m_objLineGauge.ref_ObjectCenterY;
                                    m_objLineGauge.GetObjectLine();
                                    //fStandOff = m_arrSampleBlobSideLeads[i].fEndY - m_objLineGauge.ref_ObjectLine.GetPointY(m_stcSampleBlobLead.fTipCenterX);
                                    fStandOff = m_stcSampleBlobLead.fTipMaxY - m_objLineGauge.ref_ObjectLine.GetPointY(m_stcSampleBlobLead.fTipCenterX);
                                }
                                else
                                {

                                    //fStandOff = m_stcSampleBlobLead.fTipCenterY - m_objLineGauge.ref_ObjectCenterY;
                                    m_objLineGauge.GetObjectLine();
                                    fStandOff = m_stcSampleBlobLead.fTipCenterY - m_objLineGauge.ref_ObjectLine.GetPointY(m_stcSampleBlobLead.fTipCenterX);

                                }

                                //2020-09-03 ZJYEOH : Consider angle viewing offset
                                //2020-10-14 CCENG  : Dont use LeadSize (from blob size) bcos not stable)
                                float fStandOffOrigin = 0;
                                //if (m_intLeadStandOffMethod == 0)
                                //    fStandOffOrigin = arrLeadSize[i].Height * (float)Math.Sin(m_f3DAngle * Math.PI / 180);
                                //else
                                fStandOffOrigin = arrTipLength[i] * (float)Math.Sin(m_f3DAngle * Math.PI / 180);
                                fStandOff -= fStandOffOrigin;

                                m_stcSampleBlobLead.fTipCenterX = (pEnd.X + pStart.X) / 2 - objROI.ref_ROITotalX;
                                m_stcSampleBlobLead.fTipCenterY = m_stcSampleBlobLead.fTipCenterY - objROI.ref_ROITotalY;
                                m_stcSampleBlobLead.intNoID = arrLeadID[i];

                                m_stcSampleBlobLead.fTipWidthMM = Get3DinMM(m_stcSampleBlobLead.fTipWidth) + arrWidthOffset[i]/*((BlobsFeatures)m_arrTemplateBlobLeads[i]).fWidthOffset*/;//m_fMMToPixelXValue
                                m_stcSampleBlobLead.fStandOffMM = Get3DinMM(fStandOff) + arrStandOffOffset[i]/*((BlobsFeatures)m_arrTemplateBlobLeads[i]).fStandOffOffset*/;// / m_fMMToPixelYValue;
                                if (fMaxStandOffMM < m_stcSampleBlobLead.fStandOffMM)
                                {
                                    fMaxStandOffMM = m_stcSampleBlobLead.fStandOffMM;
                                }

                                m_arrSampleBlobLeads[i] = m_stcSampleBlobLead;
                            }

                            for (int i = 0; i < arrLeadCenterPoints.Count; i++)
                            {
                                m_stcSampleBlobLead = m_arrSampleBlobLeads[i];

                                m_stcSampleBlobLead.fCoplanMM = fMaxStandOffMM - m_stcSampleBlobLead.fStandOffMM + arrCoplanOffset[i]/*((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCoplanOffset*/;

                                m_arrSampleBlobLeads[i] = m_stcSampleBlobLead;
                            }

                        }
                        break;
                    case 4: // Left
                        if (m_intLeadDirection == 0) // Horizontal Leads
                        {
                            intPointGaugeAngle_Tip = 180;
                            intPointGaugeAngle_WidthStart = -90;
                            intPointGaugeAngle_WidthEnd = 90;
                            intLeadBorderDirection = 1;

                            float fMaxStandOffMM = 0;
                            for (int i = 0; i < arrLeadCenterPoints.Count; i++)
                            {
                                for (int p = m_arrLead3DEdgeSideGaugePoints.Count; p <= i; p++)
                                {
                                    m_arrLead3DEdgeSideGaugePoints.Add(new List<PointF>());
                                    m_arrLead3DEdgeSideGaugePointsFound.Add(new List<bool>());
                                }
                                m_arrLead3DEdgeSideGaugePointsPosition.Add(m_intLeadROIDirection);
                                // ------- Find Tip Point X -----------------------------------------
                                float fStartX = objROI.ref_ROITotalX;
                                float fEndX = m_objLineGauge.ref_ObjectCenterX + 5; // put point gauge 5 pixels deeper after base line

                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].ref_GaugeTransType != 0)
                                    m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].ref_GaugeTransType = 0;

                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].SetGaugePlacement((fEndX + fStartX) / 2,
                                                                 arrLeadCenterPoints[i].Y,
                                                                 (fEndX - fStartX) / 2, intPointGaugeAngle_Tip);
                                AddSidePointGaugePlacementToArray((fEndX + fStartX) / 2,
                                                                   arrLeadCenterPoints[i].Y,
                                                                   (fEndX - fStartX) / 2, intPointGaugeAngle_Tip, i);
                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].Measure(objROI);



                                m_stcSampleBlobLead = m_arrSampleBlobLeads[i];
                                m_stcSampleBlobLead.intDirection = intLeadBorderDirection;    // Indicate this lead is from which border direction.
                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].ref_intMeasuredPointCount > 0)
                                {
                                    m_stcSampleBlobLead.fTipCenterX = m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].GetMeasurePointX(0);
                                    m_stcSampleBlobLead.fTipCenterY = m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].GetMeasurePointY(0);
                                    m_stcSampleBlobLead.blnTipCenterFound = true;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(m_stcSampleBlobLead.fTipCenterX, m_stcSampleBlobLead.fTipCenterY));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(true);
                                }
                                else
                                {
                                    m_stcSampleBlobLead.fTipCenterX = (fEndX + fStartX) / 2;
                                    m_stcSampleBlobLead.fTipCenterY = arrLeadCenterPoints[i].Y;
                                    m_stcSampleBlobLead.blnTipCenterFound = false;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(m_stcSampleBlobLead.fTipCenterX, m_stcSampleBlobLead.fTipCenterY));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(false);
                                }

                                if (m_intLeadStandOffMethod == 0)
                                {
                                    ScanMaxUsingGaugePoint(m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].ref_GaugeCenterX, m_arrSampleBlobSideLeads[i].fCenterY,
                                                                m_arrSampleBlobSideLeads[i].fHeight, m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].ref_GaugeTolerance, m_arrSidePointGauge[i][(int)PointIndex_Side.TipCenter].ref_GaugeAngle,
                                                                objROI, ref m_stcSampleBlobLead.fTipMaxX, ref m_stcSampleBlobLead.fTipMaxY, i);

                                    //2021-04-13 ZJYEOH : reassign tip center point
                                    if (m_stcSampleBlobLead.fTipMaxX != -999)
                                        m_stcSampleBlobLead.fTipCenterX = m_stcSampleBlobLead.fTipMaxX;
                                    if (m_stcSampleBlobLead.fTipMaxY != -999)
                                        m_stcSampleBlobLead.fTipCenterY = m_stcSampleBlobLead.fTipMaxY;
                                    if (m_stcSampleBlobLead.fTipMaxX != -999 && m_stcSampleBlobLead.fTipMaxY != -999)
                                        m_stcSampleBlobLead.blnTipCenterFound = true;
                                }

                                // ------- Find lead width start point -----------------------------------------
                                float fStartY = m_stcSampleBlobLead.fTipCenterY;
                                float fEndY = m_stcSampleBlobLead.fTipCenterY - arrLeadSize[i].Height;
                                float fFixPointX = m_stcSampleBlobLead.fTipCenterX + m_intTipOffset;

                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].ref_GaugeTransType != 0)
                                    m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].ref_GaugeTransType = 0;

                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].SetGaugePlacement(fFixPointX,
                                                                  (fEndY + fStartY) / 2,
                                                                 (fEndX - fStartX) / 2, intPointGaugeAngle_WidthStart);
                                SetSidePointGaugePlacementToArray(fFixPointX,
                                                               (fEndY + fStartY) / 2,
                                                              (fEndX - fStartX) / 2, intPointGaugeAngle_WidthStart, (int)PointIndex_Side.TipStart, i);
                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].Measure(objROI);

                                PointF pStart;
                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].ref_intMeasuredPointCount > 0)
                                {
                                    pStart = m_arrSidePointGauge[i][(int)PointIndex_Side.TipStart].GetMeasurePoint(0);
                                    m_stcSampleBlobLead.blnTipStartFound = true;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(pStart.X, pStart.Y));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(true);
                                }
                                else
                                {
                                    pStart = new PointF(fFixPointX, (fEndY + fStartY) / 2);
                                    m_stcSampleBlobLead.blnTipStartFound = false;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(pStart.X, pStart.Y));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(false);
                                }
                                // ------- Find lead width end point -----------------------------------------
                                fStartY = m_stcSampleBlobLead.fTipCenterY;
                                fEndY = m_stcSampleBlobLead.fTipCenterY + arrLeadSize[i].Height;
                                fFixPointX = m_stcSampleBlobLead.fTipCenterX + m_intTipOffset;

                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].ref_GaugeTransType != 0)
                                    m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].ref_GaugeTransType = 0;

                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].SetGaugePlacement(fFixPointX,
                                                                  (fEndY + fStartY) / 2,
                                                                 (fEndX - fStartX) / 2, intPointGaugeAngle_WidthEnd);
                                SetSidePointGaugePlacementToArray(fFixPointX,
                                                                 (fEndY + fStartY) / 2,
                                                                (fEndX - fStartX) / 2, intPointGaugeAngle_WidthEnd, (int)PointIndex_Side.TipEnd, i);
                                m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].Measure(objROI);

                                PointF pEnd;
                                if (m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].ref_intMeasuredPointCount > 0)
                                {
                                    pEnd = m_arrSidePointGauge[i][(int)PointIndex_Side.TipEnd].GetMeasurePoint(0);
                                    m_stcSampleBlobLead.blnTipEndFound = true;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(pEnd.X, pEnd.Y));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(true);
                                }
                                else
                                {
                                    pEnd = new PointF(fFixPointX, (fEndY + fStartY) / 2);
                                    m_stcSampleBlobLead.blnTipEndFound = false;
                                    m_arrLead3DEdgeSideGaugePoints[i].Add(new PointF(pEnd.X, pEnd.Y));
                                    m_arrLead3DEdgeSideGaugePointsFound[i].Add(false);
                                }
                                // Calculate the lead width
                                m_stcSampleBlobLead.fTipWidth = pEnd.Y - pStart.Y;
                                float fStandOff;
                                //2020-08-04 ZJYEOH : Default use max point
                                if (m_intLeadStandOffMethod == 0)
                                {

                                    //fStandOff = m_objLineGauge.ref_ObjectCenterX - m_arrSampleBlobSideLeads[i].fStartX;
                                    m_objLineGauge.GetObjectLine();
                                    //fStandOff = m_objLineGauge.ref_ObjectLine.GetPointX(m_stcSampleBlobLead.fTipCenterY) - m_arrSampleBlobSideLeads[i].fStartX;
                                    fStandOff = m_objLineGauge.ref_ObjectLine.GetPointX(m_stcSampleBlobLead.fTipCenterY) - m_stcSampleBlobLead.fTipMaxX;

                                }
                                else
                                {

                                    //fStandOff = m_objLineGauge.ref_ObjectCenterX - m_stcSampleBlobLead.fTipCenterX;
                                    m_objLineGauge.GetObjectLine();
                                    fStandOff = m_objLineGauge.ref_ObjectLine.GetPointX(m_stcSampleBlobLead.fTipCenterY) - m_stcSampleBlobLead.fTipCenterX;
                                }

                                //2020-09-03 ZJYEOH : Consider angle viewing offset
                                //2020-10-14 CCENG  : Dont use LeadSize (from blob size) bcos not stable)
                                float fStandOffOrigin = 0;
                                //if (m_intLeadStandOffMethod == 0)
                                //    fStandOffOrigin = arrLeadSize[i].Width * (float)Math.Sin(m_f3DAngle * Math.PI / 180);
                                //else
                                fStandOffOrigin = arrTipLength[i] * (float)Math.Sin(m_f3DAngle * Math.PI / 180);
                                fStandOff -= fStandOffOrigin;

                                m_stcSampleBlobLead.fTipCenterX = m_stcSampleBlobLead.fTipCenterX - objROI.ref_ROITotalX;
                                m_stcSampleBlobLead.fTipCenterY = (pEnd.Y + pStart.Y) / 2 - objROI.ref_ROITotalY;
                                m_stcSampleBlobLead.intNoID = arrLeadID[i];

                                m_stcSampleBlobLead.fTipWidthMM = Get3DinMM(m_stcSampleBlobLead.fTipWidth) + arrWidthOffset[i]/*((BlobsFeatures)m_arrTemplateBlobLeads[i]).fWidthOffset*/;// / m_fMMToPixelYValue;
                                m_stcSampleBlobLead.fStandOffMM = Get3DinMM(fStandOff) + arrStandOffOffset[i]/*((BlobsFeatures)m_arrTemplateBlobLeads[i]).fStandOffOffset*/;//m_fMMToPixelXValue
                                if (fMaxStandOffMM < m_stcSampleBlobLead.fStandOffMM)
                                {
                                    fMaxStandOffMM = m_stcSampleBlobLead.fStandOffMM;
                                }

                                m_arrSampleBlobLeads[i] = m_stcSampleBlobLead;
                            }

                            for (int i = 0; i < arrLeadCenterPoints.Count; i++)
                            {
                                m_stcSampleBlobLead = m_arrSampleBlobLeads[i];

                                m_stcSampleBlobLead.fCoplanMM = fMaxStandOffMM - m_stcSampleBlobLead.fStandOffMM + arrCoplanOffset[i]/*((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCoplanOffset*/;

                                m_arrSampleBlobLeads[i] = m_stcSampleBlobLead;
                            }

                        }
                        break;
                }
            }
        }

        private void MeasureDimension_SideLeads_Old(ROI objROI, List<int> arrLeadID, List<PointF> arrLeadCenterPoints, List<SizeF> arrLeadSize)
        {
            //if (m_intLeadDirection == 0)    // Horizontal Leads
            {
                if (m_objPointGauge.ref_GaugeTransChoice != 2)
                    m_objPointGauge.ref_GaugeTransChoice = 2;   // Use Largest Amplitude

                if (m_objPointGauge.ref_GaugeTransType != 0)
                    m_objPointGauge.ref_GaugeTransType = 0;     // Black to white

                int intPointGaugeAngle_Tip, intPointGaugeAngle_WidthStart, intPointGaugeAngle_WidthEnd;
                int intLeadBorderDirection;
                switch (m_intLeadROIDirection)
                {
                    default:
                    case 1: // Top
                        {
                            intPointGaugeAngle_Tip = -90;
                            intPointGaugeAngle_WidthStart = 180;
                            intPointGaugeAngle_WidthEnd = 0;
                            intLeadBorderDirection = 4;

                            float fMaxStandOffMM = 0;
                            for (int i = 0; i < arrLeadCenterPoints.Count; i++)
                            {
                                // ------- Find Tip Point X -----------------------------------------
                                float fStartY = m_objLineGauge.ref_ObjectCenterY;
                                float fEndY = objROI.ref_ROITotalY + objROI.ref_ROIHeight;
                                m_objPointGauge.SetGaugePlacement(arrLeadCenterPoints[i].X,
                                                                  (fEndY + fStartY) / 2,
                                                                  intPointGaugeAngle_Tip, (fEndY - fStartY) / 2);
                                m_objPointGauge.Measure(objROI);

                                m_stcSampleBlobLead = m_arrSampleBlobLeads[i];
                                m_stcSampleBlobLead.intDirection = intLeadBorderDirection;    // Indicate this lead is from which border direction.
                                m_stcSampleBlobLead.fTipCenterX = m_objPointGauge.GetMeasurePointX(0);
                                m_stcSampleBlobLead.fTipCenterY = m_objPointGauge.GetMeasurePointY(0);

                                // ------- Find lead width start point -----------------------------------------
                                float fStartX = m_stcSampleBlobLead.fTipCenterX;
                                float fEndX = m_stcSampleBlobLead.fTipCenterX - arrLeadSize[i].Width;
                                float fFixPointY = m_stcSampleBlobLead.fTipCenterY - m_intTipOffset;
                                m_objPointGauge.SetGaugePlacement((fEndX + fStartX) / 2,
                                                                  fFixPointY,
                                                                  intPointGaugeAngle_WidthStart, (fEndY - fStartY) / 2);

                                m_objPointGauge.Measure(objROI);

                                PointF pStart = m_objPointGauge.GetMeasurePoint(0);

                                // ------- Find lead width end point -----------------------------------------
                                fStartX = m_stcSampleBlobLead.fTipCenterX;
                                fEndX = m_stcSampleBlobLead.fTipCenterX + arrLeadSize[i].Width;
                                m_objPointGauge.SetGaugePlacement((fEndX + fStartX) / 2,
                                                                  fFixPointY,
                                                                  intPointGaugeAngle_WidthEnd, (fEndY - fStartY) / 2);

                                m_objPointGauge.Measure(objROI);

                                PointF pEnd = m_objPointGauge.GetMeasurePoint(0);

                                // Calculate the lead width, recenter tip
                                m_stcSampleBlobLead.fTipWidth = pEnd.X - pStart.X;
                                float fStandOff = m_stcSampleBlobLead.fTipCenterY - m_objLineGauge.ref_ObjectCenterY;
                                m_stcSampleBlobLead.fTipCenterX = (pEnd.X + pStart.X) / 2 - objROI.ref_ROITotalX;
                                m_stcSampleBlobLead.fTipCenterY = m_stcSampleBlobLead.fTipCenterY - objROI.ref_ROITotalY;
                                m_stcSampleBlobLead.intNoID = arrLeadID[i];

                                m_stcSampleBlobLead.fTipWidthMM = Get3DinMM(m_stcSampleBlobLead.fTipWidth);// / m_fMMToPixelYValue;
                                m_stcSampleBlobLead.fStandOffMM = Get3DinMM(fStandOff);// / m_fMMToPixelYValue;
                                if (fMaxStandOffMM < m_stcSampleBlobLead.fStandOffMM)
                                {
                                    fMaxStandOffMM = m_stcSampleBlobLead.fStandOffMM;
                                }

                                m_arrSampleBlobLeads[i] = m_stcSampleBlobLead;
                            }

                            for (int i = 0; i < arrLeadCenterPoints.Count; i++)
                            {
                                m_stcSampleBlobLead = m_arrSampleBlobLeads[i];

                                m_stcSampleBlobLead.fCoplanMM = fMaxStandOffMM - m_stcSampleBlobLead.fStandOffMM;

                                m_arrSampleBlobLeads[i] = m_stcSampleBlobLead;
                            }

                        }
                        break;
                    case 2: // Right
                        {
                            intPointGaugeAngle_Tip = 0;
                            intPointGaugeAngle_WidthStart = -90;
                            intPointGaugeAngle_WidthEnd = 90;
                            intLeadBorderDirection = 2;

                            float fMaxStandOffMM = 0;
                            for (int i = 0; i < arrLeadCenterPoints.Count; i++)
                            {
                                // ------- Find Tip Point X -----------------------------------------
                                float fStartX = m_objLineGauge.ref_ObjectCenterX;
                                float fEndX = objROI.ref_ROITotalX + objROI.ref_ROIWidth;
                                m_objPointGauge.SetGaugePlacement((fEndX + fStartX) / 2,
                                                                  arrLeadCenterPoints[i].Y,
                                                                  (fEndX - fStartX) / 2, intPointGaugeAngle_Tip);
                                m_objPointGauge.Measure(objROI);

                                m_stcSampleBlobLead = m_arrSampleBlobLeads[i];
                                m_stcSampleBlobLead.intDirection = intLeadBorderDirection;    // Indicate this lead is from which border direction.
                                m_stcSampleBlobLead.fTipCenterX = m_objPointGauge.GetMeasurePointX(0);
                                m_stcSampleBlobLead.fTipCenterY = m_objPointGauge.GetMeasurePointY(0);

                                // ------- Find lead width start point -----------------------------------------
                                float fStartY = m_stcSampleBlobLead.fTipCenterY;
                                float fEndY = m_stcSampleBlobLead.fTipCenterY - arrLeadSize[i].Height;
                                float fFixPointX = m_stcSampleBlobLead.fTipCenterX - m_intTipOffset;
                                m_objPointGauge.SetGaugePlacement(fFixPointX,
                                                                  (fEndY + fStartY) / 2,
                                                                 (fEndX - fStartX) / 2, intPointGaugeAngle_WidthStart);

                                m_objPointGauge.Measure(objROI);

                                PointF pStart = m_objPointGauge.GetMeasurePoint(0);

                                // ------- Find lead width end point -----------------------------------------
                                fStartY = m_stcSampleBlobLead.fTipCenterY;
                                fEndY = m_stcSampleBlobLead.fTipCenterY + arrLeadSize[i].Height;
                                m_objPointGauge.SetGaugePlacement(fFixPointX,
                                                                  (fEndY + fStartY) / 2,
                                                                 (fEndX - fStartX) / 2, intPointGaugeAngle_WidthEnd);

                                m_objPointGauge.Measure(objROI);

                                PointF pEnd = m_objPointGauge.GetMeasurePoint(0);

                                // Calculate the lead width, recenter tip
                                m_stcSampleBlobLead.fTipWidth = pEnd.Y - pStart.Y;
                                float fStandOff = m_stcSampleBlobLead.fTipCenterX - m_objLineGauge.ref_ObjectCenterX;
                                m_stcSampleBlobLead.fTipCenterX = m_stcSampleBlobLead.fTipCenterX - objROI.ref_ROITotalX;
                                m_stcSampleBlobLead.fTipCenterY = (pEnd.Y + pStart.Y) / 2 - objROI.ref_ROITotalY;
                                m_stcSampleBlobLead.intNoID = arrLeadID[i];

                                m_stcSampleBlobLead.fTipWidthMM = Get3DinMM(m_stcSampleBlobLead.fTipWidth);//m_fMMToPixelXValue
                                m_stcSampleBlobLead.fStandOffMM = Get3DinMM(fStandOff);//m_fMMToPixelXValue
                                if (fMaxStandOffMM < m_stcSampleBlobLead.fStandOffMM)
                                {
                                    fMaxStandOffMM = m_stcSampleBlobLead.fStandOffMM;
                                }

                                m_arrSampleBlobLeads[i] = m_stcSampleBlobLead;
                            }

                            for (int i = 0; i < arrLeadCenterPoints.Count; i++)
                            {
                                m_stcSampleBlobLead = m_arrSampleBlobLeads[i];

                                m_stcSampleBlobLead.fCoplanMM = fMaxStandOffMM - m_stcSampleBlobLead.fStandOffMM;

                                m_arrSampleBlobLeads[i] = m_stcSampleBlobLead;
                            }

                        }
                        break;
                    case 3: // Bottom 
                        {
                            intPointGaugeAngle_Tip = 90;
                            intPointGaugeAngle_WidthStart = 180;
                            intPointGaugeAngle_WidthEnd = 0;
                            intLeadBorderDirection = 8;

                            float fMaxStandOffMM = 0;
                            for (int i = 0; i < arrLeadCenterPoints.Count; i++)
                            {
                                // ------- Find Tip Point X -----------------------------------------
                                float fStartY = objROI.ref_ROITotalY;
                                float fEndY = m_objLineGauge.ref_ObjectCenterY;
                                m_objPointGauge.SetGaugePlacement(arrLeadCenterPoints[i].X,
                                                                  (fEndY + fStartY) / 2,
                                                                  intPointGaugeAngle_Tip, (fEndY - fStartY) / 2);
                                m_objPointGauge.Measure(objROI);

                                m_stcSampleBlobLead = m_arrSampleBlobLeads[i];
                                m_stcSampleBlobLead.intDirection = intLeadBorderDirection;    // Indicate this lead is from which border direction.
                                m_stcSampleBlobLead.fTipCenterX = m_objPointGauge.GetMeasurePointX(0);
                                m_stcSampleBlobLead.fTipCenterY = m_objPointGauge.GetMeasurePointY(0);

                                // ------- Find lead width start point -----------------------------------------
                                float fStartX = m_stcSampleBlobLead.fTipCenterX;
                                float fEndX = m_stcSampleBlobLead.fTipCenterX - arrLeadSize[i].Width;
                                float fFixPointY = m_stcSampleBlobLead.fTipCenterY + m_intTipOffset;
                                m_objPointGauge.SetGaugePlacement((fEndX + fStartX) / 2,
                                                                  fFixPointY,
                                                                  intPointGaugeAngle_WidthStart, (fEndY - fStartY) / 2);

                                m_objPointGauge.Measure(objROI);

                                PointF pStart = m_objPointGauge.GetMeasurePoint(0);

                                // ------- Find lead width end point -----------------------------------------
                                fStartX = m_stcSampleBlobLead.fTipCenterX;
                                fEndX = m_stcSampleBlobLead.fTipCenterX + arrLeadSize[i].Width;
                                fFixPointY = m_stcSampleBlobLead.fTipCenterY + m_intTipOffset;
                                m_objPointGauge.SetGaugePlacement((fEndX + fStartX) / 2,
                                                                  fFixPointY,
                                                                  intPointGaugeAngle_WidthEnd, (fEndY - fStartY) / 2);

                                m_objPointGauge.Measure(objROI);

                                PointF pEnd = m_objPointGauge.GetMeasurePoint(0);

                                // Calculate the lead width
                                m_stcSampleBlobLead.fTipWidth = pEnd.X - pStart.X;
                                float fStandOff = m_objLineGauge.ref_ObjectCenterY - m_stcSampleBlobLead.fTipCenterY;
                                m_stcSampleBlobLead.fTipCenterX = (pEnd.X + pStart.X) / 2 - objROI.ref_ROITotalX;
                                m_stcSampleBlobLead.fTipCenterY = m_stcSampleBlobLead.fTipCenterY - objROI.ref_ROITotalY;
                                m_stcSampleBlobLead.intNoID = arrLeadID[i];

                                m_stcSampleBlobLead.fTipWidthMM = Get3DinMM(m_stcSampleBlobLead.fTipWidth);// / m_fMMToPixelYValue;
                                m_stcSampleBlobLead.fStandOffMM = Get3DinMM(fStandOff);// / m_fMMToPixelYValue;
                                if (fMaxStandOffMM < m_stcSampleBlobLead.fStandOffMM)
                                {
                                    fMaxStandOffMM = m_stcSampleBlobLead.fStandOffMM;
                                }

                                m_arrSampleBlobLeads[i] = m_stcSampleBlobLead;
                            }

                            for (int i = 0; i < arrLeadCenterPoints.Count; i++)
                            {
                                m_stcSampleBlobLead = m_arrSampleBlobLeads[i];

                                m_stcSampleBlobLead.fCoplanMM = fMaxStandOffMM - m_stcSampleBlobLead.fStandOffMM;

                                m_arrSampleBlobLeads[i] = m_stcSampleBlobLead;
                            }

                        }
                        break;
                    case 4: // Left
                        {
                            intPointGaugeAngle_Tip = 180;
                            intPointGaugeAngle_WidthStart = -90;
                            intPointGaugeAngle_WidthEnd = 90;
                            intLeadBorderDirection = 1;

                            float fMaxStandOffMM = 0;
                            for (int i = 0; i < arrLeadCenterPoints.Count; i++)
                            {
                                // ------- Find Tip Point X -----------------------------------------
                                float fStartX = objROI.ref_ROITotalX;
                                float fEndX = m_objLineGauge.ref_ObjectCenterX;
                                m_objPointGauge.SetGaugePlacement((fEndX + fStartX) / 2,
                                                                  arrLeadCenterPoints[i].Y,
                                                                  (fEndX - fStartX) / 2, intPointGaugeAngle_Tip);
                                m_objPointGauge.Measure(objROI);

                                m_stcSampleBlobLead = m_arrSampleBlobLeads[i];
                                m_stcSampleBlobLead.intDirection = intLeadBorderDirection;    // Indicate this lead is from which border direction.
                                m_stcSampleBlobLead.fTipCenterX = m_objPointGauge.GetMeasurePointX(0);
                                m_stcSampleBlobLead.fTipCenterY = m_objPointGauge.GetMeasurePointY(0);

                                // ------- Find lead width start point -----------------------------------------
                                float fStartY = m_stcSampleBlobLead.fTipCenterY;
                                float fEndY = m_stcSampleBlobLead.fTipCenterY - arrLeadSize[i].Height;
                                float fFixPointX = m_stcSampleBlobLead.fTipCenterX + m_intTipOffset;
                                m_objPointGauge.SetGaugePlacement(fFixPointX,
                                                                  (fEndY + fStartY) / 2,
                                                                 (fEndX - fStartX) / 2, intPointGaugeAngle_WidthStart);

                                m_objPointGauge.Measure(objROI);

                                PointF pStart = m_objPointGauge.GetMeasurePoint(0);

                                // ------- Find lead width end point -----------------------------------------
                                fStartY = m_stcSampleBlobLead.fTipCenterY;
                                fEndY = m_stcSampleBlobLead.fTipCenterY + arrLeadSize[i].Height;
                                fFixPointX = m_stcSampleBlobLead.fTipCenterX + m_intTipOffset;
                                m_objPointGauge.SetGaugePlacement(fFixPointX,
                                                                  (fEndY + fStartY) / 2,
                                                                 (fEndX - fStartX) / 2, intPointGaugeAngle_WidthEnd);

                                m_objPointGauge.Measure(objROI);

                                PointF pEnd = m_objPointGauge.GetMeasurePoint(0);

                                // Calculate the lead width
                                m_stcSampleBlobLead.fTipWidth = pEnd.Y - pStart.Y;
                                float fStandOff = m_objLineGauge.ref_ObjectCenterX - m_stcSampleBlobLead.fTipCenterX;
                                m_stcSampleBlobLead.fTipCenterX = m_stcSampleBlobLead.fTipCenterX - objROI.ref_ROITotalX;
                                m_stcSampleBlobLead.fTipCenterY = (pEnd.Y + pStart.Y) / 2 - objROI.ref_ROITotalY;
                                m_stcSampleBlobLead.intNoID = arrLeadID[i];

                                m_stcSampleBlobLead.fTipWidthMM = Get3DinMM(m_stcSampleBlobLead.fTipWidth); //m_fMMToPixelXValue
                                m_stcSampleBlobLead.fStandOffMM = Get3DinMM(fStandOff); //m_fMMToPixelXValue
                                if (fMaxStandOffMM < m_stcSampleBlobLead.fStandOffMM)
                                {
                                    fMaxStandOffMM = m_stcSampleBlobLead.fStandOffMM;
                                }

                                m_arrSampleBlobLeads[i] = m_stcSampleBlobLead;
                            }

                            for (int i = 0; i < arrLeadCenterPoints.Count; i++)
                            {
                                m_stcSampleBlobLead = m_arrSampleBlobLeads[i];

                                m_stcSampleBlobLead.fCoplanMM = fMaxStandOffMM - m_stcSampleBlobLead.fStandOffMM;

                                m_arrSampleBlobLeads[i] = m_stcSampleBlobLead;
                            }

                        }
                        break;
                }
            }
        }

        public void DefineSideLeadTipWidth(ROI objROI, List<PointF> arrLeadCenterPoints, List<SizeF> arrLeadSize)
        {
            float fLimitCenterX;
            float fLimitCenterY;
            float fNewCenterX;
            float fNewCenterY;
            float fWidth;
            float fHeight;
            int intFixPointXY;

            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                switch (m_stcBlobLead.intDirection)
                {
                    //Top
                    case 4:
                        //Base
                        fLimitCenterX = m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterY + (m_stcBlobLead.fHeight / 2) - m_intBaseOffset, 0, MidpointRounding.AwayFromZero);
                        Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                                ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, true, true, intFixPointXY);

                        m_stcBlobLead.fBaseCenterX = fNewCenterX;
                        m_stcBlobLead.fBaseCenterY = fNewCenterY;
                        m_stcBlobLead.fBaseWidth = fWidth;
                        m_stcBlobLead.fBaseLength = fHeight;

                        //Tip
                        fLimitCenterX = m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterY - (m_stcBlobLead.fHeight / 2) + m_intTipOffset, 0, MidpointRounding.AwayFromZero);
                        Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                                ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, true, false, intFixPointXY);

                        m_stcBlobLead.fTipCenterX = fNewCenterX;
                        m_stcBlobLead.fTipCenterY = fNewCenterY;
                        m_stcBlobLead.fTipWidth = fWidth;
                        m_stcBlobLead.fTipLength = fHeight;
                        break;
                    //Right
                    case 2:
                        //Base
                        fLimitCenterX = m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        intFixPointXY = (int)Math.Round(m_stcBlobLead.fTipCenterX + m_intBaseOffset, 0, MidpointRounding.AwayFromZero);
                        Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                                ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, false, false, intFixPointXY);

                        m_stcBlobLead.fBaseCenterX = fNewCenterX;
                        m_stcBlobLead.fBaseCenterY = fNewCenterY;
                        m_stcBlobLead.fBaseWidth = fWidth;
                        m_stcBlobLead.fBaseLength = fHeight;

                        //Tip
                        fLimitCenterX = m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterX + (m_stcBlobLead.fWidth / 2) - m_intTipOffset, 0, MidpointRounding.AwayFromZero);
                        Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                                ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, false, true, intFixPointXY);

                        m_stcBlobLead.fTipCenterX = fNewCenterX;
                        m_stcBlobLead.fTipCenterY = fNewCenterY;
                        m_stcBlobLead.fTipWidth = fWidth;
                        m_stcBlobLead.fTipLength = fHeight;
                        break;
                    //Bottom
                    case 8:
                        //Base
                        fLimitCenterX = m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterY - (m_stcBlobLead.fHeight / 2) + m_intBaseOffset, 0, MidpointRounding.AwayFromZero);
                        Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                                ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, true, false, intFixPointXY);

                        m_stcBlobLead.fBaseCenterX = fNewCenterX;
                        m_stcBlobLead.fBaseCenterY = fNewCenterY;
                        m_stcBlobLead.fBaseWidth = fWidth;
                        m_stcBlobLead.fBaseLength = fHeight;

                        //Tip
                        fLimitCenterX = m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterY + (m_stcBlobLead.fHeight / 2) - m_intTipOffset, 0, MidpointRounding.AwayFromZero);
                        Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                                ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, true, true, intFixPointXY);

                        m_stcBlobLead.fTipCenterX = fNewCenterX;
                        m_stcBlobLead.fTipCenterY = fNewCenterY;
                        m_stcBlobLead.fTipWidth = fWidth;
                        m_stcBlobLead.fTipLength = fHeight;
                        break;
                    //Left
                    case 1:
                        //Tip
                        fLimitCenterX = m_stcBlobLead.fTipCenterX;
                        fLimitCenterY = m_stcBlobLead.fTipCenterY;
                        fWidth = arrLeadSize[i].Width;
                        fHeight = arrLeadSize[i].Height;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        intFixPointXY = (int)Math.Round(m_stcBlobLead.fTipCenterX + m_intTipOffset, 0, MidpointRounding.AwayFromZero);
                        Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                                ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, false, false, intFixPointXY);

                        m_stcBlobLead.fTipCenterX = fNewCenterX;
                        m_stcBlobLead.fTipCenterY = fNewCenterY;
                        m_stcBlobLead.fTipWidth = fWidth;
                        m_stcBlobLead.fTipLength = fHeight;
                        break;
                }

                m_arrTemplateBlobLeads.RemoveAt(i);
                m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
            }
        }

        private bool GetLeadArrayIndexFromNoID(int intLeadNo, ref int intArrayIndex)
        {
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                if (((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID == (intLeadNo + 1))
                {
                    intArrayIndex = i;
                    return true;
                }
            }

            return false;
        }
        public void DrawPointGauge(Graphics g)
        {
            m_objPointGauge.DrawGauge(g);
        }

        public void SetCenterPointGaugePlacement_UsingInspectedLead3DPointGaugePosition(int intLead3DIndex, int intDirectionIndex)
        {
            //intDirectionIndex:
            //    TipStart = 0
            //    TipCenter = 1
            //    TipEnd = 2
            //    BaseStart = 3
            //    BaseCenter = 4
            //    BaseEnd = 5
            // 2021 05 04 - ZJYEOH : change point index to 
            // BaseCenter = 0
            // BaseStart = 1
            // BaseEnd = 2
            // Tip Center = 3
            // Tip Start = 4
            // Tip End = 5     

            if (intLead3DIndex < 0)
                return;

            if (intLead3DIndex >= m_arrLead3DCenterPointGaugeStartX.Count)
                return;

            if (intDirectionIndex >= m_arrLead3DCenterPointGaugeStartX[intLead3DIndex].Count)
                return;

            m_objSettingPointGauge.SetGaugePlacement(m_arrLead3DCenterPointGaugeStartX[intLead3DIndex][intDirectionIndex],
                m_arrLead3DCenterPointGaugeStartY[intLead3DIndex][intDirectionIndex],
                m_arrLead3DCenterPointGaugeTolerance[intLead3DIndex][intDirectionIndex],
                m_arrLead3DCenterPointGaugeAngle[intLead3DIndex][intDirectionIndex]
                );

        }

        public void DrawCenterPointGauge_AllLead3DsPoint(Graphics g, float fScaleX, float fScaleY,
            bool blnSetToAllLeads, bool blnSetToAllPoints,
            int intSelectedROIIndex, int intSelectedLeadIndex, int intSelectedPointIndex)
        {
            //For m_arrLead3DEdgeGaugePoints second array
            //    BaseCenter = 0
            //    BaseStart = 1
            //    BaseEnd = 2
            //    TipCenter = 3
            //    TipStart = 4
            //    TipEnd = 5
            try
            {
                for (int i = 0; i < m_arrLead3DEdgeCenterGaugePoints.Count; i++)
                {
                    if (m_arrLead3DEdgeCenterGaugePoints[i].Count > 0)
                    {
                        switch (m_arrLead3DEdgeCenterGaugePointsPosition[i])
                        {
                            case 4: // Top
                                g.DrawString((i + 1).ToString(), m_Font, new SolidBrush(Color.Red),
                                            m_arrLead3DEdgeCenterGaugePoints[i][3].X * fScaleX,
                                            m_arrLead3DEdgeCenterGaugePoints[i][3].Y * fScaleY - 15);
                                break;
                            case 2: // Right
                                g.DrawString((i + 1).ToString(), m_Font, new SolidBrush(Color.Red),
                                            m_arrLead3DEdgeCenterGaugePoints[i][3].X * fScaleX + 5,
                                            m_arrLead3DEdgeCenterGaugePoints[i][3].Y * fScaleY);
                                break;
                            case 8: // Bottom
                                g.DrawString((i + 1).ToString(), m_Font, new SolidBrush(Color.Red),
                                            m_arrLead3DEdgeCenterGaugePoints[i][3].X * fScaleX,
                                            m_arrLead3DEdgeCenterGaugePoints[i][3].Y * fScaleY + 5);
                                break;
                            case 1: // Left
                                g.DrawString((i + 1).ToString(), m_Font, new SolidBrush(Color.Red),
                                            m_arrLead3DEdgeCenterGaugePoints[i][3].X * fScaleX - 15,
                                            m_arrLead3DEdgeCenterGaugePoints[i][3].Y * fScaleY);
                                break;
                        }
                    }

                    if (blnSetToAllLeads || (!blnSetToAllLeads && i == intSelectedLeadIndex))
                    {
                        for (int j = 0; j < m_arrLead3DEdgeCenterGaugePoints[i].Count; j++)
                        {
                            if (blnSetToAllPoints || (!blnSetToAllPoints && j == intSelectedPointIndex))
                            {
                                if (m_arrLead3DEdgeCenterGaugePointsFound[i][j])
                                {
                                    g.DrawLine(new Pen(Color.Lime, 2f), m_arrLead3DEdgeCenterGaugePoints[i][j].X * fScaleX - 5,
                                                                    m_arrLead3DEdgeCenterGaugePoints[i][j].Y * fScaleY,
                                                                    m_arrLead3DEdgeCenterGaugePoints[i][j].X * fScaleX + 5,
                                                                    m_arrLead3DEdgeCenterGaugePoints[i][j].Y * fScaleY);

                                    g.DrawLine(new Pen(Color.Lime, 2f), m_arrLead3DEdgeCenterGaugePoints[i][j].X * fScaleX,
                                                                    m_arrLead3DEdgeCenterGaugePoints[i][j].Y * fScaleY - 5,
                                                                    m_arrLead3DEdgeCenterGaugePoints[i][j].X * fScaleX,
                                                                    m_arrLead3DEdgeCenterGaugePoints[i][j].Y * fScaleY + 5);
                                }
                                else
                                {
                                    g.DrawLine(new Pen(Color.Red, 2f), m_arrLead3DEdgeCenterGaugePoints[i][j].X * fScaleX - 5,
                                                                      m_arrLead3DEdgeCenterGaugePoints[i][j].Y * fScaleY,
                                                                      m_arrLead3DEdgeCenterGaugePoints[i][j].X * fScaleX + 5,
                                                                      m_arrLead3DEdgeCenterGaugePoints[i][j].Y * fScaleY);

                                    g.DrawLine(new Pen(Color.Red, 2f), m_arrLead3DEdgeCenterGaugePoints[i][j].X * fScaleX,
                                                                    m_arrLead3DEdgeCenterGaugePoints[i][j].Y * fScaleY - 5,
                                                                    m_arrLead3DEdgeCenterGaugePoints[i][j].X * fScaleX,
                                                                    m_arrLead3DEdgeCenterGaugePoints[i][j].Y * fScaleY + 5);
                                }
                            }
                        }
                    }
                }


                m_objSettingPointGauge.DrawGauge(g);

            }
            catch
            {

            }
        }
        public void SetSidePointGaugePlacement_UsingInspectedLead3DPointGaugePosition(int intLead3DIndex, int intDirectionIndex)
        {
            //intDirectionIndex:
            //    TipCenter = 0
            //    TipStart = 1
            //    TipEnd = 2

            if (intLead3DIndex < 0)
                return;

            if (intLead3DIndex >= m_arrLead3DSidePointGaugeStartX.Count)
                return;

            if (intDirectionIndex >= m_arrLead3DSidePointGaugeStartX[intLead3DIndex].Count)
                return;

            m_objSettingPointGauge.SetGaugePlacement(m_arrLead3DSidePointGaugeStartX[intLead3DIndex][intDirectionIndex],
                m_arrLead3DSidePointGaugeStartY[intLead3DIndex][intDirectionIndex],
                m_arrLead3DSidePointGaugeTolerance[intLead3DIndex][intDirectionIndex],
                m_arrLead3DSidePointGaugeAngle[intLead3DIndex][intDirectionIndex]
                );

        }

        public void DrawSidePointGauge_AllLead3DsPoint(Graphics g, float fScaleX, float fScaleY, bool blnDrawSetting,
            bool blnSetToAllROIs, bool blnSetToAllLeads, bool blnSetToAllPoints,
            int intSelectedROIIndex, int intSelectedLeadIndex, int intSelectedPointIndex)
        {
            //For m_arrLead3DEdgeGaugePoints second array
            //    TipCenter = 0
            //    TipStart = 1
            //    TipEnd = 2

            try
            {
                for (int i = 0; i < m_arrLead3DEdgeSideGaugePoints.Count; i++)
                {
                    if (m_arrLead3DEdgeSideGaugePoints[i].Count > 0)
                    {
                        switch (m_arrLead3DEdgeSideGaugePointsPosition[i])
                        {
                            case 1: // Top
                                g.DrawString((i + 1).ToString(), m_Font, new SolidBrush(Color.Red),
                                            m_arrLead3DEdgeSideGaugePoints[i][0].X * fScaleX,
                                            m_arrLead3DEdgeSideGaugePoints[i][0].Y * fScaleY - 15);
                                break;
                            case 2: // Right
                                g.DrawString((i + 1).ToString(), m_Font, new SolidBrush(Color.Red),
                                            m_arrLead3DEdgeSideGaugePoints[i][0].X * fScaleX + 5,
                                            m_arrLead3DEdgeSideGaugePoints[i][0].Y * fScaleY);
                                break;
                            case 3: // Bottom
                                g.DrawString((i + 1).ToString(), m_Font, new SolidBrush(Color.Red),
                                            m_arrLead3DEdgeSideGaugePoints[i][0].X * fScaleX,
                                            m_arrLead3DEdgeSideGaugePoints[i][0].Y * fScaleY + 5);
                                break;
                            case 4: // Left
                                g.DrawString((i + 1).ToString(), m_Font, new SolidBrush(Color.Red),
                                            m_arrLead3DEdgeSideGaugePoints[i][0].X * fScaleX - 15,
                                            m_arrLead3DEdgeSideGaugePoints[i][0].Y * fScaleY);
                                break;
                        }
                    }

                    if (blnSetToAllROIs || (!blnSetToAllROIs && intSelectedROIIndex == m_intLeadROIDirection))
                    {
                        if (blnSetToAllLeads || (!blnSetToAllLeads && i == intSelectedLeadIndex))
                        {
                            for (int j = 0; j < m_arrLead3DEdgeSideGaugePoints[i].Count; j++)
                            {
                                if (blnSetToAllPoints || (!blnSetToAllPoints && j == intSelectedPointIndex))
                                {
                                    if (m_arrLead3DEdgeSideGaugePointsFound[i][j])
                                    {
                                        g.DrawLine(new Pen(Color.Lime, 2f), m_arrLead3DEdgeSideGaugePoints[i][j].X * fScaleX - 5,
                                                                        m_arrLead3DEdgeSideGaugePoints[i][j].Y * fScaleY,
                                                                        m_arrLead3DEdgeSideGaugePoints[i][j].X * fScaleX + 5,
                                                                        m_arrLead3DEdgeSideGaugePoints[i][j].Y * fScaleY);

                                        g.DrawLine(new Pen(Color.Lime, 2f), m_arrLead3DEdgeSideGaugePoints[i][j].X * fScaleX,
                                                                        m_arrLead3DEdgeSideGaugePoints[i][j].Y * fScaleY - 5,
                                                                        m_arrLead3DEdgeSideGaugePoints[i][j].X * fScaleX,
                                                                        m_arrLead3DEdgeSideGaugePoints[i][j].Y * fScaleY + 5);
                                    }
                                    else
                                    {
                                        g.DrawLine(new Pen(Color.Red, 2f), m_arrLead3DEdgeSideGaugePoints[i][j].X * fScaleX - 5,
                                                                          m_arrLead3DEdgeSideGaugePoints[i][j].Y * fScaleY,
                                                                          m_arrLead3DEdgeSideGaugePoints[i][j].X * fScaleX + 5,
                                                                          m_arrLead3DEdgeSideGaugePoints[i][j].Y * fScaleY);

                                        g.DrawLine(new Pen(Color.Red, 2f), m_arrLead3DEdgeSideGaugePoints[i][j].X * fScaleX,
                                                                        m_arrLead3DEdgeSideGaugePoints[i][j].Y * fScaleY - 5,
                                                                        m_arrLead3DEdgeSideGaugePoints[i][j].X * fScaleX,
                                                                        m_arrLead3DEdgeSideGaugePoints[i][j].Y * fScaleY + 5);
                                    }
                                }
                            }
                        }
                    }
                    
                }

                if (blnDrawSetting)
                    m_objSettingPointGauge.DrawGauge(g);

            }
            catch
            {

            }
        }
        public void SetCornerPointGaugePlacement_UsingInspectedLead3DPointGaugePosition(int intDirectionIndex)
        {
            //intDirectionIndex:
            //    Left = 0
            //    Right = 1

            if (m_arrLead3DCornerPointGaugeStartX.Count == 0)
                return;

            if (intDirectionIndex >= m_arrLead3DCornerPointGaugeStartX[0].Count)
                return;

            m_objSettingPointGauge.SetGaugePlacement(m_arrLead3DCornerPointGaugeStartX[0][intDirectionIndex],
                m_arrLead3DCornerPointGaugeStartY[0][intDirectionIndex],
                m_arrLead3DCornerPointGaugeTolerance[0][intDirectionIndex],
                m_arrLead3DCornerPointGaugeAngle[0][intDirectionIndex]
                );

        }

        public void DrawCornerPointGauge_AllLead3DsPoint(Graphics g, float fScaleX, float fScaleY, bool blnDrawSetting,
            bool blnSetToAllROIs, bool blnSetToAllPoints,
            int intSelectedROIIndex, int intSelectedPointIndex)
        {
            //For m_arrLead3DEdgeGaugePoints second array 
            //    Left = 0
            //    Right = 1


            try
            {
                for (int i = 0; i < m_arrLead3DEdgeCornerGaugePoints.Count; i++)
                {
                    if (blnSetToAllROIs || (!blnSetToAllROIs && intSelectedROIIndex == m_intLeadROIDirection))
                    {
                        for (int j = 0; j < m_arrLead3DEdgeCornerGaugePoints[i].Count; j++)
                        {
                            if (blnSetToAllPoints || (!blnSetToAllPoints && j == intSelectedPointIndex))
                            {
                                if (m_arrLead3DEdgeCornerGaugePointsFound[i][j])
                                {
                                    g.DrawLine(new Pen(Color.Lime, 2f), m_arrLead3DEdgeCornerGaugePoints[i][j].X * fScaleX - 5,
                                                                    m_arrLead3DEdgeCornerGaugePoints[i][j].Y * fScaleY,
                                                                    m_arrLead3DEdgeCornerGaugePoints[i][j].X * fScaleX + 5,
                                                                    m_arrLead3DEdgeCornerGaugePoints[i][j].Y * fScaleY);

                                    g.DrawLine(new Pen(Color.Lime, 2f), m_arrLead3DEdgeCornerGaugePoints[i][j].X * fScaleX,
                                                                    m_arrLead3DEdgeCornerGaugePoints[i][j].Y * fScaleY - 5,
                                                                    m_arrLead3DEdgeCornerGaugePoints[i][j].X * fScaleX,
                                                                    m_arrLead3DEdgeCornerGaugePoints[i][j].Y * fScaleY + 5);
                                }
                                else
                                {
                                    g.DrawLine(new Pen(Color.Red, 2f), m_arrLead3DEdgeCornerGaugePoints[i][j].X * fScaleX - 5,
                                                                      m_arrLead3DEdgeCornerGaugePoints[i][j].Y * fScaleY,
                                                                      m_arrLead3DEdgeCornerGaugePoints[i][j].X * fScaleX + 5,
                                                                      m_arrLead3DEdgeCornerGaugePoints[i][j].Y * fScaleY);

                                    g.DrawLine(new Pen(Color.Red, 2f), m_arrLead3DEdgeCornerGaugePoints[i][j].X * fScaleX,
                                                                    m_arrLead3DEdgeCornerGaugePoints[i][j].Y * fScaleY - 5,
                                                                    m_arrLead3DEdgeCornerGaugePoints[i][j].X * fScaleX,
                                                                    m_arrLead3DEdgeCornerGaugePoints[i][j].Y * fScaleY + 5);
                                }
                            }
                        }
                    }

                }

                if (blnDrawSetting)
                    m_objSettingPointGauge.DrawGauge(g);

            }
            catch
            {

            }
        }
        public void CopyCenterSettingToSettingPointGauge(int intLeadIndex, int intDirectionIndex)
        {
            if (intLeadIndex >= m_arrCenterPointGauge.Count)
                return;

            if (intDirectionIndex >= m_arrCenterPointGauge[intLeadIndex].Count)
                return;

            m_objSettingPointGauge.ref_objPointGauge.SetCenterXY(m_arrCenterPointGauge[intLeadIndex][intDirectionIndex].ref_objPointGauge.CenterX, m_arrCenterPointGauge[intLeadIndex][intDirectionIndex].ref_objPointGauge.CenterY);
            m_objSettingPointGauge.ref_objPointGauge.MinAmplitude = m_arrCenterPointGauge[intLeadIndex][intDirectionIndex].ref_objPointGauge.MinAmplitude;
            m_objSettingPointGauge.ref_objPointGauge.MinArea = m_arrCenterPointGauge[intLeadIndex][intDirectionIndex].ref_objPointGauge.MinArea;
            m_objSettingPointGauge.ref_objPointGauge.Smoothing = m_arrCenterPointGauge[intLeadIndex][intDirectionIndex].ref_objPointGauge.Smoothing;
            m_objSettingPointGauge.ref_objPointGauge.Thickness = m_arrCenterPointGauge[intLeadIndex][intDirectionIndex].ref_objPointGauge.Thickness;
            m_objSettingPointGauge.ref_objPointGauge.Threshold = m_arrCenterPointGauge[intLeadIndex][intDirectionIndex].ref_objPointGauge.Threshold;
            m_objSettingPointGauge.ref_objPointGauge.TransitionType = m_arrCenterPointGauge[intLeadIndex][intDirectionIndex].ref_objPointGauge.TransitionType;
            m_objSettingPointGauge.ref_objPointGauge.TransitionChoice = m_arrCenterPointGauge[intLeadIndex][intDirectionIndex].ref_objPointGauge.TransitionChoice;
            m_objSettingPointGauge.ref_objPointGauge.Tolerance = m_arrCenterPointGauge[intLeadIndex][intDirectionIndex].ref_objPointGauge.Tolerance;
            m_objSettingPointGauge.ref_objPointGauge.Angle = m_arrCenterPointGauge[intLeadIndex][intDirectionIndex].ref_objPointGauge.Angle;
        }

        public void CopySideSettingToSettingPointGauge(int intLeadIndex, int intDirectionIndex)
        {
            if (intLeadIndex >= m_arrSidePointGauge.Count)
                return;

            if (intDirectionIndex >= m_arrSidePointGauge[intLeadIndex].Count)
                return;

            m_objSettingPointGauge.ref_objPointGauge.SetCenterXY(m_arrSidePointGauge[intLeadIndex][intDirectionIndex].ref_objPointGauge.CenterX, m_arrSidePointGauge[intLeadIndex][intDirectionIndex].ref_objPointGauge.CenterY);
            m_objSettingPointGauge.ref_objPointGauge.MinAmplitude = m_arrSidePointGauge[intLeadIndex][intDirectionIndex].ref_objPointGauge.MinAmplitude;
            m_objSettingPointGauge.ref_objPointGauge.MinArea = m_arrSidePointGauge[intLeadIndex][intDirectionIndex].ref_objPointGauge.MinArea;
            m_objSettingPointGauge.ref_objPointGauge.Smoothing = m_arrSidePointGauge[intLeadIndex][intDirectionIndex].ref_objPointGauge.Smoothing;
            m_objSettingPointGauge.ref_objPointGauge.Thickness = m_arrSidePointGauge[intLeadIndex][intDirectionIndex].ref_objPointGauge.Thickness;
            m_objSettingPointGauge.ref_objPointGauge.Threshold = m_arrSidePointGauge[intLeadIndex][intDirectionIndex].ref_objPointGauge.Threshold;
            m_objSettingPointGauge.ref_objPointGauge.TransitionType = m_arrSidePointGauge[intLeadIndex][intDirectionIndex].ref_objPointGauge.TransitionType;
            m_objSettingPointGauge.ref_objPointGauge.TransitionChoice = m_arrSidePointGauge[intLeadIndex][intDirectionIndex].ref_objPointGauge.TransitionChoice;
            m_objSettingPointGauge.ref_objPointGauge.Tolerance = m_arrSidePointGauge[intLeadIndex][intDirectionIndex].ref_objPointGauge.Tolerance;
            m_objSettingPointGauge.ref_objPointGauge.Angle = m_arrSidePointGauge[intLeadIndex][intDirectionIndex].ref_objPointGauge.Angle;
        }

        public void CopyCornerSettingToSettingPointGauge(int intDirectionIndex)
        {
            m_objSettingPointGauge.ref_objPointGauge.SetCenterXY(m_arrCornerPointGauge[intDirectionIndex].ref_objPointGauge.CenterX, m_arrCornerPointGauge[intDirectionIndex].ref_objPointGauge.CenterY);
            m_objSettingPointGauge.ref_objPointGauge.MinAmplitude = m_arrCornerPointGauge[intDirectionIndex].ref_objPointGauge.MinAmplitude;
            m_objSettingPointGauge.ref_objPointGauge.MinArea = m_arrCornerPointGauge[intDirectionIndex].ref_objPointGauge.MinArea;
            m_objSettingPointGauge.ref_objPointGauge.Smoothing = m_arrCornerPointGauge[intDirectionIndex].ref_objPointGauge.Smoothing;
            m_objSettingPointGauge.ref_objPointGauge.Thickness = m_arrCornerPointGauge[intDirectionIndex].ref_objPointGauge.Thickness;
            m_objSettingPointGauge.ref_objPointGauge.Threshold = m_arrCornerPointGauge[intDirectionIndex].ref_objPointGauge.Threshold;
            m_objSettingPointGauge.ref_objPointGauge.TransitionType = m_arrCornerPointGauge[intDirectionIndex].ref_objPointGauge.TransitionType;
            m_objSettingPointGauge.ref_objPointGauge.TransitionChoice = m_arrCornerPointGauge[intDirectionIndex].ref_objPointGauge.TransitionChoice;
            m_objSettingPointGauge.ref_objPointGauge.Tolerance = m_arrCornerPointGauge[intDirectionIndex].ref_objPointGauge.Tolerance;
            m_objSettingPointGauge.ref_objPointGauge.Angle = m_arrCornerPointGauge[intDirectionIndex].ref_objPointGauge.Angle;
        }
        public void LoadArrayPointGauge_Center(string strPath, string strSectionName_Prev)
        {
            for (int i = 0; i < m_intNumberOfLead; i++)
            {
                if (i >= m_arrCenterPointGauge.Count)
                {
                    m_arrCenterPointGauge.Add(new List<PGauge>());
                }

                for (int j = 0; j < 6; j++)
                {
                    if (j >= m_arrCenterPointGauge[i].Count)
                    {
                        m_arrCenterPointGauge[i].Add(new PGauge());
                    }

                    // 2020 11 11 - CCENG: i is lead number. j is base tip point number.
                    m_arrCenterPointGauge[i][j].LoadPointGauge(strPath, "Lead3D" + m_intLeadROIDirection.ToString() + "_" + i.ToString() + "_" + j.ToString(), strSectionName_Prev);
                    //m_arrCenterPointGauge[i][j].ref_GaugeMinAmplitude = 0;    // 2021-05-12 ZJYEOH : User now can set min amplitude
                    m_arrCenterPointGauge[i][j].ref_GaugeMinArea = 0;
                    m_arrCenterPointGauge[i][j].ref_GaugeFilter = 2;

                }
            }

        }
        public void LoadArrayPointGauge_Side(string strPath, string strSectionName_Prev)
        {
            for (int i = 0; i < GetNumberOfLead(); i++)
            {
                if (i >= m_arrSidePointGauge.Count)
                {
                    m_arrSidePointGauge.Add(new List<PGauge>());
                }

                for (int j = 0; j < 3; j++)
                {
                    if (j >= m_arrSidePointGauge[i].Count)
                    {
                        m_arrSidePointGauge[i].Add(new PGauge());
                    }

                    // 2020 11 11 - CCENG: i is lead number. j is base tip point number.
                    m_arrSidePointGauge[i][j].LoadPointGauge(strPath, "Lead3D" + m_intLeadROIDirection.ToString() + "_" + i.ToString() + "_" + j.ToString(), strSectionName_Prev);
                    //m_arrSidePointGauge[i][j].ref_GaugeMinAmplitude = 0;      // 2021-05-12 ZJYEOH : User now can set min amplitude
                    m_arrSidePointGauge[i][j].ref_GaugeMinArea = 0;
                    m_arrSidePointGauge[i][j].ref_GaugeFilter = 2;

                }
            }

        }
        public void LoadArrayPointGauge_Corner(string strPath, string strSectionName_Prev)
        {
            for (int j = 0; j < 2; j++)
            {
                if (j >= m_arrCornerPointGauge.Count)
                {
                    m_arrCornerPointGauge.Add(new PGauge());
                }
                
                m_arrCornerPointGauge[j].LoadPointGauge(strPath, "Lead3D" + m_intLeadROIDirection.ToString() + "_" + j.ToString(), strSectionName_Prev);
                //m_arrCornerPointGauge[j].ref_GaugeMinAmplitude = 0;       // 2021-05-12 ZJYEOH : User now can set min amplitude
                m_arrCornerPointGauge[j].ref_GaugeMinArea = 0;
                m_arrCornerPointGauge[j].ref_GaugeFilter = 2;

            }
        }
        public void SaveArrayPointGauge_Center(string strPath)
        {
            for (int i = 0; i < m_intNumberOfLead; i++)
            {
                if (i >= m_arrCenterPointGauge.Count)
                    break;

                for (int j = 0; j < 6; j++)
                {
                    if (j >= m_arrCenterPointGauge[i].Count)
                        break;
                    
                    m_arrCenterPointGauge[i][j].SavePointGauge(strPath, false, "Lead3D" + m_intLeadROIDirection.ToString() + "_" + i.ToString() + "_" + j.ToString(), true, true);
                }
            }

        }
        public void SaveArrayPointGauge_Side(string strPath)
        {
           
            for (int i = 0; i < GetNumberOfLead(); i++)
            {
                if (i >= m_arrSidePointGauge.Count)
                    break;

                for (int j = 0; j < 3; j++)
                {
                    if (j >= m_arrSidePointGauge[i].Count)
                        break;

                    m_arrSidePointGauge[i][j].SavePointGauge(strPath, false, "Lead3D" + m_intLeadROIDirection.ToString() + "_" + i.ToString() + "_" + j.ToString(), true, true);
                }
            }

        }
        public void SaveArrayPointGauge_Corner(string strPath)
        {
            for (int j = 0; j < 2; j++)
            {
                if (j >= m_arrCornerPointGauge.Count)
                    break;

                m_arrCornerPointGauge[j].SavePointGauge(strPath, false, "Lead3D" + m_intLeadROIDirection.ToString() + "_" + j.ToString(), true, true);
            }
        }
        public int GetNumberOfLead()
        {
            int intNumberOfLead = 0;
            switch (m_intLeadROIDirection)
            {
                case 0:
                    intNumberOfLead = m_intNumberOfLead;
                    break;
                case 1:
                    intNumberOfLead = m_intNumberOfLead_Top;
                    break;
                case 2:
                    intNumberOfLead = m_intNumberOfLead_Right;
                    break;
                case 3:
                    intNumberOfLead = m_intNumberOfLead_Bottom;
                    break;
                case 4:
                    intNumberOfLead = m_intNumberOfLead_Left;
                    break;
            }
            return intNumberOfLead;
        }

        public int GetPitchGapToLeadNo(int intFromPadNo)
        {
            string strPitchGapData = "";

            for (int i = 0; i < m_arrPitchGap.Count; i++)
            {
                PitchGap stcPitchGap = m_arrPitchGap[i];

                if (stcPitchGap.intFromLeadNo == intFromPadNo)
                {
                    return stcPitchGap.intToLeadNo;
                }
            }

            return -1;
        }
        public List<List<string>> GetDefectList_Old()
        {
            List<List<string>> arrDefectList = new List<List<string>>();

            int intCount = 0;
            float fMeasure;

            for (int i = 0; i < m_arrFailResultMask.Length; i++)
            {
                // Length variance
                if ((m_arrFailResultMask[i] & 0x800) > 0)
                {
                    arrDefectList.Add(new List<string>());
                    switch (i)
                    {

                        case 0:
                            if (m_intLeadLengthVarianceMethod != 0)
                            {
                                fMeasure = m_fLengthVarianceOverallResult * m_fMMToUnitValue;
                                arrDefectList[intCount].Add(0x02.ToString());
                                arrDefectList[intCount].Add("Overall Length Variance");
                                arrDefectList[intCount].Add("---");
                                arrDefectList[intCount].Add(fMeasure.ToString("F4"));
                                arrDefectList[intCount].Add("---");
                            }
                            break;
                        case 1:
                            if (m_intLeadLengthVarianceMethod != 1)
                            {
                                fMeasure = m_fLengthVarianceTopResult * m_fMMToUnitValue;
                                arrDefectList[intCount].Add(0x02.ToString());
                                arrDefectList[intCount].Add("Top Length Variance");
                                arrDefectList[intCount].Add("---");
                                arrDefectList[intCount].Add(fMeasure.ToString("F4"));
                                arrDefectList[intCount].Add("---");
                            }
                            break;
                        case 2:
                            if (m_intLeadLengthVarianceMethod != 1)
                            {
                                fMeasure = m_fLengthVarianceRightResult * m_fMMToUnitValue;
                                arrDefectList[intCount].Add(0x02.ToString());
                                arrDefectList[intCount].Add("Right Length Variance");
                                arrDefectList[intCount].Add("---");
                                arrDefectList[intCount].Add(fMeasure.ToString("F4"));
                                arrDefectList[intCount].Add("---");
                            }
                            break;
                        case 3:
                            if (m_intLeadLengthVarianceMethod != 1)
                            {
                                fMeasure = m_fLengthVarianceBottomResult * m_fMMToUnitValue;
                                arrDefectList[intCount].Add(0x02.ToString());
                                arrDefectList[intCount].Add("Bottom Length Variance");
                                arrDefectList[intCount].Add("---");
                                arrDefectList[intCount].Add(fMeasure.ToString("F4"));
                                arrDefectList[intCount].Add("---");
                            }
                            break;
                        case 4:
                            if (m_intLeadLengthVarianceMethod != 1)
                            {
                                fMeasure = m_fLengthVarianceLeftResult * m_fMMToUnitValue;
                                arrDefectList[intCount].Add(0x02.ToString());
                                arrDefectList[intCount].Add("Left Length Variance");
                                arrDefectList[intCount].Add("---");
                                arrDefectList[intCount].Add(fMeasure.ToString("F4"));
                                arrDefectList[intCount].Add("---");
                            }
                            break;
                    }
                    intCount++;
                }
            }

            for (int i = 0; i < m_arrFailResultMask.Length; i++)
            {
                // Stand Off variance
                if ((m_arrFailResultMask[i] & 0x4000) > 0)
                {
                    arrDefectList.Add(new List<string>());
                    switch (i)
                    {
                        case 0:
                            fMeasure = m_fStandOffVarianceUnitResult * m_fMMToUnitValue;
                            arrDefectList[intCount].Add(0x02.ToString());
                            arrDefectList[intCount].Add("Unit Stand Off Variance");
                            arrDefectList[intCount].Add("---");
                            arrDefectList[intCount].Add(fMeasure.ToString("F4"));
                            arrDefectList[intCount].Add("---");
                            break;
                        case 1:
                            fMeasure = m_fStandOffVarianceTopResult * m_fMMToUnitValue;
                            arrDefectList[intCount].Add(0x02.ToString());
                            arrDefectList[intCount].Add("Top Stand Off Variance");
                            arrDefectList[intCount].Add("---");
                            arrDefectList[intCount].Add(fMeasure.ToString("F4"));
                            arrDefectList[intCount].Add("---");
                            break;
                        case 2:
                            fMeasure = m_fStandOffVarianceRightResult * m_fMMToUnitValue;
                            arrDefectList[intCount].Add(0x02.ToString());
                            arrDefectList[intCount].Add("Right Stand Off Variance");
                            arrDefectList[intCount].Add("---");
                            arrDefectList[intCount].Add(fMeasure.ToString("F4"));
                            arrDefectList[intCount].Add("---");
                            break;
                        case 3:
                            fMeasure = m_fStandOffVarianceBottomResult * m_fMMToUnitValue;
                            arrDefectList[intCount].Add(0x02.ToString());
                            arrDefectList[intCount].Add("Bottom Stand Off Variance");
                            arrDefectList[intCount].Add("---");
                            arrDefectList[intCount].Add(fMeasure.ToString("F4"));
                            arrDefectList[intCount].Add("---");
                            break;
                        case 4:
                            fMeasure = m_fStandOffVarianceLeftResult * m_fMMToUnitValue;
                            arrDefectList[intCount].Add(0x02.ToString());
                            arrDefectList[intCount].Add("Left Stand Off Variance");
                            arrDefectList[intCount].Add("---");
                            arrDefectList[intCount].Add(fMeasure.ToString("F4"));
                            arrDefectList[intCount].Add("---");
                            break;
                    }
                    intCount++;
                }
            }

            for (int i = 1; i < m_arrFailResultMask.Length; i++)
            {
                // Leads Sweep 
                if ((m_arrFailResultMask[i] & 0x04) > 0)
                {
                    arrDefectList.Add(new List<string>());
                    switch (i)
                    {
                        case 1:
                            fMeasure = m_fLeadSweepVarianceTopResult * m_fMMToUnitValue;
                            arrDefectList[intCount].Add(0x02.ToString());
                            arrDefectList[intCount].Add("Top Leads Sweep");
                            arrDefectList[intCount].Add("---");
                            arrDefectList[intCount].Add(fMeasure.ToString("F4"));
                            arrDefectList[intCount].Add("---");
                            break;
                        case 2:
                            fMeasure = m_fLeadSweepVarianceRightResult * m_fMMToUnitValue;
                            arrDefectList[intCount].Add(0x02.ToString());
                            arrDefectList[intCount].Add("Right Leads Sweep");
                            arrDefectList[intCount].Add("---");
                            arrDefectList[intCount].Add(fMeasure.ToString("F4"));
                            arrDefectList[intCount].Add("---");
                            break;
                        case 3:
                            fMeasure = m_fLeadSweepVarianceTopResult * m_fMMToUnitValue;
                            arrDefectList[intCount].Add(0x02.ToString());
                            arrDefectList[intCount].Add("Bottom Leads Sweep");
                            arrDefectList[intCount].Add("---");
                            arrDefectList[intCount].Add(fMeasure.ToString("F4"));
                            arrDefectList[intCount].Add("---");
                            break;
                        case 4:
                            fMeasure = m_fLeadSweepVarianceLeftResult * m_fMMToUnitValue;
                            arrDefectList[intCount].Add(0x02.ToString());
                            arrDefectList[intCount].Add("Left Leads Sweep");
                            arrDefectList[intCount].Add("---");
                            arrDefectList[intCount].Add(fMeasure.ToString("F4"));
                            arrDefectList[intCount].Add("---");
                            break;
                    }
                    intCount++;
                }
            }

            for (int i = 0; i < m_arrFailResultMask.Length; i++)
            {
                // Span
                if ((m_arrFailResultMask[i] & 0x1000) > 0)
                {
                    arrDefectList.Add(new List<string>());
                    switch (i)
                    {

                        case 0:
                            if (m_intLeadSpanMethod != 0)
                            {
                                fMeasure = m_fSpanOverallResult * m_fMMToUnitValue;
                                arrDefectList[intCount].Add(0x02.ToString());
                                arrDefectList[intCount].Add("Overall Span");
                                arrDefectList[intCount].Add("---");
                                arrDefectList[intCount].Add(fMeasure.ToString("F4"));
                                arrDefectList[intCount].Add("---");
                            }
                            break;
                        case 1:
                            if (m_intLeadSpanMethod != 1)
                            {
                                fMeasure = m_fSpanTopResult * m_fMMToUnitValue;
                                arrDefectList[intCount].Add(0x02.ToString());
                                arrDefectList[intCount].Add("Top Span");
                                arrDefectList[intCount].Add("---");
                                arrDefectList[intCount].Add(fMeasure.ToString("F4"));
                                arrDefectList[intCount].Add("---");
                            }
                            break;
                        case 2:
                            if (m_intLeadSpanMethod != 1)
                            {
                                fMeasure = m_fSpanRightResult * m_fMMToUnitValue;
                                arrDefectList[intCount].Add(0x02.ToString());
                                arrDefectList[intCount].Add("Right Span");
                                arrDefectList[intCount].Add("---");
                                arrDefectList[intCount].Add(fMeasure.ToString("F4"));
                                arrDefectList[intCount].Add("---");
                            }
                            break;
                        case 3:
                            if (m_intLeadSpanMethod != 1)
                            {
                                fMeasure = m_fSpanBottomResult * m_fMMToUnitValue;
                                arrDefectList[intCount].Add(0x02.ToString());
                                arrDefectList[intCount].Add("Bottom Span");
                                arrDefectList[intCount].Add("---");
                                arrDefectList[intCount].Add(fMeasure.ToString("F4"));
                                arrDefectList[intCount].Add("---");
                            }
                            break;
                        case 4:
                            if (m_intLeadSpanMethod != 1)
                            {
                                fMeasure = m_fSpanLeftResult * m_fMMToUnitValue;
                                arrDefectList[intCount].Add(0x02.ToString());
                                arrDefectList[intCount].Add("Left Span");
                                arrDefectList[intCount].Add("---");
                                arrDefectList[intCount].Add(fMeasure.ToString("F4"));
                                arrDefectList[intCount].Add("---");
                            }
                            break;
                    }
                    intCount++;
                }
            }
            return arrDefectList;
        }
        public List<List<string>> GetDefectList()
        {
            List<List<string>> arrDefectList = new List<List<string>>();

            int intCount = 0;
            float fMeasure;
            int intFailMask = 0;

            if ((m_intFailOptionMask & 0x2000) > 0)
            {
                for (int i = 1; i < m_arrFailResultMask.Length; i++)
                {
                    if (arrDefectList.Count <= intCount)
                    {
                        arrDefectList.Add(new List<string>());
                        arrDefectList[intCount].Add(0x00.ToString());
                        arrDefectList[intCount].Add("Pitch Variance");
                        arrDefectList[intCount].Add("Left"); // index 2
                        arrDefectList[intCount].Add("Right");// index 3
                        arrDefectList[intCount].Add("Top");// index 4
                        arrDefectList[intCount].Add("Bottom");// index 5
                        arrDefectList[intCount].Add("Unit");// index 6
                    }
                    // Pitch variance
                    if ((m_arrFailResultMask[i] & 0x2000) > 0)
                    {
                        switch (i)
                        {
                            case 1: // Top
                                intFailMask |= 0x04;
                                arrDefectList[intCount][0] = intFailMask.ToString();
                                fMeasure = m_fPitchVarianceTopResult * m_fMMToUnitValue;
                                if (fMeasure == -999)
                                    arrDefectList[intCount][4] = "---";
                                else
                                    arrDefectList[intCount][4] = fMeasure.ToString("F4");
                                break;
                            case 2: // Right
                                intFailMask |= 0x02;
                                arrDefectList[intCount][0] = intFailMask.ToString();
                                fMeasure = m_fPitchVarianceRightResult * m_fMMToUnitValue;
                                if (fMeasure == -999)
                                    arrDefectList[intCount][3] = "---";
                                else
                                    arrDefectList[intCount][3] = fMeasure.ToString("F4");
                                break;
                            case 3: // Bottom
                                intFailMask |= 0x08;
                                arrDefectList[intCount][0] = intFailMask.ToString();
                                fMeasure = m_fPitchVarianceBottomResult * m_fMMToUnitValue;
                                if (fMeasure == -999)
                                    arrDefectList[intCount][5] = "---";
                                else
                                    arrDefectList[intCount][5] = fMeasure.ToString("F4");
                                break;
                            case 4: // Left
                                intFailMask |= 0x01;
                                arrDefectList[intCount][0] = intFailMask.ToString();
                                fMeasure = m_fPitchVarianceLeftResult * m_fMMToUnitValue;
                                if (fMeasure == -999)
                                    arrDefectList[intCount][2] = "---";
                                else
                                    arrDefectList[intCount][2] = fMeasure.ToString("F4");
                                break;
                        }
                    }
                    else
                    {
                        switch (i)
                        {
                            case 1: // Top
                                fMeasure = m_fPitchVarianceTopResult * m_fMMToUnitValue;
                                if (fMeasure == -999)
                                    arrDefectList[intCount][4] = "---";
                                else
                                    arrDefectList[intCount][4] = fMeasure.ToString("F4");
                                break;
                            case 2: // Right
                                fMeasure = m_fPitchVarianceRightResult * m_fMMToUnitValue;
                                if (fMeasure == -999)
                                    arrDefectList[intCount][3] = "---";
                                else
                                    arrDefectList[intCount][3] = fMeasure.ToString("F4");
                                break;
                            case 3: // Bottom
                                fMeasure = m_fPitchVarianceBottomResult * m_fMMToUnitValue;
                                if (fMeasure == -999)
                                    arrDefectList[intCount][5] = "---";
                                else
                                    arrDefectList[intCount][5] = fMeasure.ToString("F4");
                                break;
                            case 4: // Left
                                fMeasure = m_fPitchVarianceLeftResult * m_fMMToUnitValue;
                                if (fMeasure == -999)
                                    arrDefectList[intCount][2] = "---";
                                else
                                    arrDefectList[intCount][2] = fMeasure.ToString("F4");
                                break;
                        }
                    }
                }

                if (arrDefectList.Count > intCount)
                    intCount++;
            }

            intFailMask = 0;
            if ((m_intFailOptionMask & 0x800) > 0)
            {
                for (int i = 0; i < m_arrFailResultMask.Length; i++)
                {
                    if (arrDefectList.Count <= intCount)
                    {
                        arrDefectList.Add(new List<string>());
                        arrDefectList[intCount].Add(0x00.ToString());
                        arrDefectList[intCount].Add("Length Variance");
                        arrDefectList[intCount].Add("Left"); // index 2
                        arrDefectList[intCount].Add("Right");// index 3
                        arrDefectList[intCount].Add("Top");// index 4
                        arrDefectList[intCount].Add("Bottom");// index 5
                        arrDefectList[intCount].Add("Unit");// index 6
                    }
                    // Length variance
                    if ((m_arrFailResultMask[i] & 0x800) > 0)
                    {
                        switch (i)
                        {
                            case 0: // Overall
                                if (m_intLeadLengthVarianceMethod != 0)
                                {
                                    intFailMask |= 0x10;
                                    arrDefectList[intCount][0] = intFailMask.ToString();
                                    fMeasure = m_fLengthVarianceOverallResult * m_fMMToUnitValue;
                                    if (fMeasure == -999)
                                        arrDefectList[intCount][6] = "---";
                                    else
                                        arrDefectList[intCount][6] = fMeasure.ToString("F4");
                                }
                                break;
                            case 1: // Top
                                if (m_intLeadLengthVarianceMethod != 1)
                                {
                                    intFailMask |= 0x04;
                                    arrDefectList[intCount][0] = intFailMask.ToString();
                                    fMeasure = m_fLengthVarianceTopResult * m_fMMToUnitValue;
                                    if (fMeasure == -999)
                                        arrDefectList[intCount][4] = "---";
                                    else
                                        arrDefectList[intCount][4] = fMeasure.ToString("F4");
                                }
                                break;
                            case 2: // Right
                                if (m_intLeadLengthVarianceMethod != 1)
                                {
                                    intFailMask |= 0x02;
                                    arrDefectList[intCount][0] = intFailMask.ToString();
                                    fMeasure = m_fLengthVarianceRightResult * m_fMMToUnitValue;
                                    if (fMeasure == -999)
                                        arrDefectList[intCount][3] = "---";
                                    else
                                        arrDefectList[intCount][3] = fMeasure.ToString("F4");
                                }
                                break;
                            case 3: // Bottom
                                if (m_intLeadLengthVarianceMethod != 1)
                                {
                                    intFailMask |= 0x08;
                                    arrDefectList[intCount][0] = intFailMask.ToString();
                                    fMeasure = m_fLengthVarianceBottomResult * m_fMMToUnitValue;
                                    if (fMeasure == -999)
                                        arrDefectList[intCount][5] = "---";
                                    else
                                        arrDefectList[intCount][5] = fMeasure.ToString("F4");
                                }
                                break;
                            case 4: // Left
                                if (m_intLeadLengthVarianceMethod != 1)
                                {
                                    intFailMask |= 0x01;
                                    arrDefectList[intCount][0] = intFailMask.ToString();
                                    fMeasure = m_fLengthVarianceLeftResult * m_fMMToUnitValue;
                                    if (fMeasure == -999)
                                        arrDefectList[intCount][2] = "---";
                                    else
                                        arrDefectList[intCount][2] = fMeasure.ToString("F4");
                                }
                                break;
                        }
                    }
                    else
                    {
                        switch (i)
                        {
                            case 0: // Overall
                                if (m_intLeadLengthVarianceMethod != 0)
                                {
                                    fMeasure = m_fLengthVarianceOverallResult * m_fMMToUnitValue;
                                    if (fMeasure == -999)
                                        arrDefectList[intCount][6] = "---";
                                    else
                                        arrDefectList[intCount][6] = fMeasure.ToString("F4");
                                }
                                break;
                            case 1: // Top
                                if (m_intLeadLengthVarianceMethod != 1)
                                {
                                    fMeasure = m_fLengthVarianceTopResult * m_fMMToUnitValue;
                                    if (fMeasure == -999)
                                        arrDefectList[intCount][4] = "---";
                                    else
                                        arrDefectList[intCount][4] = fMeasure.ToString("F4");
                                }
                                break;
                            case 2: // Right
                                if (m_intLeadLengthVarianceMethod != 1)
                                {
                                    fMeasure = m_fLengthVarianceRightResult * m_fMMToUnitValue;
                                    if (fMeasure == -999)
                                        arrDefectList[intCount][3] = "---";
                                    else
                                        arrDefectList[intCount][3] = fMeasure.ToString("F4");
                                }
                                break;
                            case 3: // Bottom
                                if (m_intLeadLengthVarianceMethod != 1)
                                {
                                    fMeasure = m_fLengthVarianceBottomResult * m_fMMToUnitValue;
                                    if (fMeasure == -999)
                                        arrDefectList[intCount][5] = "---";
                                    else
                                        arrDefectList[intCount][5] = fMeasure.ToString("F4");
                                }
                                break;
                            case 4: // Left
                                if (m_intLeadLengthVarianceMethod != 1)
                                {
                                    fMeasure = m_fLengthVarianceLeftResult * m_fMMToUnitValue;
                                    if (fMeasure == -999)
                                        arrDefectList[intCount][2] = "---";
                                    else
                                        arrDefectList[intCount][2] = fMeasure.ToString("F4");
                                }
                                break;
                        }
                    }
                }

                if (arrDefectList.Count > intCount)
                    intCount++;
            }

            intFailMask = 0;
            if ((m_intFailOptionMask & 0x4000) > 0)
            {
                for (int i = 0; i < m_arrFailResultMask.Length; i++)
                {
                    if (arrDefectList.Count <= intCount)
                    {
                        arrDefectList.Add(new List<string>());
                        arrDefectList[intCount].Add(0x00.ToString());
                        arrDefectList[intCount].Add("Stand Off Variance");
                        arrDefectList[intCount].Add("Left"); // index 2
                        arrDefectList[intCount].Add("Right");// index 3
                        arrDefectList[intCount].Add("Top");// index 4
                        arrDefectList[intCount].Add("Bottom");// index 5
                        arrDefectList[intCount].Add("Unit");// index 6
                    }
                    // Stand Off variance
                    if ((m_arrFailResultMask[i] & 0x4000) > 0)
                    {
                        switch (i)
                        {
                            case 0:
                                intFailMask |= 0x10;
                                arrDefectList[intCount][0] = intFailMask.ToString();
                                fMeasure = m_fStandOffVarianceUnitResult * m_fMMToUnitValue;
                                if (fMeasure == -999)
                                    arrDefectList[intCount][6] = "---";
                                else
                                    arrDefectList[intCount][6] = fMeasure.ToString("F4");
                                break;
                            case 1:
                                intFailMask |= 0x04;
                                arrDefectList[intCount][0] = intFailMask.ToString();
                                fMeasure = m_fStandOffVarianceTopResult * m_fMMToUnitValue;
                                if (fMeasure == -999)
                                    arrDefectList[intCount][4] = "---";
                                else
                                    arrDefectList[intCount][4] = fMeasure.ToString("F4");
                                break;
                            case 2:
                                intFailMask |= 0x02;
                                arrDefectList[intCount][0] = intFailMask.ToString();
                                fMeasure = m_fStandOffVarianceRightResult * m_fMMToUnitValue;
                                if (fMeasure == -999)
                                    arrDefectList[intCount][3] = "---";
                                else
                                    arrDefectList[intCount][3] = fMeasure.ToString("F4");
                                break;
                            case 3:
                                intFailMask |= 0x08;
                                arrDefectList[intCount][0] = intFailMask.ToString();
                                fMeasure = m_fStandOffVarianceBottomResult * m_fMMToUnitValue;
                                if (fMeasure == -999)
                                    arrDefectList[intCount][5] = "---";
                                else
                                    arrDefectList[intCount][5] = fMeasure.ToString("F4");
                                break;
                            case 4:
                                intFailMask |= 0x01;
                                arrDefectList[intCount][0] = intFailMask.ToString();
                                fMeasure = m_fStandOffVarianceLeftResult * m_fMMToUnitValue;
                                if (fMeasure == -999)
                                    arrDefectList[intCount][2] = "---";
                                else
                                    arrDefectList[intCount][2] = fMeasure.ToString("F4");
                                break;
                        }
                    }
                    else
                    {
                        switch (i)
                        {
                            case 0:
                                fMeasure = m_fStandOffVarianceUnitResult * m_fMMToUnitValue;
                                if (fMeasure == -999)
                                    arrDefectList[intCount][6] = "---";
                                else
                                    arrDefectList[intCount][6] = fMeasure.ToString("F4");
                                break;
                            case 1:
                                fMeasure = m_fStandOffVarianceTopResult * m_fMMToUnitValue;
                                if (fMeasure == -999)
                                    arrDefectList[intCount][4] = "---";
                                else
                                    arrDefectList[intCount][4] = fMeasure.ToString("F4");
                                break;
                            case 2:
                                fMeasure = m_fStandOffVarianceRightResult * m_fMMToUnitValue;
                                if (fMeasure == -999)
                                    arrDefectList[intCount][3] = "---";
                                else
                                    arrDefectList[intCount][3] = fMeasure.ToString("F4");
                                break;
                            case 3:
                                fMeasure = m_fStandOffVarianceBottomResult * m_fMMToUnitValue;
                                if (fMeasure == -999)
                                    arrDefectList[intCount][5] = "---";
                                else
                                    arrDefectList[intCount][5] = fMeasure.ToString("F4");
                                break;
                            case 4:
                                fMeasure = m_fStandOffVarianceLeftResult * m_fMMToUnitValue;
                                if (fMeasure == -999)
                                    arrDefectList[intCount][2] = "---";
                                else
                                    arrDefectList[intCount][2] = fMeasure.ToString("F4");
                                break;
                        }
                    }
                }

                if (arrDefectList.Count > intCount)
                    intCount++;
            }

            intFailMask = 0;
            if ((m_intFailOptionMask & 0x04) > 0)
            {
                for (int i = 1; i < m_arrFailResultMask.Length; i++)
                {
                    if (arrDefectList.Count <= intCount)
                    {
                        arrDefectList.Add(new List<string>());
                        arrDefectList[intCount].Add(0x00.ToString());
                        arrDefectList[intCount].Add("Leads Sweep");
                        arrDefectList[intCount].Add("Left"); // index 2
                        arrDefectList[intCount].Add("Right");// index 3
                        arrDefectList[intCount].Add("Top");// index 4
                        arrDefectList[intCount].Add("Bottom");// index 5
                        arrDefectList[intCount].Add("Unit");// index 6
                    }
                    // Leads Sweep 
                    if ((m_arrFailResultMask[i] & 0x04) > 0)
                    {
                        switch (i)
                        {
                            case 1:
                                intFailMask |= 0x04;
                                arrDefectList[intCount][0] = intFailMask.ToString();
                                fMeasure = m_fLeadSweepVarianceTopResult * m_fMMToUnitValue;
                                if (fMeasure == -999)
                                    arrDefectList[intCount][4] = "---";
                                else
                                    arrDefectList[intCount][4] = fMeasure.ToString("F4");
                                break;
                            case 2:
                                intFailMask |= 0x02;
                                arrDefectList[intCount][0] = intFailMask.ToString();
                                fMeasure = m_fLeadSweepVarianceRightResult * m_fMMToUnitValue;
                                if (fMeasure == -999)
                                    arrDefectList[intCount][3] = "---";
                                else
                                    arrDefectList[intCount][3] = fMeasure.ToString("F4");
                                break;
                            case 3:
                                intFailMask |= 0x08;
                                arrDefectList[intCount][0] = intFailMask.ToString();
                                fMeasure = m_fLeadSweepVarianceBottomResult * m_fMMToUnitValue;
                                if (fMeasure == -999)
                                    arrDefectList[intCount][5] = "---";
                                else
                                    arrDefectList[intCount][5] = fMeasure.ToString("F4");
                                break;
                            case 4:
                                intFailMask |= 0x01;
                                arrDefectList[intCount][0] = intFailMask.ToString();
                                fMeasure = m_fLeadSweepVarianceLeftResult * m_fMMToUnitValue;
                                if (fMeasure == -999)
                                    arrDefectList[intCount][2] = "---";
                                else
                                    arrDefectList[intCount][2] = fMeasure.ToString("F4");
                                break;
                        }
                    }
                    else
                    {
                        switch (i)
                        {
                            case 1:
                                fMeasure = m_fLeadSweepVarianceTopResult * m_fMMToUnitValue;
                                if (fMeasure == -999)
                                    arrDefectList[intCount][4] = "---";
                                else
                                    arrDefectList[intCount][4] = fMeasure.ToString("F4");
                                break;
                            case 2:
                                fMeasure = m_fLeadSweepVarianceRightResult * m_fMMToUnitValue;
                                if (fMeasure == -999)
                                    arrDefectList[intCount][3] = "---";
                                else
                                    arrDefectList[intCount][3] = fMeasure.ToString("F4");
                                break;
                            case 3:
                                fMeasure = m_fLeadSweepVarianceBottomResult * m_fMMToUnitValue;
                                if (fMeasure == -999)
                                    arrDefectList[intCount][5] = "---";
                                else
                                    arrDefectList[intCount][5] = fMeasure.ToString("F4");
                                break;
                            case 4:
                                fMeasure = m_fLeadSweepVarianceLeftResult * m_fMMToUnitValue;
                                if (fMeasure == -999)
                                    arrDefectList[intCount][2] = "---";
                                else
                                    arrDefectList[intCount][2] = fMeasure.ToString("F4");
                                break;
                        }
                    }
                }

                if (arrDefectList.Count > intCount)
                    intCount++;
            }

            intFailMask = 0;
            if ((m_intFailOptionMask & 0x1000) > 0)
            {
                for (int i = 0; i < m_arrFailResultMask.Length; i++)
                {
                    // Span
                    if (arrDefectList.Count <= intCount)
                    {
                        arrDefectList.Add(new List<string>());
                        arrDefectList[intCount].Add(0x00.ToString());
                        arrDefectList[intCount].Add("Span");
                        arrDefectList[intCount].Add("Left"); // index 2
                        arrDefectList[intCount].Add("Right");// index 3
                        arrDefectList[intCount].Add("Top");// index 4
                        arrDefectList[intCount].Add("Bottom");// index 5
                        arrDefectList[intCount].Add("Unit");// index 6
                    }

                    if ((m_arrFailResultMask[i] & 0x1000) > 0)
                    {
                        switch (i)
                        {
                            case 0: // Overall
                                if (m_intLeadSpanMethod != 0)
                                {
                                    intFailMask |= 0x10;
                                    arrDefectList[intCount][0] = intFailMask.ToString();
                                    fMeasure = m_fSpanOverallResult * m_fMMToUnitValue;
                                    if (fMeasure == -999)
                                        arrDefectList[intCount][6] = "---";
                                    else
                                        arrDefectList[intCount][6] = fMeasure.ToString("F4");
                                }
                                break;
                            case 1: // Top
                                if (m_intLeadSpanMethod != 1)
                                {
                                    intFailMask |= 0x04;
                                    arrDefectList[intCount][0] = intFailMask.ToString();
                                    fMeasure = m_fSpanTopResult * m_fMMToUnitValue;
                                    if (fMeasure == -999)
                                        arrDefectList[intCount][4] = "---";
                                    else
                                        arrDefectList[intCount][4] = fMeasure.ToString("F4");
                                }
                                break;
                            case 2: // Right
                                if (m_intLeadSpanMethod != 1)
                                {
                                    intFailMask |= 0x02;
                                    arrDefectList[intCount][0] = intFailMask.ToString();
                                    fMeasure = m_fSpanRightResult * m_fMMToUnitValue;
                                    if (fMeasure == -999)
                                        arrDefectList[intCount][3] = "---";
                                    else
                                        arrDefectList[intCount][3] = fMeasure.ToString("F4");
                                }
                                break;
                            case 3: // Bottom
                                if (m_intLeadSpanMethod != 1)
                                {
                                    intFailMask |= 0x08;
                                    arrDefectList[intCount][0] = intFailMask.ToString();
                                    fMeasure = m_fSpanBottomResult * m_fMMToUnitValue;
                                    if (fMeasure == -999)
                                        arrDefectList[intCount][5] = "---";
                                    else
                                        arrDefectList[intCount][5] = fMeasure.ToString("F4");
                                }
                                break;
                            case 4: // Left
                                if (m_intLeadSpanMethod != 1)
                                {
                                    intFailMask |= 0x01;
                                    arrDefectList[intCount][0] = intFailMask.ToString();
                                    fMeasure = m_fSpanLeftResult * m_fMMToUnitValue;
                                    if (fMeasure == -999)
                                        arrDefectList[intCount][2] = "---";
                                    else
                                        arrDefectList[intCount][2] = fMeasure.ToString("F4");
                                }
                                break;
                        }
                    }
                    else
                    {
                        switch (i)
                        {
                            case 0: // Overall
                                if (m_intLeadSpanMethod != 0)
                                {
                                    fMeasure = m_fSpanOverallResult * m_fMMToUnitValue;
                                    if (fMeasure == -999)
                                        arrDefectList[intCount][6] = "---";
                                    else
                                        arrDefectList[intCount][6] = fMeasure.ToString("F4");
                                }
                                break;
                            case 1: // Top
                                if (m_intLeadSpanMethod != 1)
                                {
                                    fMeasure = m_fSpanTopResult * m_fMMToUnitValue;
                                    if (fMeasure == -999)
                                        arrDefectList[intCount][4] = "---";
                                    else
                                        arrDefectList[intCount][4] = fMeasure.ToString("F4");
                                }
                                break;
                            case 2: // Right
                                if (m_intLeadSpanMethod != 1)
                                {
                                    fMeasure = m_fSpanRightResult * m_fMMToUnitValue;
                                    if (fMeasure == -999)
                                        arrDefectList[intCount][3] = "---";
                                    else
                                        arrDefectList[intCount][3] = fMeasure.ToString("F4");
                                }
                                break;
                            case 3: // Bottom
                                if (m_intLeadSpanMethod != 1)
                                {
                                    fMeasure = m_fSpanBottomResult * m_fMMToUnitValue;
                                    if (fMeasure == -999)
                                        arrDefectList[intCount][5] = "---";
                                    else
                                        arrDefectList[intCount][5] = fMeasure.ToString("F4");
                                }
                                break;
                            case 4: // Left
                                if (m_intLeadSpanMethod != 1)
                                {
                                    fMeasure = m_fSpanLeftResult * m_fMMToUnitValue;
                                    if (fMeasure == -999)
                                        arrDefectList[intCount][2] = "---";
                                    else
                                        arrDefectList[intCount][2] = fMeasure.ToString("F4");
                                }
                                break;
                        }
                    }
                }

                if (arrDefectList.Count > intCount)
                    intCount++;
            }
            return arrDefectList;
        }
        public List<List<string>> GetExtraDefectList()
        {
            List<List<string>> arrDefectList = new List<List<string>>();

            int intCount = 0;

            //Join, extra, contamination
            for (int i = 0; i < m_arrExtraBlobs.Count; i++)
            {
                //if (m_arrExtraBlobs[i].ref_intFailCriteria != 0)
                {
                    arrDefectList.Add(new List<string>());
                    arrDefectList[intCount].Add(m_arrExtraBlobs[i].ref_intFailCriteria.ToString());
                    if (m_arrExtraBlobs[i].ref_fWidthFailValue == -999 && m_arrExtraBlobs[i].ref_fHeightFailValue == -999)
                        arrDefectList[intCount].Add("Total Cont.");
                    else
                        arrDefectList[intCount].Add("Contamination"); //arrDefectList[intCount].Add("Contamination");

                    if (m_arrExtraBlobs[i].ref_fWidthFailValue == 0)
                        arrDefectList[intCount].Add((-999).ToString("F4"));
                    else
                        arrDefectList[intCount].Add(m_arrExtraBlobs[i].ref_fWidthFailValue.ToString("F4"));

                    if (m_arrExtraBlobs[i].ref_fHeightFailValue == 0)
                        arrDefectList[intCount].Add((-999).ToString("F4"));
                    else
                        arrDefectList[intCount].Add(m_arrExtraBlobs[i].ref_fHeightFailValue.ToString("F4"));

                    arrDefectList[intCount].Add(m_arrExtraBlobs[i].ref_fAreaFailValue.ToString("F6"));
                    intCount++;
                }
            }

            return arrDefectList;
        }

        public void SetCenterBlobsFailMaskToSideSampleBlobs(List<int> arrID, List<int> arrFailMask)
        {
            for (int i = 0; i < m_arrSampleBlobLeads.Length; i++)
            {
                m_stcSampleBlobLead = (SampleBlobsFeatures)m_arrSampleBlobLeads[i];

                for (int j = 0; j < arrID.Count; j++)
                {
                    if (arrID[j] == m_stcSampleBlobLead.intNoID)
                    {
                        m_stcSampleBlobLead.intFailMask = arrFailMask[j];
                        m_arrSampleBlobLeads[i] = m_stcSampleBlobLead;
                        break;
                    }
                }
            }
        }

        public void GetCenterSampleLeadData(ref List<int> arrLeadID, ref List<int> arrFailMask)
        {
            arrFailMask.Clear();
            arrLeadID.Clear();

            for (int i = 0; i < m_arrSampleBlobLeads.Length; i++)
            {
                arrLeadID.Add(m_arrSampleBlobLeads[i].intNoID);
                arrFailMask.Add(m_arrSampleBlobLeads[i].intFailMask);
            }
        }

        public int GetLeadFailDirection(int intMatchTemplateIndex)
        {
            if (m_arrSampleBlobLeads == null || intMatchTemplateIndex >= m_arrSampleBlobLeads.Length)
                return 0;

            BlobsFeatures stcBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobLeads[intMatchTemplateIndex];

            if (((m_intFailOptionMask & 0x10) > 0) || ((m_intFailOptionMask & 0x20) > 0))
                return stcBlobsFeatures.intDirection;

            return 0;
        }

        public List<int> GetLeadDirection(int intMatchTemplateIndex)
        {
            List<int> arrBlobID = new List<int>();
            if (m_arrTemplateBlobLeads == null || (intMatchTemplateIndex - 1) >= m_arrTemplateBlobLeads.Count)
                return arrBlobID;

            BlobsFeatures stcBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobLeads[intMatchTemplateIndex - 1];
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                BlobsFeatures stcBlobsFeatures2 = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                if (stcBlobsFeatures.intDirection == stcBlobsFeatures2.intDirection)
                {
                    arrBlobID.Add(stcBlobsFeatures2.intNoID);
                }
            }

            return arrBlobID;

        }

        public int GetLeadPitchFailDirection(int intMatchTemplateIndex)
        {
            if (m_arrSampleBlobLeads == null || intMatchTemplateIndex >= m_arrSampleBlobLeads.Length)
                return 0;

            bool blnFound = false;
            for (int i = 0; i < m_arrPitchGap.Count; i++)
            {
                if (m_arrPitchGap[i].intFromLeadNo == intMatchTemplateIndex)
                {
                    blnFound = true;
                }
            }

            if (!blnFound)
                return 0;

            BlobsFeatures stcBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobLeads[intMatchTemplateIndex];
            if (m_arrSampleBlobLeads[intMatchTemplateIndex].fPitch == -999)
                return stcBlobsFeatures.intDirection;

            return 0;
        }

        public bool CheckPositionUsingCenterPoint()
        {
            if ((Math.Abs(m_fCenterUnitAngle) > m_fAngleTolerance) ||
                (Math.Abs(m_pCornerPoint_Center.X - m_fTemplateCornerPoint_CenterX) > Get2DXinPixel(m_fXTolerance)) ||
                (Math.Abs(m_pCornerPoint_Center.Y - m_fTemplateCornerPoint_CenterY) > Get2DYinPixel(m_fYTolerance)))
            {
                m_blnFailPosition = true;
                return false;
            }
            return true;
        }

        public bool CheckPositionUsingCenterPoint_PatternMatch()
        {
            if (m_objMatcher.NumPositions > 0)
            {
                float Angle = m_objMatcher.GetPosition(0).Angle;
                float CenterX = m_objMatcher.GetPosition(0).CenterX;
                float CenterY = m_objMatcher.GetPosition(0).CenterY;
                if ((Math.Abs(m_objMatcher.GetPosition(0).Angle) > m_fAngleTolerance) ||
                (Math.Abs(m_objMatcher.GetPosition(0).CenterX - m_fTemplateMatcher_CenterX) > Get2DXinPixel(m_fXTolerance)) ||
                (Math.Abs(m_objMatcher.GetPosition(0).CenterY - m_fTemplateMatcher_CenterY) > Get2DYinPixel(m_fYTolerance)))
                {
                    m_blnFailPosition = true;
                    return false;
                }
            }
            return true;
        }

        public void GetPositionResult(ref float Angle, ref float XTolerance, ref float YTolerance)
        {
            Angle = Math.Abs(m_fCenterUnitAngle);
            XTolerance = Math.Abs(m_pCornerPoint_Center.X - m_fTemplateCornerPoint_CenterX);
            YTolerance = Math.Abs(m_pCornerPoint_Center.Y - m_fTemplateCornerPoint_CenterY);
        }

        public void GetPositionResult_PatternMatch(ref float Angle, ref float XTolerance, ref float YTolerance)
        {
            if (m_objMatcher.NumPositions > 0)
            {
                Angle = m_objMatcher.GetPosition(0).Angle;
                if ((m_objMatcher.GetPosition(0).CenterX - m_fTemplateMatcher_CenterX) > 0)
                    XTolerance = Get2DXinMM(Math.Abs(m_objMatcher.GetPosition(0).CenterX - m_fTemplateMatcher_CenterX));
                else
                    XTolerance = -Get2DXinMM(Math.Abs(m_objMatcher.GetPosition(0).CenterX - m_fTemplateMatcher_CenterX));

                if ((m_objMatcher.GetPosition(0).CenterY - m_fTemplateMatcher_CenterY) > 0)
                    YTolerance = Get2DYinMM(Math.Abs(m_objMatcher.GetPosition(0).CenterY - m_fTemplateMatcher_CenterY));
                else
                    YTolerance = -Get2DYinMM(Math.Abs(m_objMatcher.GetPosition(0).CenterY - m_fTemplateMatcher_CenterY));
            }
            else
            {
                Angle = 0;
                XTolerance = 0;
                YTolerance = 0;
            }
        }

        public bool MatchWithTemplateUnitPR(ROI objSearchROI)
        {
            if (!m_objMatcher.PatternLearnt)
                return false;
            m_objMatcher.MinAngle = -10;
            m_objMatcher.MaxAngle = 10;
            #region (DEBUG)
            //m_objUnitPRMatcher.Save("D:\\TS\\UnitPRMatcher.mch");
            //objSearchROI.ref_ROI.Save("D:\\TS\\objSearchROI.bmp");
            #endregion
            m_objMatcher.Match(objSearchROI.ref_ROI);

            if (m_objMatcher.NumPositions > 0 && m_objMatcher.GetPosition(0).Score > 0.25)     // if macthing result hit the min score, its position will be 1 or more
            {
                return true;
            }
            m_blnPatternMatchSuccess = false;
            return false;
        }

        public bool IsUnitPRPass()
        {
            if (m_objMatcher.NumPositions > 0)     // if macthing result hit the min score, its position will be 1 or more
            {
                return true;
            }
            else
                return false;
        }


        public float GetUnitPRResultAngle()
        {
            if (m_objMatcher.NumPositions > 0)     // if macthing result hit the min score, its position will be 1 or more
            {
                return m_objMatcher.GetPosition(0).Angle;
            }
            else
                return 0;
        }

        public float GetUnitPRResultCenterX()
        {
            if (m_objMatcher.NumPositions > 0)     // if macthing result hit the min score, its position will be 1 or more
            {
                return m_objMatcher.GetPosition(0).CenterX;
            }
            else
                return 0;
        }

        public float GetUnitPRResultCenterY()
        {
            if (m_objMatcher.NumPositions > 0)     // if macthing result hit the min score, its position will be 1 or more
            {
                return m_objMatcher.GetPosition(0).CenterY;
            }
            else
                return 0;
        }

        public int GetUnitPRWidth()
        {
            if (!m_objMatcher.PatternLearnt)
                return 0;

            return m_objMatcher.PatternWidth;
        }

        public int GetUnitPRHeight()
        {
            if (!m_objMatcher.PatternLearnt)
                return 0;

            return m_objMatcher.PatternHeight;
        }

        public void Dispose()
        {
            if (m_objMatcher != null)
                m_objMatcher.Dispose();
        }

        public void SetTemplateMatcherCenterPoint(ROI objROI)
        {
            if (m_objMatcher.NumPositions > 0)
            {
                m_fTemplateMatcher_CenterX = m_objMatcher.GetPosition(0).CenterX;
                m_fTemplateMatcher_CenterY = m_objMatcher.GetPosition(0).CenterY;
            }
            else
            {
                m_fTemplateMatcher_CenterX = objROI.ref_ROITotalCenterX - objROI.ref_ROITotalX;
                m_fTemplateMatcher_CenterY = objROI.ref_ROITotalCenterY - objROI.ref_ROITotalY;
            }

        }

        public string GetLeadFailResultMask()
        {
            for (int i = 0; i < m_arrSampleBlobLeads.Length; i++)
            {
                if ((m_arrSampleBlobLeads[i].intFailMask & 0x10) > 0)
                {
                    return "FailUnCutTiebar";
                }

                if ((m_arrSampleBlobLeads[i].intFailMask & 0x20000) > 0)
                {
                    return "FailOffset";
                }

                if ((m_arrSampleBlobLeads[i].intFailMask & 0x100) > 0)
                {
                    return "FailSkew";
                }

                if ((m_arrSampleBlobLeads[i].intFailMask & 0x40) > 0)
                {
                    return "FailWidth";
                }

                if ((m_arrSampleBlobLeads[i].intFailMask & 0x400000) > 0)
                {
                    return "FailWidth";
                }

                if ((m_arrSampleBlobLeads[i].intFailMask & 0x80) > 0)
                {
                    return "FailLength";
                }

                if ((m_arrSampleBlobLeads[i].intFailMask & 0x01) > 0)
                {
                    return "FailStandOff";
                }

                if ((m_arrSampleBlobLeads[i].intFailMask & 0x02) > 0)
                {
                    return "FailCoplan";
                }

                if ((m_arrSampleBlobLeads[i].intFailMask & 0x40000) > 0)
                {
                    return "FailAGV";
                }

                if ((m_arrSampleBlobLeads[i].intFailMask & 0x20) > 0)
                {
                    return "FailMissing";
                }

            }

            for (int y = 0; y < m_arrPitchGap.Count; y++)
            {
                if (((m_arrPitchGap[y].intFailMask & 0x200) > 0) || ((m_arrPitchGap[y].intFailMask & 0x400) > 0))
                {
                    return "FailPitchGap";
                }

            }

            for (int i = 0; i < m_arrFailResultMask.Length; i++)
            {
                if ((m_arrFailResultMask[i] & 0x2000) > 0)
                {
                    return "FailPitchVariance";
                }

                if ((m_arrFailResultMask[i] & 0x800) > 0)
                {
                    return "FailLengthVariance";
                }

                if ((m_arrFailResultMask[i] & 0x4000) > 0)
                {
                    return "FailStandOffVariance";
                }

                if ((m_arrFailResultMask[i] & 0x04) > 0)
                {
                    return "FailSweeps";
                }

                if ((m_arrFailResultMask[i] & 0x1000) > 0)
                {
                    return "FailSpan";
                }

                if ((m_arrFailResultMask[i] & 0x8000) > 0 || (m_arrFailResultMask[i] & 0x10000) > 0) // if ((m_arrFailResultMask[i] & 0x01) > 0 || (m_arrFailResultMask[i] & 0x1000) > 0)
                {
                    return "FailContamination";
                }
            }

            return "FailLead";
        }

        public bool GetWantInspectPackage()
        {
            return m_blnInspectPackage;
        }
        public void SetWantInspectPackage(bool bWantDefect)
        {
            m_blnInspectPackage = bWantDefect;
        }

        /// <summary>
        /// Set grab image index
        /// </summary>
        /// <param name="intArrayIndex">Index which represent different defect inspection. 0: Package Size, 1: Pkg Defect Bright Field, 2: Pkg Defect Dark Field </param>
        /// <param name="intGrabImageIndex">Select which image view no use to inspection</param>
        public void SetGrabImageIndex(int intArrayIndex, int intGrabImageIndex)
        {
            //m_arrGrabImageIndex.RemoveRange(0, m_arrGrabImageIndex.Count);
            if (intArrayIndex >= m_arrGrabImageIndex.Count)
            {
                for (int i = m_arrGrabImageIndex.Count; i <= intArrayIndex; i++)
                {
                    m_arrGrabImageIndex.Add(0);
                }
            }

            m_arrGrabImageIndex[intArrayIndex] = intGrabImageIndex;

        }

        /// <summary>
        /// Get grab image index 
        /// </summary>
        /// <param name="intArrayIndex">Index which represent different defect inspection. // 0: Pkg Size, 1: Pkg Defect Bright Field, 2: Pkg Defect Dark Field </param>
        /// <returns></returns>
        public int GetGrabImageIndex(int intArrayIndex)
        {
            // 0: Pkg Size, 1: Pkg Defect Bright Field, 2: Pkg Defect Dark Field

            if (intArrayIndex >= m_arrGrabImageIndex.Count)
                return 0;

            return m_arrGrabImageIndex[intArrayIndex];
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="intValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        /// <returns></returns>
        public float GetUnitWidthMin(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return Get2DXinPixel(m_fUnitWidthMin);//* m_fMMToPixelXValue
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fUnitWidthMin * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="fValue"></param>
        /// <param name="intFromValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        public void SetUnitWidthMin(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                case 0: // Pixel
                    m_fUnitWidthMin = Get2DXinPixel(fValue);//m_fMMToPixelXValue
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fUnitWidthMin = fValue / m_fMMToUnitValue;
                    break;
            }
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="intValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        /// <returns></returns>
        public float GetUnitWidthMax(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return Get2DXinPixel(m_fUnitWidthMax);//* m_fMMToPixelXValue
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fUnitWidthMax * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="fValue"></param>
        /// <param name="intFromValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        public void SetUnitWidthMax(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                case 0: // Pixel
                    m_fUnitWidthMax = Get2DXinPixel(fValue);//m_fMMToPixelXValue
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fUnitWidthMax = fValue / m_fMMToUnitValue;
                    break;
            }
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="intValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        /// <returns></returns>
        public float GetUnitHeightMin(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return Get2DYinPixel(m_fUnitHeightMin);//* m_fMMToPixelYValue
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fUnitHeightMin * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="fValue"></param>
        /// <param name="intFromValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        public void SetUnitHeightMin(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                case 0: // Pixel
                    m_fUnitHeightMin = Get2DYinPixel(fValue);//m_fMMToPixelYValue
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fUnitHeightMin = fValue / m_fMMToUnitValue;
                    break;
            }
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="intValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        /// <returns></returns>
        public float GetUnitHeightMax(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return Get2DYinPixel(m_fUnitHeightMax);//* m_fMMToPixelYValue
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fUnitHeightMax * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="fValue"></param>
        /// <param name="intFromValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        public void SetUnitHeightMax(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                case 0: // Pixel
                    m_fUnitHeightMax = Get2DYinPixel(fValue);// m_fMMToPixelYValue
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fUnitHeightMax = fValue / m_fMMToUnitValue;
                    break;
            }
        }
        public float GetBrightLengthLimit(int intValueType)
        {
            switch (intValueType)
            {
                case -1: // Pixel X
                    return Get2DXinPixel(m_fBrightLength);// * m_fMMToPixelXValue;
                case -2: // Pixel Y
                    return Get2DYinPixel(m_fBrightLength);// * m_fMMToPixelYValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fBrightLength * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }

        public float GetBrightWidthLimit(int intValueType)
        {
            switch (intValueType)
            {
                case -1: // Pixel X
                    return Get2DXinPixel(m_fBrightWidth);// * m_fMMToPixelXValue;
                case -2: // Pixel Y
                    return Get2DYinPixel(m_fBrightWidth);// * m_fMMToPixelYValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fBrightWidth * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }

        public float GetDarkLengthLimit(int intValueType)
        {
            switch (intValueType)
            {
                case -1: // Pixel X
                    return Get2DXinPixel(m_fDarkLength);// * m_fMMToPixelXValue;
                case -2: // Pixel Y
                    return Get2DYinPixel(m_fDarkLength);// * m_fMMToPixelYValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fDarkLength * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }
        public float GetDarkWidthLimit(int intValueType)
        {
            switch (intValueType)
            {
                case -1: // Pixel X
                    return Get2DXinPixel(m_fDarkWidth);// * m_fMMToPixelXValue;
                case -2: // Pixel Y
                    return Get2DYinPixel(m_fDarkWidth);// * m_fMMToPixelYValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fDarkWidth * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }

        public float GetBrightAreaLimit(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_fBrightArea * m_fMMtoPixelAreaValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fBrightArea * m_fMMToUnitValueArea;
                default:
                    return 0;
            }
        }

        public float GetBrightTotalAreaLimit(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_fBrightTotalArea * m_fMMtoPixelAreaValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fBrightTotalArea * m_fMMToUnitValueArea;
                default:
                    return 0;
            }
        }

        public float GetDarkAreaLimit(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_fDarkArea * m_fMMtoPixelAreaValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fDarkArea * m_fMMToUnitValueArea;
                default:
                    return 0;
            }
        }

        public float GetDarkTotalAreaLimit(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_fDarkTotalArea * m_fMMtoPixelAreaValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fDarkTotalArea * m_fMMToUnitValueArea;
                default:
                    return 0;
            }
        }

        public float GetBrightChippedOffAreaLimit(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_fBrightChippedOffArea * m_fMMtoPixelAreaValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fBrightChippedOffArea * m_fMMToUnitValueArea;
                default:
                    return 0;
            }
        }
        public float GetDarkChippedOffAreaLimit(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_fDarkChippedOffArea * m_fMMtoPixelAreaValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fDarkChippedOffArea * m_fMMToUnitValueArea;
                default:
                    return 0;
            }
        }
        public float GetDarkVerticalCrackLimit(int intValueType)
        {
            switch (intValueType)
            {
                case -1: // Pixel X
                    return Get2DXinPixel(m_fDarkVerticalCrack);// * m_fMMToPixelXValue;
                case -2: // Pixel Y
                    return Get2DYinPixel(m_fDarkVerticalCrack);// * m_fMMToPixelYValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fDarkVerticalCrack * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }

        public float GetDarkHorizontalCrackLimit(int intValueType)
        {
            switch (intValueType)
            {
                case -1: // Pixel X
                    return Get2DXinPixel(m_fDarkHorizontalCrack);// * m_fMMToPixelXValue;
                case -2: // Pixel Y
                    return Get2DYinPixel(m_fDarkHorizontalCrack);// * m_fMMToPixelYValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fDarkHorizontalCrack * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }

        public void SetBrightLengthLimit(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                //case 0: // Pixel X
                //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                //    break;
                //case 1: // Pixel Y
                //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                //    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fBrightLength = fValue / m_fMMToUnitValue;
                    break;
            }
        }

        public void SetBrightWidthLimit(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                //case 0: // Pixel X
                //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                //    break;
                //case 1: // Pixel Y
                //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                //    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fBrightWidth = fValue / m_fMMToUnitValue;
                    break;
            }
        }

        public void SetBrightAreaLimit(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                //case 0: // Pixel X
                //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                //    break;
                //case 1: // Pixel Y
                //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                //    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fBrightArea = fValue / m_fMMToUnitValueArea;
                    break;
            }
        }

        public void SetBrightTotalAreaLimit(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                //case 0: // Pixel X
                //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                //    break;
                //case 1: // Pixel Y
                //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                //    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fBrightTotalArea = fValue / m_fMMToUnitValueArea;
                    break;
            }
        }

        public void SetDarkLengthLimit(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                //case 0: // Pixel X
                //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                //    break;
                //case 1: // Pixel Y
                //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                //    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fDarkLength = fValue / m_fMMToUnitValue;
                    break;
            }
        }

        public void SetDarkWidthLimit(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                //case 0: // Pixel X
                //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                //    break;
                //case 1: // Pixel Y
                //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                //    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fDarkWidth = fValue / m_fMMToUnitValue;
                    break;
            }
        }

        public void SetDarkAreaLimit(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                //case 0: // Pixel X
                //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                //    break;
                //case 1: // Pixel Y
                //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                //    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fDarkArea = fValue / m_fMMToUnitValueArea;
                    break;
            }
        }

        public void SetDarkTotalAreaLimit(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                //case 0: // Pixel X
                //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                //    break;
                //case 1: // Pixel Y
                //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                //    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fDarkTotalArea = fValue / m_fMMToUnitValueArea;
                    break;
            }
        }

        public void SetBrightChippedOffAreaLimit(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                //case 0: // Pixel X
                //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                //    break;
                //case 1: // Pixel Y
                //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                //    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fBrightChippedOffArea = fValue / m_fMMToUnitValueArea;
                    break;
            }
        }

        public void SetDarkChippedOffAreaLimit(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                //case 0: // Pixel X
                //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                //    break;
                //case 1: // Pixel Y
                //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                //    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fDarkChippedOffArea = fValue / m_fMMToUnitValueArea;
                    break;
            }
        }
        public void SetDarkVerticalCrackLimit(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                //case 0: // Pixel X
                //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                //    break;
                //case 1: // Pixel Y
                //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                //    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fDarkVerticalCrack = fValue / m_fMMToUnitValue;
                    break;
            }
        }
        public void SetDarkHorizontalCrackLimit(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                //case 0: // Pixel X
                //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                //    break;
                //case 1: // Pixel Y
                //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                //    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fDarkHorizontalCrack = fValue / m_fMMToUnitValue;
                    break;
            }
        }
        public float GetCrackAreaLimit(int intValueType)
        {
            switch (intValueType)
            {
                case -1: // Pixel X
                    return m_fCrackArea * m_fMMtoPixelAreaValue;
                case -2: // Pixel Y
                    return m_fCrackArea * m_fMMtoPixelAreaValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fCrackArea * m_fMMToUnitValueArea;
                default:
                    return 0;
            }
        }

        public void SetCrackAreaLimit(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                //case 0: // Pixel X
                //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                //    break;
                //case 1: // Pixel Y
                //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                //    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fCrackArea = fValue / m_fMMToUnitValueArea;
                    break;
            }
        }
        public void SetMoldFlashAreaLimit(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                //case 0: // Pixel X
                //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                //    break;
                //case 1: // Pixel Y
                //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                //    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fMoldFlashArea = fValue / m_fMMToUnitValueArea;
                    break;
            }
        }
        public float GetMoldFlashAreaLimit(int intValueType)
        {
            switch (intValueType)
            {
                case -1: // Pixel X
                    return m_fMoldFlashArea * m_fMMtoPixelAreaValue;
                case -2: // Pixel Y
                    return m_fMoldFlashArea * m_fMMtoPixelAreaValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fMoldFlashArea * m_fMMToUnitValueArea;
                default:
                    return 0;
            }
        }
        public string GetPackageFailTestDisplayResult(string strPosition)
        {
            string strErrorMessage = "";
            bool blnTotalContaminationFail = false;
            for (int i = 0; i < m_arrPkgDefectList.Count; i++)
            {
                // Chip off
                if ((m_arrPkgDefectList[i].ref_intFailMask & 0x04) > 0)
                {
                    //if (m_blnUseDetailDefectCriteria)
                    //    strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " chipped off. Set=" + m_fChipArea +
                    //        "mm^2, Result=" + (m_arrPkgDefectList[i].ref_fFailValue * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2) + "mm^2.";
                    //else
                    //{
                    if (m_arrPkgDefectList[i].ref_intImageNo == 1)
                        strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " chipped off. Set=" + m_fBrightChippedOffArea +
                    "mm^2, Result=" + (m_arrPkgDefectList[i].ref_fFailValue * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2) + "mm^2.";
                    else
                        strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " chipped off. Set=" + m_fDarkChippedOffArea +
               "mm^2, Result=" + (m_arrPkgDefectList[i].ref_fFailValue * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2) + "mm^2.";
                    //}
                }

                //// Scratches
                //if ((m_arrPkgDefectList[i].ref_intFailMask & 0x08) > 0)
                //{
                //    if ((m_arrPkgDefectList[i].ref_intFailCriteria & 0x01) > 0)
                //    {
                //        strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " package scratch width. Set=" + GetScratchLengthLimit(1) +
                //            "mm, Result=" + (m_arrPkgDefectList[i].ref_fWidthFailValue * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "mm.";
                //    }

                //    if ((m_arrPkgDefectList[i].ref_intFailCriteria & 0x02) > 0)
                //    {
                //        strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " package scratch height. Set=" + GetScratchLengthLimit(1) +
                //            "mm, Result=" + (m_arrPkgDefectList[i].ref_fHeightFailValue * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "mm.";
                //    }

                //    if ((m_arrPkgDefectList[i].ref_intFailCriteria & 0x04) > 0)
                //    {
                //        strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " package scratch area. Set=" + GetScratchAreaLimit(1) +
                //            "mm^2, Result=" + (m_arrPkgDefectList[i].ref_fAreaFailValue * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2) + "mm^2.";
                //    }
                //}

                //// Contamination
                //if ((m_arrPkgDefectList[i].ref_intFailMask & 0x10) > 0)
                //{
                //    if ((m_arrPkgDefectList[i].ref_intFailCriteria & 0x01) > 0)
                //    {
                //        strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " package contamination width. Set=" + GetExtraPadLengthLimit(1) +
                //            "mm, Result=" + (m_arrPkgDefectList[i].ref_fWidthFailValue * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "mm.";
                //    }

                //    if ((m_arrPkgDefectList[i].ref_intFailCriteria & 0x02) > 0)
                //    {
                //        strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " package contamination height. Set=" + GetExtraPadLengthLimit(1) +
                //            "mm, Result=" + (m_arrPkgDefectList[i].ref_fHeightFailValue * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "mm.";
                //    }

                //    if ((m_arrPkgDefectList[i].ref_intFailCriteria & 0x04) > 0)
                //    {
                //        strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " package contamination area. Set=" + GetExtraPadMinArea(1) +
                //            "mm^2, Result=" + (m_arrPkgDefectList[i].ref_fAreaFailValue * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2) + "mm^2.";
                //    }
                //}

                if ((m_arrPkgDefectList[i].ref_intFailMask & 0x10000) > 0)
                {
                    if ((m_arrPkgDefectList[i].ref_intFailCriteria & 0x01) > 0)
                    {
                        strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " package bright width fail. Set=" + GetBrightWidthLimit(1) +
                            "mm, Result=" + (m_arrPkgDefectList[i].ref_fWidthFailValue * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "mm.";
                    }

                    if ((m_arrPkgDefectList[i].ref_intFailCriteria & 0x02) > 0)
                    {
                        strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " package bright length fail. Set=" + GetBrightLengthLimit(1) +
                            "mm, Result=" + (m_arrPkgDefectList[i].ref_fHeightFailValue * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "mm.";
                    }

                    if ((m_arrPkgDefectList[i].ref_intFailCriteria & 0x04) > 0)
                    {
                        strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " package bright area fail. Set=" + GetBrightAreaLimit(1) +
                            "mm^2, Result=" + (m_arrPkgDefectList[i].ref_fAreaFailValue * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2) + "mm^2.";
                    }

                    if ((m_arrPkgDefectList[i].ref_intFailCriteria & 0x08) > 0)
                    {
                        strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " package bright total area fail. Set=" + GetBrightTotalAreaLimit(1) +
                            "mm^2, Result=" + (m_arrPkgDefectList[i].ref_fAreaFailValue * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2) + "mm^2.";
                    }

                }

                if ((m_arrPkgDefectList[i].ref_intFailMask & 0x20000) > 0)
                {
                    if ((m_arrPkgDefectList[i].ref_intFailCriteria & 0x01) > 0)
                    {
                        strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " package dark width fail. Set=" + GetDarkWidthLimit(1) +
                            "mm, Result=" + (m_arrPkgDefectList[i].ref_fWidthFailValue * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "mm.";
                    }

                    if ((m_arrPkgDefectList[i].ref_intFailCriteria & 0x02) > 0)
                    {
                        strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " package dark length fail. Set=" + GetDarkLengthLimit(1) +
                            "mm, Result=" + (m_arrPkgDefectList[i].ref_fHeightFailValue * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "mm.";
                    }

                    if ((m_arrPkgDefectList[i].ref_intFailCriteria & 0x04) > 0)
                    {
                        strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " package dark area fail. Set=" + GetDarkAreaLimit(1) +
                            "mm^2, Result=" + (m_arrPkgDefectList[i].ref_fAreaFailValue * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2) + "mm^2.";
                    }

                    if ((m_arrPkgDefectList[i].ref_intFailCriteria & 0x08) > 0)
                    {
                        strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " package dark total area fail. Set=" + GetDarkTotalAreaLimit(1) +
                            "mm^2, Result=" + (m_arrPkgDefectList[i].ref_fAreaFailValue * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2) + "mm^2.";
                    }

                }

                //// Total Contamination
                //if ((m_arrPkgDefectList[i].ref_intFailMask & 0x40) > 0)
                //{

                //}

                // Mold Flash
                if ((m_arrPkgDefectList[i].ref_intFailMask & 0x80) > 0)
                {
                    strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " Mold Flash. Set=" + m_fMoldFlashArea +
                             "mm^2, Result=" + (m_arrPkgDefectList[i].ref_fFailValue * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2) + "mm^2.";
                }

                //// Void
                //if ((m_arrPkgDefectList[i].ref_intFailMask & 0x100) > 0)
                //{
                //    if ((m_arrPkgDefectList[i].ref_intFailCriteria & 0x01) > 0)
                //    {
                //        strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " package void width. Set=" + GetVoidLengthLimit(1) +
                //            "mm, Result=" + (m_arrPkgDefectList[i].ref_fWidthFailValue * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "mm.";
                //    }

                //    if ((m_arrPkgDefectList[i].ref_intFailCriteria & 0x02) > 0)
                //    {
                //        strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " package void height. Set=" + GetVoidLengthLimit(1) +
                //            "mm, Result=" + (m_arrPkgDefectList[i].ref_fHeightFailValue * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "mm.";
                //    }

                //    if ((m_arrPkgDefectList[i].ref_intFailCriteria & 0x04) > 0)
                //    {
                //        strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " package void area. Set=" + GetVoidAreaLimit(1) +
                //            "mm^2, Result=" + (m_arrPkgDefectList[i].ref_fAreaFailValue * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2) + "mm^2.";
                //    }

                //}

                // Crack
                if ((m_arrPkgDefectList[i].ref_intFailMask & 0x400) > 0)
                {
                    //            if (m_blnUseDetailDefectCriteria)
                    //            {
                    //                if ((m_arrPkgDefectList[i].ref_intFailCriteria & 0x01) > 0)
                    //                {
                    //                    // 2019 05 16 - CCENG: Display "crack length" not crack width or height since the Setting display Crack Length also.
                    //                    //strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " package crack width. Set=" + GetCrackLengthLimit(1) +
                    //                    //    "mm, Result=" + (m_arrPkgDefectList[i].ref_fWidthFailValue * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "mm.";
                    //                    strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " package crack length. Set=" + GetCrackLengthLimit(1) +
                    //                        "mm, Result=" + (m_arrPkgDefectList[i].ref_fWidthFailValue * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "mm.";
                    //                }

                    //                if ((m_arrPkgDefectList[i].ref_intFailCriteria & 0x02) > 0)
                    //                {
                    //                    // 2019 05 16 - CCENG: Display "crack length" not crack width or height since the Setting display Crack Length also.
                    //                    //strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " package crack height. Set=" + GetCrackLengthLimit(1) +
                    //                    //    "mm, Result=" + (m_arrPkgDefectList[i].ref_fHeightFailValue * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "mm.";
                    //                    strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " package crack length. Set=" + GetCrackLengthLimit(1) +
                    //"mm, Result=" + (m_arrPkgDefectList[i].ref_fHeightFailValue * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "mm.";
                    //                }
                    //            }
                    //            else
                    //            {
                    if ((m_arrPkgDefectList[i].ref_intFailCriteria & 0x01) > 0)
                    {
                        // 2019 05 16 - CCENG: Display "crack length" not crack width or height since the Setting display Crack Length also.
                        //strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " package crack width. Set=" + GetCrackLengthLimit(1) +
                        //    "mm, Result=" + (m_arrPkgDefectList[i].ref_fWidthFailValue * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "mm.";
                        strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " package crack width. Set=" + GetDarkHorizontalCrackLimit(1) +
                            "mm, Result=" + (m_arrPkgDefectList[i].ref_fWidthFailValue * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "mm.";
                    }

                    if ((m_arrPkgDefectList[i].ref_intFailCriteria & 0x02) > 0)
                    {
                        // 2019 05 16 - CCENG: Display "crack length" not crack width or height since the Setting display Crack Length also.
                        //strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " package crack height. Set=" + GetCrackLengthLimit(1) +
                        //    "mm, Result=" + (m_arrPkgDefectList[i].ref_fHeightFailValue * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "mm.";
                        strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " package crack length. Set=" + GetDarkVerticalCrackLimit(1) +
    "mm, Result=" + (m_arrPkgDefectList[i].ref_fHeightFailValue * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "mm.";
                    }
                    //}

                    if ((m_arrPkgDefectList[i].ref_intFailCriteria & 0x04) > 0)
                    {
                        strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " package crack area. Set=" + GetCrackAreaLimit(1) +
                            "mm^2, Result=" + (m_arrPkgDefectList[i].ref_fAreaFailValue * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2) + "mm^2.";
                    }
                }
            }

            //// Total Area Contamination
            //if (m_fResultTotalExtraPadArea > 0)
            //{
            //    strErrorMessage += "*Image 1 package contamination total area. Set=" + GetTotalExtraPadMinArea(1) +
            //        "mm^2, Result=" + (m_fResultTotalExtraPadArea * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2) + "mm^2.";

            //}

            //if (m_fResultBrightFieldTotalArea > 0)
            //{
            //    strErrorMessage += "*Image 1 package bright total area fail. Set=" + GetBrightTotalAreaLimit(1) +
            //        "mm^2, Result=" + (m_fResultBrightFieldTotalArea * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2) + "mm^2.";

            //}

            //if (m_fResultDarkFieldTotalArea > 0)
            //{
            //    strErrorMessage += "*Image 1 package dark total area fail. Set=" + GetDarkTotalAreaLimit(1) +
            //        "mm^2, Result=" + (m_fResultDarkFieldTotalArea * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2) + "mm^2.";

            //}

            if (strErrorMessage == "")
                strErrorMessage = m_strErrorMessage;
            return strErrorMessage;
        }
        private void FillChipLineLimitToCorner_4Edges(ImageDrawing objImage, int intChippedOffToleranceX, int intChippedOffToleranceY, int intChippedOffToleranceX2, int intChippedOffToleranceY2, int intChipLineLimitPixelValue)
        {
            if (objImage.ref_intImageHeight == 0 || objImage.ref_intImageWidth == 0)
                return;

            int intStartX1 = 0;
            int intStartY1 = 0;
            int intEndX1 = objImage.ref_intImageWidth - 1;
            int intEndY1 = objImage.ref_intImageHeight - 1;

            int intStartX2 = intChippedOffToleranceX;
            int intStartY2 = intChippedOffToleranceY;
            int intEndX2 = objImage.ref_intImageWidth - intChippedOffToleranceX2 - 1;
            int intEndY2 = objImage.ref_intImageHeight - intChippedOffToleranceY2 - 1;

            Line objLine1 = new Line();
            Line objLine2 = new Line();
            Line objLine3 = new Line();
            Line objLine4 = new Line();
            objLine1.CalculateStraightLine(new PointF(intStartX1, intStartY1), new PointF(intStartX2, intStartY2));
            objLine2.CalculateStraightLine(new PointF(intEndX1, intStartY1), new PointF(intEndX2, intStartY2));
            objLine3.CalculateStraightLine(new PointF(intStartX1, intEndY1), new PointF(intStartX2, intEndY2));
            objLine4.CalculateStraightLine(new PointF(intEndX1, intEndY1), new PointF(intEndX2, intEndY2));
            int x, y;
            EBW8 darkPixel = new EBW8((byte)intChipLineLimitPixelValue);

            // -------- separate corner with dark line -------------------------------------------
            for (x = intStartX1; x <= intStartX2; x++)
            {
                y = (int)Math.Round(objLine1.GetPointY(x), 0, MidpointRounding.AwayFromZero);

                if (!(y >= 0 && y < objImage.ref_objMainImage.Height &&
                     x >= 0 && x < objImage.ref_objMainImage.Width))
                {
                    continue;
                }

                if (y < objImage.ref_objMainImage.Height)
                    objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
            }
            for (x = intEndX2; x <= intEndX1; x++)
            {
                y = (int)Math.Round(objLine2.GetPointY(x), 0, MidpointRounding.AwayFromZero);

                if (!(y >= 0 && y < objImage.ref_objMainImage.Height &&
                     x >= 0 && x < objImage.ref_objMainImage.Width))
                {
                    continue;
                }

                if (y < objImage.ref_objMainImage.Height)
                    objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
            }
            for (x = intStartX1; x <= intStartX2; x++)
            {
                y = (int)Math.Round(objLine3.GetPointY(x), 0, MidpointRounding.AwayFromZero);

                if (!(y >= 0 && y < objImage.ref_objMainImage.Height &&
                     x >= 0 && x < objImage.ref_objMainImage.Width))
                {
                    continue;
                }

                if (y < objImage.ref_objMainImage.Height)
                    objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
            }
            for (x = intEndX2; x <= intEndX1; x++)
            {
                y = (int)Math.Round(objLine4.GetPointY(x), 0, MidpointRounding.AwayFromZero);

                if (!(y >= 0 && y < objImage.ref_objMainImage.Height &&
                     x >= 0 && x < objImage.ref_objMainImage.Width))
                {
                    continue;
                }

                if (y < objImage.ref_objMainImage.Height)
                    objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
            }

            // ------------------- Set limit with dark pixel --------------------------------------------------
            for (x = intStartX2; x < intEndX2; x++)
            {
                objImage.ref_objMainImage.SetPixel(darkPixel, x, intStartY2);
            }
            int intEnd = intEndY2;
            for (x = intStartX2; x < intEndX2; x++)
            {
                objImage.ref_objMainImage.SetPixel(darkPixel, x, intEnd);
            }
            for (y = intStartY2; y < intEndY2; y++)
            {
                objImage.ref_objMainImage.SetPixel(darkPixel, intStartX2, y);
            }
            intEnd = intEndX2;
            for (y = intStartY2; y < intEndY2; y++)
            {
                objImage.ref_objMainImage.SetPixel(darkPixel, intEnd, y);
            }
        }
        public bool InspectPackage_Image1(ROI objImage1UnitROI, ROI objMoldFlashROI, int intPadIndex)
        {
            // Return if Inspect Package (Option Form) is OFF.
            if (!m_blnInspectPackage)
                return true;

            m_blnLock = true;

            lock (m_objLockBlobs)
            {
                bool blnResult = true;
                bool blnDebugImage = false;
                if (blnDebugImage)
                {
                    objImage1UnitROI.SaveImage("D:\\TS\\objImage1UnitROI.bmp");// debug
                    if (objMoldFlashROI != null)
                        objMoldFlashROI.SaveImage("D:\\TS\\objMoldFlashROI.bmp");// debug
                }

                try
                {
                    if (blnResult)
                        blnResult = CheckImageBrightDefect_Simple(objImage1UnitROI, 1, intPadIndex);

                    if (blnResult)
                    {
                        if (m_blnSeperateChippedOffDefectSetting && ((m_intFailPkgOptionMask & 0x200000) != 0))
                            blnResult = CheckImageChipDefect_SimpleMode(objImage1UnitROI, 1);
                    }

                    if (blnResult)
                    {
                        if (m_blnSeperateMoldFlashDefectSetting)
                        {
                            //if (m_objRectGauge4L.GetGaugeTiltAngle() == 0)
                            blnResult = CheckImageMoldFlashDefect_Area(objImage1UnitROI, objMoldFlashROI, intPadIndex); //CheckImageMoldFlashDefect
                            //else
                            //    blnResult = CheckImageMoldFlashDefect_Area_TiltAngle(objImage1UnitROI, objMoldFlashROI, intPadIndex); //CheckImageMoldFlashDefect
                        }
                    }
                }
                catch (Exception ex)
                {
                    m_strErrorMessage = "*" + ex.ToString();
                    blnResult = false;
                }

                m_blnLock = false;
                return blnResult;
            }
        }

        public bool InspectPackage_Image2(ROI objImage1UnitROI, ROI objROI, ROI objMoldFlashROI, int intPadIndex)
        {
            // Return if Inspect Package (Option Form) is OFF.
            if (!m_blnInspectPackage)
                return true;

            m_blnLock = true;

            lock (m_objLockBlobs)
            {
                bool blnResult = true;
                bool blnDebugImage = false;

                if (blnDebugImage)
                {
                    objImage1UnitROI.SaveImage("D:\\TS\\objImage1UnitROI.bmp");// debug
                    objROI.SaveImage("D:\\TS\\objROI.bmp");
                }

                try
                {
                    if (blnResult)
                        blnResult = CheckImageDarkDefect_Simple(objImage1UnitROI, 2, intPadIndex);

                    if (blnResult)
                    {
                        if (m_blnSeperateChippedOffDefectSetting && ((m_intFailPkgOptionMask & 0x100000) != 0))
                            blnResult = CheckImageChipDefect_SimpleMode(objImage1UnitROI, 2);
                    }

                    if (blnResult)
                    {
                        if (m_blnSeperateCrackDefectSetting)
                        {
                            //if (m_objRectGauge4L.GetGaugeTiltAngle() == 0)
                            blnResult = CheckCrackDefect_SimpleMode(objImage1UnitROI, objROI.ref_ROITotalX, objROI.ref_ROITotalY, 2);
                            //else
                            //    blnResult = CheckCrackDefect_SimpleMode_TiltAngle(objImage1UnitROI, objROI.ref_ROITotalX, objROI.ref_ROITotalY, 2, intPadIndex);
                        }
                    }
                }
                catch (Exception ex)
                {
                    m_strErrorMessage = "*" + ex.ToString();
                    blnResult = false;
                }
                m_blnLock = false;
                return blnResult;
            }
        }

        private bool CheckImageBrightDefect_Simple(ROI objImageUnitROI, int intImageIndex, int intPadIndex)
        {
            // Return if Bright Field Area and Length are OFF
            if (((m_intFailPkgOptionMask & 0x10000) == 0) && ((m_intFailPkgOptionMask & 0x20000) == 0))
                return true;

            bool blnResult = true;
            bool blnDebugImage = false;

            // Get ready sample ROI
            ROI objSampleROI = new ROI();
            objSampleROI.AttachImage(m_objInsSurfacePkgImage1);  // m_objInsSurfacePkgImage1 is temporary image use to hold objSampleROI double threshold
            objSampleROI.LoadROISetting(objImageUnitROI.ref_ROITotalX, objImageUnitROI.ref_ROITotalY, objImageUnitROI.ref_ROIWidth, objImageUnitROI.ref_ROIHeight);
#if (Debug_2_12 || Release_2_12)
            // Gain and Double threshold

            if (m_fPkgImage1Gain != 1f)
            {
                EasyImage.GainOffset(objImageUnitROI.ref_ROI, objSampleROI.ref_ROI, m_fPkgImage1Gain);
                EasyImage.DoubleThreshold(objSampleROI.ref_ROI, objSampleROI.ref_ROI, (uint)m_intBrightFieldLowThreshold, (uint)m_intBrightFieldHighThreshold, 0, 255, 0); // WinXP (255,0,255) , Win7 (0,255,0)
            }
            else
            {
                EasyImage.DoubleThreshold(objImageUnitROI.ref_ROI, objSampleROI.ref_ROI, (uint)m_intBrightFieldLowThreshold, (uint)m_intBrightFieldHighThreshold, 0, 255, 0);// WinXP (255,0,255) , Win7 (0,255,0)
            }

#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
            // Gain and Double threshold

            if (m_fPkgImage1Gain != 1f)
            {
                EasyImage.GainOffset(objImageUnitROI.ref_ROI, objSampleROI.ref_ROI, m_fPkgImage1Gain);
                EasyImage.DoubleThreshold(objSampleROI.ref_ROI, objSampleROI.ref_ROI, m_intBrightFieldLowThreshold, m_intBrightFieldHighThreshold, 0, 255, 0); // WinXP (255,0,255) , Win7 (0,255,0)
            }
            else
            {
                EasyImage.DoubleThreshold(objImageUnitROI.ref_ROI, objSampleROI.ref_ROI, m_intBrightFieldLowThreshold, m_intBrightFieldHighThreshold, 0, 255, 0);// WinXP (255,0,255) , Win7 (0,255,0)
            }

#endif

            // Check Unit Surface Contamination (m_intFailPkgOptionMask 0x10=Contamination Length, 0x20=Contamiation Area, 0x40=Contamination Total Area
            if ((m_intFailPkgOptionMask & 0x30000) > 0)
            {
                //if (m_objRectGauge4L.GetGaugeTiltAngle() == 0)
                //{
                if (!IsImage1UnitBrightFieldPackageFailed(objSampleROI, objSampleROI.ref_ROITotalX, objSampleROI.ref_ROITotalY, intImageIndex))
                {
                    objSampleROI.Dispose();
                    return false;
                }
                //}
                //else
                //{
                //    if (!IsImage1UnitBrightFieldPackageFailed_TiltAngle(objSampleROI, objSampleROI.ref_ROITotalX, objSampleROI.ref_ROITotalY, intImageIndex, intPadIndex))
                //    {
                //        objSampleROI.Dispose();
                //        objTemplateROI.Dispose();
                //        objTemplateROI2.Dispose();
                //        return false;
                //    }
                //}
            }
            objSampleROI.Dispose();
            return blnResult;
        }

        private bool IsImage1UnitBrightFieldPackageFailed(ROI objSampleROI, int intROIStartX, int intROIStartY, int intImageIndex)//, bool blnPadPkg)
        {
            bool blnDebugImage = false;

            if (blnDebugImage)
                objSampleROI.SaveImage("D:\\TS\\objSampleROI.bmp"); // debug

            // Calculate start point from actual measurement package size. Fyi, objSampleROI size is not same as package size, but is PadROI Size
            float fPkgOffsetX = 0;
            float fPkgOffsetY = 0;
            if (m_blnMeasureCenterPkgSizeUsingCorner)
                fPkgOffsetX = objSampleROI.ref_ROIWidth - m_fCenterUnitWidth;
            else
                fPkgOffsetX = (objSampleROI.ref_ROIWidth - Math.Max(GetResultUpWidth_RectGauge4L(0), GetResultDownWidth_RectGauge4L(0))) / 2;

            if (m_blnMeasureCenterPkgSizeUsingCorner)
                fPkgOffsetY = objSampleROI.ref_ROIHeight - m_fCenterUnitHeight;
            else
                fPkgOffsetY = (objSampleROI.ref_ROIHeight - Math.Max(GetResultLeftHeight_RectGauge4L(0), GetResultLeftHeight_RectGauge4L(0))) / 2;


            int intStartPixelFromEdgeX = (int)Math.Round(fPkgOffsetX + m_fPkgStartPixelFromLeft, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeY = (int)Math.Round(fPkgOffsetY + m_fPkgStartPixelFromEdge, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeX2 = (int)Math.Round(fPkgOffsetX + m_fPkgStartPixelFromRight, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeY2 = (int)Math.Round(fPkgOffsetY + m_fPkgStartPixelFromBottom, 0, MidpointRounding.AwayFromZero);

            ROI objCheckAreaSampleROI = new ROI();
            objCheckAreaSampleROI.AttachImage(objSampleROI);
            objCheckAreaSampleROI.LoadROISetting(intStartPixelFromEdgeX, intStartPixelFromEdgeY,
                objSampleROI.ref_ROIWidth - intStartPixelFromEdgeX - intStartPixelFromEdgeX2,
                objSampleROI.ref_ROIHeight - intStartPixelFromEdgeY - intStartPixelFromEdgeY2);

            if (blnDebugImage)
                objCheckAreaSampleROI.SaveImage("D:\\objCheckAreaSampleROI.bmp");   // debug
            int intSelectedObjectNum = 0;

            switch (intImageIndex)
            {
                case 1: // Image 1 (Grab 1 & Grab 2 Merged)
                    {
                        intSelectedObjectNum = m_objImage1SurfaceEBlobs.BuildObjects_Filter_GetElement(objCheckAreaSampleROI, false, true, 0, 125,
              m_intBrightFieldMinArea, 999999, false, 0xEF);// 0x0D);

                    }
                    break;
                case 2: // Image 2 (Grab 3)
                    {
                        intSelectedObjectNum = m_objImage1SurfaceEBlobs.BuildObjects_Filter_GetElement(objCheckAreaSampleROI, false, true, 0, 125,
             m_intDarkFieldMinArea, 999999, false, 0xEF);// 0x0D);

                    }
                    break;
                case 4: // Image 5 (Grab 5)
                    {
                        intSelectedObjectNum = m_objImage1SurfaceEBlobs.BuildObjects_Filter_GetElement(objCheckAreaSampleROI, false, true, 0, 125,
             m_intDarkFieldMinArea, 999999, false, 0xEF);// 0x0D);

                    }
                    break;
            }

            if (blnDebugImage)
                objCheckAreaSampleROI.SaveImage("D:\\TS\\objCheckAreaSampleROI.bmp");   // debug

            bool blnOverallResult = true;
            if (intSelectedObjectNum > 0)
            {
                float fCenterX = 0, fCenterY = 0, fWidth = 0, fHeight = 0;
                float fStartX, fStartY, fEndX, fEndY, fAngle = 0;
                int intArea = 0;
                float fWidthMM, fHeightMM, fAreaInMM;
                int intFailCount = 0;

                int intTotalArea = 0;
                for (int i = 0; i < intSelectedObjectNum; i++)
                {
                    intArea = m_objImage1SurfaceEBlobs.ref_arrArea[i];
                    //fHeight = m_objImage1SurfaceEBlobs.ref_arrHeight[i];
                    //fWidth = m_objImage1SurfaceEBlobs.ref_arrWidth[i];
                    //fCenterX = m_objImage1SurfaceEBlobs.ref_arrLimitCenterX[i];
                    //fCenterY = m_objImage1SurfaceEBlobs.ref_arrLimitCenterY[i];

                    if (m_objImage1SurfaceEBlobs.ref_arrRectWidth[i] < m_objImage1SurfaceEBlobs.ref_arrRectHeight[i])
                    {
                        fWidth = m_objImage1SurfaceEBlobs.ref_arrRectWidth[i];
                        fHeight = m_objImage1SurfaceEBlobs.ref_arrRectHeight[i];

                        fAngle = m_objImage1SurfaceEBlobs.ref_arrRectAngle[i];


                        if (fAngle < 0)
                            fAngle = -Math.Abs(fAngle);
                        else
                            fAngle = -fAngle;
                    }
                    else
                    {
                        fWidth = m_objImage1SurfaceEBlobs.ref_arrRectHeight[i];
                        fHeight = m_objImage1SurfaceEBlobs.ref_arrRectWidth[i];

                        fAngle = m_objImage1SurfaceEBlobs.ref_arrRectAngle[i];


                        if (fAngle < 0)
                            fAngle = Math.Abs(fAngle);
                        else
                            fAngle = 90 - (fAngle);
                    }
                    fCenterX = m_objImage1SurfaceEBlobs.ref_arrRectLimitCenterX[i];
                    fCenterY = m_objImage1SurfaceEBlobs.ref_arrRectLimitCenterY[i];


                    intTotalArea += intArea;
                    fCenterX += intStartPixelFromEdgeX;
                    fCenterY += intStartPixelFromEdgeY;
                    fStartX = (float)Math.Floor(fCenterX - (fWidth / 2));
                    fStartY = (float)Math.Floor(fCenterY - (fHeight / 2));
                    fEndX = (float)Math.Ceiling(fCenterX + (fWidth / 2));
                    fEndY = (float)Math.Ceiling(fCenterY + (fHeight / 2));

                    // convert width and height to mm
                    fWidthMM = Get2DXinMM(fWidth);// / m_fMMToPixelXValue;
                    fHeightMM = Get2DYinMM(fHeight);// / m_fMMToPixelYValue; // 11-04-2019 ZJYEOH : Changed m_fMMToPixelXValue to m_fMMToPixelYValue
                    fAreaInMM = intArea / m_fMMtoPixelAreaValue;/// m_fMMToPixelXValue / m_fMMToPixelYValue;

                    //if ((fWidthMM > m_fScratchLength) || (fHeightMM > m_fScratchLength) || (fAreaInMM > m_fScratchArea) &&
                    //    ((m_intFailPkgOptionMask & 0x08) > 0 || (m_intFailPkgOptionMask & 0x1000) > 0))
                    {
                        intFailCount++;
                        //0x04
                        m_intFailPkgResultMask |= 0x10000; // Fail image 1 surface contamination

                        Defect objDefect = new Defect();

                        objDefect.ref_strName = "Bright";
                        objDefect.ref_intFailMask = 0x10000;
                        objDefect.ref_fCenterX = intROIStartX + fCenterX;
                        objDefect.ref_fCenterY = intROIStartY + fCenterY;
                        objDefect.ref_fStartX = intROIStartX + fStartX;
                        objDefect.ref_fStartY = intROIStartY + fStartY;
                        objDefect.ref_fEndX = intROIStartX + fEndX;
                        objDefect.ref_fEndY = intROIStartY + fEndY;
                        objDefect.ref_fWidth = fWidth;
                        objDefect.ref_fHeight = fHeight;
                        objDefect.ref_fArea = intArea;
                        objDefect.ref_fAngle = fAngle;
                        objDefect.ref_fWidthInMM = fWidthMM;
                        objDefect.ref_fHeightInMM = fHeightMM;
                        objDefect.ref_fAreaInMM2 = fAreaInMM;
                        objDefect.ref_intImageNo = 1;

                        if ((m_intFailPkgOptionMask & 0x20000) > 0)
                        {
                            if (fWidthMM > m_fBrightWidth)
                            {
                                blnOverallResult = false;
                                objDefect.ref_fWidthFailValue = fWidthMM;
                                objDefect.ref_intFailCriteria |= 0x01;
                            }
                            if (fHeightMM > m_fBrightLength)
                            {
                                blnOverallResult = false;
                                objDefect.ref_fHeightFailValue = fHeightMM;
                                objDefect.ref_intFailCriteria |= 0x02;
                            }
                        }

                        if ((m_intFailPkgOptionMask & 0x10000) > 0)
                        {
                            if (fAreaInMM > m_fBrightArea)
                            {
                                blnOverallResult = false;
                                objDefect.ref_fAreaFailValue = fAreaInMM;
                                objDefect.ref_intFailCriteria |= 0x04;
                            }
                        }

                        m_arrPkgDefectList.Add(objDefect);
                    }

                }

                if ((m_intFailPkgOptionMask & 0x10000) > 0)
                {
                    fAreaInMM = intTotalArea / m_fMMtoPixelAreaValue;/// m_fMMToPixelXValue / m_fMMToPixelYValue;

                    if (fAreaInMM > m_fBrightTotalArea)
                    {
                        Defect objDefect = new Defect();

                        objDefect.ref_strName = "Total Bright";
                        objDefect.ref_intFailMask = 0x10000;
                        objDefect.ref_fCenterX = -1;
                        objDefect.ref_fCenterY = -1;
                        objDefect.ref_fStartX = -1;
                        objDefect.ref_fStartY = -1;
                        objDefect.ref_fEndX = -1;
                        objDefect.ref_fEndY = -1;
                        objDefect.ref_fWidth = -1;
                        objDefect.ref_fHeight = -1;
                        objDefect.ref_fArea = intTotalArea;
                        objDefect.ref_fWidthInMM = -1;
                        objDefect.ref_fHeightInMM = -1;
                        objDefect.ref_fAreaInMM2 = fAreaInMM;
                        objDefect.ref_intImageNo = 1;

                        blnOverallResult = false;
                        objDefect.ref_fAreaFailValue = fAreaInMM;
                        objDefect.ref_intFailCriteria |= 0x08;

                        m_arrPkgDefectList.Add(objDefect);

                        m_intFailPkgResultMask |= 0x80000; // Fail image 1 surface total bright field

                        // Collect total extra pad for display error message
                        m_fResultBrightFieldTotalArea = fAreaInMM;
                    }
                }
            }

            objCheckAreaSampleROI.Dispose();
            return blnOverallResult;
        }

        private bool CheckImageChipDefect_SimpleMode(ROI objImageUnitROI, int intImageIndex)//, bool blnPadPkg)
        {
            // Return if Contamination, Chipped off, Scratches Length and Area is OFF
            if ((m_intFailPkgOptionMask & 0x04) == 0)
                return true;

            bool blnResult = true;
            bool blnDebugImage = false;

            if (blnDebugImage)
            {
                objImageUnitROI.SaveImage("D:\\TS\\2.objImageUnitROI.bmp");
            }

            // Get ready sample ROI
            ROI objSampleROI = new ROI();
            objSampleROI.AttachImage(m_objInsSurfacePkgImage1);  // m_objInsSurfacePkgImage1 is temporary image use to hold objSampleROI double threshold
            objSampleROI.LoadROISetting(objImageUnitROI.ref_ROITotalX, objImageUnitROI.ref_ROITotalY, objImageUnitROI.ref_ROIWidth, objImageUnitROI.ref_ROIHeight);
#if (Debug_2_12 || Release_2_12)
            // Gain and Double threshold
            switch (intImageIndex)
            {
                case 1: // Image 1 (Grab 1 & Grab 2 Merged)
                    {
                        if (m_fPkgImage1Gain != 1f)
                        {
                            EasyImage.GainOffset(objImageUnitROI.ref_ROI, objSampleROI.ref_ROI, m_fPkgImage1Gain);
                            EasyImage.DoubleThreshold(objSampleROI.ref_ROI, objSampleROI.ref_ROI, (uint)m_intPkgImage1LowSurfaceThreshold, (uint)m_intPkgImage1HighSurfaceThreshold, 0, 255, 0); // WinXP (255,0,255) , Win7 (0,255,0)
                        }
                        else
                        {
                            EasyImage.DoubleThreshold(objImageUnitROI.ref_ROI, objSampleROI.ref_ROI, (uint)m_intPkgImage1LowSurfaceThreshold, (uint)m_intPkgImage1HighSurfaceThreshold, 0, 255, 0);// WinXP (255,0,255) , Win7 (0,255,0)
                        }
                    }
                    break;
                case 2: // Image 2 (Grab 3)
                    {
                        EasyImage.DoubleThreshold(objImageUnitROI.ref_ROI, objSampleROI.ref_ROI, (uint)m_intPkgImage2LowThreshold, (uint)m_intPkgImage2HighThreshold, 0, 255, 0);// WinXP (255,0,255) , Win7 (0,255,0)
                    }
                    break;
            }
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
            // Gain and Double threshold
            switch (intImageIndex)
            {
                case 1: // Image 1 (Grab 1 & Grab 2 Merged)
                    {
                        if (m_fPkgImage1Gain != 1f)
                        {
                            EasyImage.GainOffset(objImageUnitROI.ref_ROI, objSampleROI.ref_ROI, m_fPkgImage1Gain);
                            EasyImage.DoubleThreshold(objSampleROI.ref_ROI, objSampleROI.ref_ROI, m_intPkgImage1LowSurfaceThreshold, m_intPkgImage1HighSurfaceThreshold, 0, 255, 0); // WinXP (255,0,255) , Win7 (0,255,0)
                        }
                        else
                        {
                            EasyImage.DoubleThreshold(objImageUnitROI.ref_ROI, objSampleROI.ref_ROI, m_intPkgImage1LowSurfaceThreshold, m_intPkgImage1HighSurfaceThreshold, 0, 255, 0);// WinXP (255,0,255) , Win7 (0,255,0)
                        }
                    }
                    break;
                case 2: // Image 2 (Grab 3)
                    {
                        EasyImage.DoubleThreshold(objImageUnitROI.ref_ROI, objSampleROI.ref_ROI, m_intPkgImage2LowThreshold, m_intPkgImage2HighThreshold, 0, 255, 0);// WinXP (255,0,255) , Win7 (0,255,0)
                    }
                    break;
            }
#endif

            if (blnDebugImage)
            {
                m_objInsSurfacePkgImage1.SaveImage("D:\\TS\\3.m_objInsSurfacePkgImage1.bmp");
                objSampleROI.SaveImage("D:\\TS\\4.objSampleROI.bmp");
            }

            // Check Unit Chipped off
            if ((m_intFailPkgOptionMask & 0x04) > 0)
            {

                if (blnDebugImage)
                    objSampleROI.SaveImage("D:\\TS\\B_FinalSampleROI.bmp");// debug

                //if (m_objRectGauge4L.GetGaugeTiltAngle() == 0)
                //{
                if (!IsImage1UnitChippedOff2_Area_SimpleMode(objSampleROI, objSampleROI.ref_ROITotalX, objSampleROI.ref_ROITotalY, intImageIndex))
                {
                    //objImageUnitROI.SaveImage("D:\\objImageUnitROI_"+intImageIndex.ToString()+".bmp");
                    //objSampleROI.SaveImage("D:\\objSampleROI_" + intImageIndex.ToString() + ".bmp");
                    //objTemplateROI.SaveImage("D:\\objTemplateROI_" + intImageIndex.ToString() + ".bmp");
                    //objTemplateROI2.SaveImage("D:\\objTemplateROI2_" + intImageIndex.ToString() + ".bmp");

                    objSampleROI.Dispose();

                    return false;
                }
                //}
                //else
                //{
                //    if (!IsImage1UnitChippedOff2_Area_SimpleMode_TiltAngle(objSampleROI, objSampleROI.ref_ROITotalX, objSampleROI.ref_ROITotalY, intImageIndex)) // IsImage1UnitChippedOff2
                //    {
                //        //objImageUnitROI.SaveImage("D:\\objImageUnitROI_"+intImageIndex.ToString()+".bmp");
                //        //objSampleROI.SaveImage("D:\\objSampleROI_" + intImageIndex.ToString() + ".bmp");
                //        //objTemplateROI.SaveImage("D:\\objTemplateROI_" + intImageIndex.ToString() + ".bmp");
                //        //objTemplateROI2.SaveImage("D:\\objTemplateROI2_" + intImageIndex.ToString() + ".bmp");

                //        objSampleROI.Dispose();
                //        objTemplateROI.Dispose();
                //        objTemplateROI2.Dispose();

                //        return false;
                //    }
                //}
            }

            objSampleROI.Dispose();

            return blnResult;
        }

        private bool IsImage1UnitChippedOff2_Area_SimpleMode(ROI objImage1UnitROI, int ROITotalX, int ROITotalY, int intImageIndex)
        {
            /*
             * Algoritm:
             * 
             *
             * 
             * 
             * 
             * 
             */


            bool blnResult = true;
            bool blnDebugImage = false;

            // Get Chipped off setting length in pixel
            int intCeilChipLengthLeft = (int)Math.Ceiling(m_fChipStartPixelFromLeft);//* m_fMMToPixelXValue
            int intCeilChipLengthTop = (int)Math.Ceiling(m_fChipStartPixelFromEdge);
            int intCeilChipLengthRight = (int)Math.Ceiling(m_fChipStartPixelFromRight);
            int intCeilChipLengthBottom = (int)Math.Ceiling(m_fChipStartPixelFromBottom);

            ROI objChippedOffROI = new ROI();
            objChippedOffROI.AttachImage(objImage1UnitROI); // m_objInsSurfacePkgImage1 is sample image after double threshold
            //objChippedOffROI.LoadROISetting(objImage1UnitROI.ref_ROITotalX,
            //                                            objImage1UnitROI.ref_ROITotalY,
            //                                            objImage1UnitROI.ref_ROIWidth,
            //                                            objImage1UnitROI.ref_ROIHeight);
            objChippedOffROI.LoadROISetting(0, 0, objImage1UnitROI.ref_ROIWidth, objImage1UnitROI.ref_ROIHeight);
            objChippedOffROI.CopyToImage(ref m_objInsChipOffPkgImage1); // Copy sample image to another image memory so that image can be modified without affect the original image.
            objChippedOffROI.AttachImage(m_objInsChipOffPkgImage1);
            objChippedOffROI.LoadROISetting(0, 0, m_objInsChipOffPkgImage1.ref_intImageWidth, m_objInsChipOffPkgImage1.ref_intImageHeight);

            if (intImageIndex == 1)
                FillChipLineLimitToCorner_4Edges(m_objInsChipOffPkgImage1, intCeilChipLengthLeft, intCeilChipLengthTop, intCeilChipLengthRight, intCeilChipLengthBottom, 0);
            else
                FillChipLineLimitToCorner_4Edges(m_objInsChipOffPkgImage1, intCeilChipLengthLeft, intCeilChipLengthTop, intCeilChipLengthRight, intCeilChipLengthBottom, 255);


            bool blnBlackOnWhite;
            if (intImageIndex == 1)
                blnBlackOnWhite = false;
            else
                blnBlackOnWhite = true;

            switch (intImageIndex)
            {
                case 1: // Image 1 (Grab 1 & Grab 2 Merged)
                    {
                        m_objImage1ChipOffEBlobs.BuildObjects_Filter_GetElement(objChippedOffROI, blnBlackOnWhite, true, 0, 125,
                            (int)Math.Floor(m_fSurfaceMinArea), 999999, false, 0x0F);
                    }
                    break;
                case 2: // Image 2 (Grab 3)
                    {
                        m_objImage1ChipOffEBlobs.BuildObjects_Filter_GetElement(objChippedOffROI, blnBlackOnWhite, true, 0, 125,
                            (int)Math.Floor(m_fImage2SurfaceMinArea), 999999, false, 0x0F);
                    }
                    break;
            }
            if (blnDebugImage)
            {
                objImage1UnitROI.SaveImage("D:\\TS\\objImage1UnitROI.bmp");// debug
                objChippedOffROI.SaveImage("D:\\TS\\objChippedOffROI.bmp");// debug 
            }

            if (m_objImage1ChipOffEBlobs.ref_intNumSelectedObject > 0)
            {
                float fDefectLengthPixelLeft = m_fChipStartPixelFromLeft;
                float fDefectLengthPixelTop = m_fChipStartPixelFromEdge;
                float fDefectLengthPixelRight = m_fChipStartPixelFromRight;
                float fDefectLengthPixelBottom = m_fChipStartPixelFromBottom;
                int intObjectArea = 0;
                float fObjectHeight = 0, fObjectWidth = 0, fObjectCenterX = 0, fObjectCenterY = 0;
                float fStartX, fStartY, fEndX, fEndY;
                float fOuterStartX = 1;
                float fOuterStartY = 1;
                float fOuterEndX = objChippedOffROI.ref_ROIWidth;
                float fOuterEndY = objChippedOffROI.ref_ROIHeight;
                float fInterStartX = fDefectLengthPixelLeft;
                float fInterStartY = fDefectLengthPixelTop;
                float fInterEndX = (float)objChippedOffROI.ref_ROIWidth - fDefectLengthPixelRight - 1;
                float fInterEndY = (float)objChippedOffROI.ref_ROIHeight - fDefectLengthPixelBottom - 1;
                // float fTolerance = 2f;
                float fToleranceLeft = fDefectLengthPixelLeft / 2;
                float fToleranceTop = fDefectLengthPixelTop / 2;
                float fToleranceRight = fDefectLengthPixelRight / 2;
                float fToleranceBottom = fDefectLengthPixelBottom / 2;
                int intFailCount = 0;

                for (int i = 0; i < m_objImage1ChipOffEBlobs.ref_intNumSelectedObject; i++)
                {
                    fObjectCenterX = m_objImage1ChipOffEBlobs.ref_arrLimitCenterX[i];
                    fObjectCenterY = m_objImage1ChipOffEBlobs.ref_arrLimitCenterY[i];
                    fObjectWidth = m_objImage1ChipOffEBlobs.ref_arrWidth[i];
                    fObjectHeight = m_objImage1ChipOffEBlobs.ref_arrHeight[i];
                    intObjectArea = m_objImage1ChipOffEBlobs.ref_arrArea[i];


                    fStartX = fObjectCenterX - (fObjectWidth / 2);
                    fStartY = fObjectCenterY - (fObjectHeight / 2);
                    fEndX = fObjectCenterX + (fObjectWidth / 2);
                    fEndY = fObjectCenterY + (fObjectHeight / 2);

                    bool blnDefect = false;
                    float fAddX = 0;
                    float fAddY = 0;
                    bool blnFailWidth = false;

                    if (fStartX < fInterStartX) // Possible Left Chipped
                    {
                        if (fStartY < fInterStartY) // Possible Top Chipped
                        {
                            if (fStartX < fStartY)  // Confirm Left Chipped
                            {
                                if (fObjectWidth >= fDefectLengthPixelLeft)  // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                    blnFailWidth = true;
                                }
                                else if ((fObjectCenterX - fObjectWidth / 2) > 0)
                                {
                                    //if (fObjectWidth == intCeilChipLengthX - fTolerance)    // Is Chipped same length with chip setting + tolerance
                                    if (fObjectWidth >= intCeilChipLengthLeft - fToleranceLeft)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if ((fTolerance - (fObjectCenterX + fObjectWidth / 2)) <= fTolerance) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if ((fToleranceLeft - (fObjectCenterX + fObjectWidth / 2)) <= fToleranceLeft) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            blnFailWidth = true;
                                            fAddX = fObjectCenterX - fObjectWidth / 2;
                                        }
                                    }
                                }
                            }
                            else // Confirm Top Chipped
                            {
                                if (fObjectHeight >= fDefectLengthPixelTop) // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                }
                                else if ((fObjectCenterY - fObjectHeight / 2) > 0)
                                {
                                    //if (fObjectHeight == intCeilChipLengthY - fTolerance) // Is Chipped same length with chip setting + tolerance
                                    if (fObjectHeight >= intCeilChipLengthTop - fToleranceTop)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= fTolerance)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= fToleranceTop)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            fAddY = fObjectCenterY - fObjectHeight / 2;
                                        }
                                    }
                                }

                            }
                        }
                        else if (fEndY > fInterEndY)    // Possible Bottom Chipped
                        {
                            if (fStartX < (objChippedOffROI.ref_ROIHeight - fEndY)) // Confirm Left Chipped
                            {
                                if (fObjectWidth >= fDefectLengthPixelBottom)  // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                    blnFailWidth = true;
                                }
                                else if ((fObjectCenterX - fObjectWidth / 2) > 0)   // Need to make sure object size not touching Unit edge if object size less than setting min value.
                                {
                                    //if (fObjectWidth == intCeilChipLengthX - fTolerance)    // Is Chipped same length with chip setting + tolerance
                                    if (fObjectWidth >= intCeilChipLengthBottom - fToleranceBottom)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= fTolerance) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= fToleranceBottom) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            blnFailWidth = true;
                                            fAddX = fObjectCenterX - fObjectWidth / 2;
                                        }
                                    }
                                }
                            }
                            else // Confirm BOttom Chipped
                            {
                                if (fObjectHeight >= fDefectLengthPixelBottom) // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                }
                                else if ((objChippedOffROI.ref_ROIHeight - fEndY) > 0)   // Make sure object no touch outerEndY
                                {
                                    //if (fObjectHeight == intCeilChipLengthY - fTolerance) // Is Chipped same length with chip setting + tolerance
                                    if (fObjectHeight >= intCeilChipLengthBottom - fToleranceBottom)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= fTolerance)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        //if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= fToleranceBottom)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if ((fStartY - fInterEndY) <= 0.5) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            fAddY = objChippedOffROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2);
                                        }
                                    }
                                }
                            }
                        }
                        else // Confirm Left Chipped
                        {
                            if (fObjectWidth >= fDefectLengthPixelLeft)  // Is Chipped over setting min value
                            {
                                blnDefect = true;
                                blnFailWidth = true;
                            }
                            else if ((fObjectCenterX - fObjectWidth / 2) > 0)
                            {
                                //if (fObjectWidth == intCeilChipLengthX - fTolerance)    // Is Chipped same length with chip setting + tolerance
                                if (fObjectWidth >= intCeilChipLengthLeft - fToleranceLeft)    // Is Chipped over chip setting - tolerance
                                {
                                    //if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= fTolerance) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                    if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= fToleranceLeft) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                    {
                                        blnDefect = true;
                                        blnFailWidth = true;
                                        fAddX = fObjectCenterX - fObjectWidth / 2;
                                    }
                                }
                            }

                        }
                    }

                    if (!blnDefect && fEndX > fInterEndX) // Possible Right Chipped
                    {
                        if (fStartY < fInterStartY) // Possible Top Chipped
                        {
                            if (fStartY < (objChippedOffROI.ref_ROIWidth - fEndX))  // Confirm Top Chipped
                            {
                                if (fObjectHeight >= fDefectLengthPixelTop)  // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                }
                                else if ((fObjectCenterY - fObjectHeight / 2) > 0)
                                {
                                    //if (fObjectHeight == intCeilChipLengthY - fTolerance) // Is Chipped same length with chip setting + tolerance
                                    if (fObjectHeight >= intCeilChipLengthTop - fToleranceTop)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= fTolerance)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= fToleranceTop)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            fAddY = fObjectCenterY - fObjectHeight / 2;
                                        }
                                    }
                                }
                            }
                            else // Confirm Right Chipped
                            {
                                if (fObjectWidth >= fDefectLengthPixelRight) // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                    blnFailWidth = true;
                                }
                                else if ((objChippedOffROI.ref_ROIWidth - fEndX) > 0)   // Make sure object no touch outerEndX
                                {
                                    //if (fObjectWidth == intCeilChipLengthX - fTolerance)    // Is Chipped same length with chip setting + tolerance
                                    if (fObjectWidth >= intCeilChipLengthRight - fToleranceRight)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= fTolerance) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        //if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= fToleranceRight) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if ((fStartX - fInterEndX) <= 0.5) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            blnFailWidth = true;
                                            fAddX = objChippedOffROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2);
                                        }
                                    }
                                }
                            }
                        }
                        else if (fEndY > fInterEndY)    // Possible Bottom Chipped
                        {
                            if ((objChippedOffROI.ref_ROIWidth - fEndX) < (objChippedOffROI.ref_ROIHeight - fEndY)) // Confirm Right Chipped
                            {
                                if (fObjectWidth >= fDefectLengthPixelRight)  // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                    blnFailWidth = true;
                                }
                                else if ((objChippedOffROI.ref_ROIWidth - fEndX) > 0)   // Make sure object no touch outerEndX
                                {
                                    //if (fObjectWidth == intCeilChipLengthX - fTolerance)    // Is Chipped same length with chip setting + tolerance
                                    if (fObjectWidth >= intCeilChipLengthRight - fToleranceRight)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= fTolerance) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        //if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= fToleranceRight) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if ((fStartX - fInterEndX) <= 0.5) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            blnFailWidth = true;
                                            fAddX = objChippedOffROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2);
                                        }
                                    }
                                }
                            }
                            else // Confirm BOttom Chipped
                            {
                                if (fObjectHeight >= fDefectLengthPixelBottom) // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                }
                                else if ((objChippedOffROI.ref_ROIHeight - fEndY) > 0)   // Make sure object no touch outerEndY
                                {
                                    //if (fObjectHeight == intCeilChipLengthY - fTolerance) // Is Chipped same length with chip setting + tolerance
                                    if (fObjectHeight >= intCeilChipLengthBottom - fToleranceBottom)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= fTolerance)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        //if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= fToleranceBottom)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if ((fStartY - fInterEndY) <= 0.5) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            fAddY = objChippedOffROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2);
                                        }
                                    }
                                }
                            }
                        }
                        else // Confirm Right Chipped
                        {
                            if (fObjectWidth >= fDefectLengthPixelRight)  // Is Chipped over setting min value
                            {
                                blnDefect = true;
                                blnFailWidth = true;
                            }
                            else if ((objChippedOffROI.ref_ROIWidth - fEndX) > 0)   // Make sure object no touch outerEndX
                            {
                                if (fObjectWidth >= intCeilChipLengthRight - fToleranceRight)    // Is Chipped same length with chip setting + tolerance
                                {
                                    //if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= fTolerance) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                    //if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= fToleranceRight) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                    if ((fStartX - fInterEndX) <= 0.5) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                    {
                                        blnDefect = true;
                                        blnFailWidth = true;
                                        fAddX = objChippedOffROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2);
                                    }
                                }
                            }
                        }
                    }

                    if (!blnDefect && fStartY < fInterStartY) // Possible Top chipped
                    {
                        if (fStartX < fInterStartX) // Possible Left Chipped
                        {
                            if (fStartX < fStartY)  // Confirm Left Chipped
                            {
                                if (fObjectWidth >= fDefectLengthPixelLeft)  // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                    blnFailWidth = true;
                                }
                                else if ((fObjectCenterX - fObjectWidth / 2) > 0)
                                {
                                    //if (fObjectWidth == intCeilChipLengthX - fTolerance)    // Is Chipped same length with chip setting + tolerance
                                    if (fObjectWidth >= intCeilChipLengthLeft - fToleranceLeft)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= fTolerance) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= fToleranceLeft) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            blnFailWidth = true;
                                            fAddX = fObjectCenterX - fObjectWidth / 2;
                                        }
                                    }
                                }

                            }
                            else // Confirm Top Chipped
                            {
                                if (fObjectHeight >= fDefectLengthPixelTop) // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                }
                                else if ((fObjectCenterY - fObjectHeight / 2) > 0)
                                {
                                    //if (fObjectHeight == intCeilChipLengthY - fTolerance) // Is Chipped same length with chip setting + tolerance
                                    if (fObjectHeight >= intCeilChipLengthTop - fToleranceTop)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= fTolerance)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= fToleranceTop)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            fAddY = fObjectCenterY - fObjectHeight / 2;
                                        }
                                    }
                                }
                            }
                        }
                        else if (fEndX > fInterEndX)    // Possible Right Chipped
                        {
                            if (fStartY < (objChippedOffROI.ref_ROIWidth - fEndX)) // Confirm Top Chipped
                            {
                                if (fObjectHeight >= fDefectLengthPixelTop)  // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                }
                                else if ((fObjectCenterY - fObjectHeight / 2) > 0)
                                {
                                    //if (fObjectHeight == intCeilChipLengthY - fTolerance) // Is Chipped same length with chip setting + tolerance
                                    if (fObjectHeight >= intCeilChipLengthTop - fToleranceTop)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= fTolerance)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= fToleranceTop)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            fAddY = fObjectCenterY - fObjectHeight / 2;
                                        }
                                    }
                                }
                            }
                            else // Confirm Right Chipped
                            {
                                if (fObjectWidth >= fDefectLengthPixelRight) // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                    blnFailWidth = true;
                                }
                                else if ((objChippedOffROI.ref_ROIWidth - fEndX) > 0)   // Make sure object no touch outerEndX
                                {
                                    //if (fObjectWidth == intCeilChipLengthX - fTolerance)    // Is Chipped same length with chip setting + tolerance
                                    if (fObjectWidth >= intCeilChipLengthRight - fToleranceRight)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= fTolerance) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        //if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= fToleranceRight) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if ((fStartX - fInterEndX) <= 0.5) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            blnFailWidth = true;
                                            fAddX = objChippedOffROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2);
                                        }
                                    }
                                }
                            }
                        }
                        else // Confirm Top Chipped
                        {
                            if (fObjectHeight >= fDefectLengthPixelTop)  // Is Chipped over setting min value
                            {
                                blnDefect = true;
                            }
                            else if ((fObjectCenterY - fObjectHeight / 2) > 0)
                            {
                                //if (fObjectHeight == intCeilChipLengthY - fTolerance) // Is Chipped same length with chip setting + tolerance
                                if (fObjectHeight >= intCeilChipLengthTop - fToleranceTop)    // Is Chipped over chip setting - tolerance
                                {
                                    //if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= fTolerance)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                    if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= fToleranceTop)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                    {
                                        blnDefect = true;
                                        fAddY = fObjectCenterY - fObjectHeight / 2;
                                    }
                                }
                            }
                        }
                    }

                    if (!blnDefect && fEndY > fInterEndY) // Possible Bottom Chipped
                    {
                        if (fStartX < fInterStartX) // Possible Left Chipped
                        {
                            if (fStartX < (objChippedOffROI.ref_ROIHeight - fEndY))  // Confirm Left Chipped
                            {
                                if (fObjectWidth >= fDefectLengthPixelLeft)  // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                    blnFailWidth = true;
                                }
                                else if ((fObjectCenterX - fObjectWidth / 2) > 0)
                                {
                                    //if (fObjectWidth == intCeilChipLengthX - fTolerance)    // Is Chipped same length with chip setting + tolerance
                                    if (fObjectWidth >= intCeilChipLengthLeft - fToleranceLeft)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= fTolerance) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= fToleranceLeft) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            blnFailWidth = true;
                                            fAddX = fObjectCenterX - fObjectWidth / 2;
                                        }
                                    }
                                }

                            }
                            else // Confirm Bottom Chipped
                            {
                                if (fObjectHeight >= fDefectLengthPixelBottom) // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                }
                                else if ((objChippedOffROI.ref_ROIHeight - fEndY) > 0)   // Make sure object no touch outerEndY
                                {
                                    //if (fObjectHeight == intCeilChipLengthY - fTolerance) // Is Chipped same length with chip setting + tolerance
                                    if (fObjectHeight >= intCeilChipLengthBottom - fToleranceBottom)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= fTolerance)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        //if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= fToleranceBottom)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if ((fStartY - fInterEndY) <= 0.5) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            fAddY = objChippedOffROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2);
                                        }
                                    }
                                }
                            }
                        }
                        else if (fEndX > fInterEndX)    // Possible Right Chipped
                        {
                            if ((objChippedOffROI.ref_ROIWidth - fEndX) < (objChippedOffROI.ref_ROIHeight - fEndY)) // Confirm Right Chipped
                            {
                                if (fObjectWidth >= fDefectLengthPixelRight)  // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                    blnFailWidth = true;
                                }
                                else if ((objChippedOffROI.ref_ROIWidth - fEndX) > 0)   // Make sure object no touch outerEndX
                                {
                                    //if (fObjectWidth == intCeilChipLengthX - fTolerance)    // Is Chipped same length with chip setting + tolerance
                                    if (fObjectWidth >= intCeilChipLengthRight - fToleranceRight)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= fTolerance) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        //if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= fToleranceRight) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if ((fStartX - fInterEndX) <= 0.5) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            blnFailWidth = true;
                                            fAddX = objChippedOffROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2);
                                        }
                                    }
                                }
                            }
                            else // Confirm BOttom Chipped
                            {
                                if (fObjectHeight >= fDefectLengthPixelBottom) // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                }
                                else if ((objChippedOffROI.ref_ROIHeight - fEndY) > 0)   // Make sure object no touch outerEndY
                                {
                                    //if (fObjectHeight == intCeilChipLengthY - fTolerance) // Is Chipped same length with chip setting + tolerance
                                    if (fObjectHeight >= intCeilChipLengthBottom - fToleranceBottom)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= fTolerance)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        //if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= fToleranceBottom)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if ((fStartY - fInterEndY) <= 0.5) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            fAddY = objChippedOffROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2);
                                        }
                                    }
                                }
                            }
                        }
                        else // Confirm Bottom Chipped
                        {
                            if (fObjectHeight >= fDefectLengthPixelBottom)  // Is Chipped over setting min value
                            {
                                blnDefect = true;
                            }
                            else if ((objChippedOffROI.ref_ROIHeight - fEndY) > 0)   // Make sure object no touch outerEndY
                            {
                                //if (fObjectHeight == intCeilChipLengthY - fTolerance) // Is Chipped same length with chip setting + tolerance
                                if (fObjectHeight >= intCeilChipLengthBottom - fToleranceBottom)    // Is Chipped over chip setting - tolerance
                                {
                                    //if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= fTolerance)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                    //if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= fToleranceBottom)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                    if ((fStartY - fInterEndY) <= 0.5) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                    {
                                        blnDefect = true;
                                        fAddY = objChippedOffROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2);
                                    }
                                }
                            }
                        }
                    }

                    float fWidthMM = Get2DXinMM(fObjectWidth + fAddX);// / m_fMMToPixelXValue;
                    float fHeightMM = Get2DYinMM(fObjectHeight + fAddY);// / m_fMMToPixelYValue; // 11-04-2019 ZJYEOH : Changed m_fMMToPixelXValue to m_fMMToPixelYValue
                    float fAreaInMM = intObjectArea / m_fMMtoPixelAreaValue;/// m_fMMToPixelXValue / m_fMMToPixelYValue;
                    float fChipAreaLimit;
                    if (intImageIndex == 1)
                        fChipAreaLimit = m_fBrightChippedOffArea;
                    else
                        fChipAreaLimit = m_fDarkChippedOffArea;

                    if (blnDefect && fAreaInMM > fChipAreaLimit)
                    {
                        intFailCount++;


                        //0x02
                        m_intFailPkgResultMask |= 0x04; // Fail image 1 chipped off

                        Defect objDefect = new Defect();
                        objDefect.ref_intImageNo = intImageIndex;

                        objDefect.ref_strName = "Chipped Off";

                        objDefect.ref_intFailMask = 0x04;//0x02
                        objDefect.ref_fCenterX = ROITotalX + objChippedOffROI.ref_ROITotalX + fObjectCenterX;
                        objDefect.ref_fCenterY = ROITotalY + objChippedOffROI.ref_ROITotalY + fObjectCenterY;
                        objDefect.ref_fStartX = ROITotalX + fStartX;
                        objDefect.ref_fStartY = ROITotalY + fStartY;
                        objDefect.ref_fEndX = ROITotalX + fEndX;
                        objDefect.ref_fEndY = ROITotalY + fEndY;
                        objDefect.ref_fWidth = fObjectWidth + fAddX;
                        objDefect.ref_fHeight = fObjectHeight + fAddY;
                        objDefect.ref_fArea = intObjectArea;
                        objDefect.ref_fWidthInMM = fWidthMM;
                        objDefect.ref_fHeightInMM = fHeightMM;
                        objDefect.ref_fAreaInMM2 = fAreaInMM;

                        //if (blnFailWidth)
                        //{
                        //    objDefect.ref_fFailValue = fWidthMM;
                        //    objDefect.ref_intFailCriteria |= 0x01;
                        //}
                        //else
                        //{
                        //    objDefect.ref_fFailValue = fHeightMM;
                        //    objDefect.ref_intFailCriteria |= 0x02;
                        //}

                        objDefect.ref_fFailValue = fAreaInMM;
                        objDefect.ref_intFailCriteria |= 0x04;

                        m_arrPkgDefectList.Add(objDefect);

                        if (blnResult)
                            blnResult = false;
                    }

                }
            }

            objChippedOffROI.Dispose();

            return blnResult;
        }

        private bool CheckImageMoldFlashDefect_Area(ROI objImage1UnitROI, ROI objMoldFlashROI, int intPadIndex)
        {
            if ((m_intFailPkgOptionMask & 0x80) == 0)
                return true;

            if (m_fMoldFlashArea == 0)
                return true;

            bool blnDebugImage = false;
            bool blnResult = true;
            int intTotalStartX = 0, intTotalStartY = 0;

            int intToleranceWidth = (objMoldFlashROI.ref_ROIWidth - objImage1UnitROI.ref_ROIWidth) / 2;
            int intToleranceHeight = (objMoldFlashROI.ref_ROIHeight - objImage1UnitROI.ref_ROIHeight) / 2;

            ROI objMoldFlashBorderROI = new ROI();
            objMoldFlashBorderROI.AttachImage(objMoldFlashROI);

            for (int i = 0; i < 4; i++)   // Create 4 direction ROI
            {
                if (m_intLeadROIDirection == 1 && i == 2)    // Top Side Pad 
                    continue;
                else if (m_intLeadROIDirection == 2 && i == 3) // Right Side Pad
                    continue;
                else if (m_intLeadROIDirection == 3 && i == 0) // Bottom Side Pad
                    continue;
                else if (m_intLeadROIDirection == 4 && i == 1) // Left Side Pad
                    continue;

                switch (i)
                {
                    case 0:  // Top Border
                        if (m_intLeadROIDirection == 2)
                            objMoldFlashBorderROI.LoadROISetting(intToleranceWidth, 0, objMoldFlashROI.ref_ROIWidth - intToleranceWidth, intToleranceHeight);
                        else if (m_intLeadROIDirection == 4)
                            objMoldFlashBorderROI.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth - intToleranceWidth, intToleranceHeight);
                        else
                            objMoldFlashBorderROI.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth, (int)m_fMoldStartPixelFromEdge);


                        intTotalStartX = objMoldFlashROI.ref_ROITotalX;
                        intTotalStartY = objMoldFlashROI.ref_ROITotalY;

                        break;
                    case 1: // Right Border
                        if (m_intLeadROIDirection == 1)
                            objMoldFlashBorderROI.LoadROISetting(objMoldFlashROI.ref_ROIWidth - intToleranceWidth, 0, intToleranceWidth, objMoldFlashROI.ref_ROIHeight - intToleranceHeight);
                        else if (m_intLeadROIDirection == 3)
                            objMoldFlashBorderROI.LoadROISetting(objMoldFlashROI.ref_ROIWidth - intToleranceWidth, intToleranceHeight, intToleranceWidth, objMoldFlashROI.ref_ROIHeight - intToleranceHeight);
                        else
                            objMoldFlashBorderROI.LoadROISetting(objMoldFlashROI.ref_ROIWidth - (int)m_fMoldStartPixelFromRight, 0, (int)m_fMoldStartPixelFromRight, objMoldFlashROI.ref_ROIHeight);
                        intTotalStartX = objMoldFlashROI.ref_ROITotalX + objMoldFlashROI.ref_ROIWidth - (int)m_fMoldStartPixelFromRight;
                        intTotalStartY = objMoldFlashROI.ref_ROITotalY;


                        break;
                    case 2: // Bottom Border
                        if (m_intLeadROIDirection == 2)
                            objMoldFlashBorderROI.LoadROISetting(intToleranceWidth, objMoldFlashROI.ref_ROIHeight - intToleranceHeight, objMoldFlashROI.ref_ROIWidth - intToleranceWidth, intToleranceHeight);
                        else if (m_intLeadROIDirection == 4)
                            objMoldFlashBorderROI.LoadROISetting(0, objMoldFlashROI.ref_ROIHeight - intToleranceHeight, objMoldFlashROI.ref_ROIWidth - intToleranceWidth, intToleranceHeight);
                        else
                            objMoldFlashBorderROI.LoadROISetting(0, objMoldFlashROI.ref_ROIHeight - (int)m_fMoldStartPixelFromBottom, objMoldFlashROI.ref_ROIWidth, (int)m_fMoldStartPixelFromBottom);
                        intTotalStartX = objMoldFlashROI.ref_ROITotalX;
                        intTotalStartY = objMoldFlashROI.ref_ROITotalY + objMoldFlashROI.ref_ROIHeight - (int)m_fMoldStartPixelFromBottom;


                        break;
                    case 3: // Left Border
                        if (m_intLeadROIDirection == 1)
                            objMoldFlashBorderROI.LoadROISetting(0, 0, intToleranceWidth, objMoldFlashROI.ref_ROIHeight - intToleranceHeight);
                        else if (m_intLeadROIDirection == 3)
                            objMoldFlashBorderROI.LoadROISetting(0, intToleranceHeight, intToleranceWidth, objMoldFlashROI.ref_ROIHeight - intToleranceHeight);
                        else
                            objMoldFlashBorderROI.LoadROISetting(0, 0, (int)m_fMoldStartPixelFromLeft, objMoldFlashROI.ref_ROIHeight);
                        intTotalStartX = objMoldFlashROI.ref_ROITotalX;
                        intTotalStartY = objMoldFlashROI.ref_ROITotalY;


                        break;
                }

                // Build blobs object for subtract image
                m_objImage1MoldFlashEBlobs.BuildObjects_Filter_GetElement(objMoldFlashBorderROI, false, true, 0, m_intPkgImage1MoldFlashThreshold,
                    (int)Math.Floor(m_fMoldFlashMinArea), 999999, false, 0x0F);
                //objMoldFlashBorderROI.SaveImage("D:\\objMoldFlashBorderROI.bmp");
                if (m_objImage1MoldFlashEBlobs.ref_intNumSelectedObject > 0)
                {
                    float fCenterX = 0, fCenterY = 0, fWidth = 0, fHeight = 0;
                    float fStartX = 0, fStartY = 0, fEndX = 0, fEndY = 0;
                    int intArea = 0;
                    float fWidthMM, fHeightMM, fAreaInMM;
                    int intFailCount = 0;

                    for (int x = 0; x < m_objImage1MoldFlashEBlobs.ref_intNumSelectedObject; x++)
                    {
                        fCenterX = m_objImage1MoldFlashEBlobs.ref_arrLimitCenterX[x];
                        fCenterY = m_objImage1MoldFlashEBlobs.ref_arrLimitCenterY[x];
                        fWidth = m_objImage1MoldFlashEBlobs.ref_arrWidth[x];
                        fHeight = m_objImage1MoldFlashEBlobs.ref_arrHeight[x];
                        intArea = m_objImage1MoldFlashEBlobs.ref_arrArea[x];
                        fStartX = (float)Math.Floor(fCenterX - (fWidth / 2));
                        fStartY = (float)Math.Floor(fCenterY - (fHeight / 2));
                        fEndX = (float)Math.Ceiling(fCenterX + (fWidth / 2));
                        fEndY = (float)Math.Ceiling(fCenterY + (fHeight / 2));

                        fWidthMM = Get2DXinMM(fWidth);// / m_fMMToPixelXValue;
                        fHeightMM = Get2DYinMM(fHeight);// / m_fMMToPixelYValue;
                        fAreaInMM = intArea / m_fMMtoPixelAreaValue;// / m_fMMToPixelXValue / m_fMMToPixelYValue;

                        bool blnDefect = false;
                        bool blnFailWidth = false;

                        //bool blnLengthFail = false;
                        // Not need to check length, only area
                        //if (i == 0)
                        //{
                        //    if (fHeight >= m_fMoldStartPixelFromEdge)
                        //        blnLengthFail = true;
                        //}
                        //else if (i == 1)
                        //{
                        //    if (fWidth >= m_fMoldStartPixelFromRight)
                        //        blnLengthFail = true;
                        //}
                        //else if (i == 2)
                        //{
                        //    if (fHeight >= m_fMoldStartPixelFromBottom)
                        //        blnLengthFail = true;
                        //}
                        //else if (i == 3)
                        //{
                        //    if (fWidth >= m_fMoldStartPixelFromLeft)
                        //        blnLengthFail = true;
                        //}

                        //if (blnLengthFail && fAreaInMM >= m_fMoldFlashArea)
                        if (fAreaInMM > m_fMoldFlashArea)  // 2019 07 21 - CCENG: Not need to check length anymore.
                        {
                            intFailCount++;
                            m_intFailPkgResultMask |= 0x80; // Fail Mold Flash

                            Defect objDefect = new Defect();

                            objDefect.ref_strName = "Mold Flash";
                            objDefect.ref_intFailCriteria |= 0x04;
                            objDefect.ref_intFailMask |= 0x80;
                            objDefect.ref_fCenterX = intTotalStartX + fCenterX;
                            objDefect.ref_fCenterY = intTotalStartY + fCenterY;
                            objDefect.ref_fStartX = intTotalStartX + fStartX;
                            objDefect.ref_fStartY = intTotalStartY + fStartY;
                            objDefect.ref_fEndX = intTotalStartX + fEndX;
                            objDefect.ref_fEndY = intTotalStartY + fEndY;
                            objDefect.ref_fWidth = fWidth;
                            objDefect.ref_fHeight = fHeight;
                            objDefect.ref_fArea = intArea;
                            objDefect.ref_fWidthInMM = fWidthMM;
                            objDefect.ref_fHeightInMM = fHeightMM;
                            objDefect.ref_fAreaInMM2 = fAreaInMM;
                            objDefect.ref_intImageNo = 1;
                            objDefect.ref_fFailValue = fAreaInMM;

                            m_arrPkgDefectList.Add(objDefect);

                            if (blnResult)
                                blnResult = false;
                        }
                    }
                }

            }

            objMoldFlashBorderROI.Dispose();
            return blnResult;
        }
        private bool CheckImageDarkDefect_Simple(ROI objImageUnitROI, int intImageIndex, int intPadIndex)//, bool blnPadPkg)
        {
            // Return if Bright Field Area and Length are OFF
            if (((m_intFailPkgOptionMask & 0x40000) == 0) && ((m_intFailPkgOptionMask & 0x80000) == 0))
                return true;

            bool blnResult = true;
            bool blnDebugImage = false;

            if (blnDebugImage)
            {
                objImageUnitROI.SaveImage("D:\\TS\\2.objImageUnitROI.bmp");
            }

            // Get ready sample ROI
            ROI objSampleROI = new ROI();
            objSampleROI.AttachImage(m_objInsSurfacePkgImage1);  // m_objInsSurfacePkgImage1 is temporary image use to hold objSampleROI double threshold
            objSampleROI.LoadROISetting(objImageUnitROI.ref_ROITotalX, objImageUnitROI.ref_ROITotalY, objImageUnitROI.ref_ROIWidth, objImageUnitROI.ref_ROIHeight);

            // 2019-11-06 ZJYEOH : Add gain for Dark Field Inspection Image
            EasyImage.GainOffset(objImageUnitROI.ref_ROI, objSampleROI.ref_ROI, m_fDarkFieldImageGain);
#if (Debug_2_12 || Release_2_12)
            // Gain and Double threshold
            EasyImage.DoubleThreshold(objSampleROI.ref_ROI, objSampleROI.ref_ROI, (uint)m_intDarkFieldLowThreshold, (uint)m_intDarkFieldHighThreshold, 255, 0, 255);// WinXP (255,0,255) , Win7 (0,255,0)
            
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
            // Gain and Double threshold
            EasyImage.DoubleThreshold(objSampleROI.ref_ROI, objSampleROI.ref_ROI, m_intDarkFieldLowThreshold, m_intDarkFieldHighThreshold, 255, 0, 255);// WinXP (255,0,255) , Win7 (0,255,0)

#endif

            if (blnDebugImage)
            {
                objSampleROI.SaveImage("D:\\TS\\20.B_BfSBSampleROI.bmp");// debug
            }


            // Check Unit Surface Contamination (m_intFailPkgOptionMask 0x10=Contamination Length, 0x20=Contamiation Area, 0x40=Contamination Total Area
            if (((m_intFailPkgOptionMask & 0xC0000) > 0))
            {
                //if (m_objRectGauge4L.GetGaugeTiltAngle() == 0)
                //{
                if (!IsImage2UnitDarkFieldPackageFailed(objSampleROI, objSampleROI.ref_ROITotalX, objSampleROI.ref_ROITotalY, intImageIndex))
                {
                    objSampleROI.Dispose();
                    return false;
                }
                //}
                //else
                //{
                //    if (!IsImage2UnitDarkFieldPackageFailed_TiltAngle(objSampleROI, objSampleROI.ref_ROITotalX, objSampleROI.ref_ROITotalY, intImageIndex, intPadIndex))
                //    {
                //        objSampleROI.Dispose();
                //        objTemplateROI.Dispose();
                //        objTemplateROI2.Dispose();
                //        return false;
                //    }
                //}
            }

            objSampleROI.Dispose();

            return blnResult;
        }

        private bool IsImage2UnitDarkFieldPackageFailed(ROI objSampleROI, int intROIStartX, int intROIStartY, int intImageIndex)//, bool blnPadPkg)
        {
            bool blnDebugImage = false;

            if (blnDebugImage)
                objSampleROI.SaveImage("D:\\TS\\objSampleROI.bmp"); // debug

            // Calculate start point from actual measurement package size. Fyi, objSampleROI size is not same as package size, but is PadROI Size
            float fPkgOffsetX = 0;
            float fPkgOffsetY = 0;
            if (m_blnMeasureCenterPkgSizeUsingCorner)
                fPkgOffsetX = objSampleROI.ref_ROIWidth - m_fCenterUnitWidth;
            else
                fPkgOffsetX = (objSampleROI.ref_ROIWidth - Math.Max(GetResultUpWidth_RectGauge4L(0), GetResultDownWidth_RectGauge4L(0))) / 2;

            if (m_blnMeasureCenterPkgSizeUsingCorner)
                fPkgOffsetY = objSampleROI.ref_ROIHeight - m_fCenterUnitHeight;
            else
                fPkgOffsetY = (objSampleROI.ref_ROIHeight - Math.Max(GetResultLeftHeight_RectGauge4L(0), GetResultLeftHeight_RectGauge4L(0))) / 2;


            int intStartPixelFromEdgeX = (int)Math.Round(fPkgOffsetX + m_fPkgStartPixelFromLeft, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeY = (int)Math.Round(fPkgOffsetY + m_fPkgStartPixelFromEdge, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeX2 = (int)Math.Round(fPkgOffsetX + m_fPkgStartPixelFromRight, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeY2 = (int)Math.Round(fPkgOffsetY + m_fPkgStartPixelFromBottom, 0, MidpointRounding.AwayFromZero);

            ROI objCheckAreaSampleROI = new ROI();
            objCheckAreaSampleROI.AttachImage(objSampleROI);
            objCheckAreaSampleROI.LoadROISetting(intStartPixelFromEdgeX, intStartPixelFromEdgeY,
                objSampleROI.ref_ROIWidth - intStartPixelFromEdgeX - intStartPixelFromEdgeX2,
                objSampleROI.ref_ROIHeight - intStartPixelFromEdgeY - intStartPixelFromEdgeY2);

            if (blnDebugImage)
                objCheckAreaSampleROI.SaveImage("D:\\objCheckAreaSampleROI.bmp");   // debug
            int intSelectedObjectNum = 0;

            switch (intImageIndex)
            {
                case 1: // Image 1 (Grab 1 & Grab 2 Merged)
                    {
                        intSelectedObjectNum = m_objImage2SurfaceEBlobs.BuildObjects_Filter_GetElement(objCheckAreaSampleROI, false, true, 0, 125,
                                                m_intBrightFieldMinArea, 999999, false, 0xEF);// 0x0D);

                    }
                    break;
                case 2: // Image 2 (Grab 3)
                    {
                        intSelectedObjectNum = m_objImage2SurfaceEBlobs.BuildObjects_Filter_GetElement(objCheckAreaSampleROI, false, true, 0, 125,
                                                m_intDarkFieldMinArea, 999999, false, 0xEF);// 0x0D);

                    }
                    break;
                case 4: // Image 5 (Grab 5)
                    {
                        intSelectedObjectNum = m_objImage2SurfaceEBlobs.BuildObjects_Filter_GetElement(objCheckAreaSampleROI, false, true, 0, 125,
                                                m_intDarkFieldMinArea, 999999, false, 0xEF);// 0x0D);

                    }
                    break;
            }

            if (blnDebugImage)
                objCheckAreaSampleROI.SaveImage("D:\\TS\\objCheckAreaSampleROI.bmp");   // debug

            bool blnOverallResult = true;
            if (intSelectedObjectNum > 0)
            {
                float fCenterX = 0, fCenterY = 0, fWidth = 0, fHeight = 0;
                float fStartX, fStartY, fEndX, fEndY, fAngle = 0;
                int intArea = 0;
                float fWidthMM, fHeightMM, fAreaInMM;
                int intFailCount = 0;

                int intTotalArea = 0;
                for (int i = 0; i < intSelectedObjectNum; i++)
                {
                    intArea = m_objImage2SurfaceEBlobs.ref_arrArea[i];
                    if (m_objImage2SurfaceEBlobs.ref_arrRectWidth[i] < m_objImage2SurfaceEBlobs.ref_arrRectHeight[i])
                    {
                        fWidth = m_objImage2SurfaceEBlobs.ref_arrRectWidth[i];
                        fHeight = m_objImage2SurfaceEBlobs.ref_arrRectHeight[i];

                        fAngle = m_objImage2SurfaceEBlobs.ref_arrRectAngle[i];


                        if (fAngle < 0)
                            fAngle = -Math.Abs(fAngle);
                        else
                            fAngle = -fAngle;
                    }
                    else
                    {
                        fWidth = m_objImage2SurfaceEBlobs.ref_arrRectHeight[i];
                        fHeight = m_objImage2SurfaceEBlobs.ref_arrRectWidth[i];

                        fAngle = m_objImage2SurfaceEBlobs.ref_arrRectAngle[i];


                        if (fAngle < 0)
                            fAngle = Math.Abs(fAngle);
                        else
                            fAngle = 90 - (fAngle);
                    }
                    fCenterX = m_objImage2SurfaceEBlobs.ref_arrRectLimitCenterX[i];
                    fCenterY = m_objImage2SurfaceEBlobs.ref_arrRectLimitCenterY[i];

                    intTotalArea += intArea;
                    fCenterX += intStartPixelFromEdgeX;
                    fCenterY += intStartPixelFromEdgeY;
                    fStartX = (float)Math.Floor(fCenterX - (fWidth / 2));
                    fStartY = (float)Math.Floor(fCenterY - (fHeight / 2));
                    fEndX = (float)Math.Ceiling(fCenterX + (fWidth / 2));
                    fEndY = (float)Math.Ceiling(fCenterY + (fHeight / 2));

                    // convert width and height to mm
                    fWidthMM = Get2DXinMM(fWidth);// / m_fMMToPixelXValue;
                    fHeightMM = Get2DYinMM(fHeight);// / m_fMMToPixelYValue; // 11-04-2019 ZJYEOH : Changed m_fMMToPixelXValue to m_fMMToPixelYValue
                    fAreaInMM = intArea / m_fMMtoPixelAreaValue;/// m_fMMToPixelXValue / m_fMMToPixelYValue;

                    //if ((fWidthMM > m_fScratchLength) || (fHeightMM > m_fScratchLength) || (fAreaInMM > m_fScratchArea) &&
                    //    ((m_intFailPkgOptionMask & 0x08) > 0 || (m_intFailPkgOptionMask & 0x1000) > 0))
                    {
                        intFailCount++;
                        //0x04
                        m_intFailPkgResultMask |= 0x20000; // Fail image 1 surface contamination

                        Defect objDefect = new Defect();

                        objDefect.ref_strName = "Dark";
                        objDefect.ref_intFailMask = 0x20000;
                        objDefect.ref_fCenterX = intROIStartX + fCenterX;
                        objDefect.ref_fCenterY = intROIStartY + fCenterY;
                        objDefect.ref_fStartX = intROIStartX + fStartX;
                        objDefect.ref_fStartY = intROIStartY + fStartY;
                        objDefect.ref_fEndX = intROIStartX + fEndX;
                        objDefect.ref_fEndY = intROIStartY + fEndY;
                        objDefect.ref_fWidth = fWidth;
                        objDefect.ref_fHeight = fHeight;
                        objDefect.ref_fArea = intArea;
                        objDefect.ref_fAngle = fAngle; // 2019-10-09 ZJYEOH : Need to add angle, if no add, defect in drawing will always draw 0 degree only
                        objDefect.ref_fWidthInMM = fWidthMM;
                        objDefect.ref_fHeightInMM = fHeightMM;
                        objDefect.ref_fAreaInMM2 = fAreaInMM;
                        objDefect.ref_intImageNo = 1;

                        if ((m_intFailPkgOptionMask & 0x80000) > 0)
                        {
                            if (fWidthMM > m_fDarkWidth)
                            {
                                blnOverallResult = false;
                                objDefect.ref_fWidthFailValue = fWidthMM;
                                objDefect.ref_intFailCriteria |= 0x01;
                            }
                            if (fHeightMM > m_fDarkLength)
                            {
                                blnOverallResult = false;
                                objDefect.ref_fHeightFailValue = fHeightMM;
                                objDefect.ref_intFailCriteria |= 0x02;
                            }
                        }

                        if ((m_intFailPkgOptionMask & 0x40000) > 0)
                        {
                            if (fAreaInMM > m_fDarkArea)
                            {
                                blnOverallResult = false;
                                objDefect.ref_fAreaFailValue = fAreaInMM;
                                objDefect.ref_intFailCriteria |= 0x04;
                            }
                        }

                        m_arrPkgDefectList.Add(objDefect);
                    }

                }

                if ((m_intFailPkgOptionMask & 0x40000) > 0)
                {
                    fAreaInMM = intTotalArea / m_fMMtoPixelAreaValue;/// m_fMMToPixelXValue / m_fMMToPixelYValue;

                    if (fAreaInMM > m_fDarkTotalArea)
                    {
                        Defect objDefect = new Defect();

                        objDefect.ref_strName = "Total Dark";
                        objDefect.ref_intFailMask = 0x20000;
                        objDefect.ref_fCenterX = -1;
                        objDefect.ref_fCenterY = -1;
                        objDefect.ref_fStartX = -1;
                        objDefect.ref_fStartY = -1;
                        objDefect.ref_fEndX = -1;
                        objDefect.ref_fEndY = -1;
                        objDefect.ref_fWidth = -1;
                        objDefect.ref_fHeight = -1;
                        objDefect.ref_fArea = intTotalArea;
                        objDefect.ref_fWidthInMM = -1;
                        objDefect.ref_fHeightInMM = -1;
                        objDefect.ref_fAreaInMM2 = fAreaInMM;
                        objDefect.ref_intImageNo = intImageIndex;

                        blnOverallResult = false;
                        objDefect.ref_fAreaFailValue = fAreaInMM;
                        objDefect.ref_intFailCriteria |= 0x08;

                        m_arrPkgDefectList.Add(objDefect);

                        m_intFailPkgResultMask |= 0x20000; // Fail image 1 surface total dark field

                        // Collect total extra pad for display error message
                        m_fResultDarkFieldTotalArea = fAreaInMM;
                    }
                }
            }

            objCheckAreaSampleROI.Dispose();
            return blnOverallResult;
        }
        public bool CheckCrackDefect_SimpleMode(ROI objImage1UnitROI, int intROIStartX, int intROIStartY, int intImageIndex)
        {
            // 0x400 = Crack Length, 0x800 = Crack Area
            if ((m_intFailPkgOptionMask & 0x800) == 0 && (m_intFailPkgOptionMask & 0x400) == 0)
                return true;
            bool blnDebugImage = false;
            float fPkgOffsetX = 0;
            float fPkgOffsetY = 0;
            if (m_blnMeasureCenterPkgSizeUsingCorner)
                fPkgOffsetX = objImage1UnitROI.ref_ROIWidth - m_fCenterUnitWidth;
            else
                fPkgOffsetX = (objImage1UnitROI.ref_ROIWidth - Math.Max(GetResultUpWidth_RectGauge4L(0), GetResultDownWidth_RectGauge4L(0))) / 2;

            if (m_blnMeasureCenterPkgSizeUsingCorner)
                fPkgOffsetY = objImage1UnitROI.ref_ROIHeight - m_fCenterUnitHeight;
            else
                fPkgOffsetY = (objImage1UnitROI.ref_ROIHeight - Math.Max(GetResultLeftHeight_RectGauge4L(0), GetResultLeftHeight_RectGauge4L(0))) / 2;


            int intStartPixelFromEdgeX = (int)Math.Round(fPkgOffsetX + m_fPkgStartPixelFromLeft, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeY = (int)Math.Round(fPkgOffsetY + m_fPkgStartPixelFromEdge, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeX2 = (int)Math.Round(fPkgOffsetX + m_fPkgStartPixelFromRight, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeY2 = (int)Math.Round(fPkgOffsetY + m_fPkgStartPixelFromBottom, 0, MidpointRounding.AwayFromZero);

            ROI objCrackROI = new ROI();
            objCrackROI.AttachImage(objImage1UnitROI);
            objCrackROI.LoadROISetting(intStartPixelFromEdgeX, intStartPixelFromEdgeY,
                objImage1UnitROI.ref_ROIWidth - intStartPixelFromEdgeX - intStartPixelFromEdgeX2,
                objImage1UnitROI.ref_ROIHeight - intStartPixelFromEdgeY - intStartPixelFromEdgeY2);

            int intSelectedObjectNum = m_objEBlobs.BuildObjects_Filter_GetElement_DoubleThreshold(
               objCrackROI, true, false, false, false, m_intPkgImage2LowCrackThreshold, m_intPkgImage2HighCrackThreshold,
               (int)m_fCrackMinArea, 15000, false, 0xED);


            bool blnOverallResult = true;
            if (intSelectedObjectNum > 0)
            {
                int intObjectArea = 0;
                float fObjectHeight = 0, fObjectWidth = 0, fObjectCenterX = 0, fObjectCenterY = 0, fObjectAngle = 0;

                int intFailCount = 0;
                for (int i = 0; i < intSelectedObjectNum; i++)
                {
                    intObjectArea = m_objEBlobs.ref_arrArea[i];
                    fObjectHeight = m_objEBlobs.ref_arrRectHeight[i];
                    fObjectWidth = m_objEBlobs.ref_arrRectWidth[i];
                    fObjectCenterX = m_objEBlobs.ref_arrRectLimitCenterX[i];
                    fObjectCenterY = m_objEBlobs.ref_arrRectLimitCenterY[i];
                    fObjectAngle = m_objEBlobs.ref_arrRectAngle[i];

                    fObjectCenterX += intStartPixelFromEdgeX;
                    fObjectCenterY += intStartPixelFromEdgeY;
                    if (fObjectAngle < 0)
                        fObjectAngle = Math.Abs(fObjectAngle);
                    else
                        fObjectAngle = 0 - (fObjectAngle);

                    float Max = Math.Max(fObjectHeight, fObjectWidth);
                    float Min = Math.Min(fObjectHeight, fObjectWidth);

                    if (Max / Min <= 1.5)
                    {
                        if ((intObjectArea / (fObjectHeight * fObjectWidth)) >= 0.5)
                        {
                            continue;
                        }
                    }

                    float fWidthMM = Get2DXinMM(fObjectWidth);// / m_fMMToPixelXValue;
                    float fHeightMM = Get2DYinMM(fObjectHeight);// / m_fMMToPixelYValue;
                    float fAreaMM = intObjectArea / m_fMMtoPixelAreaValue;/// m_fMMToPixelYValue / m_fMMToPixelXValue;

                    //if ((fWidthMM > m_fCrackLength) || (fHeightMM > m_fCrackLength) || (fAreaMM > m_fCrackArea) && ((m_intFailPkgOptionMask & 0x400) > 0 || (m_intFailPkgOptionMask & 0x800) > 0))
                    {
                        intFailCount++;
                        //0x04
                        m_intFailPkgResultMask |= 0x400;

                        Defect objDefect = new Defect();
                        objDefect.ref_fWidth = fObjectWidth;
                        objDefect.ref_fHeight = fObjectHeight;
                        objDefect.ref_fArea = intObjectArea;
                        objDefect.ref_fWidthInMM = fWidthMM;
                        objDefect.ref_fHeightInMM = fHeightMM;
                        objDefect.ref_fAreaInMM2 = fAreaMM;
                        objDefect.ref_strName = "Crack";
                        objDefect.ref_fCenterX = intROIStartX + fObjectCenterX;
                        objDefect.ref_fCenterY = intROIStartY + fObjectCenterY;
                        objDefect.ref_fAngle = fObjectAngle;
                        objDefect.ref_intFailMask = 0x400;
                        objDefect.ref_intImageNo = 2;

                        if ((m_intFailPkgOptionMask & 0x400) > 0)
                        {
                            if (fWidthMM > m_fDarkHorizontalCrack)
                            {
                                blnOverallResult = false;
                                objDefect.ref_fWidthFailValue = fWidthMM;
                                objDefect.ref_intFailCriteria |= 0x01;
                            }
                            if (fHeightMM > m_fDarkVerticalCrack)
                            {
                                blnOverallResult = false;
                                objDefect.ref_fHeightFailValue = fHeightMM;
                                objDefect.ref_intFailCriteria |= 0x02;
                            }
                        }

                        if ((m_intFailPkgOptionMask & 0x800) > 0)
                        {
                            if (fAreaMM > m_fCrackArea)
                            {
                                blnOverallResult = false;
                                objDefect.ref_fAreaFailValue = fAreaMM;
                                objDefect.ref_intFailCriteria |= 0x04;
                            }
                        }

                        m_arrPkgDefectList.Add(objDefect);
                    }

                }
            }

            objCrackROI.Dispose();

            return blnOverallResult;
        }

        public void DrawPkgDefect(Graphics g, float fDrawingScaleX, float fDrawingScaleY, int intDefectSelectingNumber)
        {
            lock (m_objLockBlobs)
            {
                /*
                 * Why add value 1 to Center X/Y , and minus value 1 to size?
                 * DrawRectangle tool will draw rectangle with start x y line outer the object, and end X Y line inner the object.
                 * Adding value 1 to center X and y will make sure rectangle is drawed with start xy inner the object.
                 * Reduct 1 value to size will make sure the end XY keep inner the object.
                 */
                if (m_blnLock)
                    return;

                Pen pen = new Pen(Color.Red, 1);
                Pen penLime = new Pen(Color.Lime, 1);

                for (int i = 0; i < m_arrPkgDefectList.Count; i++)
                {
                    if (m_blnLock)
                        return;

                    if (intDefectSelectingNumber == i)
                        pen = new Pen(Color.Yellow, 1);
                    else
                    {
                        if (m_arrPkgDefectList[i].ref_intFailCriteria > 0)
                        {
                            pen = new Pen(Color.Red, 1);
                        }
                        else
                        {
                            pen = new Pen(Color.Lime, 1);
                        }
                    }

                    float newX1 = 0, newY1 = 0;  // new point 1
                    float newX2 = 0, newY2 = 0; // new point 2
                    float newX3 = 0, newY3 = 0; // new point 3
                    float newX4 = 0, newY4 = 0; // new point 4


                    Math2.NewXYAfterRotate1(m_arrPkgDefectList[i].ref_fCenterX, m_arrPkgDefectList[i].ref_fCenterY, (m_arrPkgDefectList[i].ref_fCenterX - (m_arrPkgDefectList[i].ref_fWidth / 2)), (m_arrPkgDefectList[i].ref_fCenterY - (m_arrPkgDefectList[i].ref_fHeight / 2)), -m_arrPkgDefectList[i].ref_fAngle, ref newX1, ref newY1);
                    Math2.NewXYAfterRotate2(m_arrPkgDefectList[i].ref_fCenterX, m_arrPkgDefectList[i].ref_fCenterY, (m_arrPkgDefectList[i].ref_fCenterX - (m_arrPkgDefectList[i].ref_fWidth / 2)), (m_arrPkgDefectList[i].ref_fCenterY + (m_arrPkgDefectList[i].ref_fHeight / 2)), -m_arrPkgDefectList[i].ref_fAngle, ref newX2, ref newY2);
                    Math2.NewXYAfterRotate3(m_arrPkgDefectList[i].ref_fCenterX, m_arrPkgDefectList[i].ref_fCenterY, (m_arrPkgDefectList[i].ref_fCenterX + (m_arrPkgDefectList[i].ref_fWidth / 2)), (m_arrPkgDefectList[i].ref_fCenterY - (m_arrPkgDefectList[i].ref_fHeight / 2)), -m_arrPkgDefectList[i].ref_fAngle, ref newX3, ref newY3);
                    Math2.NewXYAfterRotate4(m_arrPkgDefectList[i].ref_fCenterX, m_arrPkgDefectList[i].ref_fCenterY, (m_arrPkgDefectList[i].ref_fCenterX + (m_arrPkgDefectList[i].ref_fWidth / 2)), (m_arrPkgDefectList[i].ref_fCenterY + (m_arrPkgDefectList[i].ref_fHeight / 2)), -m_arrPkgDefectList[i].ref_fAngle, ref newX4, ref newY4);

                    g.DrawLine(pen, newX1 * fDrawingScaleX, newY1 * fDrawingScaleY, (newX3) * fDrawingScaleX, (newY3) * fDrawingScaleY);
                    g.DrawLine(pen, newX2 * fDrawingScaleX, newY2 * fDrawingScaleY, (newX1) * fDrawingScaleX, (newY1) * fDrawingScaleY);
                    g.DrawLine(pen, newX2 * fDrawingScaleX, newY2 * fDrawingScaleY, (newX4) * fDrawingScaleX, (newY4) * fDrawingScaleY);
                    g.DrawLine(pen, newX4 * fDrawingScaleX, newY4 * fDrawingScaleY, (newX3) * fDrawingScaleX, (newY3) * fDrawingScaleY);

                }
            }
        }
        public List<List<string>> GetPkgDefectList()
        {
            List<List<string>> arrPkgDefectList = new List<List<string>>();

            for (int i = 0; i < m_arrPkgDefectList.Count; i++)
            {
                arrPkgDefectList.Add(new List<string>());
                arrPkgDefectList[i].Add(m_arrPkgDefectList[i].ref_intImageNo.ToString());
                arrPkgDefectList[i].Add(m_arrPkgDefectList[i].ref_intFailCriteria.ToString());
                arrPkgDefectList[i].Add(m_arrPkgDefectList[i].ref_strName);
                //arrPkgDefectList[i].Add(m_arrPkgDefectList[i].ref_fFailValue.ToString("F4"));
                arrPkgDefectList[i].Add(m_arrPkgDefectList[i].ref_fWidthInMM.ToString("F4"));
                arrPkgDefectList[i].Add(m_arrPkgDefectList[i].ref_fHeightInMM.ToString("F4"));
                arrPkgDefectList[i].Add(m_arrPkgDefectList[i].ref_fAreaInMM2.ToString("F6"));
            }

            return arrPkgDefectList;
        }
        /// <summary>
        /// Check which pkg defect object is selected
        /// </summary>
        /// <param name="intOrgX">mouse position X</param>
        /// <param name="intOrgY">mouse position Y</param>
        /// <returns>-1 = unable to match any object, other = selected pkg defect index</returns>
        public int SelectPkgDefectObject(int intOrgX, int intOrgY)
        {
            int intMatchNo = -1;

            if (m_arrPkgDefectList != null)
            {
                for (int i = 0; i < m_arrPkgDefectList.Count; i++)
                {
                    if ((intOrgX >= m_arrPkgDefectList[i].ref_fStartX && intOrgX <= m_arrPkgDefectList[i].ref_fEndX &&
                        (intOrgY >= m_arrPkgDefectList[i].ref_fStartY && intOrgY <= (m_arrPkgDefectList[i].ref_fEndY))))
                        intMatchNo = i;
                }
            }

            return intMatchNo;
        }




























        // ------------------ RectGauge4L Function ------------------------------------------------------------

        public void DrawGaugeResult_Rotated(Graphics g, float fDrawingScaleX, float fDrawingScaleY)
        {
            //lock (m_objLockBlobs)
            //{
            //    if (m_blnLock)
            //        return;

            //    m_objRectGauge4L.DrawGaugeResult_ResultLine_Rotated(g, fDrawingScaleX, fDrawingScaleY, m_intPadROIDirection);

            //}

            lock (m_objLockBlobs)
            {
                if (m_blnLock)
                    return;

                bool blnLineResultAllOK = true;
                for (int i = 0; i < m_objRectGauge4L.ref_arrLineResultOK.Length; i++)
                {
                    if (!m_objRectGauge4L.ref_arrLineResultOK[i])
                    {
                        blnLineResultAllOK = false;
                    }
                }

                if (blnLineResultAllOK) // 2019 10 09 - CCENG: if all gauge measurement pass, then only will draw 0 deg rectangle.
                    m_objRectGauge4L.DrawGaugeResult_ResultLine_Rotated(g, fDrawingScaleX, fDrawingScaleY, m_intLeadROIDirection);
                else
                    DrawGauge(g, fDrawingScaleX, fDrawingScaleY);

            }
        }

        public void DrawGaugeResult_EdgeNotFound(Graphics g, float fDrawingScaleX, float fDrawingScaleY)
        {
            lock (m_objLockBlobs)
            {
                if (m_blnLock)
                    return;

                m_objRectGauge4L.DrawGaugeResult_EdgeNotFound(g, fDrawingScaleX, fDrawingScaleY);

            }
        }

        public void DrawGauge(Graphics g, float fDrawingScaleX, float fDrawingScaleY)
        {
            lock (m_objLockBlobs)
            {
                if (m_blnLock)
                    return;

                if (m_blnDrawSamplingPoint)
                    m_objRectGauge4L.DrawGaugeResult_SamplingPoint(g);
                if (m_blnDrawDraggingBox)
                    m_objRectGauge4L.DrawGaugeSetting_Inside(g, fDrawingScaleX, fDrawingScaleY);
                else
                    m_objRectGauge4L.DrawGaugeResult_ResultLine(g, fDrawingScaleX, fDrawingScaleY);

            }
        }

        public void DrawGauge_ForLearning(Graphics g, float fDrawingScaleX, float fDrawingScaleY)
        {
            lock (m_objLockBlobs)
            {
                if (m_blnLock)
                    return;

                if (m_blnDrawSamplingPoint)
                    m_objRectGauge4L.DrawGaugeResult_SamplingPoint_ForLearning(g, m_intSelectedGaugeEdgeMask);
                if (m_blnDrawDraggingBox)
                {
                    //m_objRectGauge4L.DrawGaugeSetting_Inside(g, fDrawingScaleX, fDrawingScaleY);
                }
                else
                    m_objRectGauge4L.DrawGaugeResult_ResultLine(g, fDrawingScaleX, fDrawingScaleY);

                if (m_blnDrawTransitionTypeArrow)
                    m_objRectGauge4L.DrawGaugeSetting_TransitionTypeArrow(g, fDrawingScaleX, fDrawingScaleY, m_intSelectedGaugeEdgeMask);
            }
        }

        /// <summary>
        /// measure the die edge using rectangle gauge
        /// </summary>
        /// <param name="g">target pictire box to draw</param>
        /// <param name="objROI">source image for measuring</param>
        public bool MeasureEdge_UsingRectGauge4L(ImageDrawing objImage, ImageDrawing objWhiteImage)
        {
            //if (m_objRectGauge4L.Measure_Pad5SPackage(objImage, false))
            if (m_objRectGauge4L.Measure_Pad5SPackage_WithDontCareArea(objImage, false, objWhiteImage))
                return true;
            else
            {
                m_strErrorMessage = m_objRectGauge4L.ref_strErrorMessage;
                return false;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="intValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        /// <returns></returns>
        public float GetResultUpWidth_RectGauge4L(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_objRectGauge4L.ref_fRectUpWidth;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return Get2DXinMM(m_objRectGauge4L.ref_fRectUpWidth) * m_fMMToUnitValue; //m_objRectGauge4L.ref_fRectUpWidth * m_fMMPerPixelX * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="intValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        /// <returns></returns>
        public float GetResultDownWidth_RectGauge4L(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_objRectGauge4L.ref_fRectDownWidth;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return Get2DXinMM(m_objRectGauge4L.ref_fRectDownWidth) * m_fMMToUnitValue;//m_objRectGauge4L.ref_fRectDownWidth * m_fMMPerPixelX * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="intValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        /// <returns></returns>
        public float GetResultMaxWidth_RectGauge4L(int intValueType)
        {
            if (m_objRectGauge4L.ref_fRectDownWidth > m_objRectGauge4L.ref_fRectUpWidth)
                return GetResultDownWidth_RectGauge4L(intValueType);
            else
                return GetResultUpWidth_RectGauge4L(intValueType);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="intValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        /// <returns></returns>
        public float GetResultLeftHeight_RectGauge4L(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_objRectGauge4L.ref_fRectLeftHeight;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return Get2DYinMM(m_objRectGauge4L.ref_fRectLeftHeight) * m_fMMToUnitValue; //m_objRectGauge4L.ref_fRectLeftHeight * m_fMMPerPixelY * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="intValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        /// <returns></returns>
        public float GetResultRightHeight_RectGauge4L(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_objRectGauge4L.ref_fRectRightHeight;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return Get2DYinMM(m_objRectGauge4L.ref_fRectRightHeight) * m_fMMToUnitValue;//m_objRectGauge4L.ref_fRectRightHeight * m_fMMPerPixelY * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="intValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        /// <returns></returns>
        public float GetResultMaxHeight_RectGauge4L(int intValueType)
        {
            if (m_objRectGauge4L.ref_fRectLeftHeight > m_objRectGauge4L.ref_fRectRightHeight)
                return GetResultLeftHeight_RectGauge4L(intValueType);
            else
                return GetResultRightHeight_RectGauge4L(intValueType);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public float GetResultAngle_RectGauge4L()
        {
            return m_objRectGauge4L.ref_fRectAngle;
        }

        public PointF GetResultCenterPoint_RectGauge4L()
        {
            return m_objRectGauge4L.ref_pRectCenterPoint;
        }
        public bool GetRectGauge4LPassFail(int intPadIndex)
        {
            switch (intPadIndex)
            {
                case 0: // Center ROI
                    if (m_objRectGauge4L.ref_arrLineResultOK[0] && m_objRectGauge4L.ref_arrLineResultOK[1] && m_objRectGauge4L.ref_arrLineResultOK[2] && m_objRectGauge4L.ref_arrLineResultOK[3])
                        return true;
                    break;
                case 1: // Top ROI (bottom gauge can be ignored)
                    if (m_objRectGauge4L.ref_arrLineResultOK[0] && m_objRectGauge4L.ref_arrLineResultOK[1] && m_objRectGauge4L.ref_arrLineResultOK[3])
                        return true;
                    break;
                case 2: // Right ROI (Left gauge can be ignored)
                    if (m_objRectGauge4L.ref_arrLineResultOK[0] && m_objRectGauge4L.ref_arrLineResultOK[1] && m_objRectGauge4L.ref_arrLineResultOK[2])
                        return true;
                    break;
                case 3: // Botom ROI (Top gauge can be ignored)
                    if (m_objRectGauge4L.ref_arrLineResultOK[1] && m_objRectGauge4L.ref_arrLineResultOK[2] && m_objRectGauge4L.ref_arrLineResultOK[3])
                        return true;
                    break;
                case 4: // Left ROI (Right gauge can be ignored)
                    if (m_objRectGauge4L.ref_arrLineResultOK[0] && m_objRectGauge4L.ref_arrLineResultOK[2] && m_objRectGauge4L.ref_arrLineResultOK[3])
                        return true;
                    break;
            }
            return false;
        }
        public bool IsGaugeMeasureOK(int intPadIndex)
        {
            return m_objRectGauge4L.IsGaugeMeasureOK(intPadIndex);
        }
        public void SetCurrentMeasureSizeAsUnitSize()
        {
            m_objRectGauge4L.SetCurrentMeasureSizeAsUnitSize();
        }

        public bool MeasureEdge_ResetGaugePlaceUsingPRPositionBeforeMeasure(ImageDrawing objImage, ImageDrawing objWhiteImage)
        {
            m_objRectGauge4L.SetGaugeToleranceToTemplate();

            if (m_pUnitCenterPoint.X > 0 && m_pUnitCenterPoint.Y > 0)
            {
                m_objRectGauge4L.SetGaugePlace(m_pUnitCenterPoint.X, m_pUnitCenterPoint.Y);
                m_objRectGauge4L.SetGaugeAngle(m_fUnitAngle);
            }
            else // If unit pattern not found, use center point of pkg found using corner point method
            {
                m_objRectGauge4L.SetGaugePlace_WithOffset(m_pCornerPoint_Center.X, m_pCornerPoint_Center.Y, m_fCenterUnitWidth, m_fCenterUnitHeight);
                m_objRectGauge4L.SetGaugeAngle(m_fCenterUnitAngle);
            }


            // Make sure RectGauge4L is using User Setting
            m_objRectGauge4L.ResetGaugeSettingToUserVariables();

            //if (m_objRectGauge4L.Measure_Pad5SPackage(objImage, false))
            if (m_objRectGauge4L.Measure_Pad5SPackage_WithDontCareArea(objImage, false, objWhiteImage))
            {
                //if (m_objRectGauge4L.ref_arrLineResultOK[0] && m_objRectGauge4L.ref_arrLineResultOK[1] && m_objRectGauge4L.ref_arrLineResultOK[2] && m_objRectGauge4L.ref_arrLineResultOK[3])
                return true;
                //else
                // {
                //    return false;
                //}
            }
            else
            {
                m_strErrorMessage = m_objRectGauge4L.ref_strErrorMessage;
                return false;
            }
        }
        public void GetAGVROIToleranceValue(int intLeadID, ref int intTolTop, ref int intTolRight, ref int intTolBottom, ref int intTolLeft)
        {
            if (intLeadID > m_arrTemplateBlobLeads.Count)
                return;

            m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[intLeadID];

            intTolTop = m_stcBlobLead.intAGVROITolerance_Top;
            intTolRight = m_stcBlobLead.intAGVROITolerance_Right;
            intTolBottom = m_stcBlobLead.intAGVROITolerance_Bottom;
            intTolLeft = m_stcBlobLead.intAGVROITolerance_Left;

        }
        public void SetAGVROIToleranceValue(int intLeadID, int intDirection, int intTolValue)
        {
            if (intLeadID > m_arrTemplateBlobLeads.Count)
                return;
            BlobsFeatures stcBlobsFeatures = new BlobsFeatures();
            m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[intLeadID];

            switch (intDirection)
            {
                case 1:
                    m_stcBlobLead.intAGVROITolerance_Top = intTolValue;
                    break;
                case 2:
                    m_stcBlobLead.intAGVROITolerance_Right = intTolValue;
                    break;
                case 3:
                    m_stcBlobLead.intAGVROITolerance_Bottom = intTolValue;
                    break;
                case 4:
                    m_stcBlobLead.intAGVROITolerance_Left = intTolValue;
                    break;
            }
            stcBlobsFeatures = m_stcBlobLead;
            m_arrTemplateBlobLeads[intLeadID] = stcBlobsFeatures;

        }

        public void DrawAGVROITolerance(Graphics g, float fScaleX, float fScaleY, int intLeadIndex, int intROIX, int intROIY, Color objColor)
        {
            if (m_arrSampleBlobLeads == null)
                return;

            if (intLeadIndex >= m_arrSampleBlobLeads.Length)
                return;
            float fStartX = 0, fStartY = 0, fWidth = 0, fHeight = 0;

            m_stcSampleBlobLead = (SampleBlobsFeatures)m_arrSampleBlobLeads[intLeadIndex];
            m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[intLeadIndex];
            switch (m_stcSampleBlobLead.intDirection)
            {
                case 4: // Top
                    fStartX = (intROIX + m_stcSampleBlobLead.fTipCenterX - (m_stcSampleBlobLead.fTipWidth / 2) + m_stcBlobLead.intAGVROITolerance_Left) * fScaleX;
                    fStartY = (intROIY + m_stcSampleBlobLead.fTipCenterY + m_stcBlobLead.intAGVROITolerance_Top) * fScaleY;
                    fWidth = (m_stcSampleBlobLead.fTipWidth - m_stcBlobLead.intAGVROITolerance_Left - m_stcBlobLead.intAGVROITolerance_Right) * fScaleX;
                    fHeight = (m_stcSampleBlobLead.fTipLength - m_stcBlobLead.intAGVROITolerance_Top - m_stcBlobLead.intAGVROITolerance_Bottom) * fScaleY;
                    break;
                case 8: // Bottom
                    fStartX = (intROIX + m_stcSampleBlobLead.fTipCenterX - (m_stcSampleBlobLead.fTipWidth / 2) + m_stcBlobLead.intAGVROITolerance_Left) * fScaleX;
                    fStartY = (intROIY + m_stcSampleBlobLead.fTipCenterY - m_stcSampleBlobLead.fTipLength + m_stcBlobLead.intAGVROITolerance_Top) * fScaleY;
                    fWidth = (m_stcSampleBlobLead.fTipWidth - m_stcBlobLead.intAGVROITolerance_Left - m_stcBlobLead.intAGVROITolerance_Right) * fScaleX;
                    fHeight = (m_stcSampleBlobLead.fTipLength - m_stcBlobLead.intAGVROITolerance_Top - m_stcBlobLead.intAGVROITolerance_Bottom) * fScaleY;
                    break;
                case 1: // Left
                    fStartX = (intROIX + m_stcSampleBlobLead.fTipCenterX + m_stcBlobLead.intAGVROITolerance_Left) * fScaleX;
                    fStartY = (intROIY + m_stcSampleBlobLead.fTipCenterY - (m_stcSampleBlobLead.fTipWidth / 2) + m_stcBlobLead.intAGVROITolerance_Top) * fScaleY;
                    fWidth = (m_stcSampleBlobLead.fTipLength - m_stcBlobLead.intAGVROITolerance_Left - m_stcBlobLead.intAGVROITolerance_Right) * fScaleX;
                    fHeight = (m_stcSampleBlobLead.fTipWidth - m_stcBlobLead.intAGVROITolerance_Top - m_stcBlobLead.intAGVROITolerance_Bottom) * fScaleY;
                    break;
                case 2: // Right
                    fStartX = (intROIX + m_stcSampleBlobLead.fTipCenterX - m_stcSampleBlobLead.fTipLength + m_stcBlobLead.intAGVROITolerance_Left) * fScaleX;
                    fStartY = (intROIY + m_stcSampleBlobLead.fTipCenterY - (m_stcSampleBlobLead.fTipWidth / 2) + m_stcBlobLead.intAGVROITolerance_Top) * fScaleY;
                    fWidth = (m_stcSampleBlobLead.fTipLength - m_stcBlobLead.intAGVROITolerance_Left - m_stcBlobLead.intAGVROITolerance_Right) * fScaleX;
                    fHeight = (m_stcSampleBlobLead.fTipWidth - m_stcBlobLead.intAGVROITolerance_Top - m_stcBlobLead.intAGVROITolerance_Bottom) * fScaleY;
                    break;
            }
            g.DrawRectangle(new Pen(objColor, 1), fStartX, fStartY, fWidth, fHeight);
        }

        public void SortSideLeadSamples(List<int> arrLeadID)
        {
            for (int i = 0; i < arrLeadID.Count; i++)
            {
                for (int j = 0; j < m_arrSampleBlobSideLeads.Count; j++)
                {
                    if (arrLeadID[i] == m_arrSampleBlobSideLeads[j].intNoID)
                    {
                        m_stcBlobLead = m_arrSampleBlobSideLeads[j];
                        m_arrSampleBlobSideLeads.RemoveAt(j);
                        m_arrSampleBlobSideLeads.Insert(i, m_stcBlobLead);
                        break;
                    }
                }
            }
        }

        public bool CheckLeadCountTally()
        {
            if (m_intNumberOfLead != m_arrTemplateBlobLeads.Count)
            {
                return false;
            }

            if (m_intLeadDirection == 0)
            {
                int intLeftLeadCount = 0;
                int intRightLeadCount = 0;
                for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
                {
                    if (((BlobsFeatures)m_arrTemplateBlobLeads[i]).intDirection == 2)
                    {
                        intRightLeadCount++;
                    }

                    if (((BlobsFeatures)m_arrTemplateBlobLeads[i]).intDirection == 1)
                    {
                        intLeftLeadCount++;
                    }
                }

                if (intLeftLeadCount != m_intNumberOfLead_Left || intRightLeadCount != m_intNumberOfLead_Right)
                    return false;
            }
            else
            {
                int intTopLeadCount = 0;
                int intBottomLeadCount = 0;
                for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
                {
                    if (((BlobsFeatures)m_arrTemplateBlobLeads[i]).intDirection == 8)
                    {
                        intBottomLeadCount++;
                    }
                    if (((BlobsFeatures)m_arrTemplateBlobLeads[i]).intDirection == 4)
                    {
                        intTopLeadCount++;
                    }
                }

                if (intTopLeadCount != m_intNumberOfLead_Top || intBottomLeadCount != m_intNumberOfLead_Bottom)
                    return false;
            }
            return true;
        }
        public int[] GetEdgeImageViewNo()
        {
            return m_objRectGauge4L.GetGaugeImageNoList();
        }

        public void AssignFilterBlob()
        {
            m_arrTemplateFilteredBlobLeads = new ArrayList();
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                BlobsFeatures stcBlobTemp = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                if (!stcBlobTemp.blnSelected)
                    m_arrTemplateFilteredBlobLeads.Add(stcBlobTemp);
            }
        }
        public void ClearFilterBlob()
        {
            m_arrTemplateFilteredBlobLeads = new ArrayList();
        }

        private void FilterBlob()
        {
            for (int i = 0; i < m_arrTemplateFilteredBlobLeads.Count; i++)
            {
                BlobsFeatures stcFilterBlob = (BlobsFeatures)m_arrTemplateFilteredBlobLeads[i];
                for (int j = 0; j < m_arrTemplateBlobLeads.Count; j++)
                {
                    BlobsFeatures stcTemplateBlob = (BlobsFeatures)m_arrTemplateBlobLeads[j];
                    // template blob will smaller or equal to filter blob
                    if (stcTemplateBlob.fStartX >= (stcFilterBlob.fStartX - 1) &&
                        stcTemplateBlob.fStartY >= (stcFilterBlob.fStartY - 1) &&
                        stcTemplateBlob.fEndX <= (stcFilterBlob.fEndX + 1) &&
                        stcTemplateBlob.fEndY <= (stcFilterBlob.fEndY + 1))
                    {
                        m_arrTemplateBlobLeads.RemoveAt(j);
                        j--;
                    }
                }
            }
        }
        private void ScanMaxUsingGaugePoint(float fTipCenterX, float fTipCenterY, float fLeadWidth, float fPointGaugeTolerance, float fPointGaugeAngle, ROI objROI,
                                                ref float fPointGaugeResultMaxX, ref float fPointGaugeResultMaxY, int intLeadIndex)
        {
            fPointGaugeResultMaxY = 0;
            fPointGaugeResultMaxX = 0;

            switch (m_intLeadROIDirection)
            {
                case 1: // Top
                    {
                        // Define scanning range
                        int intStartRangeX = (int)Math.Ceiling(fTipCenterX - fLeadWidth / 2);
                        int intEndRangeX = (int)Math.Floor(fTipCenterX + fLeadWidth / 2);

                        // Scan Lead start point range
                        for (int g = intStartRangeX; g < intEndRangeX; g++)
                        {
                            m_arrSidePointGauge[intLeadIndex][(int)PointIndex_Side.TipCenter].SetGaugePlacement(g,
                                                                   fTipCenterY,
                                                                   fPointGaugeTolerance, fPointGaugeAngle);

                            m_arrSidePointGauge[intLeadIndex][(int)PointIndex_Side.TipCenter].Measure(objROI);

                            PointF p;
                            if (m_arrSidePointGauge[intLeadIndex][(int)PointIndex_Side.TipCenter].ref_intMeasuredPointCount > 0)
                            {
                                p = m_arrSidePointGauge[intLeadIndex][(int)PointIndex_Side.TipCenter].GetMeasurePoint(0);

                                if (fPointGaugeResultMaxY == 0 || fPointGaugeResultMaxY > p.Y)
                                {
                                    fPointGaugeResultMaxY = p.Y;
                                    fPointGaugeResultMaxX = p.X;
                                }
                            }
                        }
                    }
                    break;
                case 2: // Right
                    {
                        // Define scanning range
                        int intStartRangeY = (int)Math.Ceiling(fTipCenterY - fLeadWidth / 2);
                        int intEndRangeY = (int)Math.Floor(fTipCenterY + fLeadWidth / 2);

                        // Scan Lead start point range
                        for (int g = intStartRangeY; g < intEndRangeY; g++)
                        {
                            m_arrSidePointGauge[intLeadIndex][(int)PointIndex_Side.TipCenter].SetGaugePlacement(fTipCenterX,
                                                                   g,
                                                                   fPointGaugeTolerance, fPointGaugeAngle);

                            m_arrSidePointGauge[intLeadIndex][(int)PointIndex_Side.TipCenter].Measure(objROI);

                            PointF p;
                            if (m_arrSidePointGauge[intLeadIndex][(int)PointIndex_Side.TipCenter].ref_intMeasuredPointCount > 0)
                            {
                                p = m_arrSidePointGauge[intLeadIndex][(int)PointIndex_Side.TipCenter].GetMeasurePoint(0);

                                if (fPointGaugeResultMaxY == 0 || fPointGaugeResultMaxX < p.X)
                                {
                                    fPointGaugeResultMaxY = p.Y;
                                    fPointGaugeResultMaxX = p.X;
                                }
                            }
                        }
                    }
                    break;
                case 3: // Bottom
                    {
                        // Define scanning range
                        int intStartRangeX = (int)Math.Ceiling(fTipCenterX - fLeadWidth / 2);
                        int intEndRangeX = (int)Math.Floor(fTipCenterX + fLeadWidth / 2);

                        // Scan Lead start point range
                        for (int g = intStartRangeX; g < intEndRangeX; g++)
                        {
                            m_arrSidePointGauge[intLeadIndex][(int)PointIndex_Side.TipCenter].SetGaugePlacement(g,
                                                                   fTipCenterY,
                                                                   fPointGaugeTolerance, fPointGaugeAngle);

                            m_arrSidePointGauge[intLeadIndex][(int)PointIndex_Side.TipCenter].Measure(objROI);

                            PointF p;
                            if (m_arrSidePointGauge[intLeadIndex][(int)PointIndex_Side.TipCenter].ref_intMeasuredPointCount > 0)
                            {
                                p = m_arrSidePointGauge[intLeadIndex][(int)PointIndex_Side.TipCenter].GetMeasurePoint(0);

                                if (fPointGaugeResultMaxY == 0 || fPointGaugeResultMaxY < p.Y)
                                {
                                    fPointGaugeResultMaxY = p.Y;
                                    fPointGaugeResultMaxX = p.X;
                                }
                            }
                        }
                    }
                    break;
                case 4: // Left
                    {
                        // Define scanning range
                        int intStartRangeY = (int)Math.Ceiling(fTipCenterY - fLeadWidth / 2);
                        int intEndRangeY = (int)Math.Floor(fTipCenterY + fLeadWidth / 2);

                        // Scan Lead start point range
                        for (int g = intStartRangeY; g < intEndRangeY; g++)
                        {
                            m_arrSidePointGauge[intLeadIndex][(int)PointIndex_Side.TipCenter].SetGaugePlacement(fTipCenterX,
                                                                   g,
                                                                   fPointGaugeTolerance, fPointGaugeAngle);

                            m_arrSidePointGauge[intLeadIndex][(int)PointIndex_Side.TipCenter].Measure(objROI);

                            PointF p;
                            if (m_arrSidePointGauge[intLeadIndex][(int)PointIndex_Side.TipCenter].ref_intMeasuredPointCount > 0)
                            {
                                p = m_arrSidePointGauge[intLeadIndex][(int)PointIndex_Side.TipCenter].GetMeasurePoint(0);

                                if (p.X > 0 && p.Y > 0)
                                {
                                    if (fPointGaugeResultMaxY == 0 || fPointGaugeResultMaxX > p.X)
                                    {
                                        fPointGaugeResultMaxY = p.Y;
                                        fPointGaugeResultMaxX = p.X;
                                    }
                                }
                            }
                        }
                    }
                    break;

            }


        }

        public void ProduceDontCareImage(ROI objROI, ImageDrawing objImage)
        {
            ROI objDontCareROI = new ROI();
            ROI objInspectROI = new ROI();
            objInspectROI.AttachImage(objImage);
            if (m_intLeadROIDirection == 0)
            {
                objInspectROI.LoadROISetting(objROI.ref_ROIPositionX, objROI.ref_ROIPositionY, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
                objDontCareROI.LoadROISetting(0, 0, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
                objDontCareROI.AttachImage(m_objLead3DDontCareImage);
                ROI.SubtractROI(objInspectROI, objDontCareROI);
            }
            else
            {
                objInspectROI.LoadROISetting(objROI.ref_ROIPositionX, objROI.ref_ROIPositionY, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
                objDontCareROI.LoadROISetting(0, 0, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
                objDontCareROI.AttachImage(m_objLead3DDontCareImage);
                ROI.LogicOperationAddROI(objInspectROI, objDontCareROI);
            
            }
            objInspectROI.Dispose();
            objDontCareROI.Dispose();
        }
    }
}
