using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using System.IO;
using Common;
using System.Windows.Forms;
#if (Debug_2_12 || Release_2_12)
using Euresys.Open_eVision_2_12;
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
using Euresys.Open_eVision_1_2;
#endif

namespace VisionProcessing
{
    public class Lead
    {
        #region enum

        public enum PointIndex { BaseCenter = 0, BaseStart = 1, BaseEnd = 2, TipCenter = 3, TipStart = 4, TipEnd = 5};

        #endregion

        #region Member Variables
        private bool m_blnFlipToOppositeFunction = false;
        private int m_intDontCareBlobThreshold = 125;
        private int m_intMaxShadowArea = 500;
        private int m_intMinShadowArea = 0;
        private int m_intMaxShadowWidth = 10;
        private int m_intDontCareBlobROIInward = 0;

        private int m_intLeadROITolerance_Top = 0;
        private int m_intLeadROITolerance_Right = 0;
        private int m_intLeadROITolerance_Bottom = 0;
        private int m_intLeadROITolerance_Left = 0;

        private float m_fPatternROIOffsetX = 0;
        private float m_fPatternROIOffsetY = 0;
        private bool m_blnWantInspectBaseLead = false;
        private bool m_blnInspectLead;
        private float m_fUnitAverageCenterX = 0;
        private float m_fUnitAverageCenterY = 0;
        private int m_intRotationMethod = 0; // 0: Unit PR; 1: Base Line; 2: Gauge
        private int m_intLeadAngleTolerance = 10;
        private bool m_blnGotPackage = false;
        private int m_intImageViewNo = 0;
        private int m_intBaseLeadImageViewNo = 0;
        private bool m_blnWhiteOnBlack = true;
        private bool m_blnSelected = false;
        private Font m_Font = new Font("Verdana", 10);
        //private int m_intCheckLeadDimensionImageIndex = 0;
        private float m_fImageGain = 1f;
        private ArrayList m_arrTemplateBlobLeads = new ArrayList();
        private ArrayList m_arrTemplateBlobLeads_BaseLead = new ArrayList();
        private ArrayList m_arrTemporaryBlobLeads = new ArrayList();
        private ArrayList m_arrTemporaryBlobLeads_BaseLead = new ArrayList();
        private ArrayList m_arrBackupTemplateBlobLeads = new ArrayList();
        private ArrayList m_arrBackupTemplateBlobLeads_BaseLead = new ArrayList();
        private EBlobs m_objEBlobs = new EBlobs();
        private EBlobs m_objEBlobs_BaseLead = new EBlobs();
        private EBlobs m_objExtraLeadEBlobs = new EBlobs();
        private List<EBlobs> m_arrEBlobs = new List<EBlobs>();
        private BlobsFeatures m_stcBlobLead = new BlobsFeatures();
        private SampleBlobsFeatures[] m_arrSampleBlobLeads;          // sample blobs
        private SampleBlobsFeatures[] m_arrSampleBlobLeads_BaseLead;          // sample blobs
        private List<SampleExtraBlobsFeatures> m_arrExtraBlobs; // Extra lead, join lead
        private ToleranceBlobsFeatures m_stcBackupTemplateBlobLead = new ToleranceBlobsFeatures();   // Keep previous tolerance setting for learning 
        private List<PitchGap> m_arrPitchGap = new List<PitchGap>();
        private List<PitchGap> m_arrBackupPitchGap = new List<PitchGap>();
        private List<PitchGap> m_arrFailPitchGapList;
        private PitchGap m_stcPitchGap = new PitchGap();
        private TolerancePitchGap m_stcTolePitchGap = new TolerancePitchGap();      // Keep previous tolerance setting for learning
        private ArrayList m_arrTolePitchGap = new ArrayList();
        private int m_intThresholdValue = -4;
        private int m_intThresholdValue_BaseLead = -4;
        private int m_intThresholdValuePrev = -4;
        private int m_intTightSettingThresholdTolerance = 25;
        private int m_intEmptyThreshold = 125;
        private int m_intInterLeadThresholdValue = -4;
        private int m_intDarkThresholdValue = -4;
        private int m_intLeadROIDirection = 0;  //0=Center, 1=Top, 2=Right, 3=Bottom, 4=Left
        private float m_fTightSettingTolerance = 0.01f;
        private int m_intFilterMinArea = 20;
        private int m_intFilterMinArea_BaseLead = 20;
        private float m_fBlobsMinArea = 200f;
        private int m_intMaxArea = 25000000;
        private Contour[] m_arrTemplateContour;
        private bool m_blnWantUseClosestSizeDefineTolerance = false;
        private float m_fDefineSizePixel = 3;       // Use to define lead's direction mask(left, right, top, bottom or/and center)
        private int m_intNumberOfLead = 1;
        private float m_fDefaultPixelTolerance = 3; // For lead dimension default min and max tolerance.
        private bool m_blnViewLeadResultDrawing = false;
        private int m_intSensitivityOnLeadMethod = 0;    // 0=No add Sensitivity Feature On Lead, 1= Add Split Feature On Lead, 2=Add Merge Feature On Lead
        private int m_intSensitivityOnLeadValue = 0;     // 1 to 10
        private bool m_blnWantTightSetting = false;
        //private int m_intBaseOffset = 0; //offset from base to calculate base width
        //private int m_intTipOffset = 0; //offset from tip to calculate top width
        private bool m_blnClockWise = false; //true=clockwise, false=counterclockwise 
        private int m_intFirstLead = 0; //Use to define position of first lead (0=top, 1=right, 2=bottom, 3=left)
        private int m_intBaseLineTrimFromEdge = 6;  // Use for Side ROI to get correct base line when multi baseline steps case happen. It will trim edge of base line width before measure the base line.
        private int m_intBaseLineSteps = 1; // Use for Side ROI to get correct base line when multi baseline steps case happen. Sequence will loop base on this m_intBaseLineSteps value to get measure base line.
        // 0x01: CheckForeignMaterialLength/Area, 
        //0xC0: Width/Length, 
        //0x100: offset, 
        //0x200 & 0x400: pitch, gap
        //0x800: variance, 
        //0x1000: span, 
        //0x2000: CheckForeignMaterialTotalArea, 
        //0x4000: Average Gray Value, 
        //0x8000: Skew
        //0x10000: Base Offset
        //0x20000: Base Area
        private int m_intFailOptionMask = 0;
        private bool m_blnLock = false;
        private Object m_objLockBlobs = new Object();
        private GaugeWorldShape m_objWorldShape;
        private PGauge m_objPointGauge;
        private PGauge m_objSettingPointGauge;
        private List<List<PGauge>> m_arrPointGauge = new List<List<PGauge>>();
        private List<List<PGauge>> m_arrSettingPointGauge = new List<List<PGauge>>();
        private List<List<float>> m_arrLeadPointGaugeStartX = new List<List<float>>();
        private List<List<float>> m_arrLeadPointGaugeStartY = new List<List<float>>();
        private List<List<float>> m_arrLeadPointGaugeTolerance = new List<List<float>>();
        private List<List<float>> m_arrLeadPointGaugeAngle = new List<List<float>>();
        private List<List<PointF>> m_arrLeadEdgeGaugePoints = new List<List<PointF>>();
        private List<List<bool>> m_arrLeadEdgeGaugePointsFound = new List<List<bool>>();
        private List<int> m_arrLeadEdgeGaugePointsPosition = new List<int>();
        private List<int> m_arrLeadEdgeGaugePointsIDNo = new List<int>();
        private bool m_blnWantUseGaugeMeasureLeadDimension = false;
        private bool m_blnWantUsePkgToBaseTolerance = false;
        private bool m_blnWantUseAverageGrayValueMethod = false;
        private bool m_blnWantPocketDontCareAreaFix_Lead = false;
        private bool m_blnWantPocketDontCareAreaManual_Lead = false;
        private bool m_blnWantPocketDontCareAreaAuto_Lead = false;
        private bool m_blnWantPocketDontCareAreaBlob_Lead = false;
        private int m_intPocketDontCareMethod = 0; // 0: Standard , 1: SRM1
        private bool m_blnWantUseAGVMasking = true;

        private LGauge2 m_objPocketEdgeGauge;
        private int m_intLineOffset = 0;
        private int m_intMaskThickness = 0;
        private float m_fPointGaugeToleranceRate = 1f / 8f;
        private int m_intPointGaugeLoopMax = 6;
        /// <summary>
        /// 0x01=Stand Off
        /// 0x02=Coplan
        /// 0x04=LeadSweeps
        /// 0x08=Solder Pad Length
        /// 0x10=Un-Cut Tiebar
        /// 0x20=
        /// 0x40=Width
        /// 0x80=Height or Length
        /// 0x100=offset
        /// 0x200=pitch
        /// 0x400=gap
        /// 0x800=Length variance
        /// 0x1000=Span
        /// 0x2000=Pitch Variance
        /// 0x4000=Stand Off Variance 
        /// </summary>

        // New Variables for Lead
        // 2020-07-21 ZJYEOH : use m_intLeadROIDirection instead of m_intLeadDirection to handle direction easier
        //private int m_intLeadDirection = 0;  // 0=Horizontal, 1=Vertical
        // Lead3D
        private LGauge[] m_arrLineGauge = new LGauge[4];   // Use to measure unit base one in side ROI. Index 0=Top, 1=Right, 2=Botom; 3=Left
        private ROI m_objLocalROI = new ROI();
        private int m_intNumberOfLead_Top = 0;
        private int m_intNumberOfLead_Bottom = 0;
        private int m_intNumberOfLead_Left = 0;
        private int m_intNumberOfLead_Right = 0;
        private PointF m_pCornerPoint_Left = new PointF(0, 0);
        private PointF m_pCornerPoint_Right = new PointF(0, 0);
        private PointF m_pCornerPoint_Top = new PointF(0, 0);
        private PointF m_pCornerPoint_Bottom = new PointF(0, 0);
        private PointF m_pCornerPoint_TopLeft = new PointF(0, 0);
        private PointF m_pCornerPoint_TopRight = new PointF(0, 0);
        private PointF m_pCornerPoint_BottomLeft = new PointF(0, 0);
        private PointF m_pCornerPoint_BottomRight = new PointF(0, 0);
        private PointF m_pCornerPoint_Center = new PointF(0, 0);
        private float m_fCenterUnitAngle = 0;
        private float m_fCenterUnitWidth = 0;
        private float m_fCenterUnitHeight = 0;
        private float m_fBaseLineAngle = 0;
        private float m_fCenterUnitCompensateAngle_ForDrawing = 0;
        private float m_fRotateCenterX_ForDrawing = 0;
        private float m_fRotateCenterY_ForDrawing = 0;
        private Line m_objBaseLine = new Line();
        private Line m_objEdgeLine_Left = new Line();
        private Line m_objEdgeLine_Right = new Line();
        private Line m_objEdgeLine_Top = new Line();
        private Line m_objEdgeLine_Bottom = new Line();


        /// <summary>
        // 0x01: Fail Reference Point
        // 0x02: Bridge
        // 0x04: Missing Lead
        // 0x08: 
        // 0x10: 
        // 0x20: Contamination
        // 0x40: Width
        // 0x80: Height
        // 0x100: OffSet
        // 0x200: Pitch
        // 0x400: Gap
        // 0x800: Variance
        // 0x1000: Span
        // 0x2000: Total Contamination Area
        // 0x4000: Average Gray Value
        // 0x8000: Skew
        /// </summary>
        private int m_intFailResultMask = 0;
        private bool m_blnFailForeignMaterialLength = false;
        private bool m_blnFailForeignMaterialArea = false;
        private bool m_blnFailForeignMaterialTotalArea = false;

        // 0x01: Package Size
        // 0x02: Crack
        // 0x04: Chipped Off
        // 0x08: Scratches
        // 0x10: Contamination
        // 0x20: Solder melt
        // 0x40: Void
        // 0x80: Mold Flash
        // 0x100: Incomplete Plating

        /// </summary>
        private int[] m_intTemplateMatchStatus;
        private int[] m_intTemplateMatchStatus_BaseLead;
        private int[] m_intSampleMatchNumber;
        private int[] m_intSampleMatchNumber_BaseLead;
        private List<int> m_arrSampleMatchNumber = new List<int>();
        private float m_fLeadRangeStartX;
        private float m_fLeadRangeStartY;
        private float m_fLeadRangeEndX;
        private float m_fLeadRangeEndY;
        private float m_fSampleLeadRangeStartX;
        private float m_fSampleLeadRangeStartY;
        private float m_fSampleLeadRangeEndX;
        private float m_fSampleLeadRangeEndY;

        //Template Length Various Setting
        private float m_fTemplateLengthVarianceMaxLimit = 0;

        //Template span data
        private float m_fLeadMinSpanStart;
        private float m_fLeadMinSpanEnd;
        private float m_fLeadMaxSpanStart;
        private float m_fLeadMaxSpanEnd;
        private float m_fTemplateLeadMinSpanLimit;
        private float m_fTemplateLeadMaxSpanLimit;

        //Sample span data
        private float m_fSampleLeadMinSpanStart;
        private float m_fSampleLeadMinSpanEnd;
        private float m_fSampleLeadMaxSpanStart;
        private float m_fSampleLeadMaxSpanEnd;
        private float m_fLeadMinSpanResult;
        private float m_fLeadMaxSpanResult;
        private float m_fLeadSpanResultMM;
        private float m_fLeadUnitSpanTipCenterXY;

        private float m_fReferencePointStartX;
        private float m_fReferencePointStartY;
        private float m_fReferencePointEndX;
        private float m_fReferencePointEndY;
        private float m_fSampleReferencePointStartX;
        private float m_fSampleReferencePointStartY;
        private float m_fSampleReferencePointEndX;
        private float m_fSampleReferencePointEndY;
        private float m_fLengthVariance; //difference of minimum and maximum length of lead for 1 side
        private float m_fSampleLengthVariance; //difference of minimum and maximum length of lead for 1 side
        private float m_fSampleLengthVarianceMM; //difference of minimum and maximum length of lead for 1 side in mm
        private float m_fSampleLengthMinMM;   // the shortest length of leads
        private float m_fSampleLengthMaxMM;   // the longest length of leads

        // Error Message Used
        private string m_strErrorMessage;

        // Pocket Dont Care ROI reference pattern
        private EMatcher m_objManualPocketMatcher = new EMatcher();
        private float m_fManualPocketReferenceOffsetX = 0;
        private float m_fManualPocketReferenceOffsetY = 0;
        private EMatcher m_objAutoPocketMatcher = new EMatcher();
        private float m_fAutoPocketReferenceOffsetX = 0;
        private float m_fAutoPocketReferenceOffsetY = 0;

        // PRS for unit position and angle.
        private EMatcher m_objMatcher = new EMatcher();
        //private EPatternFinder m_objFinder = new EPatternFinder();
        private Point m_pUnitCenterPoint = new Point();
        private float m_fUnitAngle = 0f;
        private float m_fUnitScore = 0f;

        private float m_fOffSetX;
        private float m_fOffSetY;
        private float m_fWidthOffSet;
        private float m_fHeightOffSet;
        private float m_fPitchOffSet;
        private float m_fGapOffSet;

        // Calibration
        private float m_fAreaMMPerPixel = 14;
        private float m_fMMPerPixelX = 1;
        private float m_fMMPerPixelY = 1;

        private float m_fSizeOffSetX = 0;
        private float m_fSizeOffSetY = 0;

        private float m_fMMToPixelXValue = 1;
        private float m_fMMToPixelYValue = 1;
        private float m_fMMtoPixelAreaValue = 1;

        private float m_fMMToUnitValue = 1;
        private float m_fMMToUnitValueArea = 1;

        private float m_intDecimal = 4;
        private float m_intDecimal2 = 6;

        private float m_fUnitWidth;
        private float m_fUnitHeight;
        private float m_fUnitThickness;
        private float m_fUnitWidthMin;
        private float m_fUnitWidthMax;
        private float m_fUnitHeightMin;
        private float m_fUnitHeightMax;
        private float m_fUnitThicknessMin;
        private float m_fUnitThicknessMax;
        private float m_fUnitSizeLength;
        private float m_fCrackLength;
        private float m_fScratchLength;
        private float m_fContaminationLength;
        private float m_fSolderMeltLength;
        private float m_fVoidLength;
        private float m_fMoldFlashLength;
        private float m_fInCompletePlateLength;
        private float m_fLeadBrokenLength;
        private float m_fLeadBrokenArea;
        private float m_fUnitCenterX;
        private float m_fUnitCenterY;
        private int m_intMPTolerance; // Morphology Half Width tolerance. (Some leads has quite large different size from one unit to another unit especially small unit)

        private int m_intPkgToBaseTolerance_Top = 0;
        private int m_intPkgToBaseTolerance_Right = 0;
        private int m_intPkgToBaseTolerance_Bottom = 0;
        private int m_intPkgToBaseTolerance_Left = 0;

        private float m_fCenterX_PackageGaugeM4L = 0;
        private float m_fCenterY_PackageGaugeM4L = 0;
        private float m_fWidth_PackageGaugeM4L = 0;
        private float m_fHeight_PackageGaugeM4L = 0;
        private float m_fAngle_PackageGaugeM4L = 0;

        private int m_intExtraBlobID = 0;
        private bool m_blnWantCheckExtraLeadLength = false;
        private bool m_blnWantCheckExtraLeadArea = false;
        private float m_fTotalExtraLeadSetArea = 0.004f;
        private float m_fExtraLeadSetArea = 0.004f;
        private float m_fExtraLeadSetLength = 0.001f;
        private float m_fExcessLeadSetArea = 0.004f;
        private float m_fExcessLeadSetLength = 0.001f;
        private float m_fResultExtraLeadMinArea = -1;
        private float m_fResultExtraLeadMaxArea = -1;
        private float m_fResultTotalExtraLeadArea = -1;

        // Template Image
        private EImageBW8 m_ImgSearchROITemplateImage = new EImageBW8();
        private EImageBW8 m_ImgUnitTemplateImage = new EImageBW8();
        private EImageBW8 m_ImgTUnitDilateThresImage = new EImageBW8();
        private EImageBW8 m_ImgTUnitErodeThresImage = new EImageBW8();
        private EImageBW8 m_ImgTUnitInvertThresImage = new EImageBW8();
        private EImageBW8 m_ImgTLeadImage1 = new EImageBW8();
        private EImageBW8 m_ImgWhiteUnitTemplateImage = new EImageBW8();
        private EImageBW8 m_ImgWhiteUnitTemplateImage2 = new EImageBW8();
        private EImageBW8 m_ImgBlackUnitTemplateImage = new EImageBW8();
        private EImageBW8 m_ImgBlackUnitTemplateImage2 = new EImageBW8();
        private EImageBW8 m_ImgMPUnitTemplateImage = new EImageBW8();
        private List<EImageBW8> m_arrImgLeadImage = new List<EImageBW8>();
        #endregion

        #region Properties
        public bool ref_blnFlipToOppositeFunction { get { return m_blnFlipToOppositeFunction; } set { m_blnFlipToOppositeFunction = value; } }
        public int ref_intDontCareBlobROIInward { get { return m_intDontCareBlobROIInward; } set { m_intDontCareBlobROIInward = value; } }
        public int ref_intMinShadowArea { get { return m_intMinShadowArea; } set { m_intMinShadowArea = value; } }
        public int ref_intMaxShadowArea { get { return m_intMaxShadowArea; } set { m_intMaxShadowArea = value; } }
        public int ref_intMaxShadowWidth { get { return m_intMaxShadowWidth; } set { m_intMaxShadowWidth = value; } }
        public int ref_intDontCareBlobThreshold { get { return m_intDontCareBlobThreshold; } set { m_intDontCareBlobThreshold = value; } }
        public int ref_intLeadROITolerance_Top { get { return m_intLeadROITolerance_Top; } set { m_intLeadROITolerance_Top = value; } }
        public int ref_intLeadROITolerance_Right { get { return m_intLeadROITolerance_Right; } set { m_intLeadROITolerance_Right = value; } }
        public int ref_intLeadROITolerance_Bottom { get { return m_intLeadROITolerance_Bottom; } set { m_intLeadROITolerance_Bottom = value; } }
        public int ref_intLeadROITolerance_Left { get { return m_intLeadROITolerance_Left; } set { m_intLeadROITolerance_Left = value; } }
        public float ref_fPatternROIOffsetX { get { return m_fPatternROIOffsetX; } set { m_fPatternROIOffsetX = value; } }
        public float ref_fPatternROIOffsetY { get { return m_fPatternROIOffsetY; } set { m_fPatternROIOffsetY = value; } }
        public bool ref_blnWantInspectBaseLead { get { return m_blnWantInspectBaseLead; } set { m_blnWantInspectBaseLead = value; } }
        public bool ref_blnWantUseAGVMasking { get { return m_blnWantUseAGVMasking; } set { m_blnWantUseAGVMasking = value; } }
        public int ref_intPocketDontCareMethod { get { return m_intPocketDontCareMethod; } set { m_intPocketDontCareMethod = value; } }
        public float ref_fUnitAverageCenterX { get { return m_fUnitAverageCenterX; } set { m_fUnitAverageCenterX = value; } }
        public float ref_fUnitAverageCenterY { get { return m_fUnitAverageCenterY; } set { m_fUnitAverageCenterY = value; } }
        public float ref_fSampleReferencePointStartX { get { return m_fSampleReferencePointStartX; } set { m_fSampleReferencePointStartX = value; } }
        public float ref_fSampleReferencePointStartY { get { return m_fSampleReferencePointStartY; } set { m_fSampleReferencePointStartY = value; } }
        public float ref_fSampleReferencePointEndX { get { return m_fSampleReferencePointEndX; } set { m_fSampleReferencePointEndX = value; } }
        public float ref_fSampleReferencePointEndY { get { return m_fSampleReferencePointEndY; } set { m_fSampleReferencePointEndY = value; } }
        public int ref_intRotationMethod { get { return m_intRotationMethod; } set { m_intRotationMethod = value; } }
        public int ref_intLeadAngleTolerance { get { return m_intLeadAngleTolerance; } set { m_intLeadAngleTolerance = value; } }
        public float ref_fUnitAngle { get { return m_fUnitAngle; } set { m_fUnitAngle = value; } }
        public float ref_fUnitScore { get { return m_fUnitScore; } set { m_fUnitScore = value; } }
        public int ref_intPkgToBaseTolerance_Top { get { return m_intPkgToBaseTolerance_Top; } set { m_intPkgToBaseTolerance_Top = value; } }
        public int ref_intPkgToBaseTolerance_Right { get { return m_intPkgToBaseTolerance_Right; } set { m_intPkgToBaseTolerance_Right = value; } }
        public int ref_intPkgToBaseTolerance_Bottom { get { return m_intPkgToBaseTolerance_Bottom; } set { m_intPkgToBaseTolerance_Bottom = value; } }
        public int ref_intPkgToBaseTolerance_Left { get { return m_intPkgToBaseTolerance_Left; } set { m_intPkgToBaseTolerance_Left = value; } }
        public float ref_fManualPocketReferenceOffsetX { get { return m_fManualPocketReferenceOffsetX; } set { m_fManualPocketReferenceOffsetX = value; } }
        public float ref_fManualPocketReferenceOffsetY { get { return m_fManualPocketReferenceOffsetY; } set { m_fManualPocketReferenceOffsetY = value; } }
        public float ref_fAutoPocketReferenceOffsetX { get { return m_fAutoPocketReferenceOffsetX; } set { m_fAutoPocketReferenceOffsetX = value; } }
        public float ref_fAutoPocketReferenceOffsetY { get { return m_fAutoPocketReferenceOffsetY; } set { m_fAutoPocketReferenceOffsetY = value; } }
        public int ref_intExtraBlobID { get { return m_intExtraBlobID; } set { m_intExtraBlobID = value; } }
        public float ref_fTotalExtraLeadSetArea { get { return m_fTotalExtraLeadSetArea; } set { m_fTotalExtraLeadSetArea = value; } }
        public float ref_fExtraLeadSetArea { get { return m_fExtraLeadSetArea; } set { m_fExtraLeadSetArea = value; } }
        public float ref_fExtraLeadSetLength { get { return m_fExtraLeadSetLength; } set { m_fExtraLeadSetLength = value; } }
        public bool ref_blnWantCheckExtraLeadLength { get { return m_blnWantCheckExtraLeadLength; } set { m_blnWantCheckExtraLeadLength = value; } }
        public bool ref_blnWantCheckExtraLeadArea { get { return m_blnWantCheckExtraLeadArea; } set { m_blnWantCheckExtraLeadArea = value; } }
        public int ref_intImageViewNo { get { return m_intImageViewNo; } set { m_intImageViewNo = value; } }
        public int ref_intBaseLeadImageViewNo { get { return m_intBaseLeadImageViewNo; } set { m_intBaseLeadImageViewNo = value; } }
        public bool ref_blnSelected { get { return m_blnSelected; } set { m_blnSelected = value; } }
        //public int ref_intCheckLeadDimensionImageIndex { get { return m_intCheckLeadDimensionImageIndex; } set { m_intCheckLeadDimensionImageIndex = value; } }
        public float ref_fImageGain { get { return m_fImageGain; } set { m_fImageGain = value; } }
        public int ref_intFilterMinArea { get { return m_intFilterMinArea; } set { m_intFilterMinArea = value; } }
        public int ref_intFilterMinArea_BaseLead { get { return m_intFilterMinArea_BaseLead; } set { m_intFilterMinArea_BaseLead = value; } }
        public bool ref_blnWhiteOnBlack { get { return m_blnWhiteOnBlack; } set { m_blnWhiteOnBlack = value; } }
        public int ref_intThresholdValue { get { return m_intThresholdValue; } set { m_intThresholdValue = value; } }
        public int ref_intThresholdValue_BaseLead { get { return m_intThresholdValue_BaseLead; } set { m_intThresholdValue_BaseLead = value; } }
        public bool ref_blnWantUseClosestSizeDefineTolerance { get { return m_blnWantUseClosestSizeDefineTolerance; } set { m_blnWantUseClosestSizeDefineTolerance = value; } }
        public int ref_intNumberOfLead { get { return m_intNumberOfLead; } set { m_intNumberOfLead = value; } }

        public int ref_intNumberOfLead_Top { get { return m_intNumberOfLead_Top; } set { m_intNumberOfLead_Top = value; } }

        public int ref_intNumberOfLead_Bottom { get { return m_intNumberOfLead_Bottom; } set { m_intNumberOfLead_Bottom = value; } }

        public int ref_intNumberOfLead_Left { get { return m_intNumberOfLead_Left; } set { m_intNumberOfLead_Left = value; } }

        public int ref_intNumberOfLead_Right { get { return m_intNumberOfLead_Right; } set { m_intNumberOfLead_Right = value; } }

        //public int ref_intLeadDirection { get { return m_intLeadDirection; } set { m_intLeadDirection = value; } }

        public float ref_fDefaultPixelTolerance { get { return m_fDefaultPixelTolerance; } set { m_fDefaultPixelTolerance = value; } }
        public bool ref_blnViewLeadResultDrawing { get { return m_blnViewLeadResultDrawing; } set { m_blnViewLeadResultDrawing = value; } }
        public bool ref_blnLock { get { return m_blnLock; } set { m_blnLock = value; } }
        public int ref_intSensitivityOnLeadValue { get { return m_intSensitivityOnLeadValue; } set { m_intSensitivityOnLeadValue = value; } }
        public string ref_strErrorMessage { get { return m_strErrorMessage; } set { m_strErrorMessage = value; } }
        public bool ref_blnWantTightSetting { get { return m_blnWantTightSetting; } set { m_blnWantTightSetting = value; } }
        public float ref_fTightSettingTolerance { get { return m_fTightSettingTolerance; } set { m_fTightSettingTolerance = value; } }
        //public int ref_intBaseOffset { get { return m_intBaseOffset; } set { m_intBaseOffset = value; } }
        //public int ref_intTipOffset { get { return m_intTipOffset; } set { m_intTipOffset = value; } }
        public bool ref_blnClockWise { get { return m_blnClockWise; } set { m_blnClockWise = value; } }
        public int ref_intFirstLead { get { return m_intFirstLead; } set { m_intFirstLead = value; } }
        public int ref_intFailResultMask { get { return m_intFailResultMask; } set { m_intFailResultMask = value; } }
        public float ref_fTemplateLengthVarianceMaxLimit { get { return m_fTemplateLengthVarianceMaxLimit; } set { m_fTemplateLengthVarianceMaxLimit = value; } }
        public float ref_fTemplateLeadMinSpanLimit { get { return m_fTemplateLeadMinSpanLimit; } set { m_fTemplateLeadMinSpanLimit = value; } }
        public float ref_fTemplateLeadMaxSpanLimit { get { return m_fTemplateLeadMaxSpanLimit; } set { m_fTemplateLeadMaxSpanLimit = value; } }
        public float ref_fLeadMinSpanResult { get { return m_fLeadMinSpanResult; } set { m_fLeadMinSpanResult = value; } }
        public float ref_fLeadMaxSpanResult { get { return m_fLeadMaxSpanResult; } set { m_fLeadMaxSpanResult = value; } }
        public float ref_fLeadSpanResultMM { get { return m_fLeadSpanResultMM; } set { m_fLeadSpanResultMM = value; } }
        public float ref_fLeadUnitSpanTipCenterXY { get { return m_fLeadUnitSpanTipCenterXY; } set { m_fLeadUnitSpanTipCenterXY = value; } }
        public int ref_intFailOptionMask { get { return m_intFailOptionMask; } set { m_intFailOptionMask = value; } }
        public int ref_intBaseLineTrimFromEdge { get { return m_intBaseLineTrimFromEdge; } set { m_intBaseLineTrimFromEdge = value; } }
        public int ref_intBaseLineSteps { get { return m_intBaseLineSteps; } set { m_intBaseLineSteps = value; } }
        public float ref_fBaseLineAngle { get { return m_fBaseLineAngle; } }
        public float ref_fCenterUnitAngle { get { return m_fCenterUnitAngle; } }
        public float ref_fCenterUnitWidth { get { return m_fCenterUnitWidth; } }
        public float ref_fCenterUnitHeight { get { return m_fCenterUnitHeight; } }
        public float ref_fCenterUnitCompensateAngle_ForDrawing { get { return m_fCenterUnitCompensateAngle_ForDrawing; } set { m_fCenterUnitCompensateAngle_ForDrawing = value; } }
        public float ref_fRotateCenterX_ForDrawing { get { return m_fRotateCenterX_ForDrawing; } set { m_fRotateCenterX_ForDrawing = value; } }
        public float ref_fRotateCenterY_ForDrawing { get { return m_fRotateCenterY_ForDrawing; } set { m_fRotateCenterY_ForDrawing = value; } }
        public PointF ref_pCornerPoint_Left { get { return m_pCornerPoint_Left; } }
        public PointF ref_pCornerPoint_Right { get { return m_pCornerPoint_Right; } }
        public PointF ref_pCornerPoint_Top { get { return m_pCornerPoint_Top; } }
        public PointF ref_pCornerPoint_Bottom { get { return m_pCornerPoint_Bottom; } }
        public PointF ref_pCornerPoint_Center { get { return m_pCornerPoint_Center; } }
        public PGauge ref_objPointGauge { get { return m_objPointGauge; } set { m_objPointGauge = value; } }
        public PGauge ref_objSettingPointGauge { get { return m_objSettingPointGauge; } set { m_objSettingPointGauge = value; } }
        public List<List<PGauge>> ref_arrPointGauge { get { return m_arrPointGauge; } set { m_arrPointGauge = value; } }
        public List<List<PGauge>> ref_arrSettingPointGauge { get { return m_arrSettingPointGauge; } set { m_arrSettingPointGauge = value; } }
        public bool ref_blnWantUseGaugeMeasureLeadDimension { get { return m_blnWantUseGaugeMeasureLeadDimension; } set { m_blnWantUseGaugeMeasureLeadDimension = value; } }
        public bool ref_blnWantUsePkgToBaseTolerance { get { return m_blnWantUsePkgToBaseTolerance; } set { m_blnWantUsePkgToBaseTolerance = value; } }
        public bool ref_blnWantUseAverageGrayValueMethod { get { return m_blnWantUseAverageGrayValueMethod; } set { m_blnWantUseAverageGrayValueMethod = value; } }
        public bool ref_blnWantPocketDontCareAreaFix_Lead { get { return m_blnWantPocketDontCareAreaFix_Lead; } set { m_blnWantPocketDontCareAreaFix_Lead = value; } }
        public bool ref_blnWantPocketDontCareAreaManual_Lead { get { return m_blnWantPocketDontCareAreaManual_Lead; } set { m_blnWantPocketDontCareAreaManual_Lead = value; } }
        public bool ref_blnWantPocketDontCareAreaAuto_Lead { get { return m_blnWantPocketDontCareAreaAuto_Lead; } set { m_blnWantPocketDontCareAreaAuto_Lead = value; } }
        public bool ref_blnWantPocketDontCareAreaBlob_Lead { get { return m_blnWantPocketDontCareAreaBlob_Lead; } set { m_blnWantPocketDontCareAreaBlob_Lead = value; } }
        public LGauge2 ref_objPocketEdgeGauge { get { return m_objPocketEdgeGauge; } set { m_objPocketEdgeGauge = value; } }
        public int ref_intLineOffset { get { return m_intLineOffset; } set { m_intLineOffset = value; } }
        public int ref_intMaskThickness { get { return m_intMaskThickness; } set { m_intMaskThickness = value; } }
        public float ref_fSampleLengthVarianceMM { get { return m_fSampleLengthVarianceMM; } set { m_fSampleLengthVarianceMM = value; } }
        public float ref_fSampleLengthMinMM { get { return m_fSampleLengthMinMM; } set { m_fSampleLengthMinMM = value; } }
        public float ref_fSampleLengthMaxMM { get { return m_fSampleLengthMaxMM; } set { m_fSampleLengthMaxMM = value; } }

        #endregion

        #region Struct 

        struct BlobsFeatures
        {
            // Object Data
            public int intNoID;
            public int intObjNo;
            public int intDirection;       //1 = left column, 2 = right column, 4 = high row, 8 = low row
            public int intSide;             //1 = top side, 2 = right side, 4 = bottom side, 8 = left side
            public int intGroupID;
            public int intLengthMode;  // 1: Length = Height, 2: Length = Width
            public int[] arrContourX;
            public int[] arrContourY;
            public int intContourX;
            public int intContourY;
            public float fArea;
            public int intStartX;
            public int intStartY;
            public int intEndX;
            public int intEndY;
            public float fStartX;
            public float fStartY;
            public float fEndX;
            public float fEndY;
            public float fCenterX;
            public float fCenterY;
            public float fLimitCenterX;
            public float fLimitCenterY;
            public float fWidth;
            public float fHeight;
            public float fBaseWidth;
            public float fBaseHeight;
            public float fBaseCenterX;
            public float fBaseCenterY;
            public float fTipWidth;
            public float fTipHeight;
            public float fTipCenterX;
            public float fTipCenterY;
            public bool blnSelected;

            public bool ref_blnSelected { get { return blnSelected; } set { blnSelected = value; } }

            // Object Relation Data
            public float fLeftDistance;
            public float fRightDistance;
            public float fTopDistance;
            public float fBottomDistance;
            public float fXDistance;
            public float fYDistance;
            public float fPitch;
            public float fGap;

            // Inspection Data
            public float fOffSet;
            public float fSkew;
            public float fMinWidth;
            public float fMaxWidth;
            public float fMinHeight;
            public float fMaxHeight;

            public float fMinBaseWidth;
            public float fMaxBaseWidth;
            public float fMinBaseHeight;
            public float fMaxBaseHeight;
            public float fMinTipWidth;
            public float fMaxTipWidth;
            public float fMinTipHeight;
            public float fMaxTipHeight;

            public float fMinPitch;
            public float fMaxPitch;
            public float fMinGap;
            public float fMaxGap;
            public float fVariance;

            public float fMinAGV;
            public float fMaxAGV;

            public float fWidthOffset;
            public float fLengthOffset;
            public float fPitchOffset;
            public float fGapOffset;

            public int[] arrSelectedBlob;
            public int intSelectedBlob;

            //Inward Offset
            public int intTipInwardOffset;
            public int intBaseInwardOffset;

            public bool blnTipCenterFound;
            public bool blnTipStartFound;
            public bool blnTipEndFound;
            public bool blnBaseCenterFound;
            public bool blnBaseStartFound;
            public bool blnBaseEndFound;

            // Average Gray Value ROI Tolerance
            public int intAGVROITolerance_Top;
            public int intAGVROITolerance_Right;
            public int intAGVROITolerance_Bottom;
            public int intAGVROITolerance_Left;

            public float fMaxBaseOffset;
            public float fMinBaseArea;
            public float fMaxBaseArea;
        }
        struct SampleBlobsFeatures
        {
            // Result
            public float fOffSetMM;
            public float fSkewMM;
            public float fAreaMM;
            public float fWidthMM;
            public float fHeightMM;
            public float fBaseWidthMM;
            public float fBaseHeightMM;
            public float fTipWidthMM;
            public float fTipHeightMM;
            public float fPitchMM;
            public float fGapMM;
            public float fVarianceMM;

            public float fAGV;

            // Object Data in pixel
            public float fOffSet;
            public float fSkew;
            public float fArea;
            public float fWidth;
            public float fHeight;
            public float fPitch;
            public float fGap;

            public int intFailMask;
            public float fStartX;
            public float fStartY;
            public float fEndX;
            public float fEndY;
            public float fCenterX;
            public float fCenterY;
            public float fGravityCenterX;
            public float fGravityCenterY;

            public float fBaseCenterX;
            public float fBaseCenterY;
            public float fBaseWidth;
            public float fBaseHeight;
            public float fTipCenterX;
            public float fTipCenterY;
            public float fTipWidth;
            public float fTipHeight;

            public int intContourIndex; // Keep sample blob index

            public bool blnTipCenterFound;
            public bool blnTipStartFound;
            public bool blnTipEndFound;
            public bool blnBaseCenterFound;
            public bool blnBaseStartFound;
            public bool blnBaseEndFound;
        }
        struct SampleExtraBlobsFeatures
        {
            // Object Data
            public float fStartX;
            public float fStartY;
            public float fEndX;
            public float fEndY;
            public float fCenterX;
            public float fCenterY;
            public float fWidth;
            public float fHeight;

            public float ref_fWidthFailValue;
            public float ref_fHeightFailValue;
            public float ref_fAreaFailValue;

            public int ref_intExtraBlobID;
            public int ref_intFailCriteria; // 0x01:width, 0x02:Height, 0x04:Area
        }
        struct ToleranceBlobsFeatures
        {
            // Inspection Data
            public float fOffSet;
            public float fSkew;
            public float fMinWidth;
            public float fMaxWidth;
            public float fMinHeight;
            public float fMaxHeight;

            public float fMinBaseWidth;
            public float fMaxBaseWidth;
            public float fMinBaseHeight;
            public float fMaxBaseHeight;
            public float fMinTipWidth;
            public float fMaxTipWidth;
            public float fMinTipHeight;
            public float fMaxTipHeight;

            public float fStartX;
            public float fStartY;
            public float fEndX;
            public float fEndY;
            public float fLimitCenterX;
            public float fLimitCenterY;
            public int intNoID;
            public int intGroupID;
            public int intDirection;
            public int intLengthMode;  // 1: Length = Height, 2: Length = Width

            public float fLearnArea;
            public float fLearnWidth;
            public float fLearnHeight;
            public float fVariance;

            public float fMinAGV;
            public float fMaxAGV;

            public float fWidthOffset;
            public float fLengthOffset;
            public float fPitchOffset;
            public float fGapOffset;

            //Inward Offset
            public int intTipInwardOffset;
            public int intBaseInwardOffset;

            // Average Gray Value ROI Tolerance
            public int intAGVROITolerance_Top;
            public int intAGVROITolerance_Right;
            public int intAGVROITolerance_Bottom;
            public int intAGVROITolerance_Left;

            public float fMaxBaseOffset;
            public float fMinBaseArea;
            public float fMaxBaseArea;
        }
        struct TolerancePitchGap
        {
            public float fMinPitch;
            public float fMaxPitch;
            public float fMinGap;
            public float fMaxGap;
        }
        struct PitchGap
        {
            public int intFromLeadNo;
            public int intToLeadNo;
            public int intDirection;
            public float fPitch;
            public float fGap;
            public float fPitchMM;
            public float fGapMM;
            public float fMinPitch;
            public float fMaxPitch;
            public float fMinGap;
            public float fMaxGap;
            public int intStartPointX;
            public int intStartPointY;
            public int intEndPointX;
            public int intEndPointY;
            public int intFailMask;

        }
        struct GroupSetting
        {
            // Group reference info
            public float fReferenceArea;
            public float fReferenceWidth;
            public float fReferenceHeight;

            // Setting
            public float fOffSet;
            public float fSkew;
            //public float fMinArea;
            //public float fMaxArea;
            public float fMinWidth;
            public float fMaxWidth;
            public float fMinHeight;
            public float fMaxHeight;
            public float fMinPitch;
            public float fMaxPitch;
            public float fMinGap;
            public float fMaxGap;
            //public float fMaxBroken;
            //public float fMaxBrokenLength;
        }

        #endregion

        public Lead(GaugeWorldShape objWorldShape, int intLeadROIDirection, bool blnGotPackage)
        {
            m_objPointGauge = new PGauge(objWorldShape);
            m_objSettingPointGauge = new PGauge(objWorldShape);
            m_objPocketEdgeGauge = new LGauge2(objWorldShape, intLeadROIDirection);
            m_objWorldShape = objWorldShape;
            m_intLeadROIDirection = intLeadROIDirection;

            m_blnGotPackage = blnGotPackage;
        }

        public Lead(GaugeWorldShape objWorldShape, int intImageWidth, int intImageHeight, int intLeadROIDirection)
        {
            for (int i = 0; i < m_arrLineGauge.Length; i++)
            {
                m_arrLineGauge[i] = new LGauge(objWorldShape);
                m_arrLineGauge[i].SetGaugeAdvancedSetting(10, 0, 1, 1, 4, 1, 3, 125);
            }
            m_objPocketEdgeGauge = new LGauge2(objWorldShape, intLeadROIDirection);
            m_intLeadROIDirection = intLeadROIDirection;
        }

        /// <summary>
        /// Get blobs features count
        /// </summary>
        /// <returns></returns>
        public int GetBlobsFeaturesNumber()
        {
            return m_arrTemplateBlobLeads.Count;
        }
        public int GetBlobsFeaturesNumber_BaseLead()
        {
            return m_arrTemplateBlobLeads_BaseLead.Count;
        }

        public List<int> GetLeadID()
        {
            List<int> arrID = new List<int>();

            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                arrID.Add(m_stcBlobLead.intNoID);
            }

            return arrID;
        }
        public void DefineLeadBaseTipWidthHeight_PkgToBase(int intLeadPosition, ROI objROI)
        {
            float fLimitCenterX;
            float fLimitCenterY;
            float fNewCenterX;
            float fNewCenterY;
            float fWidth;
            float fHeight;
            int intFixPointXY;

            m_arrLeadPointGaugeStartX.Clear();
            m_arrLeadPointGaugeStartY.Clear();
            m_arrLeadPointGaugeTolerance.Clear();
            m_arrLeadPointGaugeAngle.Clear();
            m_arrLeadEdgeGaugePoints.Clear();
            m_arrLeadEdgeGaugePointsFound.Clear();
            m_arrLeadEdgeGaugePointsPosition.Clear();
            m_arrLeadEdgeGaugePointsIDNo.Clear();
            //int intTotalCount = 0;
            //for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            //{
            //    m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
            //    if (m_stcBlobLead.intNoID > intTotalCount)
            //    {
            //        intTotalCount = m_stcBlobLead.intNoID;
            //    }
            //}
            for (int p = m_arrLeadEdgeGaugePoints.Count; p < m_arrTemplateBlobLeads.Count; p++)//intTotalCount
            {
                m_arrLeadEdgeGaugePoints.Add(new List<PointF>());
                m_arrLeadEdgeGaugePointsFound.Add(new List<bool>());
                m_arrLeadEdgeGaugePointsPosition.Add(0);
                m_arrLeadEdgeGaugePointsIDNo.Add(0);
                m_arrLeadPointGaugeStartX.Add(new List<float>());
                m_arrLeadPointGaugeStartY.Add(new List<float>());
                m_arrLeadPointGaugeTolerance.Add(new List<float>());
                m_arrLeadPointGaugeAngle.Add(new List<float>());
            }
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                m_arrLeadEdgeGaugePointsPosition[i] = intLeadPosition;
                m_arrLeadEdgeGaugePointsIDNo[i] = m_stcBlobLead.intNoID;
                switch (intLeadPosition)
                {
                    //Top
                    case 1:
                        //Base
                        fLimitCenterX = objROI.ref_ROITotalX + m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = objROI.ref_ROITotalY + m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        //intFixPointXY = (int)Math.Round(objROI.ref_ROITotalY + m_stcBlobLead.fLimitCenterY + (m_stcBlobLead.fHeight / 2) - m_stcBlobLead.intBaseInwardOffset, 0, MidpointRounding.AwayFromZero);
                        //float fTopFixPointY;
                        //PointF pTopStart;
                        //PointF pTopEnd;
                        //// ------- Find Base -----------------------------------------
                        //m_stcBlobLead.fBaseCenterY = (m_fCenterY_PackageGaugeM4L - m_fHeight_PackageGaugeM4L / 2) - m_intPkgToBaseTolerance_Top;
                        //m_stcBlobLead.fBaseCenterY -= objROI.ref_ROITotalY;
                        //AddPointGaugePlacementToArray(-1, -1, -1, -(int)PointIndex.TipCenter, i);

                        //m_stcBlobLead.blnBaseCenterFound = false;
                        //m_arrLeadEdgeGaugePoints[i].Add(new PointF(-1, -1));
                        //m_arrLeadEdgeGaugePointsFound[i].Add(false);

                        //SetPointGaugePlacementToArray(-1, -1, -1, -1, (int)PointIndex.BaseStart, i);
                        //m_stcBlobLead.blnBaseStartFound = false;
                        //m_arrLeadEdgeGaugePoints[i].Add(new PointF(-1, -1));
                        //m_arrLeadEdgeGaugePointsFound[i].Add(false);

                        //SetPointGaugePlacementToArray(-1, -1, -1, -1, (int)PointIndex.BaseEnd, i);
                        //m_stcBlobLead.blnBaseEndFound = false;
                        //m_arrLeadEdgeGaugePoints[i].Add(new PointF(-1, -1));
                        //m_arrLeadEdgeGaugePointsFound[i].Add(false);


                        // ------- Find Base Point X -----------------------------------------
                        m_stcBlobLead.fBaseCenterY = (m_fCenterY_PackageGaugeM4L - m_fHeight_PackageGaugeM4L / 2) - m_intPkgToBaseTolerance_Top;

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.BaseCenter].SetGaugePlacement(fLimitCenterX, m_stcBlobLead.fBaseCenterY, fHeight * (m_fPointGaugeToleranceRate * m), 90);

                            m_arrPointGauge[i][(int)PointIndex.BaseCenter].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                            {
                                AddPointGaugePlacementToArray(fLimitCenterX, m_stcBlobLead.fBaseCenterY, fHeight * (m_fPointGaugeToleranceRate * m), 90, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                AddPointGaugePlacementToArray(fLimitCenterX, m_stcBlobLead.fBaseCenterY, fHeight * (m_fPointGaugeToleranceRate * m), 90, i);
                            }
                        }

                        if (m_arrPointGauge[i][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                        {
                            m_stcBlobLead.fBaseCenterX = m_arrPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointX(0);
                            //m_stcBlobLead.fBaseCenterY = m_arrPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointY(0);
                            m_stcBlobLead.blnBaseCenterFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(m_stcBlobLead.fBaseCenterX, m_arrPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointY(0)));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            m_stcBlobLead.fBaseCenterX = fLimitCenterX;
                            //m_stcBlobLead.fBaseCenterY = fLimitCenterY + (m_stcBlobLead.fHeight / 2);
                            m_stcBlobLead.blnBaseCenterFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(m_stcBlobLead.fBaseCenterX, m_stcBlobLead.fBaseCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Base start point -----------------------------------------
                        float fTopFixPointY = m_stcBlobLead.fBaseCenterY - m_stcBlobLead.intBaseInwardOffset;

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.BaseStart].SetGaugePlacement(m_stcBlobLead.fBaseCenterX - fWidth / 2, fTopFixPointY, fWidth * (m_fPointGaugeToleranceRate * m), 180);

                            m_arrPointGauge[i][(int)PointIndex.BaseStart].Measure(objROI);

                            if (m_arrPointGauge[i][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray(m_stcBlobLead.fBaseCenterX - fWidth / 2,
                                                              fTopFixPointY,
                                                             fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.BaseStart, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray(m_stcBlobLead.fBaseCenterX - fWidth / 2,
                                                              fTopFixPointY,
                                                             fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.BaseStart, i);
                            }
                        }

                        PointF pTopStart;
                        if (m_arrPointGauge[i][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                        {
                            pTopStart = m_arrPointGauge[i][(int)PointIndex.BaseStart].GetMeasurePoint(0);
                            m_stcBlobLead.blnBaseStartFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pTopStart.X, pTopStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pTopStart = new PointF(m_stcBlobLead.fBaseCenterX - fWidth / 2, fTopFixPointY);
                            m_stcBlobLead.blnBaseStartFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pTopStart.X, pTopStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Base end point -----------------------------------------
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.BaseEnd].SetGaugePlacement(fLimitCenterX + fWidth / 2, fTopFixPointY, fWidth * (m_fPointGaugeToleranceRate * m), 0);
                            
                            m_arrPointGauge[i][(int)PointIndex.BaseEnd].Measure(objROI);

                            if (m_arrPointGauge[i][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray(m_stcBlobLead.fBaseCenterX + fWidth / 2,
                                                          fTopFixPointY,
                                                         fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.BaseEnd, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray(m_stcBlobLead.fBaseCenterX + fWidth / 2,
                                                          fTopFixPointY,
                                                         fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.BaseEnd, i);
                            }
                        }

                        PointF pTopEnd;
                        if (m_arrPointGauge[i][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                        {
                            pTopEnd = m_arrPointGauge[i][(int)PointIndex.BaseEnd].GetMeasurePoint(0);
                            m_stcBlobLead.blnBaseEndFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pTopEnd.X, pTopEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pTopEnd = new PointF(m_stcBlobLead.fBaseCenterX + fWidth / 2, fTopFixPointY);
                            m_stcBlobLead.blnBaseEndFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pTopEnd.X, pTopEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // Calculate the Base width and center X
                        m_stcBlobLead.fBaseWidth = pTopEnd.X - pTopStart.X;
                        m_stcBlobLead.fBaseCenterX = (pTopEnd.X + pTopStart.X) / 2 - objROI.ref_ROITotalX;
                        m_stcBlobLead.fBaseCenterY -= objROI.ref_ROITotalY;


                        //Tip
                        fLimitCenterX = objROI.ref_ROITotalX + m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = objROI.ref_ROITotalY + m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        //intFixPointXY = (int)Math.Round(objROI.ref_ROITotalY + m_stcBlobLead.fLimitCenterY - (m_stcBlobLead.fHeight / 2) + m_stcBlobLead.intTipInwardOffset, 0, MidpointRounding.AwayFromZero);

                        // ------- Find Tip Point X -----------------------------------------
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.TipCenter].SetGaugePlacement(fLimitCenterX, fLimitCenterY - fHeight / 2, fHeight * (m_fPointGaugeToleranceRate * m), -90);
                            
                            m_arrPointGauge[i][(int)PointIndex.TipCenter].Measure(objROI);

                            if (m_arrPointGauge[i][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray(fLimitCenterX,
                                                           fLimitCenterY - (fHeight / 2),
                                                           fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.TipCenter, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray(fLimitCenterX,
                                                            fLimitCenterY - (fHeight / 2),
                                                            fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.TipCenter, i);
                            }
                        }

                        if (m_arrPointGauge[i][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                        {
                            m_stcBlobLead.fTipCenterX = m_arrPointGauge[i][(int)PointIndex.TipCenter].GetMeasurePointX(0);
                            m_stcBlobLead.fTipCenterY = m_arrPointGauge[i][(int)PointIndex.TipCenter].GetMeasurePointY(0);
                            m_stcBlobLead.blnTipCenterFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            m_stcBlobLead.fTipCenterX = fLimitCenterX;
                            m_stcBlobLead.fTipCenterY = fLimitCenterY - (m_stcBlobLead.fHeight / 2);
                            m_stcBlobLead.blnTipCenterFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Tip start point -----------------------------------------
                        fTopFixPointY = m_stcBlobLead.fTipCenterY + m_stcBlobLead.intTipInwardOffset;

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.TipStart].SetGaugePlacement(m_stcBlobLead.fTipCenterX - fWidth / 2,
                                                          fTopFixPointY,
                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180);
                 
                            m_arrPointGauge[i][(int)PointIndex.TipStart].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray(m_stcBlobLead.fTipCenterX - fWidth / 2,
                                                                                   fTopFixPointY,
                                                                                  fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.TipStart, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray(m_stcBlobLead.fTipCenterX - fWidth / 2,
                                                    fTopFixPointY,
                                                   fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.TipStart, i);
                            }
                        }
                        if (m_arrPointGauge[i][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                        {
                            pTopStart = m_arrPointGauge[i][(int)PointIndex.TipStart].GetMeasurePoint(0);
                            m_stcBlobLead.blnTipStartFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pTopStart.X, pTopStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pTopStart = new PointF(m_stcBlobLead.fTipCenterX - fWidth / 2, fTopFixPointY);
                            m_stcBlobLead.blnTipStartFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pTopStart.X, pTopStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Tip end point -----------------------------------------
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.TipEnd].SetGaugePlacement(m_stcBlobLead.fTipCenterX + fWidth / 2,
                                                        fTopFixPointY,
                                                       fWidth * (m_fPointGaugeToleranceRate * m), 0);
                          
                            m_arrPointGauge[i][(int)PointIndex.TipEnd].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray(m_stcBlobLead.fTipCenterX + fWidth / 2,
                                                           fTopFixPointY,
                                                          fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.TipEnd, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray(m_stcBlobLead.fTipCenterX + fWidth / 2,
                                                             fTopFixPointY,
                                                            fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.TipEnd, i);
                            }
                        }
                        if (m_arrPointGauge[i][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                        {
                            pTopEnd = m_arrPointGauge[i][(int)PointIndex.TipEnd].GetMeasurePoint(0);
                            m_stcBlobLead.blnTipEndFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pTopEnd.X, pTopEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pTopEnd = new PointF(m_stcBlobLead.fTipCenterX + fWidth / 2, fTopFixPointY);
                            m_stcBlobLead.blnTipEndFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pTopEnd.X, pTopEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // Calculate the Tip width and center X
                        m_stcBlobLead.fTipWidth = pTopEnd.X - pTopStart.X; //m_stcBlobLead.fBaseWidth = 
                        m_stcBlobLead.fTipCenterX = (pTopEnd.X + pTopStart.X) / 2 - objROI.ref_ROITotalX; //m_stcBlobLead.fBaseCenterX = 
                        m_stcBlobLead.fTipCenterY -= objROI.ref_ROITotalY;
                        // Base and Tip Length
                        m_stcBlobLead.fBaseHeight = m_stcBlobLead.fBaseCenterY - m_stcBlobLead.fTipCenterY;
                        m_stcBlobLead.fTipHeight = m_stcBlobLead.fBaseCenterY - m_stcBlobLead.fTipCenterY;
                        break;
                    //Right
                    case 2:
                        //Base
                        fLimitCenterX = objROI.ref_ROITotalX + m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = objROI.ref_ROITotalY + m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        //intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterX - (m_stcBlobLead.fWidth / 2) + m_stcBlobLead.intBaseInwardOffset, 0, MidpointRounding.AwayFromZero);
                        //float fRightFixPointX;
                        //PointF pRightStart;
                        //PointF pRightEnd;
                        //// ------- Find Base -----------------------------------------
                        //m_stcBlobLead.fBaseCenterX = (m_fCenterX_PackageGaugeM4L + m_fWidth_PackageGaugeM4L / 2) + m_intPkgToBaseTolerance_Right;
                        //m_stcBlobLead.fBaseCenterX -= objROI.ref_ROITotalX;
                        //AddPointGaugePlacementToArray(-1, -1, -1, -(int)PointIndex.TipCenter, i);

                        //m_stcBlobLead.blnBaseCenterFound = false;
                        //m_arrLeadEdgeGaugePoints[i].Add(new PointF(-1, -1));
                        //m_arrLeadEdgeGaugePointsFound[i].Add(false);

                        //SetPointGaugePlacementToArray(-1, -1, -1, -1, (int)PointIndex.BaseStart, i);
                        //m_stcBlobLead.blnBaseStartFound = false;
                        //m_arrLeadEdgeGaugePoints[i].Add(new PointF(-1, -1));
                        //m_arrLeadEdgeGaugePointsFound[i].Add(false);

                        //SetPointGaugePlacementToArray(-1, -1, -1, -1, (int)PointIndex.BaseEnd, i);
                        //m_stcBlobLead.blnBaseEndFound = false;
                        //m_arrLeadEdgeGaugePoints[i].Add(new PointF(-1, -1));
                        //m_arrLeadEdgeGaugePointsFound[i].Add(false);

                        // ------- Find Base Point Y -----------------------------------------
                        m_stcBlobLead.fBaseCenterX = (m_fCenterX_PackageGaugeM4L + m_fWidth_PackageGaugeM4L / 2) + m_intPkgToBaseTolerance_Right;
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.BaseCenter].SetGaugePlacement(m_stcBlobLead.fBaseCenterX,
                                                          fLimitCenterY,
                                                          fWidth * (m_fPointGaugeToleranceRate * m), 180);
                          
                            m_arrPointGauge[i][(int)PointIndex.BaseCenter].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                            {
                                AddPointGaugePlacementToArray(m_stcBlobLead.fBaseCenterX,
                                                            fLimitCenterY,
                                                            fWidth * (m_fPointGaugeToleranceRate * m), 180, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                AddPointGaugePlacementToArray(m_stcBlobLead.fBaseCenterX,
                                                            fLimitCenterY,
                                                            fWidth * (m_fPointGaugeToleranceRate * m), 180, i);
                            }
                        }
                        if (m_arrPointGauge[i][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                        {
                            //m_stcBlobLead.fBaseCenterX = m_arrPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointX(0);
                            m_stcBlobLead.fBaseCenterY = m_arrPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointY(0);
                            m_stcBlobLead.blnBaseCenterFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(m_arrPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointX(0), m_stcBlobLead.fBaseCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            //m_stcBlobLead.fBaseCenterX = fLimitCenterX - (m_stcBlobLead.fWidth / 2);
                            m_stcBlobLead.fBaseCenterY = fLimitCenterY;
                            m_stcBlobLead.blnBaseCenterFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(m_stcBlobLead.fBaseCenterX, m_stcBlobLead.fBaseCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Base start point -----------------------------------------
                        float fRightFixPointX = m_stcBlobLead.fBaseCenterX + m_stcBlobLead.intBaseInwardOffset;
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.BaseStart].SetGaugePlacement(fRightFixPointX,
                                                          m_stcBlobLead.fBaseCenterY - fHeight / 2,
                                                         fHeight * (m_fPointGaugeToleranceRate * m), -90);
                           
                            m_arrPointGauge[i][(int)PointIndex.BaseStart].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray(fRightFixPointX,
                                                              m_stcBlobLead.fBaseCenterY - fHeight / 2,
                                                             fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.BaseStart, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray(fRightFixPointX,
                                                                m_stcBlobLead.fBaseCenterY - fHeight / 2,
                                                               fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.BaseStart, i);
                            }
                        }

                        PointF pRightStart;
                        if (m_arrPointGauge[i][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                        {
                            pRightStart = m_arrPointGauge[i][(int)PointIndex.BaseStart].GetMeasurePoint(0);
                            m_stcBlobLead.blnBaseStartFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pRightStart.X, pRightStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pRightStart = new PointF(fRightFixPointX, m_stcBlobLead.fBaseCenterY - fHeight / 2);
                            m_stcBlobLead.blnBaseStartFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pRightStart.X, pRightStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Base end point -----------------------------------------
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.BaseEnd].SetGaugePlacement(fRightFixPointX,
                                                        m_stcBlobLead.fBaseCenterY + fHeight / 2,
                                                       fHeight * (m_fPointGaugeToleranceRate * m), 90);
                          
                            m_arrPointGauge[i][(int)PointIndex.BaseEnd].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray(fRightFixPointX, m_stcBlobLead.fBaseCenterY + fHeight / 2,
                                                                                         fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.BaseEnd, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray(fRightFixPointX, m_stcBlobLead.fBaseCenterY + fHeight / 2,
                                                                                         fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.BaseEnd, i);
                            }
                        }

                        PointF pRightEnd;
                        if (m_arrPointGauge[i][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                        {
                            pRightEnd = m_arrPointGauge[i][(int)PointIndex.BaseEnd].GetMeasurePoint(0);
                            m_stcBlobLead.blnBaseEndFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pRightEnd.X, pRightEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pRightEnd = new PointF(fRightFixPointX, m_stcBlobLead.fBaseCenterY + fHeight / 2);
                            m_stcBlobLead.blnBaseEndFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pRightEnd.X, pRightEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // Calculate the Base width and center Y
                        m_stcBlobLead.fBaseWidth = pRightEnd.Y - pRightStart.Y;
                        m_stcBlobLead.fBaseCenterY = (pRightEnd.Y + pRightStart.Y) / 2 - objROI.ref_ROITotalY;
                        m_stcBlobLead.fBaseCenterX -= objROI.ref_ROITotalX;


                        //Tip
                        fLimitCenterX = objROI.ref_ROITotalX + m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = objROI.ref_ROITotalY + m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        //intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterX + (m_stcBlobLead.fWidth / 2) - m_stcBlobLead.intTipInwardOffset, 0, MidpointRounding.AwayFromZero);

                        // ------- Find Tip Point X -----------------------------------------
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.TipCenter].SetGaugePlacement(fLimitCenterX + (m_stcBlobLead.fWidth / 2),
                                                        fLimitCenterY,
                                                        fWidth * (m_fPointGaugeToleranceRate * m), 0);
                            
                            m_arrPointGauge[i][(int)PointIndex.TipCenter].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray(fLimitCenterX + (m_stcBlobLead.fWidth / 2),
                                                            fLimitCenterY,
                                                            fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.TipCenter, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray(fLimitCenterX + (m_stcBlobLead.fWidth / 2),
                                                             fLimitCenterY,
                                                             fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.TipCenter, i);
                            }
                        }

                        if (m_arrPointGauge[i][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                        {
                            m_stcBlobLead.fTipCenterX = m_arrPointGauge[i][(int)PointIndex.TipCenter].GetMeasurePointX(0);
                            m_stcBlobLead.fTipCenterY = m_arrPointGauge[i][(int)PointIndex.TipCenter].GetMeasurePointY(0);
                            m_stcBlobLead.blnTipCenterFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            m_stcBlobLead.fTipCenterX = fLimitCenterX + (m_stcBlobLead.fWidth / 2);
                            m_stcBlobLead.fTipCenterY = fLimitCenterY;
                            m_stcBlobLead.blnTipCenterFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Tip start point -----------------------------------------
                        fRightFixPointX = m_stcBlobLead.fTipCenterX - m_stcBlobLead.intTipInwardOffset;
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.TipStart].SetGaugePlacement(fRightFixPointX,
                                                          m_stcBlobLead.fTipCenterY - (m_stcBlobLead.fHeight / 2),
                                                         fHeight * (m_fPointGaugeToleranceRate * m), -90);
                          
                            m_arrPointGauge[i][(int)PointIndex.TipStart].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray(fRightFixPointX,
                                                            m_stcBlobLead.fTipCenterY - (m_stcBlobLead.fHeight / 2),
                                                           fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.TipStart, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray(fRightFixPointX,
                                                               m_stcBlobLead.fTipCenterY - (m_stcBlobLead.fHeight / 2),
                                                              fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.TipStart, i);
                            }
                        }
                        if (m_arrPointGauge[i][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                        {
                            pRightStart = m_arrPointGauge[i][(int)PointIndex.TipStart].GetMeasurePoint(0);
                            m_stcBlobLead.blnTipStartFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pRightStart.X, pRightStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pRightStart = new PointF(fRightFixPointX, m_stcBlobLead.fTipCenterY - (m_stcBlobLead.fHeight / 2));
                            m_stcBlobLead.blnTipStartFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pRightStart.X, pRightStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Tip end point -----------------------------------------
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.TipEnd].SetGaugePlacement(fRightFixPointX,
                                                              m_stcBlobLead.fTipCenterY + (m_stcBlobLead.fHeight / 2),
                                                             fHeight * (m_fPointGaugeToleranceRate * m), 90);
                       
                            m_arrPointGauge[i][(int)PointIndex.TipEnd].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray(fRightFixPointX,
                                                                 m_stcBlobLead.fTipCenterY + (m_stcBlobLead.fHeight / 2),
                                                                fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.TipEnd, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray(fRightFixPointX,
                                                                m_stcBlobLead.fTipCenterY + (m_stcBlobLead.fHeight / 2),
                                                               fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.TipEnd, i);
                            }
                        }
                        if (m_arrPointGauge[i][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                        {
                            pRightEnd = m_arrPointGauge[i][(int)PointIndex.TipEnd].GetMeasurePoint(0);
                            m_stcBlobLead.blnTipEndFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pRightEnd.X, pRightEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pRightEnd = new PointF(fRightFixPointX, m_stcBlobLead.fTipCenterY + (m_stcBlobLead.fHeight / 2));
                            m_stcBlobLead.blnTipEndFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pRightEnd.X, pRightEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // Calculate the Tip width and center Y
                        m_stcBlobLead.fTipWidth = pRightEnd.Y - pRightStart.Y; //m_stcBlobLead.fBaseWidth = 
                        m_stcBlobLead.fTipCenterY = (pRightEnd.Y + pRightStart.Y) / 2 - objROI.ref_ROITotalY; //m_stcBlobLead.fBaseCenterY = 
                        m_stcBlobLead.fTipCenterX -= objROI.ref_ROITotalX;

                        // Base and Tip Length
                        m_stcBlobLead.fBaseHeight = m_stcBlobLead.fTipCenterX - m_stcBlobLead.fBaseCenterX;
                        m_stcBlobLead.fTipHeight = m_stcBlobLead.fTipCenterX - m_stcBlobLead.fBaseCenterX;
                        break;
                    //Bottom
                    case 3:
                        //Base
                        fLimitCenterX = objROI.ref_ROITotalX + m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = objROI.ref_ROITotalY + m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        //intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterY - (m_stcBlobLead.fHeight / 2) + m_stcBlobLead.intBaseInwardOffset, 0, MidpointRounding.AwayFromZero);

                        //float fBottomFixPointY;
                        //PointF pBottomStart;
                        //PointF pBottomEnd;

                        //// ------- Find Base -----------------------------------------
                        //m_stcBlobLead.fBaseCenterY = (m_fCenterY_PackageGaugeM4L + m_fHeight_PackageGaugeM4L / 2) + m_intPkgToBaseTolerance_Bottom;
                        //m_stcBlobLead.fBaseCenterY -= objROI.ref_ROITotalY;
                        //AddPointGaugePlacementToArray(-1, -1, -1, -(int)PointIndex.TipCenter, i);
                        //m_stcBlobLead.blnBaseCenterFound = false;
                        //m_arrLeadEdgeGaugePoints[i].Add(new PointF(-1, -1));
                        //m_arrLeadEdgeGaugePointsFound[i].Add(false);

                        //SetPointGaugePlacementToArray(-1, -1, -1, -1, (int)PointIndex.BaseStart, i);
                        //m_stcBlobLead.blnBaseStartFound = false;
                        //m_arrLeadEdgeGaugePoints[i].Add(new PointF(-1, -1));
                        //m_arrLeadEdgeGaugePointsFound[i].Add(false);

                        //SetPointGaugePlacementToArray(-1, -1, -1, -1, (int)PointIndex.BaseEnd, i);
                        //m_stcBlobLead.blnBaseEndFound = false;
                        //m_arrLeadEdgeGaugePoints[i].Add(new PointF(-1, -1));
                        //m_arrLeadEdgeGaugePointsFound[i].Add(false);

                        // ------- Find Base Point X -----------------------------------------
                        m_stcBlobLead.fBaseCenterY = (m_fCenterY_PackageGaugeM4L + m_fHeight_PackageGaugeM4L / 2) + m_intPkgToBaseTolerance_Bottom;
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.BaseCenter].SetGaugePlacement(fLimitCenterX,
                                                          m_stcBlobLead.fBaseCenterY,
                                                          fHeight * (m_fPointGaugeToleranceRate * m), -90);
                            
                            m_arrPointGauge[i][(int)PointIndex.BaseCenter].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                            {
                                AddPointGaugePlacementToArray(fLimitCenterX,
                                                              m_stcBlobLead.fBaseCenterY,
                                                              fHeight * (m_fPointGaugeToleranceRate * m), -90, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                AddPointGaugePlacementToArray(fLimitCenterX,
                                                              m_stcBlobLead.fBaseCenterY,
                                                              fHeight * (m_fPointGaugeToleranceRate * m), -90, i);
                            }
                        }
                        if (m_arrPointGauge[i][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                        {
                            m_stcBlobLead.fBaseCenterX = m_arrPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointX(0);
                            //m_stcBlobLead.fBaseCenterY = m_arrPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointY(0);
                            m_stcBlobLead.blnBaseCenterFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(m_stcBlobLead.fBaseCenterX, m_arrPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointY(0)));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            m_stcBlobLead.fBaseCenterX = fLimitCenterX;
                            //m_stcBlobLead.fBaseCenterY = fLimitCenterY - (m_stcBlobLead.fHeight / 2);
                            m_stcBlobLead.blnBaseCenterFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(m_stcBlobLead.fBaseCenterX, m_stcBlobLead.fBaseCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Base start point -----------------------------------------
                        float fBottomFixPointY = m_stcBlobLead.fBaseCenterY + m_stcBlobLead.intBaseInwardOffset;
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.BaseStart].SetGaugePlacement(m_stcBlobLead.fBaseCenterX - fWidth / 2,
                                                          fBottomFixPointY,
                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180);
                            
                            m_arrPointGauge[i][(int)PointIndex.BaseStart].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray(m_stcBlobLead.fBaseCenterX - fWidth / 2,
                                                              fBottomFixPointY,
                                                             fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.BaseStart, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray(m_stcBlobLead.fBaseCenterX - fWidth / 2,
                                                              fBottomFixPointY,
                                                             fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.BaseStart, i);
                            }
                        }
                        PointF pBottomStart;
                        if (m_arrPointGauge[i][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                        {
                            pBottomStart = m_arrPointGauge[i][(int)PointIndex.BaseStart].GetMeasurePoint(0);
                            m_stcBlobLead.blnBaseStartFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pBottomStart.X, pBottomStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pBottomStart = new PointF(m_stcBlobLead.fBaseCenterX - fWidth / 2, fBottomFixPointY);
                            m_stcBlobLead.blnBaseStartFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pBottomStart.X, pBottomStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Base end point -----------------------------------------
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.BaseEnd].SetGaugePlacement(m_stcBlobLead.fBaseCenterX + fWidth / 2,
                                                        fBottomFixPointY,
                                                       fWidth * (m_fPointGaugeToleranceRate * m), 0);
                            
                            m_arrPointGauge[i][(int)PointIndex.BaseEnd].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray(m_stcBlobLead.fBaseCenterX + fWidth / 2,
                                                            fBottomFixPointY,
                                                           fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.BaseEnd, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray(m_stcBlobLead.fBaseCenterX + fWidth / 2,
                                                                fBottomFixPointY,
                                                               fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.BaseEnd, i);
                            }
                        }
                        PointF pBottomEnd;
                        if (m_arrPointGauge[i][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                        {
                            pBottomEnd = m_arrPointGauge[i][(int)PointIndex.BaseEnd].GetMeasurePoint(0);
                            m_stcBlobLead.blnBaseEndFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pBottomEnd.X, pBottomEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pBottomEnd = new PointF(m_stcBlobLead.fBaseCenterX + fWidth / 2, fBottomFixPointY);
                            m_stcBlobLead.blnBaseEndFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pBottomEnd.X, pBottomEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // Calculate the Base width and center X
                        m_stcBlobLead.fBaseWidth = pBottomEnd.X - pBottomStart.X;
                        m_stcBlobLead.fBaseCenterX = (pBottomEnd.X + pBottomStart.X) / 2 - objROI.ref_ROITotalX;
                        m_stcBlobLead.fBaseCenterY -= objROI.ref_ROITotalY;


                        //Tip
                        fLimitCenterX = objROI.ref_ROITotalX + m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = objROI.ref_ROITotalY + m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        //intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterY + (m_stcBlobLead.fHeight / 2) - m_stcBlobLead.intTipInwardOffset, 0, MidpointRounding.AwayFromZero);

                        // ------- Find Tip Point X -----------------------------------------
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.TipCenter].SetGaugePlacement(fLimitCenterX,
                                                          fLimitCenterY + (m_stcBlobLead.fHeight / 2),
                                                          fHeight * (m_fPointGaugeToleranceRate * m), 90);
                            
                            m_arrPointGauge[i][(int)PointIndex.TipCenter].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray(fLimitCenterX,
                                                              fLimitCenterY + (m_stcBlobLead.fHeight / 2),
                                                              fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.TipCenter, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray(fLimitCenterX,
                                                              fLimitCenterY + (m_stcBlobLead.fHeight / 2),
                                                              fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.TipCenter, i);
                            }
                        }
                        if (m_arrPointGauge[i][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                        {
                            m_stcBlobLead.fTipCenterX = m_arrPointGauge[i][(int)PointIndex.TipCenter].GetMeasurePointX(0);
                            m_stcBlobLead.fTipCenterY = m_arrPointGauge[i][(int)PointIndex.TipCenter].GetMeasurePointY(0);
                            m_stcBlobLead.blnTipCenterFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            m_stcBlobLead.fTipCenterX = fLimitCenterX;
                            m_stcBlobLead.fTipCenterY = fLimitCenterY + (m_stcBlobLead.fHeight / 2);
                            m_stcBlobLead.blnTipCenterFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Tip start point -----------------------------------------
                        fBottomFixPointY = m_stcBlobLead.fTipCenterY - m_stcBlobLead.intTipInwardOffset;
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.TipStart].SetGaugePlacement(m_stcBlobLead.fTipCenterX - fWidth / 2,
                                                          fBottomFixPointY,
                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180);
                          
                            m_arrPointGauge[i][(int)PointIndex.TipStart].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray(m_stcBlobLead.fTipCenterX - fWidth / 2,
                                                               fBottomFixPointY,
                                                              fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.TipStart, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray(m_stcBlobLead.fTipCenterX - fWidth / 2,
                                                            fBottomFixPointY,
                                                           fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.TipStart, i);
                            }
                        }
                        if (m_arrPointGauge[i][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                        {
                            pBottomStart = m_arrPointGauge[i][(int)PointIndex.TipStart].GetMeasurePoint(0);
                            m_stcBlobLead.blnTipStartFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pBottomStart.X, pBottomStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pBottomStart = new PointF(m_stcBlobLead.fTipCenterX - fWidth / 2, fBottomFixPointY);
                            m_stcBlobLead.blnTipStartFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pBottomStart.X, pBottomStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Tip end point -----------------------------------------
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.TipEnd].SetGaugePlacement(m_stcBlobLead.fTipCenterX + fWidth / 2,
                                                        fBottomFixPointY,
                                                       fWidth * (m_fPointGaugeToleranceRate * m), 0);
                            
                            m_arrPointGauge[i][(int)PointIndex.TipEnd].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray(m_stcBlobLead.fTipCenterX + fWidth / 2,
                                                              fBottomFixPointY,
                                                             fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.TipEnd, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray(m_stcBlobLead.fTipCenterX + fWidth / 2,
                                                                fBottomFixPointY,
                                                               fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.TipEnd, i);
                            }
                        }
                        if (m_arrPointGauge[i][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                        {
                            pBottomEnd = m_arrPointGauge[i][(int)PointIndex.TipEnd].GetMeasurePoint(0);
                            m_stcBlobLead.blnTipEndFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pBottomEnd.X, pBottomEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pBottomEnd = new PointF(m_stcBlobLead.fTipCenterX + fWidth / 2, fBottomFixPointY);
                            m_stcBlobLead.blnTipEndFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pBottomEnd.X, pBottomEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // Calculate the Tip width and center X
                        m_stcBlobLead.fTipWidth = pBottomEnd.X - pBottomStart.X; //m_stcBlobLead.fBaseWidth = 
                        m_stcBlobLead.fTipCenterX = (pBottomEnd.X + pBottomStart.X) / 2 - objROI.ref_ROITotalX; //m_stcBlobLead.fBaseCenterX = 
                        m_stcBlobLead.fTipCenterY -= objROI.ref_ROITotalY;

                        // Base and Tip Length
                        m_stcBlobLead.fBaseHeight = m_stcBlobLead.fTipCenterY - m_stcBlobLead.fBaseCenterY;
                        m_stcBlobLead.fTipHeight = m_stcBlobLead.fTipCenterY - m_stcBlobLead.fBaseCenterY;
                        break;
                    //Left
                    case 4:
                        //Base
                        fLimitCenterX = objROI.ref_ROITotalX + m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = objROI.ref_ROITotalY + m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        //intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterX + (m_stcBlobLead.fWidth / 2) - m_stcBlobLead.intBaseInwardOffset, 0, MidpointRounding.AwayFromZero);

                        //float fLeftFixPointX;
                        //PointF pLeftStart;
                        //PointF pLeftEnd;

                        //// ------- Find Base -----------------------------------------
                        //m_stcBlobLead.fBaseCenterX = (m_fCenterX_PackageGaugeM4L - m_fWidth_PackageGaugeM4L / 2) - m_intPkgToBaseTolerance_Left;
                        //m_stcBlobLead.fBaseCenterX -= objROI.ref_ROITotalX;
                        //AddPointGaugePlacementToArray(-1, -1, -1, -(int)PointIndex.TipCenter, i);
                        //m_stcBlobLead.blnBaseCenterFound = false;
                        //m_arrLeadEdgeGaugePoints[i].Add(new PointF(-1, -1));
                        //m_arrLeadEdgeGaugePointsFound[i].Add(false);

                        //SetPointGaugePlacementToArray(-1, -1, -1, -1, (int)PointIndex.BaseStart, i);
                        //m_stcBlobLead.blnBaseStartFound = false;
                        //m_arrLeadEdgeGaugePoints[i].Add(new PointF(-1, -1));
                        //m_arrLeadEdgeGaugePointsFound[i].Add(false);

                        //SetPointGaugePlacementToArray(-1, -1, -1, -1, (int)PointIndex.BaseEnd, i);
                        //m_stcBlobLead.blnBaseEndFound = false;
                        //m_arrLeadEdgeGaugePoints[i].Add(new PointF(-1, -1));
                        //m_arrLeadEdgeGaugePointsFound[i].Add(false);

                        // ------- Find Base Point Y -----------------------------------------
                        m_stcBlobLead.fBaseCenterX = (m_fCenterX_PackageGaugeM4L - m_fWidth_PackageGaugeM4L / 2) - m_intPkgToBaseTolerance_Left;
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.BaseCenter].SetGaugePlacement(m_stcBlobLead.fBaseCenterX,
                                                          fLimitCenterY,
                                                          fWidth * (m_fPointGaugeToleranceRate * m), 0);
                            
                            m_arrPointGauge[i][(int)PointIndex.BaseCenter].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                            {
                                AddPointGaugePlacementToArray(m_stcBlobLead.fBaseCenterX,
                                                              fLimitCenterY,
                                                              fWidth * (m_fPointGaugeToleranceRate * m), (int)PointIndex.BaseCenter, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                AddPointGaugePlacementToArray(m_stcBlobLead.fBaseCenterX,
                                                              fLimitCenterY,
                                                              fWidth * (m_fPointGaugeToleranceRate * m), (int)PointIndex.BaseCenter, i);
                            }
                        }
                        if (m_arrPointGauge[i][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                        {
                            //m_stcBlobLead.fBaseCenterX = m_arrPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointX(0);
                            m_stcBlobLead.fBaseCenterY = m_arrPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointY(0);
                            m_stcBlobLead.blnBaseCenterFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(m_arrPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointX(0), m_stcBlobLead.fBaseCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            //m_stcBlobLead.fBaseCenterX = fLimitCenterX + (m_stcBlobLead.fWidth / 2);
                            m_stcBlobLead.fBaseCenterY = fLimitCenterY;
                            m_stcBlobLead.blnBaseCenterFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(m_stcBlobLead.fBaseCenterX, m_stcBlobLead.fBaseCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Base start point -----------------------------------------
                        float fLeftFixPointX = m_stcBlobLead.fBaseCenterX - m_stcBlobLead.intBaseInwardOffset;
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.BaseStart].SetGaugePlacement(fLeftFixPointX,
                                                          m_stcBlobLead.fBaseCenterY - fHeight / 2,
                                                         fHeight * (m_fPointGaugeToleranceRate * m), -90);
                            
                            m_arrPointGauge[i][(int)PointIndex.BaseStart].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray(fLeftFixPointX,
                                                              m_stcBlobLead.fBaseCenterY - fHeight / 2,
                                                             fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.BaseStart, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray(fLeftFixPointX,
                                                              m_stcBlobLead.fBaseCenterY - fHeight / 2,
                                                             fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.BaseStart, i);
                            }
                        }
                        PointF pLeftStart;
                        if (m_arrPointGauge[i][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                        {
                            pLeftStart = m_arrPointGauge[i][(int)PointIndex.BaseStart].GetMeasurePoint(0);
                            m_stcBlobLead.blnBaseStartFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pLeftStart.X, pLeftStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pLeftStart = new PointF(fLeftFixPointX, m_stcBlobLead.fBaseCenterY - fHeight / 2);
                            m_stcBlobLead.blnBaseStartFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pLeftStart.X, pLeftStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Base end point -----------------------------------------
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.BaseEnd].SetGaugePlacement(fLeftFixPointX,
                                                        m_stcBlobLead.fBaseCenterY + fHeight / 2,
                                                       fHeight * (m_fPointGaugeToleranceRate * m), 90);
                            
                            m_arrPointGauge[i][(int)PointIndex.BaseEnd].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray(fLeftFixPointX,
                                                            m_stcBlobLead.fBaseCenterY + fHeight / 2,
                                                           fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.BaseEnd, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray(fLeftFixPointX,
                                                            m_stcBlobLead.fBaseCenterY + fHeight / 2,
                                                           fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.BaseEnd, i);
                            }
                        }
                        PointF pLeftEnd;
                        if (m_arrPointGauge[i][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                        {
                            pLeftEnd = m_arrPointGauge[i][(int)PointIndex.BaseEnd].GetMeasurePoint(0);
                            m_stcBlobLead.blnBaseEndFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pLeftEnd.X, pLeftEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pLeftEnd = new PointF(fLeftFixPointX, m_stcBlobLead.fBaseCenterY + fHeight / 2);
                            m_stcBlobLead.blnBaseEndFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pLeftEnd.X, pLeftEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // Calculate the Base width center Y
                        m_stcBlobLead.fBaseWidth = pLeftEnd.Y - pLeftStart.Y;
                        m_stcBlobLead.fBaseCenterY = (pLeftEnd.Y + pLeftStart.Y) / 2 - objROI.ref_ROITotalY;
                        m_stcBlobLead.fBaseCenterX -= objROI.ref_ROITotalX;


                        //Tip
                        fLimitCenterX = objROI.ref_ROITotalX + m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = objROI.ref_ROITotalY + m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        //intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterX - (m_stcBlobLead.fWidth / 2) + m_stcBlobLead.intTipInwardOffset, 0, MidpointRounding.AwayFromZero);

                        // ------- Find Tip Point X -----------------------------------------
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.TipCenter].SetGaugePlacement(fLimitCenterX - (m_stcBlobLead.fWidth / 2),
                                                        fLimitCenterY,
                                                        fWidth * (m_fPointGaugeToleranceRate * m), 180);
                            
                            m_arrPointGauge[i][(int)PointIndex.TipCenter].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray(fLimitCenterX - (m_stcBlobLead.fWidth / 2),
                                                            fLimitCenterY,
                                                            fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.TipCenter, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray(fLimitCenterX - (m_stcBlobLead.fWidth / 2),
                                                            fLimitCenterY,
                                                            fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.TipCenter, i);
                            }
                        }
                        if (m_arrPointGauge[i][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                        {
                            m_stcBlobLead.fTipCenterX = m_arrPointGauge[i][(int)PointIndex.TipCenter].GetMeasurePointX(0);
                            m_stcBlobLead.fTipCenterY = m_arrPointGauge[i][(int)PointIndex.TipCenter].GetMeasurePointY(0);
                            m_stcBlobLead.blnTipCenterFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            m_stcBlobLead.fTipCenterX = fLimitCenterX - (m_stcBlobLead.fWidth / 2);
                            m_stcBlobLead.fTipCenterY = fLimitCenterY;
                            m_stcBlobLead.blnTipCenterFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Tip start point -----------------------------------------
                        fLeftFixPointX = m_stcBlobLead.fTipCenterX + m_stcBlobLead.intTipInwardOffset;
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.TipStart].SetGaugePlacement(fLeftFixPointX,
                                                          m_stcBlobLead.fTipCenterY - (m_stcBlobLead.fHeight / 2),
                                                         fHeight * (m_fPointGaugeToleranceRate * m), -90);
                            
                            m_arrPointGauge[i][(int)PointIndex.TipStart].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray(fLeftFixPointX,
                                                              m_stcBlobLead.fTipCenterY - (m_stcBlobLead.fHeight / 2),
                                                             fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.TipStart, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray(fLeftFixPointX,
                                                              m_stcBlobLead.fTipCenterY - (m_stcBlobLead.fHeight / 2),
                                                             fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.TipStart, i);
                            }
                        }
                        if (m_arrPointGauge[i][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                        {
                            pLeftStart = m_arrPointGauge[i][(int)PointIndex.TipStart].GetMeasurePoint(0);
                            m_stcBlobLead.blnTipStartFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pLeftStart.X, pLeftStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pLeftStart = new PointF(fLeftFixPointX, m_stcBlobLead.fTipCenterY - (m_stcBlobLead.fHeight / 2));
                            m_stcBlobLead.blnTipStartFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pLeftStart.X, pLeftStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Tip end point -----------------------------------------
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.TipEnd].SetGaugePlacement(fLeftFixPointX,
                                                              m_stcBlobLead.fTipCenterY + (m_stcBlobLead.fHeight / 2),
                                                             fHeight * (m_fPointGaugeToleranceRate * m), 90);
                            
                            m_arrPointGauge[i][(int)PointIndex.TipEnd].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray(fLeftFixPointX,
                                                                  m_stcBlobLead.fTipCenterY + (m_stcBlobLead.fHeight / 2),
                                                                 fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.TipEnd, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray(fLeftFixPointX,
                                                                  m_stcBlobLead.fTipCenterY + (m_stcBlobLead.fHeight / 2),
                                                                 fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.TipEnd, i);
                            }
                        }
                        if (m_arrPointGauge[i][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                        {
                            pLeftEnd = m_arrPointGauge[i][(int)PointIndex.TipEnd].GetMeasurePoint(0);
                            m_stcBlobLead.blnTipEndFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pLeftEnd.X, pLeftEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pLeftEnd = new PointF(fLeftFixPointX, m_stcBlobLead.fTipCenterY + (m_stcBlobLead.fHeight / 2));
                            m_stcBlobLead.blnTipEndFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pLeftEnd.X, pLeftEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // Calculate the Tip width and center Y
                        m_stcBlobLead.fTipWidth = pLeftEnd.Y - pLeftStart.Y; //m_stcBlobLead.fBaseWidth = 
                        m_stcBlobLead.fTipCenterY = (pLeftEnd.Y + pLeftStart.Y) / 2 - objROI.ref_ROITotalY; //m_stcBlobLead.fBaseCenterY = 
                        m_stcBlobLead.fTipCenterX -= objROI.ref_ROITotalX;

                        // Base and Tip Length
                        m_stcBlobLead.fBaseHeight = m_stcBlobLead.fBaseCenterX - m_stcBlobLead.fTipCenterX;
                        m_stcBlobLead.fTipHeight = m_stcBlobLead.fBaseCenterX - m_stcBlobLead.fTipCenterX;
                        break;
                }

                m_arrTemplateBlobLeads.RemoveAt(i);
                m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
            }
        }
        public void DefineLeadBaseTipWidthHeight(int intLeadPosition, ROI objROI)
        {
            float fLimitCenterX;
            float fLimitCenterY;
            float fNewCenterX;
            float fNewCenterY;
            float fWidth;
            float fHeight;
            int intFixPointXY;

            m_arrLeadPointGaugeStartX.Clear();
            m_arrLeadPointGaugeStartY.Clear();
            m_arrLeadPointGaugeTolerance.Clear();
            m_arrLeadPointGaugeAngle.Clear();
            m_arrLeadEdgeGaugePoints.Clear();
            m_arrLeadEdgeGaugePointsFound.Clear();
            m_arrLeadEdgeGaugePointsPosition.Clear();
            m_arrLeadEdgeGaugePointsIDNo.Clear();
            //int intTotalCount = 0;
            //for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            //{
            //    m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
            //    if (m_stcBlobLead.intNoID > intTotalCount)
            //    {
            //        intTotalCount = m_stcBlobLead.intNoID;
            //    }
            //}
            for (int p = m_arrLeadEdgeGaugePoints.Count; p < m_arrTemplateBlobLeads.Count; p++)//intTotalCount
            {
                m_arrLeadEdgeGaugePoints.Add(new List<PointF>());
                m_arrLeadEdgeGaugePointsFound.Add(new List<bool>());
                m_arrLeadEdgeGaugePointsPosition.Add(0);
                m_arrLeadEdgeGaugePointsIDNo.Add(0);
                m_arrLeadPointGaugeStartX.Add(new List<float>());
                m_arrLeadPointGaugeStartY.Add(new List<float>());
                m_arrLeadPointGaugeTolerance.Add(new List<float>());
                m_arrLeadPointGaugeAngle.Add(new List<float>());
            }
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                m_arrLeadEdgeGaugePointsPosition[i] = intLeadPosition;
                m_arrLeadEdgeGaugePointsIDNo[i] = m_stcBlobLead.intNoID;
                switch (intLeadPosition)
                {
                    //Top
                    case 1:
                        //Base
                        fLimitCenterX = objROI.ref_ROITotalX + m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = objROI.ref_ROITotalY + m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        //intFixPointXY = (int)Math.Round(objROI.ref_ROITotalY + m_stcBlobLead.fLimitCenterY + (m_stcBlobLead.fHeight / 2) - m_stcBlobLead.intBaseInwardOffset, 0, MidpointRounding.AwayFromZero);

                        // ------- Find Base Point X -----------------------------------------
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.BaseCenter].SetGaugePlacement(fLimitCenterX, fLimitCenterY + fHeight / 2, fHeight * (m_fPointGaugeToleranceRate * m), 90);
                            
                            m_arrPointGauge[i][(int)PointIndex.BaseCenter].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                            {
                                AddPointGaugePlacementToArray(fLimitCenterX, fLimitCenterY + fHeight / 2, fHeight * (m_fPointGaugeToleranceRate * m), 90, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                AddPointGaugePlacementToArray(fLimitCenterX, fLimitCenterY + fHeight / 2, fHeight * (m_fPointGaugeToleranceRate * m), 90, i);
                            }
                        }
                        if (m_arrPointGauge[i][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                        {
                            m_stcBlobLead.fBaseCenterX = m_arrPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointX(0);
                            m_stcBlobLead.fBaseCenterY = m_arrPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointY(0);
                            m_stcBlobLead.blnBaseCenterFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(m_stcBlobLead.fBaseCenterX, m_stcBlobLead.fBaseCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            m_stcBlobLead.fBaseCenterX = fLimitCenterX;
                            m_stcBlobLead.fBaseCenterY = fLimitCenterY + (m_stcBlobLead.fHeight / 2);
                            m_stcBlobLead.blnBaseCenterFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(m_stcBlobLead.fBaseCenterX, m_stcBlobLead.fBaseCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Base start point -----------------------------------------
                        float fTopFixPointY = m_stcBlobLead.fBaseCenterY - m_stcBlobLead.intBaseInwardOffset;
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.BaseStart].SetGaugePlacement(m_stcBlobLead.fBaseCenterX - fWidth / 2, fTopFixPointY, fWidth * (m_fPointGaugeToleranceRate * m), 180);
                            
                            m_arrPointGauge[i][(int)PointIndex.BaseStart].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray(m_stcBlobLead.fBaseCenterX - fWidth / 2,
                                                          fTopFixPointY,
                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.BaseStart, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray(m_stcBlobLead.fBaseCenterX - fWidth / 2,
                                                           fTopFixPointY,
                                                          fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.BaseStart, i);
                            }
                        }
                        PointF pTopStart;
                        if (m_arrPointGauge[i][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                        {
                            pTopStart = m_arrPointGauge[i][(int)PointIndex.BaseStart].GetMeasurePoint(0);
                            m_stcBlobLead.blnBaseStartFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pTopStart.X, pTopStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pTopStart = new PointF(m_stcBlobLead.fBaseCenterX - fWidth / 2, fTopFixPointY);
                            m_stcBlobLead.blnBaseStartFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pTopStart.X, pTopStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Base end point -----------------------------------------
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.BaseEnd].SetGaugePlacement(fLimitCenterX + fWidth / 2, fTopFixPointY, fWidth * (m_fPointGaugeToleranceRate * m), 0);
                            
                            m_arrPointGauge[i][(int)PointIndex.BaseEnd].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray(m_stcBlobLead.fBaseCenterX + fWidth / 2,
                                                          fTopFixPointY,
                                                         fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.BaseEnd, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray(m_stcBlobLead.fBaseCenterX + fWidth / 2,
                                                          fTopFixPointY,
                                                         fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.BaseEnd, i);
                            }
                        }
                        PointF pTopEnd;
                        if (m_arrPointGauge[i][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                        {
                            pTopEnd = m_arrPointGauge[i][(int)PointIndex.BaseEnd].GetMeasurePoint(0);
                            m_stcBlobLead.blnBaseEndFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pTopEnd.X, pTopEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pTopEnd = new PointF(m_stcBlobLead.fBaseCenterX + fWidth / 2, fTopFixPointY);
                            m_stcBlobLead.blnBaseEndFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pTopEnd.X, pTopEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // Calculate the Base width and center X
                        m_stcBlobLead.fBaseWidth = pTopEnd.X - pTopStart.X;
                        m_stcBlobLead.fBaseCenterX = (pTopEnd.X + pTopStart.X) / 2 - objROI.ref_ROITotalX;
                        m_stcBlobLead.fBaseCenterY -= objROI.ref_ROITotalY;

                        //Tip
                        fLimitCenterX = objROI.ref_ROITotalX + m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = objROI.ref_ROITotalY + m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        //intFixPointXY = (int)Math.Round(objROI.ref_ROITotalY + m_stcBlobLead.fLimitCenterY - (m_stcBlobLead.fHeight / 2) + m_stcBlobLead.intTipInwardOffset, 0, MidpointRounding.AwayFromZero);

                        // ------- Find Tip Point X -----------------------------------------
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.TipCenter].SetGaugePlacement(fLimitCenterX, fLimitCenterY - fHeight / 2, fHeight * (m_fPointGaugeToleranceRate * m), -90);
                            
                            m_arrPointGauge[i][(int)PointIndex.TipCenter].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray(fLimitCenterX,
                                                           fLimitCenterY - (fHeight / 2),
                                                           fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.TipCenter, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray(fLimitCenterX,
                                                           fLimitCenterY - (fHeight / 2),
                                                           fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.TipCenter, i);
                            }
                        }
                        if (m_arrPointGauge[i][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                        {
                            m_stcBlobLead.fTipCenterX = m_arrPointGauge[i][(int)PointIndex.TipCenter].GetMeasurePointX(0);
                            m_stcBlobLead.fTipCenterY = m_arrPointGauge[i][(int)PointIndex.TipCenter].GetMeasurePointY(0);
                            m_stcBlobLead.blnTipCenterFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            m_stcBlobLead.fTipCenterX = fLimitCenterX;
                            m_stcBlobLead.fTipCenterY = fLimitCenterY - (m_stcBlobLead.fHeight / 2);
                            m_stcBlobLead.blnTipCenterFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Tip start point -----------------------------------------
                        fTopFixPointY = m_stcBlobLead.fTipCenterY + m_stcBlobLead.intTipInwardOffset;
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.TipStart].SetGaugePlacement(m_stcBlobLead.fTipCenterX - fWidth / 2,
                                                          fTopFixPointY,
                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180);
                            
                            m_arrPointGauge[i][(int)PointIndex.TipStart].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray(m_stcBlobLead.fTipCenterX - fWidth / 2,
                                                              fTopFixPointY,
                                                             fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.TipStart, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray(m_stcBlobLead.fTipCenterX - fWidth / 2,
                                                              fTopFixPointY,
                                                             fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.TipStart, i);
                            }
                        }
                        if (m_arrPointGauge[i][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                        {
                            pTopStart = m_arrPointGauge[i][(int)PointIndex.TipStart].GetMeasurePoint(0);
                            m_stcBlobLead.blnTipStartFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pTopStart.X, pTopStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pTopStart = new PointF(m_stcBlobLead.fTipCenterX - fWidth / 2, fTopFixPointY);
                            m_stcBlobLead.blnTipStartFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pTopStart.X, pTopStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Tip end point -----------------------------------------
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.TipEnd].SetGaugePlacement(m_stcBlobLead.fTipCenterX + fWidth / 2,
                                                        fTopFixPointY,
                                                       fWidth * (m_fPointGaugeToleranceRate * m), 0);
                            
                            m_arrPointGauge[i][(int)PointIndex.TipEnd].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray(m_stcBlobLead.fTipCenterX + fWidth / 2,
                                                            fTopFixPointY,
                                                           fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.TipEnd, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray(m_stcBlobLead.fTipCenterX + fWidth / 2,
                                                            fTopFixPointY,
                                                           fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.TipEnd, i);
                            }
                        }

                        if (m_arrPointGauge[i][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                        {
                            pTopEnd = m_arrPointGauge[i][(int)PointIndex.TipEnd].GetMeasurePoint(0);
                            m_stcBlobLead.blnTipEndFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pTopEnd.X, pTopEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pTopEnd = new PointF(m_stcBlobLead.fTipCenterX + fWidth / 2, fTopFixPointY);
                            m_stcBlobLead.blnTipEndFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pTopEnd.X, pTopEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // Calculate the Tip width and center X
                        m_stcBlobLead.fTipWidth = pTopEnd.X - pTopStart.X;
                        m_stcBlobLead.fTipCenterX = (pTopEnd.X + pTopStart.X) / 2 - objROI.ref_ROITotalX;
                        m_stcBlobLead.fTipCenterY -= objROI.ref_ROITotalY;
                        // Base and Tip Length
                        m_stcBlobLead.fBaseHeight = m_stcBlobLead.fBaseCenterY - m_stcBlobLead.fTipCenterY;
                        m_stcBlobLead.fTipHeight = m_stcBlobLead.fBaseCenterY - m_stcBlobLead.fTipCenterY;
                        break;
                    //Right
                    case 2:
                        //Base
                        fLimitCenterX = objROI.ref_ROITotalX + m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = objROI.ref_ROITotalY + m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        //intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterX - (m_stcBlobLead.fWidth / 2) + m_stcBlobLead.intBaseInwardOffset, 0, MidpointRounding.AwayFromZero);

                        // ------- Find Base Point Y -----------------------------------------
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.BaseCenter].SetGaugePlacement(fLimitCenterX - (fWidth / 2),
                                                          fLimitCenterY,
                                                          fWidth * (m_fPointGaugeToleranceRate * m), 180);
                            
                            m_arrPointGauge[i][(int)PointIndex.BaseCenter].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                            {
                                AddPointGaugePlacementToArray(fLimitCenterX - (fWidth / 2),
                                                              fLimitCenterY,
                                                              fWidth * (m_fPointGaugeToleranceRate * m), 180, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                AddPointGaugePlacementToArray(fLimitCenterX - (fWidth / 2),
                                                              fLimitCenterY,
                                                              fWidth * (m_fPointGaugeToleranceRate * m), 180, i);
                            }
                        }

                        if (m_arrPointGauge[i][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                        {
                            m_stcBlobLead.fBaseCenterX = m_arrPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointX(0);
                            m_stcBlobLead.fBaseCenterY = m_arrPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointY(0);
                            m_stcBlobLead.blnBaseCenterFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(m_stcBlobLead.fBaseCenterX, m_stcBlobLead.fBaseCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            m_stcBlobLead.fBaseCenterX = fLimitCenterX - (m_stcBlobLead.fWidth / 2);
                            m_stcBlobLead.fBaseCenterY = fLimitCenterY;
                            m_stcBlobLead.blnBaseCenterFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(m_stcBlobLead.fBaseCenterX, m_stcBlobLead.fBaseCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Base start point -----------------------------------------
                        float fRightFixPointX = m_stcBlobLead.fBaseCenterX + m_stcBlobLead.intBaseInwardOffset;
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.BaseStart].SetGaugePlacement(fRightFixPointX,
                                                          m_stcBlobLead.fBaseCenterY - fHeight / 2,
                                                         fHeight * (m_fPointGaugeToleranceRate * m), -90);
                            
                            m_arrPointGauge[i][(int)PointIndex.BaseStart].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray(fRightFixPointX,
                                                              m_stcBlobLead.fBaseCenterY - fHeight / 2,
                                                             fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.BaseStart, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray(fRightFixPointX,
                                                              m_stcBlobLead.fBaseCenterY - fHeight / 2,
                                                             fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.BaseStart, i);
                            }
                        }

                        PointF pRightStart;
                        if (m_arrPointGauge[i][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                        {
                            pRightStart = m_arrPointGauge[i][(int)PointIndex.BaseStart].GetMeasurePoint(0);
                            m_stcBlobLead.blnBaseStartFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pRightStart.X, pRightStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pRightStart = new PointF(fRightFixPointX, m_stcBlobLead.fBaseCenterY - fHeight / 2);
                            m_stcBlobLead.blnBaseStartFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pRightStart.X, pRightStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Base end point -----------------------------------------
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.BaseEnd].SetGaugePlacement(fRightFixPointX,
                                                        m_stcBlobLead.fBaseCenterY + fHeight / 2,
                                                       fHeight * (m_fPointGaugeToleranceRate * m), 90);
                            
                            m_arrPointGauge[i][(int)PointIndex.BaseEnd].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray(fRightFixPointX,
                                                            m_stcBlobLead.fBaseCenterY + fHeight / 2,
                                                           fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.BaseEnd, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray(fRightFixPointX,
                                                            m_stcBlobLead.fBaseCenterY + fHeight / 2,
                                                           fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.BaseEnd, i);
                            }
                        }

                        PointF pRightEnd;
                        if (m_arrPointGauge[i][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                        {
                            pRightEnd = m_arrPointGauge[i][(int)PointIndex.BaseEnd].GetMeasurePoint(0);
                            m_stcBlobLead.blnBaseEndFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pRightEnd.X, pRightEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pRightEnd = new PointF(fRightFixPointX, m_stcBlobLead.fBaseCenterY + fHeight / 2);
                            m_stcBlobLead.blnBaseEndFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pRightEnd.X, pRightEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // Calculate the Base width and center Y
                        m_stcBlobLead.fBaseWidth = pRightEnd.Y - pRightStart.Y;
                        m_stcBlobLead.fBaseCenterY = (pRightEnd.Y + pRightStart.Y) / 2 - objROI.ref_ROITotalY;
                        m_stcBlobLead.fBaseCenterX -= objROI.ref_ROITotalX;

                        //Tip
                        fLimitCenterX = objROI.ref_ROITotalX + m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = objROI.ref_ROITotalY + m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        //intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterX + (m_stcBlobLead.fWidth / 2) - m_stcBlobLead.intTipInwardOffset, 0, MidpointRounding.AwayFromZero);

                        // ------- Find Tip Point X -----------------------------------------
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.TipCenter].SetGaugePlacement(fLimitCenterX + (m_stcBlobLead.fWidth / 2),
                                                        fLimitCenterY,
                                                        fWidth * (m_fPointGaugeToleranceRate * m), 0);
                            
                            m_arrPointGauge[i][(int)PointIndex.TipCenter].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray(fLimitCenterX + (m_stcBlobLead.fWidth / 2),
                                                            fLimitCenterY,
                                                            fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.TipCenter, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray(fLimitCenterX + (m_stcBlobLead.fWidth / 2),
                                                            fLimitCenterY,
                                                            fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.TipCenter, i);
                            }
                        }

                        if (m_arrPointGauge[i][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                        {
                            m_stcBlobLead.fTipCenterX = m_arrPointGauge[i][(int)PointIndex.TipCenter].GetMeasurePointX(0);
                            m_stcBlobLead.fTipCenterY = m_arrPointGauge[i][(int)PointIndex.TipCenter].GetMeasurePointY(0);
                            m_stcBlobLead.blnTipCenterFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            m_stcBlobLead.fTipCenterX = fLimitCenterX + (m_stcBlobLead.fWidth / 2);
                            m_stcBlobLead.fTipCenterY = fLimitCenterY;
                            m_stcBlobLead.blnTipCenterFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Tip start point -----------------------------------------
                        fRightFixPointX = m_stcBlobLead.fTipCenterX - m_stcBlobLead.intTipInwardOffset;
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.TipStart].SetGaugePlacement(fRightFixPointX,
                                                          m_stcBlobLead.fTipCenterY - (m_stcBlobLead.fHeight / 2),
                                                         fHeight * (m_fPointGaugeToleranceRate * m), -90);
                            
                            m_arrPointGauge[i][(int)PointIndex.TipStart].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray(fRightFixPointX,
                                                              m_stcBlobLead.fTipCenterY - (m_stcBlobLead.fHeight / 2),
                                                             fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.TipStart, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray(fRightFixPointX,
                                                              m_stcBlobLead.fTipCenterY - (m_stcBlobLead.fHeight / 2),
                                                             fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.TipStart, i);
                            }
                        }
                        if (m_arrPointGauge[i][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                        {
                            pRightStart = m_arrPointGauge[i][(int)PointIndex.TipStart].GetMeasurePoint(0);
                            m_stcBlobLead.blnTipStartFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pRightStart.X, pRightStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pRightStart = new PointF(fRightFixPointX, m_stcBlobLead.fTipCenterY - (m_stcBlobLead.fHeight / 2));
                            m_stcBlobLead.blnTipStartFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pRightStart.X, pRightStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Tip end point -----------------------------------------
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.TipEnd].SetGaugePlacement(fRightFixPointX,
                                                              m_stcBlobLead.fTipCenterY + (m_stcBlobLead.fHeight / 2),
                                                             fHeight * (m_fPointGaugeToleranceRate * m), 90);
                            
                            m_arrPointGauge[i][(int)PointIndex.TipEnd].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray(fRightFixPointX,
                                                                  m_stcBlobLead.fTipCenterY + (m_stcBlobLead.fHeight / 2),
                                                                 fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.TipEnd, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray(fRightFixPointX,
                                                                  m_stcBlobLead.fTipCenterY + (m_stcBlobLead.fHeight / 2),
                                                                 fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.TipEnd, i);
                            }
                        }
                        if (m_arrPointGauge[i][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                        {
                            pRightEnd = m_arrPointGauge[i][(int)PointIndex.TipEnd].GetMeasurePoint(0);
                            m_stcBlobLead.blnTipEndFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pRightEnd.X, pRightEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pRightEnd = new PointF(fRightFixPointX, m_stcBlobLead.fTipCenterY + (m_stcBlobLead.fHeight / 2));
                            m_stcBlobLead.blnTipEndFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pRightEnd.X, pRightEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // Calculate the Tip width and center Y
                        m_stcBlobLead.fTipWidth = pRightEnd.Y - pRightStart.Y;
                        m_stcBlobLead.fTipCenterY = (pRightEnd.Y + pRightStart.Y) / 2 - objROI.ref_ROITotalY;
                        m_stcBlobLead.fTipCenterX -= objROI.ref_ROITotalX;

                        // Base and Tip Length
                        m_stcBlobLead.fBaseHeight = m_stcBlobLead.fTipCenterX - m_stcBlobLead.fBaseCenterX;
                        m_stcBlobLead.fTipHeight = m_stcBlobLead.fTipCenterX - m_stcBlobLead.fBaseCenterX;
                        break;
                    //Bottom
                    case 3:
                        //Base
                        fLimitCenterX = objROI.ref_ROITotalX + m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = objROI.ref_ROITotalY + m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        //intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterY - (m_stcBlobLead.fHeight / 2) + m_stcBlobLead.intBaseInwardOffset, 0, MidpointRounding.AwayFromZero);
                        // ------- Find Base Point X -----------------------------------------
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.BaseCenter].SetGaugePlacement(fLimitCenterX,
                                                          fLimitCenterY - (m_stcBlobLead.fHeight / 2),
                                                          fHeight * (m_fPointGaugeToleranceRate * m), -90);
                            
                            m_arrPointGauge[i][(int)PointIndex.BaseCenter].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                            {
                                AddPointGaugePlacementToArray(fLimitCenterX,
                                                              fLimitCenterY - (m_stcBlobLead.fHeight / 2),
                                                              fHeight * (m_fPointGaugeToleranceRate * m), -90, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                AddPointGaugePlacementToArray(fLimitCenterX,
                                                              fLimitCenterY - (m_stcBlobLead.fHeight / 2),
                                                              fHeight * (m_fPointGaugeToleranceRate * m), -90, i);
                            }
                        }

                        if (m_arrPointGauge[i][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                        {
                            m_stcBlobLead.fBaseCenterX = m_arrPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointX(0);
                            m_stcBlobLead.fBaseCenterY = m_arrPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointY(0);
                            m_stcBlobLead.blnBaseCenterFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(m_stcBlobLead.fBaseCenterX, m_stcBlobLead.fBaseCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            m_stcBlobLead.fBaseCenterX = fLimitCenterX;
                            m_stcBlobLead.fBaseCenterY = fLimitCenterY - (m_stcBlobLead.fHeight / 2);
                            m_stcBlobLead.blnBaseCenterFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(m_stcBlobLead.fBaseCenterX, m_stcBlobLead.fBaseCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Base start point -----------------------------------------
                        float fBottomFixPointY = m_stcBlobLead.fBaseCenterY + m_stcBlobLead.intBaseInwardOffset;
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.BaseStart].SetGaugePlacement(m_stcBlobLead.fBaseCenterX - fWidth / 2,
                                                          fBottomFixPointY,
                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180);
                            
                            m_arrPointGauge[i][(int)PointIndex.BaseStart].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray(m_stcBlobLead.fBaseCenterX - fWidth / 2,
                                                              fBottomFixPointY,
                                                             fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.BaseStart, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray(m_stcBlobLead.fBaseCenterX - fWidth / 2,
                                                              fBottomFixPointY,
                                                             fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.BaseStart, i);
                            }
                        }
                        PointF pBottomStart;
                        if (m_arrPointGauge[i][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                        {
                            pBottomStart = m_arrPointGauge[i][(int)PointIndex.BaseStart].GetMeasurePoint(0);
                            m_stcBlobLead.blnBaseStartFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pBottomStart.X, pBottomStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pBottomStart = new PointF(m_stcBlobLead.fBaseCenterX - fWidth / 2, fBottomFixPointY);
                            m_stcBlobLead.blnBaseStartFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pBottomStart.X, pBottomStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Base end point -----------------------------------------
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.BaseEnd].SetGaugePlacement(m_stcBlobLead.fBaseCenterX + fWidth / 2,
                                                        fBottomFixPointY,
                                                       fWidth * (m_fPointGaugeToleranceRate * m), 0);
                            
                            m_arrPointGauge[i][(int)PointIndex.BaseEnd].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray(m_stcBlobLead.fBaseCenterX + fWidth / 2,
                                                            fBottomFixPointY,
                                                           fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.BaseEnd, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray(m_stcBlobLead.fBaseCenterX + fWidth / 2,
                                                            fBottomFixPointY,
                                                           fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.BaseEnd, i);
                            }
                        }
                        PointF pBottomEnd;
                        if (m_arrPointGauge[i][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                        {
                            pBottomEnd = m_arrPointGauge[i][(int)PointIndex.BaseEnd].GetMeasurePoint(0);
                            m_stcBlobLead.blnBaseEndFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pBottomEnd.X, pBottomEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pBottomEnd = new PointF(m_stcBlobLead.fBaseCenterX + fWidth / 2, fBottomFixPointY);
                            m_stcBlobLead.blnBaseEndFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pBottomEnd.X, pBottomEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // Calculate the Base width and center X
                        m_stcBlobLead.fBaseWidth = pBottomEnd.X - pBottomStart.X;
                        m_stcBlobLead.fBaseCenterX = (pBottomEnd.X + pBottomStart.X) / 2 - objROI.ref_ROITotalX;
                        m_stcBlobLead.fBaseCenterY -= objROI.ref_ROITotalY;

                        //Tip
                        fLimitCenterX = objROI.ref_ROITotalX + m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = objROI.ref_ROITotalY + m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        //intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterY + (m_stcBlobLead.fHeight / 2) - m_stcBlobLead.intTipInwardOffset, 0, MidpointRounding.AwayFromZero);

                        // ------- Find Tip Point X -----------------------------------------
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.TipCenter].SetGaugePlacement(fLimitCenterX,
                                                          fLimitCenterY + (m_stcBlobLead.fHeight / 2),
                                                          fHeight * (m_fPointGaugeToleranceRate * m), 90);
                            
                            m_arrPointGauge[i][(int)PointIndex.TipCenter].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray(fLimitCenterX,
                                                              fLimitCenterY + (m_stcBlobLead.fHeight / 2),
                                                              fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.TipCenter, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray(fLimitCenterX,
                                                              fLimitCenterY + (m_stcBlobLead.fHeight / 2),
                                                              fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.TipCenter, i);
                            }
                        }
                        if (m_arrPointGauge[i][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                        {
                            m_stcBlobLead.fTipCenterX = m_arrPointGauge[i][(int)PointIndex.TipCenter].GetMeasurePointX(0);
                            m_stcBlobLead.fTipCenterY = m_arrPointGauge[i][(int)PointIndex.TipCenter].GetMeasurePointY(0);
                            m_stcBlobLead.blnTipCenterFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            m_stcBlobLead.fTipCenterX = fLimitCenterX;
                            m_stcBlobLead.fTipCenterY = fLimitCenterY + (m_stcBlobLead.fHeight / 2);
                            m_stcBlobLead.blnTipCenterFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Tip start point -----------------------------------------
                        fBottomFixPointY = m_stcBlobLead.fTipCenterY - m_stcBlobLead.intTipInwardOffset;
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.TipStart].SetGaugePlacement(m_stcBlobLead.fTipCenterX - fWidth / 2,
                                                          fBottomFixPointY,
                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180);
                            
                            m_arrPointGauge[i][(int)PointIndex.TipStart].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray(m_stcBlobLead.fTipCenterX - fWidth / 2,
                                                              fBottomFixPointY,
                                                             fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.TipStart, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray(m_stcBlobLead.fTipCenterX - fWidth / 2,
                                                              fBottomFixPointY,
                                                             fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.TipStart, i);
                            }
                        }
                        if (m_arrPointGauge[i][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                        {
                            pBottomStart = m_arrPointGauge[i][(int)PointIndex.TipStart].GetMeasurePoint(0);
                            m_stcBlobLead.blnTipStartFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pBottomStart.X, pBottomStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pBottomStart = new PointF(m_stcBlobLead.fTipCenterX - fWidth / 2, fBottomFixPointY);
                            m_stcBlobLead.blnTipStartFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pBottomStart.X, pBottomStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Tip end point -----------------------------------------
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.TipEnd].SetGaugePlacement(m_stcBlobLead.fTipCenterX + fWidth / 2,
                                                        fBottomFixPointY,
                                                       fWidth * (m_fPointGaugeToleranceRate * m), 0);
                            
                            m_arrPointGauge[i][(int)PointIndex.TipEnd].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray(m_stcBlobLead.fTipCenterX + fWidth / 2,
                                                            fBottomFixPointY,
                                                           fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.TipEnd, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray(m_stcBlobLead.fTipCenterX + fWidth / 2,
                                                            fBottomFixPointY,
                                                           fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.TipEnd, i);
                            }
                        }
                        if (m_arrPointGauge[i][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                        {
                            pBottomEnd = m_arrPointGauge[i][(int)PointIndex.TipEnd].GetMeasurePoint(0);
                            m_stcBlobLead.blnTipEndFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pBottomEnd.X, pBottomEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pBottomEnd = new PointF(m_stcBlobLead.fTipCenterX + fWidth / 2, fBottomFixPointY);
                            m_stcBlobLead.blnTipEndFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pBottomEnd.X, pBottomEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // Calculate the Tip width and center X
                        m_stcBlobLead.fTipWidth = pBottomEnd.X - pBottomStart.X;
                        m_stcBlobLead.fTipCenterX = (pBottomEnd.X + pBottomStart.X) / 2 - objROI.ref_ROITotalX;
                        m_stcBlobLead.fTipCenterY -= objROI.ref_ROITotalY;

                        // Base and Tip Length
                        m_stcBlobLead.fBaseHeight = m_stcBlobLead.fTipCenterY - m_stcBlobLead.fBaseCenterY;
                        m_stcBlobLead.fTipHeight = m_stcBlobLead.fTipCenterY - m_stcBlobLead.fBaseCenterY;
                        break;
                    //Left
                    case 4:
                        //Base
                        fLimitCenterX = objROI.ref_ROITotalX + m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = objROI.ref_ROITotalY + m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        //intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterX + (m_stcBlobLead.fWidth / 2) - m_stcBlobLead.intBaseInwardOffset, 0, MidpointRounding.AwayFromZero);

                        // ------- Find Base Point Y -----------------------------------------
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.BaseCenter].SetGaugePlacement(fLimitCenterX + (m_stcBlobLead.fWidth / 2),
                                                          fLimitCenterY,
                                                          fWidth * (m_fPointGaugeToleranceRate * m), 0);
                            
                            m_arrPointGauge[i][(int)PointIndex.BaseCenter].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                            {
                                AddPointGaugePlacementToArray(fLimitCenterX + (m_stcBlobLead.fWidth / 2),
                                                              fLimitCenterY,
                                                              fWidth * (m_fPointGaugeToleranceRate * m), (int)PointIndex.BaseCenter, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                AddPointGaugePlacementToArray(fLimitCenterX + (m_stcBlobLead.fWidth / 2),
                                                              fLimitCenterY,
                                                              fWidth * (m_fPointGaugeToleranceRate * m), (int)PointIndex.BaseCenter, i);
                            }
                        }
                        if (m_arrPointGauge[i][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                        {
                            m_stcBlobLead.fBaseCenterX = m_arrPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointX(0);
                            m_stcBlobLead.fBaseCenterY = m_arrPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointY(0);
                            m_stcBlobLead.blnBaseCenterFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(m_stcBlobLead.fBaseCenterX, m_stcBlobLead.fBaseCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            m_stcBlobLead.fBaseCenterX = fLimitCenterX + (m_stcBlobLead.fWidth / 2);
                            m_stcBlobLead.fBaseCenterY = fLimitCenterY;
                            m_stcBlobLead.blnBaseCenterFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(m_stcBlobLead.fBaseCenterX, m_stcBlobLead.fBaseCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Base start point -----------------------------------------
                        float fLeftFixPointX = m_stcBlobLead.fBaseCenterX - m_stcBlobLead.intBaseInwardOffset;
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.BaseStart].SetGaugePlacement(fLeftFixPointX,
                                                          m_stcBlobLead.fBaseCenterY - fHeight / 2,
                                                         fHeight * (m_fPointGaugeToleranceRate * m), -90);
                            
                            m_arrPointGauge[i][(int)PointIndex.BaseStart].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray(fLeftFixPointX,
                                                              m_stcBlobLead.fBaseCenterY - fHeight / 2,
                                                             fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.BaseStart, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray(fLeftFixPointX,
                                                              m_stcBlobLead.fBaseCenterY - fHeight / 2,
                                                             fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.BaseStart, i);
                            }
                        }
                        PointF pLeftStart;
                        if (m_arrPointGauge[i][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                        {
                            pLeftStart = m_arrPointGauge[i][(int)PointIndex.BaseStart].GetMeasurePoint(0);
                            m_stcBlobLead.blnBaseStartFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pLeftStart.X, pLeftStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pLeftStart = new PointF(fLeftFixPointX, m_stcBlobLead.fBaseCenterY - fHeight / 2);
                            m_stcBlobLead.blnBaseStartFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pLeftStart.X, pLeftStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Base end point -----------------------------------------
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.BaseEnd].SetGaugePlacement(fLeftFixPointX,
                                                        m_stcBlobLead.fBaseCenterY + fHeight / 2,
                                                       fHeight * (m_fPointGaugeToleranceRate * m), 90);
                            
                            m_arrPointGauge[i][(int)PointIndex.BaseEnd].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray(fLeftFixPointX,
                                                            m_stcBlobLead.fBaseCenterY + fHeight / 2,
                                                           fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.BaseEnd, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray(fLeftFixPointX,
                                                            m_stcBlobLead.fBaseCenterY + fHeight / 2,
                                                           fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.BaseEnd, i);
                            }
                        }
                        PointF pLeftEnd;
                        if (m_arrPointGauge[i][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                        {
                            pLeftEnd = m_arrPointGauge[i][(int)PointIndex.BaseEnd].GetMeasurePoint(0);
                            m_stcBlobLead.blnBaseEndFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pLeftEnd.X, pLeftEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pLeftEnd = new PointF(fLeftFixPointX, m_stcBlobLead.fBaseCenterY + fHeight / 2);
                            m_stcBlobLead.blnBaseEndFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pLeftEnd.X, pLeftEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // Calculate the Base width center Y
                        m_stcBlobLead.fBaseWidth = pLeftEnd.Y - pLeftStart.Y;
                        m_stcBlobLead.fBaseCenterY = (pLeftEnd.Y + pLeftStart.Y) / 2 - objROI.ref_ROITotalY;
                        m_stcBlobLead.fBaseCenterX -= objROI.ref_ROITotalX;


                        //Tip
                        fLimitCenterX = objROI.ref_ROITotalX + m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = objROI.ref_ROITotalY + m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        //intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterX - (m_stcBlobLead.fWidth / 2) + m_stcBlobLead.intTipInwardOffset, 0, MidpointRounding.AwayFromZero);

                        // ------- Find Tip Point X -----------------------------------------
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.TipCenter].SetGaugePlacement(fLimitCenterX - (m_stcBlobLead.fWidth / 2),
                                                        fLimitCenterY,
                                                        fWidth * (m_fPointGaugeToleranceRate * m), 180);
                            
                            m_arrPointGauge[i][(int)PointIndex.TipCenter].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray(fLimitCenterX - (m_stcBlobLead.fWidth / 2),
                                                            fLimitCenterY,
                                                            fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.TipCenter, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray(fLimitCenterX - (m_stcBlobLead.fWidth / 2),
                                                            fLimitCenterY,
                                                            fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.TipCenter, i);
                            }
                        }
                        if (m_arrPointGauge[i][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                        {
                            m_stcBlobLead.fTipCenterX = m_arrPointGauge[i][(int)PointIndex.TipCenter].GetMeasurePointX(0);
                            m_stcBlobLead.fTipCenterY = m_arrPointGauge[i][(int)PointIndex.TipCenter].GetMeasurePointY(0);
                            m_stcBlobLead.blnTipCenterFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            m_stcBlobLead.fTipCenterX = fLimitCenterX - (m_stcBlobLead.fWidth / 2);
                            m_stcBlobLead.fTipCenterY = fLimitCenterY;
                            m_stcBlobLead.blnTipCenterFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Tip start point -----------------------------------------
                        fLeftFixPointX = m_stcBlobLead.fTipCenterX + m_stcBlobLead.intTipInwardOffset;
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.TipStart].SetGaugePlacement(fLeftFixPointX,
                                                          m_stcBlobLead.fTipCenterY - (m_stcBlobLead.fHeight / 2),
                                                         fHeight * (m_fPointGaugeToleranceRate * m), -90);
                            
                            m_arrPointGauge[i][(int)PointIndex.TipStart].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray(fLeftFixPointX,
                                                              m_stcBlobLead.fTipCenterY - (m_stcBlobLead.fHeight / 2),
                                                             fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.TipStart, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray(fLeftFixPointX,
                                                              m_stcBlobLead.fTipCenterY - (m_stcBlobLead.fHeight / 2),
                                                             fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.TipStart, i);
                            }
                        }
                        if (m_arrPointGauge[i][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                        {
                            pLeftStart = m_arrPointGauge[i][(int)PointIndex.TipStart].GetMeasurePoint(0);
                            m_stcBlobLead.blnTipStartFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pLeftStart.X, pLeftStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pLeftStart = new PointF(fLeftFixPointX, m_stcBlobLead.fTipCenterY - (m_stcBlobLead.fHeight / 2));
                            m_stcBlobLead.blnTipStartFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pLeftStart.X, pLeftStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Tip end point -----------------------------------------
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.TipEnd].SetGaugePlacement(fLeftFixPointX,
                                                              m_stcBlobLead.fTipCenterY + (m_stcBlobLead.fHeight / 2),
                                                             fHeight * (m_fPointGaugeToleranceRate * m), 90);
                            
                            m_arrPointGauge[i][(int)PointIndex.TipEnd].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray(fLeftFixPointX,
                                                                  m_stcBlobLead.fTipCenterY + (m_stcBlobLead.fHeight / 2),
                                                                 fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.TipEnd, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray(fLeftFixPointX,
                                                                  m_stcBlobLead.fTipCenterY + (m_stcBlobLead.fHeight / 2),
                                                                 fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.TipEnd, i);
                            }
                        }
                        if (m_arrPointGauge[i][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                        {
                            pLeftEnd = m_arrPointGauge[i][(int)PointIndex.TipEnd].GetMeasurePoint(0);
                            m_stcBlobLead.blnTipEndFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pLeftEnd.X, pLeftEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pLeftEnd = new PointF(fLeftFixPointX, m_stcBlobLead.fTipCenterY + (m_stcBlobLead.fHeight / 2));
                            m_stcBlobLead.blnTipEndFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pLeftEnd.X, pLeftEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // Calculate the Tip width and center Y
                        m_stcBlobLead.fTipWidth = pLeftEnd.Y - pLeftStart.Y;
                        m_stcBlobLead.fTipCenterY = (pLeftEnd.Y + pLeftStart.Y) / 2 - objROI.ref_ROITotalY;
                        m_stcBlobLead.fTipCenterX -= objROI.ref_ROITotalX;

                        // Base and Tip Length
                        m_stcBlobLead.fBaseHeight = m_stcBlobLead.fBaseCenterX - m_stcBlobLead.fTipCenterX;
                        m_stcBlobLead.fTipHeight = m_stcBlobLead.fBaseCenterX - m_stcBlobLead.fTipCenterX;
                        break;
                }

                m_arrTemplateBlobLeads.RemoveAt(i);
                m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
            }
        }

        ///// <summary>
        ///// This function will give 3 chances to increase Point Gauge Length when cannot found any point
        ///// </summary>
        ///// <param name="intLeadPosition"></param>
        ///// <param name="objROI"></param>
        //public void DefineLeadBaseTipWidthHeight_Old(int intLeadPosition, ROI objROI)
        //{
        //    float fLimitCenterX;
        //    float fLimitCenterY;
        //    float fNewCenterX;
        //    float fNewCenterY;
        //    float fWidth;
        //    float fHeight;
        //    int intFixPointXY;

        //    for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
        //    {
        //        m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
        //        switch (intLeadPosition)
        //        {
        //            //Top
        //            case 1:
        //                //Base
        //                fLimitCenterX = m_stcBlobLead.fLimitCenterX;
        //                fLimitCenterY = m_stcBlobLead.fLimitCenterY;
        //                fWidth = m_stcBlobLead.fWidth;
        //                fHeight = m_stcBlobLead.fHeight;
        //                fNewCenterX = fLimitCenterX;
        //                fNewCenterY = fLimitCenterY;
        //                intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterY + (m_stcBlobLead.fHeight / 2) - m_stcBlobLead.intBaseInwardOffset, 0, MidpointRounding.AwayFromZero);


        //                if (!m_blnWantUseGaugeMeasureLeadDimension)
        //                {
        //                    Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
        //                            ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, true, true, intFixPointXY);
        //                }
        //                else
        //                {
        //                    UpdateBlobSizeAndCenterPointWithGauge(objROI, fLimitCenterX, fLimitCenterY,
        //                        ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, true, intFixPointXY);
        //                }

        //                m_stcBlobLead.fBaseCenterX = fNewCenterX;
        //                m_stcBlobLead.fBaseWidth = fWidth;

        //                //Tip
        //                fLimitCenterX = m_stcBlobLead.fLimitCenterX;
        //                fLimitCenterY = m_stcBlobLead.fLimitCenterY;
        //                fWidth = m_stcBlobLead.fWidth;
        //                fHeight = m_stcBlobLead.fHeight;
        //                fNewCenterX = fLimitCenterX;
        //                fNewCenterY = fLimitCenterY;
        //                intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterY - (m_stcBlobLead.fHeight / 2) + m_stcBlobLead.intTipInwardOffset, 0, MidpointRounding.AwayFromZero);


        //                if (!m_blnWantUseGaugeMeasureLeadDimension)
        //                {
        //                    Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
        //                            ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, true, false, intFixPointXY);
        //                }
        //                else
        //                {
        //                    UpdateBlobSizeAndCenterPointWithGauge(objROI, fLimitCenterX, fLimitCenterY,
        //                        ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, true, intFixPointXY);
        //                }

        //                m_stcBlobLead.fTipCenterX = fNewCenterX;
        //                m_stcBlobLead.fTipWidth = fWidth;

        //                //Length
        //                fLimitCenterX = m_stcBlobLead.fLimitCenterX;
        //                fLimitCenterY = m_stcBlobLead.fLimitCenterY;
        //                fWidth = m_stcBlobLead.fWidth;
        //                fHeight = m_stcBlobLead.fHeight;
        //                fNewCenterX = fLimitCenterX;
        //                fNewCenterY = fLimitCenterY;

        //                intFixPointXY = (int)Math.Round(fLimitCenterX, 0, MidpointRounding.AwayFromZero);

        //                UpdateBlobSizeAndCenterPointWithGauge(objROI, fLimitCenterX, fLimitCenterY,
        //                        ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, false, intFixPointXY);

        //                m_stcBlobLead.fTipCenterY = fNewCenterY - fHeight / 2;
        //                m_stcBlobLead.fTipHeight = fHeight;
        //                m_stcBlobLead.fBaseCenterY = fNewCenterY + fHeight / 2;
        //                m_stcBlobLead.fBaseHeight = fHeight;
        //                break;
        //            //Right
        //            case 2:
        //                //Base
        //                fLimitCenterX = m_stcBlobLead.fLimitCenterX;
        //                fLimitCenterY = m_stcBlobLead.fLimitCenterY;
        //                fWidth = m_stcBlobLead.fWidth;
        //                fHeight = m_stcBlobLead.fHeight;
        //                fNewCenterX = fLimitCenterX;
        //                fNewCenterY = fLimitCenterY;
        //                intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterX - (m_stcBlobLead.fWidth / 2) + m_stcBlobLead.intBaseInwardOffset, 0, MidpointRounding.AwayFromZero);

        //                if (!m_blnWantUseGaugeMeasureLeadDimension)
        //                {
        //                    Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
        //                            ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, false, false, intFixPointXY);
        //                }
        //                else
        //                {
        //                    UpdateBlobSizeAndCenterPointWithGauge(objROI, fLimitCenterX, fLimitCenterY,
        //                        ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, false, intFixPointXY);
        //                }

        //                m_stcBlobLead.fBaseCenterY = fNewCenterY;
        //                m_stcBlobLead.fBaseHeight = fHeight;

        //                //Tip
        //                fLimitCenterX = m_stcBlobLead.fLimitCenterX;
        //                fLimitCenterY = m_stcBlobLead.fLimitCenterY;
        //                fWidth = m_stcBlobLead.fWidth;
        //                fHeight = m_stcBlobLead.fHeight;
        //                fNewCenterX = fLimitCenterX;
        //                fNewCenterY = fLimitCenterY;
        //                intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterX + (m_stcBlobLead.fWidth / 2) - m_stcBlobLead.intTipInwardOffset, 0, MidpointRounding.AwayFromZero);

        //                if (!m_blnWantUseGaugeMeasureLeadDimension)
        //                {
        //                    Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
        //                            ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, false, true, intFixPointXY);
        //                }
        //                else
        //                {
        //                    UpdateBlobSizeAndCenterPointWithGauge(objROI, fLimitCenterX, fLimitCenterY,
        //                        ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, false, intFixPointXY);
        //                }

        //                m_stcBlobLead.fTipCenterY = fNewCenterY;
        //                m_stcBlobLead.fTipHeight = fHeight;

        //                //Length
        //                fLimitCenterX = m_stcBlobLead.fLimitCenterX;
        //                fLimitCenterY = m_stcBlobLead.fLimitCenterY;
        //                fWidth = m_stcBlobLead.fWidth;
        //                fHeight = m_stcBlobLead.fHeight;
        //                fNewCenterX = fLimitCenterX;
        //                fNewCenterY = fLimitCenterY;

        //                intFixPointXY = (int)Math.Round(fLimitCenterY, 0, MidpointRounding.AwayFromZero);

        //                UpdateBlobSizeAndCenterPointWithGauge(objROI, fLimitCenterX, fLimitCenterY,
        //                        ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, true, intFixPointXY);

        //                m_stcBlobLead.fTipCenterX = fNewCenterX + fWidth / 2;
        //                m_stcBlobLead.fTipWidth = fWidth;
        //                m_stcBlobLead.fBaseCenterX = fNewCenterX - fWidth / 2;
        //                m_stcBlobLead.fBaseWidth = fWidth;
        //                break;
        //            //Bottom
        //            case 3:
        //                //Base
        //                fLimitCenterX = m_stcBlobLead.fLimitCenterX;
        //                fLimitCenterY = m_stcBlobLead.fLimitCenterY;
        //                fWidth = m_stcBlobLead.fWidth;
        //                fHeight = m_stcBlobLead.fHeight;
        //                fNewCenterX = fLimitCenterX;
        //                fNewCenterY = fLimitCenterY;
        //                intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterY - (m_stcBlobLead.fHeight / 2) + m_stcBlobLead.intBaseInwardOffset, 0, MidpointRounding.AwayFromZero);

        //                if (!m_blnWantUseGaugeMeasureLeadDimension)
        //                {
        //                    Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
        //                            ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, true, false, intFixPointXY);
        //                }
        //                else
        //                {
        //                    UpdateBlobSizeAndCenterPointWithGauge(objROI, fLimitCenterX, fLimitCenterY,
        //                        ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, true, intFixPointXY);
        //                }

        //                m_stcBlobLead.fBaseCenterX = fNewCenterX;
        //                m_stcBlobLead.fBaseWidth = fWidth;

        //                //Tip
        //                fLimitCenterX = m_stcBlobLead.fLimitCenterX;
        //                fLimitCenterY = m_stcBlobLead.fLimitCenterY;
        //                fWidth = m_stcBlobLead.fWidth;
        //                fHeight = m_stcBlobLead.fHeight;
        //                fNewCenterX = fLimitCenterX;
        //                fNewCenterY = fLimitCenterY;
        //                intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterY + (m_stcBlobLead.fHeight / 2) - m_stcBlobLead.intTipInwardOffset, 0, MidpointRounding.AwayFromZero);

        //                if (!m_blnWantUseGaugeMeasureLeadDimension)
        //                {
        //                    Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
        //                            ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, true, true, intFixPointXY);
        //                }
        //                else
        //                {
        //                    UpdateBlobSizeAndCenterPointWithGauge(objROI, fLimitCenterX, fLimitCenterY,
        //                        ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, true, intFixPointXY);
        //                }

        //                m_stcBlobLead.fTipCenterX = fNewCenterX;
        //                m_stcBlobLead.fTipWidth = fWidth;

        //                //Length
        //                fLimitCenterX = m_stcBlobLead.fLimitCenterX;
        //                fLimitCenterY = m_stcBlobLead.fLimitCenterY;
        //                fWidth = m_stcBlobLead.fWidth;
        //                fHeight = m_stcBlobLead.fHeight;
        //                fNewCenterX = fLimitCenterX;
        //                fNewCenterY = fLimitCenterY;

        //                intFixPointXY = (int)Math.Round(fLimitCenterX, 0, MidpointRounding.AwayFromZero);

        //                UpdateBlobSizeAndCenterPointWithGauge(objROI, fLimitCenterX, fLimitCenterY,
        //                        ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, false, intFixPointXY);

        //                m_stcBlobLead.fTipCenterY = fNewCenterY + fHeight / 2;
        //                m_stcBlobLead.fTipHeight = fHeight;
        //                m_stcBlobLead.fBaseCenterY = fNewCenterY - fHeight / 2;
        //                m_stcBlobLead.fBaseHeight = fHeight;
        //                break;
        //            //Left
        //            case 4:
        //                //Base
        //                fLimitCenterX = m_stcBlobLead.fLimitCenterX;
        //                fLimitCenterY = m_stcBlobLead.fLimitCenterY;
        //                fWidth = m_stcBlobLead.fWidth;
        //                fHeight = m_stcBlobLead.fHeight;
        //                fNewCenterX = fLimitCenterX;
        //                fNewCenterY = fLimitCenterY;
        //                intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterX + (m_stcBlobLead.fWidth / 2) - m_stcBlobLead.intBaseInwardOffset, 0, MidpointRounding.AwayFromZero);

        //                if (!m_blnWantUseGaugeMeasureLeadDimension)
        //                {
        //                    Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
        //                            ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, false, true, intFixPointXY);
        //                }
        //                else
        //                {
        //                    UpdateBlobSizeAndCenterPointWithGauge(objROI, fLimitCenterX, fLimitCenterY,
        //                        ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, false, intFixPointXY);
        //                }

        //                m_stcBlobLead.fBaseCenterX = fNewCenterX;
        //                m_stcBlobLead.fBaseCenterY = fNewCenterY;
        //                m_stcBlobLead.fBaseWidth = fWidth;
        //                m_stcBlobLead.fBaseHeight = fHeight;

        //                //Tip
        //                fLimitCenterX = m_stcBlobLead.fLimitCenterX;
        //                fLimitCenterY = m_stcBlobLead.fLimitCenterY;
        //                fWidth = m_stcBlobLead.fWidth;
        //                fHeight = m_stcBlobLead.fHeight;
        //                fNewCenterX = fLimitCenterX;
        //                fNewCenterY = fLimitCenterY;
        //                intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterX - (m_stcBlobLead.fWidth / 2) + m_stcBlobLead.intTipInwardOffset, 0, MidpointRounding.AwayFromZero);

        //                if (!m_blnWantUseGaugeMeasureLeadDimension)
        //                {
        //                    Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
        //                            ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, false, false, intFixPointXY);
        //                }
        //                else
        //                {
        //                    UpdateBlobSizeAndCenterPointWithGauge(objROI, fLimitCenterX, fLimitCenterY,
        //                        ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, false, intFixPointXY);
        //                }

        //                m_stcBlobLead.fTipCenterX = fNewCenterX;
        //                m_stcBlobLead.fTipCenterY = fNewCenterY;
        //                m_stcBlobLead.fTipWidth = fWidth;
        //                m_stcBlobLead.fTipHeight = fHeight;

        //                //Length
        //                fLimitCenterX = m_stcBlobLead.fLimitCenterX;
        //                fLimitCenterY = m_stcBlobLead.fLimitCenterY;
        //                fWidth = m_stcBlobLead.fWidth;
        //                fHeight = m_stcBlobLead.fHeight;
        //                fNewCenterX = fLimitCenterX;
        //                fNewCenterY = fLimitCenterY;

        //                intFixPointXY = (int)Math.Round(fLimitCenterY, 0, MidpointRounding.AwayFromZero);

        //                UpdateBlobSizeAndCenterPointWithGauge(objROI, fLimitCenterX, fLimitCenterY,
        //                        ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, true, intFixPointXY);

        //                m_stcBlobLead.fTipCenterX = fNewCenterX - fWidth / 2;
        //                m_stcBlobLead.fTipWidth = fWidth;
        //                m_stcBlobLead.fBaseCenterX = fNewCenterX + fWidth / 2;
        //                m_stcBlobLead.fBaseWidth = fWidth;
        //                break;
        //        }

        //        m_arrTemplateBlobLeads.RemoveAt(i);
        //        m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
        //    }
        //}

        public bool GetLeadTipInfoFromCenterLead3D(int intDirection, ref List<PointF> arrLeadTipPoint, ref List<float> arrLeadWidth)
        {
            arrLeadTipPoint.Clear();
            arrLeadWidth.Clear();

            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                if (m_stcBlobLead.intDirection == intDirection)
                {

                }

            }

            return true;
        }

        public void DefineLeadBaseTipWidth_Lead3D(ROI objROI)
        {
            float fLimitCenterX;
            float fLimitCenterY;
            float fNewCenterX;
            float fNewCenterY;
            float fWidth;
            float fHeight;
            int intFixPointXY;

            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                switch (m_stcBlobLead.intDirection)
                {
                    //Top
                    case 4:
                        //Base
                        fLimitCenterX = m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterY + (m_stcBlobLead.fHeight / 2) - m_stcBlobLead.intBaseInwardOffset, 0, MidpointRounding.AwayFromZero);
                        Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                                ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, true, true, intFixPointXY);

                        m_stcBlobLead.fBaseCenterX = fNewCenterX;
                        m_stcBlobLead.fBaseCenterY = fNewCenterY;
                        m_stcBlobLead.fBaseWidth = fWidth;
                        m_stcBlobLead.fBaseHeight = fHeight;

                        //Tip
                        fLimitCenterX = m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterY - (m_stcBlobLead.fHeight / 2) + m_stcBlobLead.intTipInwardOffset, 0, MidpointRounding.AwayFromZero);
                        Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                                ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, true, false, intFixPointXY);

                        m_stcBlobLead.fTipCenterX = fNewCenterX;
                        m_stcBlobLead.fTipCenterY = fNewCenterY;
                        m_stcBlobLead.fTipWidth = fWidth;
                        m_stcBlobLead.fTipHeight = fHeight;
                        break;
                    //Right
                    case 2:
                        //Base
                        fLimitCenterX = m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterX - (m_stcBlobLead.fWidth / 2) + m_stcBlobLead.intBaseInwardOffset, 0, MidpointRounding.AwayFromZero);
                        Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                                ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, false, false, intFixPointXY);

                        m_stcBlobLead.fBaseCenterX = fNewCenterX;
                        m_stcBlobLead.fBaseCenterY = fNewCenterY;
                        m_stcBlobLead.fBaseWidth = fWidth;
                        m_stcBlobLead.fBaseHeight = fHeight;

                        //Tip
                        fLimitCenterX = m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterX + (m_stcBlobLead.fWidth / 2) - m_stcBlobLead.intTipInwardOffset, 0, MidpointRounding.AwayFromZero);
                        Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                                ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, false, true, intFixPointXY);

                        m_stcBlobLead.fTipCenterX = fNewCenterX;
                        m_stcBlobLead.fTipCenterY = fNewCenterY;
                        m_stcBlobLead.fTipWidth = fWidth;
                        m_stcBlobLead.fTipHeight = fHeight;
                        break;
                    //Bottom
                    case 8:
                        //Base
                        fLimitCenterX = m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterY - (m_stcBlobLead.fHeight / 2) + m_stcBlobLead.intBaseInwardOffset, 0, MidpointRounding.AwayFromZero);
                        Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                                ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, true, false, intFixPointXY);

                        m_stcBlobLead.fBaseCenterX = fNewCenterX;
                        m_stcBlobLead.fBaseCenterY = fNewCenterY;
                        m_stcBlobLead.fBaseWidth = fWidth;
                        m_stcBlobLead.fBaseHeight = fHeight;

                        //Tip
                        fLimitCenterX = m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterY + (m_stcBlobLead.fHeight / 2) - m_stcBlobLead.intTipInwardOffset, 0, MidpointRounding.AwayFromZero);
                        Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                                ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, true, true, intFixPointXY);

                        m_stcBlobLead.fTipCenterX = fNewCenterX;
                        m_stcBlobLead.fTipCenterY = fNewCenterY;
                        m_stcBlobLead.fTipWidth = fWidth;
                        m_stcBlobLead.fTipHeight = fHeight;
                        break;
                    //Left
                    case 1:
                        //Base
                        fLimitCenterX = m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;

                        intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterX + (m_stcBlobLead.fWidth / 2) - m_stcBlobLead.intBaseInwardOffset, 0, MidpointRounding.AwayFromZero);
                        Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                                ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, false, true, intFixPointXY);

                        m_stcBlobLead.fBaseCenterX = fNewCenterX;
                        m_stcBlobLead.fBaseCenterY = fNewCenterY;
                        m_stcBlobLead.fBaseWidth = fWidth;
                        m_stcBlobLead.fBaseHeight = fHeight;

                        //Tip
                        fLimitCenterX = m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterX - (m_stcBlobLead.fWidth / 2) + m_stcBlobLead.intTipInwardOffset, 0, MidpointRounding.AwayFromZero);
                        Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                                ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, false, false, intFixPointXY);

                        m_stcBlobLead.fTipCenterX = fNewCenterX;
                        m_stcBlobLead.fTipCenterY = fNewCenterY;
                        m_stcBlobLead.fTipWidth = fWidth;
                        m_stcBlobLead.fTipHeight = fHeight;
                        break;
                }

                m_arrTemplateBlobLeads.RemoveAt(i);
                m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
            }
        }

        public void DefineLeadTipWidth_SideLead3D(ROI objROI)
        {
            float fLimitCenterX;
            float fLimitCenterY;
            float fNewCenterX;
            float fNewCenterY;
            float fWidth;
            float fHeight;
            int intFixPointXY;

            for (int i = 0; i < m_intNumberOfLead; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                switch (m_stcBlobLead.intDirection)
                {
                    //Top
                    case 4:
                        //Base
                        fLimitCenterX = m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterY + (m_stcBlobLead.fHeight / 2) - m_stcBlobLead.intBaseInwardOffset, 0, MidpointRounding.AwayFromZero);
                        Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                                ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, true, true, intFixPointXY);

                        m_stcBlobLead.fBaseCenterX = fNewCenterX;
                        m_stcBlobLead.fBaseCenterY = fNewCenterY;
                        m_stcBlobLead.fBaseWidth = fWidth;
                        m_stcBlobLead.fBaseHeight = fHeight;

                        //Tip
                        fLimitCenterX = m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterY - (m_stcBlobLead.fHeight / 2) + m_stcBlobLead.intTipInwardOffset, 0, MidpointRounding.AwayFromZero);
                        Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                                ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, true, false, intFixPointXY);

                        m_stcBlobLead.fTipCenterX = fNewCenterX;
                        m_stcBlobLead.fTipCenterY = fNewCenterY;
                        m_stcBlobLead.fTipWidth = fWidth;
                        m_stcBlobLead.fTipHeight = fHeight;
                        break;
                    //Right
                    case 2:
                        //Base
                        fLimitCenterX = m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterX - (m_stcBlobLead.fWidth / 2) + m_stcBlobLead.intBaseInwardOffset, 0, MidpointRounding.AwayFromZero);
                        Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                                ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, false, false, intFixPointXY);

                        m_stcBlobLead.fBaseCenterX = fNewCenterX;
                        m_stcBlobLead.fBaseCenterY = fNewCenterY;
                        m_stcBlobLead.fBaseWidth = fWidth;
                        m_stcBlobLead.fBaseHeight = fHeight;

                        //Tip
                        fLimitCenterX = m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterX + (m_stcBlobLead.fWidth / 2) - m_stcBlobLead.intTipInwardOffset, 0, MidpointRounding.AwayFromZero);
                        Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                                ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, false, true, intFixPointXY);

                        m_stcBlobLead.fTipCenterX = fNewCenterX;
                        m_stcBlobLead.fTipCenterY = fNewCenterY;
                        m_stcBlobLead.fTipWidth = fWidth;
                        m_stcBlobLead.fTipHeight = fHeight;
                        break;
                    //Bottom
                    case 8:
                        //Base
                        fLimitCenterX = m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterY - (m_stcBlobLead.fHeight / 2) + m_stcBlobLead.intBaseInwardOffset, 0, MidpointRounding.AwayFromZero);
                        Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                                ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, true, false, intFixPointXY);

                        m_stcBlobLead.fBaseCenterX = fNewCenterX;
                        m_stcBlobLead.fBaseCenterY = fNewCenterY;
                        m_stcBlobLead.fBaseWidth = fWidth;
                        m_stcBlobLead.fBaseHeight = fHeight;

                        //Tip
                        fLimitCenterX = m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterY + (m_stcBlobLead.fHeight / 2) - m_stcBlobLead.intTipInwardOffset, 0, MidpointRounding.AwayFromZero);
                        Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                                ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, true, true, intFixPointXY);

                        m_stcBlobLead.fTipCenterX = fNewCenterX;
                        m_stcBlobLead.fTipCenterY = fNewCenterY;
                        m_stcBlobLead.fTipWidth = fWidth;
                        m_stcBlobLead.fTipHeight = fHeight;
                        break;
                    //Left
                    case 1:
                        //Base
                        fLimitCenterX = m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;

                        intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterX + (m_stcBlobLead.fWidth / 2) - m_stcBlobLead.intBaseInwardOffset, 0, MidpointRounding.AwayFromZero);
                        Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                                ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, false, true, intFixPointXY);

                        m_stcBlobLead.fBaseCenterX = fNewCenterX;
                        m_stcBlobLead.fBaseCenterY = fNewCenterY;
                        m_stcBlobLead.fBaseWidth = fWidth;
                        m_stcBlobLead.fBaseHeight = fHeight;

                        //Tip
                        fLimitCenterX = m_stcBlobLead.fLimitCenterX;
                        fLimitCenterY = m_stcBlobLead.fLimitCenterY;
                        fWidth = m_stcBlobLead.fWidth;
                        fHeight = m_stcBlobLead.fHeight;
                        fNewCenterX = fLimitCenterX;
                        fNewCenterY = fLimitCenterY;
                        intFixPointXY = (int)Math.Round(m_stcBlobLead.fLimitCenterX - (m_stcBlobLead.fWidth / 2) + m_stcBlobLead.intTipInwardOffset, 0, MidpointRounding.AwayFromZero);
                        Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                                ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, false, false, intFixPointXY);

                        m_stcBlobLead.fTipCenterX = fNewCenterX;
                        m_stcBlobLead.fTipCenterY = fNewCenterY;
                        m_stcBlobLead.fTipWidth = fWidth;
                        m_stcBlobLead.fTipHeight = fHeight;
                        break;
                }

                m_arrTemplateBlobLeads.RemoveAt(i);
                m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
            }
        }

        public void DefineLeadVariance(ROI objROI)
        {
            float fStartX, fStartY, fEndX, fEndY;
            float fMinLength = float.MaxValue;
            float fMaxLength = 0;

            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                ////Top and bottom height=length
                //if(m_stcBlobLead.intLengthMode == 1)
                //{
                //    fStartY = m_stcBlobLead.fLimitCenterY - m_stcBlobLead.fHeight / 2;
                //    fEndY = m_stcBlobLead.fLimitCenterY + m_stcBlobLead.fHeight / 2;

                //    if (fEndY - fStartY > fMaxLength)
                //        fMaxLength = fEndY - fStartY;

                //    if (fEndY - fStartY < fMinLength)
                //        fMinLength = fEndY - fStartY;
                //}
                //else
                //{
                //    fStartX = m_stcBlobLead.fLimitCenterX - m_stcBlobLead.fWidth / 2;
                //    fEndX = m_stcBlobLead.fLimitCenterX + m_stcBlobLead.fWidth / 2;

                //    if (fEndX - fStartX > fMaxLength)
                //        fMaxLength = fEndX - fStartX;

                //    if (fEndX - fStartX < fMinLength)
                //        fMinLength = fEndX - fStartX;
                //}

                switch (m_intLeadROIDirection)
                {
                    case 1:
                        if (m_stcBlobLead.fBaseCenterY - m_stcBlobLead.fTipCenterY > fMaxLength)
                            fMaxLength = m_stcBlobLead.fBaseCenterY - m_stcBlobLead.fTipCenterY;

                        if (m_stcBlobLead.fBaseCenterY - m_stcBlobLead.fTipCenterY < fMinLength)
                            fMinLength = m_stcBlobLead.fBaseCenterY - m_stcBlobLead.fTipCenterY;
                        break;
                    case 2:
                        if (m_stcBlobLead.fTipCenterX - m_stcBlobLead.fBaseCenterX > fMaxLength)
                            fMaxLength = m_stcBlobLead.fTipCenterX - m_stcBlobLead.fBaseCenterX;

                        if (m_stcBlobLead.fTipCenterX - m_stcBlobLead.fBaseCenterX < fMinLength)
                            fMinLength = m_stcBlobLead.fTipCenterX - m_stcBlobLead.fBaseCenterX;
                        break;
                    case 3:
                        if (m_stcBlobLead.fTipCenterY - m_stcBlobLead.fBaseCenterY > fMaxLength)
                            fMaxLength = m_stcBlobLead.fTipCenterY - m_stcBlobLead.fBaseCenterY;

                        if (m_stcBlobLead.fTipCenterY - m_stcBlobLead.fBaseCenterY < fMinLength)
                            fMinLength = m_stcBlobLead.fTipCenterY - m_stcBlobLead.fBaseCenterY;
                        break;
                    case 4:
                        if (m_stcBlobLead.fBaseCenterX - m_stcBlobLead.fTipCenterX > fMaxLength)
                            fMaxLength = m_stcBlobLead.fBaseCenterX - m_stcBlobLead.fTipCenterX;

                        if (m_stcBlobLead.fBaseCenterX - m_stcBlobLead.fTipCenterX < fMinLength)
                            fMinLength = m_stcBlobLead.fBaseCenterX - m_stcBlobLead.fTipCenterX;
                        break;
                }

            }

            m_fLengthVariance = (float)Math.Round(fMaxLength - fMinLength, 3, MidpointRounding.AwayFromZero);
        }

        /// <summary>
        /// Build Lead range - start X, start Y, end X, end Y
        /// </summary>
        /// <param name="objROI"></param>
        public void BuildLeadRange(ROI objROI)
        {
            float fStartX, fStartY, fEndX, fEndY;
            fStartX = (float)objROI.ref_ROIWidth;
            fStartY = (float)objROI.ref_ROIHeight;
            fEndX = 0;
            fEndY = 0;

            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];


                if (m_stcBlobLead.fLimitCenterX - m_stcBlobLead.fWidth / 2 < fStartX)
                    fStartX = m_stcBlobLead.fLimitCenterX - m_stcBlobLead.fWidth / 2;

                if (m_stcBlobLead.fLimitCenterY - m_stcBlobLead.fHeight / 2 < fStartY)
                    fStartY = m_stcBlobLead.fLimitCenterY - m_stcBlobLead.fHeight / 2;

                if (m_stcBlobLead.fLimitCenterX + m_stcBlobLead.fWidth / 2 > fEndX)
                    fEndX = m_stcBlobLead.fLimitCenterX + m_stcBlobLead.fWidth / 2;

                if (m_stcBlobLead.fLimitCenterY + m_stcBlobLead.fHeight / 2 > fEndY)
                    fEndY = m_stcBlobLead.fLimitCenterY + m_stcBlobLead.fHeight / 2;
            }

            m_fLeadRangeStartX = fStartX;
            m_fLeadRangeStartY = fStartY;
            m_fLeadRangeEndX = fEndX;
            m_fLeadRangeEndY = fEndY;
        }
        public void BuildLeadDistance_PatternMatch(ROI objROI)
        {
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                //m_stcBlobLead.fXDistance = objROI.ref_ROITotalX + m_stcBlobLead.fTipCenterX - m_pCornerPoint_Center.X;
                //m_stcBlobLead.fYDistance = objROI.ref_ROITotalY + m_stcBlobLead.fTipCenterY - m_pCornerPoint_Center.Y;
                m_stcBlobLead.fXDistance = objROI.ref_ROITotalX + m_stcBlobLead.fTipCenterX - m_fUnitAverageCenterX;
                m_stcBlobLead.fYDistance = objROI.ref_ROITotalY + m_stcBlobLead.fTipCenterY - m_fUnitAverageCenterY;
                // Keep this in case when the method use corner point to find unit center unstable, might need to use pattern match
                //m_stcBlobLead.fXDistance = m_stcBlobLead.fLimitCenterX - (float)objROI.ref_ROIWidth / 2;
                //m_stcBlobLead.fYDistance = m_stcBlobLead.fLimitCenterY - (float)objROI.ref_ROIHeight / 2;

                m_arrTemplateBlobLeads.RemoveAt(i);
                m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
            }
        }
        public void BuildLeadDistance_PatternMatch_BaseLead(ROI objROI)
        {
            for (int i = 0; i < m_arrTemplateBlobLeads_BaseLead.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i];

                //m_stcBlobLead.fXDistance = objROI.ref_ROITotalX + m_stcBlobLead.fTipCenterX - m_pCornerPoint_Center.X;
                //m_stcBlobLead.fYDistance = objROI.ref_ROITotalY + m_stcBlobLead.fTipCenterY - m_pCornerPoint_Center.Y;
                m_stcBlobLead.fXDistance = objROI.ref_ROITotalX + m_stcBlobLead.fCenterX - m_fUnitAverageCenterX;
                m_stcBlobLead.fYDistance = objROI.ref_ROITotalY + m_stcBlobLead.fCenterY - m_fUnitAverageCenterY;
                // Keep this in case when the method use corner point to find unit center unstable, might need to use pattern match
                //m_stcBlobLead.fXDistance = m_stcBlobLead.fLimitCenterX - (float)objROI.ref_ROIWidth / 2;
                //m_stcBlobLead.fYDistance = m_stcBlobLead.fLimitCenterY - (float)objROI.ref_ROIHeight / 2;

                m_arrTemplateBlobLeads_BaseLead.RemoveAt(i);
                m_arrTemplateBlobLeads_BaseLead.Insert(i, m_stcBlobLead);
            }
        }
        public void BuildLeadDistance(ROI objROI)
        {
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                m_stcBlobLead.fLeftDistance = m_stcBlobLead.fLimitCenterX - m_fLeadRangeStartX;
                m_stcBlobLead.fRightDistance = m_fLeadRangeEndX - m_stcBlobLead.fLimitCenterX;
                m_stcBlobLead.fTopDistance = m_stcBlobLead.fLimitCenterY - m_fLeadRangeStartY;
                m_stcBlobLead.fBottomDistance = m_fLeadRangeEndY - m_stcBlobLead.fLimitCenterY;
                m_stcBlobLead.fXDistance = m_stcBlobLead.fLimitCenterX - (float)objROI.ref_ROIWidth / 2;
                m_stcBlobLead.fYDistance = m_stcBlobLead.fLimitCenterY - (float)objROI.ref_ROIHeight / 2;

                m_arrTemplateBlobLeads.RemoveAt(i);
                m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
            }
        }

        private void BuildLeadReferencePoint(int intLeadPosition, ROI objROI)
        {
            m_fReferencePointStartX = objROI.ref_ROIWidth;
            m_fReferencePointStartY = objROI.ref_ROIHeight;
            m_fReferencePointEndX = 0;
            m_fReferencePointEndY = 0;

            switch (intLeadPosition)
            {
                case 1:
                    for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
                    {
                        m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                        if (m_stcBlobLead.fBaseCenterX - m_stcBlobLead.fBaseWidth / 2 < m_fReferencePointStartX)
                        {
                            m_fReferencePointStartX = m_stcBlobLead.fBaseCenterX - m_stcBlobLead.fBaseWidth / 2;
                            m_fReferencePointStartY = m_stcBlobLead.fBaseCenterY;
                        }

                        if (m_stcBlobLead.fBaseCenterX + m_stcBlobLead.fBaseWidth / 2 > m_fReferencePointEndX)
                        {
                            m_fReferencePointEndX = m_stcBlobLead.fBaseCenterX + m_stcBlobLead.fBaseWidth / 2;
                            m_fReferencePointEndY = m_stcBlobLead.fBaseCenterY;
                        }
                    }
                    break;
                case 2:
                    for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
                    {
                        m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                        if (m_stcBlobLead.fBaseCenterY - m_stcBlobLead.fBaseWidth / 2 < m_fReferencePointStartY)
                        {
                            m_fReferencePointStartY = m_stcBlobLead.fBaseCenterY - m_stcBlobLead.fBaseWidth / 2;
                            m_fReferencePointStartX = m_stcBlobLead.fBaseCenterX;
                        }

                        if (m_stcBlobLead.fBaseCenterY + m_stcBlobLead.fBaseWidth / 2 > m_fReferencePointEndY)
                        {
                            m_fReferencePointEndY = m_stcBlobLead.fBaseCenterY + m_stcBlobLead.fBaseWidth / 2;
                            m_fReferencePointEndX = m_stcBlobLead.fBaseCenterX;
                        }
                    }
                    break;
                case 3:
                    for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
                    {
                        m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                        if (m_stcBlobLead.fBaseCenterX - m_stcBlobLead.fBaseWidth / 2 < m_fReferencePointStartX)
                        {
                            m_fReferencePointStartX = m_stcBlobLead.fBaseCenterX - m_stcBlobLead.fBaseWidth / 2;
                            m_fReferencePointStartY = m_stcBlobLead.fBaseCenterY;
                        }

                        if (m_stcBlobLead.fBaseCenterX + m_stcBlobLead.fBaseWidth / 2 > m_fReferencePointEndX)
                        {
                            m_fReferencePointEndX = m_stcBlobLead.fBaseCenterX + m_stcBlobLead.fBaseWidth / 2;
                            m_fReferencePointEndY = m_stcBlobLead.fBaseCenterY;
                        }
                    }
                    break;
                case 4:
                    for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
                    {
                        m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                        if (m_stcBlobLead.fBaseCenterY - m_stcBlobLead.fBaseWidth / 2 < m_fReferencePointStartY)
                        {
                            m_fReferencePointStartY = m_stcBlobLead.fBaseCenterY - m_stcBlobLead.fBaseWidth / 2;
                            m_fReferencePointStartX = m_stcBlobLead.fBaseCenterX;
                        }

                        if (m_stcBlobLead.fBaseCenterY + m_stcBlobLead.fBaseWidth / 2 > m_fReferencePointEndY)
                        {
                            m_fReferencePointEndY = m_stcBlobLead.fBaseCenterY + m_stcBlobLead.fBaseWidth / 2;
                            m_fReferencePointEndX = m_stcBlobLead.fBaseCenterX;
                        }
                    }
                    break;
            }
        }

        private void BuildLeadReferencePoint_Lead3D(ROI objROI)
        {
            m_fReferencePointStartX = objROI.ref_ROIWidth;
            m_fReferencePointStartY = objROI.ref_ROIHeight;
            m_fReferencePointEndX = 0;
            m_fReferencePointEndY = 0;

            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                switch (m_stcBlobLead.intDirection)
                {
                    case 4:
                        {
                            if (m_stcBlobLead.fBaseCenterX - m_stcBlobLead.fBaseWidth / 2 < m_fReferencePointStartX)
                            {
                                m_fReferencePointStartX = m_stcBlobLead.fBaseCenterX - m_stcBlobLead.fBaseWidth / 2;
                                m_fReferencePointStartY = m_stcBlobLead.fLimitCenterY + m_stcBlobLead.fHeight / 2;
                            }

                            if (m_stcBlobLead.fBaseCenterX + m_stcBlobLead.fBaseWidth / 2 > m_fReferencePointEndX)
                            {
                                m_fReferencePointEndX = m_stcBlobLead.fBaseCenterX + m_stcBlobLead.fBaseWidth / 2;
                                m_fReferencePointEndY = m_stcBlobLead.fLimitCenterY + m_stcBlobLead.fHeight / 2;
                            }
                        }
                        break;
                    case 2:
                        {
                            if (m_stcBlobLead.fBaseCenterY - m_stcBlobLead.fBaseHeight / 2 < m_fReferencePointStartY)
                            {
                                m_fReferencePointStartY = m_stcBlobLead.fBaseCenterY - m_stcBlobLead.fBaseHeight / 2;
                                m_fReferencePointStartX = m_stcBlobLead.fLimitCenterX - m_stcBlobLead.fWidth / 2;
                            }

                            if (m_stcBlobLead.fBaseCenterY + m_stcBlobLead.fBaseHeight / 2 > m_fReferencePointEndY)
                            {
                                m_fReferencePointEndY = m_stcBlobLead.fBaseCenterY + m_stcBlobLead.fBaseHeight / 2;
                                m_fReferencePointEndX = m_stcBlobLead.fLimitCenterX - m_stcBlobLead.fWidth / 2;
                            }
                        }
                        break;
                    case 8:
                        {
                            if (m_stcBlobLead.fBaseCenterX - m_stcBlobLead.fBaseWidth / 2 < m_fReferencePointStartX)
                            {
                                m_fReferencePointStartX = m_stcBlobLead.fBaseCenterX - m_stcBlobLead.fBaseWidth / 2;
                                m_fReferencePointStartY = m_stcBlobLead.fLimitCenterY - m_stcBlobLead.fHeight / 2;
                            }

                            if (m_stcBlobLead.fBaseCenterX + m_stcBlobLead.fBaseWidth / 2 > m_fReferencePointEndX)
                            {
                                m_fReferencePointEndX = m_stcBlobLead.fBaseCenterX + m_stcBlobLead.fBaseWidth / 2;
                                m_fReferencePointEndY = m_stcBlobLead.fLimitCenterY - m_stcBlobLead.fHeight / 2;
                            }
                        }
                        break;
                    case 1:
                        {
                            if (m_stcBlobLead.fBaseCenterY - m_stcBlobLead.fBaseHeight / 2 < m_fReferencePointStartY)
                            {
                                m_fReferencePointStartY = m_stcBlobLead.fBaseCenterY - m_stcBlobLead.fBaseHeight / 2;
                                m_fReferencePointStartX = m_stcBlobLead.fLimitCenterX + m_stcBlobLead.fWidth / 2;
                            }

                            if (m_stcBlobLead.fBaseCenterY + m_stcBlobLead.fBaseHeight / 2 > m_fReferencePointEndY)
                            {
                                m_fReferencePointEndY = m_stcBlobLead.fBaseCenterY + m_stcBlobLead.fBaseHeight / 2;
                                m_fReferencePointEndX = m_stcBlobLead.fLimitCenterX + m_stcBlobLead.fWidth / 2;
                            }
                        }
                        break;
                }
            }
        }


        /// <summary>
        /// Clear m_arrTemplateBlobLeads
        /// </summary>
        public void ClearTemplateBlobsFeatures()
        {
            m_arrTemplateBlobLeads.Clear();
        }
        public void ClearTemplateBlobsFeatures_BaseLead()
        {
            m_arrTemplateBlobLeads_BaseLead.Clear();
        }

        /// <summary>
        /// Clear m_arrTemporaryBlobLeads
        /// </summary>
        public void ClearTempBlobsFeatures()
        {
            m_arrTemporaryBlobLeads.Clear();
        }
        public void ClearTempBlobsFeatures_BaseLead()
        {
            m_arrTemporaryBlobLeads_BaseLead.Clear();
        }
        /// <summary>
        /// Clear m_arrPitchGap
        /// </summary>
        public void ClearTemplatePitchGap()
        {
            m_arrPitchGap.Clear();
        }

        /// <summary>
        /// Get total pitch gap
        /// </summary>
        /// <returns>total pitch gap</returns>
        public int GetTotalPitchGap()
        {
            return m_arrPitchGap.Count;
        }

        public PointF GetResultCenterPoint_UnitMatcher()
        {
            return m_pUnitCenterPoint;
        }
        public Size GetPatternSize_UnitMatcher()
        {
            if(m_objMatcher.PatternLearnt)
                return new Size(m_objMatcher.PatternWidth, m_objMatcher.PatternHeight);
            else
                return new Size(0, 0);
        }
        
        /// <summary>
        /// Get blobs features length mode
        /// </summary>
        /// <param name="intIndex">blob index</param>
        /// <returns>length mode, 1: Length = Height, 2: Length = Width</returns>
        public int GetSampleLengthMode(int intIndex)
        {
            return ((BlobsFeatures)m_arrTemplateBlobLeads[intIndex]).intLengthMode;
        }

        /// <summary>
        /// Get pitch gap data
        /// </summary>
        /// <param name="intPitchGapIndex">pitch gap index</param>
        /// <returns>pitch gap data</returns>
        public string GetPitchGapData(int intPitchGapIndex)
        {
            string strPitchGapData = "";

            PitchGap stcPitchGap = m_arrPitchGap[intPitchGapIndex];

            strPitchGapData += stcPitchGap.intFromLeadNo.ToString() + "#";
            strPitchGapData += stcPitchGap.intToLeadNo.ToString() + "#";
            strPitchGapData += (stcPitchGap.fMinPitch * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "#";
            strPitchGapData += (stcPitchGap.fMaxPitch * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "#";
            strPitchGapData += (stcPitchGap.fMinGap * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "#";
            strPitchGapData += (stcPitchGap.fMaxGap * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "#";
            strPitchGapData += stcPitchGap.fGap.ToString() + "#";
            strPitchGapData += stcPitchGap.fPitch.ToString() + "#";
            strPitchGapData += stcPitchGap.intStartPointX.ToString() + "#";
            strPitchGapData += stcPitchGap.intStartPointY.ToString() + "#";
            strPitchGapData += stcPitchGap.intEndPointX.ToString() + "#";
            strPitchGapData += stcPitchGap.intEndPointY.ToString() + "#";
            strPitchGapData += stcPitchGap.intDirection.ToString() + "#";

            return strPitchGapData;
        }
        public int GetPitchGapToLeadNo(int intFromLeadNo)
        {
            string strPitchGapData = "";

            for (int i = 0; i < m_arrPitchGap.Count; i++)
            {
                PitchGap stcPitchGap = m_arrPitchGap[i];

                if (stcPitchGap.intFromLeadNo == intFromLeadNo)
                {
                    return stcPitchGap.intToLeadNo;
                }
            }

            return -1;
        }
        /// <summary>
        /// Get total selected object
        /// </summary>
        /// <returns>selected object count</returns>
        public int GetSelectedObjectNumber()
        {
            int intObjectCount = 0;
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                if (((BlobsFeatures)m_arrTemplateBlobLeads[i]).blnSelected)
                    intObjectCount++;
            }
            return intObjectCount;
        }
        public int GetSelectedObjectNumber_BaseLead()
        {
            int intObjectCount = 0;
            for (int i = 0; i < m_arrTemplateBlobLeads_BaseLead.Count; i++)
            {
                if (((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).blnSelected)
                    intObjectCount++;
            }
            return intObjectCount;
        }
        /// <summary>
        /// Get the pitch gap drawing point
        /// </summary>
        /// <param name="intStartLine1">start line 1</param>
        /// <param name="intEndLine1">end line 1</param>
        /// <param name="intStartLine2">start line 2</param>
        /// <param name="intEndLine2">end line 2</param>
        /// <returns>pitch gap drawing point</returns>
        public int GetDrawPoint(int intStartLine1, int intEndLine1, int intStartLine2, int intEndLine2)
        {
            int intStartPoint;
            int intEndPoint;

            if (intStartLine1 > intStartLine2)
                intStartPoint = intStartLine1;
            else
                intStartPoint = intStartLine2;

            if (intEndLine1 < intEndLine2)
                intEndPoint = intEndLine1;
            else
                intEndPoint = intEndLine2;

            return intStartPoint + (int)Math.Abs((intStartPoint - intEndPoint) / 2);
        }

        /// <summary>
        /// Get inspection fail result
        /// </summary>
        /// <param name="strPosition">ROI position (Center ROI, Top ROI, Bottom ROI, Left ROI, Right ROI)</param>
        /// <returns>inspection fail result in string</returns>
        public string GetLeadFailTestDisplayResult_BaseLead(string strPosition)
        {
            float fData;
            float fMin;
            float fMax;
            float fMeasure;
            int intNoID;
            string strFailMessage = "";

            BlobsFeatures stcBlobsFeatures;

            for (int i = 0; i < m_arrSampleBlobLeads_BaseLead.Length; i++)
            {
                stcBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i];
                intNoID = stcBlobsFeatures.intNoID;

                if ((m_arrSampleBlobLeads_BaseLead[i].intFailMask & 0x40000) > 0)
                {
                    strFailMessage += strPosition + "Lead " + intNoID + ": Missing Base Lead.";
                }

            }

            for (int i = 0; i < m_arrSampleBlobLeads_BaseLead.Length; i++)
            {
                stcBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i];
                intNoID = stcBlobsFeatures.intNoID;
                
                if ((m_arrSampleBlobLeads_BaseLead[i].intFailMask & 0x10000) > 0)
                {
                    strFailMessage += strPosition + "Lead " + intNoID + ": Base Lead Offset. ";
                    fMax = stcBlobsFeatures.fMaxBaseOffset * m_fMMToUnitValue;    // Can use either m_fMMToUnitValue or m_fMMToUnitValue
                    fMeasure = m_arrSampleBlobLeads_BaseLead[i].fOffSetMM * m_fMMToUnitValue;
                    strFailMessage += "Set < " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                }

                if ((m_arrSampleBlobLeads_BaseLead[i].intFailMask & 0x20000) > 0)
                {
                    strFailMessage += strPosition + "Lead " + intNoID + ": Base Lead Area Fail. ";
                    //else
                    //    strFailMessage += strPosition + "Lead " + intNoID + ": Width Fail. ";

                    fMin = stcBlobsFeatures.fMinBaseArea * m_fMMToUnitValue;
                    fMax = stcBlobsFeatures.fMaxBaseArea * m_fMMToUnitValue;
                    fMeasure = m_arrSampleBlobLeads_BaseLead[i].fAreaMM * m_fMMToUnitValue;
                    strFailMessage += "Min: " + fMin.ToString("F" + m_intDecimal) + ", Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                }

            }

            return strFailMessage;
        }
        public string GetLeadFailTestDisplayResult(string strPosition)
        {
            float fData;
            float fMin;
            float fMax;
            float fMeasure;
            int intNoID;
            string strFailMessage = "";
            List<int> arrJoint = new List<int>();
            //List<int> arrBroken = new List<int>();
            //List<int> arrExcess = new List<int>();
            //List<int> arrSmear = new List<int>();

            BlobsFeatures stcBlobsFeatures;

            for (int i = 0; i < m_arrSampleBlobLeads.Length; i++)
            {
                stcBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                intNoID = stcBlobsFeatures.intNoID;

                if ((m_arrSampleBlobLeads[i].intFailMask & 0x40) > 0)
                {
                    //if (stcBlobsFeatures.intLengthMode == 1)
                    strFailMessage += strPosition + "Lead " + intNoID + ": Width Fail. ";
                    //else
                    //    strFailMessage += strPosition + "Lead " + intNoID + ": Length Fail. ";

                    fMin = stcBlobsFeatures.fMinTipWidth * m_fMMToUnitValue;
                    fMax = stcBlobsFeatures.fMaxTipWidth * m_fMMToUnitValue;
                    fMeasure = m_arrSampleBlobLeads[i].fTipWidthMM * m_fMMToUnitValue;
                    strFailMessage += "Min: " + fMin.ToString("F" + m_intDecimal) + ", Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                }

                if ((m_arrSampleBlobLeads[i].intFailMask & 0x80) > 0)
                {
                    //if (stcBlobsFeatures.intLengthMode == 1)
                    strFailMessage += strPosition + "Lead " + intNoID + ": Length Fail. ";
                    //else
                    //    strFailMessage += strPosition + "Lead " + intNoID + ": Width Fail. ";

                    fMin = stcBlobsFeatures.fMinTipHeight * m_fMMToUnitValue;
                    fMax = stcBlobsFeatures.fMaxTipHeight * m_fMMToUnitValue;
                    fMeasure = m_arrSampleBlobLeads[i].fTipHeightMM * m_fMMToUnitValue;
                    strFailMessage += "Min: " + fMin.ToString("F" + m_intDecimal) + ", Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                }

                if ((m_arrSampleBlobLeads[i].intFailMask & 0x100) > 0)
                {
                    strFailMessage += strPosition + "Lead " + intNoID + ": Lead Off Set. ";
                    fMax = stcBlobsFeatures.fOffSet * m_fMMToUnitValue;    // Can use either m_fMMToUnitValue or m_fMMToUnitValue
                    fMeasure = m_arrSampleBlobLeads[i].fOffSetMM * m_fMMToUnitValue;
                    strFailMessage += "Set < " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                }

                if ((m_arrSampleBlobLeads[i].intFailMask & 0x8000) > 0)
                {
                    strFailMessage += strPosition + "Lead " + intNoID + ": Lead Skew. ";
                    if (m_arrSampleBlobLeads[i].blnBaseStartFound || m_arrSampleBlobLeads[i].blnBaseEndFound)
                    {
                        fMax = stcBlobsFeatures.fSkew * m_fMMToUnitValue;    // Can use either m_fMMToUnitValue or m_fMMToUnitValue
                        fMeasure = m_arrSampleBlobLeads[i].fSkewMM * m_fMMToUnitValue;
                        strFailMessage += "Set < " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                    }
                    else
                    {
                        strFailMessage += "Fail to find base points";
                    }
                }

                if ((m_arrSampleBlobLeads[i].intFailMask & 0x800) > 0)
                {
                    strFailMessage += strPosition + "Lead " + intNoID + ": Lead Variance. ";
                    fMax = stcBlobsFeatures.fVariance * m_fMMToUnitValue;    // Can use either m_fMMToUnitValue or m_fMMToUnitValue
                    fMeasure = m_arrSampleBlobLeads[i].fVarianceMM * m_fMMToUnitValue;
                    strFailMessage += "Set < " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                }

                if ((m_arrSampleBlobLeads[i].intFailMask & 0x4000) > 0)
                {
                    strFailMessage += strPosition + "Lead " + intNoID + ": Lead Average Gray Value. ";
                    fMin = stcBlobsFeatures.fMinAGV;
                    fMax = stcBlobsFeatures.fMaxAGV;
                    fMeasure = m_arrSampleBlobLeads[i].fAGV;
                    strFailMessage += "Min: " + fMin.ToString("F" + m_intDecimal) + ", Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                }
            }

            for (int y = 0; y < m_arrPitchGap.Count; y++)
            {
                int intFrom = m_arrPitchGap[y].intFromLeadNo + 1;
                int intTo = m_arrPitchGap[y].intToLeadNo + 1;
                if ((m_arrPitchGap[y].intFailMask & 0x400) > 0)
                {
                    strFailMessage += strPosition + "Gap " + intFrom.ToString() + " to " + intTo.ToString() + " Fail. ";
                    fMin = m_arrPitchGap[y].fMinGap * m_fMMToUnitValue;
                    fMax = m_arrPitchGap[y].fMaxGap * m_fMMToUnitValue;
                    fMeasure = m_arrPitchGap[y].fGapMM * m_fMMToUnitValue;
                    //fMeasure = m_arrSampleBlobLeads[intFrom - 1].fGapMM * m_fMMToUnitValue;
                    strFailMessage += "Min: " + fMin.ToString("F" + m_intDecimal) + ", Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                }

                if ((m_arrPitchGap[y].intFailMask & 0x200) > 0)
                {
                    strFailMessage += strPosition + "Pitch " + intFrom.ToString() + " to " + intTo.ToString() + " Fail. ";
                    fMin = m_arrPitchGap[y].fMinPitch * m_fMMToUnitValue;
                    fMax = m_arrPitchGap[y].fMaxPitch * m_fMMToUnitValue;
                    fMeasure = m_arrPitchGap[y].fPitchMM * m_fMMToUnitValue;
                    //fMeasure = m_arrSampleBlobLeads[intFrom - 1].fPitchMM * m_fMMToUnitValue;
                    strFailMessage += "Min: " + fMin.ToString("F" + m_intDecimal) + ", Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                }
            }

            for (int i = 0; i < m_arrSampleBlobLeads.Length; i++)
            {
                stcBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                intNoID = stcBlobsFeatures.intNoID;

                //Lead Reference point
                if ((m_arrSampleBlobLeads[i].intFailMask & 0x01) > 0)
                {
                    strFailMessage += strPosition + "Lead " + intNoID + ": Lead Reference Point fail.";
                }


                //Joint Lead
                if ((m_arrSampleBlobLeads[i].intFailMask & 0x02) > 0)
                {
                    arrJoint.Add(intNoID);
                }

                if ((m_arrSampleBlobLeads[i].intFailMask & 0x04) > 0)
                {
                    strFailMessage += strPosition + "Lead " + intNoID + ": Missing Lead.";
                }

                ////Broken Lead and Hole Lead
                //if ((m_arrSampleBlobLeads[i].intFailMask & 0x08) > 0 || (m_arrSampleBlobLeads[i].intFailMask & 0x10) > 0)
                //{
                //    arrBroken.Add(intNoID);
                //}

                ////Excess Lead
                //if ((m_arrSampleBlobLeads[i].intFailMask & 0x800) > 0)
                //{
                //    arrExcess.Add(intNoID);
                //}

                ////Smear Lead
                //if ((m_arrSampleBlobLeads[i].intFailMask & 0x2000) > 0)
                //{
                //    arrSmear.Add(intNoID);
                //}
            }

            if (arrJoint.Count > 0)
            {
                for (int i = 0; i < arrJoint.Count; i++)
                {
                    if (i == 0)
                        strFailMessage += strPosition + "Lead " + (arrJoint[i]);
                    else
                        strFailMessage += (arrJoint[i]);

                    if (i != arrJoint.Count - 1)
                        strFailMessage += ", ";
                    else
                    {
                        strFailMessage += ": Bridgging.";
                    }
                }
            }

            if ((m_intFailResultMask & 0x800) > 0)
            {
                strFailMessage += strPosition + "Length Variance Fail. Set=" + m_fTemplateLengthVarianceMaxLimit.ToString() + "mm, Result=" + m_fSampleLengthVarianceMM.ToString("F4") + "mm";
            }

            if ((m_intFailResultMask & 0x1000) > 0)
            {
                strFailMessage += strPosition + "Span Fail. Set Min: " + m_fTemplateLeadMinSpanLimit.ToString("F" + m_intDecimal) +
                                                ", Max: " + m_fTemplateLeadMaxSpanLimit.ToString("F" + m_intDecimal) +
                                                ", Result =" + m_fLeadSpanResultMM.ToString("F4") + "mm";
            }


            if (m_arrExtraBlobs.Count > 0)
            {
                for (int i = 0; i < m_arrExtraBlobs.Count; i++)
                {
                    //strFailMessage += strPosition + "Extra Lead.";
                    // Contamination
                    if (m_blnWantCheckExtraLeadLength)
                    {
                        if ((m_arrExtraBlobs[i].ref_intFailCriteria & 0x01) > 0)
                        {
                            strFailMessage += strPosition + "Defect " + m_arrExtraBlobs[i].ref_intExtraBlobID + " Lead contamination width. Set=" + m_fExtraLeadSetLength +
                                "mm, Result=" + (m_arrExtraBlobs[i].ref_fWidthFailValue).ToString("F" + m_intDecimal) + "mm.";
                        }

                        if ((m_arrExtraBlobs[i].ref_intFailCriteria & 0x02) > 0)
                        {
                            strFailMessage += strPosition + "Defect " + m_arrExtraBlobs[i].ref_intExtraBlobID + " Lead contamination length. Set=" + m_fExtraLeadSetLength +
                                "mm, Result=" + (m_arrExtraBlobs[i].ref_fHeightFailValue).ToString("F" + m_intDecimal) + "mm.";
                        }
                    }
                    if (m_blnWantCheckExtraLeadArea)
                    {
                        if ((m_arrExtraBlobs[i].ref_intFailCriteria & 0x04) > 0 && !m_blnFailForeignMaterialTotalArea)
                        {
                            strFailMessage += strPosition + "Defect " + m_arrExtraBlobs[i].ref_intExtraBlobID + " Lead contamination area. Set=" + m_fExtraLeadSetArea +
                                "mm^2, Result=" + (m_arrExtraBlobs[i].ref_fAreaFailValue).ToString("F" + m_intDecimal2) + "mm^2.";
                        }
                    }
                    if ((m_intFailOptionMask & 0x2000) > 0)
                    {
                        if (((m_arrExtraBlobs[i].ref_intFailCriteria & 0x04) > 0) && m_blnFailForeignMaterialTotalArea)
                        {
                            strFailMessage += strPosition + "Defect " + m_arrExtraBlobs[i].ref_intExtraBlobID + " Lead contamination Total area. Set=" + m_fTotalExtraLeadSetArea +
                                "mm^2, Result=" + (m_arrExtraBlobs[i].ref_fAreaFailValue).ToString("F" + m_intDecimal2) + "mm^2.";
                        }
                    }
                }
            }
            return strFailMessage;
        }
        /// <summary>
        /// Get inspection fail result
        /// </summary>
        /// <param name="strPosition">ROI position (Center ROI, Top ROI, Bottom ROI, Left ROI, Right ROI)</param>
        /// <returns>inspection fail result in string</returns>
        public string GetLeadSpanFailTestDisplayResult()
        {
            string strFailMessage = "";

            if ((m_intFailResultMask & 0x1000) > 0)
            {
                if (m_fTemplateLeadMinSpanLimit > m_fLeadMinSpanResult && m_fTemplateLeadMaxSpanLimit < m_fLeadMaxSpanResult)
                {
                    strFailMessage += "Lead Min Span fail.";
                    strFailMessage += "Set > " + m_fTemplateLeadMinSpanLimit.ToString("F" + m_intDecimal) + ", Measure: " + m_fLeadMinSpanResult.ToString("F" + m_intDecimal) + ",\n";

                    strFailMessage += "Lead Max Span fail.";
                    strFailMessage += "Set < " + m_fTemplateLeadMaxSpanLimit.ToString("F" + m_intDecimal) + ", Measure: " + m_fLeadMaxSpanResult.ToString("F" + m_intDecimal);
                }
                else if (m_fTemplateLeadMinSpanLimit > m_fLeadMinSpanResult)
                {
                    strFailMessage += "Lead Min Span fail.";
                    strFailMessage += "Set > " + m_fTemplateLeadMinSpanLimit.ToString("F" + m_intDecimal) + ", Measure: " + m_fLeadMinSpanResult.ToString("F" + m_intDecimal);
                }
                else if (m_fTemplateLeadMaxSpanLimit < m_fLeadMaxSpanResult)
                {
                    strFailMessage += "Lead Max Span fail.";
                    strFailMessage += "Set < " + m_fTemplateLeadMaxSpanLimit.ToString("F" + m_intDecimal) + ", Measure: " + m_fLeadMaxSpanResult.ToString("F" + m_intDecimal);
                }


            }

            return strFailMessage;
        }
        public string GetLeadSpanFailTestDisplayResult(string strPosition)
        {
            string strFailMessage = "";

            if ((m_intFailResultMask & 0x1000) > 0)
            {
                if (m_fTemplateLeadMaxSpanLimit < m_fLeadSpanResultMM || m_fTemplateLeadMinSpanLimit > m_fLeadSpanResultMM)
                {
                    strFailMessage += strPosition + "Span Fail. Set Min: " + m_fTemplateLeadMinSpanLimit.ToString("F" + m_intDecimal) +
                                                                    ", Max: " + m_fTemplateLeadMaxSpanLimit.ToString("F" + m_intDecimal) +
                                                                    ", Result =" + m_fLeadSpanResultMM.ToString("F4") + "mm";
                }

            }

            return strFailMessage;
        }
        /// <summary>
        /// Get threshold value of particular ROI using specific threshold mode
        /// </summary>
        /// <param name="objROI">ROI</param>
        /// <param name="intThresholdMode">threshold mode, 0 = absolute, 1 = isodata, 3 = max entropy, 4 = min residue, 5 = relative</param>
        /// <returns>threshold value</returns>
        public int GetAutoThresholdValue(ROI objROI, int intThresholdMode)
        {
            EBW8 objBW8;
            if (intThresholdMode == 0)
                objBW8 = EasyImage.AutoThreshold(objROI.ref_ROI, EThresholdMode.Absolute);
            else if (intThresholdMode == 1)
                objBW8 = EasyImage.AutoThreshold(objROI.ref_ROI, EThresholdMode.Isodata);
            else if (intThresholdMode == 2)
                objBW8 = EasyImage.AutoThreshold(objROI.ref_ROI, EThresholdMode.MaxEntropy);
            else if (intThresholdMode == 3)
                objBW8 = EasyImage.AutoThreshold(objROI.ref_ROI, EThresholdMode.MinResidue);
            else
                objBW8 = EasyImage.AutoThreshold(objROI.ref_ROI, EThresholdMode.Relative);

            return objBW8.Value;
        }

        public void GetSpanData(int intLeadNo, ref float fLeadMinSpan, ref float fLeadMaxSpan)
        {
            switch (intLeadNo)
            {
                case 1:
                    fLeadMinSpan = m_fLeadMinSpanStart;
                    fLeadMaxSpan = m_fLeadMaxSpanStart;
                    break;
                case 2:
                    fLeadMinSpan = m_fLeadMinSpanEnd;
                    fLeadMaxSpan = m_fLeadMaxSpanEnd;
                    break;
                case 3:
                    fLeadMinSpan = m_fLeadMinSpanEnd;
                    fLeadMaxSpan = m_fLeadMaxSpanEnd;
                    break;
                case 4:
                    fLeadMinSpan = m_fLeadMinSpanStart;
                    fLeadMaxSpan = m_fLeadMaxSpanStart;
                    break;
            }
        }

        public void GetSampleSpanData(int intLeadNo, ref float fSampleLeadMinSpan, ref float fSampleLeadMaxSpan)
        {
            switch (intLeadNo)
            {
                case 1:
                    fSampleLeadMinSpan = m_fSampleLeadMinSpanStart;
                    fSampleLeadMaxSpan = m_fSampleLeadMaxSpanStart;
                    break;
                case 2:
                    fSampleLeadMinSpan = m_fSampleLeadMinSpanEnd;
                    fSampleLeadMaxSpan = m_fSampleLeadMaxSpanEnd;
                    break;
                case 3:
                    fSampleLeadMinSpan = m_fSampleLeadMinSpanEnd;
                    fSampleLeadMaxSpan = m_fSampleLeadMaxSpanEnd;
                    break;
                case 4:
                    fSampleLeadMinSpan = m_fSampleLeadMinSpanStart;
                    fSampleLeadMaxSpan = m_fSampleLeadMaxSpanStart;
                    break;
            }
        }

        /// <summary>
        /// Set blobs data in m_objBlobs into m_arrTemporaryBlobLeads
        /// </summary>
        public void SetBlobsFeaturesToTempArray(ROI objROI)
        {
            SetBlobsFeaturesToArray(m_objEBlobs, m_arrTemporaryBlobLeads, objROI, true);
        }
        public void SetBlobsFeaturesToTempArray_BaseLead(ROI objROI)
        {
            SetBlobsFeaturesToArray_BaseLead(m_objEBlobs_BaseLead, m_arrTemporaryBlobLeads_BaseLead, objROI, true);
        }
        public void SetBlobsFeaturesToTempArray_CenterLead3D(ROI objROI)
        {
            SetBlobsFeaturesToArray_CenterLead3D(m_objEBlobs, m_arrTemporaryBlobLeads, objROI);
        }

        public void SetBlobsFeaturesToTempArray_SideLead3D(ROI objROI)
        {
            SetBlobsFeaturesToArray_SideLead3D(m_objEBlobs, m_arrTemporaryBlobLeads, objROI);
        }

        /// <summary>
        /// Set blobs data in m_objBlobs into m_arrTemplateBlobLeads
        /// </summary>
        public void SetBlobsFeaturesToArray(ROI objROI)
        {
            SetBlobsFeaturesToArray(m_objEBlobs, m_arrTemplateBlobLeads, objROI, false);
        }
        public void SetBlobsFeaturesToArray_BaseLead(ROI objROI)
        {
            SetBlobsFeaturesToArray_BaseLead(m_objEBlobs_BaseLead, m_arrTemplateBlobLeads_BaseLead, objROI, false);
        }
        public void SetBlobsFeaturesToArray_CenterLead3D(ROI objROI)
        {
            SetBlobsFeaturesToArray_CenterLead3D(m_objEBlobs, m_arrTemplateBlobLeads, objROI);
        }

        public void SetBlobsFeaturesToArray_SideLead3D(ROI objROI)
        {
            SetBlobsFeaturesToArray_SideLead3D(m_objEBlobs, m_arrTemplateBlobLeads, objROI);
        }

        /// <summary>
        /// Check no of objects is it tally with previous setting
        /// </summary>
        /// <param name="intCount">no of previous objects</param>
        /// <returns>true = objects no is tally, false = otherwise</returns>
        public bool CheckLeadTally(ref int intCount)
        {
            intCount = m_arrBackupTemplateBlobLeads.Count;
            int intNewCount = GetSelectedObjectNumber();

            if (intNewCount == m_arrBackupTemplateBlobLeads.Count)
                return true;
            else
                return false;
        }
        public bool CheckLeadTally_BaseLead(ref int intCount)
        {
            intCount = m_arrBackupTemplateBlobLeads.Count;
            int intNewCount = GetSelectedObjectNumber_BaseLead();

            if (intNewCount == m_arrBackupTemplateBlobLeads.Count)
                return true;
            else
                return false;
        }

        /// <summary>
        /// Check whether pitch gap link is exist
        /// </summary>
        /// <param name="intFromLeadNo">from Lead no</param>
        /// <param name="intToLeadNo">to Lead no</param>
        /// <returns>true = pitch gap link exist, false = otherwise</returns>
        public bool CheckPitchGapLinkExist(int intFromLeadNo, int intToLeadNo)
        {
            for (int i = 0; i < m_arrPitchGap.Count; i++)
            {
                if ((m_arrPitchGap[i].intFromLeadNo == (intFromLeadNo)) &&
                    (m_arrPitchGap[i].intToLeadNo == (intToLeadNo)) ||
                    (m_arrPitchGap[i].intFromLeadNo == (intToLeadNo)) &&
                    (m_arrPitchGap[i].intToLeadNo == (intFromLeadNo)))
                {
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// Check whether this Lead has already link with other Lead
        /// </summary>
        /// <param name="intFromLeadNo">from Lead no</param>
        /// <returns>true = Lead has link with other Lead, false = otherwise</returns>
        public bool CheckPitchGapLinkInLeadAlready(int intFromLeadNo)
        {
            for (int i = 0; i < m_arrPitchGap.Count; i++)
            {
                if (m_arrPitchGap[i].intFromLeadNo == intFromLeadNo)
                {
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// Verify whether pitch gap allow to be created between two Leads
        /// </summary>
        /// <param name="intFromLeadNo">from Lead no</param>
        /// <param name="intToLeadNo">to Lead no</param>
        /// <returns>true = valid pitch gap link, false = invalid pitch gap link</returns>
        public bool CheckPitchGapLinkAvailable(int intFromLeadNo, int intToLeadNo)
        {
            m_stcPitchGap = new PitchGap();
            m_stcPitchGap.intFromLeadNo = intFromLeadNo;
            m_stcPitchGap.intToLeadNo = intToLeadNo;

            if ((intFromLeadNo < m_arrTemplateBlobLeads.Count) && (intToLeadNo < m_arrTemplateBlobLeads.Count))
            {
                int intDrawPoint;
                bool blnUpDownFound = false;
                bool blnLeftRightFound = false;
                BlobsFeatures stcFromBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobLeads[intFromLeadNo];
                BlobsFeatures stcToBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobLeads[intToLeadNo];

                int intStartX_From = 0, intStartY_From = 0, intEndX_From = 0, intEndY_From = 0;
                int intStartX_To = 0, intStartY_To = 0, intEndX_To = 0, intEndY_To = 0;

                switch (m_intLeadROIDirection)
                {
                    case 1: //Top
                        intStartX_From = (int)(stcFromBlobsFeatures.fTipCenterX - stcFromBlobsFeatures.fTipWidth / 2);

                        intEndX_From = (int)(stcFromBlobsFeatures.fTipCenterX + stcFromBlobsFeatures.fTipWidth / 2);

                        intStartY_From = (int)(stcFromBlobsFeatures.fTipCenterY);

                        intEndY_From = (int)(stcFromBlobsFeatures.fTipCenterY + stcFromBlobsFeatures.fTipHeight);
                        break;
                    case 2: //Right
                        intStartX_From = (int)(stcFromBlobsFeatures.fTipCenterX - stcFromBlobsFeatures.fTipHeight);

                        intEndX_From = (int)(stcFromBlobsFeatures.fTipCenterX);

                        intStartY_From = (int)(stcFromBlobsFeatures.fTipCenterY - stcFromBlobsFeatures.fTipWidth / 2);

                        intEndY_From = (int)(stcFromBlobsFeatures.fTipCenterY + stcFromBlobsFeatures.fTipWidth / 2);
                        break;
                    case 3: //Bottom
                        intStartX_From = (int)(stcFromBlobsFeatures.fTipCenterX - stcFromBlobsFeatures.fTipWidth / 2);

                        intEndX_From = (int)(stcFromBlobsFeatures.fTipCenterX + stcFromBlobsFeatures.fTipWidth / 2);

                        intStartY_From = (int)(stcFromBlobsFeatures.fTipCenterY - stcFromBlobsFeatures.fTipHeight);

                        intEndY_From = (int)(stcFromBlobsFeatures.fTipCenterY);
                        break;
                    case 4: //Left
                        intStartX_From = (int)(stcFromBlobsFeatures.fTipCenterX);

                        intEndX_From = (int)(stcFromBlobsFeatures.fTipCenterX + stcFromBlobsFeatures.fTipHeight);

                        intStartY_From = (int)(stcFromBlobsFeatures.fTipCenterY - stcFromBlobsFeatures.fTipWidth / 2);

                        intEndY_From = (int)(stcFromBlobsFeatures.fTipCenterY + stcFromBlobsFeatures.fTipWidth / 2);
                        break;
                }

                switch (m_intLeadROIDirection)
                {
                    case 1: //Top
                        intStartX_To = (int)(stcToBlobsFeatures.fTipCenterX - stcToBlobsFeatures.fTipWidth / 2);

                        intEndX_To = (int)(stcToBlobsFeatures.fTipCenterX + stcToBlobsFeatures.fTipWidth / 2);

                        intStartY_To = (int)(stcToBlobsFeatures.fTipCenterY);

                        intEndY_To = (int)(stcToBlobsFeatures.fTipCenterY + stcToBlobsFeatures.fTipHeight);
                        break;
                    case 2: //Right
                        intStartX_To = (int)(stcToBlobsFeatures.fTipCenterX - stcToBlobsFeatures.fTipHeight);

                        intEndX_To = (int)(stcToBlobsFeatures.fTipCenterX);

                        intStartY_To = (int)(stcToBlobsFeatures.fTipCenterY - stcToBlobsFeatures.fTipWidth / 2);

                        intEndY_To = (int)(stcToBlobsFeatures.fTipCenterY + stcToBlobsFeatures.fTipWidth / 2);
                        break;
                    case 3: //Bottom
                        intStartX_To = (int)(stcToBlobsFeatures.fTipCenterX - stcToBlobsFeatures.fTipWidth / 2);

                        intEndX_To = (int)(stcToBlobsFeatures.fTipCenterX + stcToBlobsFeatures.fTipWidth / 2);

                        intStartY_To = (int)(stcToBlobsFeatures.fTipCenterY - stcToBlobsFeatures.fTipHeight);

                        intEndY_To = (int)(stcToBlobsFeatures.fTipCenterY);
                        break;
                    case 4: //Left
                        intStartX_To = (int)(stcToBlobsFeatures.fTipCenterX);

                        intEndX_To = (int)(stcToBlobsFeatures.fTipCenterX + stcToBlobsFeatures.fTipHeight);

                        intStartY_To = (int)(stcToBlobsFeatures.fTipCenterY - stcToBlobsFeatures.fTipWidth / 2);

                        intEndY_To = (int)(stcToBlobsFeatures.fTipCenterY + stcToBlobsFeatures.fTipWidth / 2);
                        break;
                }

                // Check pitch available between up and down Leads
                if ((intStartX_From >= intStartX_To) && (intStartX_From <= intEndX_To) ||
                    (intEndX_From >= intStartX_To) && (intEndX_From <= intEndX_To) ||
                    (intStartX_To >= intStartX_From) && (intEndX_To <= intEndX_From) ||
                    (intEndX_To >= intStartX_From) && (intEndX_To <= intEndX_From))
                {
                    blnUpDownFound = true;
                }

                // Check pitch available between left and right Leads
                if ((intStartY_From >= intStartY_To) && (intStartY_From <= intEndY_To) ||
                    (intEndY_From >= intStartY_To) && (intEndY_From <= intEndY_To) ||
                    (intStartY_To >= intStartY_From) && (intEndY_To <= intEndY_From) ||
                    (intEndY_To >= intStartY_From) && (intEndY_To <= intEndY_From))
                {
                    blnLeftRightFound = true;
                }

                //// Check pitch available between up and down Leads
                //if ((stcFromBlobsFeatures.intStartX >= stcToBlobsFeatures.intStartX) && (stcFromBlobsFeatures.intStartX <= stcToBlobsFeatures.intEndX) ||
                //    (stcFromBlobsFeatures.intEndX >= stcToBlobsFeatures.intStartX) && (stcFromBlobsFeatures.intEndX <= stcToBlobsFeatures.intEndX) ||
                //    (stcToBlobsFeatures.intStartX >= stcFromBlobsFeatures.intStartX) && (stcToBlobsFeatures.intEndX <= stcFromBlobsFeatures.intEndX) ||
                //    (stcToBlobsFeatures.intEndX >= stcFromBlobsFeatures.intStartX) && (stcToBlobsFeatures.intEndX <= stcFromBlobsFeatures.intEndX))
                //{
                //    blnUpDownFound = true;
                //}

                //// Check pitch available between left and right Leads
                //if ((stcFromBlobsFeatures.intStartY >= stcToBlobsFeatures.intStartY) && (stcFromBlobsFeatures.intStartY <= stcToBlobsFeatures.intEndY) ||
                //    (stcFromBlobsFeatures.intEndY >= stcToBlobsFeatures.intStartY) && (stcFromBlobsFeatures.intEndY <= stcToBlobsFeatures.intEndY) ||
                //    (stcToBlobsFeatures.intStartY >= stcFromBlobsFeatures.intStartY) && (stcToBlobsFeatures.intEndY <= stcFromBlobsFeatures.intEndY) ||
                //    (stcToBlobsFeatures.intEndY >= stcFromBlobsFeatures.intStartY) && (stcToBlobsFeatures.intEndY <= stcFromBlobsFeatures.intEndY))
                //{
                //    blnLeftRightFound = true;
                //}

                // Pitch only available in up down or left right only
                if ((blnLeftRightFound && !blnUpDownFound) || (!blnLeftRightFound && blnUpDownFound))
                {
                    if (blnUpDownFound)
                    {
                        //// Pitch only available if distance gap between Leads > 1 pixel
                        //if ((stcToBlobsFeatures.intStartY - stcFromBlobsFeatures.intEndY) > 1)
                        //{
                        //    intDrawPoint = GetDrawPoint(stcFromBlobsFeatures.intStartX, stcFromBlobsFeatures.intEndX, stcToBlobsFeatures.intStartX, stcToBlobsFeatures.intEndX);
                        //    m_stcPitchGap.intStartPointX = intDrawPoint;
                        //    m_stcPitchGap.intEndPointX = intDrawPoint;
                        //    m_stcPitchGap.intStartPointY = stcFromBlobsFeatures.intEndY;
                        //    m_stcPitchGap.intEndPointY = stcToBlobsFeatures.intStartY;
                        //    //m_stcPitchGap.fGap = stcToBlobsFeatures.intStartY - stcFromBlobsFeatures.intEndY;
                        //    m_stcPitchGap.fPitch = stcToBlobsFeatures.fTipCenterY - stcFromBlobsFeatures.fTipCenterY;
                        //    m_stcPitchGap.intDirection = 180;
                        //    return true;
                        //}
                        //else if ((stcFromBlobsFeatures.intStartY - stcToBlobsFeatures.intEndY) > 1)
                        //{
                        //    intDrawPoint = GetDrawPoint(stcFromBlobsFeatures.intStartX, stcFromBlobsFeatures.intEndX, stcToBlobsFeatures.intStartX, stcToBlobsFeatures.intEndX);
                        //    m_stcPitchGap.intStartPointX = intDrawPoint;
                        //    m_stcPitchGap.intEndPointX = intDrawPoint;
                        //    m_stcPitchGap.intStartPointY = stcFromBlobsFeatures.intStartY;
                        //    m_stcPitchGap.intEndPointY = stcToBlobsFeatures.intEndY;
                        //    //m_stcPitchGap.fGap = stcFromBlobsFeatures.intStartY - stcToBlobsFeatures.intEndY;
                        //    m_stcPitchGap.fPitch = stcFromBlobsFeatures.fTipCenterY - stcToBlobsFeatures.fTipCenterY;
                        //    m_stcPitchGap.intDirection = 0;
                        //    return true;
                        //}
                        //else
                        //{
                        //    return false;
                        //}
                        // Pitch only available if distance gap between Leads > 1 pixel
                        if ((intStartY_To - intEndY_From) > 1)
                        {
                            intDrawPoint = GetDrawPoint(intStartX_From, intEndX_From, intStartX_To, intEndX_To);
                            m_stcPitchGap.intStartPointX = intDrawPoint;
                            m_stcPitchGap.intEndPointX = intDrawPoint;
                            m_stcPitchGap.intStartPointY = intEndY_From;
                            m_stcPitchGap.intEndPointY = intStartY_To;
                            m_stcPitchGap.fGap = intStartY_To - intEndY_From;
                            m_stcPitchGap.fPitch = stcToBlobsFeatures.fTipCenterY - stcFromBlobsFeatures.fTipCenterY;
                            m_stcPitchGap.intDirection = 180;
                            return true;
                        }
                        else if ((intStartY_From - intEndY_To) > 1)
                        {
                            intDrawPoint = GetDrawPoint(intStartX_From, intEndX_From, intStartX_To, intEndX_To);
                            m_stcPitchGap.intStartPointX = intDrawPoint;
                            m_stcPitchGap.intEndPointX = intDrawPoint;
                            m_stcPitchGap.intStartPointY = intStartY_From;
                            m_stcPitchGap.intEndPointY = intEndY_To;
                            m_stcPitchGap.fGap = intStartY_From - intEndY_To;
                            m_stcPitchGap.fPitch = stcFromBlobsFeatures.fTipCenterY - stcToBlobsFeatures.fTipCenterY;
                            m_stcPitchGap.intDirection = 0;
                            return true;
                        }
                        else
                        {
                            return false;
                        }
                    }
                    else
                    {
                        //// Pitch only available if distance gap between Leads > 1 pixel
                        //if ((stcToBlobsFeatures.intStartX - stcFromBlobsFeatures.intEndX) > 1)
                        //{
                        //    intDrawPoint = GetDrawPoint(stcFromBlobsFeatures.intStartY, stcFromBlobsFeatures.intEndY, stcToBlobsFeatures.intStartY, stcToBlobsFeatures.intEndY);
                        //    m_stcPitchGap.intStartPointX = stcFromBlobsFeatures.intEndX;
                        //    m_stcPitchGap.intEndPointX = stcToBlobsFeatures.intStartX;
                        //    m_stcPitchGap.intStartPointY = intDrawPoint;
                        //    m_stcPitchGap.intEndPointY = intDrawPoint;
                        //    //m_stcPitchGap.fGap = stcToBlobsFeatures.intStartX - stcFromBlobsFeatures.intEndX;
                        //    m_stcPitchGap.fPitch = stcToBlobsFeatures.fTipCenterX - stcFromBlobsFeatures.fTipCenterX;
                        //    m_stcPitchGap.intDirection = 90;
                        //    return true;
                        //}
                        //else if ((stcFromBlobsFeatures.intStartX - stcToBlobsFeatures.intEndX) > 1)
                        //{
                        //    intDrawPoint = GetDrawPoint(stcFromBlobsFeatures.intStartY, stcFromBlobsFeatures.intEndY, stcToBlobsFeatures.intStartY, stcToBlobsFeatures.intEndY);
                        //    m_stcPitchGap.intStartPointX = stcFromBlobsFeatures.intStartX;
                        //    m_stcPitchGap.intEndPointX = stcToBlobsFeatures.intEndX;
                        //    m_stcPitchGap.intStartPointY = intDrawPoint;
                        //    m_stcPitchGap.intEndPointY = intDrawPoint;
                        //    //m_stcPitchGap.fGap = stcFromBlobsFeatures.intStartX - stcToBlobsFeatures.intEndX;
                        //    m_stcPitchGap.fPitch = stcFromBlobsFeatures.fTipCenterX - stcToBlobsFeatures.fTipCenterX;
                        //    m_stcPitchGap.intDirection = 270;
                        //    return true;
                        //}
                        //else
                        //{
                        //    return false;
                        //}
                        // Pitch only available if distance gap between Leads > 1 pixel
                        if ((intStartX_To - intEndX_From) > 1)
                        {
                            intDrawPoint = GetDrawPoint(intStartY_From, intEndY_From, intStartY_To, intEndY_To);
                            m_stcPitchGap.intStartPointX = intEndX_From;
                            m_stcPitchGap.intEndPointX = intStartX_To;
                            m_stcPitchGap.intStartPointY = intDrawPoint;
                            m_stcPitchGap.intEndPointY = intDrawPoint;
                            m_stcPitchGap.fGap = intStartX_To - intEndX_From;
                            m_stcPitchGap.fPitch = stcToBlobsFeatures.fTipCenterX - stcFromBlobsFeatures.fTipCenterX;
                            m_stcPitchGap.intDirection = 90;
                            return true;
                        }
                        else if ((intStartX_From - intEndX_To) > 1)
                        {
                            intDrawPoint = GetDrawPoint(intStartY_From, intEndY_From, intStartY_To, intEndY_To);
                            m_stcPitchGap.intStartPointX = intStartX_From;
                            m_stcPitchGap.intEndPointX = intEndX_To;
                            m_stcPitchGap.intStartPointY = intDrawPoint;
                            m_stcPitchGap.intEndPointY = intDrawPoint;
                            m_stcPitchGap.fGap = intStartX_From - intEndX_To;
                            m_stcPitchGap.fPitch = stcFromBlobsFeatures.fTipCenterX - stcToBlobsFeatures.fTipCenterX;
                            m_stcPitchGap.intDirection = 270;
                            return true;
                        }
                        else
                        {
                            return false;
                        }
                    }
                }
                else
                    return false;
            }
            return true;
        }

        private void CheckPitchGap(ROI objROI)
        {
            #region ---- Check Pitch and Gap ----
            if ((m_intFailOptionMask & 0x400) > 0 || (m_intFailOptionMask & 0x200) > 0)
            {
                for (int i = 0; i < m_arrPitchGap.Count; i++)
                {
                    int intFrom = m_arrPitchGap[i].intFromLeadNo;
                    int intTo = m_arrPitchGap[i].intToLeadNo;
                    float fPitch, fDiffX, fDiffY, fPitchMM, fGap, fGapMM;
                    fPitch = fDiffX = fDiffY = fPitchMM = fGap = fGapMM = 0.0f;

                    //if is valid, broken, hole blob
                    if (((m_arrSampleBlobLeads[intFrom].intFailMask & 0x02) == 0) && ((m_arrSampleBlobLeads[intFrom].intFailMask & 0x04) == 0))
                    {
                        if (((m_arrSampleBlobLeads[intTo].intFailMask & 0x02) == 0) && ((m_arrSampleBlobLeads[intTo].intFailMask & 0x04) == 0))
                        {
                            bool blnResult = true;
                            //Check Pitch Lead
                            //fDiffX = Math.Abs(m_arrSampleBlobLeads[intFrom].fCenterX - m_arrSampleBlobLeads[intTo].fCenterX);
                            //fDiffY = Math.Abs(m_arrSampleBlobLeads[intFrom].fCenterY - m_arrSampleBlobLeads[intTo].fCenterY);

                            //if (fDiffX > fDiffY)
                            //    fPitch = fDiffX;
                            //else
                            //    fPitch = fDiffY;

                            m_stcPitchGap = m_arrPitchGap[i];
                            if (m_stcPitchGap.intDirection == 0 || m_stcPitchGap.intDirection == 180)
                            {

                                fPitch = Math.Abs(m_arrSampleBlobLeads[intFrom].fTipCenterY - m_arrSampleBlobLeads[intTo].fTipCenterY);
                                fPitchMM = fPitch / m_fMMToPixelYValue + ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fPitchOffset;
                            }
                            else
                            {
                                fPitch = Math.Abs(m_arrSampleBlobLeads[intFrom].fTipCenterX - m_arrSampleBlobLeads[intTo].fTipCenterX);
                                fPitchMM = fPitch / m_fMMToPixelXValue + ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fPitchOffset;
                            }

                            bool blnPitchResult;
                            if (m_blnWantTightSetting)
                            {
                                if ((fPitchMM < (m_arrPitchGap[i].fMinPitch + m_fTightSettingTolerance)) || (fPitchMM > (m_arrPitchGap[i].fMaxPitch - m_fTightSettingTolerance)))
                                    blnPitchResult = false;
                                else
                                    blnPitchResult = true;
                            }
                            else
                            {
                                if ((fPitchMM < m_arrPitchGap[i].fMinPitch) || (fPitchMM > m_arrPitchGap[i].fMaxPitch))
                                    blnPitchResult = false;
                                else
                                    blnPitchResult = true;
                            }

                            // Check is pitch fail
                            if (!blnPitchResult)
                            {
                                PitchGap objPitchGap = new PitchGap();
                                objPitchGap.intFromLeadNo = intFrom;
                                objPitchGap.intToLeadNo = intTo;
                                if (m_arrPitchGap[i].intStartPointX == m_arrPitchGap[i].intEndPointX)
                                {
                                    //objPitchGap.intStartPointX = objROI.ref_ROITotalX + m_arrPitchGap[i].intStartPointX;
                                    //objPitchGap.intStartPointY = objROI.ref_ROITotalY + (int)Math.Round(m_arrSampleBlobLeads[intFrom].fCenterY, 0, MidpointRounding.AwayFromZero);
                                    //objPitchGap.intEndPointX = objROI.ref_ROITotalX + m_arrPitchGap[i].intStartPointX;
                                    //objPitchGap.intEndPointY = objROI.ref_ROITotalY + (int)Math.Round(m_arrSampleBlobLeads[intTo].fCenterY, 0, MidpointRounding.AwayFromZero);
                                    objPitchGap.intStartPointX = objROI.ref_ROITotalX + m_arrPitchGap[i].intStartPointX;
                                    objPitchGap.intStartPointY = objROI.ref_ROITotalY + (int)Math.Round(m_arrSampleBlobLeads[intFrom].fTipCenterY, 0, MidpointRounding.AwayFromZero);
                                    objPitchGap.intEndPointX = objROI.ref_ROITotalX + m_arrPitchGap[i].intStartPointX;
                                    objPitchGap.intEndPointY = objROI.ref_ROITotalY + (int)Math.Round(m_arrSampleBlobLeads[intTo].fTipCenterY, 0, MidpointRounding.AwayFromZero);
                                }
                                else
                                {
                                    //objPitchGap.intStartPointX = objROI.ref_ROITotalX + (int)Math.Round(m_arrSampleBlobLeads[intFrom].fCenterX, 0, MidpointRounding.AwayFromZero);
                                    //objPitchGap.intStartPointY = objROI.ref_ROITotalY + m_arrPitchGap[i].intStartPointY;
                                    //objPitchGap.intEndPointX = objROI.ref_ROITotalX + (int)Math.Round(m_arrSampleBlobLeads[intTo].fCenterX, 0, MidpointRounding.AwayFromZero);
                                    //objPitchGap.intEndPointY = objROI.ref_ROITotalY + m_arrPitchGap[i].intStartPointY;
                                    objPitchGap.intStartPointX = objROI.ref_ROITotalX + (int)Math.Round(m_arrSampleBlobLeads[intFrom].fTipCenterX, 0, MidpointRounding.AwayFromZero);
                                    objPitchGap.intStartPointY = objROI.ref_ROITotalY + m_arrPitchGap[i].intStartPointY;
                                    objPitchGap.intEndPointX = objROI.ref_ROITotalX + (int)Math.Round(m_arrSampleBlobLeads[intTo].fTipCenterX, 0, MidpointRounding.AwayFromZero);
                                    objPitchGap.intEndPointY = objROI.ref_ROITotalY + m_arrPitchGap[i].intStartPointY;

                                }
                                m_arrFailPitchGapList.Add(objPitchGap);     // Add Pitch location
                                //m_arrSampleBlobLeads[intFrom].intFailMask |= 0x400;
                                m_stcPitchGap.intFailMask = 0x200;
                                m_intFailResultMask |= 0x200;

                                blnResult = false;
                            }

                            // record the inspection result
                            m_stcPitchGap.fPitchMM = fPitchMM; //m_stcPitchGap.fPitchMM = fPitchMM + ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fPitchOffset;
                            m_arrPitchGap.RemoveAt(i);
                            m_arrPitchGap.Insert(i, m_stcPitchGap);
                            m_arrSampleBlobLeads[intFrom].fPitch = fPitch;

                            //Check Gap
                            float fCenterX_From = 0, fCenterY_From = 0, fWidth_From = 0, fHeight_From = 0;
                            float fCenterX_To = 0, fCenterY_To = 0, fWidth_To = 0, fHeight_To = 0;

                            switch (m_intLeadROIDirection)
                            {
                                case 1: // Top
                                    fCenterX_From = m_arrSampleBlobLeads[intFrom].fTipCenterX;
                                    fCenterY_From = m_arrSampleBlobLeads[intFrom].fTipCenterY + m_arrSampleBlobLeads[intFrom].fTipHeight / 2;
                                    fWidth_From = m_arrSampleBlobLeads[intFrom].fTipWidth;
                                    fHeight_From = m_arrSampleBlobLeads[intFrom].fTipHeight;
                                    break;
                                case 2: // Right
                                    fCenterX_From = m_arrSampleBlobLeads[intFrom].fTipCenterX - m_arrSampleBlobLeads[intFrom].fTipHeight / 2;
                                    fCenterY_From = m_arrSampleBlobLeads[intFrom].fTipCenterY;
                                    fWidth_From = m_arrSampleBlobLeads[intFrom].fTipHeight;
                                    fHeight_From = m_arrSampleBlobLeads[intFrom].fTipWidth;
                                    break;
                                case 3: // Bottom
                                    fCenterX_From = m_arrSampleBlobLeads[intFrom].fTipCenterX;
                                    fCenterY_From = m_arrSampleBlobLeads[intFrom].fTipCenterY - m_arrSampleBlobLeads[intFrom].fTipHeight / 2;
                                    fWidth_From = m_arrSampleBlobLeads[intFrom].fTipWidth;
                                    fHeight_From = m_arrSampleBlobLeads[intFrom].fTipHeight;
                                    break;
                                case 4: // Left
                                    fCenterX_From = m_arrSampleBlobLeads[intFrom].fTipCenterX + m_arrSampleBlobLeads[intFrom].fTipHeight / 2;
                                    fCenterY_From = m_arrSampleBlobLeads[intFrom].fTipCenterY;
                                    fWidth_From = m_arrSampleBlobLeads[intFrom].fTipHeight;
                                    fHeight_From = m_arrSampleBlobLeads[intFrom].fTipWidth;
                                    break;
                            }

                            switch (m_intLeadROIDirection)
                            {
                                case 1: // Top
                                    fCenterX_To = m_arrSampleBlobLeads[intTo].fTipCenterX;
                                    fCenterY_To = m_arrSampleBlobLeads[intTo].fTipCenterY + m_arrSampleBlobLeads[intTo].fTipHeight / 2;
                                    fWidth_To = m_arrSampleBlobLeads[intTo].fTipWidth;
                                    fHeight_To = m_arrSampleBlobLeads[intTo].fTipHeight;
                                    break;
                                case 2: // Right
                                    fCenterX_To = m_arrSampleBlobLeads[intTo].fTipCenterX - m_arrSampleBlobLeads[intTo].fTipHeight / 2;
                                    fCenterY_To = m_arrSampleBlobLeads[intTo].fTipCenterY;
                                    fWidth_To = m_arrSampleBlobLeads[intTo].fTipHeight;
                                    fHeight_To = m_arrSampleBlobLeads[intTo].fTipWidth;
                                    break;
                                case 3: // Bottom
                                    fCenterX_To = m_arrSampleBlobLeads[intTo].fTipCenterX;
                                    fCenterY_To = m_arrSampleBlobLeads[intTo].fTipCenterY - m_arrSampleBlobLeads[intTo].fTipHeight / 2;
                                    fWidth_To = m_arrSampleBlobLeads[intTo].fTipWidth;
                                    fHeight_To = m_arrSampleBlobLeads[intTo].fTipHeight;
                                    break;
                                case 4: // Left
                                    fCenterX_To = m_arrSampleBlobLeads[intTo].fTipCenterX + m_arrSampleBlobLeads[intTo].fTipHeight / 2;
                                    fCenterY_To = m_arrSampleBlobLeads[intTo].fTipCenterY;
                                    fWidth_To = m_arrSampleBlobLeads[intTo].fTipHeight;
                                    fHeight_To = m_arrSampleBlobLeads[intTo].fTipWidth;
                                    break;
                            }

                            if (fCenterX_To > fCenterX_From)
                            {
                                fDiffX = (fCenterX_To - (fWidth_To / 2)) -
                                (fCenterX_From + (fWidth_From / 2));
                            }
                            else
                            {
                                fDiffX = (fCenterX_From - (fWidth_From / 2)) -
                                 (fCenterX_To + (fWidth_To / 2));
                            }

                            if (fCenterY_To > fCenterY_From)
                            {
                                fDiffY = (fCenterY_To - (fHeight_To / 2)) -
                                (fCenterY_From + (fHeight_From / 2));
                            }
                            else
                            {
                                fDiffY = (fCenterY_From - (fHeight_From / 2)) -
                                 (fCenterY_To + (fHeight_To / 2));
                            }

                            float fFromSize, fToSize;
                            if (fDiffX > fDiffY)
                            {
                                fGap = fDiffX;
                                //// 05-07-2019 ZJYEOH : Include offset in Gap
                                //if (m_blnWantUseGroupToleranceSetting)
                                //    fGap += ((BlobsFeatures)m_arrGroupTemplateBlobPads[((BlobsFeatures)m_arrTemplateBlobPads[intFrom]).intGroupID]).fGapOffset * m_fMMToPixelXValue;
                                //else
                                //    fGap += ((BlobsFeatures)m_arrTemplateBlobPads[intFrom]).fGapOffset * m_fMMToPixelXValue;
                                fFromSize = fWidth_From / 2;
                                fToSize = fWidth_To / 2;
                            }
                            else
                            {
                                fGap = fDiffY;
                                //// 05-07-2019 ZJYEOH : Include offset in Gap
                                //if (m_blnWantUseGroupToleranceSetting)
                                //    fGap += ((BlobsFeatures)m_arrGroupTemplateBlobPads[((BlobsFeatures)m_arrTemplateBlobPads[intFrom]).intGroupID]).fGapOffset * m_fMMToPixelYValue;
                                //else
                                //    fGap += ((BlobsFeatures)m_arrTemplateBlobPads[intFrom]).fGapOffset * m_fMMToPixelYValue;
                                fFromSize = fHeight_From / 2;
                                fToSize = fHeight_To / 2;
                            }

                            m_stcPitchGap = m_arrPitchGap[i];
                            if (m_stcPitchGap.intDirection == 0 || m_stcPitchGap.intDirection == 180)
                                fGapMM = fGap / m_fMMToPixelYValue + ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fGapOffset;
                            else
                                fGapMM = fGap / m_fMMToPixelXValue + ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fGapOffset;

                            bool blnGapResult;
                            //if (m_blnWantUseGroupToleranceSetting)
                            //{
                            //    int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[intFrom]).intGroupID;
                            //    if (m_blnWantTightSetting)
                            //    {
                            //        if ((fGapMM < (((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMinGap + m_fTightSettingTolerance)) || (fGapMM > (((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxGap - m_fTightSettingTolerance)))
                            //            blnGapResult = true;
                            //        else
                            //            blnGapResult = false;
                            //    }
                            //    else
                            //    {
                            //        if ((fGapMM < ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMinGap) || (fGapMM > ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxGap))
                            //            blnGapResult = true;
                            //        else
                            //            blnGapResult = false;
                            //    }
                            //}
                            //else
                            //{
                            if (m_blnWantTightSetting)
                            {
                                if ((fGapMM < (m_arrPitchGap[i].fMinGap + m_fTightSettingTolerance)) || (fGapMM > (m_arrPitchGap[i].fMaxGap - m_fTightSettingTolerance)))
                                    blnGapResult = true;
                                else
                                    blnGapResult = false;
                            }
                            else
                            {
                                if ((fGapMM < m_arrPitchGap[i].fMinGap) || (fGapMM > m_arrPitchGap[i].fMaxGap))
                                    blnGapResult = true;
                                else
                                    blnGapResult = false;
                            }
                            //}

                            if (blnGapResult)
                            {
                                m_intFailResultMask |= 0x400;
                                m_arrSampleBlobLeads[intFrom].fGap = fGap;
                                //m_arrSampleBlobPads[intFrom].intFailMask |= 0x200;
                                m_stcPitchGap.intFailMask |= 0x400;

                                BlobsFeatures stcTemplateBlobFrom = (BlobsFeatures)m_arrTemplateBlobLeads[intFrom];
                                BlobsFeatures stcTemplateBlobTo = (BlobsFeatures)m_arrTemplateBlobLeads[intTo];

                                if (blnResult)
                                {
                                    PitchGap objPitchGap = new PitchGap();
                                    objPitchGap.intFromLeadNo = intFrom;
                                    objPitchGap.intToLeadNo = intTo;
                                    if (m_arrPitchGap[i].intStartPointX == m_arrPitchGap[i].intEndPointX)
                                    {
                                        if (fCenterY_From > fCenterY_To)
                                        {
                                            //objPitchGap.intStartPointX = objROI.ref_ROITotalX + m_arrPitchGap[i].intStartPointX;
                                            //objPitchGap.intStartPointY = objROI.ref_ROITotalY + (int)Math.Round(m_arrSampleBlobLeads[intFrom].fTipCenterY - fFromSize, 0, MidpointRounding.AwayFromZero);
                                            //objPitchGap.intEndPointX = objROI.ref_ROITotalX + m_arrPitchGap[i].intStartPointX;
                                            //objPitchGap.intEndPointY = objROI.ref_ROITotalY + (int)Math.Round(m_arrSampleBlobLeads[intTo].fTipCenterY + fToSize, 0, MidpointRounding.AwayFromZero);
                                            if (m_intLeadROIDirection == 2)
                                                objPitchGap.intStartPointX = objROI.ref_ROITotalX + (int)Math.Round(m_arrSampleBlobLeads[intFrom].fTipCenterX - stcTemplateBlobFrom.intTipInwardOffset, 0, MidpointRounding.AwayFromZero);
                                            else if (m_intLeadROIDirection == 4)
                                                objPitchGap.intStartPointX = objROI.ref_ROITotalX + (int)Math.Round(m_arrSampleBlobLeads[intFrom].fTipCenterX + stcTemplateBlobFrom.intTipInwardOffset, 0, MidpointRounding.AwayFromZero);

                                            objPitchGap.intStartPointY = objROI.ref_ROITotalY + (int)Math.Round(m_arrSampleBlobLeads[intFrom].fTipCenterY - fFromSize, 0, MidpointRounding.AwayFromZero);

                                            if (m_intLeadROIDirection == 2)
                                                objPitchGap.intEndPointX = objROI.ref_ROITotalX + (int)Math.Round(m_arrSampleBlobLeads[intTo].fTipCenterX - stcTemplateBlobTo.intTipInwardOffset, 0, MidpointRounding.AwayFromZero);
                                            else if (m_intLeadROIDirection == 4)
                                                objPitchGap.intEndPointX = objROI.ref_ROITotalX + (int)Math.Round(m_arrSampleBlobLeads[intTo].fTipCenterX + stcTemplateBlobTo.intTipInwardOffset, 0, MidpointRounding.AwayFromZero);

                                            objPitchGap.intEndPointY = objROI.ref_ROITotalY + (int)Math.Round(m_arrSampleBlobLeads[intTo].fTipCenterY + fToSize, 0, MidpointRounding.AwayFromZero);
                                        }
                                        else
                                        {
                                            //objPitchGap.intStartPointX = objROI.ref_ROITotalX + m_arrPitchGap[i].intStartPointX;
                                            //objPitchGap.intStartPointY = objROI.ref_ROITotalY + (int)Math.Round(m_arrSampleBlobLeads[intFrom].fTipCenterY + fFromSize, 0, MidpointRounding.AwayFromZero);
                                            //objPitchGap.intEndPointX = objROI.ref_ROITotalX + m_arrPitchGap[i].intStartPointX;
                                            //objPitchGap.intEndPointY = objROI.ref_ROITotalY + (int)Math.Round(m_arrSampleBlobLeads[intTo].fTipCenterY - fToSize, 0, MidpointRounding.AwayFromZero);
                                            if (m_intLeadROIDirection == 2)
                                                objPitchGap.intStartPointX = objROI.ref_ROITotalX + (int)Math.Round(m_arrSampleBlobLeads[intFrom].fTipCenterX - stcTemplateBlobFrom.intTipInwardOffset, 0, MidpointRounding.AwayFromZero);
                                            else if (m_intLeadROIDirection == 4)
                                                objPitchGap.intStartPointX = objROI.ref_ROITotalX + (int)Math.Round(m_arrSampleBlobLeads[intFrom].fTipCenterX + stcTemplateBlobFrom.intTipInwardOffset, 0, MidpointRounding.AwayFromZero);

                                            objPitchGap.intStartPointY = objROI.ref_ROITotalY + (int)Math.Round(m_arrSampleBlobLeads[intFrom].fTipCenterY + fFromSize, 0, MidpointRounding.AwayFromZero);

                                            if (m_intLeadROIDirection == 2)
                                                objPitchGap.intEndPointX = objROI.ref_ROITotalX + (int)Math.Round(m_arrSampleBlobLeads[intTo].fTipCenterX - stcTemplateBlobTo.intTipInwardOffset, 0, MidpointRounding.AwayFromZero);
                                            else if (m_intLeadROIDirection == 4)
                                                objPitchGap.intEndPointX = objROI.ref_ROITotalX + (int)Math.Round(m_arrSampleBlobLeads[intTo].fTipCenterX + stcTemplateBlobTo.intTipInwardOffset, 0, MidpointRounding.AwayFromZero);

                                            objPitchGap.intEndPointY = objROI.ref_ROITotalY + (int)Math.Round(m_arrSampleBlobLeads[intTo].fTipCenterY - fToSize, 0, MidpointRounding.AwayFromZero);
                                        }
                                    }
                                    else
                                    {
                                        if (fCenterX_From > fCenterX_To)
                                        {
                                            //objPitchGap.intStartPointX = objROI.ref_ROITotalX + (int)Math.Round(m_arrSampleBlobLeads[intFrom].fTipCenterX - fFromSize, 0, MidpointRounding.AwayFromZero);
                                            //objPitchGap.intStartPointY = objROI.ref_ROITotalY + m_arrPitchGap[i].intStartPointY;
                                            //objPitchGap.intEndPointX = objROI.ref_ROITotalX + (int)Math.Round(m_arrSampleBlobLeads[intTo].fTipCenterX + fToSize, 0, MidpointRounding.AwayFromZero);
                                            //objPitchGap.intEndPointY = objROI.ref_ROITotalY + m_arrPitchGap[i].intStartPointY;
                                            objPitchGap.intStartPointX = objROI.ref_ROITotalX + (int)Math.Round(m_arrSampleBlobLeads[intFrom].fTipCenterX - fFromSize, 0, MidpointRounding.AwayFromZero);

                                            if (m_intLeadROIDirection == 1)
                                                objPitchGap.intStartPointY = objROI.ref_ROITotalY + (int)Math.Round(m_arrSampleBlobLeads[intFrom].fTipCenterY + stcTemplateBlobFrom.intTipInwardOffset, 0, MidpointRounding.AwayFromZero);
                                            else if (m_intLeadROIDirection == 3)
                                                objPitchGap.intStartPointY = objROI.ref_ROITotalY + (int)Math.Round(m_arrSampleBlobLeads[intFrom].fTipCenterY - stcTemplateBlobFrom.intTipInwardOffset, 0, MidpointRounding.AwayFromZero);

                                            objPitchGap.intEndPointX = objROI.ref_ROITotalX + (int)Math.Round(m_arrSampleBlobLeads[intTo].fTipCenterX + fToSize, 0, MidpointRounding.AwayFromZero);

                                            if (m_intLeadROIDirection == 1)
                                                objPitchGap.intEndPointY = objROI.ref_ROITotalY + (int)Math.Round(m_arrSampleBlobLeads[intTo].fTipCenterY + stcTemplateBlobTo.intTipInwardOffset, 0, MidpointRounding.AwayFromZero);
                                            else if (m_intLeadROIDirection == 3)
                                                objPitchGap.intEndPointY = objROI.ref_ROITotalY + (int)Math.Round(m_arrSampleBlobLeads[intTo].fTipCenterY - stcTemplateBlobTo.intTipInwardOffset, 0, MidpointRounding.AwayFromZero);
                                        }
                                        else
                                        {
                                            //objPitchGap.intStartPointX = objROI.ref_ROITotalX + (int)Math.Round(m_arrSampleBlobLeads[intFrom].fTipCenterX + fFromSize, 0, MidpointRounding.AwayFromZero);
                                            //objPitchGap.intStartPointY = objROI.ref_ROITotalY + m_arrPitchGap[i].intStartPointY;
                                            //objPitchGap.intEndPointX = objROI.ref_ROITotalX + (int)Math.Round(m_arrSampleBlobLeads[intTo].fTipCenterX - fToSize, 0, MidpointRounding.AwayFromZero);
                                            //objPitchGap.intEndPointY = objROI.ref_ROITotalY + m_arrPitchGap[i].intStartPointY;
                                            objPitchGap.intStartPointX = objROI.ref_ROITotalX + (int)Math.Round(m_arrSampleBlobLeads[intFrom].fTipCenterX + fFromSize, 0, MidpointRounding.AwayFromZero);

                                            if (m_intLeadROIDirection == 1)
                                                objPitchGap.intStartPointY = objROI.ref_ROITotalY + (int)Math.Round(m_arrSampleBlobLeads[intFrom].fTipCenterY + stcTemplateBlobFrom.intTipInwardOffset, 0, MidpointRounding.AwayFromZero);
                                            else if (m_intLeadROIDirection == 3)
                                                objPitchGap.intStartPointY = objROI.ref_ROITotalY + (int)Math.Round(m_arrSampleBlobLeads[intFrom].fTipCenterY - stcTemplateBlobFrom.intTipInwardOffset, 0, MidpointRounding.AwayFromZero);

                                            objPitchGap.intEndPointX = objROI.ref_ROITotalX + (int)Math.Round(m_arrSampleBlobLeads[intTo].fTipCenterX - fToSize, 0, MidpointRounding.AwayFromZero);

                                            if (m_intLeadROIDirection == 1)
                                                objPitchGap.intEndPointY = objROI.ref_ROITotalY + (int)Math.Round(m_arrSampleBlobLeads[intTo].fTipCenterY + stcTemplateBlobTo.intTipInwardOffset, 0, MidpointRounding.AwayFromZero);
                                            else if (m_intLeadROIDirection == 3)
                                                objPitchGap.intEndPointY = objROI.ref_ROITotalY + (int)Math.Round(m_arrSampleBlobLeads[intTo].fTipCenterY - stcTemplateBlobTo.intTipInwardOffset, 0, MidpointRounding.AwayFromZero);
                                        }
                                    }
                                    m_arrFailPitchGapList.Add(objPitchGap); // Add gap location
                                }
                            }

                            m_stcPitchGap.fGapMM = fGapMM; //m_stcPitchGap.fGapMM = fGapMM + ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fGapOffset;
                            m_arrPitchGap.RemoveAt(i);
                            m_arrPitchGap.Insert(i, m_stcPitchGap);
                            m_arrSampleBlobLeads[intFrom].fGap = fGap;
                        }
                    }
                }
            }
            #endregion

        }

        /// <summary>
        /// Check whether sample objects fall in don't care area
        /// </summary>
        /// <param name="fCenterX">object gravity center X</param>
        /// <param name="fCenterY">object gravity center Y</param>
        /// <param name="arrDontCare">don't care area points</param>
        /// <returns>true = fall in don't care area, false = fall in don't care area</returns>
        private bool IsInDontCareArea(float fCenterX, float fCenterY, List<List<PointF>> arrDontCare)
        {
            //Check is in Don't Care area or not
            for (int j = 0; j < arrDontCare.Count; j++)
            {
                if ((fCenterX >= arrDontCare[j][0].X) && (fCenterX <= arrDontCare[j][1].X) &&
                    (fCenterY >= arrDontCare[j][0].Y) && (fCenterY <= arrDontCare[j][1].Y))
                {
                    return true;
                }
            }

            return false;
        }
        private void LeadTestStage1_BaseLead(ROI objROI, List<List<PointF>> arrDontCare)
        {
            float fUnitAreaWidth = objROI.ref_ROIWidth;
            float fUnitAreaHeight = objROI.ref_ROIHeight;
            float fUnitAreaStartX = (float)Math.Round(objROI.ref_ROITotalCenterX - fUnitAreaWidth / 2, MidpointRounding.AwayFromZero) - objROI.ref_ROITotalX;// * m_fMMToPixelXValue;
            float fUnitAreaStartY = (float)Math.Round(objROI.ref_ROITotalCenterY - fUnitAreaHeight / 2, MidpointRounding.AwayFromZero) - objROI.ref_ROITotalY;// * m_fMMToPixelYValue;
            float fUnitAreaEndX = (float)Math.Round(objROI.ref_ROITotalCenterX + fUnitAreaWidth / 2, MidpointRounding.AwayFromZero) - objROI.ref_ROITotalX;// * m_fMMToPixelXValue;
            float fUnitAreaEndY = (float)Math.Round(objROI.ref_ROITotalCenterY + fUnitAreaHeight / 2, MidpointRounding.AwayFromZero) - objROI.ref_ROITotalY;// * m_fMMToPixelYValue;
            //float fUnitAreaStartX = objROI.ref_ROIPositionX;
            //float fUnitAreaStartY = objROI.ref_ROIPositionY;
            //float fUnitAreaEndX = objROI.ref_ROIPositionX + fUnitAreaWidth;
            //float fUnitAreaEndY = objROI.ref_ROIPositionY + fUnitAreaHeight;
            // Testing Type:
            // 1. Match Blobs Object to Template Lead
            // 2. Find reference point of lead
            float fTotalExtraArea = 0;
            float fLimitCenterX = 0;
            float fLimitCenterY = 0;
            float fWidth = 0;
            float fHeight = 0;
            float fOrgX = 0;
            float fOrgY = 0;
            int intTotalSelectedBlobCount = 0;
            int intArea = 0;
            float fGravityCenterX = 0;
            float fGravityCenterY = 0;
            float fStartX = 0;
            float fStartY = 0;
            float fEndX = 0;
            float fEndY = 0;
            float fBaseCenterX = 0;
            float fBaseCenterY = 0;
            float fBaseWidth = 0;
            float fBaseHeight = 0;
            float fTipCenterX = 0;
            float fTipCenterY = 0;
            float fTipWidth = 0;
            float fTipHeight = 0;
            float fNewCenterX = 0;
            float fNewCenterY = 0;
            int intFixPointXY = 0;
            List<int> arrSkipNo = new List<int>();
            bool blnSkipToNextObject = false;

            int intSelectedObjectNum = 0;
            //if (m_objEBlobs.ref_intNumSelectedObject >= m_intNumberOfLead)
            //    intSelectedObjectNum = m_intNumberOfLead;
            //else
            intSelectedObjectNum = m_objEBlobs_BaseLead.ref_intNumSelectedObject;

            for (int i = 0; i < intSelectedObjectNum; i++)
            {
                for (int k = 0; k < arrSkipNo.Count; k++)
                {
                    if (i == arrSkipNo[k])
                    {
                        blnSkipToNextObject = true;
                        break;
                    }
                }

                if (blnSkipToNextObject)
                {
                    // This segment is to handle the case when the largest blob builded is from the same lead
                    // Since the number of lead is predefined, each blob data collected must be from different lead
                    if (m_objEBlobs_BaseLead.ref_intNumSelectedObject > intSelectedObjectNum)

                        intSelectedObjectNum++;
                    blnSkipToNextObject = false;
                    continue;
                }

                fLimitCenterX = m_objEBlobs_BaseLead.ref_arrLimitCenterX[i];
                fLimitCenterY = m_objEBlobs_BaseLead.ref_arrLimitCenterY[i];
                fWidth = m_objEBlobs_BaseLead.ref_arrWidth[i];
                fHeight = m_objEBlobs_BaseLead.ref_arrHeight[i];
                fOrgX = fLimitCenterX - fWidth / 2;
                fOrgY = fLimitCenterY - fHeight / 2;
                intArea = m_objEBlobs_BaseLead.ref_arrArea[i];
                fGravityCenterX = m_objEBlobs_BaseLead.ref_arrGravityCenterX[i];
                fGravityCenterY = m_objEBlobs_BaseLead.ref_arrGravityCenterY[i];
                fStartX = fOrgX;
                fStartY = fOrgY;
                fEndX = fOrgX + fWidth;
                fEndY = fOrgY + fHeight;
                intTotalSelectedBlobCount = 0;

                //for (int j = i; j < m_objEBlobs_BaseLead.ref_intNumSelectedObject; j++)
                //{
                //    if (m_intLeadROIDirection == 2 || m_intLeadROIDirection == 4) //m_intLeadDirection == 0
                //    {
                //        //Horizontal lead
                //        if (m_objEBlobs_BaseLead.ref_arrLimitCenterY[j] < fOrgY || m_objEBlobs_BaseLead.ref_arrLimitCenterY[j] > (fOrgY + fHeight))
                //            continue;
                //    }
                //    else if (m_intLeadROIDirection == 1 || m_intLeadROIDirection == 3) //else
                //    {
                //        //Vertical lead
                //        if (m_objEBlobs_BaseLead.ref_arrLimitCenterX[j] < fOrgX || m_objEBlobs_BaseLead.ref_arrLimitCenterX[j] > (fOrgX + fWidth))
                //            continue;
                //    }

                //    //Once the blob met the requirement, add the blob into skip array to prevent the same blob added twice
                //    arrSkipNo.Add(j);

                //    intArea += m_objEBlobs_BaseLead.ref_arrArea[j];
                //    fGravityCenterX += m_objEBlobs_BaseLead.ref_arrGravityCenterX[j] * m_objEBlobs_BaseLead.ref_arrArea[j];
                //    fGravityCenterY += m_objEBlobs_BaseLead.ref_arrGravityCenterY[j] * m_objEBlobs_BaseLead.ref_arrArea[j];

                //    if (fStartX > m_objEBlobs_BaseLead.ref_arrLimitCenterX[j] - (m_objEBlobs_BaseLead.ref_arrWidth[j] / 2))
                //    {
                //        fStartX = m_objEBlobs_BaseLead.ref_arrLimitCenterX[j] - (m_objEBlobs_BaseLead.ref_arrWidth[j] / 2);
                //    }

                //    if (fStartY > m_objEBlobs_BaseLead.ref_arrLimitCenterY[j] - (m_objEBlobs_BaseLead.ref_arrHeight[j] / 2))
                //    {
                //        fStartY = m_objEBlobs_BaseLead.ref_arrLimitCenterY[j] - (m_objEBlobs_BaseLead.ref_arrHeight[j] / 2);
                //    }

                //    if (fEndX < m_objEBlobs_BaseLead.ref_arrLimitCenterX[j] + (m_objEBlobs_BaseLead.ref_arrWidth[j] / 2))
                //    {
                //        fEndX = m_objEBlobs_BaseLead.ref_arrLimitCenterX[j] + (m_objEBlobs_BaseLead.ref_arrWidth[j] / 2);
                //    }

                //    if (fEndY < m_objEBlobs_BaseLead.ref_arrLimitCenterY[j] + (m_objEBlobs_BaseLead.ref_arrHeight[j] / 2))
                //    {
                //        fEndY = m_objEBlobs_BaseLead.ref_arrLimitCenterY[j] + (m_objEBlobs_BaseLead.ref_arrHeight[j] / 2);
                //    }

                //    intTotalSelectedBlobCount++;
                //}

                //fGravityCenterX = fGravityCenterX / intArea;
                //fGravityCenterY = fGravityCenterY / intArea;
                //fWidth = fEndX - fStartX;
                //fHeight = fEndY - fStartY;
                //fLimitCenterX = fStartX + fWidth / 2;
                //fLimitCenterY = fStartY + fHeight / 2;

                if (IsInDontCareArea(fGravityCenterX, fGravityCenterY, arrDontCare))
                {
                    return;
                }

                // Get template number which match with sample
                List<int> arrMatch = MatchTemplateObjects_Inspection_BaseLead(objROI, fStartX, fStartY,
                                                        fEndX, fEndY,
                                                        fWidth, fHeight,
                                                        fBaseWidth, fBaseHeight,
                                                        fTipWidth, fTipHeight,
                                                        fGravityCenterX, fGravityCenterY,
                                                        intArea);
                for (int j = 0; j < arrMatch.Count; j++)
                    m_intTemplateMatchStatus_BaseLead[arrMatch[j]]++;

                if (arrMatch.Count == 0)        // Set to -1 if match nothing with any template leads
                    m_intSampleMatchNumber_BaseLead[i] = -1;
                else if (arrMatch.Count > 1)    // Set to -2 if match more than 1 template leads
                    m_intSampleMatchNumber_BaseLead[i] = -2;
                else
                    m_intSampleMatchNumber_BaseLead[i] = arrMatch[0];

                // No template match with sample
                if (m_intSampleMatchNumber_BaseLead[i] == -1)
                {
                    //Extra
                }
                // More than 1 templates match with sample
                if (m_intSampleMatchNumber_BaseLead[i] == -2)  // Temporary close bridging
                {
                    //Join/Bridge Lead
                }
                //Sample fall in Don't Care ROI area
                else if (m_intSampleMatchNumber_BaseLead[i] == -3)
                {
                    return;
                }
                // Found only 1 templates match with sample
                else if (m_intSampleMatchNumber_BaseLead[i] >= 0)
                {
                    if (m_arrSampleBlobLeads_BaseLead[m_intSampleMatchNumber_BaseLead[i]].fArea == -999)
                    {
                        //Collect ordinary blob data
                        m_arrSampleBlobLeads_BaseLead[m_intSampleMatchNumber_BaseLead[i]].intFailMask |= 0;
                        m_arrSampleBlobLeads_BaseLead[m_intSampleMatchNumber_BaseLead[i]].fStartX = fStartX;
                        m_arrSampleBlobLeads_BaseLead[m_intSampleMatchNumber_BaseLead[i]].fStartY = fStartY;
                        m_arrSampleBlobLeads_BaseLead[m_intSampleMatchNumber_BaseLead[i]].fEndX = fEndX;
                        m_arrSampleBlobLeads_BaseLead[m_intSampleMatchNumber_BaseLead[i]].fEndY = fEndY;


                        m_arrSampleBlobLeads_BaseLead[m_intSampleMatchNumber_BaseLead[i]].fCenterX = fLimitCenterX;
                        m_arrSampleBlobLeads_BaseLead[m_intSampleMatchNumber_BaseLead[i]].fCenterY = fLimitCenterY;
                        //m_arrSampleBlobLeads[m_intSampleMatchNumber[i]].fCenterX = fTipCenterX;
                        //m_arrSampleBlobLeads[m_intSampleMatchNumber[i]].fCenterY = fTipCenterY;

                        m_arrSampleBlobLeads_BaseLead[m_intSampleMatchNumber_BaseLead[i]].fGravityCenterX = fGravityCenterX;
                        m_arrSampleBlobLeads_BaseLead[m_intSampleMatchNumber_BaseLead[i]].fGravityCenterY = fGravityCenterY;


                        m_arrSampleBlobLeads_BaseLead[m_intSampleMatchNumber_BaseLead[i]].fWidth = fWidth;
                        m_arrSampleBlobLeads_BaseLead[m_intSampleMatchNumber_BaseLead[i]].fHeight = fHeight;
                        //m_arrSampleBlobLeads[m_intSampleMatchNumber[i]].fWidth = fTipWidth;
                        //m_arrSampleBlobLeads[m_intSampleMatchNumber[i]].fHeight = fTipHeight;

                        m_arrSampleBlobLeads_BaseLead[m_intSampleMatchNumber_BaseLead[i]].fArea = (float)intArea;
                        m_arrSampleBlobLeads_BaseLead[m_intSampleMatchNumber_BaseLead[i]].intContourIndex = 0;

                        // Collect sample blobs data in MM
                        m_arrSampleBlobLeads_BaseLead[m_intSampleMatchNumber_BaseLead[i]].fWidthMM = fWidth / m_fMMToPixelXValue;
                        m_arrSampleBlobLeads_BaseLead[m_intSampleMatchNumber_BaseLead[i]].fHeightMM = fHeight / m_fMMToPixelYValue;
                        m_arrSampleBlobLeads_BaseLead[m_intSampleMatchNumber_BaseLead[i]].fAreaMM = (float)intArea / m_fMMtoPixelAreaValue;
                        ////2021-04-11 ZJYEOH : Need to use calibration data based on m_intLeadROIDirection
                        //switch (m_intLeadROIDirection)
                        //{
                        //    case 1:
                        //    case 3:
                        //        // Collect sample blobs data in MM
                        //        m_arrSampleBlobLeads_BaseLead[m_intSampleMatchNumber_BaseLead[i]].fWidthMM = fWidth / m_fMMToPixelXValue;
                        //        m_arrSampleBlobLeads_BaseLead[m_intSampleMatchNumber_BaseLead[i]].fHeightMM = fHeight / m_fMMToPixelYValue;
                        //        m_arrSampleBlobLeads_BaseLead[m_intSampleMatchNumber_BaseLead[i]].fAreaMM = (float)intArea / m_fMMtoPixelAreaValue;
                        //        break;
                        //    case 2:
                        //    case 4:
                        //        // Collect sample blobs data in MM
                        //        m_arrSampleBlobLeads_BaseLead[m_intSampleMatchNumber_BaseLead[i]].fWidthMM = fWidth / m_fMMToPixelYValue;
                        //        m_arrSampleBlobLeads_BaseLead[m_intSampleMatchNumber_BaseLead[i]].fHeightMM = fHeight / m_fMMToPixelXValue;
                        //        m_arrSampleBlobLeads_BaseLead[m_intSampleMatchNumber_BaseLead[i]].fAreaMM = (float)intArea / m_fMMtoPixelAreaValue;
                        //        break;
                        //}

                        //m_stcBlobLead = ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[m_intSampleMatchNumber_BaseLead[i]]);
                        //float fMaxTipOffSet = 0;
                        //switch (m_stcBlobLead.intGroupID)
                        //{
                        //    case 1:
                        //    case 3:
                        //        fMaxTipOffSet = Math.Abs(m_stcBlobLead.fXDistance - (objROI.ref_ROITotalX + fLimitCenterX - m_fUnitAverageCenterX)) / m_fMMToPixelXValue;
                        //        break;
                        //    case 2:
                        //    case 4:
                        //        fMaxTipOffSet = Math.Abs(m_stcBlobLead.fYDistance - (objROI.ref_ROITotalY + fLimitCenterY - m_fUnitAverageCenterY)) / m_fMMToPixelYValue;
                        //        break;
                        //}
                        //////////fMaxTipOffSet = Math.Max(Math.Abs(m_stcBlobLead.fXDistance - (objROI.ref_ROITotalX + fLimitCenterX - m_fUnitAverageCenterX)) / m_fMMToPixelXValue,
                        //////////                         Math.Abs(m_stcBlobLead.fYDistance - (objROI.ref_ROITotalY + fLimitCenterY - m_fUnitAverageCenterY)) / m_fMMToPixelYValue);
                        //////////if (fMaxTipOffSet > m_stcBlobLead.fMaxBaseOffset)
                        //////////{
                        //////////    // Base OffSet fail
                        //////////    if ((m_intFailOptionMask & 0x10000) > 0)
                        //////////    {
                        //////////        m_arrSampleBlobLeads_BaseLead[m_intSampleMatchNumber_BaseLead[i]].intFailMask |= 0x10000;
                        //////////        m_intFailResultMask |= 0x10000;
                        //////////    }
                        //////////}
                        //////////m_arrSampleBlobLeads_BaseLead[m_intSampleMatchNumber_BaseLead[i]].fOffSetMM = fMaxTipOffSet;
                        //////////if ((((float)intArea / m_fMMtoPixelAreaValue) < m_stcBlobLead.fMinBaseArea) || (((float)intArea / m_fMMtoPixelAreaValue) > m_stcBlobLead.fMaxBaseArea))
                        //////////{
                        //////////    // Base Area fail
                        //////////    if ((m_intFailOptionMask & 0x20000) > 0)
                        //////////    {
                        //////////        m_arrSampleBlobLeads_BaseLead[m_intSampleMatchNumber_BaseLead[i]].intFailMask |= 0x20000;
                        //////////        m_intFailResultMask |= 0x20000;
                        //////////    }
                        //////////}
                    }
                    else
                    {
                        SampleBlobsFeatures objSampleBlobsFeatures = m_arrSampleBlobLeads_BaseLead[m_intSampleMatchNumber_BaseLead[i]];

                        if (objSampleBlobsFeatures.fStartX > fStartX)
                            objSampleBlobsFeatures.fStartX = fStartX;

                        if (objSampleBlobsFeatures.fStartY > fStartY)
                            objSampleBlobsFeatures.fStartY = fStartY;

                        if (objSampleBlobsFeatures.fEndX < fEndX)
                            objSampleBlobsFeatures.fEndX = fEndX;

                        if (objSampleBlobsFeatures.fEndY < fEndY)
                            objSampleBlobsFeatures.fEndY = fEndY;

                        objSampleBlobsFeatures.fCenterX = (objSampleBlobsFeatures.fStartX + objSampleBlobsFeatures.fEndX) / 2;
                        objSampleBlobsFeatures.fCenterY = (objSampleBlobsFeatures.fStartY + objSampleBlobsFeatures.fEndY) / 2;

                        objSampleBlobsFeatures.fWidth = objSampleBlobsFeatures.fEndX - objSampleBlobsFeatures.fStartX;
                        objSampleBlobsFeatures.fHeight = objSampleBlobsFeatures.fEndY - objSampleBlobsFeatures.fStartY;

                        objSampleBlobsFeatures.fArea += (float)intArea;

                        objSampleBlobsFeatures.fWidthMM = objSampleBlobsFeatures.fWidth / m_fMMToPixelXValue;
                        objSampleBlobsFeatures.fHeightMM = objSampleBlobsFeatures.fHeight / m_fMMToPixelYValue;
                        objSampleBlobsFeatures.fAreaMM = objSampleBlobsFeatures.fArea / m_fMMtoPixelAreaValue;
                        ////2021-04-11 ZJYEOH : Need to use calibration data based on m_intLeadROIDirection
                        //switch (m_intLeadROIDirection)
                        //{
                        //    case 1:
                        //    case 3:
                        //        objSampleBlobsFeatures.fWidthMM = objSampleBlobsFeatures.fWidth / m_fMMToPixelXValue;
                        //        objSampleBlobsFeatures.fHeightMM = objSampleBlobsFeatures.fHeight / m_fMMToPixelYValue;
                        //        objSampleBlobsFeatures.fAreaMM = objSampleBlobsFeatures.fArea / m_fMMtoPixelAreaValue;
                        //        break;
                        //    case 2:
                        //    case 4:
                        //        objSampleBlobsFeatures.fWidthMM = objSampleBlobsFeatures.fWidth / m_fMMToPixelYValue;
                        //        objSampleBlobsFeatures.fHeightMM = objSampleBlobsFeatures.fHeight / m_fMMToPixelXValue;
                        //        objSampleBlobsFeatures.fAreaMM = objSampleBlobsFeatures.fArea / m_fMMtoPixelAreaValue;
                        //        break;
                        //}

                        //m_stcBlobLead = ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[m_intSampleMatchNumber_BaseLead[i]]);
                        //float fMaxTipOffSet = 0;

                        //fMaxTipOffSet = Math.Max(Math.Abs(m_stcBlobLead.fXDistance - (objROI.ref_ROITotalX + objSampleBlobsFeatures.fCenterX - m_fUnitAverageCenterX)) / m_fMMToPixelXValue,
                        //                         Math.Abs(m_stcBlobLead.fYDistance - (objROI.ref_ROITotalY + objSampleBlobsFeatures.fCenterY - m_fUnitAverageCenterY)) / m_fMMToPixelYValue);

                        //if (fMaxTipOffSet > m_stcBlobLead.fMaxBaseOffset)
                        //{
                        //    // Base OffSet fail
                        //    if ((m_intFailOptionMask & 0x10000) > 0)
                        //    {
                        //        objSampleBlobsFeatures.intFailMask |= 0x10000;
                        //        m_intFailResultMask |= 0x10000;
                        //    }
                        //}

                        //objSampleBlobsFeatures.fOffSetMM = fMaxTipOffSet;

                        //if ((((float)objSampleBlobsFeatures.fArea / m_fMMtoPixelAreaValue) < m_stcBlobLead.fMinBaseArea) || (((float)objSampleBlobsFeatures.fArea / m_fMMtoPixelAreaValue) > m_stcBlobLead.fMaxBaseArea))
                        //{
                        //    // Base Area fail
                        //    if ((m_intFailOptionMask & 0x20000) > 0)
                        //    {
                        //        objSampleBlobsFeatures.intFailMask |= 0x20000;
                        //        m_intFailResultMask |= 0x20000;
                        //    }
                        //}


                        m_arrSampleBlobLeads_BaseLead[m_intSampleMatchNumber_BaseLead[i]] = objSampleBlobsFeatures;
                    }
                }
            }

            for (int i = 0; i < m_arrSampleBlobLeads_BaseLead.Length; i++)
            {
                if (m_arrSampleBlobLeads_BaseLead[i].fArea == -999)
                {
                    m_intFailResultMask |= 0x40000;
                    m_arrSampleBlobLeads_BaseLead[i].intFailMask |= 0x40000;
                }
                else
                {
                    m_stcBlobLead = ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]);

                    float fMaxTipOffSet = Math.Max(Math.Abs(m_stcBlobLead.fXDistance - (objROI.ref_ROITotalX + m_arrSampleBlobLeads_BaseLead[i].fCenterX - m_fUnitAverageCenterX)) / m_fMMToPixelXValue,
                                             Math.Abs(m_stcBlobLead.fYDistance - (objROI.ref_ROITotalY + m_arrSampleBlobLeads_BaseLead[i].fCenterY - m_fUnitAverageCenterY)) / m_fMMToPixelYValue);
                   
                    if (fMaxTipOffSet > m_stcBlobLead.fMaxBaseOffset)
                    {
                        // Base OffSet fail
                        if ((m_intFailOptionMask & 0x10000) > 0)
                        {
                            m_arrSampleBlobLeads_BaseLead[i].intFailMask |= 0x10000;
                            m_intFailResultMask |= 0x10000;
                        }
                    }
                    m_arrSampleBlobLeads_BaseLead[i].fOffSetMM = fMaxTipOffSet;
                    if ((m_arrSampleBlobLeads_BaseLead[i].fAreaMM < m_stcBlobLead.fMinBaseArea) || (m_arrSampleBlobLeads_BaseLead[i].fAreaMM > m_stcBlobLead.fMaxBaseArea))
                    {
                        // Base Area fail
                        if ((m_intFailOptionMask & 0x20000) > 0)
                        {
                            m_arrSampleBlobLeads_BaseLead[i].intFailMask |= 0x20000;
                            m_intFailResultMask |= 0x20000;
                        }
                    }
                }
            }
        }
        private void LeadTestStage1(ROI objROI, List<List<PointF>> arrDontCare)
        {
            float fUnitAreaWidth = objROI.ref_ROIWidth;
            float fUnitAreaHeight = objROI.ref_ROIHeight;
            float fUnitAreaStartX = (float)Math.Round(objROI.ref_ROITotalCenterX - fUnitAreaWidth / 2, MidpointRounding.AwayFromZero) - objROI.ref_ROITotalX;// * m_fMMToPixelXValue;
            float fUnitAreaStartY = (float)Math.Round(objROI.ref_ROITotalCenterY - fUnitAreaHeight / 2, MidpointRounding.AwayFromZero) - objROI.ref_ROITotalY;// * m_fMMToPixelYValue;
            float fUnitAreaEndX = (float)Math.Round(objROI.ref_ROITotalCenterX + fUnitAreaWidth / 2, MidpointRounding.AwayFromZero) - objROI.ref_ROITotalX;// * m_fMMToPixelXValue;
            float fUnitAreaEndY = (float)Math.Round(objROI.ref_ROITotalCenterY + fUnitAreaHeight / 2, MidpointRounding.AwayFromZero) - objROI.ref_ROITotalY;// * m_fMMToPixelYValue;
            //float fUnitAreaStartX = objROI.ref_ROIPositionX;
            //float fUnitAreaStartY = objROI.ref_ROIPositionY;
            //float fUnitAreaEndX = objROI.ref_ROIPositionX + fUnitAreaWidth;
            //float fUnitAreaEndY = objROI.ref_ROIPositionY + fUnitAreaHeight;
            // Testing Type:
            // 1. Match Blobs Object to Template Lead
            // 2. Find reference point of lead
            float fTotalExtraArea = 0;
            float fLimitCenterX = 0;
            float fLimitCenterY = 0;
            float fWidth = 0;
            float fHeight = 0;
            float fOrgX = 0;
            float fOrgY = 0;
            int intTotalSelectedBlobCount = 0;
            int intArea = 0;
            float fGravityCenterX = 0;
            float fGravityCenterY = 0;
            float fStartX = 0;
            float fStartY = 0;
            float fEndX = 0;
            float fEndY = 0;
            float fBaseCenterX = 0;
            float fBaseCenterY = 0;
            float fBaseWidth = 0;
            float fBaseHeight = 0;
            float fTipCenterX = 0;
            float fTipCenterY = 0;
            float fTipWidth = 0;
            float fTipHeight = 0;
            float fNewCenterX = 0;
            float fNewCenterY = 0;
            int intFixPointXY = 0;
            List<int> arrSkipNo = new List<int>();
            bool blnSkipToNextObject = false;

            int intSelectedObjectNum = 0;
            //if (m_objEBlobs.ref_intNumSelectedObject >= m_intNumberOfLead)
            //    intSelectedObjectNum = m_intNumberOfLead;
            //else
            intSelectedObjectNum = m_objEBlobs.ref_intNumSelectedObject;

            for (int i = 0; i < intSelectedObjectNum; i++)
            {
                for (int k = 0; k < arrSkipNo.Count; k++)
                {
                    if (i == arrSkipNo[k])
                    {
                        blnSkipToNextObject = true;
                        break;
                    }
                }

                if (blnSkipToNextObject)
                {
                    // This segment is to handle the case when the largest blob builded is from the same lead
                    // Since the number of lead is predefined, each blob data collected must be from different lead
                    if (m_objEBlobs.ref_intNumSelectedObject > intSelectedObjectNum)

                        intSelectedObjectNum++;
                    blnSkipToNextObject = false;
                    continue;
                }

                fLimitCenterX = m_objEBlobs.ref_arrLimitCenterX[i];
                fLimitCenterY = m_objEBlobs.ref_arrLimitCenterY[i];
                fWidth = m_objEBlobs.ref_arrWidth[i];
                fHeight = m_objEBlobs.ref_arrHeight[i];
                fOrgX = fLimitCenterX - fWidth / 2;
                fOrgY = fLimitCenterY - fHeight / 2;
                intArea = 0;
                fGravityCenterX = 0;
                fGravityCenterY = 0;
                fStartX = fOrgX;
                fStartY = fOrgY;
                fEndX = fOrgX + fWidth;
                fEndY = fOrgY + fHeight;
                intTotalSelectedBlobCount = 0;

                for (int j = i; j < m_objEBlobs.ref_intNumSelectedObject; j++)
                {
                    if (m_intLeadROIDirection == 2 || m_intLeadROIDirection == 4) //m_intLeadDirection == 0
                    {
                        //Horizontal lead
                        if (m_objEBlobs.ref_arrLimitCenterY[j] < fOrgY || m_objEBlobs.ref_arrLimitCenterY[j] > (fOrgY + fHeight))
                            continue;
                    }
                    else if (m_intLeadROIDirection == 1 || m_intLeadROIDirection == 3) //else
                    {
                        //Vertical lead
                        if (m_objEBlobs.ref_arrLimitCenterX[j] < fOrgX || m_objEBlobs.ref_arrLimitCenterX[j] > (fOrgX + fWidth))
                            continue;
                    }

                    //Once the blob met the requirement, add the blob into skip array to prevent the same blob added twice
                    arrSkipNo.Add(j);

                    intArea += m_objEBlobs.ref_arrArea[j];
                    fGravityCenterX += m_objEBlobs.ref_arrGravityCenterX[j] * m_objEBlobs.ref_arrArea[j];
                    fGravityCenterY += m_objEBlobs.ref_arrGravityCenterY[j] * m_objEBlobs.ref_arrArea[j];

                    if (fStartX > m_objEBlobs.ref_arrLimitCenterX[j] - (m_objEBlobs.ref_arrWidth[j] / 2))
                    {
                        fStartX = m_objEBlobs.ref_arrLimitCenterX[j] - (m_objEBlobs.ref_arrWidth[j] / 2);
                    }

                    if (fStartY > m_objEBlobs.ref_arrLimitCenterY[j] - (m_objEBlobs.ref_arrHeight[j] / 2))
                    {
                        fStartY = m_objEBlobs.ref_arrLimitCenterY[j] - (m_objEBlobs.ref_arrHeight[j] / 2);
                    }

                    if (fEndX < m_objEBlobs.ref_arrLimitCenterX[j] + (m_objEBlobs.ref_arrWidth[j] / 2))
                    {
                        fEndX = m_objEBlobs.ref_arrLimitCenterX[j] + (m_objEBlobs.ref_arrWidth[j] / 2);
                    }

                    if (fEndY < m_objEBlobs.ref_arrLimitCenterY[j] + (m_objEBlobs.ref_arrHeight[j] / 2))
                    {
                        fEndY = m_objEBlobs.ref_arrLimitCenterY[j] + (m_objEBlobs.ref_arrHeight[j] / 2);
                    }

                    intTotalSelectedBlobCount++;
                }

                fGravityCenterX = fGravityCenterX / intArea;
                fGravityCenterY = fGravityCenterY / intArea;
                fWidth = fEndX - fStartX;
                fHeight = fEndY - fStartY;
                fLimitCenterX = fStartX + fWidth / 2;
                fLimitCenterY = fStartY + fHeight / 2;

                if (IsInDontCareArea(fGravityCenterX, fGravityCenterY, arrDontCare))
                {
                    return;
                }
                //m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                //switch (m_stcBlobLead.intGroupID)
                //{
                //    //Top
                //    case 1:
                //        //Base
                //        fBaseWidth = fWidth;
                //        intFixPointXY = (int)Math.Round(fLimitCenterY + (fHeight / 2) - m_stcBlobLead.intBaseInwardOffset, 0, MidpointRounding.AwayFromZero);

                //        if (!m_blnWantUseGaugeMeasureLeadDimension)
                //        {
                //            Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                //                    ref fBaseWidth, ref fHeight, ref fBaseCenterX, ref fBaseCenterY, m_intThresholdValue, true, true, intFixPointXY);
                //        }
                //        else
                //        {
                //            UpdateBlobSizeAndCenterPointWithGauge(objROI, fLimitCenterX, fLimitCenterY,
                //                ref fBaseWidth, ref fHeight, ref fBaseCenterX, ref fBaseCenterY, m_intThresholdValue, true, intFixPointXY);
                //        }

                //        //Tip
                //        fTipWidth = fWidth;
                //        intFixPointXY = (int)Math.Round(fLimitCenterY - (fHeight / 2) + m_stcBlobLead.intTipInwardOffset, 0, MidpointRounding.AwayFromZero);

                //        if (!m_blnWantUseGaugeMeasureLeadDimension)
                //        {
                //            Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                //                ref fTipWidth, ref fHeight, ref fTipCenterX, ref fTipCenterY, m_intThresholdValue, true, false, intFixPointXY);
                //        }
                //        else
                //        {
                //            UpdateBlobSizeAndCenterPointWithGauge(objROI, fLimitCenterX, fLimitCenterY,
                //                ref fTipWidth, ref fHeight, ref fTipCenterX, ref fTipCenterY, m_intThresholdValue, true, intFixPointXY);
                //        }

                //        //Length
                //        intFixPointXY = (int)Math.Round(fLimitCenterX, 0, MidpointRounding.AwayFromZero);

                //        UpdateBlobSizeAndCenterPointWithGauge(objROI, fLimitCenterX, fLimitCenterY,
                //                ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, false, intFixPointXY);

                //        fTipCenterY = fNewCenterY - fHeight / 2;
                //        fTipHeight = fHeight;
                //        fBaseCenterY = fNewCenterY + fHeight / 2;
                //        fBaseHeight = fHeight;
                //        break;
                //    //Right
                //    case 2:
                //        //Base
                //        fBaseHeight = fHeight;
                //        intFixPointXY = (int)Math.Round(fLimitCenterX - (fWidth / 2) + m_stcBlobLead.intBaseInwardOffset, 0, MidpointRounding.AwayFromZero);

                //        if (!m_blnWantUseGaugeMeasureLeadDimension)
                //        {
                //            Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                //                ref fWidth, ref fBaseHeight, ref fBaseCenterX, ref fBaseCenterY, m_intThresholdValue, false, false, intFixPointXY);
                //        }
                //        else
                //        {
                //            UpdateBlobSizeAndCenterPointWithGauge(objROI, fLimitCenterX, fLimitCenterY,
                //                ref fWidth, ref fBaseHeight, ref fBaseCenterX, ref fBaseCenterY, m_intThresholdValue, false, intFixPointXY);
                //        }

                //        //Tip
                //        fTipHeight = fHeight;
                //        intFixPointXY = (int)Math.Round(fLimitCenterX + (fWidth / 2) - m_stcBlobLead.intTipInwardOffset, 0, MidpointRounding.AwayFromZero);

                //        if (!m_blnWantUseGaugeMeasureLeadDimension)
                //        {
                //            Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                //                ref fWidth, ref fTipHeight, ref fTipCenterX, ref fTipCenterY, m_intThresholdValue, false, true, intFixPointXY);
                //        }
                //        else
                //        {
                //            UpdateBlobSizeAndCenterPointWithGauge(objROI, fLimitCenterX, fLimitCenterY,
                //                ref fWidth, ref fTipHeight, ref fTipCenterX, ref fTipCenterY, m_intThresholdValue, false, intFixPointXY);
                //        }

                //        //Length
                //        intFixPointXY = (int)Math.Round(fLimitCenterY, 0, MidpointRounding.AwayFromZero);

                //        UpdateBlobSizeAndCenterPointWithGauge(objROI, fLimitCenterX, fLimitCenterY,
                //                ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, true, intFixPointXY);

                //        fTipCenterX = fNewCenterX + fWidth / 2;
                //        fTipWidth = fWidth;
                //        fBaseCenterX = fNewCenterX - fWidth / 2;
                //        fBaseWidth = fWidth;
                //        break;
                //    //Bottom
                //    case 3:
                //        //Base
                //        fBaseWidth = fWidth;
                //        intFixPointXY = (int)Math.Round(fLimitCenterY - (fHeight / 2) + m_stcBlobLead.intBaseInwardOffset, 0, MidpointRounding.AwayFromZero);

                //        if (!m_blnWantUseGaugeMeasureLeadDimension)
                //        {
                //            Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                //                ref fBaseWidth, ref fHeight, ref fBaseCenterX, ref fBaseCenterY, m_intThresholdValue, true, false, intFixPointXY);
                //        }
                //        else
                //        {
                //            UpdateBlobSizeAndCenterPointWithGauge(objROI, fLimitCenterX, fLimitCenterY,
                //                ref fBaseWidth, ref fHeight, ref fBaseCenterX, ref fBaseCenterY, m_intThresholdValue, true, intFixPointXY);
                //        }
                //        //Tip
                //        fTipWidth = fWidth;
                //        intFixPointXY = (int)Math.Round(fLimitCenterY + (fHeight / 2) - m_stcBlobLead.intTipInwardOffset, 0, MidpointRounding.AwayFromZero);

                //        if (!m_blnWantUseGaugeMeasureLeadDimension)
                //        {
                //            Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                //                ref fTipWidth, ref fHeight, ref fTipCenterX, ref fTipCenterY, m_intThresholdValue, true, true, intFixPointXY);
                //        }
                //        else
                //        {
                //            UpdateBlobSizeAndCenterPointWithGauge(objROI, fLimitCenterX, fLimitCenterY,
                //                ref fTipWidth, ref fHeight, ref fTipCenterX, ref fTipCenterY, m_intThresholdValue, true, intFixPointXY);
                //        }

                //        //Length
                //        intFixPointXY = (int)Math.Round(fLimitCenterX, 0, MidpointRounding.AwayFromZero);

                //        UpdateBlobSizeAndCenterPointWithGauge(objROI, fLimitCenterX, fLimitCenterY,
                //                ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, false, intFixPointXY);

                //        fTipCenterY = fNewCenterY + fHeight / 2;
                //        fTipHeight = fHeight;
                //        fBaseCenterY = fNewCenterY - fHeight / 2;
                //        fBaseHeight = fHeight;
                //        break;
                //    //Left
                //    case 4:
                //        //Base
                //        fBaseHeight = fHeight;
                //        intFixPointXY = (int)Math.Round(fLimitCenterX + (fWidth / 2) - m_stcBlobLead.intBaseInwardOffset, 0, MidpointRounding.AwayFromZero);

                //        if (!m_blnWantUseGaugeMeasureLeadDimension)
                //        {
                //            Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                //                ref fWidth, ref fBaseHeight, ref fBaseCenterX, ref fBaseCenterY, m_intThresholdValue, false, true, intFixPointXY);
                //        }
                //        else
                //        {
                //            UpdateBlobSizeAndCenterPointWithGauge(objROI, fLimitCenterX, fLimitCenterY,
                //                ref fWidth, ref fBaseHeight, ref fBaseCenterX, ref fBaseCenterY, m_intThresholdValue, false, intFixPointXY);
                //        }

                //        //Tip
                //        fTipHeight = fHeight;
                //        intFixPointXY = (int)Math.Round(fLimitCenterX - (fWidth / 2) + m_stcBlobLead.intTipInwardOffset, 0, MidpointRounding.AwayFromZero);

                //        if (!m_blnWantUseGaugeMeasureLeadDimension)
                //        {
                //            Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                //                ref fWidth, ref fTipHeight, ref fTipCenterX, ref fTipCenterY, m_intThresholdValue, false, false, intFixPointXY);
                //        }
                //        else
                //        {
                //            UpdateBlobSizeAndCenterPointWithGauge(objROI, fLimitCenterX, fLimitCenterY,
                //                ref fWidth, ref fTipHeight, ref fTipCenterX, ref fTipCenterY, m_intThresholdValue, false, intFixPointXY);
                //        }

                //        //Length
                //        intFixPointXY = (int)Math.Round(fLimitCenterY, 0, MidpointRounding.AwayFromZero);

                //        UpdateBlobSizeAndCenterPointWithGauge(objROI, fLimitCenterX, fLimitCenterY,
                //                ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, true, intFixPointXY); 

                //        fTipCenterX = fNewCenterX - fWidth / 2;
                //        fTipWidth = fWidth;
                //        fBaseCenterX = fNewCenterX + fWidth / 2;
                //        fBaseWidth = fWidth;
                //        break;
                //}

                // Get template number which match with sample
                List<int> arrMatch = MatchTemplateObjects_Inspection(objROI, fStartX, fStartY,
                                                        fEndX, fEndY,
                                                        fWidth, fHeight,
                                                        fBaseWidth, fBaseHeight,
                                                        fTipWidth, fTipHeight,
                                                        fGravityCenterX, fGravityCenterY,
                                                        intArea);
                for (int j = 0; j < arrMatch.Count; j++)
                    m_intTemplateMatchStatus[arrMatch[j]]++;

                if (arrMatch.Count == 0)        // Set to -1 if match nothing with any template leads
                    m_intSampleMatchNumber[i] = -1;
                else if (arrMatch.Count > 1)    // Set to -2 if match more than 1 template leads
                    m_intSampleMatchNumber[i] = -2;
                else
                    m_intSampleMatchNumber[i] = arrMatch[0];

                // No template match with sample
                if (m_intSampleMatchNumber[i] == -1)
                {
                    //Extra Lead
                    if (((m_intFailOptionMask & 0x01) > 0) || ((m_intFailOptionMask & 0x2000) > 0))
                    {
                        float fOutWidth = Math.Max(fUnitAreaStartX - fStartX, 0) + Math.Max(fEndX - fUnitAreaEndX, 0);
                        float fOutHeight = Math.Max(fUnitAreaStartY - fStartY, 0) + Math.Max(fEndY - fUnitAreaEndY, 0);

                        // check is sample under unit area range
                        if (((fWidth - fOutWidth) > 0) && ((fHeight - fOutHeight) > 0)) // both value are > 0 when it is in check area range
                        {
                            //if (m_blnWantCheckExtraLeadLength || m_blnWantCheckExtraLeadArea)
                            {
                                // Create small ROI for the extra area
                                ROI objExtraAreaROI = new ROI();
                                objExtraAreaROI.AttachImage(objROI);
                                //objExtraAreaROI.LoadROISetting((int)Math.Ceiling(fStartX + Math.Max(fUnitAreaStartX - fStartX, 0)),
                                //                               (int)Math.Ceiling(fStartY + Math.Max(fUnitAreaStartY - fStartY, 0)),
                                //                               (int)Math.Floor(fWidth - Math.Max(fUnitAreaStartX - fStartX, 0) - Math.Max(fEndX - fUnitAreaEndX, 0)),
                                //                               (int)Math.Floor(fHeight - Math.Max(fUnitAreaStartY - fStartY, 0) - Math.Max(fEndY - fUnitAreaEndY, 0)));
                                objExtraAreaROI.LoadROISetting((int)Math.Ceiling(fStartX), (int)Math.Ceiling(fStartY), (int)Math.Floor(fEndX - fStartX), (int)Math.Floor(fEndY - fStartY));

                                if (objExtraAreaROI.ref_ROIWidth > 0 && objExtraAreaROI.ref_ROIHeight > 0)
                                {
                                    m_objExtraLeadEBlobs.BuildObjects_Filter_GetElement(objExtraAreaROI, false, true, 0, m_objEBlobs.ref_intAbsoluteThreshold,
                                       m_intFilterMinArea, objExtraAreaROI.ref_ROIHeight * objExtraAreaROI.ref_ROIWidth, false, 0x0F);

                                    if (m_objExtraLeadEBlobs.ref_intNumSelectedObject > 0)
                                    {

                                        float fLimitCenterX2 = 0, fLimitCenterY2 = 0;
                                        float fFinalLimitCenterX = 0, fFinalLimitCenterY = 0;
                                        for (int k = 0; k < m_objExtraLeadEBlobs.ref_intNumSelectedObject; k++)
                                        {
                                            m_intExtraBlobID++;
                                            fLimitCenterX2 = m_objExtraLeadEBlobs.ref_arrLimitCenterX[k];
                                            fLimitCenterY2 = m_objExtraLeadEBlobs.ref_arrLimitCenterY[k];


                                            fFinalLimitCenterX = fLimitCenterX2;
                                            fFinalLimitCenterY = fLimitCenterY2;
                                            fWidth = m_objExtraLeadEBlobs.ref_arrWidth[k];
                                            fHeight = m_objExtraLeadEBlobs.ref_arrHeight[k];
                                            intArea = m_objExtraLeadEBlobs.ref_arrArea[k];

                                            // Reposition so that it offset to objROI
                                            fFinalLimitCenterX += objExtraAreaROI.ref_ROIPositionX;
                                            fFinalLimitCenterY += objExtraAreaROI.ref_ROIPositionY;

                                            // Get object start point and end point
                                            fStartX = fFinalLimitCenterX - (fWidth / 2);
                                            fStartY = fFinalLimitCenterY - (fHeight / 2);
                                            fEndX = fFinalLimitCenterX + (fWidth / 2);
                                            fEndY = fFinalLimitCenterY + (fHeight / 2);
                                            m_blnFailForeignMaterialLength = false;
                                            m_blnFailForeignMaterialArea = false;
                                            m_blnFailForeignMaterialTotalArea = false;
                                            SampleExtraBlobsFeatures extra = new SampleExtraBlobsFeatures();
                                            extra.fStartX = fStartX;
                                            extra.fEndX = fEndX;
                                            extra.fStartY = fStartY;
                                            extra.fEndY = fEndY;
                                            extra.fWidth = fWidth;
                                            extra.fHeight = fHeight;
                                            extra.fCenterX = fLimitCenterX;
                                            extra.fCenterY = fLimitCenterY;
                                            extra.ref_intExtraBlobID = m_intExtraBlobID;
                                            float fWidthInMM = fWidth / m_fMMToPixelXValue;
                                            float fHeightInMM = fHeight / m_fMMToPixelYValue;
                                            ////2021-04-11 ZJYEOH : Need to use calibration data based on m_intLeadROIDirection
                                            //switch (m_stcBlobLead.m_intLeadROIDirection)
                                            //{
                                            //    case 1:
                                            //    case 3:
                                            //        fWidthInMM = fWidth / m_fMMToPixelXValue;
                                            //        fHeightInMM = fHeight / m_fMMToPixelYValue;
                                            //        break;
                                            //    case 2:
                                            //    case 4:
                                            //        fWidthInMM = fWidth / m_fMMToPixelYValue;
                                            //        fHeightInMM = fHeight / m_fMMToPixelXValue;
                                            //        break;
                                            //}
                                            float fArea = intArea * m_fAreaMMPerPixel;

                                            if (m_blnWantCheckExtraLeadLength)
                                            {
                                                //////////////// Check extra Lead using length limit setting ////////////////////
                                                extra.ref_fWidthFailValue = fWidthInMM;
                                                extra.ref_fHeightFailValue = fHeightInMM;

                                                if ((fWidthInMM > m_fExtraLeadSetLength) ||
                                                    (fHeightInMM > m_fExtraLeadSetLength))
                                                {

                                                    if (fWidthInMM > m_fExtraLeadSetLength)
                                                    {
                                                        extra.ref_intFailCriteria |= 0x01;
                                                        m_intFailResultMask |= 0x20;
                                                    }

                                                    if (fHeightInMM > m_fExtraLeadSetLength)
                                                    {
                                                        extra.ref_intFailCriteria |= 0x02;
                                                        m_intFailResultMask |= 0x20;
                                                    }
                                                    m_blnFailForeignMaterialLength = true;
                                                    // Collect extra Lead min and max area for display error message
                                                    //if ((fWidthInMM > m_fExtraLeadSetLength) &&
                                                    //(fHeightInMM > m_fExtraLeadSetLength))
                                                    //{
                                                    //    float fMin = Math.Min(fWidthInMM, fHeightInMM);
                                                    //    if ((m_fResultExtraLeadMinArea == -1) || (fMin < m_fResultExtraLeadMinArea))
                                                    //        m_fResultExtraLeadMinArea = fMin;

                                                    //    float fMax = Math.Max(fWidthInMM, fHeightInMM);
                                                    //    if ((m_fResultExtraLeadMaxArea == -1) || (fMax > m_fResultExtraLeadMaxArea))
                                                    //        m_fResultExtraLeadMaxArea = fMax;
                                                    //}
                                                    //else if (fWidthInMM > m_fExtraLeadSetLength)
                                                    //{
                                                    //    if ((m_fResultExtraLeadMinArea == -1) || (fWidthInMM < m_fResultExtraLeadMinArea))
                                                    //        m_fResultExtraLeadMinArea = fWidthInMM;
                                                    //    if ((m_fResultExtraLeadMaxArea == -1) || (fWidthInMM > m_fResultExtraLeadMaxArea))
                                                    //        m_fResultExtraLeadMaxArea = fWidthInMM;
                                                    //}
                                                    //else if (fHeightInMM > m_fExtraLeadSetLength)
                                                    //{
                                                    //    if ((m_fResultExtraLeadMinArea == -1) || (fHeightInMM < m_fResultExtraLeadMinArea))
                                                    //        m_fResultExtraLeadMinArea = fHeightInMM;
                                                    //    if ((m_fResultExtraLeadMaxArea == -1) || (fHeightInMM > m_fResultExtraLeadMaxArea))
                                                    //        m_fResultExtraLeadMaxArea = fHeightInMM;
                                                    //}
                                                }

                                            }

                                            if (m_blnWantCheckExtraLeadArea)
                                            {
                                                //////////////// Check extra Lead using area limit setting ////////////////////
                                                // Change unit pixel to mm
                                                extra.ref_fAreaFailValue = fArea;
                                                if (fArea > m_fExtraLeadSetArea)
                                                {
                                                    m_blnFailForeignMaterialArea = true;
                                                    extra.ref_intFailCriteria |= 0x04;

                                                    m_intFailResultMask |= 0x20;
                                                    //// Collect extra Lead min and max area for display error message
                                                    //if ((m_fResultExtraLeadMinArea == -1) || (fArea < m_fResultExtraLeadMinArea))
                                                    //    m_fResultExtraLeadMinArea = fArea;
                                                    //if ((m_fResultExtraLeadMaxArea == -1) || (fArea > m_fResultExtraLeadMaxArea))
                                                    //    m_fResultExtraLeadMaxArea = fArea;
                                                }
                                                //////////////////////////////////////////////////////////////////////
                                            }

                                            //////////////// Get Total Extra pad unit area ///////////////////////////////
                                            if ((m_intFailOptionMask & 0x2000) > 0)
                                            {
                                                fTotalExtraArea += fArea;
                                            }
                                            m_arrExtraBlobs.Add(extra);
                                        }

                                    }
                                    else
                                    {
                                        // Set extra area as empty if cannot find object in small ROI
                                        fWidth = 0;
                                        fHeight = 0;
                                        intArea = 0;
                                    }
                                }
                                else
                                {
                                    fWidth = 0;
                                    fHeight = 0;
                                    intArea = 0;
                                }

                                objExtraAreaROI.Dispose();
                            }


                        }
                    }
                    #region Original code
                    ////Extra Lead
                    //if ((m_intFailOptionMask & 0x01) > 0)
                    //{
                    //    float fOutWidth = Math.Max(fUnitAreaStartX - fStartX, 0) + Math.Max(fEndX - fUnitAreaEndX, 0);
                    //    float fOutHeight = Math.Max(fUnitAreaStartY - fStartY, 0) + Math.Max(fEndY - fUnitAreaEndY, 0);

                    //    // check is sample under unit area range
                    //    if (((fWidth - fOutWidth) > 0) && ((fHeight - fOutHeight) > 0)) // both value are > 0 when it is in check area range
                    //    {
                    //        if (m_blnWantCheckExtraLeadLength || m_blnWantCheckExtraLeadArea)
                    //        {
                    //            // Create small ROI for the extra area
                    //            ROI objExtraAreaROI = new ROI();
                    //            objExtraAreaROI.AttachImage(objROI);
                    //            objExtraAreaROI.LoadROISetting((int)Math.Ceiling(fStartX + Math.Max(fUnitAreaStartX - fStartX, 0)),
                    //                                           (int)Math.Ceiling(fStartY + Math.Max(fUnitAreaStartY - fStartY, 0)),
                    //                                           (int)Math.Floor(fWidth - Math.Max(fUnitAreaStartX - fStartX, 0) - Math.Max(fEndX - fUnitAreaEndX, 0)),
                    //                                           (int)Math.Floor(fHeight - Math.Max(fUnitAreaStartY - fStartY, 0) - Math.Max(fEndY - fUnitAreaEndY, 0)));

                    //            if (objExtraAreaROI.ref_ROIWidth > 0 && objExtraAreaROI.ref_ROIHeight > 0)
                    //            {
                    //                if (m_objExtraLeadBlobs.ref_intThreshold != m_objBlobs.ref_intThreshold)
                    //                    m_objExtraLeadBlobs.ref_intThreshold = m_objBlobs.ref_intThreshold;
                    //                if (m_objExtraLeadBlobs.ref_intMinArea != m_objBlobs.ref_intMinArea)
                    //                    m_objExtraLeadBlobs.ref_intMinArea = m_objBlobs.ref_intMinArea;
                    //                m_objExtraLeadBlobs.SetClassSelection(2);
                    //                m_objExtraLeadBlobs.BuildObjects(objExtraAreaROI);

                    //                if (m_objExtraLeadBlobs.ref_intNumSelectedObject > 0)
                    //                {
                    //                    m_objExtraLeadBlobs.SetFirstListBlobs();
                    //                    double dClosest = double.MaxValue;
                    //                    float fLimitCenterX2 = 0, fLimitCenterY2 = 0;
                    //                    float fFinalLimitCenterX = 0, fFinalLimitCenterY = 0;
                    //                    for (int k = 0; k < m_objExtraLeadBlobs.ref_intNumSelectedObject; k++)
                    //                    {
                    //                        m_objExtraLeadBlobs.GetSelectedListBlobsLimitCenterX(ref fLimitCenterX2);
                    //                        m_objExtraLeadBlobs.GetSelectedListBlobsLimitCenterY(ref fLimitCenterY2);

                    //                        double dDistance = Math.Pow(Math.Pow(fLimitCenterX - (objExtraAreaROI.ref_ROIPositionX + fLimitCenterX2), 2) + Math.Pow(fLimitCenterY - (objExtraAreaROI.ref_ROIPositionY + fLimitCenterY2), 2), 0.5);

                    //                        if (dClosest > dDistance)
                    //                        {
                    //                            dClosest = dDistance;
                    //                            fFinalLimitCenterX = fLimitCenterX2;
                    //                            fFinalLimitCenterY = fLimitCenterY2;
                    //                            m_objExtraLeadBlobs.GetSelectedListBlobsWidth(ref fWidth);
                    //                            m_objExtraLeadBlobs.GetSelectedListBlobsHeight(ref fHeight);
                    //                            m_objExtraLeadBlobs.GetSelectedListBlobsArea(ref intArea);
                    //                        }

                    //                        m_objExtraLeadBlobs.SetListBlobsToNext();
                    //                    }

                    //                    // get the object dimension from small ROI and reset this new dimension to the extra area dimension
                    //                    //m_objExtraLeadBlobs.SetFirstListBlobs();
                    //                    //m_objExtraLeadBlobs.GetSelectedListBlobsLimitCenterX(ref fLimitCenterX);
                    //                    //m_objExtraLeadBlobs.GetSelectedListBlobsLimitCenterY(ref fLimitCenterY);
                    //                    //m_objExtraLeadBlobs.GetSelectedListBlobsWidth(ref fWidth);
                    //                    //m_objExtraLeadBlobs.GetSelectedListBlobsHeight(ref fHeight);
                    //                    //m_objExtraLeadBlobs.GetSelectedListBlobsArea(ref intArea);

                    //                    // Reposition so that it offset to objROI
                    //                    fFinalLimitCenterX += objExtraAreaROI.ref_ROIPositionX;
                    //                    fFinalLimitCenterY += objExtraAreaROI.ref_ROIPositionY;

                    //                    // Get object start point and end point
                    //                    fStartX = fFinalLimitCenterX - (fWidth / 2);
                    //                    fStartY = fFinalLimitCenterY - (fHeight / 2);
                    //                    fEndX = fFinalLimitCenterX + (fWidth / 2);
                    //                    fEndY = fFinalLimitCenterY + (fHeight / 2);
                    //                }
                    //                else
                    //                {
                    //                    // Set extra area as empty if cannot find object in small ROI
                    //                    fWidth = 0;
                    //                    fHeight = 0;
                    //                    intArea = 0;
                    //                }
                    //            }
                    //            else
                    //            {
                    //                fWidth = 0;
                    //                fHeight = 0;
                    //                intArea = 0;
                    //            }

                    //            objExtraAreaROI.Dispose();
                    //        }

                    //        if (m_blnWantCheckExtraLeadLength)
                    //        {
                    //            //////////////// Check extra Lead using length limit setting ////////////////////

                    //            float fWidthInMM = fWidth / m_fMMToPixelXValue;
                    //            float fHeightInMM = fHeight / m_fMMToPixelXValue;

                    //            if ((fWidthInMM > m_fExtraLeadSetLength) ||
                    //                (fHeightInMM > m_fExtraLeadSetLength))
                    //            {
                    //                SampleExtraBlobsFeatures extra = new SampleExtraBlobsFeatures();
                    //                extra.fStartX = fStartX;
                    //                extra.fEndX = fEndX;
                    //                extra.fStartY = fStartY;
                    //                extra.fEndY = fEndY;
                    //                extra.fWidth = fWidth;
                    //                extra.fHeight = fHeight;
                    //                extra.fCenterX = fLimitCenterX;
                    //                extra.fCenterY = fLimitCenterY;

                    //                m_arrExtraBlobs.Add(extra);

                    //                m_intFailResultMask |= 0x20;
                    //                m_blnFailForeignMaterialLength = true;

                    //                // Collect extra Lead min and max area for display error message
                    //                if ((fWidthInMM > m_fExtraLeadSetLength) &&
                    //                (fHeightInMM > m_fExtraLeadSetLength))
                    //                {
                    //                    float fMin = Math.Min(fWidthInMM, fHeightInMM);
                    //                    if ((m_fResultExtraLeadMinArea == -1) || (fMin < m_fResultExtraLeadMinArea))
                    //                        m_fResultExtraLeadMinArea = fMin;

                    //                    float fMax = Math.Max(fWidthInMM, fHeightInMM);
                    //                    if ((m_fResultExtraLeadMaxArea == -1) || (fMax > m_fResultExtraLeadMaxArea))
                    //                        m_fResultExtraLeadMaxArea = fMax;
                    //                }
                    //                else if (fWidthInMM > m_fExtraLeadSetLength)
                    //                {
                    //                    if ((m_fResultExtraLeadMinArea == -1) || (fWidthInMM < m_fResultExtraLeadMinArea))
                    //                        m_fResultExtraLeadMinArea = fWidthInMM;
                    //                    if ((m_fResultExtraLeadMaxArea == -1) || (fWidthInMM > m_fResultExtraLeadMaxArea))
                    //                        m_fResultExtraLeadMaxArea = fWidthInMM;
                    //                }
                    //                else if (fHeightInMM > m_fExtraLeadSetLength)
                    //                {
                    //                    if ((m_fResultExtraLeadMinArea == -1) || (fHeightInMM < m_fResultExtraLeadMinArea))
                    //                        m_fResultExtraLeadMinArea = fHeightInMM;
                    //                    if ((m_fResultExtraLeadMaxArea == -1) || (fHeightInMM > m_fResultExtraLeadMaxArea))
                    //                        m_fResultExtraLeadMaxArea = fHeightInMM;
                    //                }
                    //            }
                    //        }

                    //        if (m_blnWantCheckExtraLeadArea && !m_blnFailForeignMaterialLength)
                    //        {
                    //            //////////////// Check extra Lead using area limit setting ////////////////////
                    //            float fArea = intArea * m_fAreaMMPerPixel;  // Change unit pixel to mm
                    //            if (fArea >= m_fExtraLeadSetArea)
                    //            {
                    //                SampleExtraBlobsFeatures extra = new SampleExtraBlobsFeatures();
                    //                extra.fStartX = fStartX;
                    //                extra.fEndX = fEndX;
                    //                extra.fStartY = fStartY;
                    //                extra.fEndY = fEndY;
                    //                extra.fWidth = fWidth;
                    //                extra.fHeight = fHeight;
                    //                extra.fCenterX = fLimitCenterX;
                    //                extra.fCenterY = fLimitCenterY;

                    //                m_arrExtraBlobs.Add(extra);

                    //                m_intFailResultMask |= 0x20;
                    //                m_blnFailForeignMaterialArea = true;

                    //                // Collect extra Lead min and max area for display error message
                    //                if ((m_fResultExtraLeadMinArea == -1) || (fArea < m_fResultExtraLeadMinArea))
                    //                    m_fResultExtraLeadMinArea = fArea;
                    //                if ((m_fResultExtraLeadMaxArea == -1) || (fArea > m_fResultExtraLeadMaxArea))
                    //                    m_fResultExtraLeadMaxArea = fArea;
                    //            }

                    //            //////////////////////////////////////////////////////////////////////
                    //        }
                    //    }
                    //}
                    #endregion
                }
                // More than 1 templates match with sample
                if (m_intSampleMatchNumber[i] == -2)  // Temporary close bridging
                {
                    //Join/Bridge Lead
                    SampleExtraBlobsFeatures extra = new SampleExtraBlobsFeatures();
                    extra.fStartX = fStartX;
                    extra.fEndX = fEndX;
                    extra.fStartY = fStartY;
                    extra.fEndY = fEndY;
                    extra.fWidth = fWidth;
                    extra.fHeight = fHeight;
                    extra.fCenterX = fLimitCenterX;
                    extra.fCenterY = fLimitCenterY;

                    m_arrExtraBlobs.Add(extra);

                    for (int b = 0; b < arrMatch.Count; b++)
                    {
                        m_arrSampleBlobLeads[arrMatch[b]].intFailMask |= 0x02;
                    }

                    m_intFailResultMask |= 0x02;
                }
                //Sample fall in Don't Care ROI area
                else if (m_intSampleMatchNumber[i] == -3)
                {
                    return;
                }
                // Found only 1 templates match with sample
                else if (m_intSampleMatchNumber[i] >= 0)
                {
                    if (m_intSampleMatchNumber[i] == 4 || m_intSampleMatchNumber[i] == 5)
                    {
                    }
                    if (m_arrSampleBlobLeads[m_intSampleMatchNumber[i]].fArea == -999)
                    {
                        m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[m_intSampleMatchNumber[i]];

                        //Collect ordinary blob data
                        m_arrSampleBlobLeads[m_intSampleMatchNumber[i]].intFailMask |= 0;
                        m_arrSampleBlobLeads[m_intSampleMatchNumber[i]].fStartX = fStartX;
                        m_arrSampleBlobLeads[m_intSampleMatchNumber[i]].fStartY = fStartY;
                        m_arrSampleBlobLeads[m_intSampleMatchNumber[i]].fEndX = fEndX;
                        m_arrSampleBlobLeads[m_intSampleMatchNumber[i]].fEndY = fEndY;


                        m_arrSampleBlobLeads[m_intSampleMatchNumber[i]].fCenterX = fLimitCenterX;
                        m_arrSampleBlobLeads[m_intSampleMatchNumber[i]].fCenterY = fLimitCenterY;
                        //m_arrSampleBlobLeads[m_intSampleMatchNumber[i]].fCenterX = fTipCenterX;
                        //m_arrSampleBlobLeads[m_intSampleMatchNumber[i]].fCenterY = fTipCenterY;

                        m_arrSampleBlobLeads[m_intSampleMatchNumber[i]].fGravityCenterX = fGravityCenterX;
                        m_arrSampleBlobLeads[m_intSampleMatchNumber[i]].fGravityCenterY = fGravityCenterY;


                        m_arrSampleBlobLeads[m_intSampleMatchNumber[i]].fWidth = fWidth;
                        m_arrSampleBlobLeads[m_intSampleMatchNumber[i]].fHeight = fHeight;
                        //m_arrSampleBlobLeads[m_intSampleMatchNumber[i]].fWidth = fTipWidth;
                        //m_arrSampleBlobLeads[m_intSampleMatchNumber[i]].fHeight = fTipHeight;

                        m_arrSampleBlobLeads[m_intSampleMatchNumber[i]].fArea = (float)intArea;
                        m_arrSampleBlobLeads[m_intSampleMatchNumber[i]].intContourIndex = 0;
                        m_arrSampleBlobLeads[m_intSampleMatchNumber[i]].fBaseCenterX = fBaseCenterX;
                        m_arrSampleBlobLeads[m_intSampleMatchNumber[i]].fBaseCenterY = fBaseCenterY;
                        m_arrSampleBlobLeads[m_intSampleMatchNumber[i]].fTipCenterX = fTipCenterX;
                        m_arrSampleBlobLeads[m_intSampleMatchNumber[i]].fTipCenterY = fTipCenterY;
                        m_arrSampleBlobLeads[m_intSampleMatchNumber[i]].fBaseWidth = fBaseWidth;
                        m_arrSampleBlobLeads[m_intSampleMatchNumber[i]].fBaseHeight = fBaseHeight;
                        m_arrSampleBlobLeads[m_intSampleMatchNumber[i]].fTipWidth = fTipWidth;
                        m_arrSampleBlobLeads[m_intSampleMatchNumber[i]].fTipHeight = fTipHeight;

                        // Collect Lead range data
                        if (fStartX < m_fSampleLeadRangeStartX)
                            m_fSampleLeadRangeStartX = fStartX;
                        if (fStartY < m_fSampleLeadRangeStartY)
                            m_fSampleLeadRangeStartY = fStartY;
                        if (fEndX > m_fSampleLeadRangeEndX)
                            m_fSampleLeadRangeEndX = fEndX;
                        if (fEndY > m_fSampleLeadRangeEndY)
                            m_fSampleLeadRangeEndY = fEndY;

                        switch (m_stcBlobLead.intGroupID)
                        {
                            ////Top
                            //case 1:
                            //    if (m_fSampleLeadMinSpanStart == -999)
                            //        m_fSampleLeadMinSpanStart = fLimitCenterY - fHeight / 2 + objROI.ref_ROITotalY;
                            //    else
                            //    {
                            //        if (fLimitCenterY - fHeight / 2 + objROI.ref_ROITotalY > m_fSampleLeadMinSpanStart)
                            //            m_fSampleLeadMinSpanStart = fLimitCenterY - fHeight / 2 + objROI.ref_ROITotalY;
                            //    }

                            //    if (m_fSampleLeadMaxSpanStart == -999)
                            //        m_fSampleLeadMaxSpanStart = fLimitCenterY - fHeight / 2 + objROI.ref_ROITotalY;
                            //    else
                            //    {
                            //        if (fLimitCenterY - fHeight / 2 + objROI.ref_ROITotalY < m_fSampleLeadMaxSpanStart)
                            //            m_fSampleLeadMaxSpanStart = fLimitCenterY - fHeight / 2 + objROI.ref_ROITotalY;
                            //    }
                            //    break;
                            ////Right
                            //case 2:
                            //    if (m_fSampleLeadMinSpanEnd == -999)
                            //        m_fSampleLeadMinSpanEnd = fLimitCenterX + fWidth / 2 + objROI.ref_ROITotalX;
                            //    else
                            //    {
                            //        if (fLimitCenterX + fWidth / 2 + objROI.ref_ROITotalX < m_fSampleLeadMinSpanEnd)
                            //            m_fSampleLeadMinSpanEnd = fLimitCenterX + fWidth / 2 + objROI.ref_ROITotalX;
                            //    }

                            //    if (m_fSampleLeadMaxSpanEnd == -999)
                            //        m_fSampleLeadMaxSpanEnd = fLimitCenterX + fWidth / 2 + objROI.ref_ROITotalX;
                            //    else
                            //    {
                            //        if (fLimitCenterX + fWidth / 2 + objROI.ref_ROITotalX > m_fSampleLeadMaxSpanEnd)
                            //            m_fSampleLeadMaxSpanEnd = fLimitCenterX + fWidth / 2 + objROI.ref_ROITotalX;
                            //    }
                            //    break;
                            ////Bottom
                            //case 3:
                            //    if (m_fSampleLeadMinSpanEnd == -999)
                            //        m_fSampleLeadMinSpanEnd = fLimitCenterY + fHeight / 2 + objROI.ref_ROITotalY;
                            //    else
                            //    {
                            //        if (fLimitCenterY + fHeight / 2 + objROI.ref_ROITotalY < m_fSampleLeadMinSpanEnd)
                            //            m_fSampleLeadMinSpanEnd = fLimitCenterY + fHeight / 2 + objROI.ref_ROITotalY;
                            //    }

                            //    if (m_fSampleLeadMaxSpanEnd == -999)
                            //        m_fSampleLeadMaxSpanEnd = fLimitCenterY + fHeight / 2 + objROI.ref_ROITotalY;
                            //    else
                            //    {
                            //        if (fLimitCenterY + fHeight / 2 + objROI.ref_ROITotalY > m_fSampleLeadMaxSpanEnd)
                            //            m_fSampleLeadMaxSpanEnd = fLimitCenterY + fHeight / 2 + objROI.ref_ROITotalY;
                            //    }
                            //    break;
                            ////left
                            //case 4:
                            //    if (m_fSampleLeadMinSpanStart == -999)
                            //        m_fSampleLeadMinSpanStart = fLimitCenterX - fWidth / 2 + objROI.ref_ROITotalX;
                            //    else
                            //    {
                            //        if (fLimitCenterX - fWidth / 2 + objROI.ref_ROITotalX > m_fSampleLeadMinSpanStart)
                            //            m_fSampleLeadMinSpanStart = fLimitCenterX - fWidth / 2 + objROI.ref_ROITotalX;
                            //    }

                            //    if (m_fSampleLeadMaxSpanStart == -999)
                            //        m_fSampleLeadMaxSpanStart = fLimitCenterX - fWidth / 2 + objROI.ref_ROITotalX;
                            //    else
                            //    {
                            //        if (fLimitCenterX - fWidth / 2 + objROI.ref_ROITotalX < m_fSampleLeadMaxSpanStart)
                            //            m_fSampleLeadMaxSpanStart = fLimitCenterX - fWidth / 2 + objROI.ref_ROITotalX;
                            //    }
                            //    break;

                            //Top
                            case 1:
                                if (m_fSampleLeadMinSpanStart == -999)
                                    m_fSampleLeadMinSpanStart = fTipCenterY - fTipHeight / 2 + objROI.ref_ROITotalY;
                                else
                                {
                                    if (fTipCenterY - fTipHeight / 2 + objROI.ref_ROITotalY > m_fSampleLeadMinSpanStart)
                                        m_fSampleLeadMinSpanStart = fTipCenterY - fTipHeight / 2 + objROI.ref_ROITotalY;
                                }

                                if (m_fSampleLeadMaxSpanStart == -999)
                                    m_fSampleLeadMaxSpanStart = fTipCenterY - fTipHeight / 2 + objROI.ref_ROITotalY;
                                else
                                {
                                    if (fTipCenterY - fTipHeight / 2 + objROI.ref_ROITotalY < m_fSampleLeadMaxSpanStart)
                                        m_fSampleLeadMaxSpanStart = fTipCenterY - fTipHeight / 2 + objROI.ref_ROITotalY;
                                }
                                break;
                            //Right
                            case 2:
                                if (m_fSampleLeadMinSpanEnd == -999)
                                    m_fSampleLeadMinSpanEnd = fTipCenterX + fTipHeight / 2 + objROI.ref_ROITotalX;
                                else
                                {
                                    if (fTipCenterX + fTipHeight / 2 + objROI.ref_ROITotalX < m_fSampleLeadMinSpanEnd)
                                        m_fSampleLeadMinSpanEnd = fTipCenterX + fTipHeight / 2 + objROI.ref_ROITotalX;
                                }

                                if (m_fSampleLeadMaxSpanEnd == -999)
                                    m_fSampleLeadMaxSpanEnd = fTipCenterX + fTipHeight / 2 + objROI.ref_ROITotalX;
                                else
                                {
                                    if (fTipCenterX + fTipHeight / 2 + objROI.ref_ROITotalX > m_fSampleLeadMaxSpanEnd)
                                        m_fSampleLeadMaxSpanEnd = fTipCenterX + fTipHeight / 2 + objROI.ref_ROITotalX;
                                }
                                break;
                            //Bottom
                            case 3:
                                if (m_fSampleLeadMinSpanEnd == -999)
                                    m_fSampleLeadMinSpanEnd = fTipCenterY + fTipHeight / 2 + objROI.ref_ROITotalY;
                                else
                                {
                                    if (fTipCenterY + fTipHeight / 2 + objROI.ref_ROITotalY < m_fSampleLeadMinSpanEnd)
                                        m_fSampleLeadMinSpanEnd = fTipCenterY + fTipHeight / 2 + objROI.ref_ROITotalY;
                                }

                                if (m_fSampleLeadMaxSpanEnd == -999)
                                    m_fSampleLeadMaxSpanEnd = fTipCenterY + fTipHeight / 2 + objROI.ref_ROITotalY;
                                else
                                {
                                    if (fTipCenterY + fTipHeight / 2 + objROI.ref_ROITotalY > m_fSampleLeadMaxSpanEnd)
                                        m_fSampleLeadMaxSpanEnd = fTipCenterY + fTipHeight / 2 + objROI.ref_ROITotalY;
                                }
                                break;
                            //left
                            case 4:
                                if (m_fSampleLeadMinSpanStart == -999)
                                    m_fSampleLeadMinSpanStart = fTipCenterX - fTipHeight / 2 + objROI.ref_ROITotalX;
                                else
                                {
                                    if (fTipCenterX - fTipHeight / 2 + objROI.ref_ROITotalX > m_fSampleLeadMinSpanStart)
                                        m_fSampleLeadMinSpanStart = fTipCenterX - fTipHeight / 2 + objROI.ref_ROITotalX;
                                }

                                if (m_fSampleLeadMaxSpanStart == -999)
                                    m_fSampleLeadMaxSpanStart = fTipCenterX - fTipHeight / 2 + objROI.ref_ROITotalX;
                                else
                                {
                                    if (fTipCenterX - fTipHeight / 2 + objROI.ref_ROITotalX < m_fSampleLeadMaxSpanStart)
                                        m_fSampleLeadMaxSpanStart = fTipCenterX - fTipHeight / 2 + objROI.ref_ROITotalX;
                                }
                                break;
                        }

                        //// Collect sample blobs data in MM
                        //m_arrSampleBlobLeads[m_intSampleMatchNumber[i]].fWidthMM = fWidth / m_fMMToPixelXValue;
                        //m_arrSampleBlobLeads[m_intSampleMatchNumber[i]].fHeightMM = fHeight / m_fMMToPixelXValue;
                        //m_arrSampleBlobLeads[m_intSampleMatchNumber[i]].fTipWidthMM = fTipWidth / m_fMMToPixelXValue;
                        //m_arrSampleBlobLeads[m_intSampleMatchNumber[i]].fTipHeightMM = fTipHeight / m_fMMToPixelXValue;
                        //m_arrSampleBlobLeads[m_intSampleMatchNumber[i]].fAreaMM = (float)intArea / m_fMMtoPixelAreaValue;
                        //2021-04-11 ZJYEOH : Need to use calibration data based on m_intLeadROIDirection
                        switch (m_intLeadROIDirection)
                        {
                            case 1:
                            case 3:
                                // Collect sample blobs data in MM
                                m_arrSampleBlobLeads[m_intSampleMatchNumber[i]].fWidthMM = fWidth / m_fMMToPixelXValue;
                                m_arrSampleBlobLeads[m_intSampleMatchNumber[i]].fHeightMM = fHeight / m_fMMToPixelYValue;
                                m_arrSampleBlobLeads[m_intSampleMatchNumber[i]].fTipWidthMM = fTipWidth / m_fMMToPixelXValue;
                                m_arrSampleBlobLeads[m_intSampleMatchNumber[i]].fTipHeightMM = fTipHeight / m_fMMToPixelYValue;
                                m_arrSampleBlobLeads[m_intSampleMatchNumber[i]].fAreaMM = (float)intArea / m_fMMtoPixelAreaValue;
                                break;
                            case 2:
                            case 4:
                                // Collect sample blobs data in MM
                                m_arrSampleBlobLeads[m_intSampleMatchNumber[i]].fWidthMM = fWidth / m_fMMToPixelYValue;
                                m_arrSampleBlobLeads[m_intSampleMatchNumber[i]].fHeightMM = fHeight / m_fMMToPixelXValue;
                                m_arrSampleBlobLeads[m_intSampleMatchNumber[i]].fTipWidthMM = fTipWidth / m_fMMToPixelYValue;
                                m_arrSampleBlobLeads[m_intSampleMatchNumber[i]].fTipHeightMM = fTipHeight / m_fMMToPixelXValue;
                                m_arrSampleBlobLeads[m_intSampleMatchNumber[i]].fAreaMM = (float)intArea / m_fMMtoPixelAreaValue;
                                break;
                        }
                    }
                }
            }

            if (((m_intFailOptionMask & 0x2000) > 0) && !m_blnFailForeignMaterialLength && !m_blnFailForeignMaterialArea)
            {
                if (fTotalExtraArea > 0)
                {
                    m_intExtraBlobID++;
                    //////////////// Check Total Extra Lead unit area ///////////////////////////////
                    SampleExtraBlobsFeatures extra = new SampleExtraBlobsFeatures();
                    extra.ref_intExtraBlobID = m_intExtraBlobID;
                    extra.ref_fWidthFailValue = -999;
                    extra.ref_fHeightFailValue = -999;
                    extra.ref_fAreaFailValue = fTotalExtraArea;
                    if (fTotalExtraArea > m_fTotalExtraLeadSetArea)
                    {
                        m_blnFailForeignMaterialTotalArea = true;
                        for (int i = 0; i < m_arrExtraBlobs.Count; i++)
                        {
                            SampleExtraBlobsFeatures objExtraBlob = m_arrExtraBlobs[i];
                            objExtraBlob.ref_intFailCriteria |= 0x08;
                            m_arrExtraBlobs[i] = objExtraBlob;
                        }
                        extra.ref_intFailCriteria |= 0x04;
                        m_intFailResultMask |= 0x2000;
                    }
                    m_arrExtraBlobs.Add(extra);
                }
            }
            // Missing Lead if template got Leads but sample is empty
            for (int i = 0; i < m_arrSampleBlobLeads.Length; i++)
            {
                if (m_arrSampleBlobLeads[i].fArea == -999)
                {
                    m_intFailResultMask |= 0x04;
                    m_arrSampleBlobLeads[i].intFailMask |= 0x04;
                }
            }
        }

        private void Lead3DTestStage1(ROI objROI, int intNumberOfLead)
        {
            // Testing Type:
            // 1. Match Blobs Object to Template Lead
            // 2. Find reference point of lead

            float fLimitCenterX = 0;
            float fLimitCenterY = 0;
            float fWidth = 0;
            float fHeight = 0;
            float fOrgX = 0;
            float fOrgY = 0;
            int intTotalBlobCount = 0;
            int intArea = 0;
            float fGravityCenterX = 0;
            float fGravityCenterY = 0;
            float fStartX = 0;
            float fStartY = 0;
            float fEndX = 0;
            float fEndY = 0;
            float fBaseCenterX = 0;
            float fBaseCenterY = 0;
            float fBaseWidth = 0;
            float fBaseHeight = 0;
            float fTipCenterX = 0;
            float fTipCenterY = 0;
            float fTipWidth = 0;
            float fTipHeight = 0;
            int intFixPointXY = 0;
            List<int> arrSkipNo = new List<int>();
            bool blnSkipToNextObject = false;

            int intSelectedObjectNum = 0;
            if (m_objEBlobs.ref_intNumSelectedObject >= intNumberOfLead)
                intSelectedObjectNum = intNumberOfLead;
            else
                intSelectedObjectNum = m_objEBlobs.ref_intNumSelectedObject;

            // Assign blobs to sample arrary
            for (int i = 0; i < intSelectedObjectNum; i++)
            {
                m_arrSampleMatchNumber.Add(-1);

                for (int k = 0; k < arrSkipNo.Count; k++)
                {
                    if (i == arrSkipNo[k])
                    {
                        blnSkipToNextObject = true;
                        break;
                    }
                }

                if (blnSkipToNextObject)
                {
                    blnSkipToNextObject = false;
                    continue;
                }

                float fFromROIOffsetLimitCenterX = objROI.ref_ROIPositionX + m_objEBlobs.ref_arrLimitCenterX[i];
                float fFromROIOffsetLimitCenterY = objROI.ref_ROIPositionY + m_objEBlobs.ref_arrLimitCenterY[i];
                // Get blob center point, start point and size
                fWidth = m_objEBlobs.ref_arrWidth[i];
                fHeight = m_objEBlobs.ref_arrHeight[i];
                fOrgX = fFromROIOffsetLimitCenterX - fWidth / 2;
                fOrgY = fFromROIOffsetLimitCenterY - fHeight / 2;
                intArea = 0;
                fGravityCenterX = 0;
                fGravityCenterY = 0;
                fLimitCenterX = 0;
                fLimitCenterY = 0;
                fStartX = fOrgX;
                fStartY = fOrgY;
                fEndX = fOrgX + fWidth;
                fEndY = fOrgY + fHeight;
                intTotalBlobCount = 0;

                // Search Is there other blobs same under same lead area.
                for (int j = i; j < m_objEBlobs.ref_intNumSelectedObject; j++)
                {
                    float fFromROIOffsetCenterX2 = objROI.ref_ROIPositionX + m_objEBlobs.ref_arrGravityCenterX[j];
                    float fFromROIOffsetCenterY2 = objROI.ref_ROIPositionY + m_objEBlobs.ref_arrGravityCenterY[j];
                    float fFromROIOffsetLimitCenterX2 = objROI.ref_ROIPositionX + m_objEBlobs.ref_arrLimitCenterX[j];
                    float fFromROIOffsetLimitCenterY2 = objROI.ref_ROIPositionY + m_objEBlobs.ref_arrLimitCenterY[j];

                    if (m_intLeadROIDirection == 2 || m_intLeadROIDirection == 4) //m_intLeadDirection == 0
                    {
                        //Horizontal lead
                        if (fFromROIOffsetLimitCenterY2 < fOrgY || fFromROIOffsetLimitCenterY2 > (fOrgY + fHeight))
                            continue;
                    }
                    else if (m_intLeadROIDirection == 1 || m_intLeadROIDirection == 3) //else
                    {
                        //Vertical lead
                        if (fFromROIOffsetLimitCenterX2 < fOrgX || fFromROIOffsetLimitCenterX2 > (fOrgX + fWidth))
                            continue;
                    }

                    if (intSelectedObjectNum >= j && i != j)
                    {
                        if (m_objEBlobs.ref_intNumSelectedObject > intSelectedObjectNum)
                            intSelectedObjectNum++;
                        arrSkipNo.Add(j);
                    }

                    intArea += m_objEBlobs.ref_arrArea[j];
                    fGravityCenterX += fFromROIOffsetCenterX2 * m_objEBlobs.ref_arrArea[j];
                    fGravityCenterY += fFromROIOffsetCenterY2 * m_objEBlobs.ref_arrArea[j];
                    fLimitCenterX += fFromROIOffsetLimitCenterX2 * m_objEBlobs.ref_arrArea[j];
                    fLimitCenterY += fFromROIOffsetLimitCenterY2 * m_objEBlobs.ref_arrArea[j];

                    if (fStartX > fFromROIOffsetLimitCenterX2 - (m_objEBlobs.ref_arrWidth[j] / 2))
                    {
                        fStartX = fFromROIOffsetLimitCenterX2 - (m_objEBlobs.ref_arrWidth[j] / 2);
                    }

                    if (fStartY > fFromROIOffsetLimitCenterY2 - (m_objEBlobs.ref_arrHeight[j] / 2))
                    {
                        fStartY = fFromROIOffsetLimitCenterY2 - (m_objEBlobs.ref_arrHeight[j] / 2);
                    }

                    if (fEndX < fFromROIOffsetLimitCenterX2 + (m_objEBlobs.ref_arrWidth[j] / 2))
                    {
                        fEndX = fFromROIOffsetLimitCenterX2 + (m_objEBlobs.ref_arrWidth[j] / 2);
                    }

                    if (fEndY < fFromROIOffsetLimitCenterY2 + (m_objEBlobs.ref_arrHeight[j] / 2))
                    {
                        fEndY = fFromROIOffsetLimitCenterY2 + (m_objEBlobs.ref_arrHeight[j] / 2);
                    }

                    intTotalBlobCount++;
                }

                if (intArea == 0)
                {
                    continue;
                }
                fGravityCenterX = fGravityCenterX / intArea;
                fGravityCenterY = fGravityCenterY / intArea;
                fLimitCenterX = fLimitCenterX / intArea;
                fLimitCenterY = fLimitCenterY / intArea;
                fWidth = fEndX - fStartX;
                fHeight = fEndY - fStartY;

                // Get template number which match with sample
                List<int> arrMatch = MatchTemplateObjects_Inspection(objROI, fStartX, fStartY,
                                                        fEndX, fEndY,
                                                        fWidth, fHeight,
                                                        fBaseWidth, fBaseHeight,
                                                        fTipWidth, fTipHeight,
                                                        fGravityCenterX, fGravityCenterY,
                                                        intArea);
                for (int j = 0; j < arrMatch.Count; j++)
                    m_intTemplateMatchStatus[arrMatch[j]]++;

                if (arrMatch.Count == 0)        // Set to -1 if match nothing with any template leads
                    m_arrSampleMatchNumber[i] = -1;
                else if (arrMatch.Count > 1)    // Set to -2 if match more than 1 template leads
                    m_arrSampleMatchNumber[i] = -2;
                else
                    m_arrSampleMatchNumber[i] = arrMatch[0];

                // No template match with sample
                if (m_arrSampleMatchNumber[i] == -1)
                {
                }
                // More than 1 templates match with sample
                if (m_arrSampleMatchNumber[i] == -2)  // Temporary close bridging
                {
                    //Join/Bridge Lead
                    SampleExtraBlobsFeatures extra = new SampleExtraBlobsFeatures();
                    extra.fStartX = fStartX;
                    extra.fEndX = fEndX;
                    extra.fStartY = fStartY;
                    extra.fEndY = fEndY;
                    extra.fWidth = fWidth;
                    extra.fHeight = fHeight;
                    extra.fCenterX = fLimitCenterX;
                    extra.fCenterY = fLimitCenterY;

                    m_arrExtraBlobs.Add(extra);

                    for (int b = 0; b < arrMatch.Count; b++)
                    {
                        m_arrSampleBlobLeads[arrMatch[b]].intFailMask |= 0x02;
                    }

                    m_intFailResultMask |= 0x02;
                }
                //Sample fall in Don't Care ROI area
                else if (m_arrSampleMatchNumber[i] == -3)
                {
                    return;
                }
                // Found only 1 templates match with sample
                else if (m_arrSampleMatchNumber[i] >= 0)
                {
                    if (m_arrSampleBlobLeads[m_arrSampleMatchNumber[i]].fArea == -999)
                    {
                        m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[m_arrSampleMatchNumber[i]];

                        switch (m_stcBlobLead.intDirection)
                        {
                            //Top
                            case 4:
                                //Base             
                                intFixPointXY = (int)Math.Round(fLimitCenterY + (fHeight / 2) - m_stcBlobLead.intBaseInwardOffset, 0, MidpointRounding.AwayFromZero);
                                Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                                        ref fWidth, ref fHeight, ref fBaseCenterX, ref fBaseCenterY, m_intThresholdValue, true, true, intFixPointXY);

                                fBaseWidth = fWidth;
                                fBaseHeight = fHeight;

                                //Tip
                                intFixPointXY = (int)Math.Round(fLimitCenterY - (fHeight / 2) + m_stcBlobLead.intTipInwardOffset, 0, MidpointRounding.AwayFromZero);
                                Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                                        ref fWidth, ref fHeight, ref fTipCenterX, ref fTipCenterY, m_intThresholdValue, true, false, intFixPointXY);

                                fTipWidth = fWidth;
                                fTipHeight = fHeight;
                                break;
                            //Right
                            case 2:
                                //Base
                                intFixPointXY = (int)Math.Round(fLimitCenterX - (fWidth / 2) + m_stcBlobLead.intBaseInwardOffset, 0, MidpointRounding.AwayFromZero);
                                Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                                        ref fWidth, ref fHeight, ref fBaseCenterX, ref fBaseCenterY, m_intThresholdValue, false, false, intFixPointXY);

                                fBaseWidth = fWidth;
                                fBaseHeight = fHeight;

                                //Tip
                                intFixPointXY = (int)Math.Round(fLimitCenterX + (fWidth / 2) - m_stcBlobLead.intTipInwardOffset, 0, MidpointRounding.AwayFromZero);
                                Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                                        ref fWidth, ref fHeight, ref fTipCenterX, ref fTipCenterY, m_intThresholdValue, false, true, intFixPointXY);

                                fTipWidth = fWidth;
                                fTipHeight = fHeight;
                                break;
                            //Bottom
                            case 8:
                                //Base
                                intFixPointXY = (int)Math.Round(fLimitCenterY - (fHeight / 2) + m_stcBlobLead.intBaseInwardOffset, 0, MidpointRounding.AwayFromZero);
                                Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                                        ref fWidth, ref fHeight, ref fBaseCenterX, ref fBaseCenterY, m_intThresholdValue, true, false, intFixPointXY);

                                fBaseWidth = fWidth;
                                fBaseHeight = fHeight;

                                //Tip
                                intFixPointXY = (int)Math.Round(fLimitCenterY + (fHeight / 2) - m_stcBlobLead.intTipInwardOffset, 0, MidpointRounding.AwayFromZero);
                                Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                                        ref fWidth, ref fHeight, ref fTipCenterX, ref fTipCenterY, m_intThresholdValue, true, true, intFixPointXY);

                                fTipWidth = fWidth;
                                fTipHeight = fHeight;
                                break;
                            //Left
                            case 1:
                                //Base
                                intFixPointXY = (int)Math.Round(fLimitCenterX + (fWidth / 2) - m_stcBlobLead.intBaseInwardOffset, 0, MidpointRounding.AwayFromZero);
                                Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                                        ref fWidth, ref fHeight, ref fBaseCenterX, ref fBaseCenterY, m_intThresholdValue, false, true, intFixPointXY);

                                fBaseWidth = fWidth;
                                fBaseHeight = fHeight;

                                //Tip
                                intFixPointXY = (int)Math.Round(fLimitCenterX - (fWidth / 2) + m_stcBlobLead.intTipInwardOffset, 0, MidpointRounding.AwayFromZero);
                                Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                                        ref fWidth, ref fHeight, ref fTipCenterX, ref fTipCenterY, m_intThresholdValue, false, false, intFixPointXY);

                                fTipWidth = fWidth;
                                fTipHeight = fHeight;
                                break;
                        }


                        //Collect ordinary blob data
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[i]].intFailMask |= 0;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[i]].fStartX = fStartX;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[i]].fStartY = fStartY;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[i]].fEndX = fEndX;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[i]].fEndY = fEndY;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[i]].fCenterX = fLimitCenterX;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[i]].fCenterY = fLimitCenterY;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[i]].fGravityCenterX = fGravityCenterX;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[i]].fGravityCenterY = fGravityCenterY;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[i]].fWidth = fWidth;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[i]].fHeight = fHeight;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[i]].fArea = (float)intArea;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[i]].intContourIndex = 0;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[i]].fBaseCenterX = fBaseCenterX;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[i]].fBaseCenterY = fBaseCenterY;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[i]].fTipCenterX = fTipCenterX;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[i]].fTipCenterY = fTipCenterY;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[i]].fBaseWidth = fBaseWidth;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[i]].fBaseHeight = fBaseHeight;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[i]].fTipWidth = fTipWidth;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[i]].fTipHeight = fTipHeight;

                        // Collect Lead range data
                        if (fStartX < m_fSampleLeadRangeStartX)
                            m_fSampleLeadRangeStartX = fStartX;
                        if (fStartY < m_fSampleLeadRangeStartY)
                            m_fSampleLeadRangeStartY = fStartY;
                        if (fEndX > m_fSampleLeadRangeEndX)
                            m_fSampleLeadRangeEndX = fEndX;
                        if (fEndY > m_fSampleLeadRangeEndY)
                            m_fSampleLeadRangeEndY = fEndY;

                        // Collect sample blobs data in MM
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[i]].fWidthMM = fWidth / m_fMMToPixelXValue;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[i]].fHeightMM = fHeight / m_fMMToPixelXValue;
                        m_arrSampleBlobLeads[m_arrSampleMatchNumber[i]].fAreaMM = (float)intArea / m_fMMtoPixelAreaValue;
                    }
                }
            }
        }

        private void CheckReferencePoint()
        {
            switch (m_stcBlobLead.intGroupID)
            {
                case 1:
                    for (int i = 0; i < m_arrSampleBlobLeads.Length; i++)
                    {
                        ////Skip if join Lead
                        if ((m_arrSampleBlobLeads[i].intFailMask & 0x02) > 0)
                            continue;

                        ////Skip if missing Lead
                        if ((m_arrSampleBlobLeads[i].intFailMask & 0x04) > 0)
                            continue;

                        // 2020 08 14 - CCENG - m_fSampleReferencePointStartXY has been changed to -999 to indicate inspection fail or not before set this variable.
                        //if (m_arrSampleBlobLeads[i].fBaseCenterX - m_arrSampleBlobLeads[i].fBaseWidth / 2 < m_fSampleReferencePointStartX)
                        if (m_fSampleReferencePointStartX == -999 || (m_arrSampleBlobLeads[i].fBaseCenterX - m_arrSampleBlobLeads[i].fBaseWidth / 2 < m_fSampleReferencePointStartX))
                        {
                            m_fSampleReferencePointStartX = m_arrSampleBlobLeads[i].fBaseCenterX - m_arrSampleBlobLeads[i].fBaseWidth / 2;
                            m_fSampleReferencePointStartY = m_arrSampleBlobLeads[i].fBaseCenterY;
                        }

                        // 2020 08 14 - CCENG - m_fSampleReferencePointStartXY has been changed to -999 to indicate inspection fail or not before set this variable.
                        //if (m_arrSampleBlobLeads[i].fBaseCenterX + m_arrSampleBlobLeads[i].fBaseWidth / 2 > m_fSampleReferencePointEndX)
                        if (m_fSampleReferencePointEndX == -999 || (m_arrSampleBlobLeads[i].fBaseCenterX + m_arrSampleBlobLeads[i].fBaseWidth / 2 > m_fSampleReferencePointEndX))
                        {
                            m_fSampleReferencePointEndX = m_arrSampleBlobLeads[i].fBaseCenterX + m_arrSampleBlobLeads[i].fBaseWidth / 2;
                            m_fSampleReferencePointEndY = m_arrSampleBlobLeads[i].fBaseCenterY;
                        }
                    }
                    break;
                case 2:
                    for (int i = 0; i < m_arrSampleBlobLeads.Length; i++)
                    {
                        ////Skip if join Lead
                        if ((m_arrSampleBlobLeads[i].intFailMask & 0x02) > 0)
                            continue;

                        ////Skip if missing Lead
                        if ((m_arrSampleBlobLeads[i].intFailMask & 0x04) > 0)
                            continue;

                        // 2020 08 14 - CCENG - m_fSampleReferencePointStartXY has been changed to -999 to indicate inspection fail or not before set this variable.
                        //if (m_arrSampleBlobLeads[i].fBaseCenterY - m_arrSampleBlobLeads[i].fBaseWidth / 2 < m_fSampleReferencePointStartY)
                        if (m_fSampleReferencePointStartX == -999 || (m_arrSampleBlobLeads[i].fBaseCenterY - m_arrSampleBlobLeads[i].fBaseWidth / 2 < m_fSampleReferencePointStartY))
                        {
                            m_fSampleReferencePointStartY = m_arrSampleBlobLeads[i].fBaseCenterY - m_arrSampleBlobLeads[i].fBaseWidth / 2;
                            m_fSampleReferencePointStartX = m_arrSampleBlobLeads[i].fBaseCenterX;
                        }

                        // 2020 08 14 - CCENG - m_fSampleReferencePointStartXY has been changed to -999 to indicate inspection fail or not before set this variable.
                        //if (m_arrSampleBlobLeads[i].fBaseCenterY + m_arrSampleBlobLeads[i].fBaseWidth / 2 > m_fSampleReferencePointEndY)
                        if (m_fSampleReferencePointEndX == -999 || (m_arrSampleBlobLeads[i].fBaseCenterY + m_arrSampleBlobLeads[i].fBaseWidth / 2 > m_fSampleReferencePointEndY))
                        {
                            m_fSampleReferencePointEndY = m_arrSampleBlobLeads[i].fBaseCenterY + m_arrSampleBlobLeads[i].fBaseWidth / 2;
                            m_fSampleReferencePointEndX = m_arrSampleBlobLeads[i].fBaseCenterX;
                        }
                    }
                    break;
                case 3:
                    for (int i = 0; i < m_arrSampleBlobLeads.Length; i++)
                    {
                        ////Skip if join Lead
                        if ((m_arrSampleBlobLeads[i].intFailMask & 0x02) > 0)
                            continue;

                        ////Skip if missing Lead
                        if ((m_arrSampleBlobLeads[i].intFailMask & 0x04) > 0)
                            continue;

                        // 2020 08 14 - CCENG - m_fSampleReferencePointStartXY has been changed to -999 to indicate inspection fail or not before set this variable.
                        //if (m_arrSampleBlobLeads[i].fBaseCenterX - m_arrSampleBlobLeads[i].fBaseWidth / 2 < m_fSampleReferencePointStartX)
                        if (m_fSampleReferencePointStartX == -999 || (m_arrSampleBlobLeads[i].fBaseCenterX - m_arrSampleBlobLeads[i].fBaseWidth / 2 < m_fSampleReferencePointStartX))
                        {
                            m_fSampleReferencePointStartX = m_arrSampleBlobLeads[i].fBaseCenterX - m_arrSampleBlobLeads[i].fBaseWidth / 2;
                            m_fSampleReferencePointStartY = m_arrSampleBlobLeads[i].fBaseCenterY;
                        }

                        // 2020 08 14 - CCENG - m_fSampleReferencePointStartXY has been changed to -999 to indicate inspection fail or not before set this variable.
                        //if (m_arrSampleBlobLeads[i].fBaseCenterX + m_arrSampleBlobLeads[i].fBaseWidth / 2 > m_fSampleReferencePointEndX)
                        if (m_fSampleReferencePointEndX == -999 || (m_arrSampleBlobLeads[i].fBaseCenterX + m_arrSampleBlobLeads[i].fBaseWidth / 2 > m_fSampleReferencePointEndX))
                        {
                            m_fSampleReferencePointEndX = m_arrSampleBlobLeads[i].fBaseCenterX + m_arrSampleBlobLeads[i].fBaseWidth / 2;
                            m_fSampleReferencePointEndY = m_arrSampleBlobLeads[i].fBaseCenterY;
                        }
                    }
                    break;
                case 4:
                    for (int i = 0; i < m_arrSampleBlobLeads.Length; i++)
                    {
                        ////Skip if join Lead
                        if ((m_arrSampleBlobLeads[i].intFailMask & 0x02) > 0)
                            continue;

                        ////Skip if missing Lead
                        if ((m_arrSampleBlobLeads[i].intFailMask & 0x04) > 0)
                            continue;

                        // 2020 08 14 - CCENG - m_fSampleReferencePointStartXY has been changed to -999 to indicate inspection fail or not before set this variable.
                        //if (m_arrSampleBlobLeads[i].fBaseCenterY - m_arrSampleBlobLeads[i].fBaseWidth / 2 < m_fSampleReferencePointStartY)
                        if (m_fSampleReferencePointStartX == -999 || (m_arrSampleBlobLeads[i].fBaseCenterY - m_arrSampleBlobLeads[i].fBaseWidth / 2 < m_fSampleReferencePointStartY))
                        {
                            m_fSampleReferencePointStartY = m_arrSampleBlobLeads[i].fBaseCenterY - m_arrSampleBlobLeads[i].fBaseWidth / 2;
                            m_fSampleReferencePointStartX = m_arrSampleBlobLeads[i].fBaseCenterX;
                        }

                        // 2020 08 14 - CCENG - m_fSampleReferencePointStartXY has been changed to -999 to indicate inspection fail or not before set this variable.
                        //if (m_arrSampleBlobLeads[i].fBaseCenterY + m_arrSampleBlobLeads[i].fBaseWidth / 2 > m_fSampleReferencePointEndY)
                        if (m_fSampleReferencePointEndX == -999 || (m_arrSampleBlobLeads[i].fBaseCenterY + m_arrSampleBlobLeads[i].fBaseWidth / 2 > m_fSampleReferencePointEndY))
                        {
                            m_fSampleReferencePointEndY = m_arrSampleBlobLeads[i].fBaseCenterY + m_arrSampleBlobLeads[i].fBaseWidth / 2;
                            m_fSampleReferencePointEndX = m_arrSampleBlobLeads[i].fBaseCenterX;
                        }
                    }
                    break;
            }

            // ---------------------------- Check reference point ----------------------------

            //if (!MatchTemplateObjectsReferencePoint())
            //{
            //    m_intFailResultMask |= 0x01;
            //    return;
            //}
        }
        private void CheckDimension(ROI objROI)
        {
            m_arrLeadPointGaugeStartX.Clear();
            m_arrLeadPointGaugeStartY.Clear();
            m_arrLeadPointGaugeTolerance.Clear();
            m_arrLeadPointGaugeAngle.Clear();
            m_arrLeadEdgeGaugePoints.Clear();
            m_arrLeadEdgeGaugePointsFound.Clear();
            m_arrLeadEdgeGaugePointsPosition.Clear();
            m_arrLeadEdgeGaugePointsIDNo.Clear();
            //int intTotalCount = 0;
            //for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            //{
            //    m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
            //    if (m_stcBlobLead.intNoID > intTotalCount)
            //    {
            //        intTotalCount = m_stcBlobLead.intNoID;
            //    }
            //}

            for (int p = m_arrLeadEdgeGaugePoints.Count; p < m_arrTemplateBlobLeads.Count; p++) //intTotalCount
            {
                m_arrLeadEdgeGaugePoints.Add(new List<PointF>());
                m_arrLeadEdgeGaugePointsFound.Add(new List<bool>());
                m_arrLeadEdgeGaugePointsPosition.Add(0);
                m_arrLeadEdgeGaugePointsIDNo.Add(0);
                m_arrLeadPointGaugeStartX.Add(new List<float>());
                m_arrLeadPointGaugeStartY.Add(new List<float>());
                m_arrLeadPointGaugeTolerance.Add(new List<float>());
                m_arrLeadPointGaugeAngle.Add(new List<float>());
            }

            #region ----- Width, Height, OffSet -----

            float fWidth, fHeight, fTipCenterX, fTipCenterY, fBaseCenterX, fBaseCenterY,
                fBaseWidth, fTipWidth, fBaseHeight, fTipHeight,
                fBaseWidthMM, fTipWidthMM, fBaseHeightMM, fTipHeightMM;

            for (int i = 0; i < m_arrSampleBlobLeads.Length; i++)
            {
                fWidth = fHeight = 0;
                fBaseWidth = fTipWidth = fBaseHeight = fTipHeight = 0;

                ////Skip if fail reference point
                if ((m_arrSampleBlobLeads[i].intFailMask & 0x01) > 0)
                    continue;

                ////Skip if join Lead
                if ((m_arrSampleBlobLeads[i].intFailMask & 0x02) > 0)
                    continue;

                ////Skip if missing Lead
                if ((m_arrSampleBlobLeads[i].intFailMask & 0x04) > 0)
                    continue;

                fWidth = m_arrSampleBlobLeads[i].fWidth;
                fHeight = m_arrSampleBlobLeads[i].fHeight;
                fBaseWidth = m_arrSampleBlobLeads[i].fBaseWidth;
                fBaseHeight = m_arrSampleBlobLeads[i].fBaseHeight;
                fTipWidth = m_arrSampleBlobLeads[i].fTipWidth;
                fTipHeight = m_arrSampleBlobLeads[i].fTipHeight;
                fBaseCenterX = m_arrSampleBlobLeads[i].fBaseCenterX;
                fBaseCenterY = m_arrSampleBlobLeads[i].fBaseCenterY;
                fTipCenterX = m_arrSampleBlobLeads[i].fTipCenterX;
                fTipCenterY = m_arrSampleBlobLeads[i].fTipCenterY;

                float fLimitCenterX = m_arrSampleBlobLeads[i].fCenterX;
                float fLimitCenterY = m_arrSampleBlobLeads[i].fCenterY;
                float fNewCenterX = fLimitCenterX;
                float fNewCenterY = fLimitCenterY;
                int intFixPointXY;

                //2019-10-17 ZJYEOH : Measure point gauge here because need matching first just can assign tip/base offset value to individual lead.
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                m_arrLeadEdgeGaugePointsPosition[i] = m_stcBlobLead.intGroupID;
                m_arrLeadEdgeGaugePointsIDNo[i] = m_stcBlobLead.intNoID;
                switch (m_stcBlobLead.intGroupID)
                {
                    //Top
                    case 1:
                        //Base
                        // ------- Find Base Point X -----------------------------------------

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.BaseCenter].SetGaugePlacement(objROI.ref_ROITotalX + fLimitCenterX,
                                                          objROI.ref_ROITotalY + fLimitCenterY + (fHeight / 2),
                                                          fHeight * (m_fPointGaugeToleranceRate * m), 90);

                            m_arrPointGauge[i][(int)PointIndex.BaseCenter].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                            {
                                AddPointGaugePlacementToArray_Inspection(objROI.ref_ROITotalX + fLimitCenterX,
                                                          objROI.ref_ROITotalY + fLimitCenterY + (fHeight / 2),
                                                          fHeight * (m_fPointGaugeToleranceRate * m), 90, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                AddPointGaugePlacementToArray_Inspection(objROI.ref_ROITotalX + fLimitCenterX,
                                                          objROI.ref_ROITotalY + fLimitCenterY + (fHeight / 2),
                                                          fHeight * (m_fPointGaugeToleranceRate * m), 90, i);
                            }
                        }

                        if (m_arrPointGauge[i][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                        {
                            fBaseCenterX = m_arrPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointX(0);
                            fBaseCenterY = m_arrPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointY(0);
                            m_stcBlobLead.blnBaseCenterFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(fBaseCenterX, fBaseCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            fBaseCenterX = objROI.ref_ROITotalX + fLimitCenterX;
                            fBaseCenterY = objROI.ref_ROITotalY + fLimitCenterY + (fHeight / 2);
                            m_stcBlobLead.blnBaseCenterFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(fBaseCenterX, fBaseCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Base start point -----------------------------------------
                        float fTopFixPointY = fBaseCenterY - m_stcBlobLead.intBaseInwardOffset;

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.BaseStart].SetGaugePlacement(fBaseCenterX - fWidth / 2,
                                                          fTopFixPointY,
                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180);

                            m_arrPointGauge[i][(int)PointIndex.BaseStart].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray_Inspection(fBaseCenterX - fWidth / 2,
                                                           fTopFixPointY,
                                                          fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.BaseStart, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray_Inspection(fBaseCenterX - fWidth / 2,
                                                          fTopFixPointY,
                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.BaseStart, i);
                            }
                        }

                        PointF pTopStart;
                        if (m_arrPointGauge[i][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                        {
                            pTopStart = m_arrPointGauge[i][(int)PointIndex.BaseStart].GetMeasurePoint(0);
                            m_stcBlobLead.blnBaseStartFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pTopStart.X, pTopStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pTopStart = new PointF(fBaseCenterX - fWidth / 2, fTopFixPointY);
                            m_stcBlobLead.blnBaseStartFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pTopStart.X, pTopStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Base end point -----------------------------------------

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.BaseEnd].SetGaugePlacement(fBaseCenterX + fWidth / 2,
                                                            fTopFixPointY,
                                                           fWidth * (m_fPointGaugeToleranceRate * m), 0);

                            m_arrPointGauge[i][(int)PointIndex.BaseEnd].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray_Inspection(fBaseCenterX + fWidth / 2,
                                                                fTopFixPointY,
                                                               fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.BaseEnd, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray_Inspection(fBaseCenterX + fWidth / 2,
                                                                fTopFixPointY,
                                                               fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.BaseEnd, i);
                            }
                        }

                        PointF pTopEnd;
                        if (m_arrPointGauge[i][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                        {
                            pTopEnd = m_arrPointGauge[i][(int)PointIndex.BaseEnd].GetMeasurePoint(0);
                            m_stcBlobLead.blnBaseEndFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pTopEnd.X, pTopEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pTopEnd = new PointF(fBaseCenterX + fWidth / 2, fTopFixPointY);
                            m_stcBlobLead.blnBaseEndFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pTopEnd.X, pTopEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // Calculate the Base width and center X
                        fBaseWidth = pTopEnd.X - pTopStart.X;
                        fBaseCenterX = (pTopEnd.X + pTopStart.X) / 2;

                        //Tip

                        // ------- Find Tip Point X -----------------------------------------
                        
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.TipCenter].SetGaugePlacement(objROI.ref_ROITotalX + fLimitCenterX,
                                                           objROI.ref_ROITotalY + fLimitCenterY - (fHeight / 2),
                                                          fHeight * (m_fPointGaugeToleranceRate * m), -90);

                            m_arrPointGauge[i][(int)PointIndex.TipCenter].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray_Inspection(objROI.ref_ROITotalX + fLimitCenterX,
                                                           objROI.ref_ROITotalY + fLimitCenterY - (fHeight / 2),
                                                          fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.TipCenter, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray_Inspection(objROI.ref_ROITotalX + fLimitCenterX,
                                                           objROI.ref_ROITotalY + fLimitCenterY - (fHeight / 2),
                                                          fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.TipCenter, i);
                            }
                        }

                        if (m_arrPointGauge[i][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                        {
                            fTipCenterX = m_arrPointGauge[i][(int)PointIndex.TipCenter].GetMeasurePointX(0);
                            fTipCenterY = m_arrPointGauge[i][(int)PointIndex.TipCenter].GetMeasurePointY(0);
                            m_stcBlobLead.blnTipCenterFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(fTipCenterX, fTipCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            fTipCenterX = objROI.ref_ROITotalX + fLimitCenterX;
                            fTipCenterY = objROI.ref_ROITotalY + fLimitCenterY - (fHeight / 2);
                            m_stcBlobLead.blnTipCenterFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(fTipCenterX, fTipCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Tip start point -----------------------------------------
                        fTopFixPointY = fTipCenterY + m_stcBlobLead.intTipInwardOffset;
                        
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.TipStart].SetGaugePlacement(fTipCenterX - fWidth / 2,
                                                          fTopFixPointY,
                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180);

                            m_arrPointGauge[i][(int)PointIndex.TipStart].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray_Inspection(fTipCenterX - fWidth / 2,
                                                         fTopFixPointY,
                                                        fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.TipStart, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray_Inspection(fTipCenterX - fWidth / 2,
                                                         fTopFixPointY,
                                                        fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.TipStart, i);
                            }
                        }

                        if (m_arrPointGauge[i][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                        {
                            pTopStart = m_arrPointGauge[i][(int)PointIndex.TipStart].GetMeasurePoint(0);
                            m_stcBlobLead.blnTipStartFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pTopStart.X, pTopStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pTopStart = new PointF(fTipCenterX - fWidth / 2, fTopFixPointY);
                            m_stcBlobLead.blnTipStartFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pTopStart.X, pTopStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Tip end point -----------------------------------------

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.TipEnd].SetGaugePlacement(fTipCenterX + fWidth / 2,
                                                         fTopFixPointY,
                                                        fWidth * (m_fPointGaugeToleranceRate * m), 0);

                            m_arrPointGauge[i][(int)PointIndex.TipEnd].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray_Inspection(fTipCenterX + fWidth / 2,
                                                        fTopFixPointY,
                                                       fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.TipEnd, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray_Inspection(fTipCenterX + fWidth / 2,
                                                        fTopFixPointY,
                                                       fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.TipEnd, i);
                            }
                        }


                        if (m_arrPointGauge[i][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                        {
                            pTopEnd = m_arrPointGauge[i][(int)PointIndex.TipEnd].GetMeasurePoint(0);
                            m_stcBlobLead.blnTipEndFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pTopEnd.X, pTopEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pTopEnd = new PointF(fTipCenterX + fWidth / 2, fTopFixPointY);
                            m_stcBlobLead.blnTipEndFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pTopEnd.X, pTopEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // Calculate the Tip width and center X
                        fTipWidth = pTopEnd.X - pTopStart.X;
                        fTipCenterX = (pTopEnd.X + pTopStart.X) / 2;

                        // Base and Tip Length
                        fBaseHeight = fBaseCenterY - fTipCenterY;
                        fTipHeight = fBaseCenterY - fTipCenterY;
                        break;
                    //Right
                    case 2:
                        //Base
                        // ------- Find Base Point Y -----------------------------------------

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.BaseCenter].SetGaugePlacement(objROI.ref_ROITotalX + fLimitCenterX - (fWidth / 2),
                                                              objROI.ref_ROITotalY + fLimitCenterY,
                                                              fWidth * (m_fPointGaugeToleranceRate * m), 180);

                            m_arrPointGauge[i][(int)PointIndex.BaseCenter].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                            {
                                AddPointGaugePlacementToArray_Inspection(objROI.ref_ROITotalX + fLimitCenterX - (fWidth / 2),
                                                                  objROI.ref_ROITotalY + fLimitCenterY,
                                                                  fWidth * (m_fPointGaugeToleranceRate * m), 180, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                AddPointGaugePlacementToArray_Inspection(objROI.ref_ROITotalX + fLimitCenterX - (fWidth / 2),
                                                                  objROI.ref_ROITotalY + fLimitCenterY,
                                                                  fWidth * (m_fPointGaugeToleranceRate * m), 180, i);
                            }
                        }

                        if (m_arrPointGauge[i][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                        {
                            fBaseCenterX = m_arrPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointX(0);
                            fBaseCenterY = m_arrPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointY(0);
                            m_stcBlobLead.blnBaseCenterFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(fBaseCenterX, fBaseCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            fBaseCenterX = objROI.ref_ROITotalX + fLimitCenterX - (fWidth / 2);
                            fBaseCenterY = objROI.ref_ROITotalY + fLimitCenterY;
                            m_stcBlobLead.blnBaseCenterFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(fBaseCenterX, fBaseCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Base start point -----------------------------------------
                        float fRightFixPointX = fBaseCenterX + m_stcBlobLead.intBaseInwardOffset;

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.BaseStart].SetGaugePlacement(fRightFixPointX,
                                                              fBaseCenterY - fHeight / 2,
                                                             fHeight * (m_fPointGaugeToleranceRate * m), -90);

                            m_arrPointGauge[i][(int)PointIndex.BaseStart].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray_Inspection(fRightFixPointX,
                                                                  fBaseCenterY - fHeight / 2,
                                                                 fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.BaseStart, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray_Inspection(fRightFixPointX,
                                                                  fBaseCenterY - fHeight / 2,
                                                                 fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.BaseStart, i);
                            }
                        }

                        PointF pRightStart;
                        if (m_arrPointGauge[i][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                        {
                            pRightStart = m_arrPointGauge[i][(int)PointIndex.BaseStart].GetMeasurePoint(0);
                            m_stcBlobLead.blnBaseStartFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pRightStart.X, pRightStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pRightStart = new PointF(fRightFixPointX, fBaseCenterY - fHeight / 2);
                            m_stcBlobLead.blnBaseStartFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pRightStart.X, pRightStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Base end point -----------------------------------------
                        
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.BaseEnd].SetGaugePlacement(fRightFixPointX,
                                                        fBaseCenterY + fHeight / 2,
                                                       fHeight * (m_fPointGaugeToleranceRate * m), 90);

                            m_arrPointGauge[i][(int)PointIndex.BaseEnd].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray_Inspection(fRightFixPointX,
                                                        fBaseCenterY + fHeight / 2,
                                                       fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.BaseEnd, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray_Inspection(fRightFixPointX,
                                                         fBaseCenterY + fHeight / 2,
                                                        fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.BaseEnd, i);
                            }
                        }

                        PointF pRightEnd;
                        if (m_arrPointGauge[i][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                        {
                            pRightEnd = m_arrPointGauge[i][(int)PointIndex.BaseEnd].GetMeasurePoint(0);
                            m_stcBlobLead.blnBaseEndFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pRightEnd.X, pRightEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pRightEnd = new PointF(fRightFixPointX, fBaseCenterY + fHeight / 2);
                            m_stcBlobLead.blnBaseEndFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pRightEnd.X, pRightEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // Calculate the Base width and center Y
                        fBaseWidth = pRightEnd.Y - pRightStart.Y;
                        fBaseCenterY = (pRightEnd.Y + pRightStart.Y) / 2;

                        //Tip
                        // ------- Find Tip Point X -----------------------------------------
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.TipCenter].SetGaugePlacement(objROI.ref_ROITotalX + fLimitCenterX + (fWidth / 2),
                                                            objROI.ref_ROITotalY + fLimitCenterY,
                                                            fWidth * (m_fPointGaugeToleranceRate * m), 0);

                            m_arrPointGauge[i][(int)PointIndex.TipCenter].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray_Inspection(objROI.ref_ROITotalX + fLimitCenterX + (fWidth / 2),
                                                                objROI.ref_ROITotalY + fLimitCenterY,
                                                                fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.TipCenter, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray_Inspection(objROI.ref_ROITotalX + fLimitCenterX + (fWidth / 2),
                                                                objROI.ref_ROITotalY + fLimitCenterY,
                                                                fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.TipCenter, i);
                            }
                        }

                        if (m_arrPointGauge[i][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                        {
                            fTipCenterX = m_arrPointGauge[i][(int)PointIndex.TipCenter].GetMeasurePointX(0);
                            fTipCenterY = m_arrPointGauge[i][(int)PointIndex.TipCenter].GetMeasurePointY(0);
                            m_stcBlobLead.blnTipCenterFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(fTipCenterX, fTipCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            fTipCenterX = objROI.ref_ROITotalX + fLimitCenterX + (fWidth / 2);
                            fTipCenterY = objROI.ref_ROITotalY + fLimitCenterY;
                            m_stcBlobLead.blnTipCenterFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(fTipCenterX, fTipCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Tip start point -----------------------------------------
                        fRightFixPointX = fTipCenterX - m_stcBlobLead.intTipInwardOffset;

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.TipStart].SetGaugePlacement(fRightFixPointX,
                                                             fTipCenterY - (fHeight / 2),
                                                             fHeight * (m_fPointGaugeToleranceRate * m), -90);

                            m_arrPointGauge[i][(int)PointIndex.TipStart].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray_Inspection(fRightFixPointX,
                                                                  fTipCenterY - (fHeight / 2),
                                                                 fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.TipStart, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray_Inspection(fRightFixPointX,
                                                                  fTipCenterY - (fHeight / 2),
                                                                 fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.TipStart, i);
                            }
                        }

                        if (m_arrPointGauge[i][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                        {
                            pRightStart = m_arrPointGauge[i][(int)PointIndex.TipStart].GetMeasurePoint(0);
                            m_stcBlobLead.blnTipStartFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pRightStart.X, pRightStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pRightStart = new PointF(fRightFixPointX, fTipCenterY - (fHeight / 2));
                            m_stcBlobLead.blnTipStartFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pRightStart.X, pRightStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Tip end point -----------------------------------------
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.TipEnd].SetGaugePlacement(fRightFixPointX,
                                                                 fTipCenterY + (fHeight / 2),
                                                                 fHeight * (m_fPointGaugeToleranceRate * m), 90);

                            m_arrPointGauge[i][(int)PointIndex.TipEnd].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray_Inspection(fRightFixPointX,
                                                                     fTipCenterY + (fHeight / 2),
                                                                     fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.TipEnd, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray_Inspection(fRightFixPointX,
                                                                     fTipCenterY + (fHeight / 2),
                                                                     fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.TipEnd, i);
                            }
                        }

                        if (m_arrPointGauge[i][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                        {
                            pRightEnd = m_arrPointGauge[i][(int)PointIndex.TipEnd].GetMeasurePoint(0);
                            m_stcBlobLead.blnTipEndFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pRightEnd.X, pRightEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pRightEnd = new PointF(fRightFixPointX, fTipCenterY + (fHeight / 2));
                            m_stcBlobLead.blnTipEndFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pRightEnd.X, pRightEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // Calculate the Tip width and center Y
                        fTipWidth = pRightEnd.Y - pRightStart.Y;
                        fTipCenterY = (pRightEnd.Y + pRightStart.Y) / 2;

                        // Base and Tip Length
                        fBaseHeight = fTipCenterX - fBaseCenterX;
                        fTipHeight = fTipCenterX - fBaseCenterX;
                        break;
                    //Bottom
                    case 3:
                        //Base
                        // ------- Find Base Point X -----------------------------------------
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.BaseCenter].SetGaugePlacement(objROI.ref_ROITotalX + fLimitCenterX,
                                                              objROI.ref_ROITotalY + fLimitCenterY - (fHeight / 2),
                                                              fHeight * (m_fPointGaugeToleranceRate * m), -90);

                            m_arrPointGauge[i][(int)PointIndex.BaseCenter].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                            {
                                AddPointGaugePlacementToArray_Inspection(objROI.ref_ROITotalX + fLimitCenterX,
                                                                  objROI.ref_ROITotalY + fLimitCenterY - (fHeight / 2),
                                                                  fHeight * (m_fPointGaugeToleranceRate * m), -90, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                AddPointGaugePlacementToArray_Inspection(objROI.ref_ROITotalX + fLimitCenterX,
                                                                  objROI.ref_ROITotalY + fLimitCenterY - (fHeight / 2),
                                                                  fHeight * (m_fPointGaugeToleranceRate * m), -90, i);
                            }
                        }

                        if (m_arrPointGauge[i][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                        {
                            fBaseCenterX = m_arrPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointX(0);
                            fBaseCenterY = m_arrPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointY(0);
                            m_stcBlobLead.blnBaseCenterFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(fBaseCenterX, fBaseCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            fBaseCenterX = objROI.ref_ROITotalX + fLimitCenterX;
                            fBaseCenterY = objROI.ref_ROITotalY + fLimitCenterY - (fHeight / 2);
                            m_stcBlobLead.blnBaseCenterFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(fBaseCenterX, fBaseCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Base start point -----------------------------------------
                        float fBottomFixPointY = fBaseCenterY + m_stcBlobLead.intBaseInwardOffset;
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.BaseStart].SetGaugePlacement(fBaseCenterX - fWidth / 2,
                                                              fBottomFixPointY,
                                                             fWidth * (m_fPointGaugeToleranceRate * m), 180);

                            m_arrPointGauge[i][(int)PointIndex.BaseStart].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray_Inspection(fBaseCenterX - fWidth / 2,
                                                                  fBottomFixPointY,
                                                                 fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.BaseStart, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray_Inspection(fBaseCenterX - fWidth / 2,
                                                                  fBottomFixPointY,
                                                                 fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.BaseStart, i);
                            }
                        }

                        PointF pBottomStart;
                        if (m_arrPointGauge[i][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                        {
                            pBottomStart = m_arrPointGauge[i][(int)PointIndex.BaseStart].GetMeasurePoint(0);
                            m_stcBlobLead.blnBaseStartFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pBottomStart.X, pBottomStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pBottomStart = new PointF(fBaseCenterX - fWidth / 2, fBottomFixPointY);
                            m_stcBlobLead.blnBaseStartFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pBottomStart.X, pBottomStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Base end point -----------------------------------------

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.BaseEnd].SetGaugePlacement(fBaseCenterX + fWidth / 2,
                                                            fBottomFixPointY,
                                                           fWidth * (m_fPointGaugeToleranceRate * m), 0);

                            m_arrPointGauge[i][(int)PointIndex.BaseEnd].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray_Inspection(fBaseCenterX + fWidth / 2,
                                                                fBottomFixPointY,
                                                               fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.BaseEnd, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray_Inspection(fBaseCenterX + fWidth / 2,
                                                                fBottomFixPointY,
                                                               fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.BaseEnd, i);
                            }
                        }

                        PointF pBottomEnd;
                        if (m_arrPointGauge[i][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                        {
                            pBottomEnd = m_arrPointGauge[i][(int)PointIndex.BaseEnd].GetMeasurePoint(0);
                            m_stcBlobLead.blnBaseEndFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pBottomEnd.X, pBottomEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pBottomEnd = new PointF(fBaseCenterX + fWidth / 2, fBottomFixPointY);
                            m_stcBlobLead.blnBaseEndFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pBottomEnd.X, pBottomEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // Calculate the Base width and center X
                        fBaseWidth = pBottomEnd.X - pBottomStart.X;
                        fBaseCenterX = (pBottomEnd.X + pBottomStart.X) / 2;

                        //Tip
                        // ------- Find Tip Point X -----------------------------------------
                        
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.TipCenter].SetGaugePlacement(objROI.ref_ROITotalX + fLimitCenterX,
                                                                                      objROI.ref_ROITotalY + fLimitCenterY + (fHeight / 2),
                                                                                      fHeight * (m_fPointGaugeToleranceRate * m), 90);
                            m_arrPointGauge[i][(int)PointIndex.TipCenter].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray_Inspection(objROI.ref_ROITotalX + fLimitCenterX,
                                                                  objROI.ref_ROITotalY + fLimitCenterY + (fHeight / 2),
                                                                  fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.TipCenter, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray_Inspection(objROI.ref_ROITotalX + fLimitCenterX,
                                                                  objROI.ref_ROITotalY + fLimitCenterY + (fHeight / 2),
                                                                  fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.TipCenter, i);
                            }
                        }

                        if (m_arrPointGauge[i][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                        {
                            fTipCenterX = m_arrPointGauge[i][(int)PointIndex.TipCenter].GetMeasurePointX(0);
                            fTipCenterY = m_arrPointGauge[i][(int)PointIndex.TipCenter].GetMeasurePointY(0);
                            m_stcBlobLead.blnTipCenterFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(fTipCenterX, fTipCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            fTipCenterX = objROI.ref_ROITotalX + fLimitCenterX;
                            fTipCenterY = objROI.ref_ROITotalY + fLimitCenterY + (fHeight / 2);
                            m_stcBlobLead.blnTipCenterFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(fTipCenterX, fTipCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Tip start point -----------------------------------------
                        fBottomFixPointY = fTipCenterY - m_stcBlobLead.intTipInwardOffset;

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.TipStart].SetGaugePlacement(fTipCenterX - fWidth / 2,
                                                              fBottomFixPointY,
                                                             fWidth * (m_fPointGaugeToleranceRate * m), 180);

                            m_arrPointGauge[i][(int)PointIndex.TipStart].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray_Inspection(fTipCenterX - fWidth / 2,
                                                                  fBottomFixPointY,
                                                                 fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.TipStart, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray_Inspection(fTipCenterX - fWidth / 2,
                                                                  fBottomFixPointY,
                                                                 fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.TipStart, i);
                            }
                        }


                        if (m_arrPointGauge[i][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                        {
                            pBottomStart = m_arrPointGauge[i][(int)PointIndex.TipStart].GetMeasurePoint(0);
                            m_stcBlobLead.blnTipStartFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pBottomStart.X, pBottomStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pBottomStart = new PointF(fTipCenterX - fWidth / 2, fBottomFixPointY);
                            m_stcBlobLead.blnTipStartFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pBottomStart.X, pBottomStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Tip end point -----------------------------------------
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.TipEnd].SetGaugePlacement(fTipCenterX + fWidth / 2,
                                                            fBottomFixPointY,
                                                           fWidth * (m_fPointGaugeToleranceRate * m), 0);

                            m_arrPointGauge[i][(int)PointIndex.TipEnd].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray_Inspection(fTipCenterX + fWidth / 2,
                                                                fBottomFixPointY,
                                                               fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.TipEnd, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray_Inspection(fTipCenterX + fWidth / 2,
                                                                fBottomFixPointY,
                                                               fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.TipEnd, i);
                            }
                        }


                        if (m_arrPointGauge[i][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                        {
                            pBottomEnd = m_arrPointGauge[i][(int)PointIndex.TipEnd].GetMeasurePoint(0);
                            m_stcBlobLead.blnTipEndFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pBottomEnd.X, pBottomEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pBottomEnd = new PointF(fTipCenterX + fWidth / 2, fBottomFixPointY);
                            m_stcBlobLead.blnTipEndFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pBottomEnd.X, pBottomEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // Calculate the Tip width and center X
                        fTipWidth = pBottomEnd.X - pBottomStart.X;
                        fTipCenterX = (pBottomEnd.X + pBottomStart.X) / 2;
                        // Base and Tip Length
                        fBaseHeight = fTipCenterY - fBaseCenterY;
                        fTipHeight = fTipCenterY - fBaseCenterY;
                        break;
                    //Left
                    case 4:
                        //Base
                        // ------- Find Base Point Y -----------------------------------------
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.BaseCenter].SetGaugePlacement(objROI.ref_ROITotalX + fLimitCenterX + (fWidth / 2),
                                                             objROI.ref_ROITotalY + fLimitCenterY,
                                                              fWidth * (m_fPointGaugeToleranceRate * m), 0);

                            m_arrPointGauge[i][(int)PointIndex.BaseCenter].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                            {
                                AddPointGaugePlacementToArray_Inspection(objROI.ref_ROITotalX + fLimitCenterX + (fWidth / 2),
                                                                 objROI.ref_ROITotalY + fLimitCenterY,
                                                                  fWidth * (m_fPointGaugeToleranceRate * m), (int)PointIndex.BaseCenter, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                AddPointGaugePlacementToArray_Inspection(objROI.ref_ROITotalX + fLimitCenterX + (fWidth / 2),
                                                                 objROI.ref_ROITotalY + fLimitCenterY,
                                                                  fWidth * (m_fPointGaugeToleranceRate * m), (int)PointIndex.BaseCenter, i);
                            }
                        }
                        if (m_arrPointGauge[i][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                        {
                            fBaseCenterX = m_arrPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointX(0);
                            fBaseCenterY = m_arrPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointY(0);
                            m_stcBlobLead.blnBaseCenterFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(fBaseCenterX, fBaseCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            fBaseCenterX = objROI.ref_ROITotalX + fLimitCenterX + (fWidth / 2);
                            fBaseCenterY = objROI.ref_ROITotalY + fLimitCenterY;
                            m_stcBlobLead.blnBaseCenterFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(fBaseCenterX, fBaseCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Base start point -----------------------------------------
                        float fLeftFixPointX = fBaseCenterX - m_stcBlobLead.intBaseInwardOffset;
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.BaseStart].SetGaugePlacement(fLeftFixPointX,
                                                              fBaseCenterY - fHeight / 2,
                                                             fHeight * (m_fPointGaugeToleranceRate * m), -90);

                            m_arrPointGauge[i][(int)PointIndex.BaseStart].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray_Inspection(fLeftFixPointX,
                                                                  fBaseCenterY - fHeight / 2,
                                                                 fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.BaseStart, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray_Inspection(fLeftFixPointX,
                                                                  fBaseCenterY - fHeight / 2,
                                                                 fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.BaseStart, i);
                            }
                        }

                        PointF pLeftStart;
                        if (m_arrPointGauge[i][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                        {
                            pLeftStart = m_arrPointGauge[i][(int)PointIndex.BaseStart].GetMeasurePoint(0);
                            m_stcBlobLead.blnBaseStartFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pLeftStart.X, pLeftStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pLeftStart = new PointF(fLeftFixPointX, fBaseCenterY - fHeight / 2);
                            m_stcBlobLead.blnBaseStartFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pLeftStart.X, pLeftStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Base end point -----------------------------------------
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.BaseEnd].SetGaugePlacement(fLeftFixPointX,
                                                            fBaseCenterY + fHeight / 2,
                                                           fHeight * (m_fPointGaugeToleranceRate * m), 90);

                            m_arrPointGauge[i][(int)PointIndex.BaseEnd].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray_Inspection(fLeftFixPointX,
                                                                fBaseCenterY + fHeight / 2,
                                                               fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.BaseEnd, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray_Inspection(fLeftFixPointX,
                                                                fBaseCenterY + fHeight / 2,
                                                               fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.BaseEnd, i);
                            }
                        }

                        PointF pLeftEnd;
                        if (m_arrPointGauge[i][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                        {
                            pLeftEnd = m_arrPointGauge[i][(int)PointIndex.BaseEnd].GetMeasurePoint(0);
                            m_stcBlobLead.blnBaseEndFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pLeftEnd.X, pLeftEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pLeftEnd = new PointF(fLeftFixPointX, fBaseCenterY + fHeight / 2);
                            m_stcBlobLead.blnBaseEndFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pLeftEnd.X, pLeftEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // Calculate the Base width center Y
                        fBaseWidth = pLeftEnd.Y - pLeftStart.Y;
                        fBaseCenterY = (pLeftEnd.Y + pLeftStart.Y) / 2;

                        //Tip
                        // ------- Find Tip Point X -----------------------------------------
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.TipCenter].SetGaugePlacement(objROI.ref_ROITotalX + fLimitCenterX - (fWidth / 2),
                                                           objROI.ref_ROITotalY + fLimitCenterY,
                                                            fWidth * (m_fPointGaugeToleranceRate * m), 180);

                            m_arrPointGauge[i][(int)PointIndex.TipCenter].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray_Inspection(objROI.ref_ROITotalX + fLimitCenterX - (fWidth / 2),
                                                               objROI.ref_ROITotalY + fLimitCenterY,
                                                                fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.TipCenter, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray_Inspection(objROI.ref_ROITotalX + fLimitCenterX - (fWidth / 2),
                                                               objROI.ref_ROITotalY + fLimitCenterY,
                                                                fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.TipCenter, i);
                            }
                        }

                        if (m_arrPointGauge[i][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                        {
                            fTipCenterX = m_arrPointGauge[i][(int)PointIndex.TipCenter].GetMeasurePointX(0);
                            fTipCenterY = m_arrPointGauge[i][(int)PointIndex.TipCenter].GetMeasurePointY(0);
                            m_stcBlobLead.blnTipCenterFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(fTipCenterX, fTipCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            fTipCenterX = objROI.ref_ROITotalX + fLimitCenterX - (fWidth / 2);
                            fTipCenterY = objROI.ref_ROITotalY + fLimitCenterY;
                            m_stcBlobLead.blnTipCenterFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(fTipCenterX, fTipCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Tip start point -----------------------------------------
                        fLeftFixPointX = fTipCenterX + m_stcBlobLead.intTipInwardOffset;
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.TipStart].SetGaugePlacement(fLeftFixPointX,
                                                          fTipCenterY - (fHeight / 2),
                                                             fHeight * (m_fPointGaugeToleranceRate * m), -90);

                            m_arrPointGauge[i][(int)PointIndex.TipStart].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray_Inspection(fLeftFixPointX,
                                                                fTipCenterY - (fHeight / 2),
                                                                 fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.TipStart, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray_Inspection(fLeftFixPointX,
                                                                fTipCenterY - (fHeight / 2),
                                                                 fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.TipStart, i);
                            }
                        }

                        if (m_arrPointGauge[i][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                        {
                            pLeftStart = m_arrPointGauge[i][(int)PointIndex.TipStart].GetMeasurePoint(0);
                            m_stcBlobLead.blnTipStartFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pLeftStart.X, pLeftStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pLeftStart = new PointF(fLeftFixPointX, fTipCenterY - (fHeight / 2));
                            m_stcBlobLead.blnTipStartFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pLeftStart.X, pLeftStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Tip end point -----------------------------------------
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.TipEnd].SetGaugePlacement(fLeftFixPointX,
                                                               fTipCenterY + (fHeight / 2),
                                                                 fHeight * (m_fPointGaugeToleranceRate * m), 90);

                            m_arrPointGauge[i][(int)PointIndex.TipEnd].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray_Inspection(fLeftFixPointX,
                                                                    fTipCenterY + (fHeight / 2),
                                                                     fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.TipEnd, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray_Inspection(fLeftFixPointX,
                                                                    fTipCenterY + (fHeight / 2),
                                                                     fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.TipEnd, i);
                            }
                        }

                        if (m_arrPointGauge[i][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                        {
                            pLeftEnd = m_arrPointGauge[i][(int)PointIndex.TipEnd].GetMeasurePoint(0);
                            m_stcBlobLead.blnTipEndFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pLeftEnd.X, pLeftEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pLeftEnd = new PointF(fLeftFixPointX, fTipCenterY + (fHeight / 2));
                            m_stcBlobLead.blnTipEndFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pLeftEnd.X, pLeftEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // Calculate the Tip width and center Y
                        fTipWidth = pLeftEnd.Y - pLeftStart.Y;
                        fTipCenterY = (pLeftEnd.Y + pLeftStart.Y) / 2;

                        // Base and Tip Length
                        fBaseHeight = fBaseCenterX - fTipCenterX;
                        fTipHeight = fBaseCenterX - fTipCenterX;
                        break;
                }
                switch (m_stcBlobLead.intGroupID)
                {
                    //Top
                    case 1:
                        if (m_fSampleLeadMinSpanStart == -999)
                            m_fSampleLeadMinSpanStart = fTipCenterY - fTipHeight / 2;
                        else
                        {
                            if (fTipCenterY - fTipHeight / 2 > m_fSampleLeadMinSpanStart)
                                m_fSampleLeadMinSpanStart = fTipCenterY - fTipHeight / 2;
                        }

                        if (m_fSampleLeadMaxSpanStart == -999)
                            m_fSampleLeadMaxSpanStart = fTipCenterY - fTipHeight / 2;
                        else
                        {
                            if (fTipCenterY - fTipHeight / 2 < m_fSampleLeadMaxSpanStart)
                                m_fSampleLeadMaxSpanStart = fTipCenterY - fTipHeight / 2;
                        }
                        break;
                    //Right
                    case 2:
                        if (m_fSampleLeadMinSpanEnd == -999)
                            m_fSampleLeadMinSpanEnd = fTipCenterX + fTipHeight / 2;
                        else
                        {
                            if (fTipCenterX + fTipHeight / 2 < m_fSampleLeadMinSpanEnd)
                                m_fSampleLeadMinSpanEnd = fTipCenterX + fTipHeight / 2;
                        }

                        if (m_fSampleLeadMaxSpanEnd == -999)
                            m_fSampleLeadMaxSpanEnd = fTipCenterX + fTipHeight / 2;
                        else
                        {
                            if (fTipCenterX + fTipHeight / 2 > m_fSampleLeadMaxSpanEnd)
                                m_fSampleLeadMaxSpanEnd = fTipCenterX + fTipHeight / 2;
                        }
                        break;
                    //Bottom
                    case 3:
                        if (m_fSampleLeadMinSpanEnd == -999)
                            m_fSampleLeadMinSpanEnd = fTipCenterY + fTipHeight / 2;
                        else
                        {
                            if (fTipCenterY + fTipHeight / 2 < m_fSampleLeadMinSpanEnd)
                                m_fSampleLeadMinSpanEnd = fTipCenterY + fTipHeight / 2;
                        }

                        if (m_fSampleLeadMaxSpanEnd == -999)
                            m_fSampleLeadMaxSpanEnd = fTipCenterY + fTipHeight / 2;
                        else
                        {
                            if (fTipCenterY + fTipHeight / 2 > m_fSampleLeadMaxSpanEnd)
                                m_fSampleLeadMaxSpanEnd = fTipCenterY + fTipHeight / 2;
                        }
                        break;
                    //left
                    case 4:
                        if (m_fSampleLeadMinSpanStart == -999)
                            m_fSampleLeadMinSpanStart = fTipCenterX - fTipHeight / 2;
                        else
                        {
                            if (fTipCenterX - fTipHeight / 2 > m_fSampleLeadMinSpanStart)
                                m_fSampleLeadMinSpanStart = fTipCenterX - fTipHeight / 2;
                        }

                        if (m_fSampleLeadMaxSpanStart == -999)
                            m_fSampleLeadMaxSpanStart = fTipCenterX - fTipHeight / 2;
                        else
                        {
                            if (fTipCenterX - fTipHeight / 2 < m_fSampleLeadMaxSpanStart)
                                m_fSampleLeadMaxSpanStart = fTipCenterX - fTipHeight / 2;
                        }
                        break;
                }

                m_arrSampleBlobLeads[i].fWidth = fWidth;
                m_arrSampleBlobLeads[i].fHeight = fHeight;
                m_arrSampleBlobLeads[i].intContourIndex = 0;
                m_arrSampleBlobLeads[i].fBaseCenterX = fBaseCenterX - objROI.ref_ROITotalX;
                m_arrSampleBlobLeads[i].fBaseCenterY = fBaseCenterY - objROI.ref_ROITotalY;
                m_arrSampleBlobLeads[i].fTipCenterX = fTipCenterX - objROI.ref_ROITotalX;
                m_arrSampleBlobLeads[i].fTipCenterY = fTipCenterY - objROI.ref_ROITotalY;
                m_arrSampleBlobLeads[i].fBaseWidth = fBaseWidth;
                m_arrSampleBlobLeads[i].fBaseHeight = fBaseHeight;
                m_arrSampleBlobLeads[i].fTipWidth = fTipWidth;
                m_arrSampleBlobLeads[i].fTipHeight = fTipHeight;

                m_arrSampleBlobLeads[i].blnTipCenterFound = m_stcBlobLead.blnTipCenterFound;
                m_arrSampleBlobLeads[i].blnTipStartFound = m_stcBlobLead.blnTipStartFound;
                m_arrSampleBlobLeads[i].blnTipEndFound = m_stcBlobLead.blnTipEndFound;
                m_arrSampleBlobLeads[i].blnBaseCenterFound = m_stcBlobLead.blnBaseCenterFound;
                m_arrSampleBlobLeads[i].blnBaseStartFound = m_stcBlobLead.blnBaseStartFound;
                m_arrSampleBlobLeads[i].blnBaseEndFound = m_stcBlobLead.blnBaseEndFound;

                // Collect sample blobs data in MM
                m_arrSampleBlobLeads[i].fWidthMM = fWidth / m_fMMToPixelXValue;
                m_arrSampleBlobLeads[i].fHeightMM = fHeight / m_fMMToPixelYValue;
                ////2021-04-11 ZJYEOH : Need to use calibration data based on m_intLeadROIDirection
                //switch (m_intLeadROIDirection)
                //{
                //    case 1:
                //    case 3:
                //        // Collect sample blobs data in MM
                //        m_arrSampleBlobLeads[i].fWidthMM = fWidth / m_fMMToPixelXValue;
                //        m_arrSampleBlobLeads[i].fHeightMM = fHeight / m_fMMToPixelYValue;
                //        break;
                //    case 2:
                //    case 4:
                //        // Collect sample blobs data in MM
                //        m_arrSampleBlobLeads[i].fWidthMM = fWidth / m_fMMToPixelYValue;
                //        m_arrSampleBlobLeads[i].fHeightMM = fHeight / m_fMMToPixelXValue;
                //        break;
                //}
                // Add calibrate off set value to measurement
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                // Check base/tip Width
                fBaseWidthMM = fBaseWidth / m_fMMToPixelXValue;
                fTipWidthMM = fTipWidth / m_fMMToPixelXValue;
                //2021-04-11 ZJYEOH : Need to use calibration data based on m_intLeadROIDirection
                switch (m_intLeadROIDirection)
                {
                    case 1:
                    case 3:
                        fBaseWidthMM = fBaseWidth / m_fMMToPixelXValue;
                        fTipWidthMM = fTipWidth / m_fMMToPixelXValue;
                        break;
                    case 2:
                    case 4:
                        fBaseWidthMM = fBaseWidth / m_fMMToPixelYValue;
                        fTipWidthMM = fTipWidth / m_fMMToPixelYValue;
                        break;
                }
                if (!MatchTemplateObjectsWidth(i, fTipWidthMM + m_stcBlobLead.fWidthOffset))
                {
                    if ((m_intFailOptionMask & 0x40) > 0)
                    {
                        m_arrSampleBlobLeads[i].intFailMask |= 0x40;
                        m_intFailResultMask |= 0x40;
                    }
                }

                // Check base/tip Height
                fBaseHeightMM = fBaseHeight / m_fMMToPixelYValue;
                fTipHeightMM = fTipHeight / m_fMMToPixelYValue;
                //2021-04-11 ZJYEOH : Need to use calibration data based on m_intLeadROIDirection
                switch (m_intLeadROIDirection)
                {
                    case 1:
                    case 3:
                        fBaseHeightMM = fBaseHeight / m_fMMToPixelYValue;
                        fTipHeightMM = fTipHeight / m_fMMToPixelYValue;
                        break;
                    case 2:
                    case 4:
                        fBaseHeightMM = fBaseHeight / m_fMMToPixelXValue;
                        fTipHeightMM = fTipHeight / m_fMMToPixelXValue;
                        break;
                }
                if (!MatchTemplateObjectsWidth(i, fTipWidthMM + m_stcBlobLead.fWidthOffset))
                {
                    if ((m_intFailOptionMask & 0x40) > 0)
                    {
                        m_arrSampleBlobLeads[i].intFailMask |= 0x40;
                        m_intFailResultMask |= 0x40;
                    }
                }

                if (!MatchTemplateObjectsHeight(i, fTipHeightMM + m_stcBlobLead.fLengthOffset))
                {
                    if ((m_intFailOptionMask & 0x80) > 0)
                    {
                        m_arrSampleBlobLeads[i].intFailMask |= 0x80;
                        m_intFailResultMask |= 0x80;
                    }
                }

                // Add calibrate off set value to measurement
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                //Tip offset value here
                float fMaxTipOffSet = 0;
                //PointF p1 = new PointF();
                //PointF p2 = new PointF();

                //switch (m_stcBlobLead.intGroupID)
                //{
                //    case 1:
                //        p1 = new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY - (m_stcBlobLead.fTipHeight / 2));
                //        p2 = new PointF(fTipCenterX, fTipCenterY - (fTipHeight / 2));
                //        break;
                //    case 2:
                //        p1 = new PointF(m_stcBlobLead.fTipCenterX + (m_stcBlobLead.fTipWidth / 2), m_stcBlobLead.fTipCenterY);
                //        p2 = new PointF(fTipCenterX + (fTipWidth / 2), fTipCenterY);
                //        break;
                //    case 3:
                //        p1 = new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY + (m_stcBlobLead.fTipHeight / 2));
                //        p2 = new PointF(fTipCenterX, fTipCenterY + (fTipHeight / 2));
                //        break;
                //    case 4:
                //        p1 = new PointF(m_stcBlobLead.fTipCenterX - (m_stcBlobLead.fTipWidth / 2), m_stcBlobLead.fTipCenterY);
                //        p2 = new PointF(fTipCenterX - (fTipWidth / 2), fTipCenterY);
                //        break;
                //}

                //fMaxTipOffSet = Math2.GetDistanceBtw2Points(p1, p2);

                //fMaxTipOffSet = Math.Max(Math.Abs(m_stcBlobLead.fXDistance - (fTipCenterX - m_fUnitAverageCenterX)) / m_fMMToPixelXValue,// m_fMMToPixelXValue
                //                                   Math.Abs(m_stcBlobLead.fYDistance - (fTipCenterY - m_fUnitAverageCenterY)) / m_fMMToPixelYValue);// m_fMMToPixelYValue


                float fMaxSkew = 0;
                switch (m_stcBlobLead.intGroupID)
                {
                    case 1:
                    case 3:
                        fMaxTipOffSet = Math.Abs(m_stcBlobLead.fXDistance - (fTipCenterX - m_fUnitAverageCenterX)) / m_fMMToPixelXValue;

                        fMaxSkew = Math.Abs(fBaseCenterX - fTipCenterX) / m_fMMToPixelXValue; //2019-10-11 ZJYEOH : Lead Offset or bend --> Compare the center point between base and tip
                        break;
                    case 2:
                    case 4:
                        fMaxTipOffSet = Math.Abs(m_stcBlobLead.fYDistance - (fTipCenterY - m_fUnitAverageCenterY)) / m_fMMToPixelYValue;

                        fMaxSkew = Math.Abs(fBaseCenterY - fTipCenterY) / m_fMMToPixelYValue; //2019-10-11 ZJYEOH : Lead Offset or bend --> Compare the center point between base and tip
                        break;
                }

                if (fMaxTipOffSet > m_stcBlobLead.fOffSet)
                {
                    // Tip OffSet fail
                    if ((m_intFailOptionMask & 0x100) > 0)
                    {
                        m_arrSampleBlobLeads[i].intFailMask |= 0x100;
                        m_intFailResultMask |= 0x100;
                    }
                }

                if (fMaxSkew > m_stcBlobLead.fSkew)
                {
                    // Tip OffSet fail
                    if ((m_intFailOptionMask & 0x8000) > 0)
                    {
                        m_arrSampleBlobLeads[i].intFailMask |= 0x8000;
                        m_intFailResultMask |= 0x8000;
                    }
                }

                m_arrSampleBlobLeads[i].fOffSetMM = fMaxTipOffSet;
                m_arrSampleBlobLeads[i].fSkewMM = fMaxSkew;
                m_arrSampleBlobLeads[i].fBaseWidthMM = fBaseWidthMM + m_stcBlobLead.fWidthOffset;
                m_arrSampleBlobLeads[i].fBaseHeightMM = fBaseHeightMM + m_stcBlobLead.fLengthOffset;
                m_arrSampleBlobLeads[i].fTipWidthMM = fTipWidthMM + m_stcBlobLead.fWidthOffset;
                m_arrSampleBlobLeads[i].fTipHeightMM = fTipHeightMM + m_stcBlobLead.fLengthOffset;
            }
            #endregion
        }

        private void CheckDimension_PkgToBase(ROI objROI)
        {
            m_arrLeadPointGaugeStartX.Clear();
            m_arrLeadPointGaugeStartY.Clear();
            m_arrLeadPointGaugeTolerance.Clear();
            m_arrLeadPointGaugeAngle.Clear();
            m_arrLeadEdgeGaugePoints.Clear();
            m_arrLeadEdgeGaugePointsFound.Clear();
            m_arrLeadEdgeGaugePointsPosition.Clear();
            m_arrLeadEdgeGaugePointsIDNo.Clear();
            //int intTotalCount = 0;
            //for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            //{
            //    m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
            //    if (m_stcBlobLead.intNoID > intTotalCount)
            //    {
            //        intTotalCount = m_stcBlobLead.intNoID;
            //    }
            //}

            for (int p = m_arrLeadEdgeGaugePoints.Count; p < m_arrTemplateBlobLeads.Count; p++) //intTotalCount
            {
                m_arrLeadEdgeGaugePoints.Add(new List<PointF>());
                m_arrLeadEdgeGaugePointsFound.Add(new List<bool>());
                m_arrLeadEdgeGaugePointsPosition.Add(0);
                m_arrLeadEdgeGaugePointsIDNo.Add(0);
                m_arrLeadPointGaugeStartX.Add(new List<float>());
                m_arrLeadPointGaugeStartY.Add(new List<float>());
                m_arrLeadPointGaugeTolerance.Add(new List<float>());
                m_arrLeadPointGaugeAngle.Add(new List<float>());
            }

            #region ----- Width, Height, OffSet -----

            float fWidth, fHeight, fTipCenterX, fTipCenterY, fBaseCenterX, fBaseCenterY,
                fBaseWidth, fTipWidth, fBaseHeight, fTipHeight,
                fBaseWidthMM, fTipWidthMM, fBaseHeightMM, fTipHeightMM;

            for (int i = 0; i < m_arrSampleBlobLeads.Length; i++)
            {
                fWidth = fHeight = 0;
                fBaseWidth = fTipWidth = fBaseHeight = fTipHeight = 0;

                ////Skip if fail reference point
                if ((m_arrSampleBlobLeads[i].intFailMask & 0x01) > 0)
                    continue;

                ////Skip if join Lead
                if ((m_arrSampleBlobLeads[i].intFailMask & 0x02) > 0)
                    continue;

                ////Skip if missing Lead
                if ((m_arrSampleBlobLeads[i].intFailMask & 0x04) > 0)
                    continue;

                fWidth = m_arrSampleBlobLeads[i].fWidth;
                fHeight = m_arrSampleBlobLeads[i].fHeight;
                fBaseWidth = m_arrSampleBlobLeads[i].fBaseWidth;
                fBaseHeight = m_arrSampleBlobLeads[i].fBaseHeight;
                fTipWidth = m_arrSampleBlobLeads[i].fTipWidth;
                fTipHeight = m_arrSampleBlobLeads[i].fTipHeight;
                fBaseCenterX = m_arrSampleBlobLeads[i].fBaseCenterX;
                fBaseCenterY = m_arrSampleBlobLeads[i].fBaseCenterY;
                fTipCenterX = m_arrSampleBlobLeads[i].fTipCenterX;
                fTipCenterY = m_arrSampleBlobLeads[i].fTipCenterY;

                float fLimitCenterX = m_arrSampleBlobLeads[i].fCenterX;
                float fLimitCenterY = m_arrSampleBlobLeads[i].fCenterY;
                float fNewCenterX = fLimitCenterX;
                float fNewCenterY = fLimitCenterY;
                int intFixPointXY;

                //2019-10-17 ZJYEOH : Measure point gauge here because need matching first just can assign tip/base offset value to individual lead.
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                m_arrLeadEdgeGaugePointsPosition[i] = m_stcBlobLead.intGroupID;
                m_arrLeadEdgeGaugePointsIDNo[i] = m_stcBlobLead.intNoID;
                switch (m_stcBlobLead.intGroupID)
                {
                    //Top
                    case 1:
                        //Base
                        //float fTopFixPointY;
                        //PointF pTopStart;
                        //PointF pTopEnd;
                        //fBaseCenterY = (m_fCenterY_PackageGaugeM4L - m_fHeight_PackageGaugeM4L / 2) - m_intPkgToBaseTolerance_Top;
                        //AddPointGaugePlacementToArray_Inspection(-1, -1, -1, -(int)PointIndex.TipCenter, i);
                        //m_stcBlobLead.blnBaseCenterFound = false;
                        //m_arrLeadEdgeGaugePoints[i].Add(new PointF(-1, -1));
                        //m_arrLeadEdgeGaugePointsFound[i].Add(false);

                        //SetPointGaugePlacementToArray_Inspection(-1, -1, -1, -1, (int)PointIndex.BaseStart, i);
                        //m_stcBlobLead.blnBaseStartFound = false;
                        //m_arrLeadEdgeGaugePoints[i].Add(new PointF(-1, -1));
                        //m_arrLeadEdgeGaugePointsFound[i].Add(false);

                        //SetPointGaugePlacementToArray_Inspection(-1, -1, -1, -1, (int)PointIndex.BaseEnd, i);
                        //m_stcBlobLead.blnBaseEndFound = false;
                        //m_arrLeadEdgeGaugePoints[i].Add(new PointF(-1, -1));
                        //m_arrLeadEdgeGaugePointsFound[i].Add(false);

                        // ------- Find Base Point X -----------------------------------------
                        fBaseCenterY = (m_fCenterY_PackageGaugeM4L - m_fHeight_PackageGaugeM4L / 2) - m_intPkgToBaseTolerance_Top;

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.BaseCenter].SetGaugePlacement(objROI.ref_ROITotalX + fLimitCenterX,
                                                          fBaseCenterY,
                                                          fHeight * (m_fPointGaugeToleranceRate * m), 90);

                            m_arrPointGauge[i][(int)PointIndex.BaseCenter].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                            {
                                AddPointGaugePlacementToArray_Inspection(objROI.ref_ROITotalX + fLimitCenterX,
                                                         fBaseCenterY,
                                                         fHeight * (m_fPointGaugeToleranceRate * m), 90, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                AddPointGaugePlacementToArray_Inspection(objROI.ref_ROITotalX + fLimitCenterX,
                                                          fBaseCenterY,
                                                          fHeight * (m_fPointGaugeToleranceRate * m), 90, i);
                            }
                        }

                        if (m_arrPointGauge[i][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                        {
                            fBaseCenterX = m_arrPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointX(0);
                            //fBaseCenterY = m_arrPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointY(0);
                            m_stcBlobLead.blnBaseCenterFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(fBaseCenterX, m_arrPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointY(0)));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            fBaseCenterX = objROI.ref_ROITotalX + fLimitCenterX;
                            //fBaseCenterY = objROI.ref_ROITotalY + fLimitCenterY + (fHeight / 2);
                            m_stcBlobLead.blnBaseCenterFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(fBaseCenterX, fBaseCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Base start point -----------------------------------------
                        float fTopFixPointY = fBaseCenterY - m_stcBlobLead.intBaseInwardOffset;
                        
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.BaseStart].SetGaugePlacement(fBaseCenterX - fWidth / 2,
                                                                                      fTopFixPointY,
                                                                                     fWidth * (m_fPointGaugeToleranceRate * m), 180);
                            m_arrPointGauge[i][(int)PointIndex.BaseStart].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray_Inspection(fBaseCenterX - fWidth / 2,
                                                                  fTopFixPointY,
                                                                 fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.BaseStart, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray_Inspection(fBaseCenterX - fWidth / 2,
                                                                  fTopFixPointY,
                                                                 fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.BaseStart, i);
                            }
                        }

                        PointF pTopStart;
                        if (m_arrPointGauge[i][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                        {
                            pTopStart = m_arrPointGauge[i][(int)PointIndex.BaseStart].GetMeasurePoint(0);
                            m_stcBlobLead.blnBaseStartFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pTopStart.X, pTopStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pTopStart = new PointF(fBaseCenterX - fWidth / 2, fTopFixPointY);
                            m_stcBlobLead.blnBaseStartFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pTopStart.X, pTopStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Base end point -----------------------------------------
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.BaseEnd].SetGaugePlacement(fBaseCenterX + fWidth / 2,
                                                            fTopFixPointY,
                                                           fWidth * (m_fPointGaugeToleranceRate * m), 0);

                            m_arrPointGauge[i][(int)PointIndex.BaseEnd].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray_Inspection(fBaseCenterX + fWidth / 2,
                                                                fTopFixPointY,
                                                               fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.BaseEnd, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray_Inspection(fBaseCenterX + fWidth / 2,
                                                                fTopFixPointY,
                                                               fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.BaseEnd, i);
                            }
                        }



                        PointF pTopEnd;
                        if (m_arrPointGauge[i][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                        {
                            pTopEnd = m_arrPointGauge[i][(int)PointIndex.BaseEnd].GetMeasurePoint(0);
                            m_stcBlobLead.blnBaseEndFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pTopEnd.X, pTopEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pTopEnd = new PointF(fBaseCenterX + fWidth / 2, fTopFixPointY);
                            m_stcBlobLead.blnBaseEndFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pTopEnd.X, pTopEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // Calculate the Base width and center X
                        fBaseWidth = pTopEnd.X - pTopStart.X;
                        fBaseCenterX = (pTopEnd.X + pTopStart.X) / 2;


                        //Tip

                        // ------- Find Tip Point X -----------------------------------------
                        
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.TipCenter].SetGaugePlacement(objROI.ref_ROITotalX + fLimitCenterX,
                                   objROI.ref_ROITotalY + fLimitCenterY - (fHeight / 2),
                                  fHeight * (m_fPointGaugeToleranceRate * m), -90);


                            m_arrPointGauge[i][(int)PointIndex.TipCenter].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray_Inspection(objROI.ref_ROITotalX + fLimitCenterX,
                                                                                           objROI.ref_ROITotalY + fLimitCenterY - (fHeight / 2),
                                                                                          fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.TipCenter, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray_Inspection(objROI.ref_ROITotalX + fLimitCenterX,
                                                                                           objROI.ref_ROITotalY + fLimitCenterY - (fHeight / 2),
                                                                                          fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.TipCenter, i);
                            }
                        }

                        if (m_arrPointGauge[i][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                        {
                            fTipCenterX = m_arrPointGauge[i][(int)PointIndex.TipCenter].GetMeasurePointX(0);
                            fTipCenterY = m_arrPointGauge[i][(int)PointIndex.TipCenter].GetMeasurePointY(0);
                            m_stcBlobLead.blnTipCenterFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(fTipCenterX, fTipCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            fTipCenterX = objROI.ref_ROITotalX + fLimitCenterX;
                            fTipCenterY = objROI.ref_ROITotalY + fLimitCenterY - (fHeight / 2);
                            m_stcBlobLead.blnTipCenterFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(fTipCenterX, fTipCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Tip start point -----------------------------------------
                        fTopFixPointY = fTipCenterY + m_stcBlobLead.intTipInwardOffset;

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.TipStart].SetGaugePlacement(fTipCenterX - fWidth / 2,
                                                              fTopFixPointY,
                                                             fWidth * (m_fPointGaugeToleranceRate * m), 180);

                            m_arrPointGauge[i][(int)PointIndex.TipStart].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray_Inspection(fTipCenterX - fWidth / 2,
                                                                  fTopFixPointY,
                                                                 fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.TipStart, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray_Inspection(fTipCenterX - fWidth / 2,
                                                                  fTopFixPointY,
                                                                 fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.TipStart, i);
                            }
                        }

                        if (m_arrPointGauge[i][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                        {
                            pTopStart = m_arrPointGauge[i][(int)PointIndex.TipStart].GetMeasurePoint(0);
                            m_stcBlobLead.blnTipStartFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pTopStart.X, pTopStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pTopStart = new PointF(fTipCenterX - fWidth / 2, fTopFixPointY);
                            m_stcBlobLead.blnTipStartFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pTopStart.X, pTopStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Tip end point -----------------------------------------

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.TipEnd].SetGaugePlacement(fTipCenterX + fWidth / 2,
                                                            fTopFixPointY,
                                                           fWidth * (m_fPointGaugeToleranceRate * m), 0);

                            m_arrPointGauge[i][(int)PointIndex.TipEnd].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray_Inspection(fTipCenterX + fWidth / 2,
                                                                fTopFixPointY,
                                                               fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.TipEnd, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray_Inspection(fTipCenterX + fWidth / 2,
                                                                fTopFixPointY,
                                                               fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.TipEnd, i);
                            }
                        }

                        if (m_arrPointGauge[i][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                        {
                            pTopEnd = m_arrPointGauge[i][(int)PointIndex.TipEnd].GetMeasurePoint(0);
                            m_stcBlobLead.blnTipEndFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pTopEnd.X, pTopEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pTopEnd = new PointF(fTipCenterX + fWidth / 2, fTopFixPointY);
                            m_stcBlobLead.blnTipEndFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pTopEnd.X, pTopEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // Calculate the Tip width and center X
                        fTipWidth = pTopEnd.X - pTopStart.X; //fBaseWidth = 
                        fTipCenterX = (pTopEnd.X + pTopStart.X) / 2; //fBaseCenterX = 

                        // Base and Tip Length
                        fBaseHeight = fBaseCenterY - fTipCenterY;
                        fTipHeight = fBaseCenterY - fTipCenterY;
                        break;
                    //Right
                    case 2:
                        //Base
                        //float fRightFixPointX;
                        //PointF pRightStart;
                        //PointF pRightEnd;

                        //// ------- Find Base -----------------------------------------
                        //fBaseCenterX = (m_fCenterX_PackageGaugeM4L + m_fWidth_PackageGaugeM4L / 2) + m_intPkgToBaseTolerance_Right;

                        //AddPointGaugePlacementToArray_Inspection(-1, -1, -1, -(int)PointIndex.TipCenter, i);

                        //m_stcBlobLead.blnBaseCenterFound = false;
                        //m_arrLeadEdgeGaugePoints[i].Add(new PointF(-1, -1));
                        //m_arrLeadEdgeGaugePointsFound[i].Add(false);

                        //SetPointGaugePlacementToArray_Inspection(-1, -1, -1, -1, (int)PointIndex.BaseStart, i);
                        //m_stcBlobLead.blnBaseStartFound = false;
                        //m_arrLeadEdgeGaugePoints[i].Add(new PointF(-1, -1));
                        //m_arrLeadEdgeGaugePointsFound[i].Add(false);

                        //SetPointGaugePlacementToArray_Inspection(-1, -1, -1, -1, (int)PointIndex.BaseEnd, i);
                        //m_stcBlobLead.blnBaseEndFound = false;
                        //m_arrLeadEdgeGaugePoints[i].Add(new PointF(-1, -1));
                        //m_arrLeadEdgeGaugePointsFound[i].Add(false);

                        // ------- Find Base Point Y -----------------------------------------
                        fBaseCenterX = (m_fCenterX_PackageGaugeM4L + m_fWidth_PackageGaugeM4L / 2) + m_intPkgToBaseTolerance_Right;

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.BaseCenter].SetGaugePlacement(fBaseCenterX,
                                                              objROI.ref_ROITotalY + fLimitCenterY,
                                                              fWidth * (m_fPointGaugeToleranceRate * m), 180);

                            m_arrPointGauge[i][(int)PointIndex.BaseCenter].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                            {
                                AddPointGaugePlacementToArray_Inspection(fBaseCenterX,
                                                                  objROI.ref_ROITotalY + fLimitCenterY,
                                                                  fWidth * (m_fPointGaugeToleranceRate * m), 180, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                AddPointGaugePlacementToArray_Inspection(fBaseCenterX,
                                                                  objROI.ref_ROITotalY + fLimitCenterY,
                                                                  fWidth * (m_fPointGaugeToleranceRate * m), 180, i);
                            }
                        }

                        if (m_arrPointGauge[i][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                        {
                            //fBaseCenterX = m_arrPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointX(0);
                            fBaseCenterY = m_arrPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointY(0);
                            m_stcBlobLead.blnBaseCenterFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(m_arrPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointX(0), fBaseCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            //fBaseCenterX = objROI.ref_ROITotalX + fLimitCenterX - (fWidth / 2);
                            fBaseCenterY = objROI.ref_ROITotalY + fLimitCenterY;
                            m_stcBlobLead.blnBaseCenterFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(fBaseCenterX, fBaseCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Base start point -----------------------------------------
                        float fRightFixPointX = fBaseCenterX + m_stcBlobLead.intBaseInwardOffset;

                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.BaseStart].SetGaugePlacement(fRightFixPointX,
                                                              fBaseCenterY - fHeight / 2,
                                                             fHeight * (m_fPointGaugeToleranceRate * m), -90);

                            m_arrPointGauge[i][(int)PointIndex.BaseStart].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray_Inspection(fRightFixPointX,
                                                                  fBaseCenterY - fHeight / 2,
                                                                 fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.BaseStart, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray_Inspection(fRightFixPointX,
                                                                  fBaseCenterY - fHeight / 2,
                                                                 fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.BaseStart, i);
                            }
                        }

                        PointF pRightStart;
                        if (m_arrPointGauge[i][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                        {
                            pRightStart = m_arrPointGauge[i][(int)PointIndex.BaseStart].GetMeasurePoint(0);
                            m_stcBlobLead.blnBaseStartFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pRightStart.X, pRightStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pRightStart = new PointF(fRightFixPointX, fBaseCenterY - fHeight / 2);
                            m_stcBlobLead.blnBaseStartFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pRightStart.X, pRightStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Base end point -----------------------------------------
                        
                        
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.BaseEnd].SetGaugePlacement(fRightFixPointX,
                                                        fBaseCenterY + fHeight / 2,
                                                       fHeight * (m_fPointGaugeToleranceRate * m), 90);

                            m_arrPointGauge[i][(int)PointIndex.BaseEnd].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray_Inspection(fRightFixPointX,
                                                                fBaseCenterY + fHeight / 2,
                                                               fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.BaseEnd, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray_Inspection(fRightFixPointX,
                                                                fBaseCenterY + fHeight / 2,
                                                               fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.BaseEnd, i);
                            }
                        }
                        PointF pRightEnd;
                        if (m_arrPointGauge[i][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                        {
                            pRightEnd = m_arrPointGauge[i][(int)PointIndex.BaseEnd].GetMeasurePoint(0);
                            m_stcBlobLead.blnBaseEndFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pRightEnd.X, pRightEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pRightEnd = new PointF(fRightFixPointX, fBaseCenterY + fHeight / 2);
                            m_stcBlobLead.blnBaseEndFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pRightEnd.X, pRightEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // Calculate the Base width and center Y
                        fBaseWidth = pRightEnd.Y - pRightStart.Y;
                        fBaseCenterY = (pRightEnd.Y + pRightStart.Y) / 2;


                        //Tip
                        // ------- Find Tip Point X -----------------------------------------
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.TipCenter].SetGaugePlacement(objROI.ref_ROITotalX + fLimitCenterX + (fWidth / 2),
                                                            objROI.ref_ROITotalY + fLimitCenterY,
                                                            fWidth * (m_fPointGaugeToleranceRate * m), 0);

                            m_arrPointGauge[i][(int)PointIndex.TipCenter].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray_Inspection(objROI.ref_ROITotalX + fLimitCenterX + (fWidth / 2),
                                                                objROI.ref_ROITotalY + fLimitCenterY,
                                                                fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.TipCenter, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray_Inspection(objROI.ref_ROITotalX + fLimitCenterX + (fWidth / 2),
                                                                objROI.ref_ROITotalY + fLimitCenterY,
                                                                fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.TipCenter, i);
                            }
                        }

                        if (m_arrPointGauge[i][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                        {
                            fTipCenterX = m_arrPointGauge[i][(int)PointIndex.TipCenter].GetMeasurePointX(0);
                            fTipCenterY = m_arrPointGauge[i][(int)PointIndex.TipCenter].GetMeasurePointY(0);
                            m_stcBlobLead.blnTipCenterFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(fTipCenterX, fTipCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            fTipCenterX = objROI.ref_ROITotalX + fLimitCenterX + (fWidth / 2);
                            fTipCenterY = objROI.ref_ROITotalY + fLimitCenterY;
                            m_stcBlobLead.blnTipCenterFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(fTipCenterX, fTipCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Tip start point -----------------------------------------
                        fRightFixPointX = fTipCenterX - m_stcBlobLead.intTipInwardOffset;
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.TipStart].SetGaugePlacement(fRightFixPointX,
                                                             fTipCenterY - (fHeight / 2),
                                                             fHeight * (m_fPointGaugeToleranceRate * m), -90);

                            m_arrPointGauge[i][(int)PointIndex.TipStart].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray_Inspection(fRightFixPointX,
                                                                  fTipCenterY - (fHeight / 2),
                                                                 fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.TipStart, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray_Inspection(fRightFixPointX,
                                                                  fTipCenterY - (fHeight / 2),
                                                                 fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.TipStart, i);
                            }
                        }


                        if (m_arrPointGauge[i][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                        {
                            pRightStart = m_arrPointGauge[i][(int)PointIndex.TipStart].GetMeasurePoint(0);
                            m_stcBlobLead.blnTipStartFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pRightStart.X, pRightStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pRightStart = new PointF(fRightFixPointX, fTipCenterY - (fHeight / 2));
                            m_stcBlobLead.blnTipStartFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pRightStart.X, pRightStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Tip end point -----------------------------------------
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.TipEnd].SetGaugePlacement(fRightFixPointX,
                                                                 fTipCenterY + (fHeight / 2),
                                                                 fHeight * (m_fPointGaugeToleranceRate * m), 90);

                            m_arrPointGauge[i][(int)PointIndex.TipEnd].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray_Inspection(fRightFixPointX,
                                                                     fTipCenterY + (fHeight / 2),
                                                                     fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.TipEnd, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray_Inspection(fRightFixPointX,
                                                                     fTipCenterY + (fHeight / 2),
                                                                     fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.TipEnd, i);
                            }
                        }

                        if (m_arrPointGauge[i][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                        {
                            pRightEnd = m_arrPointGauge[i][(int)PointIndex.TipEnd].GetMeasurePoint(0);
                            m_stcBlobLead.blnTipEndFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pRightEnd.X, pRightEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pRightEnd = new PointF(fRightFixPointX, fTipCenterY + (fHeight / 2));
                            m_stcBlobLead.blnTipEndFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pRightEnd.X, pRightEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // Calculate the Tip width and center Y
                        fTipWidth = pRightEnd.Y - pRightStart.Y; //fBaseWidth = 
                        fTipCenterY = (pRightEnd.Y + pRightStart.Y) / 2; //fBaseCenterY = 

                        // Base and Tip Length
                        fBaseHeight = fTipCenterX - fBaseCenterX;
                        fTipHeight = fTipCenterX - fBaseCenterX;
                        break;
                    //Bottom
                    case 3:
                        //Base

                        //float fBottomFixPointY;
                        //PointF pBottomStart;
                        //PointF pBottomEnd;

                        //// ------- Find Base -----------------------------------------
                        //fBaseCenterY = (m_fCenterY_PackageGaugeM4L + m_fHeight_PackageGaugeM4L / 2) + m_intPkgToBaseTolerance_Bottom;
                        //AddPointGaugePlacementToArray_Inspection(-1, -1, -1, -(int)PointIndex.TipCenter, i);

                        //m_stcBlobLead.blnBaseCenterFound = false;
                        //m_arrLeadEdgeGaugePoints[i].Add(new PointF(-1, -1));
                        //m_arrLeadEdgeGaugePointsFound[i].Add(false);

                        //SetPointGaugePlacementToArray_Inspection(-1, -1, -1, -1, (int)PointIndex.BaseStart, i);
                        //m_stcBlobLead.blnBaseStartFound = false;
                        //m_arrLeadEdgeGaugePoints[i].Add(new PointF(-1, -1));
                        //m_arrLeadEdgeGaugePointsFound[i].Add(false);

                        //SetPointGaugePlacementToArray_Inspection(-1, -1, -1, -1, (int)PointIndex.BaseEnd, i);
                        //m_stcBlobLead.blnBaseEndFound = false;
                        //m_arrLeadEdgeGaugePoints[i].Add(new PointF(-1, -1));
                        //m_arrLeadEdgeGaugePointsFound[i].Add(false);

                        // ------- Find Base Point X -----------------------------------------
                        fBaseCenterY = (m_fCenterY_PackageGaugeM4L + m_fHeight_PackageGaugeM4L / 2) + m_intPkgToBaseTolerance_Bottom;
                        
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.BaseCenter].SetGaugePlacement(objROI.ref_ROITotalX + fLimitCenterX,
                                                                                      fBaseCenterY,
                                                                                      fHeight * (m_fPointGaugeToleranceRate * m), -90);
                            m_arrPointGauge[i][(int)PointIndex.BaseCenter].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                            {
                                AddPointGaugePlacementToArray_Inspection(objROI.ref_ROITotalX + fLimitCenterX,
                                                                  fBaseCenterY,
                                                                  fHeight * (m_fPointGaugeToleranceRate * m), -90, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                AddPointGaugePlacementToArray_Inspection(objROI.ref_ROITotalX + fLimitCenterX,
                                                                  fBaseCenterY,
                                                                  fHeight * (m_fPointGaugeToleranceRate * m), -90, i);
                            }
                        }

                        if (m_arrPointGauge[i][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                        {
                            fBaseCenterX = m_arrPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointX(0);
                            //fBaseCenterY = m_arrPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointY(0);
                            m_stcBlobLead.blnBaseCenterFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(fBaseCenterX, m_arrPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointY(0)));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            fBaseCenterX = objROI.ref_ROITotalX + fLimitCenterX;
                            //fBaseCenterY = objROI.ref_ROITotalY + fLimitCenterY - (fHeight / 2);
                            m_stcBlobLead.blnBaseCenterFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(fBaseCenterX, fBaseCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Base start point -----------------------------------------
                        float fBottomFixPointY = fBaseCenterY + m_stcBlobLead.intBaseInwardOffset;
                        
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.BaseStart].SetGaugePlacement(fBaseCenterX - fWidth / 2,
                                                          fBottomFixPointY,
                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180);

                            m_arrPointGauge[i][(int)PointIndex.BaseStart].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray_Inspection(fBaseCenterX - fWidth / 2,
                                                          fBottomFixPointY,
                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.BaseStart, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray_Inspection(fBaseCenterX - fWidth / 2,
                                                                                          fBottomFixPointY,
                                                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.BaseStart, i);
                            }
                        }

                        PointF pBottomStart;
                        if (m_arrPointGauge[i][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                        {
                            pBottomStart = m_arrPointGauge[i][(int)PointIndex.BaseStart].GetMeasurePoint(0);
                            m_stcBlobLead.blnBaseStartFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pBottomStart.X, pBottomStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pBottomStart = new PointF(fBaseCenterX - fWidth / 2, fBottomFixPointY);
                            m_stcBlobLead.blnBaseStartFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pBottomStart.X, pBottomStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Base end point -----------------------------------------
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.BaseEnd].SetGaugePlacement(fBaseCenterX + fWidth / 2,
                                                            fBottomFixPointY,
                                                           fWidth * (m_fPointGaugeToleranceRate * m), 0);

                            m_arrPointGauge[i][(int)PointIndex.BaseEnd].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray_Inspection(fBaseCenterX + fWidth / 2,
                                                                fBottomFixPointY,
                                                               fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.BaseEnd, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray_Inspection(fBaseCenterX + fWidth / 2,
                                                                fBottomFixPointY,
                                                               fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.BaseEnd, i);
                            }
                        }

                        PointF pBottomEnd;
                        if (m_arrPointGauge[i][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                        {
                            pBottomEnd = m_arrPointGauge[i][(int)PointIndex.BaseEnd].GetMeasurePoint(0);
                            m_stcBlobLead.blnBaseEndFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pBottomEnd.X, pBottomEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pBottomEnd = new PointF(fBaseCenterX + fWidth / 2, fBottomFixPointY);
                            m_stcBlobLead.blnBaseEndFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pBottomEnd.X, pBottomEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // Calculate the Base width and center X
                        fBaseWidth = pBottomEnd.X - pBottomStart.X;
                        fBaseCenterX = (pBottomEnd.X + pBottomStart.X) / 2;


                        //Tip
                        // ------- Find Tip Point X -----------------------------------------
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.TipCenter].SetGaugePlacement(objROI.ref_ROITotalX + fLimitCenterX,
                                                              objROI.ref_ROITotalY + fLimitCenterY + (fHeight / 2),
                                                              fHeight * (m_fPointGaugeToleranceRate * m), 90);

                            m_arrPointGauge[i][(int)PointIndex.TipCenter].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray_Inspection(objROI.ref_ROITotalX + fLimitCenterX,
                                                                  objROI.ref_ROITotalY + fLimitCenterY + (fHeight / 2),
                                                                  fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.TipCenter, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray_Inspection(objROI.ref_ROITotalX + fLimitCenterX,
                                                                  objROI.ref_ROITotalY + fLimitCenterY + (fHeight / 2),
                                                                  fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.TipCenter, i);
                            }
                        }

                        if (m_arrPointGauge[i][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                        {
                            fTipCenterX = m_arrPointGauge[i][(int)PointIndex.TipCenter].GetMeasurePointX(0);
                            fTipCenterY = m_arrPointGauge[i][(int)PointIndex.TipCenter].GetMeasurePointY(0);
                            m_stcBlobLead.blnTipCenterFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(fTipCenterX, fTipCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            fTipCenterX = objROI.ref_ROITotalX + fLimitCenterX;
                            fTipCenterY = objROI.ref_ROITotalY + fLimitCenterY + (fHeight / 2);
                            m_stcBlobLead.blnTipCenterFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(fTipCenterX, fTipCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Tip start point -----------------------------------------
                        fBottomFixPointY = fTipCenterY - m_stcBlobLead.intTipInwardOffset;
                        
                        
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.TipStart].SetGaugePlacement(fTipCenterX - fWidth / 2,
                                                                                      fBottomFixPointY,
                                                                                     fWidth * (m_fPointGaugeToleranceRate * m), 180);
                            m_arrPointGauge[i][(int)PointIndex.TipStart].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray_Inspection(fTipCenterX - fWidth / 2,
                                                                                          fBottomFixPointY,
                                                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.TipStart, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray_Inspection(fTipCenterX - fWidth / 2,
                                                          fBottomFixPointY,
                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.TipStart, i);
                            }
                        }

                        if (m_arrPointGauge[i][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                        {
                            pBottomStart = m_arrPointGauge[i][(int)PointIndex.TipStart].GetMeasurePoint(0);
                            m_stcBlobLead.blnTipStartFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pBottomStart.X, pBottomStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pBottomStart = new PointF(fTipCenterX - fWidth / 2, fBottomFixPointY);
                            m_stcBlobLead.blnTipStartFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pBottomStart.X, pBottomStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Tip end point -----------------------------------------
                        
                        
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.TipEnd].SetGaugePlacement(fTipCenterX + fWidth / 2,
                                                        fBottomFixPointY,
                                                       fWidth * (m_fPointGaugeToleranceRate * m), 0);

                            m_arrPointGauge[i][(int)PointIndex.TipEnd].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray_Inspection(fTipCenterX + fWidth / 2,
                                                        fBottomFixPointY,
                                                       fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.TipEnd, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray_Inspection(fTipCenterX + fWidth / 2,
                                                                                        fBottomFixPointY,
                                                                                       fWidth * (m_fPointGaugeToleranceRate * m), 0, (int)PointIndex.TipEnd, i);
                            }
                        }

                        if (m_arrPointGauge[i][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                        {
                            pBottomEnd = m_arrPointGauge[i][(int)PointIndex.TipEnd].GetMeasurePoint(0);
                            m_stcBlobLead.blnTipEndFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pBottomEnd.X, pBottomEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pBottomEnd = new PointF(fTipCenterX + fWidth / 2, fBottomFixPointY);
                            m_stcBlobLead.blnTipEndFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pBottomEnd.X, pBottomEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // Calculate the Tip width and center X
                        fTipWidth = pBottomEnd.X - pBottomStart.X; //fBaseWidth = 
                        fTipCenterX = (pBottomEnd.X + pBottomStart.X) / 2; //fBaseCenterX = 
                        // Base and Tip Length
                        fBaseHeight = fTipCenterY - fBaseCenterY;
                        fTipHeight = fTipCenterY - fBaseCenterY;
                        break;
                    //Left
                    case 4:
                        //Base

                        //float fLeftFixPointX;
                        //PointF pLeftStart;
                        //PointF pLeftEnd;

                        //// ------- Find Base Point Y -----------------------------------------
                        //fBaseCenterX = (m_fCenterX_PackageGaugeM4L - m_fWidth_PackageGaugeM4L / 2) - m_intPkgToBaseTolerance_Left;
                        //AddPointGaugePlacementToArray_Inspection(-1, -1, -1, -(int)PointIndex.TipCenter, i);

                        //m_stcBlobLead.blnBaseCenterFound = false;
                        //m_arrLeadEdgeGaugePoints[i].Add(new PointF(-1, -1));
                        //m_arrLeadEdgeGaugePointsFound[i].Add(false);

                        //SetPointGaugePlacementToArray_Inspection(-1, -1, -1, -1, (int)PointIndex.BaseStart, i);
                        //m_stcBlobLead.blnBaseStartFound = false;
                        //m_arrLeadEdgeGaugePoints[i].Add(new PointF(-1, -1));
                        //m_arrLeadEdgeGaugePointsFound[i].Add(false);

                        //SetPointGaugePlacementToArray_Inspection(-1, -1, -1, -1, (int)PointIndex.BaseEnd, i);
                        //m_stcBlobLead.blnBaseEndFound = false;
                        //m_arrLeadEdgeGaugePoints[i].Add(new PointF(-1, -1));
                        //m_arrLeadEdgeGaugePointsFound[i].Add(false);

                        // ------- Find Base Point Y -----------------------------------------
                        fBaseCenterX = (m_fCenterX_PackageGaugeM4L - m_fWidth_PackageGaugeM4L / 2) - m_intPkgToBaseTolerance_Left;
                        
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.BaseCenter].SetGaugePlacement(fBaseCenterX,
                                                         objROI.ref_ROITotalY + fLimitCenterY,
                                                          fWidth * (m_fPointGaugeToleranceRate * m), 0);

                            m_arrPointGauge[i][(int)PointIndex.BaseCenter].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                            {
                                AddPointGaugePlacementToArray_Inspection(fBaseCenterX,
                                                                 objROI.ref_ROITotalY + fLimitCenterY,
                                                                  fWidth * (m_fPointGaugeToleranceRate * m), (int)PointIndex.BaseCenter, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                AddPointGaugePlacementToArray_Inspection(fBaseCenterX,
                                                                 objROI.ref_ROITotalY + fLimitCenterY,
                                                                  fWidth * (m_fPointGaugeToleranceRate * m), (int)PointIndex.BaseCenter, i);
                            }
                        }
                        if (m_arrPointGauge[i][(int)PointIndex.BaseCenter].ref_intMeasuredPointCount > 0)
                        {
                            //fBaseCenterX = m_arrPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointX(0);
                            fBaseCenterY = m_arrPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointY(0);
                            m_stcBlobLead.blnBaseCenterFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(m_arrPointGauge[i][(int)PointIndex.BaseCenter].GetMeasurePointX(0), fBaseCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            //fBaseCenterX = objROI.ref_ROITotalX + fLimitCenterX + (fWidth / 2);
                            fBaseCenterY = objROI.ref_ROITotalY + fLimitCenterY;
                            m_stcBlobLead.blnBaseCenterFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(fBaseCenterX, fBaseCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Base start point -----------------------------------------
                        float fLeftFixPointX = fBaseCenterX - m_stcBlobLead.intBaseInwardOffset;
                        
                        
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.BaseStart].SetGaugePlacement(fLeftFixPointX,
                                                              fBaseCenterY - fHeight / 2,
                                                             fHeight * (m_fPointGaugeToleranceRate * m), -90);

                            m_arrPointGauge[i][(int)PointIndex.BaseStart].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray_Inspection(fLeftFixPointX,
                                                          fBaseCenterY - fHeight / 2,
                                                         fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.BaseStart, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray_Inspection(fLeftFixPointX,
                                                          fBaseCenterY - fHeight / 2,
                                                         fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.BaseStart, i);
                            }
                        }

                        PointF pLeftStart;
                        if (m_arrPointGauge[i][(int)PointIndex.BaseStart].ref_intMeasuredPointCount > 0)
                        {
                            pLeftStart = m_arrPointGauge[i][(int)PointIndex.BaseStart].GetMeasurePoint(0);
                            m_stcBlobLead.blnBaseStartFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pLeftStart.X, pLeftStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pLeftStart = new PointF(fLeftFixPointX, fBaseCenterY - fHeight / 2);
                            m_stcBlobLead.blnBaseStartFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pLeftStart.X, pLeftStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Base end point -----------------------------------------
                        
                       
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.BaseEnd].SetGaugePlacement(fLeftFixPointX,
                                                        fBaseCenterY + fHeight / 2,
                                                       fHeight * (m_fPointGaugeToleranceRate * m), 90);

                            m_arrPointGauge[i][(int)PointIndex.BaseEnd].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray_Inspection(fLeftFixPointX,
                                                       fBaseCenterY + fHeight / 2,
                                                      fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.BaseEnd, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray_Inspection(fLeftFixPointX,
                                                        fBaseCenterY + fHeight / 2,
                                                       fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.BaseEnd, i);
                            }
                        }

                        PointF pLeftEnd;
                        if (m_arrPointGauge[i][(int)PointIndex.BaseEnd].ref_intMeasuredPointCount > 0)
                        {
                            pLeftEnd = m_arrPointGauge[i][(int)PointIndex.BaseEnd].GetMeasurePoint(0);
                            m_stcBlobLead.blnBaseEndFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pLeftEnd.X, pLeftEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pLeftEnd = new PointF(fLeftFixPointX, fBaseCenterY + fHeight / 2);
                            m_stcBlobLead.blnBaseEndFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pLeftEnd.X, pLeftEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // Calculate the Base width center Y
                        fBaseWidth = pLeftEnd.Y - pLeftStart.Y;
                        fBaseCenterY = (pLeftEnd.Y + pLeftStart.Y) / 2;


                        //Tip
                        // ------- Find Tip Point X -----------------------------------------
                        
                        
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.TipCenter].SetGaugePlacement(objROI.ref_ROITotalX + fLimitCenterX - (fWidth / 2),
                                                        objROI.ref_ROITotalY + fLimitCenterY,
                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180);

                            m_arrPointGauge[i][(int)PointIndex.TipCenter].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray_Inspection(objROI.ref_ROITotalX + fLimitCenterX - (fWidth / 2),
                                                        objROI.ref_ROITotalY + fLimitCenterY,
                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.TipCenter, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray_Inspection(objROI.ref_ROITotalX + fLimitCenterX - (fWidth / 2),
                                                        objROI.ref_ROITotalY + fLimitCenterY,
                                                         fWidth * (m_fPointGaugeToleranceRate * m), 180, (int)PointIndex.TipCenter, i);
                            }
                        }

                        if (m_arrPointGauge[i][(int)PointIndex.TipCenter].ref_intMeasuredPointCount > 0)
                        {
                            fTipCenterX = m_arrPointGauge[i][(int)PointIndex.TipCenter].GetMeasurePointX(0);
                            fTipCenterY = m_arrPointGauge[i][(int)PointIndex.TipCenter].GetMeasurePointY(0);
                            m_stcBlobLead.blnTipCenterFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(fTipCenterX, fTipCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            fTipCenterX = objROI.ref_ROITotalX + fLimitCenterX - (fWidth / 2);
                            fTipCenterY = objROI.ref_ROITotalY + fLimitCenterY;
                            m_stcBlobLead.blnTipCenterFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(fTipCenterX, fTipCenterY));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Tip start point -----------------------------------------
                        fLeftFixPointX = fTipCenterX + m_stcBlobLead.intTipInwardOffset;
                        
                       
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.TipStart].SetGaugePlacement(fLeftFixPointX,
                                                       fTipCenterY - (fHeight / 2),
                                                          fHeight * (m_fPointGaugeToleranceRate * m), -90);

                            m_arrPointGauge[i][(int)PointIndex.TipStart].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray_Inspection(fLeftFixPointX,
                                                        fTipCenterY - (fHeight / 2),
                                                         fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.TipStart, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray_Inspection(fLeftFixPointX,
                                                                                       fTipCenterY - (fHeight / 2),
                                                                                        fHeight * (m_fPointGaugeToleranceRate * m), -90, (int)PointIndex.TipStart, i);
                            }
                        }

                        if (m_arrPointGauge[i][(int)PointIndex.TipStart].ref_intMeasuredPointCount > 0)
                        {
                            pLeftStart = m_arrPointGauge[i][(int)PointIndex.TipStart].GetMeasurePoint(0);
                            m_stcBlobLead.blnTipStartFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pLeftStart.X, pLeftStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pLeftStart = new PointF(fLeftFixPointX, fTipCenterY - (fHeight / 2));
                            m_stcBlobLead.blnTipStartFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pLeftStart.X, pLeftStart.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // ------- Find Tip end point -----------------------------------------
                        
                        for (int m = 1; m <= m_intPointGaugeLoopMax; m++)
                        {
                            m_arrPointGauge[i][(int)PointIndex.TipEnd].SetGaugePlacement(fLeftFixPointX,
                                                           fTipCenterY + (fHeight / 2),
                                                             fHeight * (m_fPointGaugeToleranceRate * m), 90);
                            m_arrPointGauge[i][(int)PointIndex.TipEnd].Measure(objROI);
                            if (m_arrPointGauge[i][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                            {
                                SetPointGaugePlacementToArray_Inspection(fLeftFixPointX,
                                                                    fTipCenterY + (fHeight / 2),
                                                                     fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.TipEnd, i);
                                break;
                            }
                            else if (m == m_intPointGaugeLoopMax)    // record the last gauge if still cannot find point result in last loop
                            {
                                SetPointGaugePlacementToArray_Inspection(fLeftFixPointX,
                                                                    fTipCenterY + (fHeight / 2),
                                                                     fHeight * (m_fPointGaugeToleranceRate * m), 90, (int)PointIndex.TipEnd, i);
                            }
                        }

                        if (m_arrPointGauge[i][(int)PointIndex.TipEnd].ref_intMeasuredPointCount > 0)
                        {
                            pLeftEnd = m_arrPointGauge[i][(int)PointIndex.TipEnd].GetMeasurePoint(0);
                            m_stcBlobLead.blnTipEndFound = true;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pLeftEnd.X, pLeftEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(true);
                        }
                        else
                        {
                            pLeftEnd = new PointF(fLeftFixPointX, fTipCenterY + (fHeight / 2));
                            m_stcBlobLead.blnTipEndFound = false;
                            m_arrLeadEdgeGaugePoints[i].Add(new PointF(pLeftEnd.X, pLeftEnd.Y));
                            m_arrLeadEdgeGaugePointsFound[i].Add(false);
                        }

                        // Calculate the Tip width and center Y
                        fTipWidth = pLeftEnd.Y - pLeftStart.Y; //fBaseWidth = 
                        fTipCenterY = (pLeftEnd.Y + pLeftStart.Y) / 2; //fBaseCenterY = 

                        // Base and Tip Length
                        fBaseHeight = fBaseCenterX - fTipCenterX;
                        fTipHeight = fBaseCenterX - fTipCenterX;
                        break;
                }

                switch (m_stcBlobLead.intGroupID)
                {
                    //Top
                    case 1:
                        if (m_fSampleLeadMinSpanStart == -999)
                            m_fSampleLeadMinSpanStart = fTipCenterY - fTipHeight / 2;
                        else
                        {
                            if (fTipCenterY - fTipHeight / 2 > m_fSampleLeadMinSpanStart)
                                m_fSampleLeadMinSpanStart = fTipCenterY - fTipHeight / 2;
                        }

                        if (m_fSampleLeadMaxSpanStart == -999)
                            m_fSampleLeadMaxSpanStart = fTipCenterY - fTipHeight / 2;
                        else
                        {
                            if (fTipCenterY - fTipHeight / 2 < m_fSampleLeadMaxSpanStart)
                                m_fSampleLeadMaxSpanStart = fTipCenterY - fTipHeight / 2;
                        }
                        break;
                    //Right
                    case 2:
                        if (m_fSampleLeadMinSpanEnd == -999)
                            m_fSampleLeadMinSpanEnd = fTipCenterX + fTipHeight / 2;
                        else
                        {
                            if (fTipCenterX + fTipHeight / 2 < m_fSampleLeadMinSpanEnd)
                                m_fSampleLeadMinSpanEnd = fTipCenterX + fTipHeight / 2;
                        }

                        if (m_fSampleLeadMaxSpanEnd == -999)
                            m_fSampleLeadMaxSpanEnd = fTipCenterX + fTipHeight / 2;
                        else
                        {
                            if (fTipCenterX + fTipHeight / 2 > m_fSampleLeadMaxSpanEnd)
                                m_fSampleLeadMaxSpanEnd = fTipCenterX + fTipHeight / 2;
                        }
                        break;
                    //Bottom
                    case 3:
                        if (m_fSampleLeadMinSpanEnd == -999)
                            m_fSampleLeadMinSpanEnd = fTipCenterY + fTipHeight / 2;
                        else
                        {
                            if (fTipCenterY + fTipHeight / 2 < m_fSampleLeadMinSpanEnd)
                                m_fSampleLeadMinSpanEnd = fTipCenterY + fTipHeight / 2;
                        }

                        if (m_fSampleLeadMaxSpanEnd == -999)
                            m_fSampleLeadMaxSpanEnd = fTipCenterY + fTipHeight / 2;
                        else
                        {
                            if (fTipCenterY + fTipHeight / 2 > m_fSampleLeadMaxSpanEnd)
                                m_fSampleLeadMaxSpanEnd = fTipCenterY + fTipHeight / 2;
                        }
                        break;
                    //left
                    case 4:
                        if (m_fSampleLeadMinSpanStart == -999)
                            m_fSampleLeadMinSpanStart = fTipCenterX - fTipHeight / 2;
                        else
                        {
                            if (fTipCenterX - fTipHeight / 2 > m_fSampleLeadMinSpanStart)
                                m_fSampleLeadMinSpanStart = fTipCenterX - fTipHeight / 2;
                        }

                        if (m_fSampleLeadMaxSpanStart == -999)
                            m_fSampleLeadMaxSpanStart = fTipCenterX - fTipHeight / 2;
                        else
                        {
                            if (fTipCenterX - fTipHeight / 2 < m_fSampleLeadMaxSpanStart)
                                m_fSampleLeadMaxSpanStart = fTipCenterX - fTipHeight / 2;
                        }
                        break;
                }

                m_arrSampleBlobLeads[i].fWidth = fWidth;
                m_arrSampleBlobLeads[i].fHeight = fHeight;
                m_arrSampleBlobLeads[i].intContourIndex = 0;
                m_arrSampleBlobLeads[i].fBaseCenterX = fBaseCenterX - objROI.ref_ROITotalX;
                m_arrSampleBlobLeads[i].fBaseCenterY = fBaseCenterY - objROI.ref_ROITotalY;
                m_arrSampleBlobLeads[i].fTipCenterX = fTipCenterX - objROI.ref_ROITotalX;
                m_arrSampleBlobLeads[i].fTipCenterY = fTipCenterY - objROI.ref_ROITotalY;
                m_arrSampleBlobLeads[i].fBaseWidth = fBaseWidth;
                m_arrSampleBlobLeads[i].fBaseHeight = fBaseHeight;
                m_arrSampleBlobLeads[i].fTipWidth = fTipWidth;
                m_arrSampleBlobLeads[i].fTipHeight = fTipHeight;

                m_arrSampleBlobLeads[i].blnTipCenterFound = m_stcBlobLead.blnTipCenterFound;
                m_arrSampleBlobLeads[i].blnTipStartFound = m_stcBlobLead.blnTipStartFound;
                m_arrSampleBlobLeads[i].blnTipEndFound = m_stcBlobLead.blnTipEndFound;
                m_arrSampleBlobLeads[i].blnBaseCenterFound = m_stcBlobLead.blnBaseCenterFound;
                m_arrSampleBlobLeads[i].blnBaseStartFound = m_stcBlobLead.blnBaseStartFound;
                m_arrSampleBlobLeads[i].blnBaseEndFound = m_stcBlobLead.blnBaseEndFound;

                // Collect sample blobs data in MM
                m_arrSampleBlobLeads[i].fWidthMM = fWidth / m_fMMToPixelXValue;
                m_arrSampleBlobLeads[i].fHeightMM = fHeight / m_fMMToPixelYValue;


                // Check base/tip Width
                fBaseWidthMM = fBaseWidth / m_fMMToPixelXValue;
                fTipWidthMM = fTipWidth / m_fMMToPixelXValue;

                //2021-04-11 ZJYEOH : Need to use calibration data based on m_intLeadROIDirection
                switch (m_intLeadROIDirection)
                {
                    case 1:
                    case 3:
                        //// Collect sample blobs data in MM
                        //m_arrSampleBlobLeads[i].fWidthMM = fWidth / m_fMMToPixelXValue;
                        //m_arrSampleBlobLeads[i].fHeightMM = fHeight / m_fMMToPixelYValue;


                        // Check base/tip Width
                        fBaseWidthMM = fBaseWidth / m_fMMToPixelXValue;
                        fTipWidthMM = fTipWidth / m_fMMToPixelXValue;
                        break;
                    case 2:
                    case 4:
                        //// Collect sample blobs data in MM
                        //m_arrSampleBlobLeads[i].fWidthMM = fWidth / m_fMMToPixelYValue;
                        //m_arrSampleBlobLeads[i].fHeightMM = fHeight / m_fMMToPixelXValue;


                        // Check base/tip Width
                        fBaseWidthMM = fBaseWidth / m_fMMToPixelYValue;
                        fTipWidthMM = fTipWidth / m_fMMToPixelYValue;
                        break;
                }

                if (!MatchTemplateObjectsWidth(i, fTipWidthMM + m_stcBlobLead.fWidthOffset))
                {
                    if ((m_intFailOptionMask & 0x40) > 0)
                    {
                        m_arrSampleBlobLeads[i].intFailMask |= 0x40;
                        m_intFailResultMask |= 0x40;
                    }
                }

                // Check base/tip Height
                fBaseHeightMM = fBaseHeight / m_fMMToPixelYValue;
                fTipHeightMM = fTipHeight / m_fMMToPixelYValue;
                //2021-04-11 ZJYEOH : Need to use calibration data based on m_intLeadROIDirection
                switch (m_intLeadROIDirection)
                {
                    case 1:
                    case 3:
                        // Check base/tip Height
                        fBaseHeightMM = fBaseHeight / m_fMMToPixelYValue;
                        fTipHeightMM = fTipHeight / m_fMMToPixelYValue;
                        break;
                    case 2:
                    case 4:
                        // Check base/tip Height
                        fBaseHeightMM = fBaseHeight / m_fMMToPixelXValue;
                        fTipHeightMM = fTipHeight / m_fMMToPixelXValue;
                        break;
                }

                if (!MatchTemplateObjectsHeight(i, fTipHeightMM + m_stcBlobLead.fLengthOffset))
                {
                    if ((m_intFailOptionMask & 0x80) > 0)
                    {
                        m_arrSampleBlobLeads[i].intFailMask |= 0x80;
                        m_intFailResultMask |= 0x80;
                    }
                }

                // Add calibrate off set value to measurement
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                //Tip offset value here
                float fMaxTipOffSet = 0;
                //PointF p1 = new PointF();
                //PointF p2 = new PointF();

                //switch (m_stcBlobLead.intGroupID)
                //{
                //    case 1:
                //        p1 = new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY - (m_stcBlobLead.fTipHeight / 2));
                //        p2 = new PointF(fTipCenterX, fTipCenterY - (fTipHeight / 2));
                //        break;
                //    case 2:
                //        p1 = new PointF(m_stcBlobLead.fTipCenterX + (m_stcBlobLead.fTipWidth / 2), m_stcBlobLead.fTipCenterY);
                //        p2 = new PointF(fTipCenterX + (fTipWidth / 2), fTipCenterY);
                //        break;
                //    case 3:
                //        p1 = new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY + (m_stcBlobLead.fTipHeight / 2));
                //        p2 = new PointF(fTipCenterX, fTipCenterY + (fTipHeight / 2));
                //        break;
                //    case 4:
                //        p1 = new PointF(m_stcBlobLead.fTipCenterX - (m_stcBlobLead.fTipWidth / 2), m_stcBlobLead.fTipCenterY);
                //        p2 = new PointF(fTipCenterX - (fTipWidth / 2), fTipCenterY);
                //        break;
                //}

                //fMaxTipOffSet = Math2.GetDistanceBtw2Points(p1, p2);

                float fMaxSkew = 0;
                switch (m_stcBlobLead.intGroupID)
                {
                    case 1:
                    case 3:
                        fMaxTipOffSet = Math.Abs(m_stcBlobLead.fXDistance - (fTipCenterX - m_fUnitAverageCenterX)) / m_fMMToPixelXValue;

                        if (m_arrSampleBlobLeads[i].blnBaseStartFound || m_arrSampleBlobLeads[i].blnBaseEndFound)
                            fMaxSkew = Math.Abs(fBaseCenterX - fTipCenterX) / m_fMMToPixelXValue; //2019-10-11 ZJYEOH : Lead Offset or bend --> Compare the center point between base and tip
                        else
                            fMaxSkew = -999;
                        break;
                    case 2:
                    case 4:
                        fMaxTipOffSet = Math.Abs(m_stcBlobLead.fYDistance - (fTipCenterY - m_fUnitAverageCenterY)) / m_fMMToPixelYValue;

                        if (m_arrSampleBlobLeads[i].blnBaseStartFound || m_arrSampleBlobLeads[i].blnBaseEndFound)
                            fMaxSkew = Math.Abs(fBaseCenterY - fTipCenterY) / m_fMMToPixelYValue; //2019-10-11 ZJYEOH : Lead Offset or bend --> Compare the center point between base and tip
                        else
                            fMaxSkew = -999;
                        break;
                }

                if (fMaxTipOffSet > m_stcBlobLead.fOffSet)
                {
                    // Tip OffSet fail
                    if ((m_intFailOptionMask & 0x100) > 0)
                    {
                        m_arrSampleBlobLeads[i].intFailMask |= 0x100;
                        m_intFailResultMask |= 0x100;
                    }
                }

                if (fMaxSkew > m_stcBlobLead.fSkew || (!m_arrSampleBlobLeads[i].blnBaseStartFound && !m_arrSampleBlobLeads[i].blnBaseEndFound))// && !m_blnWantUsePkgToBaseTolerance)
                {
                    // Skew fail
                    if ((m_intFailOptionMask & 0x0800) > 0)
                    {
                        m_arrSampleBlobLeads[i].intFailMask |= 0x8000;
                        m_intFailResultMask |= 0x8000;
                    }
                }

                m_arrSampleBlobLeads[i].fOffSetMM = fMaxTipOffSet;
                m_arrSampleBlobLeads[i].fSkewMM = fMaxSkew;
                m_arrSampleBlobLeads[i].fBaseWidthMM = fBaseWidthMM + m_stcBlobLead.fWidthOffset;
                m_arrSampleBlobLeads[i].fBaseHeightMM = fBaseHeightMM + m_stcBlobLead.fLengthOffset;
                m_arrSampleBlobLeads[i].fTipWidthMM = fTipWidthMM + m_stcBlobLead.fWidthOffset;
                m_arrSampleBlobLeads[i].fTipHeightMM = fTipHeightMM + m_stcBlobLead.fLengthOffset;
            }
            #endregion
        }

        /// <summary>
        /// This function will 3 chances to increase Point Gauge Length if no found any Point
        /// </summary>
        /// <param name="objROI"></param>
        //private void CheckDimension_Old(ROI objROI)
        //{
        //    #region ----- Width, Height, OffSet -----

        //    float fWidth, fHeight, fTipCenterX, fTipCenterY, fBaseCenterX, fBaseCenterY,
        //        fBaseWidth, fTipWidth, fBaseHeight, fTipHeight,
        //        fBaseWidthMM, fTipWidthMM, fBaseHeightMM, fTipHeightMM;

        //    for (int i = 0; i < m_arrSampleBlobLeads.Length; i++)
        //    {
        //        fWidth = fHeight = 0;
        //        fBaseWidth = fTipWidth = fBaseHeight = fTipHeight = 0;

        //        ////Skip if fail reference point
        //        if ((m_arrSampleBlobLeads[i].intFailMask & 0x01) > 0)
        //            continue;

        //        ////Skip if join Lead
        //        if ((m_arrSampleBlobLeads[i].intFailMask & 0x02) > 0)
        //            continue;

        //        ////Skip if missing Lead
        //        if ((m_arrSampleBlobLeads[i].intFailMask & 0x04) > 0)
        //            continue;

        //        fWidth = m_arrSampleBlobLeads[i].fWidth;
        //        fHeight = m_arrSampleBlobLeads[i].fHeight;
        //        fBaseWidth = m_arrSampleBlobLeads[i].fBaseWidth;
        //        fBaseHeight = m_arrSampleBlobLeads[i].fBaseHeight;
        //        fTipWidth = m_arrSampleBlobLeads[i].fTipWidth;
        //        fTipHeight = m_arrSampleBlobLeads[i].fTipHeight;
        //        fBaseCenterX = m_arrSampleBlobLeads[i].fBaseCenterX;
        //        fBaseCenterY = m_arrSampleBlobLeads[i].fBaseCenterY;
        //        fTipCenterX = m_arrSampleBlobLeads[i].fTipCenterX;
        //        fTipCenterY = m_arrSampleBlobLeads[i].fTipCenterY;

        //        float fLimitCenterX = m_arrSampleBlobLeads[i].fCenterX;
        //        float fLimitCenterY = m_arrSampleBlobLeads[i].fCenterY;
        //        float fNewCenterX = fLimitCenterX;
        //        float fNewCenterY = fLimitCenterY;
        //        int intFixPointXY;

        //        //2019-10-17 ZJYEOH : Measure point gauge here because need matching first just can assign tip/base offset value to individual lead.
        //        m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
        //        switch (m_stcBlobLead.intGroupID)
        //        {
        //            //Top
        //            case 1:
        //                //2019-10-17 ZJYEOH : Measure length first because need the position to assign tip/base measure location
        //                //Length
        //                intFixPointXY = (int)Math.Round(fLimitCenterX, 0, MidpointRounding.AwayFromZero);

        //                UpdateBlobSizeAndCenterPointWithGauge(objROI, fLimitCenterX, fLimitCenterY,
        //                        ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, false, intFixPointXY);

        //                //Base
        //                fBaseWidth = fWidth;
        //                intFixPointXY = (int)Math.Round(fNewCenterY + (fHeight / 2) - m_stcBlobLead.intBaseInwardOffset, 0, MidpointRounding.AwayFromZero);

        //                if (!m_blnWantUseGaugeMeasureLeadDimension)
        //                {
        //                    Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
        //                            ref fBaseWidth, ref fHeight, ref fBaseCenterX, ref fBaseCenterY, m_intThresholdValue, true, true, intFixPointXY);
        //                }
        //                else
        //                {
        //                    UpdateBlobSizeAndCenterPointWithGauge(objROI, fLimitCenterX, fLimitCenterY,
        //                        ref fBaseWidth, ref fHeight, ref fBaseCenterX, ref fBaseCenterY, m_intThresholdValue, true, intFixPointXY);
        //                }

        //                //Tip
        //                fTipWidth = fWidth;
        //                intFixPointXY = (int)Math.Round(fNewCenterY - (fHeight / 2) + m_stcBlobLead.intTipInwardOffset, 0, MidpointRounding.AwayFromZero);

        //                if (!m_blnWantUseGaugeMeasureLeadDimension)
        //                {
        //                    Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
        //                        ref fTipWidth, ref fHeight, ref fTipCenterX, ref fTipCenterY, m_intThresholdValue, true, false, intFixPointXY);
        //                }
        //                else
        //                {
        //                    UpdateBlobSizeAndCenterPointWithGauge(objROI, fLimitCenterX, fLimitCenterY,
        //                        ref fTipWidth, ref fHeight, ref fTipCenterX, ref fTipCenterY, m_intThresholdValue, true, intFixPointXY);
        //                }

        //                fTipCenterY = fNewCenterY - fHeight / 2;
        //                fTipHeight = fHeight;
        //                fBaseCenterY = fNewCenterY + fHeight / 2;
        //                fBaseHeight = fHeight;
        //                break;
        //            //Right
        //            case 2:
        //                //2019-10-17 ZJYEOH : Measure length first because need the position to assign tip/base measure location
        //                //Length
        //                intFixPointXY = (int)Math.Round(fLimitCenterY, 0, MidpointRounding.AwayFromZero);

        //                UpdateBlobSizeAndCenterPointWithGauge(objROI, fLimitCenterX, fLimitCenterY,
        //                        ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, true, intFixPointXY);

        //                //Base
        //                fBaseHeight = fHeight;
        //                intFixPointXY = (int)Math.Round(fNewCenterX - (fWidth / 2) + m_stcBlobLead.intBaseInwardOffset, 0, MidpointRounding.AwayFromZero);

        //                if (!m_blnWantUseGaugeMeasureLeadDimension)
        //                {
        //                    Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
        //                        ref fWidth, ref fBaseHeight, ref fBaseCenterX, ref fBaseCenterY, m_intThresholdValue, false, false, intFixPointXY);
        //                }
        //                else
        //                {
        //                    UpdateBlobSizeAndCenterPointWithGauge(objROI, fLimitCenterX, fLimitCenterY,
        //                        ref fWidth, ref fBaseHeight, ref fBaseCenterX, ref fBaseCenterY, m_intThresholdValue, false, intFixPointXY);
        //                }

        //                //Tip
        //                fTipHeight = fHeight;
        //                intFixPointXY = (int)Math.Round(fNewCenterX + (fWidth / 2) - m_stcBlobLead.intTipInwardOffset, 0, MidpointRounding.AwayFromZero);

        //                if (!m_blnWantUseGaugeMeasureLeadDimension)
        //                {
        //                    Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
        //                        ref fWidth, ref fTipHeight, ref fTipCenterX, ref fTipCenterY, m_intThresholdValue, false, true, intFixPointXY);
        //                }
        //                else
        //                {
        //                    UpdateBlobSizeAndCenterPointWithGauge(objROI, fLimitCenterX, fLimitCenterY,
        //                        ref fWidth, ref fTipHeight, ref fTipCenterX, ref fTipCenterY, m_intThresholdValue, false, intFixPointXY);
        //                }

        //                fTipCenterX = fNewCenterX + fWidth / 2;
        //                fTipWidth = fWidth;
        //                fBaseCenterX = fNewCenterX - fWidth / 2;
        //                fBaseWidth = fWidth;
        //                break;
        //            //Bottom
        //            case 3:
        //                //2019-10-17 ZJYEOH : Measure length first because need the position to assign tip/base measure location
        //                //Length
        //                intFixPointXY = (int)Math.Round(fLimitCenterX, 0, MidpointRounding.AwayFromZero);

        //                UpdateBlobSizeAndCenterPointWithGauge(objROI, fLimitCenterX, fLimitCenterY,
        //                        ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, false, intFixPointXY);

        //                //Base
        //                fBaseWidth = fWidth;
        //                intFixPointXY = (int)Math.Round(fNewCenterY - (fHeight / 2) + m_stcBlobLead.intBaseInwardOffset, 0, MidpointRounding.AwayFromZero);

        //                if (!m_blnWantUseGaugeMeasureLeadDimension)
        //                {
        //                    Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
        //                        ref fBaseWidth, ref fHeight, ref fBaseCenterX, ref fBaseCenterY, m_intThresholdValue, true, false, intFixPointXY);
        //                }
        //                else
        //                {
        //                    UpdateBlobSizeAndCenterPointWithGauge(objROI, fLimitCenterX, fLimitCenterY,
        //                        ref fBaseWidth, ref fHeight, ref fBaseCenterX, ref fBaseCenterY, m_intThresholdValue, true, intFixPointXY);
        //                }
        //                //Tip
        //                fTipWidth = fWidth;
        //                intFixPointXY = (int)Math.Round(fNewCenterY + (fHeight / 2) - m_stcBlobLead.intTipInwardOffset, 0, MidpointRounding.AwayFromZero);

        //                if (!m_blnWantUseGaugeMeasureLeadDimension)
        //                {
        //                    Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
        //                        ref fTipWidth, ref fHeight, ref fTipCenterX, ref fTipCenterY, m_intThresholdValue, true, true, intFixPointXY);
        //                }
        //                else
        //                {
        //                    UpdateBlobSizeAndCenterPointWithGauge(objROI, fLimitCenterX, fLimitCenterY,
        //                        ref fTipWidth, ref fHeight, ref fTipCenterX, ref fTipCenterY, m_intThresholdValue, true, intFixPointXY);
        //                }

        //                fTipCenterY = fNewCenterY + fHeight / 2;
        //                fTipHeight = fHeight;
        //                fBaseCenterY = fNewCenterY - fHeight / 2;
        //                fBaseHeight = fHeight;
        //                break;
        //            //Left
        //            case 4:
        //                //2019-10-17 ZJYEOH : Measure length first because need the position to assign tip/base measure location
        //                //Length
        //                intFixPointXY = (int)Math.Round(fLimitCenterY, 0, MidpointRounding.AwayFromZero);

        //                UpdateBlobSizeAndCenterPointWithGauge(objROI, fLimitCenterX, fLimitCenterY,
        //                        ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue, true, intFixPointXY);

        //                //Base
        //                fBaseHeight = fHeight;
        //                intFixPointXY = (int)Math.Round(fNewCenterX + (fWidth / 2) - m_stcBlobLead.intBaseInwardOffset, 0, MidpointRounding.AwayFromZero);

        //                if (!m_blnWantUseGaugeMeasureLeadDimension)
        //                {
        //                    Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
        //                        ref fWidth, ref fBaseHeight, ref fBaseCenterX, ref fBaseCenterY, m_intThresholdValue, false, true, intFixPointXY);
        //                }
        //                else
        //                {
        //                    UpdateBlobSizeAndCenterPointWithGauge(objROI, fLimitCenterX, fLimitCenterY,
        //                        ref fWidth, ref fBaseHeight, ref fBaseCenterX, ref fBaseCenterY, m_intThresholdValue, false, intFixPointXY);
        //                }

        //                //Tip
        //                fTipHeight = fHeight;
        //                intFixPointXY = (int)Math.Round(fNewCenterX - (fWidth / 2) + m_stcBlobLead.intTipInwardOffset, 0, MidpointRounding.AwayFromZero);

        //                if (!m_blnWantUseGaugeMeasureLeadDimension)
        //                {
        //                    Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
        //                        ref fWidth, ref fTipHeight, ref fTipCenterX, ref fTipCenterY, m_intThresholdValue, false, false, intFixPointXY);
        //                }
        //                else
        //                {
        //                    UpdateBlobSizeAndCenterPointWithGauge(objROI, fLimitCenterX, fLimitCenterY,
        //                        ref fWidth, ref fTipHeight, ref fTipCenterX, ref fTipCenterY, m_intThresholdValue, false, intFixPointXY);
        //                }

        //                fTipCenterX = fNewCenterX - fWidth / 2;
        //                fTipWidth = fWidth;
        //                fBaseCenterX = fNewCenterX + fWidth / 2;
        //                fBaseWidth = fWidth;
        //                break;
        //        }
        //        m_arrSampleBlobLeads[i].fWidth = fWidth;
        //        m_arrSampleBlobLeads[i].fHeight = fHeight;
        //        m_arrSampleBlobLeads[i].intContourIndex = 0;
        //        m_arrSampleBlobLeads[i].fBaseCenterX = fBaseCenterX;
        //        m_arrSampleBlobLeads[i].fBaseCenterY = fBaseCenterY;
        //        m_arrSampleBlobLeads[i].fTipCenterX = fTipCenterX;
        //        m_arrSampleBlobLeads[i].fTipCenterY = fTipCenterY;
        //        m_arrSampleBlobLeads[i].fBaseWidth = fBaseWidth;
        //        m_arrSampleBlobLeads[i].fBaseHeight = fBaseHeight;
        //        m_arrSampleBlobLeads[i].fTipWidth = fTipWidth;
        //        m_arrSampleBlobLeads[i].fTipHeight = fTipHeight;

        //        // Collect sample blobs data in MM
        //        m_arrSampleBlobLeads[i].fWidthMM = fWidth / m_fMMToPixelXValue;
        //        m_arrSampleBlobLeads[i].fHeightMM = fHeight / m_fMMToPixelYValue;


        //        // Check base/tip Width
        //        fBaseWidthMM = fBaseWidth / m_fMMToPixelXValue;
        //        fTipWidthMM = fTipWidth / m_fMMToPixelXValue;
        //        if (!MatchTemplateObjectsWidth(i, fTipWidthMM + m_stcBlobLead.fWidthOffset))
        //        {
        //            if ((m_intFailOptionMask & 0x40) > 0)
        //            {
        //                m_arrSampleBlobLeads[i].intFailMask |= 0x40;
        //                m_intFailResultMask |= 0x40;
        //            }
        //        }

        //        // Check base/tip Height
        //        fBaseHeightMM = fBaseHeight / m_fMMToPixelYValue;
        //        fTipHeightMM = fTipHeight / m_fMMToPixelYValue;
        //        if (!MatchTemplateObjectsHeight(i, fTipHeightMM + m_stcBlobLead.fLengthOffset))
        //        {
        //            if ((m_intFailOptionMask & 0x80) > 0)
        //            {
        //                m_arrSampleBlobLeads[i].intFailMask |= 0x80;
        //                m_intFailResultMask |= 0x80;
        //            }
        //        }

        //        // Add calibrate off set value to measurement
        //        m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

        //        //Tip offset value here
        //        float fMaxTipOffSet = 0;
        //        //PointF p1 = new PointF();
        //        //PointF p2 = new PointF();

        //        //switch (m_stcBlobLead.intGroupID)
        //        //{
        //        //    case 1:
        //        //        p1 = new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY - (m_stcBlobLead.fTipHeight / 2));
        //        //        p2 = new PointF(fTipCenterX, fTipCenterY - (fTipHeight / 2));
        //        //        break;
        //        //    case 2:
        //        //        p1 = new PointF(m_stcBlobLead.fTipCenterX + (m_stcBlobLead.fTipWidth / 2), m_stcBlobLead.fTipCenterY);
        //        //        p2 = new PointF(fTipCenterX + (fTipWidth / 2), fTipCenterY);
        //        //        break;
        //        //    case 3:
        //        //        p1 = new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY + (m_stcBlobLead.fTipHeight / 2));
        //        //        p2 = new PointF(fTipCenterX, fTipCenterY + (fTipHeight / 2));
        //        //        break;
        //        //    case 4:
        //        //        p1 = new PointF(m_stcBlobLead.fTipCenterX - (m_stcBlobLead.fTipWidth / 2), m_stcBlobLead.fTipCenterY);
        //        //        p2 = new PointF(fTipCenterX - (fTipWidth / 2), fTipCenterY);
        //        //        break;
        //        //}

        //        //fMaxTipOffSet = Math2.GetDistanceBtw2Points(p1, p2);

        //        //switch (m_stcBlobLead.intGroupID)
        //        //{
        //        //    case 1:
        //        //    case 3:
        //        //        fMaxTipOffSet = Math.Abs(m_stcBlobLead.fTipCenterX - fTipCenterX);
        //        //        break;
        //        //    case 2:
        //        //    case 4:
        //        //        fMaxTipOffSet = Math.Abs(m_stcBlobLead.fTipCenterY - fTipCenterY);
        //        //        break;
        //        //}

        //        switch (m_stcBlobLead.intGroupID)
        //        {
        //            case 1:
        //            case 3:
        //                fMaxTipOffSet = Math.Abs(fBaseCenterX - fTipCenterX) / m_fMMToPixelXValue; //2019-10-11 ZJYEOH : Lead Offset or bend --> Compare the center point between base and tip
        //                break;
        //            case 2:
        //            case 4:
        //                fMaxTipOffSet = Math.Abs(fBaseCenterY - fTipCenterY) / m_fMMToPixelYValue; //2019-10-11 ZJYEOH : Lead Offset or bend --> Compare the center point between base and tip
        //                break;
        //        }

        //        //fMaxTipOffSet = fMaxTipOffSet / m_fMMToPixelXValue;

        //        if (fMaxTipOffSet > m_stcBlobLead.fOffSet)
        //        {
        //            // Tip OffSet fail
        //            if ((m_intFailOptionMask & 0x100) > 0)
        //            {
        //                m_arrSampleBlobLeads[i].intFailMask |= 0x100;
        //                m_intFailResultMask |= 0x100;
        //            }
        //        }

        //        m_arrSampleBlobLeads[i].fOffSetMM = fMaxTipOffSet;
        //        m_arrSampleBlobLeads[i].fBaseWidthMM = fBaseWidthMM;
        //        m_arrSampleBlobLeads[i].fBaseHeightMM = fBaseHeightMM;
        //        m_arrSampleBlobLeads[i].fTipWidthMM = fTipWidthMM;
        //        m_arrSampleBlobLeads[i].fTipHeightMM = fTipHeightMM;
        //    }
        //    #endregion
        //}

        private void CheckDimension_Lead3D(ROI objROI)
        {
            #region ----- Width, Height, OffSet -----

            float fWidth, fHeight, fLimitCenterX, fLimitCenterY,
                fNewCenterX, fNewCenterY, fWidthMM, fHeightMM,
                fTipCenterX, fTipCenterY, fBaseCenterX, fBaseCenterY,
                fBaseWidth, fTipWidth, fBaseHeight, fTipHeight,
                fBaseWidthMM, fTipWidthMM, fBaseHeightMM, fTipHeightMM;

            for (int i = 0; i < m_arrSampleBlobLeads.Length; i++)
            {
                fWidth = fHeight = fLimitCenterX = fLimitCenterY = 0;
                fBaseWidth = fTipWidth = fBaseHeight = fTipHeight = 0;

                ////Skip if fail reference point
                if ((m_arrSampleBlobLeads[i].intFailMask & 0x01) > 0)
                    continue;

                ////Skip if join Lead
                if ((m_arrSampleBlobLeads[i].intFailMask & 0x02) > 0)
                    continue;

                ////Skip if missing Lead
                if ((m_arrSampleBlobLeads[i].intFailMask & 0x04) > 0)
                    continue;

                fLimitCenterX = m_arrSampleBlobLeads[i].fCenterX;
                fLimitCenterY = m_arrSampleBlobLeads[i].fCenterY;
                fWidth = m_arrSampleBlobLeads[i].fWidth;
                fHeight = m_arrSampleBlobLeads[i].fHeight;
                fBaseWidth = m_arrSampleBlobLeads[i].fBaseWidth;
                fBaseHeight = m_arrSampleBlobLeads[i].fBaseHeight;
                fTipWidth = m_arrSampleBlobLeads[i].fTipWidth;
                fTipHeight = m_arrSampleBlobLeads[i].fTipHeight;

                fBaseCenterX = m_arrSampleBlobLeads[i].fBaseCenterX;
                fBaseCenterY = m_arrSampleBlobLeads[i].fBaseCenterY;
                fTipCenterX = m_arrSampleBlobLeads[i].fTipCenterX;
                fTipCenterY = m_arrSampleBlobLeads[i].fTipCenterY;

                fNewCenterX = fLimitCenterX;
                fNewCenterY = fLimitCenterY;

                // Check base/tip Width
                fBaseWidthMM = fBaseWidth / m_fMMToPixelXValue;
                fTipWidthMM = fTipWidth / m_fMMToPixelXValue;
                if (!MatchTemplateObjectsWidth(i, fTipWidthMM))
                {
                    if ((m_intFailOptionMask & 0x40) > 0)
                    {
                        m_arrSampleBlobLeads[i].intFailMask |= 0x40;
                        m_intFailResultMask |= 0x40;
                    }
                }

                // Check base/tip Height
                fBaseHeightMM = fBaseHeight / m_fMMToPixelYValue;
                fTipHeightMM = fTipHeight / m_fMMToPixelYValue;
                if (!MatchTemplateObjectsHeight(i, fTipHeightMM))
                {
                    if ((m_intFailOptionMask & 0x80) > 0)
                    {
                        m_arrSampleBlobLeads[i].intFailMask |= 0x80;
                        m_intFailResultMask |= 0x80;
                    }
                }


                // Add calibrate off set value to measurement
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                //float fMaxOffSet;
                //fMaxOffSet = Math.Max(Math.Abs(m_stcBlobLead.fXDistance - (objROI.ref_ROITotalX + fNewCenterX - m_pUnitCenterPoint.X)) / m_fMMToPixelXValue,
                //                                Math.Abs(m_stcBlobLead.fYDistance - (objROI.ref_ROITotalY + fNewCenterY - m_pUnitCenterPoint.Y)) / m_fMMToPixelYValue);

                //if (fMaxOffSet > m_stcBlobLead.fOffSet)
                //{
                //    // Off Set
                //    if ((m_intFailOptionMask & 0x100) > 0)
                //    {
                //        m_arrSampleBlobLeads[i].intFailMask |= 0x100;
                //        m_intFailResultMask |= 0x100;
                //    }
                //}

                //Tip offset value here
                float fMaxTipOffSet;
                Line objLine1 = new Line();
                Line objLine2 = new Line();
                PointF p1 = new PointF();
                PointF p2 = new PointF();
                PointF p3 = new PointF();
                PointF p4 = new PointF();

                switch (m_stcBlobLead.intGroupID)
                {
                    case 1:
                        p1 = new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY - (m_stcBlobLead.fHeight / 2));
                        p2 = new PointF(m_stcBlobLead.fBaseCenterX, m_stcBlobLead.fBaseCenterY + (m_stcBlobLead.fHeight / 2));
                        p3 = new PointF(fTipCenterX, fTipCenterY - (fHeight / 2));
                        p4 = new PointF(fBaseCenterX, fBaseCenterY + (fHeight / 2));
                        break;
                    case 2:
                        p1 = new PointF(m_stcBlobLead.fBaseCenterX - (m_stcBlobLead.fWidth / 2), m_stcBlobLead.fBaseCenterY);
                        p2 = new PointF(m_stcBlobLead.fTipCenterX + (m_stcBlobLead.fWidth / 2), m_stcBlobLead.fTipCenterY);
                        p3 = new PointF(fBaseCenterX - (fWidth / 2), fBaseCenterY);
                        p4 = new PointF(fTipCenterX + (fWidth / 2), fTipCenterY);
                        break;
                    case 3:
                        p1 = new PointF(m_stcBlobLead.fBaseCenterX, m_stcBlobLead.fBaseCenterY - (m_stcBlobLead.fHeight / 2));
                        p2 = new PointF(m_stcBlobLead.fTipCenterX, m_stcBlobLead.fTipCenterY + (m_stcBlobLead.fHeight / 2));
                        p3 = new PointF(fBaseCenterX, fBaseCenterY - (fHeight / 2));
                        p4 = new PointF(fTipCenterX, fTipCenterY + (fHeight / 2));
                        break;
                    case 4:
                        p1 = new PointF(m_stcBlobLead.fTipCenterX - (m_stcBlobLead.fWidth / 2), m_stcBlobLead.fTipCenterY);
                        p2 = new PointF(m_stcBlobLead.fBaseCenterX + (m_stcBlobLead.fWidth / 2), m_stcBlobLead.fBaseCenterY);
                        p3 = new PointF(fTipCenterX - (fWidth / 2), fTipCenterY);
                        p4 = new PointF(fBaseCenterX + (fWidth / 2), fBaseCenterY);
                        break;
                }


                objLine1.CalculateStraightLine(p1, p2);
                objLine2.CalculateStraightLine(p3, p4);

                fMaxTipOffSet = Math2.GetDistanceBtw2Points(p1, p2);
                fMaxTipOffSet = fMaxTipOffSet / m_fMMToPixelXValue;

                if (fMaxTipOffSet > m_stcBlobLead.fOffSet)
                {
                    // Tip OffSet fail
                    if ((m_intFailOptionMask & 0x100) > 0)
                    {
                        m_arrSampleBlobLeads[i].intFailMask |= 0x100;
                        m_intFailResultMask |= 0x100;
                    }
                }

                m_arrSampleBlobLeads[i].fOffSetMM = fMaxTipOffSet;
                m_arrSampleBlobLeads[i].fBaseWidthMM = fBaseWidthMM;
                m_arrSampleBlobLeads[i].fBaseHeightMM = fBaseHeightMM;
                m_arrSampleBlobLeads[i].fTipWidthMM = fTipWidthMM;
                m_arrSampleBlobLeads[i].fTipHeightMM = fTipHeightMM;
                m_arrSampleBlobLeads[i].fCenterX = fNewCenterX;
                m_arrSampleBlobLeads[i].fCenterY = fNewCenterY;
                m_arrSampleBlobLeads[i].fStartX = fNewCenterX - fWidth / 2;
                m_arrSampleBlobLeads[i].fStartY = fNewCenterY - fHeight / 2;
                m_arrSampleBlobLeads[i].fEndX = fNewCenterX + fWidth / 2;
                m_arrSampleBlobLeads[i].fEndY = fNewCenterY + fHeight / 2;

            }
            #endregion
        }

        private void CheckVariance(ROI objROI)
        {
            float fStartX, fStartY, fEndX, fEndY;
            float fMinLength = float.MaxValue;
            float fMaxLength = 0;

            for (int i = 0; i < m_arrSampleBlobLeads.Length; i++)
            {
                //Skip if Joint Lead
                if ((m_arrSampleBlobLeads[i].intFailMask & 0x02) > 0)
                    continue;

                //Skip if missing Lead
                if ((m_arrSampleBlobLeads[i].intFailMask & 0x04) > 0)
                    continue;

                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                ////Top and bottom height=length
                //if (m_stcBlobLead.intLengthMode == 1)
                //{
                //    if (m_arrSampleBlobLeads[i].fCenterY == -999)
                //        continue;

                //    fStartY = m_arrSampleBlobLeads[i].fCenterY - m_arrSampleBlobLeads[i].fHeight / 2;
                //    fEndY = m_arrSampleBlobLeads[i].fCenterY + m_arrSampleBlobLeads[i].fHeight / 2;

                //    if (fEndY - fStartY > fMaxLength)
                //        fMaxLength = fEndY - fStartY;

                //    if (fEndY - fStartY < fMinLength)
                //        fMinLength = fEndY - fStartY;
                //}
                //else
                //{
                //    if (m_arrSampleBlobLeads[i].fCenterX == -999)
                //        continue;

                //    fStartX = m_arrSampleBlobLeads[i].fCenterX - m_arrSampleBlobLeads[i].fWidth / 2;
                //    fEndX = m_arrSampleBlobLeads[i].fCenterX + m_arrSampleBlobLeads[i].fWidth / 2;

                //    if (fEndX - fStartX > fMaxLength)
                //        fMaxLength = fEndX - fStartX;

                //    if (fEndX - fStartX < fMinLength)
                //        fMinLength = fEndX - fStartX;
                //}

                switch (m_intLeadROIDirection)
                {
                    case 1:
                        if (m_arrSampleBlobLeads[i].fBaseCenterY - m_arrSampleBlobLeads[i].fTipCenterY > fMaxLength)
                            fMaxLength = m_arrSampleBlobLeads[i].fBaseCenterY - m_arrSampleBlobLeads[i].fTipCenterY;

                        if (m_arrSampleBlobLeads[i].fBaseCenterY - m_arrSampleBlobLeads[i].fTipCenterY < fMinLength)
                            fMinLength = m_arrSampleBlobLeads[i].fBaseCenterY - m_arrSampleBlobLeads[i].fTipCenterY;
                        break;
                    case 2:
                        if (m_arrSampleBlobLeads[i].fTipCenterX - m_arrSampleBlobLeads[i].fBaseCenterX > fMaxLength)
                            fMaxLength = m_arrSampleBlobLeads[i].fTipCenterX - m_arrSampleBlobLeads[i].fBaseCenterX;

                        if (m_arrSampleBlobLeads[i].fTipCenterX - m_arrSampleBlobLeads[i].fBaseCenterX < fMinLength)
                            fMinLength = m_arrSampleBlobLeads[i].fTipCenterX - m_arrSampleBlobLeads[i].fBaseCenterX;
                        break;
                    case 3:
                        if (m_arrSampleBlobLeads[i].fTipCenterY - m_arrSampleBlobLeads[i].fBaseCenterY > fMaxLength)
                            fMaxLength = m_arrSampleBlobLeads[i].fTipCenterY - m_arrSampleBlobLeads[i].fBaseCenterY;

                        if (m_arrSampleBlobLeads[i].fTipCenterY - m_arrSampleBlobLeads[i].fBaseCenterY < fMinLength)
                            fMinLength = m_arrSampleBlobLeads[i].fTipCenterY - m_arrSampleBlobLeads[i].fBaseCenterY;
                        break;
                    case 4:
                        if (m_arrSampleBlobLeads[i].fBaseCenterX - m_arrSampleBlobLeads[i].fTipCenterX > fMaxLength)
                            fMaxLength = m_arrSampleBlobLeads[i].fBaseCenterX - m_arrSampleBlobLeads[i].fTipCenterX;

                        if (m_arrSampleBlobLeads[i].fBaseCenterX - m_arrSampleBlobLeads[i].fTipCenterX < fMinLength)
                            fMinLength = m_arrSampleBlobLeads[i].fBaseCenterX - m_arrSampleBlobLeads[i].fTipCenterX;
                        break;
                }

            }

            m_fSampleLengthVariance = fMaxLength - fMinLength;  //(float)Math.Round(fMaxLength - fMinLength, 3, MidpointRounding.AwayFromZero); // 2020 09 08 - CCENG: No need to round.
            if (m_intLeadROIDirection == 1 || m_intLeadROIDirection == 3)   // Top or bottom leads
            {
                m_fSampleLengthVarianceMM = m_fSampleLengthVariance / m_fMMToPixelYValue;
                m_fSampleLengthMinMM = fMinLength / m_fMMToPixelYValue;
                m_fSampleLengthMaxMM = fMaxLength / m_fMMToPixelYValue;
            }
            else // Left or Right leads
            {
                m_fSampleLengthVarianceMM = m_fSampleLengthVariance / m_fMMToPixelXValue;
                m_fSampleLengthMinMM = fMinLength / m_fMMToPixelXValue;
                m_fSampleLengthMaxMM = fMaxLength / m_fMMToPixelXValue;
            }

            for (int i = 0; i < m_arrSampleBlobLeads.Length; i++)
            {
                //Skip if Joint Lead
                if ((m_arrSampleBlobLeads[i].intFailMask & 0x02) > 0)
                    continue;

                //Skip if missing Lead
                if ((m_arrSampleBlobLeads[i].intFailMask & 0x04) > 0)
                    continue;

                m_arrSampleBlobLeads[i].fVarianceMM = m_fSampleLengthVarianceMM;
            }

            if ((m_intFailOptionMask & 0x800) > 0)
            {
                //for (int i = 0; i < m_arrSampleBlobLeads.Length; i++)
                //{
                //    //Skip if Joint Lead
                //    if ((m_arrSampleBlobLeads[i].intFailMask & 0x02) > 0)
                //        continue;

                //    //Skip if missing Lead
                //    if ((m_arrSampleBlobLeads[i].intFailMask & 0x04) > 0)
                //        continue;

                //    if (m_arrSampleBlobLeads[i].fVarianceMM > m_stcBlobLead.fVariance)
                //    {
                //        //Fail variance
                //        m_arrSampleBlobLeads[i].intFailMask |= 0x800;
                //        m_intFailResultMask |= 0x800;
                //    }
                //}

                if (m_fSampleLengthVarianceMM > m_fTemplateLengthVarianceMaxLimit)  //m_stcBlobLead.fVariance)
                {
                    //Fail length variance
                    m_intFailResultMask |= 0x800;
                }
            }
        }

        private void CheckSpan(ROI objROI)
        {
            float fMinSpan = float.MaxValue;
            float fMaxSpan = 0;
            float fLongestTipCenterXY = -999;

            for (int i = 0; i < m_arrSampleBlobLeads.Length; i++)
            {
                //Skip if Joint Lead
                if ((m_arrSampleBlobLeads[i].intFailMask & 0x02) > 0)
                    continue;

                //Skip if missing Lead
                if ((m_arrSampleBlobLeads[i].intFailMask & 0x04) > 0)
                    continue;

                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                switch (m_intLeadROIDirection)
                {
                    case 1: // top using X to find span
                        //if (fMinSpan > m_arrSampleBlobLeads[i].fStartX)
                        //{
                        //    fMinSpan = m_arrSampleBlobLeads[i].fStartX;
                        //}

                        //if (fMaxSpan < m_arrSampleBlobLeads[i].fEndX)
                        //{
                        //    fMaxSpan = m_arrSampleBlobLeads[i].fEndX;
                        //}

                        if (fMinSpan > m_arrSampleBlobLeads[i].fTipCenterX - m_arrSampleBlobLeads[i].fTipWidth / 2)
                        {
                            fMinSpan = m_arrSampleBlobLeads[i].fTipCenterX - m_arrSampleBlobLeads[i].fTipWidth / 2;
                        }

                        if (fMaxSpan < m_arrSampleBlobLeads[i].fTipCenterX + m_arrSampleBlobLeads[i].fTipWidth / 2)
                        {
                            fMaxSpan = m_arrSampleBlobLeads[i].fTipCenterX + m_arrSampleBlobLeads[i].fTipWidth / 2;
                        }

                        if (fLongestTipCenterXY == -999 || fLongestTipCenterXY > m_arrSampleBlobLeads[i].fTipCenterY)
                        {
                            fLongestTipCenterXY = m_arrSampleBlobLeads[i].fTipCenterY;
                        }
                        break;
                    case 2:
                        //if (fMinSpan > m_arrSampleBlobLeads[i].fStartY)
                        //{
                        //    fMinSpan = m_arrSampleBlobLeads[i].fStartY;
                        //}

                        //if (fMaxSpan < m_arrSampleBlobLeads[i].fEndY)
                        //{
                        //    fMaxSpan = m_arrSampleBlobLeads[i].fEndY;
                        //}

                        if (fMinSpan > m_arrSampleBlobLeads[i].fTipCenterY - m_arrSampleBlobLeads[i].fTipWidth / 2)
                        {
                            fMinSpan = m_arrSampleBlobLeads[i].fTipCenterY - m_arrSampleBlobLeads[i].fTipWidth / 2;
                        }

                        if (fMaxSpan < m_arrSampleBlobLeads[i].fTipCenterY + m_arrSampleBlobLeads[i].fTipWidth / 2)
                        {
                            fMaxSpan = m_arrSampleBlobLeads[i].fTipCenterY + m_arrSampleBlobLeads[i].fTipWidth / 2;
                        }

                        if (fLongestTipCenterXY == -999 || fLongestTipCenterXY < m_arrSampleBlobLeads[i].fTipCenterX)
                        {
                            fLongestTipCenterXY = m_arrSampleBlobLeads[i].fTipCenterX;
                        }
                        break;
                    case 3: // bottom using X to find span
                        //if (fMinSpan > m_arrSampleBlobLeads[i].fStartX)
                        //{
                        //    fMinSpan = m_arrSampleBlobLeads[i].fStartX;
                        //}

                        //if (fMaxSpan < m_arrSampleBlobLeads[i].fEndX)
                        //{
                        //    fMaxSpan = m_arrSampleBlobLeads[i].fEndX;
                        //}

                        if (fMinSpan > m_arrSampleBlobLeads[i].fTipCenterX - m_arrSampleBlobLeads[i].fTipWidth / 2)
                        {
                            fMinSpan = m_arrSampleBlobLeads[i].fTipCenterX - m_arrSampleBlobLeads[i].fTipWidth / 2;
                        }

                        if (fMaxSpan < m_arrSampleBlobLeads[i].fTipCenterX + m_arrSampleBlobLeads[i].fTipWidth / 2)
                        {
                            fMaxSpan = m_arrSampleBlobLeads[i].fTipCenterX + m_arrSampleBlobLeads[i].fTipWidth / 2;
                        }

                        if (fLongestTipCenterXY == -999 || fLongestTipCenterXY < m_arrSampleBlobLeads[i].fTipCenterY)
                        {
                            fLongestTipCenterXY = m_arrSampleBlobLeads[i].fTipCenterY;
                        }
                        break;
                    case 4:
                        //if (fMinSpan > m_arrSampleBlobLeads[i].fStartY)
                        //{
                        //    fMinSpan = m_arrSampleBlobLeads[i].fStartY;
                        //}

                        //if (fMaxSpan < m_arrSampleBlobLeads[i].fEndY)
                        //{
                        //    fMaxSpan = m_arrSampleBlobLeads[i].fEndY;
                        //}

                        if (fMinSpan > m_arrSampleBlobLeads[i].fTipCenterY - m_arrSampleBlobLeads[i].fTipWidth / 2)
                        {
                            fMinSpan = m_arrSampleBlobLeads[i].fTipCenterY - m_arrSampleBlobLeads[i].fTipWidth / 2;
                        }

                        if (fMaxSpan < m_arrSampleBlobLeads[i].fTipCenterY + m_arrSampleBlobLeads[i].fTipWidth / 2)
                        {
                            fMaxSpan = m_arrSampleBlobLeads[i].fTipCenterY + m_arrSampleBlobLeads[i].fTipWidth / 2;
                        }

                        if (fLongestTipCenterXY == -999 || fLongestTipCenterXY > m_arrSampleBlobLeads[i].fTipCenterX)
                        {
                            fLongestTipCenterXY = m_arrSampleBlobLeads[i].fTipCenterX;
                        }
                        break;
                }

            }

            float fSpan = fMaxSpan - fMinSpan;
            if (m_intLeadROIDirection == 1 || m_intLeadROIDirection == 3)   // Top or bottom leads
            {
                m_fLeadSpanResultMM = fSpan / m_fMMToPixelXValue;
                m_fLeadUnitSpanTipCenterXY = fLongestTipCenterXY + objROI.ref_ROITotalY;
            }
            else // Left or Right leads
            {
                m_fLeadSpanResultMM = fSpan / m_fMMToPixelYValue;
                m_fLeadUnitSpanTipCenterXY = fLongestTipCenterXY + objROI.ref_ROITotalX;
            }



            if ((m_intFailOptionMask & 0x1000) > 0)
            {
                if (m_fLeadSpanResultMM < m_fTemplateLeadMinSpanLimit || m_fLeadSpanResultMM > m_fTemplateLeadMaxSpanLimit)  //m_stcBlobLead.fVariance)
                {
                    //Fail Span for (Top, bottom, left or right)
                    m_intFailResultMask |= 0x1000;
                }
            }
        }


        private void CheckAverageGrayValue(ROI objROI)
        {
            if ((m_intFailOptionMask & 0x4000) == 0 || !m_blnWantUseAverageGrayValueMethod)
                return;

            float fStartX = 0, fStartY = 0, fWidth = 0, fHeight = 0;

            for (int i = 0; i < m_arrSampleBlobLeads.Length; i++)
            {
                //Skip if Joint Lead
                if ((m_arrSampleBlobLeads[i].intFailMask & 0x02) > 0)
                    continue;

                //Skip if missing Lead
                if ((m_arrSampleBlobLeads[i].intFailMask & 0x04) > 0)
                    continue;

                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                switch (m_intLeadROIDirection)
                {
                    case 1: // Top
                        fStartX = (m_arrSampleBlobLeads[i].fTipCenterX - (m_arrSampleBlobLeads[i].fTipWidth / 2) + m_stcBlobLead.intAGVROITolerance_Left);
                        fStartY = (m_arrSampleBlobLeads[i].fTipCenterY + m_stcBlobLead.intAGVROITolerance_Top);
                        fWidth = (m_arrSampleBlobLeads[i].fTipWidth - m_stcBlobLead.intAGVROITolerance_Left - m_stcBlobLead.intAGVROITolerance_Right);
                        fHeight = (m_arrSampleBlobLeads[i].fTipHeight - m_stcBlobLead.intAGVROITolerance_Top - m_stcBlobLead.intAGVROITolerance_Bottom);
                        break;
                    case 3: // Bottom
                        fStartX = (m_arrSampleBlobLeads[i].fTipCenterX - (m_arrSampleBlobLeads[i].fTipWidth / 2) + m_stcBlobLead.intAGVROITolerance_Left);
                        fStartY = (m_arrSampleBlobLeads[i].fTipCenterY - m_arrSampleBlobLeads[i].fTipHeight + m_stcBlobLead.intAGVROITolerance_Top);
                        fWidth = (m_arrSampleBlobLeads[i].fTipWidth - m_stcBlobLead.intAGVROITolerance_Left - m_stcBlobLead.intAGVROITolerance_Right);
                        fHeight = (m_arrSampleBlobLeads[i].fTipHeight - m_stcBlobLead.intAGVROITolerance_Top - m_stcBlobLead.intAGVROITolerance_Bottom);
                        break;
                    case 4: // Left
                        fStartX = (m_arrSampleBlobLeads[i].fTipCenterX + m_stcBlobLead.intAGVROITolerance_Left);
                        fStartY = (m_arrSampleBlobLeads[i].fTipCenterY - (m_arrSampleBlobLeads[i].fTipWidth / 2) + m_stcBlobLead.intAGVROITolerance_Top);
                        fWidth = (m_arrSampleBlobLeads[i].fTipHeight - m_stcBlobLead.intAGVROITolerance_Left - m_stcBlobLead.intAGVROITolerance_Right);
                        fHeight = (m_arrSampleBlobLeads[i].fTipWidth - m_stcBlobLead.intAGVROITolerance_Top - m_stcBlobLead.intAGVROITolerance_Bottom);
                        break;
                    case 2: // Right
                        fStartX = (m_arrSampleBlobLeads[i].fTipCenterX - m_arrSampleBlobLeads[i].fTipHeight + m_stcBlobLead.intAGVROITolerance_Left);
                        fStartY = (m_arrSampleBlobLeads[i].fTipCenterY - (m_arrSampleBlobLeads[i].fTipWidth / 2) + m_stcBlobLead.intAGVROITolerance_Top);
                        fWidth = (m_arrSampleBlobLeads[i].fTipHeight - m_stcBlobLead.intAGVROITolerance_Left - m_stcBlobLead.intAGVROITolerance_Right);
                        fHeight = (m_arrSampleBlobLeads[i].fTipWidth - m_stcBlobLead.intAGVROITolerance_Top - m_stcBlobLead.intAGVROITolerance_Bottom);
                        break;
                }
                if (fStartX < 0)
                    fStartX = 0;
                if (fStartY < 0)
                    fStartY = 0;
                if (fWidth < 1)
                    fWidth = 1;
                if (fHeight < 1)
                    fHeight = 1;
                float fAverageGrayValue = 0;
                ROI objTempROI = new ROI();
                objTempROI.AttachImage(objROI);
                objTempROI.LoadROISetting((int)Math.Round(fStartX, 0), (int)Math.Round(fStartY, 0), (int)Math.Round(fWidth, 0), (int)Math.Round(fHeight, 0));
           

                ROI objThresholdROI = new ROI();
                ImageDrawing objTempImage = new ImageDrawing(true);
                objROI.CopyToImage(ref objTempImage);
                objThresholdROI.AttachImage(objTempImage);

                objThresholdROI.LoadROISetting((int)Math.Round(fStartX, 0), (int)Math.Round(fStartY, 0), (int)Math.Round(fWidth, 0), (int)Math.Round(fHeight, 0));
                

                EasyImage.PixelAverage(objTempROI.ref_ROI, out fAverageGrayValue);

                if (m_blnWantUseAGVMasking)
                {
                    int intThreshold = (int)Math.Round(fAverageGrayValue);

                    //objThresholdROI.ref_ROI.Save("D:\\objThresholdROI1.bmp");
                    //objROI.ref_ROI.Save("D:\\objROI1.bmp");
#if (Debug_2_12 || Release_2_12)
                    EasyImage.Threshold(objThresholdROI.ref_ROI, objThresholdROI.ref_ROI, (uint)intThreshold);
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                    EasyImage.Threshold(objThresholdROI.ref_ROI, objThresholdROI.ref_ROI, intThreshold);
#endif

                    //objThresholdROI.ref_ROI.Save("D:\\objThresholdROI2.bmp");
                    // Step 3 : invert the thrshold ROI 
                    //EasyImage.Oper(EArithmeticLogicOperation.Invert, objThresholdROI.ref_ROI, objThresholdROI.ref_ROI);
                    ROI.InvertOperationROI(objThresholdROI);
                    //objThresholdROI.ref_ROI.Save("D:\\objThresholdROI3.bmp");
                    //objTempROI.ref_ROI.Save("D:\\objTempROI1.bmp");
                    fAverageGrayValue = 0;
                    EasyImage.PixelAverage(objTempROI.ref_ROI, objThresholdROI.ref_ROI, out fAverageGrayValue);
                    //objTempROI.ref_ROI.Save("D:\\objTempROI1.bmp");
                }

                objThresholdROI.Dispose();
                objTempROI.Dispose();
                objTempImage.Dispose();


                m_arrSampleBlobLeads[i].fAGV = fAverageGrayValue;

                if (m_arrSampleBlobLeads[i].fAGV < m_stcBlobLead.fMinAGV || m_arrSampleBlobLeads[i].fAGV > m_stcBlobLead.fMaxAGV)
                {
                    //Fail Average Gray Value
                    m_arrSampleBlobLeads[i].intFailMask |= 0x4000;
                    m_intFailResultMask |= 0x4000;
                }
            }
        }

        /// <summary>
        /// Sort object number
        /// </summary>
        private void SortObjectNumber()
        {
            int intNoID = 1;
            BlobsFeatures stcBlobsFeatures = new BlobsFeatures();
            int[] intDirectionOrder = { -1, -1, -1, -1, -1, -1, -1, -1, -1 };

            #region Set Direction Sequence
            bool blnTopFound = false;
            bool blnBottomFound = false;
            bool blnLeftFound = false;
            bool blnRightFound = false;
            int intOneColumn = 0;
            int intOneRow = 0;
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                if (!m_stcBlobLead.blnSelected)
                    continue;

                if (m_stcBlobLead.intDirection == 1)
                    blnLeftFound = true;

                if (m_stcBlobLead.intDirection == 2)
                    blnRightFound = true;

                if (m_stcBlobLead.intDirection == 4)
                    blnTopFound = true;

                if (m_stcBlobLead.intDirection == 8)
                    blnBottomFound = true;

                if (m_stcBlobLead.intDirection == 7)
                    intOneColumn |= 0x01;

                if (m_stcBlobLead.intDirection == 3)
                    intOneColumn |= 0x02;

                if (m_stcBlobLead.intDirection == 11)
                    intOneColumn |= 0x04;

                if (m_stcBlobLead.intDirection == 13)
                    intOneRow |= 0x01;

                if (m_stcBlobLead.intDirection == 12)
                    intOneRow |= 0x02;

                if (m_stcBlobLead.intDirection == 14)
                    intOneRow |= 0x04;
            }

            int intIndex = 0;
            //if (intOneColumn == 0x07)
            if (intOneColumn > 0)
            {
                intDirectionOrder[intIndex++] = 7;
                intDirectionOrder[intIndex++] = 3;
                intDirectionOrder[intIndex++] = 11;
            }
            //else if (intOneRow == 0x07)
            else if (intOneRow > 0)
            {
                intDirectionOrder[intIndex++] = 13;
                intDirectionOrder[intIndex++] = 12;
                intDirectionOrder[intIndex++] = 14;
            }
            else
            {
                if (blnTopFound)
                {
                    intDirectionOrder[intIndex++] = 5;

                }

                intDirectionOrder[intIndex++] = 4;
                intDirectionOrder[intIndex++] = 6;
                intDirectionOrder[intIndex++] = 2;
                intDirectionOrder[intIndex++] = 10;
                intDirectionOrder[intIndex++] = 8;
                intDirectionOrder[intIndex++] = 9;
                intDirectionOrder[intIndex++] = 1;

                if (!blnTopFound)
                    intDirectionOrder[intIndex++] = 5;

                intDirectionOrder[intIndex] = 0;
            }

            #endregion

            #region Known Direction
            for (int d = 0; d < intDirectionOrder.Length; d++)
            {
                if (intDirectionOrder[d] == -1)
                    continue;

                for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
                {
                    m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                    if (!m_stcBlobLead.blnSelected)
                        continue;

                    if (m_stcBlobLead.intDirection == intDirectionOrder[d])
                    {
                        m_stcBlobLead.intNoID = intNoID;

                        for (int j = 0; j < i; j++)
                        {
                            stcBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobLeads[j];

                            if (!stcBlobsFeatures.blnSelected)
                                continue;

                            if (stcBlobsFeatures.intDirection == intDirectionOrder[d])
                            {
                                if ((intDirectionOrder[d] == 5) || (intDirectionOrder[d] == 4) || (intDirectionOrder[d] == 6) || (intDirectionOrder[d] == 12) || (intDirectionOrder[d] == 13) || (intDirectionOrder[d] == 14))
                                {
                                    if (m_stcBlobLead.intStartX < stcBlobsFeatures.intStartX)
                                    {
                                        if (m_stcBlobLead.intNoID > stcBlobsFeatures.intNoID)
                                            m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                    }
                                }
                                else if ((intDirectionOrder[d] == 2) || (intDirectionOrder[d] == 0) || (intDirectionOrder[d] == 7) || (intDirectionOrder[d] == 3) || (intDirectionOrder[d] == 11))
                                {
                                    if (m_stcBlobLead.intStartY < stcBlobsFeatures.intStartY)
                                    {
                                        if (m_stcBlobLead.intNoID > stcBlobsFeatures.intNoID)
                                            m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                    }
                                }
                                else if ((intDirectionOrder[d] == 10) || (intDirectionOrder[d] == 8) || (intDirectionOrder[d] == 9))
                                {
                                    if (m_stcBlobLead.intStartX > stcBlobsFeatures.intStartX)
                                    {
                                        if (m_stcBlobLead.intNoID > stcBlobsFeatures.intNoID)
                                            m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                    }
                                }
                                else
                                {
                                    if (m_stcBlobLead.intStartY > stcBlobsFeatures.intStartY)
                                    {
                                        if (m_stcBlobLead.intNoID > stcBlobsFeatures.intNoID)
                                            m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                    }
                                }
                            }
                        }

                        for (int j = 0; j < i; j++)
                        {
                            stcBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobLeads[j];
                            if (stcBlobsFeatures.intDirection == intDirectionOrder[d])
                            {
                                if (m_stcBlobLead.intNoID <= stcBlobsFeatures.intNoID)
                                {
                                    stcBlobsFeatures.intNoID++;
                                    m_arrTemplateBlobLeads.RemoveAt(j);
                                    m_arrTemplateBlobLeads.Insert(j, stcBlobsFeatures);
                                }
                            }
                        }
                        intNoID++;
                    }
                    m_arrTemplateBlobLeads.RemoveAt(i);
                    m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
                }
            }
            #endregion

            #region Unknown Direction

            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                if (!m_stcBlobLead.blnSelected)
                    continue;

                if (m_stcBlobLead.intNoID == 0)
                {
                    m_stcBlobLead.intNoID = intNoID;
                    m_arrTemplateBlobLeads.RemoveAt(i);
                    m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
                    intNoID++;
                }
            }

            #endregion
        }
        public void SortObjectNumber_BaseLead(int intLeadPosition, bool blnClockWise, ref int intLeadNo)
        {
            int intStartNoID = intLeadNo;
            BlobsFeatures stcBlobsFeatures = new BlobsFeatures();
            int[] intDirectionOrder = { -1, -1, -1, -1, -1, -1, -1, -1, -1 };

            #region Set Direction Sequence
            bool blnTopFound = false;
            bool blnBottomFound = false;
            bool blnLeftFound = false;
            bool blnRightFound = false;
            int intOneColumn = 0;
            int intOneRow = 0;
            int intSelectedBlobCount = m_arrTemplateBlobLeads_BaseLead.Count;

            for (int i = 0; i < m_arrTemplateBlobLeads_BaseLead.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i];
                if (!m_stcBlobLead.blnSelected)
                {
                    intSelectedBlobCount--;
                    continue;
                }

                if (m_stcBlobLead.intDirection == 1)
                    blnLeftFound = true;

                if (m_stcBlobLead.intDirection == 2)
                    blnRightFound = true;

                if (m_stcBlobLead.intDirection == 4)
                    blnTopFound = true;

                if (m_stcBlobLead.intDirection == 8)
                    blnBottomFound = true;

                if (m_stcBlobLead.intDirection == 7)
                    intOneColumn |= 0x01;

                if (m_stcBlobLead.intDirection == 3)
                    intOneColumn |= 0x02;

                if (m_stcBlobLead.intDirection == 11)
                    intOneColumn |= 0x04;

                if (m_stcBlobLead.intDirection == 13)
                    intOneRow |= 0x01;

                if (m_stcBlobLead.intDirection == 12)
                    intOneRow |= 0x02;

                if (m_stcBlobLead.intDirection == 14)
                    intOneRow |= 0x04;
            }

            int intIndex = 0;
            //if (intOneColumn == 0x07)
            if (intOneColumn > 0)
            {
                intDirectionOrder[intIndex++] = 7;
                intDirectionOrder[intIndex++] = 3;
                intDirectionOrder[intIndex++] = 11;
            }
            //else if (intOneRow == 0x07)
            else if (intOneRow > 0)
            {
                intDirectionOrder[intIndex++] = 13;
                intDirectionOrder[intIndex++] = 12;
                intDirectionOrder[intIndex++] = 14;

            }
            else
            {
                if (blnTopFound)
                {
                    intDirectionOrder[intIndex++] = 5;

                }

                intDirectionOrder[intIndex++] = 4;
                intDirectionOrder[intIndex++] = 6;
                intDirectionOrder[intIndex++] = 2;
                intDirectionOrder[intIndex++] = 10;
                intDirectionOrder[intIndex++] = 8;
                intDirectionOrder[intIndex++] = 9;
                intDirectionOrder[intIndex++] = 1;

                if (!blnTopFound)
                    intDirectionOrder[intIndex++] = 5;

                intDirectionOrder[intIndex] = 0;
            }

            #endregion

            #region Known Direction
            for (int d = 0; d < intDirectionOrder.Length; d++)
            {
                if (intDirectionOrder[d] == -1)
                    continue;

                for (int i = 0; i < m_arrTemplateBlobLeads_BaseLead.Count; i++)
                {
                    m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i];

                    if (!m_stcBlobLead.blnSelected)
                        continue;

                    if (m_stcBlobLead.intDirection == intDirectionOrder[d])
                    {
                        if ((intLeadPosition == 1 && blnClockWise) || (intLeadPosition == 3 && !blnClockWise) || (intLeadPosition == 2 && blnClockWise) || (intLeadPosition == 4 && !blnClockWise))
                        {
                            m_stcBlobLead.intNoID = intLeadNo;
                        }
                        else
                        {
                            if (intLeadPosition == m_intFirstLead)
                                m_stcBlobLead.intNoID = intSelectedBlobCount - (intLeadNo - 1);
                            else
                                m_stcBlobLead.intNoID = intSelectedBlobCount + intStartNoID - (intLeadNo - (intStartNoID - 1));

                        }

                        for (int j = 0; j < i; j++)
                        {
                            stcBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[j];

                            if (!stcBlobsFeatures.blnSelected)
                                continue;

                            if (stcBlobsFeatures.intDirection == intDirectionOrder[d])
                            {
                                if ((intDirectionOrder[d] == 5) || (intDirectionOrder[d] == 4) || (intDirectionOrder[d] == 6) || (intDirectionOrder[d] == 12) || (intDirectionOrder[d] == 13) || (intDirectionOrder[d] == 14))
                                {
                                    if ((intLeadPosition == 1 && blnClockWise) || (intLeadPosition == 3 && !blnClockWise) || (intLeadPosition == 2 && blnClockWise) || (intLeadPosition == 4 && !blnClockWise))
                                    {
                                        if (m_stcBlobLead.intStartX < stcBlobsFeatures.intStartX)
                                        {
                                            if (m_stcBlobLead.intNoID > stcBlobsFeatures.intNoID)
                                                m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                        }
                                    }
                                    else
                                    {
                                        if (m_stcBlobLead.intStartX < stcBlobsFeatures.intStartX)
                                        {
                                            if (m_stcBlobLead.intNoID < stcBlobsFeatures.intNoID)
                                                m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                        }
                                    }
                                }
                                else if ((intDirectionOrder[d] == 2) || (intDirectionOrder[d] == 0) || (intDirectionOrder[d] == 7) || (intDirectionOrder[d] == 3) || (intDirectionOrder[d] == 11))
                                {
                                    if ((intLeadPosition == 1 && blnClockWise) || (intLeadPosition == 3 && !blnClockWise) || (intLeadPosition == 2 && blnClockWise) || (intLeadPosition == 4 && !blnClockWise))
                                    {
                                        if (m_stcBlobLead.intStartY < stcBlobsFeatures.intStartY)
                                        {
                                            if (m_stcBlobLead.intNoID > stcBlobsFeatures.intNoID)
                                                m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                        }
                                    }
                                    else
                                    {
                                        if (m_stcBlobLead.intStartY < stcBlobsFeatures.intStartY)
                                        {
                                            if (m_stcBlobLead.intNoID < stcBlobsFeatures.intNoID)
                                                m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                        }
                                    }
                                }
                                else if ((intDirectionOrder[d] == 10) || (intDirectionOrder[d] == 8) || (intDirectionOrder[d] == 9))
                                {
                                    if ((intLeadPosition == 1 && blnClockWise) || (intLeadPosition == 3 && !blnClockWise) || (intLeadPosition == 2 && blnClockWise) || (intLeadPosition == 4 && !blnClockWise))
                                    {
                                        if (m_stcBlobLead.intStartX > stcBlobsFeatures.intStartX)
                                        {
                                            if (m_stcBlobLead.intNoID > stcBlobsFeatures.intNoID)
                                                m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                        }
                                    }
                                    else
                                    {
                                        if (m_stcBlobLead.intStartX > stcBlobsFeatures.intStartX)
                                        {
                                            if (m_stcBlobLead.intNoID < stcBlobsFeatures.intNoID)
                                                m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                        }
                                    }
                                }
                                else
                                {
                                    if ((intLeadPosition == 1 && blnClockWise) || (intLeadPosition == 3 && !blnClockWise) || (intLeadPosition == 2 && blnClockWise) || (intLeadPosition == 4 && !blnClockWise))
                                    {
                                        if (m_stcBlobLead.intStartY > stcBlobsFeatures.intStartY)
                                        {
                                            if (m_stcBlobLead.intNoID > stcBlobsFeatures.intNoID)
                                                m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                        }
                                    }
                                    else
                                    {
                                        if (m_stcBlobLead.intStartY > stcBlobsFeatures.intStartY)
                                        {
                                            if (m_stcBlobLead.intNoID < stcBlobsFeatures.intNoID)
                                                m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                        }
                                    }
                                }
                            }
                        }

                        for (int j = 0; j < i; j++)
                        {
                            stcBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[j];
                            if (stcBlobsFeatures.intDirection == intDirectionOrder[d])
                            {
                                if ((intLeadPosition == 1 && blnClockWise) || (intLeadPosition == 3 && !blnClockWise) || (intLeadPosition == 2 && blnClockWise) || (intLeadPosition == 4 && !blnClockWise))
                                {
                                    if (m_stcBlobLead.intNoID <= stcBlobsFeatures.intNoID)
                                    {
                                        stcBlobsFeatures.intNoID++;
                                        m_arrTemplateBlobLeads_BaseLead.RemoveAt(j);
                                        m_arrTemplateBlobLeads_BaseLead.Insert(j, stcBlobsFeatures);
                                    }
                                }
                                else
                                {
                                    if (m_stcBlobLead.intNoID >= stcBlobsFeatures.intNoID)
                                    {
                                        stcBlobsFeatures.intNoID--;
                                        m_arrTemplateBlobLeads_BaseLead.RemoveAt(j);
                                        m_arrTemplateBlobLeads_BaseLead.Insert(j, stcBlobsFeatures);
                                    }
                                }
                            }
                        }
                        intLeadNo++;
                    }
                    m_arrTemplateBlobLeads_BaseLead.RemoveAt(i);
                    m_arrTemplateBlobLeads_BaseLead.Insert(i, m_stcBlobLead);
                }
            }
            #endregion

            #region Unknown Direction

            for (int i = 0; i < m_arrTemplateBlobLeads_BaseLead.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i];

                if (!m_stcBlobLead.blnSelected)
                    continue;

                if (m_stcBlobLead.intNoID == 0)
                {
                    m_stcBlobLead.intNoID = intLeadNo;
                    m_arrTemplateBlobLeads_BaseLead.RemoveAt(i);
                    m_arrTemplateBlobLeads_BaseLead.Insert(i, m_stcBlobLead);
                    intLeadNo++;
                }
            }

            #endregion
        }

        private void SortObjectNumber(int intLeadPosition)
        {
            int intNoID = 1;
            BlobsFeatures stcBlobsFeatures = new BlobsFeatures();
            int[] intDirectionOrder = { -1, -1, -1, -1, -1, -1, -1, -1, -1 };

            #region Set Direction Sequence
            bool blnTopFound = false;
            bool blnBottomFound = false;
            bool blnLeftFound = false;
            bool blnRightFound = false;
            int intOneColumn = 0;
            int intOneRow = 0;
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                if (!m_stcBlobLead.blnSelected)
                    continue;

                if (m_stcBlobLead.intDirection == 1)
                    blnLeftFound = true;

                if (m_stcBlobLead.intDirection == 2)
                    blnRightFound = true;

                if (m_stcBlobLead.intDirection == 4)
                    blnTopFound = true;

                if (m_stcBlobLead.intDirection == 8)
                    blnBottomFound = true;

                if (m_stcBlobLead.intDirection == 7)
                    intOneColumn |= 0x01;

                if (m_stcBlobLead.intDirection == 3)
                    intOneColumn |= 0x02;

                if (m_stcBlobLead.intDirection == 11)
                    intOneColumn |= 0x04;

                if (m_stcBlobLead.intDirection == 13)
                    intOneRow |= 0x01;

                if (m_stcBlobLead.intDirection == 12)
                    intOneRow |= 0x02;

                if (m_stcBlobLead.intDirection == 14)
                    intOneRow |= 0x04;
            }

            int intIndex = 0;
            if ((intLeadPosition == 0 && (intOneColumn == 0x05 || intOneColumn == 0x07)) ||
                (intLeadPosition > 0 && (intOneColumn > 0)))
            {
                intDirectionOrder[intIndex++] = 7;
                intDirectionOrder[intIndex++] = 3;
                intDirectionOrder[intIndex++] = 11;
            }
            else if ((intLeadPosition == 0 && (intOneRow == 0x05 || intOneRow == 0x07)) ||
                (intLeadPosition > 0 && (intOneRow > 0)))
            {
                intDirectionOrder[intIndex++] = 13;
                intDirectionOrder[intIndex++] = 12;
                intDirectionOrder[intIndex++] = 14;
            }
            else
            {
                if (blnTopFound)
                {
                    intDirectionOrder[intIndex++] = 5;

                }

                intDirectionOrder[intIndex++] = 4;
                intDirectionOrder[intIndex++] = 6;
                intDirectionOrder[intIndex++] = 2;
                intDirectionOrder[intIndex++] = 10;
                intDirectionOrder[intIndex++] = 8;
                intDirectionOrder[intIndex++] = 9;
                intDirectionOrder[intIndex++] = 1;

                if (!blnTopFound)
                    intDirectionOrder[intIndex++] = 5;

                intDirectionOrder[intIndex] = 0;
            }

            #endregion

            #region Known Direction
            for (int d = 0; d < intDirectionOrder.Length; d++)
            {
                if (intDirectionOrder[d] == -1)
                    continue;

                for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
                {
                    m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                    if (!m_stcBlobLead.blnSelected)
                        continue;

                    if (m_stcBlobLead.intDirection == intDirectionOrder[d])
                    {
                        m_stcBlobLead.intNoID = intNoID;

                        for (int j = 0; j < i; j++)
                        {
                            stcBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobLeads[j];

                            if (!stcBlobsFeatures.blnSelected)
                                continue;

                            if (stcBlobsFeatures.intDirection == intDirectionOrder[d])
                            {
                                if ((intDirectionOrder[d] == 5) || (intDirectionOrder[d] == 4) || (intDirectionOrder[d] == 6) || (intDirectionOrder[d] == 12) || (intDirectionOrder[d] == 13) || (intDirectionOrder[d] == 14))
                                {
                                    if (m_stcBlobLead.intStartX < stcBlobsFeatures.intStartX)
                                    {
                                        if (m_stcBlobLead.intNoID > stcBlobsFeatures.intNoID)
                                            m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                    }
                                }
                                else if ((intDirectionOrder[d] == 2) || (intDirectionOrder[d] == 0) || (intDirectionOrder[d] == 7) || (intDirectionOrder[d] == 3) || (intDirectionOrder[d] == 11))
                                {
                                    if (m_stcBlobLead.intStartY < stcBlobsFeatures.intStartY)
                                    {
                                        if (m_stcBlobLead.intNoID > stcBlobsFeatures.intNoID)
                                            m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                    }
                                }
                                else if ((intDirectionOrder[d] == 10) || (intDirectionOrder[d] == 8) || (intDirectionOrder[d] == 9))
                                {
                                    if (m_stcBlobLead.intStartX > stcBlobsFeatures.intStartX)
                                    {
                                        if (m_stcBlobLead.intNoID > stcBlobsFeatures.intNoID)
                                            m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                    }
                                }
                                else
                                {
                                    if (m_stcBlobLead.intStartY > stcBlobsFeatures.intStartY)
                                    {
                                        if (m_stcBlobLead.intNoID > stcBlobsFeatures.intNoID)
                                            m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                    }
                                }
                            }
                        }

                        for (int j = 0; j < i; j++)
                        {
                            stcBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobLeads[j];
                            if (stcBlobsFeatures.intDirection == intDirectionOrder[d])
                            {
                                if (m_stcBlobLead.intNoID <= stcBlobsFeatures.intNoID)
                                {
                                    stcBlobsFeatures.intNoID++;
                                    m_arrTemplateBlobLeads.RemoveAt(j);
                                    m_arrTemplateBlobLeads.Insert(j, stcBlobsFeatures);
                                }
                            }
                        }
                        intNoID++;
                    }
                    m_arrTemplateBlobLeads.RemoveAt(i);
                    m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
                }
            }
            #endregion

            #region Unknown Direction

            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                if (!m_stcBlobLead.blnSelected)
                    continue;

                if (m_stcBlobLead.intNoID == 0)
                {
                    m_stcBlobLead.intNoID = intNoID;
                    m_arrTemplateBlobLeads.RemoveAt(i);
                    m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
                    intNoID++;
                }
            }

            #endregion
        }

        /// <summary>
        /// Sort object number
        /// </summary>
        private void SortObjectNumber(int intLeadPosition, bool blnClockWise, ref int intLeadNo)
        {
            int intStartNoID = intLeadNo;
            BlobsFeatures stcBlobsFeatures = new BlobsFeatures();
            int[] intDirectionOrder = { -1, -1, -1, -1, -1, -1, -1, -1, -1 };

            #region Set Direction Sequence
            bool blnTopFound = false;
            bool blnBottomFound = false;
            bool blnLeftFound = false;
            bool blnRightFound = false;
            int intOneColumn = 0;
            int intOneRow = 0;
            int intSelectedBlobCount = m_arrTemplateBlobLeads.Count;

            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                if (!m_stcBlobLead.blnSelected)
                {
                    intSelectedBlobCount--;
                    continue;
                }

                if (m_stcBlobLead.intDirection == 1)
                    blnLeftFound = true;

                if (m_stcBlobLead.intDirection == 2)
                    blnRightFound = true;

                if (m_stcBlobLead.intDirection == 4)
                    blnTopFound = true;

                if (m_stcBlobLead.intDirection == 8)
                    blnBottomFound = true;

                if (m_stcBlobLead.intDirection == 7)
                    intOneColumn |= 0x01;

                if (m_stcBlobLead.intDirection == 3)
                    intOneColumn |= 0x02;

                if (m_stcBlobLead.intDirection == 11)
                    intOneColumn |= 0x04;

                if (m_stcBlobLead.intDirection == 13)
                    intOneRow |= 0x01;

                if (m_stcBlobLead.intDirection == 12)
                    intOneRow |= 0x02;

                if (m_stcBlobLead.intDirection == 14)
                    intOneRow |= 0x04;
            }

            int intIndex = 0;
            //if (intOneColumn == 0x07)
            if (intOneColumn > 0)
            {
                intDirectionOrder[intIndex++] = 7;
                intDirectionOrder[intIndex++] = 3;
                intDirectionOrder[intIndex++] = 11;
            }
            //else if (intOneRow == 0x07)
            else if (intOneRow > 0)
            {
                intDirectionOrder[intIndex++] = 13;
                intDirectionOrder[intIndex++] = 12;
                intDirectionOrder[intIndex++] = 14;

            }
            else
            {
                if (blnTopFound)
                {
                    intDirectionOrder[intIndex++] = 5;

                }

                intDirectionOrder[intIndex++] = 4;
                intDirectionOrder[intIndex++] = 6;
                intDirectionOrder[intIndex++] = 2;
                intDirectionOrder[intIndex++] = 10;
                intDirectionOrder[intIndex++] = 8;
                intDirectionOrder[intIndex++] = 9;
                intDirectionOrder[intIndex++] = 1;

                if (!blnTopFound)
                    intDirectionOrder[intIndex++] = 5;

                intDirectionOrder[intIndex] = 0;
            }

            #endregion

            #region Known Direction
            for (int d = 0; d < intDirectionOrder.Length; d++)
            {
                if (intDirectionOrder[d] == -1)
                    continue;

                for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
                {
                    m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                    if (!m_stcBlobLead.blnSelected)
                        continue;

                    if (m_stcBlobLead.intDirection == intDirectionOrder[d])
                    {
                        if ((intLeadPosition == 1 && blnClockWise) || (intLeadPosition == 3 && !blnClockWise) || (intLeadPosition == 2 && blnClockWise) || (intLeadPosition == 4 && !blnClockWise))
                        {
                            m_stcBlobLead.intNoID = intLeadNo;
                        }
                        else
                        {
                            if (intLeadPosition == m_intFirstLead)
                                m_stcBlobLead.intNoID = intSelectedBlobCount - (intLeadNo - 1);
                            else
                                m_stcBlobLead.intNoID = intSelectedBlobCount + intStartNoID - (intLeadNo - (intStartNoID - 1));

                        }

                        for (int j = 0; j < i; j++)
                        {
                            stcBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobLeads[j];

                            if (!stcBlobsFeatures.blnSelected)
                                continue;

                            if (stcBlobsFeatures.intDirection == intDirectionOrder[d])
                            {
                                if ((intDirectionOrder[d] == 5) || (intDirectionOrder[d] == 4) || (intDirectionOrder[d] == 6) || (intDirectionOrder[d] == 12) || (intDirectionOrder[d] == 13) || (intDirectionOrder[d] == 14))
                                {
                                    if ((intLeadPosition == 1 && blnClockWise) || (intLeadPosition == 3 && !blnClockWise) || (intLeadPosition == 2 && blnClockWise) || (intLeadPosition == 4 && !blnClockWise))
                                    {
                                        if (m_stcBlobLead.intStartX < stcBlobsFeatures.intStartX)
                                        {
                                            if (m_stcBlobLead.intNoID > stcBlobsFeatures.intNoID)
                                                m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                        }
                                    }
                                    else
                                    {
                                        if (m_stcBlobLead.intStartX < stcBlobsFeatures.intStartX)
                                        {
                                            if (m_stcBlobLead.intNoID < stcBlobsFeatures.intNoID)
                                                m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                        }
                                    }
                                }
                                else if ((intDirectionOrder[d] == 2) || (intDirectionOrder[d] == 0) || (intDirectionOrder[d] == 7) || (intDirectionOrder[d] == 3) || (intDirectionOrder[d] == 11))
                                {
                                    if ((intLeadPosition == 1 && blnClockWise) || (intLeadPosition == 3 && !blnClockWise) || (intLeadPosition == 2 && blnClockWise) || (intLeadPosition == 4 && !blnClockWise))
                                    {
                                        if (m_stcBlobLead.intStartY < stcBlobsFeatures.intStartY)
                                        {
                                            if (m_stcBlobLead.intNoID > stcBlobsFeatures.intNoID)
                                                m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                        }
                                    }
                                    else
                                    {
                                        if (m_stcBlobLead.intStartY < stcBlobsFeatures.intStartY)
                                        {
                                            if (m_stcBlobLead.intNoID < stcBlobsFeatures.intNoID)
                                                m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                        }
                                    }
                                }
                                else if ((intDirectionOrder[d] == 10) || (intDirectionOrder[d] == 8) || (intDirectionOrder[d] == 9))
                                {
                                    if ((intLeadPosition == 1 && blnClockWise) || (intLeadPosition == 3 && !blnClockWise) || (intLeadPosition == 2 && blnClockWise) || (intLeadPosition == 4 && !blnClockWise))
                                    {
                                        if (m_stcBlobLead.intStartX > stcBlobsFeatures.intStartX)
                                        {
                                            if (m_stcBlobLead.intNoID > stcBlobsFeatures.intNoID)
                                                m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                        }
                                    }
                                    else
                                    {
                                        if (m_stcBlobLead.intStartX > stcBlobsFeatures.intStartX)
                                        {
                                            if (m_stcBlobLead.intNoID < stcBlobsFeatures.intNoID)
                                                m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                        }
                                    }
                                }
                                else
                                {
                                    if ((intLeadPosition == 1 && blnClockWise) || (intLeadPosition == 3 && !blnClockWise) || (intLeadPosition == 2 && blnClockWise) || (intLeadPosition == 4 && !blnClockWise))
                                    {
                                        if (m_stcBlobLead.intStartY > stcBlobsFeatures.intStartY)
                                        {
                                            if (m_stcBlobLead.intNoID > stcBlobsFeatures.intNoID)
                                                m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                        }
                                    }
                                    else
                                    {
                                        if (m_stcBlobLead.intStartY > stcBlobsFeatures.intStartY)
                                        {
                                            if (m_stcBlobLead.intNoID < stcBlobsFeatures.intNoID)
                                                m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                        }
                                    }
                                }
                            }
                        }

                        for (int j = 0; j < i; j++)
                        {
                            stcBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobLeads[j];
                            if (stcBlobsFeatures.intDirection == intDirectionOrder[d])
                            {
                                if ((intLeadPosition == 1 && blnClockWise) || (intLeadPosition == 3 && !blnClockWise) || (intLeadPosition == 2 && blnClockWise) || (intLeadPosition == 4 && !blnClockWise))
                                {
                                    if (m_stcBlobLead.intNoID <= stcBlobsFeatures.intNoID)
                                    {
                                        stcBlobsFeatures.intNoID++;
                                        m_arrTemplateBlobLeads.RemoveAt(j);
                                        m_arrTemplateBlobLeads.Insert(j, stcBlobsFeatures);
                                    }
                                }
                                else
                                {
                                    if (m_stcBlobLead.intNoID >= stcBlobsFeatures.intNoID)
                                    {
                                        stcBlobsFeatures.intNoID--;
                                        m_arrTemplateBlobLeads.RemoveAt(j);
                                        m_arrTemplateBlobLeads.Insert(j, stcBlobsFeatures);
                                    }
                                }
                            }
                        }
                        intLeadNo++;
                    }
                    m_arrTemplateBlobLeads.RemoveAt(i);
                    m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
                }
            }
            #endregion

            #region Unknown Direction

            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                if (!m_stcBlobLead.blnSelected)
                    continue;

                if (m_stcBlobLead.intNoID == 0)
                {
                    m_stcBlobLead.intNoID = intLeadNo;
                    m_arrTemplateBlobLeads.RemoveAt(i);
                    m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
                    intLeadNo++;
                }
            }

            #endregion
        }

        public void SetBlobsFeaturesToArray(EBlobs objEBlobs, ArrayList arrBlobsFeature, ROI objROI, bool blnTemporaryBlob)
        {
            arrBlobsFeature.Clear();

            int intSelectedObjectNum = 0;
            //float fBorderDistanceX, fBorderDistanceY;

            //if (objEBlobs.ref_intNumSelectedObject >= m_intNumberOfLead)
            //    intSelectedObjectNum = m_intNumberOfLead;
            //else
            intSelectedObjectNum = objEBlobs.ref_intNumSelectedObject;

            if (intSelectedObjectNum > 0)
            {
                //if there are more than 1 blob
                //Combine all the blob within the range
                float fLimitCenterX;
                float fLimitCenterY;
                float fWidth;
                float fHeight;
                float fOrgX;
                float fOrgY;
                int intTotalSelectedBlobCount;
                int intCycleCount = 0;
                List<int> arrSelectedBlob = new List<int>();
                int intTotalArea;
                float fTotalCenterX;
                float fTotalCenterY;
                float fStartX;
                float fStartY;
                float fEndX;
                float fEndY;
                List<int> arrSkipNo = new List<int>();
                bool blnSkipToNextObject = false;

                for (int i = 0; i < intSelectedObjectNum; i++)
                {
                    for (int k = 0; k < arrSkipNo.Count; k++)
                    {
                        if (i == arrSkipNo[k])
                        {
                            blnSkipToNextObject = true;
                            break;
                        }
                    }

                    if (blnSkipToNextObject)
                    {
                        // This segment is to handle the case when the largest blob builded is from the same lead
                        // Since the number of lead is predefined, each blob data collected must be from different lead
                        if (objEBlobs.ref_intNumSelectedObject > intSelectedObjectNum)
                            intSelectedObjectNum++;

                        blnSkipToNextObject = false;
                        continue;
                    }

                    fLimitCenterX = objEBlobs.ref_arrLimitCenterX[i];
                    fLimitCenterY = objEBlobs.ref_arrLimitCenterY[i];
                    fWidth = objEBlobs.ref_arrWidth[i];
                    fHeight = objEBlobs.ref_arrHeight[i];
                    fOrgX = fLimitCenterX - fWidth / 2;
                    fOrgY = fLimitCenterY - fHeight / 2;
                    intTotalArea = 0;
                    fTotalCenterX = 0;
                    fTotalCenterY = 0;
                    fStartX = fOrgX;
                    fStartY = fOrgY;
                    fEndX = fOrgX + fWidth;
                    fEndY = fOrgY + fHeight;
                    intTotalSelectedBlobCount = 0;
                    arrSelectedBlob.Clear();

                    for (int j = i; j < objEBlobs.ref_intNumSelectedObject; j++)
                    {

                        if (m_intLeadROIDirection == 2 || m_intLeadROIDirection == 4) //m_intLeadDirection == 0
                        {
                            //Horizontal lead
                            if (objEBlobs.ref_arrLimitCenterY[j] < fOrgY || objEBlobs.ref_arrLimitCenterY[j] > (fOrgY + fHeight))
                                continue;
                        }
                        else if (m_intLeadROIDirection == 1 || m_intLeadROIDirection == 3) //else
                        {
                            //Vertical lead
                            if (objEBlobs.ref_arrLimitCenterX[j] < fOrgX || objEBlobs.ref_arrLimitCenterX[j] > (fOrgX + fWidth))
                                continue;
                        }

                        //Once the blob met the requirement, add the blob into skip array to prevent the same blob added twice
                        arrSkipNo.Add(j);

                        intTotalArea += objEBlobs.ref_arrArea[j];
                        fTotalCenterX += objEBlobs.ref_arrGravityCenterX[j] * objEBlobs.ref_arrArea[j];
                        fTotalCenterY += objEBlobs.ref_arrGravityCenterY[j] * objEBlobs.ref_arrArea[j];

                        if (fStartX > objEBlobs.ref_arrLimitCenterX[j] - (objEBlobs.ref_arrWidth[j] / 2))
                        {
                            fStartX = objEBlobs.ref_arrLimitCenterX[j] - (objEBlobs.ref_arrWidth[j] / 2);
                        }

                        if (fStartY > objEBlobs.ref_arrLimitCenterY[j] - (objEBlobs.ref_arrHeight[j] / 2))
                        {
                            fStartY = objEBlobs.ref_arrLimitCenterY[j] - (objEBlobs.ref_arrHeight[j] / 2);
                        }

                        if (fEndX < objEBlobs.ref_arrLimitCenterX[j] + (objEBlobs.ref_arrWidth[j] / 2))
                        {
                            fEndX = objEBlobs.ref_arrLimitCenterX[j] + (objEBlobs.ref_arrWidth[j] / 2);
                        }

                        if (fEndY < objEBlobs.ref_arrLimitCenterY[j] + (objEBlobs.ref_arrHeight[j] / 2))
                        {
                            fEndY = objEBlobs.ref_arrLimitCenterY[j] + (objEBlobs.ref_arrHeight[j] / 2);
                        }

                        arrSelectedBlob.Add(j);
                        intTotalSelectedBlobCount++;
                    }

                    m_stcBlobLead = new BlobsFeatures();
                    m_stcBlobLead.fArea = intTotalArea;
                    m_stcBlobLead.fCenterX = fTotalCenterX / intTotalArea;
                    m_stcBlobLead.fCenterY = fTotalCenterY / intTotalArea;
                    m_stcBlobLead.fWidth = fEndX - fStartX;
                    m_stcBlobLead.fHeight = fEndY - fStartY;
                    m_stcBlobLead.fLimitCenterX = fStartX + (fEndX - fStartX) / 2;
                    m_stcBlobLead.fLimitCenterY = fStartY + (fEndY - fStartY) / 2;

                    m_stcBlobLead.intLengthMode = -1;

                    m_stcBlobLead.arrContourX = new int[intTotalSelectedBlobCount];
                    m_stcBlobLead.arrContourY = new int[intTotalSelectedBlobCount];


                    for (int j = 0; j < arrSelectedBlob.Count; j++)
                    {
                        for (int k = 0; k < objEBlobs.ref_intNumSelectedObject; k++)
                        {
                            if (arrSelectedBlob[j] == k)
                            {
                                m_stcBlobLead.arrContourX[j] = objEBlobs.ref_arrContourX[k];
                                m_stcBlobLead.arrContourY[j] = objEBlobs.ref_arrContourY[k];
                            }
                        }
                    }

                    m_stcBlobLead.intObjNo = 0;
                    m_stcBlobLead.fStartX = (float)Math.Round(fStartX, 4);
                    m_stcBlobLead.fEndX = (float)Math.Round(fEndX, 4);
                    m_stcBlobLead.fStartY = (float)Math.Round(fStartY, 4);
                    m_stcBlobLead.fEndY = (float)Math.Round(fEndY, 4);
                    m_stcBlobLead.intStartX = (int)Math.Round(fStartX, 0, MidpointRounding.AwayFromZero);
                    m_stcBlobLead.intEndX = (int)Math.Round(fEndX, 0, MidpointRounding.AwayFromZero);
                    m_stcBlobLead.intStartY = (int)Math.Round(fStartY, 0, MidpointRounding.AwayFromZero);
                    m_stcBlobLead.intEndY = (int)Math.Round(fEndY, 0, MidpointRounding.AwayFromZero);
                    m_stcBlobLead.intDirection = -1;
                    m_stcBlobLead.intGroupID = 0;
                    //m_stcBlobLead.fPitch = -1;
                    m_stcBlobLead.intNoID = 0;

                    if (blnTemporaryBlob)
                    {
                        if (m_arrTemplateBlobLeads.Count < m_intNumberOfLead)
                        {
                            if (intCycleCount < m_arrTemplateBlobLeads.Count)
                                m_stcBlobLead.blnSelected = ((BlobsFeatures)m_arrTemplateBlobLeads[intCycleCount]).blnSelected;
                            else
                                m_stcBlobLead.blnSelected = true;
                        }
                        else
                        {
                            if (arrBlobsFeature.Count >= m_intNumberOfLead)
                                m_stcBlobLead.blnSelected = false;
                            else
                                m_stcBlobLead.blnSelected = true;
                        }
                    }
                    else
                    {
                        if (arrBlobsFeature.Count >= m_intNumberOfLead)
                            m_stcBlobLead.blnSelected = false;
                        else
                            m_stcBlobLead.blnSelected = true;
                    }

                    m_stcBlobLead.arrSelectedBlob = new int[arrSelectedBlob.Count];

                    for (int l = 0; l < arrSelectedBlob.Count; l++)
                        m_stcBlobLead.arrSelectedBlob[l] = arrSelectedBlob[l];

                    arrBlobsFeature.Add(m_stcBlobLead);

                    intCycleCount++;
                }
            }
            //else if (intSelectedObjectNum > 0)
            //{
            //    m_stcBlobLead = new BlobsFeatures();
            //    m_stcBlobLead.fArea = objEBlobs.ref_arrArea[0];
            //    m_stcBlobLead.fCenterX = objEBlobs.ref_arrGravityCenterX[0];
            //    m_stcBlobLead.fCenterY = objEBlobs.ref_arrGravityCenterY[0];
            //    m_stcBlobLead.fLimitCenterX = objEBlobs.ref_arrLimitCenterX[0];
            //    m_stcBlobLead.fLimitCenterY = objEBlobs.ref_arrLimitCenterY[0];
            //    m_stcBlobLead.fWidth = objEBlobs.ref_arrWidth[0];
            //    m_stcBlobLead.fHeight = objEBlobs.ref_arrHeight[0];

            //    fBorderDistanceX = Math.Min(m_stcBlobLead.fLimitCenterX, objROI.ref_ROIWidth - m_stcBlobLead.fLimitCenterX);
            //    fBorderDistanceY = Math.Min(m_stcBlobLead.fLimitCenterY, objROI.ref_ROIHeight - m_stcBlobLead.fLimitCenterY);

            //    if ((fBorderDistanceX / fBorderDistanceY) < 0.7) // point x closer to border compare with point y
            //    {
            //        m_stcBlobLead.intLengthMode = 2;   // 2 mean length == width OR set Width == fHeight, Length == fWidth
            //    }
            //    else if ((fBorderDistanceY / fBorderDistanceX) < 0.7)   // point y closer to border compare with point x
            //    {
            //        m_stcBlobLead.intLengthMode = 1;   // 1 mean length == height OR set Width == fWidth, Length == fHeight
            //    }
            //    else
            //    {
            //        if (m_stcBlobLead.fWidth < m_stcBlobLead.fHeight)  // width shorter then height
            //        {
            //            m_stcBlobLead.intLengthMode = 1;   // 1 mean length == height
            //        }
            //        else
            //        {
            //            m_stcBlobLead.intLengthMode = 2;   // 2 mean length == width
            //        }
            //    }

            //    m_stcBlobLead.intContourX = objEBlobs.ref_arrContourX[0];
            //    m_stcBlobLead.intContourY = objEBlobs.ref_arrContourY[0];
            //    m_stcBlobLead.intObjNo = 0;
            //    m_stcBlobLead.fStartX = (float)Math.Round(m_stcBlobLead.fLimitCenterX - (m_stcBlobLead.fWidth / 2), 4);
            //    m_stcBlobLead.fEndX = (float)Math.Round(m_stcBlobLead.fLimitCenterX + (m_stcBlobLead.fWidth / 2), 4);
            //    m_stcBlobLead.fStartY = (float)Math.Round(m_stcBlobLead.fLimitCenterY - (m_stcBlobLead.fHeight / 2), 4);
            //    m_stcBlobLead.fEndY = (float)Math.Round(m_stcBlobLead.fLimitCenterY + (m_stcBlobLead.fHeight / 2), 4);
            //    m_stcBlobLead.intStartX = (int)Math.Round(m_stcBlobLead.fLimitCenterX - (m_stcBlobLead.fWidth / 2), 0, MidpointRounding.AwayFromZero);
            //    m_stcBlobLead.intEndX = (int)Math.Round(m_stcBlobLead.fLimitCenterX + (m_stcBlobLead.fWidth / 2), 0, MidpointRounding.AwayFromZero);
            //    m_stcBlobLead.intStartY = (int)Math.Round(m_stcBlobLead.fLimitCenterY - (m_stcBlobLead.fHeight / 2), 0, MidpointRounding.AwayFromZero);
            //    m_stcBlobLead.intEndY = (int)Math.Round(m_stcBlobLead.fLimitCenterY + (m_stcBlobLead.fHeight / 2), 0, MidpointRounding.AwayFromZero);
            //    m_stcBlobLead.blnSelected = true;
            //    m_stcBlobLead.intDirection = -1;
            //    m_stcBlobLead.intGroupID = 0;
            //    //m_stcBlobLead.fPitch = -1;
            //    //m_stcBlobLead.fGap = -1;
            //    m_stcBlobLead.intNoID = 0;
            //    m_stcBlobLead.intSelectedBlob = intSelectedBlob;
            //    arrBlobsFeature.Add(m_stcBlobLead);
            //}
        }
        public void SetBlobsFeaturesToArray_BaseLead(EBlobs objEBlobs, ArrayList arrBlobsFeature, ROI objROI, bool blnTemporaryBlob)
        {
            arrBlobsFeature.Clear();

            int intSelectedObjectNum = 0;
            //float fBorderDistanceX, fBorderDistanceY;

            //if (objEBlobs.ref_intNumSelectedObject >= m_intNumberOfLead)
            //    intSelectedObjectNum = m_intNumberOfLead;
            //else
            intSelectedObjectNum = objEBlobs.ref_intNumSelectedObject;

            if (intSelectedObjectNum > 0)
            {
                List<int> arrFilterBlob = new List<int>();
                //2020-10-01 ZJYEOH : Assign Filtered Blob build outside template range
                for (int i = 0; i < intSelectedObjectNum; i++)
                {
                    float fSX = objEBlobs.ref_arrLimitCenterX[i] - objEBlobs.ref_arrWidth[i] / 2;
                    float fSY = objEBlobs.ref_arrLimitCenterY[i] - objEBlobs.ref_arrHeight[i] / 2;
                    float fEX = objEBlobs.ref_arrLimitCenterX[i] + objEBlobs.ref_arrWidth[i] / 2;
                    float fEY = objEBlobs.ref_arrLimitCenterY[i] + objEBlobs.ref_arrHeight[i] / 2;
                    float fCX = objEBlobs.ref_arrLimitCenterX[i];
                    float fCY = objEBlobs.ref_arrLimitCenterY[i];

                    // Get current blobs number
                    List<int> arrMatch = MatchTemplateObjects(fSX, fSY, fEX, fEY, fCX, fCY);

                    if (arrMatch.Count == 0)
                        arrFilterBlob.Add(i);
                }

                //if there are more than 1 blob
                //Combine all the blob within the range
                float fLimitCenterX;
                float fLimitCenterY;
                float fWidth;
                float fHeight;
                float fOrgX;
                float fOrgY;
                int intTotalSelectedBlobCount;
                int intCycleCount = 0;
                List<int> arrSelectedBlob = new List<int>();
                int intTotalArea;
                float fTotalCenterX;
                float fTotalCenterY;
                float fStartX;
                float fStartY;
                float fEndX;
                float fEndY;
                List<int> arrSkipNo = new List<int>();
                bool blnSkipToNextObject = false;

                for (int i = 0; i < intSelectedObjectNum; i++)
                {
                    //2020-10-01 ZJYEOH : Skip Filtered Blob build outside template range
                    if (arrFilterBlob.Contains(i))
                        continue;

                    for (int k = 0; k < arrSkipNo.Count; k++)
                    {
                        if (i == arrSkipNo[k])
                        {
                            blnSkipToNextObject = true;
                            break;
                        }
                    }

                    if (blnSkipToNextObject)
                    {
                        // This segment is to handle the case when the largest blob builded is from the same lead
                        // Since the number of lead is predefined, each blob data collected must be from different lead
                        if (objEBlobs.ref_intNumSelectedObject > intSelectedObjectNum)
                            intSelectedObjectNum++;

                        blnSkipToNextObject = false;
                        continue;
                    }

                    fLimitCenterX = objEBlobs.ref_arrLimitCenterX[i];
                    fLimitCenterY = objEBlobs.ref_arrLimitCenterY[i];
                    fWidth = objEBlobs.ref_arrWidth[i];
                    fHeight = objEBlobs.ref_arrHeight[i];
                    fOrgX = fLimitCenterX - fWidth / 2;
                    fOrgY = fLimitCenterY - fHeight / 2;
                    intTotalArea = 0;
                    fTotalCenterX = 0;
                    fTotalCenterY = 0;
                    fStartX = fOrgX;
                    fStartY = fOrgY;
                    fEndX = fOrgX + fWidth;
                    fEndY = fOrgY + fHeight;
                    intTotalSelectedBlobCount = 0;
                    arrSelectedBlob.Clear();

                    for (int j = i; j < objEBlobs.ref_intNumSelectedObject; j++)
                    {
                        bool blnFiltered = false;
                        for (int f = 0; f < arrFilterBlob.Count; f++)
                        {
                            if (arrFilterBlob[f] == j)
                                blnFiltered = true;
                        }

                        if (blnFiltered)
                            continue;

                        if (m_intLeadROIDirection == 2 || m_intLeadROIDirection == 4) //m_intLeadDirection == 0
                        {
                            //Horizontal lead
                            if (objEBlobs.ref_arrLimitCenterY[j] < fOrgY || objEBlobs.ref_arrLimitCenterY[j] > (fOrgY + fHeight))
                                continue;
                        }
                        else if (m_intLeadROIDirection == 1 || m_intLeadROIDirection == 3) //else
                        {
                            //Vertical lead
                            if (objEBlobs.ref_arrLimitCenterX[j] < fOrgX || objEBlobs.ref_arrLimitCenterX[j] > (fOrgX + fWidth))
                                continue;
                        }

                        //Once the blob met the requirement, add the blob into skip array to prevent the same blob added twice
                        arrSkipNo.Add(j);

                        intTotalArea += objEBlobs.ref_arrArea[j];
                        fTotalCenterX += objEBlobs.ref_arrGravityCenterX[j] * objEBlobs.ref_arrArea[j];
                        fTotalCenterY += objEBlobs.ref_arrGravityCenterY[j] * objEBlobs.ref_arrArea[j];

                        if (fStartX > objEBlobs.ref_arrLimitCenterX[j] - (objEBlobs.ref_arrWidth[j] / 2))
                        {
                            fStartX = objEBlobs.ref_arrLimitCenterX[j] - (objEBlobs.ref_arrWidth[j] / 2);
                        }

                        if (fStartY > objEBlobs.ref_arrLimitCenterY[j] - (objEBlobs.ref_arrHeight[j] / 2))
                        {
                            fStartY = objEBlobs.ref_arrLimitCenterY[j] - (objEBlobs.ref_arrHeight[j] / 2);
                        }

                        if (fEndX < objEBlobs.ref_arrLimitCenterX[j] + (objEBlobs.ref_arrWidth[j] / 2))
                        {
                            fEndX = objEBlobs.ref_arrLimitCenterX[j] + (objEBlobs.ref_arrWidth[j] / 2);
                        }

                        if (fEndY < objEBlobs.ref_arrLimitCenterY[j] + (objEBlobs.ref_arrHeight[j] / 2))
                        {
                            fEndY = objEBlobs.ref_arrLimitCenterY[j] + (objEBlobs.ref_arrHeight[j] / 2);
                        }

                        arrSelectedBlob.Add(j);
                        intTotalSelectedBlobCount++;
                    }

                    m_stcBlobLead = new BlobsFeatures();
                    m_stcBlobLead.fArea = intTotalArea;
                    m_stcBlobLead.fCenterX = fTotalCenterX / intTotalArea;
                    m_stcBlobLead.fCenterY = fTotalCenterY / intTotalArea;
                    m_stcBlobLead.fWidth = fEndX - fStartX;
                    m_stcBlobLead.fHeight = fEndY - fStartY;
                    m_stcBlobLead.fLimitCenterX = fStartX + (fEndX - fStartX) / 2;
                    m_stcBlobLead.fLimitCenterY = fStartY + (fEndY - fStartY) / 2;

                    m_stcBlobLead.intLengthMode = -1;

                    m_stcBlobLead.arrContourX = new int[intTotalSelectedBlobCount];
                    m_stcBlobLead.arrContourY = new int[intTotalSelectedBlobCount];


                    for (int j = 0; j < arrSelectedBlob.Count; j++)
                    {
                        for (int k = 0; k < objEBlobs.ref_intNumSelectedObject; k++)
                        {
                            if (arrSelectedBlob[j] == k)
                            {
                                m_stcBlobLead.arrContourX[j] = objEBlobs.ref_arrContourX[k];
                                m_stcBlobLead.arrContourY[j] = objEBlobs.ref_arrContourY[k];
                            }
                        }
                    }

                    m_stcBlobLead.intObjNo = 0;
                    m_stcBlobLead.fStartX = (float)Math.Round(fStartX, 4);
                    m_stcBlobLead.fEndX = (float)Math.Round(fEndX, 4);
                    m_stcBlobLead.fStartY = (float)Math.Round(fStartY, 4);
                    m_stcBlobLead.fEndY = (float)Math.Round(fEndY, 4);
                    m_stcBlobLead.intStartX = (int)Math.Round(fStartX, 0, MidpointRounding.AwayFromZero);
                    m_stcBlobLead.intEndX = (int)Math.Round(fEndX, 0, MidpointRounding.AwayFromZero);
                    m_stcBlobLead.intStartY = (int)Math.Round(fStartY, 0, MidpointRounding.AwayFromZero);
                    m_stcBlobLead.intEndY = (int)Math.Round(fEndY, 0, MidpointRounding.AwayFromZero);
                    m_stcBlobLead.intDirection = -1;
                    m_stcBlobLead.intGroupID = m_intLeadROIDirection;
                    //m_stcBlobLead.fPitch = -1;
                    m_stcBlobLead.intNoID = 0;

                    if (blnTemporaryBlob)
                    {
                        if (m_arrTemplateBlobLeads_BaseLead.Count < m_intNumberOfLead)
                        {
                            if (intCycleCount < m_arrTemplateBlobLeads_BaseLead.Count)
                                m_stcBlobLead.blnSelected = ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[intCycleCount]).blnSelected;
                            else
                                m_stcBlobLead.blnSelected = true;
                        }
                        else
                        {
                            if (arrBlobsFeature.Count >= m_intNumberOfLead)
                                m_stcBlobLead.blnSelected = false;
                            else
                                m_stcBlobLead.blnSelected = true;
                        }
                    }
                    else
                    {
                        if (arrBlobsFeature.Count >= m_intNumberOfLead)
                            m_stcBlobLead.blnSelected = false;
                        else
                            m_stcBlobLead.blnSelected = true;
                    }

                    m_stcBlobLead.arrSelectedBlob = new int[arrSelectedBlob.Count];

                    for (int l = 0; l < arrSelectedBlob.Count; l++)
                        m_stcBlobLead.arrSelectedBlob[l] = arrSelectedBlob[l];

                    arrBlobsFeature.Add(m_stcBlobLead);

                    intCycleCount++;
                }
            }
        }

        public void SetBlobsFeaturesToArray_CenterLead3D(EBlobs objEBlobs, ArrayList arrBlobsFeature, ROI objROI)
        {
            arrBlobsFeature.Clear();

            int intSelectedObjectNum = objEBlobs.ref_intNumSelectedObject;
            float fBorderDistanceX, fBorderDistanceY;
            for (int i = 0; i < intSelectedObjectNum; i++)
            {

                m_stcBlobLead = new BlobsFeatures();

                m_stcBlobLead.fArea = objEBlobs.ref_arrArea[i];
                m_stcBlobLead.fCenterX = objEBlobs.ref_arrGravityCenterX[i];
                m_stcBlobLead.fCenterY = objEBlobs.ref_arrGravityCenterY[i];
                m_stcBlobLead.fLimitCenterX = objEBlobs.ref_arrLimitCenterX[i];
                m_stcBlobLead.fLimitCenterY = objEBlobs.ref_arrLimitCenterY[i];
                m_stcBlobLead.fWidth = objEBlobs.ref_arrWidth[i];
                m_stcBlobLead.fHeight = objEBlobs.ref_arrHeight[i];

                fBorderDistanceX = Math.Min(m_stcBlobLead.fLimitCenterX, objROI.ref_ROIWidth - m_stcBlobLead.fLimitCenterX);
                fBorderDistanceY = Math.Min(m_stcBlobLead.fLimitCenterY, objROI.ref_ROIHeight - m_stcBlobLead.fLimitCenterY);

                if ((fBorderDistanceX / fBorderDistanceY) < 0.7) // point x closer to border compare with point y
                {
                    m_stcBlobLead.intLengthMode = 2;   // 2 mean length == width OR set Width == fHeight, Length == fWidth
                }
                else if ((fBorderDistanceY / fBorderDistanceX) < 0.7)   // point y closer to border compare with point x
                {
                    m_stcBlobLead.intLengthMode = 1;   // 1 mean length == height OR set Width == fWidth, Length == fHeight
                }
                else
                {
                    if (m_stcBlobLead.fWidth < m_stcBlobLead.fHeight)  // width shorter then height
                    {
                        m_stcBlobLead.intLengthMode = 1;   // 1 mean length == height
                    }
                    else
                    {
                        m_stcBlobLead.intLengthMode = 2;   // 2 mean length == width
                    }
                }

                m_stcBlobLead.intContourX = objEBlobs.ref_arrContourX[i];
                m_stcBlobLead.intContourY = objEBlobs.ref_arrContourY[i];
                m_stcBlobLead.intObjNo = i;
                m_stcBlobLead.fStartX = (float)Math.Round(m_stcBlobLead.fLimitCenterX - (m_stcBlobLead.fWidth / 2), 4);
                m_stcBlobLead.fEndX = (float)Math.Round(m_stcBlobLead.fLimitCenterX + (m_stcBlobLead.fWidth / 2), 4);
                m_stcBlobLead.fStartY = (float)Math.Round(m_stcBlobLead.fLimitCenterY - (m_stcBlobLead.fHeight / 2), 4);
                m_stcBlobLead.fEndY = (float)Math.Round(m_stcBlobLead.fLimitCenterY + (m_stcBlobLead.fHeight / 2), 4);
                m_stcBlobLead.intStartX = (int)Math.Round(m_stcBlobLead.fLimitCenterX - (m_stcBlobLead.fWidth / 2), 0, MidpointRounding.AwayFromZero);
                m_stcBlobLead.intEndX = (int)Math.Round(m_stcBlobLead.fLimitCenterX + (m_stcBlobLead.fWidth / 2), 0, MidpointRounding.AwayFromZero);
                m_stcBlobLead.intStartY = (int)Math.Round(m_stcBlobLead.fLimitCenterY - (m_stcBlobLead.fHeight / 2), 0, MidpointRounding.AwayFromZero);
                m_stcBlobLead.intEndY = (int)Math.Round(m_stcBlobLead.fLimitCenterY + (m_stcBlobLead.fHeight / 2), 0, MidpointRounding.AwayFromZero);
                m_stcBlobLead.blnSelected = true;
                m_stcBlobLead.intDirection = -1;
                m_stcBlobLead.intGroupID = 0;
                m_stcBlobLead.intNoID = 0;
                m_stcBlobLead.intSelectedBlob = i;
                arrBlobsFeature.Add(m_stcBlobLead);
            }
        }

        public void SetBlobsFeaturesToArray_SideLead3D(EBlobs objEBlobs, ArrayList arrBlobsFeature, ROI objROI)
        {
            arrBlobsFeature.Clear();

            int intSelectedObjectNum = 0;
            float fBorderDistanceX, fBorderDistanceY;

            if (objEBlobs.ref_intNumSelectedObject > 0)
                intSelectedObjectNum = 1;

            //If more than 1 blob is found
            if (intSelectedObjectNum > 0)
            {
                //if there are more than 1 blob
                //Combine all the blob within the range
                float fLimitCenterX;
                float fLimitCenterY;
                float fWidth;
                float fHeight;
                float fOrgX;
                float fOrgY;
                int intTotalBlobCount;
                int intSelectedBlob = 0;
                int intTotalArea;
                float fTotalCenterX;
                float fTotalCenterY;
                float fTotalLimitCenterX;
                float fTotalLimitCenterY;
                float fStartX;
                float fStartY;
                float fEndX;
                float fEndY;
                List<int> arrSkipNo = new List<int>();
                bool blnSkipToNextObject = false;

                for (int i = 0; i < intSelectedObjectNum; i++)
                {
                    for (int k = 0; k < arrSkipNo.Count; k++)
                    {
                        if (i == arrSkipNo[k])
                        {
                            blnSkipToNextObject = true;
                            break;
                        }
                    }

                    if (blnSkipToNextObject)
                    {
                        blnSkipToNextObject = false;
                        continue;
                    }

                    fLimitCenterX = objEBlobs.ref_arrLimitCenterX[i];
                    fLimitCenterY = objEBlobs.ref_arrLimitCenterY[i];
                    fWidth = objEBlobs.ref_arrWidth[i];
                    fHeight = objEBlobs.ref_arrHeight[i];
                    fOrgX = fLimitCenterX - fWidth / 2;
                    fOrgY = fLimitCenterY - fHeight / 2;
                    intTotalArea = 0;
                    fTotalCenterX = 0;
                    fTotalCenterY = 0;
                    fTotalLimitCenterX = 0;
                    fTotalLimitCenterY = 0;
                    fStartX = fOrgX;
                    fStartY = fOrgY;
                    fEndX = fOrgX + fWidth;
                    fEndY = fOrgY + fHeight;
                    intSelectedBlob = 0;
                    intTotalBlobCount = 0;

                    for (int j = i; j < objEBlobs.ref_intNumSelectedObject; j++)
                    {

                        if (m_intLeadROIDirection == 2 || m_intLeadROIDirection == 4) //m_intLeadDirection == 0
                        {
                            //Horizontal lead
                            if (objEBlobs.ref_arrLimitCenterY[j] < fOrgY || objEBlobs.ref_arrLimitCenterY[j] > (fOrgY + fHeight))
                                continue;
                        }
                        else if (m_intLeadROIDirection == 1 || m_intLeadROIDirection == 3) //else
                        {
                            //Vertical lead
                            if (objEBlobs.ref_arrLimitCenterX[j] < fOrgX || objEBlobs.ref_arrLimitCenterX[j] > (fOrgX + fWidth))
                                continue;
                        }

                        // This segment is to handle the case when the largest blob builded is from the same lead
                        // Since the number of lead is predefined, each blob data collected must be from different lead
                        if (intSelectedObjectNum >= j && i != j)
                        {
                            if (objEBlobs.ref_intNumSelectedObject > intSelectedObjectNum)
                                intSelectedObjectNum++;
                            arrSkipNo.Add(j);
                        }

                        intTotalArea += objEBlobs.ref_arrArea[j];
                        fTotalCenterX += objEBlobs.ref_arrGravityCenterX[j] * objEBlobs.ref_arrArea[j];
                        fTotalCenterY += objEBlobs.ref_arrGravityCenterY[j] * objEBlobs.ref_arrArea[j];
                        fTotalLimitCenterX += objEBlobs.ref_arrLimitCenterX[j] * objEBlobs.ref_arrArea[j];
                        fTotalLimitCenterY += objEBlobs.ref_arrLimitCenterY[j] * objEBlobs.ref_arrArea[j];

                        if (fStartX > objEBlobs.ref_arrLimitCenterX[j] - (objEBlobs.ref_arrWidth[j] / 2))
                        {
                            fStartX = objEBlobs.ref_arrLimitCenterX[j] - (objEBlobs.ref_arrWidth[j] / 2);
                        }

                        if (fStartY > objEBlobs.ref_arrLimitCenterY[j] - (objEBlobs.ref_arrHeight[j] / 2))
                        {
                            fStartY = objEBlobs.ref_arrLimitCenterY[j] - (objEBlobs.ref_arrHeight[j] / 2);
                        }

                        if (fEndX < objEBlobs.ref_arrLimitCenterX[j] + (objEBlobs.ref_arrWidth[j] / 2))
                        {
                            fEndX = objEBlobs.ref_arrLimitCenterX[j] + (objEBlobs.ref_arrWidth[j] / 2);
                        }

                        if (fEndY < objEBlobs.ref_arrLimitCenterY[j] + (objEBlobs.ref_arrHeight[j] / 2))
                        {
                            fEndY = objEBlobs.ref_arrLimitCenterY[j] + (objEBlobs.ref_arrHeight[j] / 2);
                        }

                        intSelectedBlob |= (1 << j);
                        intTotalBlobCount++;
                    }

                    m_stcBlobLead = new BlobsFeatures();
                    m_stcBlobLead.fArea = intTotalArea;
                    m_stcBlobLead.fCenterX = fTotalCenterX / intTotalArea;
                    m_stcBlobLead.fCenterY = fTotalCenterY / intTotalArea;
                    m_stcBlobLead.fLimitCenterX = fTotalLimitCenterX / intTotalArea;
                    m_stcBlobLead.fLimitCenterY = fTotalLimitCenterY / intTotalArea;
                    m_stcBlobLead.fWidth = fEndX - fStartX;
                    m_stcBlobLead.fHeight = fEndY - fStartY;

                    fBorderDistanceX = Math.Min(m_stcBlobLead.fLimitCenterX, objROI.ref_ROIWidth - m_stcBlobLead.fLimitCenterX);
                    fBorderDistanceY = Math.Min(m_stcBlobLead.fLimitCenterY, objROI.ref_ROIHeight - m_stcBlobLead.fLimitCenterY);

                    if ((fBorderDistanceX / fBorderDistanceY) < 0.7) // point x closer to border compare with point y
                    {
                        m_stcBlobLead.intLengthMode = 2;   // 2 mean length == width OR set Width == fHeight, Length == fWidth
                    }
                    else if ((fBorderDistanceY / fBorderDistanceX) < 0.7)   // point y closer to border compare with point x
                    {
                        m_stcBlobLead.intLengthMode = 1;   // 1 mean length == height OR set Width == fWidth, Length == fHeight
                    }
                    else
                    {
                        if (m_stcBlobLead.fWidth < m_stcBlobLead.fHeight)  // width shorter then height
                        {
                            m_stcBlobLead.intLengthMode = 1;   // 1 mean length == height
                        }
                        else
                        {
                            m_stcBlobLead.intLengthMode = 2;   // 2 mean length == width
                        }
                    }

                    m_stcBlobLead.intContourX = objEBlobs.ref_arrContourX[0];
                    m_stcBlobLead.intContourY = objEBlobs.ref_arrContourY[0];
                    m_stcBlobLead.intObjNo = 0;
                    m_stcBlobLead.fStartX = (float)Math.Round(fStartX, 4);
                    m_stcBlobLead.fEndX = (float)Math.Round(fEndX, 4);
                    m_stcBlobLead.fStartY = (float)Math.Round(fStartY, 4);
                    m_stcBlobLead.fEndY = (float)Math.Round(fEndY, 4);
                    m_stcBlobLead.intStartX = (int)Math.Round(fStartX, 0, MidpointRounding.AwayFromZero);
                    m_stcBlobLead.intEndX = (int)Math.Round(fEndX, 0, MidpointRounding.AwayFromZero);
                    m_stcBlobLead.intStartY = (int)Math.Round(fStartY, 0, MidpointRounding.AwayFromZero);
                    m_stcBlobLead.intEndY = (int)Math.Round(fEndY, 0, MidpointRounding.AwayFromZero);
                    m_stcBlobLead.blnSelected = true;
                    m_stcBlobLead.intDirection = -1;
                    m_stcBlobLead.intGroupID = 0;
                    //m_stcBlobLead.fPitch = -1;
                    m_stcBlobLead.intNoID = 0;
                    m_stcBlobLead.intSelectedBlob = intSelectedBlob;
                    arrBlobsFeature.Add(m_stcBlobLead);
                }
            }
        }

        public void SetBlobsFeaturesToArray_CenterLead3D_SingleSide(EBlobs objEBlobs, ArrayList arrBlobsFeature, ROI objROI, int intNumberOfLead, int intDirection)
        {
            int intSelectedObjectNum = 0;
            float fBorderDistanceX, fBorderDistanceY;

            if (objEBlobs.ref_intNumSelectedObject >= intNumberOfLead)
                intSelectedObjectNum = intNumberOfLead;
            else
                intSelectedObjectNum = objEBlobs.ref_intNumSelectedObject;

            //If more than 1 blob is found
            if (intSelectedObjectNum > 0)
            {
                //if there are more than 1 blob
                //Combine all the blob within the range
                float fLimitCenterX;
                float fLimitCenterY;
                float fWidth;
                float fHeight;
                float fOrgX;
                float fOrgY;
                int intTotalBlobCount;
                int intSelectedBlob = 0;
                int intTotalArea;
                float fTotalCenterX;
                float fTotalCenterY;
                float fTotalLimitCenterX;
                float fTotalLimitCenterY;
                float fStartX;
                float fStartY;
                float fEndX;
                float fEndY;
                List<int> arrSkipNo = new List<int>();
                bool blnSkipToNextObject = false;

                // Scan blob to get biggest size blobs for the each lead location.
                for (int i = 0; i < intSelectedObjectNum; i++)
                {
                    for (int k = 0; k < arrSkipNo.Count; k++)
                    {
                        if (i == arrSkipNo[k])
                        {
                            blnSkipToNextObject = true;
                            break;
                        }
                    }

                    // Skip this blob because ???
                    if (blnSkipToNextObject)
                    {
                        blnSkipToNextObject = false;
                        continue;
                    }

                    float fFromROIOffsetLimitCenterX = objROI.ref_ROIPositionX + objEBlobs.ref_arrLimitCenterX[i];
                    float fFromROIOffsetLimitCenterY = objROI.ref_ROIPositionY + objEBlobs.ref_arrLimitCenterY[i];
                    // Get blob center point, start point and size
                    fLimitCenterX = fFromROIOffsetLimitCenterX;
                    fLimitCenterY = fFromROIOffsetLimitCenterY;
                    fWidth = objEBlobs.ref_arrWidth[i];
                    fHeight = objEBlobs.ref_arrHeight[i];
                    fOrgX = fLimitCenterX - fWidth / 2;
                    fOrgY = fLimitCenterY - fHeight / 2;
                    intTotalArea = 0;
                    fTotalCenterX = 0;
                    fTotalCenterY = 0;
                    fTotalLimitCenterX = 0;
                    fTotalLimitCenterY = 0;
                    fStartX = fOrgX;
                    fStartY = fOrgY;
                    fEndX = fOrgX + fWidth;
                    fEndY = fOrgY + fHeight;
                    intSelectedBlob = 0;
                    intTotalBlobCount = 0;

                    // Scan the i blob itself and rest of the smaller blob whether they are same y range (horizontal) or x range (vertical).
                    for (int j = i; j < objEBlobs.ref_intNumSelectedObject; j++)    // start from i itselft
                    {
                        float fFromROIOffsetCenterX2 = objROI.ref_ROIPositionX + objEBlobs.ref_arrGravityCenterX[j];
                        float fFromROIOffsetCenterY2 = objROI.ref_ROIPositionY + objEBlobs.ref_arrGravityCenterY[j];
                        float fFromROIOffsetLimitCenterX2 = objROI.ref_ROIPositionX + objEBlobs.ref_arrLimitCenterX[j];
                        float fFromROIOffsetLimitCenterY2 = objROI.ref_ROIPositionY + objEBlobs.ref_arrLimitCenterY[j];


                        if (i != j)
                        {
                            if (m_intLeadROIDirection == 2 || m_intLeadROIDirection == 4) //m_intLeadDirection == 0
                            {//Horizontal lead
                                // skip if j blob not within i blob y range.
                                if (fFromROIOffsetLimitCenterY2 < fOrgY || fFromROIOffsetLimitCenterY2 > (fOrgY + fHeight))
                                    continue;
                            }
                            else if (m_intLeadROIDirection == 1 || m_intLeadROIDirection == 3) //else  
                            { //Vertical lead
                                // skip if j blob not within i blob x range.
                                if (fFromROIOffsetLimitCenterX2 < fOrgX || fFromROIOffsetLimitCenterX2 > (fOrgX + fWidth))
                                    continue;
                            }

                            // This segment is to handle the case when the largest blob builded is from the same lead
                            // Since the number of lead is predefined, each blob data collected must be from different lead
                            if (intSelectedObjectNum >= j && i != j)
                            {
                                if (objEBlobs.ref_intNumSelectedObject > intSelectedObjectNum)
                                    intSelectedObjectNum++;
                                arrSkipNo.Add(j);   // Add this j blob to skip list so that this blob will not be checked again in i blob scanning.
                            }
                        }

                        intTotalArea += objEBlobs.ref_arrArea[j];
                        fTotalCenterX += fFromROIOffsetCenterX2 * objEBlobs.ref_arrArea[j];
                        fTotalCenterY += fFromROIOffsetCenterY2 * objEBlobs.ref_arrArea[j];
                        fTotalLimitCenterX += fFromROIOffsetLimitCenterX2 * objEBlobs.ref_arrArea[j];
                        fTotalLimitCenterY += fFromROIOffsetLimitCenterY2 * objEBlobs.ref_arrArea[j];

                        if (fStartX > fFromROIOffsetLimitCenterX2 - (objEBlobs.ref_arrWidth[j] / 2))
                        {
                            fStartX = fFromROIOffsetLimitCenterX2 - (objEBlobs.ref_arrWidth[j] / 2);
                        }

                        if (fStartY > fFromROIOffsetLimitCenterY2 - (objEBlobs.ref_arrHeight[j] / 2))
                        {
                            fStartY = fFromROIOffsetLimitCenterY2 - (objEBlobs.ref_arrHeight[j] / 2);
                        }

                        if (fEndX < fFromROIOffsetLimitCenterX2 + (objEBlobs.ref_arrWidth[j] / 2))
                        {
                            fEndX = fFromROIOffsetLimitCenterX2 + (objEBlobs.ref_arrWidth[j] / 2);
                        }

                        if (fEndY < fFromROIOffsetLimitCenterY2 + (objEBlobs.ref_arrHeight[j] / 2))
                        {
                            fEndY = fFromROIOffsetLimitCenterY2 + (objEBlobs.ref_arrHeight[j] / 2);
                        }

                        intSelectedBlob |= (1 << j);
                        intTotalBlobCount++;
                    }

                    m_stcBlobLead = new BlobsFeatures();
                    m_stcBlobLead.fArea = intTotalArea;
                    m_stcBlobLead.fCenterX = fTotalCenterX / intTotalArea;
                    m_stcBlobLead.fCenterY = fTotalCenterY / intTotalArea;
                    m_stcBlobLead.fLimitCenterX = fTotalLimitCenterX / intTotalArea;
                    m_stcBlobLead.fLimitCenterY = fTotalLimitCenterY / intTotalArea;
                    m_stcBlobLead.fWidth = fEndX - fStartX;
                    m_stcBlobLead.fHeight = fEndY - fStartY;

                    fBorderDistanceX = Math.Min(m_stcBlobLead.fLimitCenterX, objROI.ref_ROIWidth - m_stcBlobLead.fLimitCenterX);
                    fBorderDistanceY = Math.Min(m_stcBlobLead.fLimitCenterY, objROI.ref_ROIHeight - m_stcBlobLead.fLimitCenterY);

                    if ((fBorderDistanceX / fBorderDistanceY) < 0.7) // point x closer to border compare with point y
                    {
                        m_stcBlobLead.intLengthMode = 2;   // 2 mean length == width OR set Width == fHeight, Length == fWidth
                    }
                    else if ((fBorderDistanceY / fBorderDistanceX) < 0.7)   // point y closer to border compare with point x
                    {
                        m_stcBlobLead.intLengthMode = 1;   // 1 mean length == height OR set Width == fWidth, Length == fHeight
                    }
                    else
                    {
                        if (m_stcBlobLead.fWidth < m_stcBlobLead.fHeight)  // width shorter then height
                        {
                            m_stcBlobLead.intLengthMode = 1;   // 1 mean length == height
                        }
                        else
                        {
                            m_stcBlobLead.intLengthMode = 2;   // 2 mean length == width
                        }
                    }

                    m_stcBlobLead.intContourX = objEBlobs.ref_arrContourX[0];
                    m_stcBlobLead.intContourY = objEBlobs.ref_arrContourY[0];
                    m_stcBlobLead.intObjNo = 0;
                    m_stcBlobLead.fStartX = (float)Math.Round(fStartX, 4);
                    m_stcBlobLead.fEndX = (float)Math.Round(fEndX, 4);
                    m_stcBlobLead.fStartY = (float)Math.Round(fStartY, 4);
                    m_stcBlobLead.fEndY = (float)Math.Round(fEndY, 4);
                    m_stcBlobLead.intStartX = (int)Math.Round(fStartX, 0, MidpointRounding.AwayFromZero);
                    m_stcBlobLead.intEndX = (int)Math.Round(fEndX, 0, MidpointRounding.AwayFromZero);
                    m_stcBlobLead.intStartY = (int)Math.Round(fStartY, 0, MidpointRounding.AwayFromZero);
                    m_stcBlobLead.intEndY = (int)Math.Round(fEndY, 0, MidpointRounding.AwayFromZero);
                    m_stcBlobLead.blnSelected = true;
                    m_stcBlobLead.intDirection = intDirection;
                    m_stcBlobLead.intGroupID = 0;
                    //m_stcBlobLead.fPitch = -1;
                    m_stcBlobLead.intNoID = 0;
                    m_stcBlobLead.intSelectedBlob = intSelectedBlob;
                    arrBlobsFeature.Add(m_stcBlobLead);
                }
            }
        }

        public string GetBlobsFeaturesAllData()
        {
            string strBlobsFeatures = "";

            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).intGroupID.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fArea.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).intLengthMode.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).intContourX.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).intContourY.ToString() + "#";
                if (((BlobsFeatures)m_arrTemplateBlobLeads[i]).arrContourX == null)
                {
                    strBlobsFeatures += "0#";
                }
                else {
                    strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).arrContourX.Length.ToString() + "#";

                    for (int j = 0; j < ((BlobsFeatures)m_arrTemplateBlobLeads[i]).arrContourX.Length; j++)
                    {
                        strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).arrContourX[j].ToString() + "#";
                        strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).arrContourY[j].ToString() + "#";
                    }
                }
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).intStartX.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).intStartY.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).intEndX.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).intEndY.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fStartX.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fStartY.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fEndX.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fEndY.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).intDirection.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).intSide.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCenterX.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCenterY.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterX.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterY.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fWidth.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fHeight.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fBaseWidth.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fBaseHeight.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fBaseCenterX.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fBaseCenterY.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fTipWidth.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fTipHeight.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fTipCenterX.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fTipCenterY.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).blnSelected.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLeftDistance.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fRightDistance.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fTopDistance.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fBottomDistance.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fXDistance.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fYDistance.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fPitch.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fGap.ToString() + "#";

                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fOffSet).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fSkew).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinWidth).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxWidth).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinHeight).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxHeight).ToString("F4") + "#";

                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinBaseWidth).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxBaseWidth).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinBaseHeight).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxBaseHeight).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinTipWidth).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxTipWidth).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinTipHeight).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxTipHeight).ToString("F4") + "#";

                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinPitch).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxPitch).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinGap).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxGap).ToString("F4") + "#";

                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fVariance).ToString("F4") + "#";

                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinAGV).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxAGV).ToString("F4") + "#";

                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).intBaseInwardOffset).ToString() + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).intTipInwardOffset).ToString() + "#";

                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).intAGVROITolerance_Top).ToString() + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).intAGVROITolerance_Right).ToString() + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).intAGVROITolerance_Bottom).ToString() + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).intAGVROITolerance_Left).ToString() + "#";

                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fWidthOffset).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLengthOffset).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fPitchOffset).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fGapOffset).ToString("F4") + "#";

            }
            return strBlobsFeatures;
        }
        public string GetBlobsFeaturesAllData_BaseLead()
        {
            string strBlobsFeatures = "";

            for (int i = 0; i < m_arrTemplateBlobLeads_BaseLead.Count; i++)
            {
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).intNoID.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).intGroupID.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).fArea.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).intLengthMode.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).intContourX.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).intContourY.ToString() + "#";
                if (((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).arrContourX == null)
                {
                    strBlobsFeatures += "0#";
                }
                else
                {
                    strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).arrContourX.Length.ToString() + "#";

                    for (int j = 0; j < ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).arrContourX.Length; j++)
                    {
                        strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).arrContourX[j].ToString() + "#";
                        strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).arrContourY[j].ToString() + "#";
                    }
                }
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).intStartX.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).intStartY.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).intEndX.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).intEndY.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).fStartX.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).fStartY.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).fEndX.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).fEndY.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).intDirection.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).intSide.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).fCenterX.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).fCenterY.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).fLimitCenterX.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).fLimitCenterY.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).fWidth.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).fHeight.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).fBaseWidth.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).fBaseHeight.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).fBaseCenterX.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).fBaseCenterY.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).fTipWidth.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).fTipHeight.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).fTipCenterX.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).fTipCenterY.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).blnSelected.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).fLeftDistance.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).fRightDistance.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).fTopDistance.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).fBottomDistance.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).fXDistance.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).fYDistance.ToString() + "#";

                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).fMaxBaseOffset).ToString("F4") + "#";

                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).fMinBaseArea).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).fMaxBaseArea).ToString("F4") + "#";

            }
            return strBlobsFeatures;
        }
        public List<string> GetBlobFeaturesResult_WithPassFailIndicator_BaseLead(int intMatchTemplateIndex)
        {
            List<string> arrResultList = new List<string>();

            int intResultTableFailMask = 0;
            float fData, fMaxData, fMinData;
            int i = intMatchTemplateIndex;

            if (m_arrSampleBlobLeads_BaseLead == null || i >= m_arrSampleBlobLeads_BaseLead.Length)
            {
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add(intResultTableFailMask.ToString());
                return arrResultList;
            }

            if (m_arrSampleBlobLeads_BaseLead[i].fOffSetMM == -999 || (m_intFailOptionMask & 0x10000) == 0)
            {
                if((m_arrSampleBlobLeads_BaseLead[i].intFailMask & 0x40000) > 0)
                    intResultTableFailMask |= 0x04;
                if ((m_arrSampleBlobLeads_BaseLead[i].intFailMask & 0x80000) > 0)
                    intResultTableFailMask |= 0x08;
                arrResultList.Add("---");
            }
            else
            {
                fData = m_arrSampleBlobLeads_BaseLead[i].fOffSetMM * m_fMMToUnitValue;
                arrResultList.Add(fData.ToString("F" + m_intDecimal));
                fMaxData = ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).fMaxBaseOffset * m_fMMToUnitValue;
                if (fData > fMaxData)
                    intResultTableFailMask |= 0x01;
            }

            // Average Gray Value
            if (m_arrSampleBlobLeads_BaseLead[i].fAreaMM == -999 || (m_intFailOptionMask & 0x20000) == 0)
            {
                arrResultList.Add("---");
                if ((m_arrSampleBlobLeads_BaseLead[i].intFailMask & 0x40000) > 0)
                    intResultTableFailMask |= 0x04;
                if ((m_arrSampleBlobLeads_BaseLead[i].intFailMask & 0x80000) > 0)
                    intResultTableFailMask |= 0x08;
            }
            else
            {
                fData = m_arrSampleBlobLeads_BaseLead[i].fAreaMM * m_fMMToUnitValueArea;
                arrResultList.Add(fData.ToString("F" + m_intDecimal));
                fMinData = ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).fMinBaseArea * m_fMMToUnitValueArea;
                fMaxData = ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).fMaxBaseArea * m_fMMToUnitValueArea;

                if (fData < fMinData || fData > fMaxData)
                {
                    intResultTableFailMask |= 0x02;
                }
            }


            arrResultList.Add(intResultTableFailMask.ToString());

            return arrResultList;
        }
        public List<string> GetBlobFeaturesResult_WithPassFailIndicator(int intMatchTemplateIndex)
        {
            List<string> arrResultList = new List<string>();

            int intResultTableFailMask = 0;
            float fData, fMaxData, fMinData;
            int i = intMatchTemplateIndex;

            if (m_arrSampleBlobLeads == null || i >= m_arrSampleBlobLeads.Length)
            {
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add(intResultTableFailMask.ToString());
                return arrResultList;
            }

            if (m_arrSampleBlobLeads[i].fOffSetMM == -999 || (m_intFailOptionMask & 0x100) == 0)
                arrResultList.Add("---");
            else
            {
                fData = m_arrSampleBlobLeads[i].fOffSetMM * m_fMMToUnitValue;
                arrResultList.Add(fData.ToString("F" + m_intDecimal));
                fMaxData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fOffSet * m_fMMToUnitValue;
                if (fData > fMaxData)
                    intResultTableFailMask |= 0x01;
            }

            if (m_arrSampleBlobLeads[i].fSkewMM == -999 || (m_intFailOptionMask & 0x8000) == 0)
            {
                arrResultList.Add("---");

                if ((m_arrSampleBlobLeads[i].intFailMask & 0x8000) > 0)
                {
                    intResultTableFailMask |= 0x02;
                }
                //if (!m_arrSampleBlobLeads[i].blnBaseStartFound && !m_arrSampleBlobLeads[i].blnBaseEndFound)
                //{
                //    intResultTableFailMask |= 0x02;
                //}
            }
            else
            {
                fData = m_arrSampleBlobLeads[i].fSkewMM * m_fMMToUnitValue;
                arrResultList.Add(fData.ToString("F" + m_intDecimal));
                fMaxData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fSkew * m_fMMToUnitValue;
                if (fData > fMaxData)
                    intResultTableFailMask |= 0x02;
            }

            //if (((BlobsFeatures)m_arrTemplateBlobLeads[i]).intLengthMode == 1)
            //{
            if (m_arrSampleBlobLeads[i].fTipWidthMM == -999 || (m_intFailOptionMask & 0xC0) == 0)
                arrResultList.Add("---");
            else
            {
                fData = m_arrSampleBlobLeads[i].fTipWidthMM * m_fMMToUnitValue;
                arrResultList.Add(fData.ToString("F" + m_intDecimal));
                fMinData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinTipWidth * m_fMMToUnitValue;
                fMaxData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxTipWidth * m_fMMToUnitValue;
                if (fData < fMinData || fData > fMaxData)
                {
                    intResultTableFailMask |= 0x04;
                }
            }

            if (m_arrSampleBlobLeads[i].fTipHeightMM == -999 || (m_intFailOptionMask & 0xC0) == 0)
                arrResultList.Add("---");
            else
            {
                fData = m_arrSampleBlobLeads[i].fTipHeightMM * m_fMMToUnitValue;
                arrResultList.Add(fData.ToString("F" + m_intDecimal));
                fMinData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinTipHeight * m_fMMToUnitValue;
                fMaxData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxTipHeight * m_fMMToUnitValue;
                if (fData < fMinData || fData > fMaxData)
                {
                    intResultTableFailMask |= 0x08;
                }
            }
            //}
            //else
            //{
            //    if (m_arrSampleBlobLeads[i].fTipHeightMM == -999 || (m_intFailOptionMask & 0xC0) == 0)
            //        arrResultList.Add("---");
            //    else
            //    {
            //        fData = m_arrSampleBlobLeads[i].fTipHeightMM * m_fMMToUnitValue;
            //        arrResultList.Add(fData.ToString("F" + m_intDecimal));
            //        fMinData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinTipHeight * m_fMMToUnitValue;
            //        fMaxData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxTipHeight * m_fMMToUnitValue;
            //        if (fData < fMinData || fData > fMaxData)
            //        {
            //            intResultTableFailMask |= 0x04;
            //        }
            //    }

            //    if (m_arrSampleBlobLeads[i].fTipWidthMM == -999 || (m_intFailOptionMask & 0xC0) == 0)
            //        arrResultList.Add("---");
            //    else
            //    {
            //        fData = m_arrSampleBlobLeads[i].fTipWidthMM * m_fMMToUnitValue;
            //        arrResultList.Add(fData.ToString("F" + m_intDecimal));
            //        fMinData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinTipWidth * m_fMMToUnitValue;
            //        fMaxData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxTipWidth * m_fMMToUnitValue;
            //        if (fData < fMinData || fData > fMaxData)
            //        {
            //            intResultTableFailMask |= 0x08;
            //        }
            //    }
            //}

            float fPitch = 0, fGap = 0;
            float fMinP = 0, fMaxP = 0, fMinG = 0, fMaxG = 0;
            if (GetPitchGapResult(i, ref fPitch, ref fGap) && (m_intFailOptionMask & 0x600) > 0)
            {
                if (fPitch != -999 && ((m_intFailOptionMask & 0x200) > 0))
                {
                    if (GetPitchGapMinMax(i, ref fMinP, ref fMaxP, ref fMinG, ref fMaxG))
                    {
                        fData = fPitch * m_fMMToUnitValue;
                        arrResultList.Add(fData.ToString("F" + m_intDecimal));
                        fMinData = fMinP * m_fMMToUnitValue;
                        fMaxData = fMaxP * m_fMMToUnitValue;
                        if (fData < fMinData || fData > fMaxData)
                        {
                            intResultTableFailMask |= 0x10;
                        }
                    }
                    else
                    {
                        arrResultList.Add("---");
                    }
                }
                else
                {
                    arrResultList.Add("---");
                }

                if (fGap != -999 && ((m_intFailOptionMask & 0x400) > 0))
                {
                    if (GetPitchGapMinMax(i, ref fMinP, ref fMaxP, ref fMinG, ref fMaxG))
                    {
                        fData = fGap * m_fMMToUnitValue;
                        arrResultList.Add(fData.ToString("F" + m_intDecimal));
                        fMinData = fMinG * m_fMMToUnitValue;
                        fMaxData = fMaxG * m_fMMToUnitValue;
                        if (fData < fMinData || fData > fMaxData)
                        {
                            intResultTableFailMask |= 0x20;
                        }
                    }
                    else
                    {
                        arrResultList.Add("---");
                    }
                }
                else
                {
                    arrResultList.Add("---");
                }
            }
            else
            {
                arrResultList.Add("---");
                arrResultList.Add("---");
            }

            if (m_arrSampleBlobLeads[i].fVarianceMM == -999 || (m_intFailOptionMask & 0x800) == 0)
                arrResultList.Add("---");
            else
            {
                fData = m_arrSampleBlobLeads[i].fVarianceMM * m_fMMToUnitValue;
                arrResultList.Add(fData.ToString("F" + m_intDecimal));
                fMaxData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fVariance * m_fMMToUnitValue;
                if (fData > fMaxData)
                    intResultTableFailMask |= 0x40;
            }

            // Average Gray Value
            if (m_arrSampleBlobLeads[i].fAGV == -999 || (m_intFailOptionMask & 0x4000) == 0)
                arrResultList.Add("---");
            else
            {
                fData = m_arrSampleBlobLeads[i].fAGV;
                arrResultList.Add(fData.ToString("F" + m_intDecimal));
                fMinData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinAGV;
                fMaxData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxAGV;

                if (fData < fMinData || fData > fMaxData)
                {
                    intResultTableFailMask |= 0x200;
                }
            }

            //Min Span
            if (m_fLeadMinSpanResult == 0 || (m_intFailOptionMask & 0x1000) == 0)
                arrResultList.Add("---");
            else
            {
                fData = m_fLeadMinSpanResult;
                arrResultList.Add(fData.ToString("F" + m_intDecimal));
                fMinData = m_fTemplateLeadMinSpanLimit;
                if (fData < fMinData)
                    intResultTableFailMask |= 0x80;
            }

            //Max Span
            if (m_fLeadMaxSpanResult == 0 || (m_intFailOptionMask & 0x1000) == 0)
                arrResultList.Add("---");
            else
            {
                fData = m_fLeadMaxSpanResult;
                arrResultList.Add(fData.ToString("F" + m_intDecimal));
                fMaxData = m_fTemplateLeadMaxSpanLimit;
                if (fData > fMaxData)
                    intResultTableFailMask |= 0x100;
            }

            if ((m_arrSampleBlobLeads[i].intFailMask & 0x04) > 0)
            {
                intResultTableFailMask |= 0x400;
            }

            arrResultList.Add(intResultTableFailMask.ToString());

            return arrResultList;
        }

        /// <summary>
        /// Get pitch gap data include min pitch, max pitch, min gap, max gap
        /// </summary>
        /// <param name="intIndex">pitch gap index</param>
        /// <param name="minPitch">min pitch</param>
        /// <param name="maxPitch">max pitch</param>
        /// <param name="minGap">min gap</param>
        /// <param name="maxGap">max gap</param>
        /// <returns>true = min pitch != 0.0, false = min pitch = 0.0</returns>
        private bool GetPitchGapMinMax(int intIndex, ref float minPitch, ref float maxPitch, ref float minGap, ref float maxGap)
        {
            int iFrom, iTo;
            iFrom = iTo = 0;

            for (int i = 0; i < GetTotalPitchGap(); i++)
            {
                GetPitchGapLeadLink(i, ref iFrom, ref iTo);

                if ((intIndex + 1) == iFrom)
                {
                    minPitch = m_arrPitchGap[i].fMinPitch;
                    maxPitch = m_arrPitchGap[i].fMaxPitch;
                    minGap = m_arrPitchGap[i].fMinGap;
                    maxGap = m_arrPitchGap[i].fMaxGap;
                    return true;
                }
            }

            //if (minPitch != 0.0f)
            //    return true;
            //else
            return false;
        }

        public string GetBaseLeadTolerance()
        {
            string strBlobsFeatures = "";
            float fData;
            for (int i = 0; i < m_arrTemplateBlobLeads_BaseLead.Count; i++)
            {
                fData = ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).fMaxBaseOffset * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";

                fData = ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).fMinBaseArea * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";

                fData = ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).fMaxBaseArea * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
            }
            return strBlobsFeatures;
        }
        /// <summary>
        /// Get all inspection data store in blobs features 
        /// </summary>
        /// <returns>blobs features inspection data in string</returns>
        public string GetBlobsFeaturesInspectRealData()
        {
            string strBlobsFeatures = "";
            float fData;
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fOffSet * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";

                fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fSkew * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";

                //if (((BlobsFeatures)m_arrTemplateBlobLeads[i]).intLengthMode == 2)
                //{
                //    fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinTipHeight * m_fMMToUnitValue;
                //    strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                //    fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxTipHeight * m_fMMToUnitValue;
                //    strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                //    fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinTipWidth * m_fMMToUnitValue;
                //    strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                //    fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxTipWidth * m_fMMToUnitValue;
                //    strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                //}
                //else
                //{
                fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinTipWidth * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxTipWidth * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinTipHeight * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxTipHeight * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                //}

                float fMinP, fMaxP, fMinG, fMaxG;
                fMinP = fMaxP = fMinG = fMaxG = 0.0f;

                if (GetPitchGapMinMax(i, ref fMinP, ref fMaxP, ref fMinG, ref fMaxG))
                {
                    fData = fMinP * m_fMMToUnitValue;
                    strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";

                    fData = fMaxP * m_fMMToUnitValue;
                    strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";

                    fData = fMinG * m_fMMToUnitValue;
                    strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";

                    fData = fMaxG * m_fMMToUnitValue;
                    strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                }
                else
                {
                    for (int j = 0; j < 4; j++)
                    {
                        fData = -1;
                        strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                    }
                }

                fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fVariance * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";

                fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinAGV;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";

                fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxAGV;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";

                //fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fWidthOffset * m_fMMToUnitValue;
                //strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";

                //fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLengthOffset * m_fMMToUnitValue;
                //strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";

                //fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fPitchOffset * m_fMMToUnitValue;
                //strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";

                //fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fGapOffset * m_fMMToUnitValue;
                //strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";

            }
            return strBlobsFeatures;
        }
        public string GetLeadOffsetSettingValue()
        {
            string strBlobsFeatures = "";
            float fData;
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fWidthOffset * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";

                fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLengthOffset * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";

                fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fPitchOffset * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";

                fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fGapOffset * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";

            }
            return strBlobsFeatures;
        }
        public int GetBlobsNoID()
        {
            if (m_arrTemplateBlobLeads.Count > 0)
                return Convert.ToInt32(((BlobsFeatures)m_arrTemplateBlobLeads[0]).intNoID);
            else
                return 0;
        }
        public int GetBlobsNoID(int intIndex)
        {
            if (m_arrTemplateBlobLeads.Count > 0)
                return Convert.ToInt32(((BlobsFeatures)m_arrTemplateBlobLeads[intIndex]).intNoID);
            else
                return 0;
        }
        public void GetBaseLeadResult(int intMatchTemplateIndex, ref float fOffset, ref float fArea)
        {
            int i = intMatchTemplateIndex;
            if (m_arrSampleBlobLeads_BaseLead == null || i >= m_arrSampleBlobLeads_BaseLead.Length)
            {
                fOffset = -999;
                fArea = -999;
                return;
            }

            if (m_arrSampleBlobLeads_BaseLead[i].fOffSetMM == -999)
                fOffset = -999;
            else
            {
                fOffset = m_arrSampleBlobLeads_BaseLead[i].fOffSetMM * m_fMMToUnitValue;
            }

            if (m_arrSampleBlobLeads_BaseLead[i].fAreaMM == -999)
                fArea = -999;
            else
            {
                fArea = m_arrSampleBlobLeads_BaseLead[i].fAreaMM * m_fMMToUnitValue;
            }
        }
        /// <summary>
        /// Get all blobs features result
        /// </summary>
        /// <param name="intTemplateIndex">template index</param>
        /// <returns>blobs features result in string</returns>
        public string GetBlobFeaturesResult(int intMatchTemplateIndex)
        {
            string strBlobFeatures = "";
            float fData;
            int i = intMatchTemplateIndex;

            if (m_arrSampleBlobLeads == null || i >= m_arrSampleBlobLeads.Length)
                return "---#---#---#---#---#---#---#---#---#---#---#";

            if (m_arrSampleBlobLeads == null)
                return "---#---#---#---#---#---#---#---#---#---#---#";

            strBlobFeatures += "Set Value#";

            if (m_arrSampleBlobLeads[i].fOffSetMM == -999)
                strBlobFeatures += "---#";
            else
            {
                fData = m_arrSampleBlobLeads[i].fOffSetMM * m_fMMToUnitValue;
                strBlobFeatures += fData.ToString("F" + m_intDecimal) + "#";
            }

            if (m_arrSampleBlobLeads[i].fSkewMM == -999)
            {
                if (!m_arrSampleBlobLeads[i].blnBaseStartFound && !m_arrSampleBlobLeads[i].blnBaseEndFound)
                {
                    strBlobFeatures += "----#";
                }
                else
                {
                    strBlobFeatures += "---#";
                }
            }
            else
            {
                fData = m_arrSampleBlobLeads[i].fSkewMM * m_fMMToUnitValue;
                strBlobFeatures += fData.ToString("F" + m_intDecimal) + "#";
            }

            //if (((BlobsFeatures)m_arrTemplateBlobLeads[i]).intLengthMode == 1)
            //{
            //    if (m_arrSampleBlobLeads[i].fWidthMM == -999)
            //        strBlobFeatures += "---#";
            //    else
            //    {
            //        fData = m_arrSampleBlobLeads[i].fWidthMM * m_fMMToUnitValue;
            //        strBlobFeatures += fData.ToString("F" + m_intDecimal) + "#";
            //    }

            //    if (m_arrSampleBlobLeads[i].fHeightMM == -999)
            //        strBlobFeatures += "---#";
            //    else
            //    {
            //        fData = m_arrSampleBlobLeads[i].fHeightMM * m_fMMToUnitValue;
            //        strBlobFeatures += fData.ToString("F" + m_intDecimal) + "#";
            //    }
            //}
            //else
            //{
            //    if (m_arrSampleBlobLeads[i].fHeightMM == -999)
            //        strBlobFeatures += "---#";
            //    else
            //    {
            //        fData = m_arrSampleBlobLeads[i].fHeightMM * m_fMMToUnitValue;
            //        strBlobFeatures += fData.ToString("F" + m_intDecimal) + "#";
            //    }

            //    if (m_arrSampleBlobLeads[i].fWidthMM == -999)
            //        strBlobFeatures += "---#";
            //    else
            //    {
            //        fData = m_arrSampleBlobLeads[i].fWidthMM * m_fMMToUnitValue;
            //        strBlobFeatures += fData.ToString("F" + m_intDecimal) + "#";
            //    }
            //}

            //if (((BlobsFeatures)m_arrTemplateBlobLeads[i]).intLengthMode == 1)
            //{
            if (m_arrSampleBlobLeads[i].fTipWidthMM == -999)
                strBlobFeatures += "---#";
            else
            {
                fData = m_arrSampleBlobLeads[i].fTipWidthMM * m_fMMToUnitValue;
                strBlobFeatures += fData.ToString("F" + m_intDecimal) + "#";
            }

            if (m_arrSampleBlobLeads[i].fTipHeightMM == -999)
                strBlobFeatures += "---#";
            else
            {
                fData = m_arrSampleBlobLeads[i].fTipHeightMM * m_fMMToUnitValue;
                strBlobFeatures += fData.ToString("F" + m_intDecimal) + "#";
            }
            //}
            //else
            //{
            //    if (m_arrSampleBlobLeads[i].fTipHeightMM == -999)
            //        strBlobFeatures += "---#";
            //    else
            //    {
            //        fData = m_arrSampleBlobLeads[i].fTipHeightMM * m_fMMToUnitValue;
            //        strBlobFeatures += fData.ToString("F" + m_intDecimal) + "#";
            //    }

            //    if (m_arrSampleBlobLeads[i].fTipWidthMM == -999)
            //        strBlobFeatures += "---#";
            //    else
            //    {
            //        fData = m_arrSampleBlobLeads[i].fTipWidthMM * m_fMMToUnitValue;
            //        strBlobFeatures += fData.ToString("F" + m_intDecimal) + "#";
            //    }
            //}

            float fPitch = 0, fGap = 0;
            if (GetPitchGapResult(i, ref fPitch, ref fGap))
            {
                if (fPitch != -999)
                    strBlobFeatures += (fPitch * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "#";
                else
                    strBlobFeatures += "---#";
                if (fGap != -999)
                    strBlobFeatures += (fGap * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "#";
                else
                    strBlobFeatures += "---#";
            }
            else
            {
                strBlobFeatures += "---#";
                strBlobFeatures += "---#";
            }

            if (m_arrSampleBlobLeads[i].fVarianceMM == -999)
                strBlobFeatures += "---#";
            else
            {
                fData = m_arrSampleBlobLeads[i].fVarianceMM * m_fMMToUnitValue;
                strBlobFeatures += fData.ToString("F" + m_intDecimal) + "#";
            }

            if (m_arrSampleBlobLeads[i].fAGV == -999)
                strBlobFeatures += "---#";
            else
            {
                fData = m_arrSampleBlobLeads[i].fAGV;
                strBlobFeatures += fData.ToString("F" + m_intDecimal) + "#";
            }

            return strBlobFeatures;

        }

        private bool GetPitchGapResult(int intIndex, ref float fPitch, ref float fGap)
        {
            int iFrom, iTo;
            iFrom = iTo = 0;

            for (int i = 0; i < GetTotalPitchGap(); i++)
            {
                GetPitchGapLeadLink(i, ref iFrom, ref iTo);

                if ((intIndex + 1) == iFrom)
                {
                    fPitch = m_arrPitchGap[i].fPitchMM;
                    fGap = m_arrPitchGap[i].fGapMM;
                    return true;
                }
            }
            return false;
        }


        /// <summary>
        /// Get pitch gap from Lead no and to Lead no
        /// </summary>
        /// <param name="intPitchGapIndex">pitch gap index</param>
        /// <param name="intFromLeadNo">from Lead no</param>
        /// <param name="intToLeadNo">to Lead no</param>
        public void GetPitchGapLeadLink(int intPitchGapIndex, ref int intFromLeadNo, ref int intToLeadNo)
        {
            if (intPitchGapIndex < m_arrPitchGap.Count)
            {
                intFromLeadNo = m_arrPitchGap[intPitchGapIndex].intFromLeadNo + 1;
                intToLeadNo = m_arrPitchGap[intPitchGapIndex].intToLeadNo + 1;
            }
        }

        public void DefineLeadSpanStartEnd(bool blnStart, ROI objROI)
        {
            if (blnStart)
            {
                float fMinStart = 0;
                float fMaxStart = 0;
                for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
                {
                    m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                    if (m_stcBlobLead.intLengthMode == 2)
                    {
                        if (i == 0)
                        {
                            fMinStart = m_stcBlobLead.fTipCenterX;
                            fMaxStart = m_stcBlobLead.fTipCenterX;
                        }
                        else
                        {
                            if (m_stcBlobLead.fTipCenterX > fMinStart)
                                fMinStart = m_stcBlobLead.fTipCenterX;

                            if (m_stcBlobLead.fTipCenterX < fMaxStart)
                                fMaxStart = m_stcBlobLead.fTipCenterX;
                        }
                    }
                    else
                    {
                        if (i == 0)
                        {
                            fMinStart = m_stcBlobLead.fTipCenterY;
                            fMaxStart = m_stcBlobLead.fTipCenterY;
                        }
                        else
                        {
                            if (m_stcBlobLead.fTipCenterY > fMinStart)
                                fMinStart = m_stcBlobLead.fTipCenterY;

                            if (m_stcBlobLead.fTipCenterY < fMaxStart)
                                fMaxStart = m_stcBlobLead.fTipCenterY;
                        }
                    }
                }

                if (m_stcBlobLead.intLengthMode == 2)
                {
                    m_fLeadMinSpanStart = fMinStart + objROI.ref_ROITotalX;
                    m_fLeadMaxSpanStart = fMaxStart + objROI.ref_ROITotalX;
                }
                else
                {
                    m_fLeadMinSpanStart = fMinStart + objROI.ref_ROITotalY;
                    m_fLeadMaxSpanStart = fMaxStart + objROI.ref_ROITotalY;
                }
            }
            else
            {
                float fMinEnd = 0;
                float fMaxEnd = 0;
                for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
                {
                    m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                    if (m_stcBlobLead.intLengthMode == 2)
                    {
                        if (i == 0)
                        {
                            fMinEnd = m_stcBlobLead.fTipCenterX;
                            fMaxEnd = m_stcBlobLead.fTipCenterX;
                        }
                        else
                        {
                            if (m_stcBlobLead.fTipCenterX < fMinEnd)
                                fMinEnd = m_stcBlobLead.fTipCenterX;

                            if (m_stcBlobLead.fTipCenterX > fMaxEnd)
                                fMaxEnd = m_stcBlobLead.fTipCenterX;
                        }
                    }
                    else
                    {
                        if (i == 0)
                        {
                            fMinEnd = m_stcBlobLead.fTipCenterY;
                            fMaxEnd = m_stcBlobLead.fTipCenterY;
                        }
                        else
                        {
                            if (m_stcBlobLead.fTipCenterY < fMinEnd)
                                fMinEnd = m_stcBlobLead.fTipCenterY;

                            if (m_stcBlobLead.fTipCenterY > fMaxEnd)
                                fMaxEnd = m_stcBlobLead.fTipCenterY;
                        }
                    }
                }

                if (m_stcBlobLead.intLengthMode == 2)
                {
                    m_fLeadMinSpanEnd = fMinEnd + objROI.ref_ROITotalX;
                    m_fLeadMaxSpanEnd = fMaxEnd + objROI.ref_ROITotalX;
                }
                else
                {
                    m_fLeadMinSpanEnd = fMinEnd + objROI.ref_ROITotalY;
                    m_fLeadMaxSpanEnd = fMaxEnd + objROI.ref_ROITotalY;
                }

            }
        }

        /// <summary>
        /// Add pitch gap into m_arrPitchGap
        /// </summary>
        /// <param name="intFromLeadNo">from lead no</param>
        /// <param name="intToLeadNo">to lead no</param>
        /// <param name="fMinPitch">min pitch</param>
        /// <param name="fMaxPitch">max pitch</param>
        /// <param name="fMinGap">min gap</param>
        /// <param name="fMaxGap">max gap</param>
        /// <param name="fPitch">pitch</param>
        /// <param name="fGap">gap</param>
        /// <param name="intStartX">start X position</param>
        /// <param name="intStartY">start Y position</param>
        /// <param name="intEndX">end X position</param>
        /// <param name="intEndY">end Y position</param>
        /// <param name="intDirection">direction</param>
        public void SetPitchGapData(int intFromLeadNo, int intToLeadNo, float fMinPitch, float fMaxPitch, float fMinGap, float fMaxGap,
            float fPitch, float fGap, int intStartX, int intStartY, int intEndX, int intEndY, int intDirection)
        {
            m_stcPitchGap.intFromLeadNo = intFromLeadNo;
            m_stcPitchGap.intToLeadNo = intToLeadNo;
            m_stcPitchGap.fMinPitch = fMinPitch;
            m_stcPitchGap.fMaxPitch = fMaxPitch;
            m_stcPitchGap.fMinGap = fMinGap;
            m_stcPitchGap.fMaxGap = fMaxGap;
            m_stcPitchGap.fPitch = fPitch;
            m_stcPitchGap.fGap = fGap;
            m_stcPitchGap.intStartPointX = intStartX;
            m_stcPitchGap.intStartPointY = intStartY;
            m_stcPitchGap.intEndPointX = intEndX;
            m_stcPitchGap.intEndPointY = intEndY;
            m_stcPitchGap.intDirection = intDirection;

            m_arrPitchGap.Add(m_stcPitchGap);
        }

        public string GetMicronBlobsFeaturesData()
        {
            string strBlobsFeatures = "";
            float fData;
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fOffSet * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";

                //if (((BlobsFeatures)m_arrTemplateBlobLeads[i]).intLengthMode == 1)
                //{
                //fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinWidth * m_fMMToUnitValue;
                //strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                //fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxWidth * m_fMMToUnitValue;
                //strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                //fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinHeight * m_fMMToUnitValue;
                //strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                //fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxHeight * m_fMMToUnitValue;
                //strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";

                fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinTipWidth * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxTipWidth * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinTipHeight * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxTipHeight * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                //}
                //else
                //{
                //    //fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinHeight * m_fMMToUnitValue;
                //    //strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                //    //fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxHeight * m_fMMToUnitValue;
                //    //strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                //    //fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinWidth * m_fMMToUnitValue;
                //    //strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                //    //fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxWidth * m_fMMToUnitValue;
                //    //strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";

                //    fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinTipHeight * m_fMMToUnitValue;
                //    strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                //    fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxTipHeight * m_fMMToUnitValue;
                //    strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                //    fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMinTipWidth * m_fMMToUnitValue;
                //    strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                //    fData = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).fMaxTipWidth * m_fMMToUnitValue;
                //    strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";

                //}
            }
            return strBlobsFeatures;
        }

        public string GetMicronPitchGapData(int intPitchGapIndex)
        {
            string strPitchGapData = "";

            PitchGap stcPitchGap = m_arrPitchGap[intPitchGapIndex];

            strPitchGapData += stcPitchGap.intFromLeadNo.ToString() + "#";
            strPitchGapData += stcPitchGap.intToLeadNo.ToString() + "#";
            strPitchGapData += (stcPitchGap.fMinPitch).ToString() + "#";
            strPitchGapData += (stcPitchGap.fMaxPitch).ToString() + "#";
            strPitchGapData += (stcPitchGap.fMinGap).ToString() + "#";
            strPitchGapData += (stcPitchGap.fMaxGap).ToString() + "#";
            strPitchGapData += stcPitchGap.fGap.ToString() + "#";
            strPitchGapData += stcPitchGap.fPitch.ToString() + "#";
            strPitchGapData += stcPitchGap.intStartPointX.ToString() + "#";
            strPitchGapData += stcPitchGap.intStartPointY.ToString() + "#";
            strPitchGapData += stcPitchGap.intEndPointX.ToString() + "#";
            strPitchGapData += stcPitchGap.intEndPointY.ToString() + "#";
            strPitchGapData += stcPitchGap.intDirection.ToString() + "#";

            return strPitchGapData;
        }

        /// <summary>
        /// Build lead range, lead distance and define side lead
        /// </summary>
        /// <param name="objROI"></param>
        public void BuildLeadsParameter(int intLeadPosition, ROI objROI)
        {
            if (m_blnWantUsePkgToBaseTolerance)
                DefineLeadBaseTipWidthHeight_PkgToBase(intLeadPosition, objROI);
            else
                DefineLeadBaseTipWidthHeight(intLeadPosition, objROI);
            BuildLeadRange(objROI);
            BuildLeadDistance(objROI);
            BuildLeadReferencePoint(intLeadPosition, objROI);
            //DefineSideLead(15);
        }

        public void BuildLeadsParameter_CenterLead3D(ROI objROI)
        {
            DefineLeadBaseTipWidth_Lead3D(objROI);
            BuildLeadRange(objROI);
            BuildLeadDistance(objROI);
            BuildLeadReferencePoint_Lead3D(objROI);
            //DefineSideLead(15);
        }

        public void BuildLeadsParameter_SideLead3D(ROI objROI)
        {
            DefineLeadTipWidth_SideLead3D(objROI);
            BuildLeadRange(objROI);
            BuildLeadDistance(objROI);
            BuildLeadReferencePoint_Lead3D(objROI);
            //DefineSideLead(15);
        }
        public float BuildDontCareArea(ROI objROI, bool blnLearn)
        {
            // Define actual threshold value
            if (m_intDontCareBlobThreshold == -4)
                m_intDontCareBlobThreshold = GetAutoThresholdValue(objROI, 3);

            int intMaxShadowArea = m_intMaxShadowArea;
            //objROI.SaveImage("D:\\TS\\objROI.bmp");

            m_objEBlobs.BuildLeadObjects_Filter_GetElement(objROI, !m_blnWhiteOnBlack, true, 0, m_intDontCareBlobThreshold,
                    m_intMinShadowArea, objROI.ref_ROIWidth * objROI.ref_ROIHeight + 1, false, 0x1F);
            
            if (m_objEBlobs.ref_intNumSelectedObject > 0)
            {
                switch (m_intLeadROIDirection)
                {
                    case 1: // top
                        {
                            float fSelectedEndY = -1;
                            float fSelectedStartY = -1;
                            float fSelectedHeight = 0;
                            int intSelectedIndex = -1;
                            float fLeadStartY = objROI.ref_ROIHeight;
                            int[] arrBlobStatus = new int[m_objEBlobs.ref_intNumSelectedObject];
                            // Look for most outer blob with area under min max setting.
                            for (int i = 0; i < m_objEBlobs.ref_intNumSelectedObject; i++)
                            {
                                float fStartY = (m_objEBlobs.ref_arrLimitCenterY[i] - m_objEBlobs.ref_arrHeight[i] / 2);
                                float fEndY = (m_objEBlobs.ref_arrLimitCenterY[i] + m_objEBlobs.ref_arrHeight[i] / 2);

                                // The blob is considered Not Lead, not shadow if touch the outer edge.
                                if (fStartY <= 0)
                                {
                                    continue;
                                }

                                // The blob is considered as Lead if touch the inner edge.
                                if (fEndY >= objROI.ref_ROIHeight)
                                {
                                    // Record Lead outest position
                                    if (fLeadStartY > fStartY)
                                    {
                                        fLeadStartY = fStartY;
                                    }
                                    continue;
                                }

                                // If the blob position inside the lead outest position, mean it is not shadow.
                                if (fEndY > (fLeadStartY + m_intMaxShadowWidth))
                                {
                                    // Record Lead outest position
                                    if (fLeadStartY > fStartY)
                                    {
                                        fLeadStartY = fStartY;
                                    }
                                    continue;
                                }

                                if (m_objEBlobs.ref_arrArea[i] > intMaxShadowArea)
                                {
                                    // Record Lead outest position
                                    if (fLeadStartY > fStartY)
                                    {
                                        fLeadStartY = fStartY;
                                    }
                                    continue;

                                }

                                arrBlobStatus[i] = 1;
                            }

                            for (int i = 0; i < m_objEBlobs.ref_intNumSelectedObject; i++)
                            {
                                if (arrBlobStatus[i] == 0)
                                    continue;

                                float fStartY = (m_objEBlobs.ref_arrLimitCenterY[i] - m_objEBlobs.ref_arrHeight[i] / 2);
                                float fEndY = (m_objEBlobs.ref_arrLimitCenterY[i] + m_objEBlobs.ref_arrHeight[i] / 2);

                                // If the blob position inside the lead outest position, mean it is not shadow.
                                if (fEndY > (fLeadStartY + m_intMaxShadowWidth))
                                {
                                    // Record Lead outest position
                                    if (fLeadStartY > fStartY)
                                    {
                                        fLeadStartY = fStartY;
                                    }
                                    arrBlobStatus[i] = 0;
                                    continue;
                                }

                                if (fSelectedEndY == -1 || (fSelectedStartY > (m_objEBlobs.ref_arrLimitCenterY[i] - m_objEBlobs.ref_arrHeight[i] / 2)))
                                {

                                    fSelectedStartY = (m_objEBlobs.ref_arrLimitCenterY[i] - m_objEBlobs.ref_arrHeight[i] / 2);
                                    intSelectedIndex = i;
                                }

                                if (fSelectedHeight < m_objEBlobs.ref_arrHeight[i])
                                {
                                    fSelectedHeight = m_objEBlobs.ref_arrHeight[i];
                                }

                                if (fSelectedEndY == -1 || (fSelectedEndY < (m_objEBlobs.ref_arrLimitCenterY[i] + m_objEBlobs.ref_arrHeight[i] / 2)))
                                {
                                    fSelectedEndY = (m_objEBlobs.ref_arrLimitCenterY[i] + m_objEBlobs.ref_arrHeight[i] / 2);
                                }
                            }

                            // 
                            float fSelectedEndY2 = fSelectedEndY;
                            for (int i = 0; i < m_objEBlobs.ref_intNumSelectedObject; i++)
                            {
                                if (arrBlobStatus[i] == 0)
                                    continue;

                                if (i == intSelectedIndex)
                                    continue;

                                if (m_objEBlobs.ref_arrLimitCenterY[i] < fSelectedEndY)
                                {
                                    fSelectedEndY2 = Math.Max(fSelectedEndY2, (m_objEBlobs.ref_arrLimitCenterY[i] + m_objEBlobs.ref_arrHeight[i] / 2));

                                }
                            }

                            if (blnLearn)
                            {
                                for (int i = m_objEBlobs.ref_intNumSelectedObject - 1; i >= 0; i--)
                                {
                                    if (arrBlobStatus[i] == 0)
                                        m_objEBlobs.RemoveBlobElement(i);
                                }
                            }

                            if (intSelectedIndex == -1)
                                return -1;
                            else
                                return fSelectedEndY2;
                        }
                    case 2: // right
                        {
                            float fSelectedEndX = -1;
                            float fSelectedStartX = -1;
                            float fSelectedWitdh = 0;
                            int intSelectedIndex = -1;
                            float fLeadEndX = 0;
                            int[] arrBlobStatus = new int[m_objEBlobs.ref_intNumSelectedObject];
                            // Look for most outer blob with area under min max setting.
                            for (int i = 0; i < m_objEBlobs.ref_intNumSelectedObject; i++)
                            {
                                float fStartX = (m_objEBlobs.ref_arrLimitCenterX[i] - m_objEBlobs.ref_arrWidth[i] / 2);
                                float fEndX = (m_objEBlobs.ref_arrLimitCenterX[i] + m_objEBlobs.ref_arrWidth[i] / 2);

                                // The blob is considered Not Lead, not shadow if touch the outer edge.
                                if (fEndX >= objROI.ref_ROIWidth)
                                {
                                    continue;
                                }

                                // The blob is considered as Lead if touch the inner edge.
                                if (fStartX <= 0)
                                {
                                    // Record Lead outest position
                                    if (fLeadEndX < fEndX)
                                    {
                                        fLeadEndX = fEndX;
                                    }
                                    continue;
                                }

                                // If the blob position inside thee lead outest position, mean it is not shadow.
                                if (fStartX < (fLeadEndX - m_intMaxShadowWidth))
                                {
                                    // Record Lead outest position
                                    if (fLeadEndX < fEndX)
                                    {
                                        fLeadEndX = fEndX;
                                    }
                                    continue;
                                }

                                if (m_objEBlobs.ref_arrArea[i] > intMaxShadowArea)
                                {
                                    // Record Lead outest position
                                    if (fLeadEndX < fEndX)
                                    {
                                        fLeadEndX = fEndX;
                                    }
                                    continue;

                                }

                                arrBlobStatus[i] = 1;
                            }

                            for (int i = 0; i < m_objEBlobs.ref_intNumSelectedObject; i++)
                            {
                                if (arrBlobStatus[i] == 0)
                                    continue;

                                float fStartX = (m_objEBlobs.ref_arrLimitCenterX[i] - m_objEBlobs.ref_arrWidth[i] / 2);
                                float fEndX = (m_objEBlobs.ref_arrLimitCenterX[i] + m_objEBlobs.ref_arrWidth[i] / 2);

                                // If the blob position inside thee lead outest position, mean it is not shadow.
                                if (fStartX < (fLeadEndX - m_intMaxShadowWidth))
                                {
                                    // Record Lead outest position
                                    if (fLeadEndX < fEndX)
                                    {
                                        fLeadEndX = fEndX;
                                    }
                                    arrBlobStatus[i] = 0;
                                    continue;
                                }

                                if (fSelectedEndX == -1 || (fSelectedEndX < (m_objEBlobs.ref_arrLimitCenterX[i] + m_objEBlobs.ref_arrWidth[i] / 2)))
                                {
                                    fSelectedEndX = (m_objEBlobs.ref_arrLimitCenterX[i] + m_objEBlobs.ref_arrWidth[i] / 2);
                                    intSelectedIndex = i;
                                }

                                if (fSelectedWitdh < m_objEBlobs.ref_arrWidth[i])
                                {
                                    fSelectedWitdh = m_objEBlobs.ref_arrWidth[i];
                                }

                                if (fSelectedStartX == -1 || (fSelectedStartX > (m_objEBlobs.ref_arrLimitCenterX[i] - m_objEBlobs.ref_arrWidth[i] / 2)))
                                {
                                    fSelectedStartX = (m_objEBlobs.ref_arrLimitCenterX[i] - m_objEBlobs.ref_arrWidth[i] / 2);
                                }
                            }

                            // 
                            float fSelectedStartX2 = fSelectedStartX;
                            for (int i = 0; i < m_objEBlobs.ref_intNumSelectedObject; i++)
                            {
                                if (arrBlobStatus[i] == 0)
                                    continue;

                                if (i == intSelectedIndex)
                                    continue;

                                if (m_objEBlobs.ref_arrLimitCenterX[i] > fSelectedStartX)
                                {
                                    fSelectedStartX2 = Math.Min(fSelectedStartX2, (m_objEBlobs.ref_arrLimitCenterX[i] - m_objEBlobs.ref_arrWidth[i] / 2));

                                }
                            }

                            if (blnLearn)
                            {
                                for (int i = m_objEBlobs.ref_intNumSelectedObject - 1; i >= 0; i--)
                                {
                                    if (arrBlobStatus[i] == 0)
                                        m_objEBlobs.RemoveBlobElement(i);
                                }
                            }

                            if (intSelectedIndex == -1)
                                return -1;
                            else
                                return fSelectedStartX2;
                        }
                    case 3: // bottom
                        {
                            float fSelectedEndY = -1;
                            float fSelectedStartY = -1;
                            float fSelectedHeight = 0;
                            int intSelectedIndex = -1;
                            float fLeadEndY = 0;
                            int[] arrBlobStatus = new int[m_objEBlobs.ref_intNumSelectedObject];
                            // Look for most outer blob with area under min max setting.
                            for (int i = 0; i < m_objEBlobs.ref_intNumSelectedObject; i++)
                            {
                                float fStartY = (m_objEBlobs.ref_arrLimitCenterY[i] - m_objEBlobs.ref_arrHeight[i] / 2);
                                float fEndY = (m_objEBlobs.ref_arrLimitCenterY[i] + m_objEBlobs.ref_arrHeight[i] / 2);

                                // The blob is considered Not Lead, not shadow if touch the outer edge.
                                if (fEndY >= objROI.ref_ROIHeight)
                                {
                                    continue;
                                }

                                // The blob is considered as Lead if touch the inner edge.
                                if (fStartY <= 0)
                                {
                                    // Record Lead outest position
                                    if (fLeadEndY < fEndY)
                                    {
                                        fLeadEndY = fEndY;
                                    }
                                    continue;
                                }

                                // If the blob position inside thee lead outest position, mean it is not shadow.
                                if (fStartY < (fLeadEndY - m_intMaxShadowWidth))
                                {
                                    // Record Lead outest position
                                    if (fLeadEndY < fEndY)
                                    {
                                        fLeadEndY = fEndY;
                                    }
                                    continue;
                                }

                                if (m_objEBlobs.ref_arrArea[i] > intMaxShadowArea)
                                {
                                    // Record Lead outest position
                                    if (fLeadEndY < fEndY)
                                    {
                                        fLeadEndY = fEndY;
                                    }
                                    continue;

                                }

                                arrBlobStatus[i] = 1;
                            }

                            for (int i = 0; i < m_objEBlobs.ref_intNumSelectedObject; i++)
                            {
                                if (arrBlobStatus[i] == 0)
                                    continue;

                                float fStartY = (m_objEBlobs.ref_arrLimitCenterY[i] - m_objEBlobs.ref_arrHeight[i] / 2);
                                float fEndY = (m_objEBlobs.ref_arrLimitCenterY[i] + m_objEBlobs.ref_arrHeight[i] / 2);

                                if (fStartY < (fLeadEndY - m_intMaxShadowWidth))
                                {
                                    // Record Lead outest position
                                    if (fLeadEndY < fEndY)
                                    {
                                        fLeadEndY = fEndY;
                                    }
                                    arrBlobStatus[i] = 0;
                                    continue;
                                }

                                if (fSelectedEndY == -1 || (fSelectedEndY < (m_objEBlobs.ref_arrLimitCenterY[i] + m_objEBlobs.ref_arrHeight[i] / 2)))
                                {
                                    fSelectedEndY = (m_objEBlobs.ref_arrLimitCenterY[i] + m_objEBlobs.ref_arrHeight[i] / 2);
                                    intSelectedIndex = i;
                                }

                                if (fSelectedHeight < m_objEBlobs.ref_arrHeight[i])
                                {
                                    fSelectedHeight = m_objEBlobs.ref_arrHeight[i];
                                }

                                if (fSelectedStartY == -1 || (fSelectedStartY > (m_objEBlobs.ref_arrLimitCenterY[i] - m_objEBlobs.ref_arrHeight[i] / 2)))
                                {
                                    fSelectedStartY = (m_objEBlobs.ref_arrLimitCenterY[i] - m_objEBlobs.ref_arrHeight[i] / 2);
                                }
                            }

                            // 
                            float fSelectedStartY2 = fSelectedStartY;
                            if (intSelectedIndex >= 0)
                            {
                                for (int i = 0; i < m_objEBlobs.ref_intNumSelectedObject; i++)
                                {
                                    if (arrBlobStatus[i] == 0)
                                        continue;

                                    if (i == intSelectedIndex)
                                        continue;

                                    if (m_objEBlobs.ref_arrLimitCenterY[i] > fSelectedStartY)
                                    {
                                        fSelectedStartY2 = Math.Min(fSelectedStartY2, (m_objEBlobs.ref_arrLimitCenterY[i] - m_objEBlobs.ref_arrHeight[i] / 2));

                                    }
                                }
                            }

                            if (blnLearn)
                            {
                                for (int i = m_objEBlobs.ref_intNumSelectedObject - 1; i >= 0; i--)
                                {
                                    if (arrBlobStatus[i] == 0)
                                        m_objEBlobs.RemoveBlobElement(i);
                                }
                            }

                            if (intSelectedIndex == -1)
                                return -1;
                            else
                                return fSelectedStartY2;
                        }
                    case 4:
                        {
                            float fSelectedEndX = -1;
                            float fSelectedStartX = -1;
                            float fSelectedWitdh = 0;
                            int intSelectedIndex = -1;
                            float fLeadStartX = objROI.ref_ROIWidth;
                            int[] arrBlobStatus = new int[m_objEBlobs.ref_intNumSelectedObject];
                            // Look for most outer blob with area under min max setting.
                            for (int i = 0; i < m_objEBlobs.ref_intNumSelectedObject; i++)
                            {
                                float fStartX = (m_objEBlobs.ref_arrLimitCenterX[i] - m_objEBlobs.ref_arrWidth[i] / 2);
                                float fEndX = (m_objEBlobs.ref_arrLimitCenterX[i] + m_objEBlobs.ref_arrWidth[i] / 2);

                                // The blob is considered Not Lead, not shadow if touch the outer edge.
                                if (fStartX <= 0)
                                {
                                    continue;
                                }

                                // The blob is considered as Lead if touch the inner edge.
                                if (fEndX >= objROI.ref_ROIWidth)
                                {
                                    // Record Lead outest position
                                    if (fLeadStartX > fStartX)
                                    {
                                        fLeadStartX = fStartX;
                                    }
                                    continue;
                                }

                                // If the blob position inside the lead outest position, mean it is not shadow.
                                if (fEndX > (fLeadStartX + m_intMaxShadowWidth))
                                {
                                    // Record Lead outest position
                                    if (fLeadStartX > fStartX)
                                    {
                                        fLeadStartX = fStartX;
                                    }
                                    continue;
                                }

                                if (m_objEBlobs.ref_arrArea[i] > intMaxShadowArea)
                                {
                                    // Record Lead outest position
                                    if (fLeadStartX > fStartX)
                                    {
                                        fLeadStartX = fStartX;
                                    }
                                    continue;

                                }

                                arrBlobStatus[i] = 1;
                            }

                            for (int i = 0; i < m_objEBlobs.ref_intNumSelectedObject; i++)
                            {
                                if (arrBlobStatus[i] == 0)
                                    continue;

                                float fStartX = (m_objEBlobs.ref_arrLimitCenterX[i] - m_objEBlobs.ref_arrWidth[i] / 2);
                                float fEndX = (m_objEBlobs.ref_arrLimitCenterX[i] + m_objEBlobs.ref_arrWidth[i] / 2);

                                // If the blob position inside the lead outest position, mean it is not shadow.
                                if (fEndX > (fLeadStartX + m_intMaxShadowWidth))
                                {
                                    // Record Lead outest position
                                    if (fLeadStartX > fStartX)
                                    {
                                        fLeadStartX = fStartX;
                                    }
                                    arrBlobStatus[i] = 0;
                                    continue;
                                }

                                if (fSelectedEndX == -1 || (fSelectedStartX > (m_objEBlobs.ref_arrLimitCenterX[i] - m_objEBlobs.ref_arrWidth[i] / 2)))
                                {

                                    fSelectedStartX = (m_objEBlobs.ref_arrLimitCenterX[i] - m_objEBlobs.ref_arrWidth[i] / 2);
                                    intSelectedIndex = i;
                                }

                                if (fSelectedWitdh < m_objEBlobs.ref_arrWidth[i])
                                {
                                    fSelectedWitdh = m_objEBlobs.ref_arrWidth[i];
                                }

                                if (fSelectedEndX == -1 || (fSelectedEndX < (m_objEBlobs.ref_arrLimitCenterX[i] + m_objEBlobs.ref_arrWidth[i] / 2)))
                                {
                                    fSelectedEndX = (m_objEBlobs.ref_arrLimitCenterX[i] + m_objEBlobs.ref_arrWidth[i] / 2);
                                }
                            }

                            // 
                            float fSelectedEndX2 = fSelectedEndX;
                            for (int i = 0; i < m_objEBlobs.ref_intNumSelectedObject; i++)
                            {
                                if (arrBlobStatus[i] == 0)
                                    continue;

                                if (i == intSelectedIndex)
                                    continue;

                                if (m_objEBlobs.ref_arrLimitCenterX[i] < fSelectedEndX)
                                {
                                    fSelectedEndX2 = Math.Max(fSelectedEndX2, (m_objEBlobs.ref_arrLimitCenterX[i] + m_objEBlobs.ref_arrWidth[i] / 2));

                                }
                            }

                            if (blnLearn)
                            {
                                for (int i = m_objEBlobs.ref_intNumSelectedObject - 1; i >= 0; i--)
                                {
                                    if (arrBlobStatus[i] == 0)
                                        m_objEBlobs.RemoveBlobElement(i);
                                }
                            }

                            if (intSelectedIndex == -1)
                                return -1;
                            else
                                return fSelectedEndX2;
                        }
                }

                return -1;

            }
            else
                return -1;
        }
        public float BuildDontCareArea2(ROI objROI, bool blnLearn)
        {
            // Define actual threshold value
            if (m_intDontCareBlobThreshold == -4)
                m_intDontCareBlobThreshold = GetAutoThresholdValue(objROI, 3);

            int intMaxShadowArea = m_intMaxShadowArea;// 1000;
            //objROI.SaveImage("D:\\TS\\objROI.bmp");

            m_objEBlobs.BuildLeadObjects_Filter_GetElement(objROI, !m_blnWhiteOnBlack, true, 0, m_intDontCareBlobThreshold,
                    m_intMinShadowArea, objROI.ref_ROIWidth * objROI.ref_ROIHeight + 1, false, 0x1F);
            
            if (m_objEBlobs.ref_intNumSelectedObject > 0)
            {
                switch (m_intLeadROIDirection)
                {
                    case 1: // top
                        {
                            float fSelectedEndY = -1;
                            float fSelectedStartY = -1;
                            float fSelectedHeight = 0;
                            int intSelectedIndex = -1;
                            float fLeadStartY = objROI.ref_ROIHeight;
                            int[] arrBlobStatus = new int[m_objEBlobs.ref_intNumSelectedObject];
                            // Look for most outer blob with area under min max setting.
                            for (int i = 0; i < m_objEBlobs.ref_intNumSelectedObject; i++)
                            {
                                float fStartY = (m_objEBlobs.ref_arrLimitCenterY[i] - m_objEBlobs.ref_arrHeight[i] / 2);
                                float fEndY = (m_objEBlobs.ref_arrLimitCenterY[i] + m_objEBlobs.ref_arrHeight[i] / 2);

                                // The blob is considered as Lead if touch the inner edge.
                                if (fEndY >= objROI.ref_ROIWidth)
                                {
                                    // Record Lead outest position
                                    if (fLeadStartY > fStartY)
                                    {
                                        fLeadStartY = fStartY;
                                    }
                                    continue;
                                }

                                // If the blob position inside the lead outest position, mean it is not shadow.
                                if (fStartY > fLeadStartY)
                                {
                                    continue;
                                }

                                if (m_objEBlobs.ref_arrArea[i] > intMaxShadowArea)
                                {
                                    // Record Lead outest position
                                    if (fLeadStartY > fStartY)
                                    {
                                        fLeadStartY = fStartY;
                                    }
                                    continue;

                                }
                                else
                                {
                                    arrBlobStatus[i] = 1;

                                    if (fSelectedEndY == -1 || (fSelectedStartY > (m_objEBlobs.ref_arrLimitCenterY[i] - m_objEBlobs.ref_arrHeight[i] / 2)))
                                    {

                                        fSelectedStartY = (m_objEBlobs.ref_arrLimitCenterY[i] - m_objEBlobs.ref_arrHeight[i] / 2);
                                        intSelectedIndex = i;
                                    }

                                    if (fSelectedHeight < m_objEBlobs.ref_arrHeight[i])
                                    {
                                        fSelectedHeight = m_objEBlobs.ref_arrHeight[i];
                                    }

                                    if (fSelectedEndY == -1 || (fSelectedEndY < (m_objEBlobs.ref_arrLimitCenterY[i] + m_objEBlobs.ref_arrHeight[i] / 2)))
                                    {
                                        fSelectedEndY = (m_objEBlobs.ref_arrLimitCenterY[i] + m_objEBlobs.ref_arrHeight[i] / 2);
                                    }
                                }
                            }

                            // 
                            float fSelectedEndY2 = fSelectedEndY;
                            for (int i = 0; i < m_objEBlobs.ref_intNumSelectedObject; i++)
                            {
                                if (arrBlobStatus[i] == 0)
                                    continue;

                                if (i == intSelectedIndex)
                                    continue;

                                if (m_objEBlobs.ref_arrLimitCenterY[i] < fSelectedEndY)
                                {
                                    fSelectedEndY2 = Math.Max(fSelectedEndY2, (m_objEBlobs.ref_arrLimitCenterY[i] + m_objEBlobs.ref_arrHeight[i] / 2));

                                }
                            }

                            if (blnLearn)
                            {
                                for (int i = m_objEBlobs.ref_intNumSelectedObject - 1; i >= 0; i--)
                                {
                                    if (arrBlobStatus[i] == 0)
                                        m_objEBlobs.RemoveBlobElement(i);
                                }
                            }

                            if (intSelectedIndex == -1)
                                return -1;
                            else
                                return fSelectedEndY2;
                        }
                    case 2: // right
                        {
                            float fSelectedEndX = -1;
                            float fSelectedStartX = -1;
                            float fSelectedWitdh = 0;
                            int intSelectedIndex = -1;
                            float fLeadEndX = 0;
                            int[] arrBlobStatus = new int[m_objEBlobs.ref_intNumSelectedObject];
                            // Look for most outer blob with area under min max setting.
                            for (int i = 0; i < m_objEBlobs.ref_intNumSelectedObject; i++)
                            {
                                float fStartX = (m_objEBlobs.ref_arrLimitCenterX[i] - m_objEBlobs.ref_arrWidth[i] / 2);
                                float fEndX = (m_objEBlobs.ref_arrLimitCenterX[i] + m_objEBlobs.ref_arrWidth[i] / 2);

                                // The blob is considered as Lead if touch the inner edge.
                                if (fStartX <= 0)
                                {
                                    // Record Lead outest position
                                    if (fLeadEndX < fEndX)
                                    {
                                        fLeadEndX = fEndX;
                                    }
                                    continue;
                                }

                                // If the blob position inside thee lead outest position, mean it is not shadow.
                                if (fEndX < fLeadEndX)
                                {
                                    continue;
                                }

                                if (m_objEBlobs.ref_arrArea[i] > intMaxShadowArea)
                                {
                                    // Record Lead outest position
                                    if (fLeadEndX < fEndX)
                                    {
                                        fLeadEndX = fEndX;
                                    }
                                    continue;

                                }
                                else
                                {
                                    arrBlobStatus[i] = 1;

                                    if (fSelectedEndX == -1 || (fSelectedEndX < (m_objEBlobs.ref_arrLimitCenterX[i] + m_objEBlobs.ref_arrWidth[i] / 2)))
                                    {
                                        fSelectedEndX = (m_objEBlobs.ref_arrLimitCenterX[i] + m_objEBlobs.ref_arrWidth[i] / 2);
                                        intSelectedIndex = i;
                                    }

                                    if (fSelectedWitdh < m_objEBlobs.ref_arrWidth[i])
                                    {
                                        fSelectedWitdh = m_objEBlobs.ref_arrWidth[i];
                                    }

                                    if (fSelectedStartX == -1 || (fSelectedStartX > (m_objEBlobs.ref_arrLimitCenterX[i] - m_objEBlobs.ref_arrWidth[i] / 2)))
                                    {
                                        fSelectedStartX = (m_objEBlobs.ref_arrLimitCenterX[i] - m_objEBlobs.ref_arrWidth[i] / 2);
                                    }
                                }
                            }

                            // 
                            float fSelectedStartX2 = fSelectedStartX;
                            for (int i = 0; i < m_objEBlobs.ref_intNumSelectedObject; i++)
                            {
                                if (arrBlobStatus[i] == 0)
                                    continue;

                                if (i == intSelectedIndex)
                                    continue;

                                if (m_objEBlobs.ref_arrLimitCenterX[i] > fSelectedStartX)
                                {
                                    fSelectedStartX2 = Math.Min(fSelectedStartX2, (m_objEBlobs.ref_arrLimitCenterX[i] - m_objEBlobs.ref_arrWidth[i] / 2));

                                }
                            }

                            if (blnLearn)
                            {
                                for (int i = m_objEBlobs.ref_intNumSelectedObject - 1; i >= 0; i--)
                                {
                                    if (arrBlobStatus[i] == 0)
                                        m_objEBlobs.RemoveBlobElement(i);
                                }
                            }

                            if (intSelectedIndex == -1)
                                return -1;
                            else
                                return fSelectedStartX2;
                        }
                    case 3: // bottom
                        {
                            float fSelectedEndY = -1;
                            float fSelectedStartY = -1;
                            float fSelectedHeight = 0;
                            int intSelectedIndex = -1;
                            float fLeadEndY = 0;
                            int[] arrBlobStatus = new int[m_objEBlobs.ref_intNumSelectedObject];
                            // Look for most outer blob with area under min max setting.
                            for (int i = 0; i < m_objEBlobs.ref_intNumSelectedObject; i++)
                            {
                                float fStartY = (m_objEBlobs.ref_arrLimitCenterY[i] - m_objEBlobs.ref_arrHeight[i] / 2);
                                float fEndY = (m_objEBlobs.ref_arrLimitCenterY[i] + m_objEBlobs.ref_arrHeight[i] / 2);

                                // The blob is considered as Lead if touch the inner edge.
                                if (fStartY <= 0)
                                {
                                    // Record Lead outest position
                                    if (fLeadEndY < fEndY)
                                    {
                                        fLeadEndY = fEndY;
                                    }
                                    continue;
                                }

                                // If the blob position inside thee lead outest position, mean it is not shadow.
                                if (fEndY < fLeadEndY)
                                {
                                    continue;
                                }

                                if (m_objEBlobs.ref_arrArea[i] > intMaxShadowArea)
                                {
                                    // Record Lead outest position
                                    if (fLeadEndY < fEndY)
                                    {
                                        fLeadEndY = fEndY;
                                    }
                                    continue;

                                }
                                else
                                {
                                    arrBlobStatus[i] = 1;

                                    if (fSelectedEndY == -1 || (fSelectedEndY < (m_objEBlobs.ref_arrLimitCenterY[i] + m_objEBlobs.ref_arrHeight[i] / 2)))
                                    {
                                        fSelectedEndY = (m_objEBlobs.ref_arrLimitCenterY[i] + m_objEBlobs.ref_arrHeight[i] / 2);
                                        intSelectedIndex = i;
                                    }

                                    if (fSelectedHeight < m_objEBlobs.ref_arrHeight[i])
                                    {
                                        fSelectedHeight = m_objEBlobs.ref_arrHeight[i];
                                    }

                                    if (fSelectedStartY == -1 || (fSelectedStartY > (m_objEBlobs.ref_arrLimitCenterY[i] - m_objEBlobs.ref_arrHeight[i] / 2)))
                                    {
                                        fSelectedStartY = (m_objEBlobs.ref_arrLimitCenterY[i] - m_objEBlobs.ref_arrHeight[i] / 2);
                                    }
                                }
                            }

                            // 
                            float fSelectedStartY2 = fSelectedStartY;
                            if (intSelectedIndex >= 0)
                            {
                                for (int i = 0; i < m_objEBlobs.ref_intNumSelectedObject; i++)
                                {
                                    if (arrBlobStatus[i] == 0)
                                        continue;

                                    if (i == intSelectedIndex)
                                        continue;

                                    if (m_objEBlobs.ref_arrLimitCenterY[i] > fSelectedStartY)
                                    {
                                        fSelectedStartY2 = Math.Min(fSelectedStartY2, (m_objEBlobs.ref_arrLimitCenterY[i] - m_objEBlobs.ref_arrHeight[i] / 2));

                                    }
                                }
                            }

                            if (blnLearn)
                            {
                                for (int i = m_objEBlobs.ref_intNumSelectedObject - 1; i >= 0; i--)
                                {
                                    if (arrBlobStatus[i] == 0)
                                        m_objEBlobs.RemoveBlobElement(i);
                                }
                            }

                            if (intSelectedIndex == -1)
                                return -1;
                            else
                                return fSelectedStartY2;
                        }
                    case 4:
                        {
                            float fSelectedEndX = -1;
                            float fSelectedStartX = -1;
                            float fSelectedWitdh = 0;
                            int intSelectedIndex = -1;
                            float fLeadStartX = objROI.ref_ROIWidth;
                            int[] arrBlobStatus = new int[m_objEBlobs.ref_intNumSelectedObject];
                            // Look for most outer blob with area under min max setting.
                            for (int i = 0; i < m_objEBlobs.ref_intNumSelectedObject; i++)
                            {
                                float fStartX = (m_objEBlobs.ref_arrLimitCenterX[i] - m_objEBlobs.ref_arrWidth[i] / 2);
                                float fEndX = (m_objEBlobs.ref_arrLimitCenterX[i] + m_objEBlobs.ref_arrWidth[i] / 2);

                                // The blob is considered as Lead if touch the inner edge.
                                if (fEndX >= objROI.ref_ROIWidth)
                                {
                                    // Record Lead outest position
                                    if (fLeadStartX > fStartX)
                                    {
                                        fLeadStartX = fStartX;
                                    }
                                    continue;
                                }

                                // If the blob position inside the lead outest position, mean it is not shadow.
                                if (fStartX > fLeadStartX)
                                {
                                    continue;
                                }

                                if (m_objEBlobs.ref_arrArea[i] > intMaxShadowArea)
                                {
                                    // Record Lead outest position
                                    if (fLeadStartX > fStartX)
                                    {
                                        fLeadStartX = fStartX;
                                    }
                                    continue;

                                }
                                else
                                {
                                    arrBlobStatus[i] = 1;

                                    if (fSelectedEndX == -1 || (fSelectedStartX > (m_objEBlobs.ref_arrLimitCenterX[i] - m_objEBlobs.ref_arrWidth[i] / 2)))
                                    {

                                        fSelectedStartX = (m_objEBlobs.ref_arrLimitCenterX[i] - m_objEBlobs.ref_arrWidth[i] / 2);
                                        intSelectedIndex = i;
                                    }

                                    if (fSelectedWitdh < m_objEBlobs.ref_arrWidth[i])
                                    {
                                        fSelectedWitdh = m_objEBlobs.ref_arrWidth[i];
                                    }

                                    if (fSelectedEndX == -1 || (fSelectedEndX < (m_objEBlobs.ref_arrLimitCenterX[i] + m_objEBlobs.ref_arrWidth[i] / 2)))
                                    {
                                        fSelectedEndX = (m_objEBlobs.ref_arrLimitCenterX[i] + m_objEBlobs.ref_arrWidth[i] / 2);
                                    }
                                }
                            }

                            // 
                            float fSelectedEndX2 = fSelectedEndX;
                            for (int i = 0; i < m_objEBlobs.ref_intNumSelectedObject; i++)
                            {
                                if (arrBlobStatus[i] == 0)
                                    continue;

                                if (i == intSelectedIndex)
                                    continue;

                                if (m_objEBlobs.ref_arrLimitCenterX[i] < fSelectedEndX)
                                {
                                    fSelectedEndX2 = Math.Max(fSelectedEndX2, (m_objEBlobs.ref_arrLimitCenterX[i] + m_objEBlobs.ref_arrWidth[i] / 2));

                                }
                            }

                            if (blnLearn)
                            {
                                for (int i = m_objEBlobs.ref_intNumSelectedObject - 1; i >= 0; i--)
                                {
                                    if (arrBlobStatus[i] == 0)
                                        m_objEBlobs.RemoveBlobElement(i);
                                }
                            }

                            if (intSelectedIndex == -1)
                                return -1;
                            else
                                return fSelectedEndX2;
                        }
                }

                return -1;

            }
            else
                return -1;
        }
        /// <summary>
        /// Build object in ROI
        /// </summary>
        /// <param name="objROI">ROI</param>
        /// <returns>true = selected objects > 0, false = otherwise</returns>
        public bool BuildOnlyLeadObjects(ROI objROI)
        {
            // Define actual threshold value
            m_intThresholdValuePrev = m_intThresholdValue;
            if (m_intThresholdValue == -4)
                m_intThresholdValue = GetAutoThresholdValue(objROI, 3);

            //2020-09-11 ZJYEOH : Set remove border to false because when lead is longer than ROI then will become missing lead
            m_objEBlobs.BuildLeadObjects_Filter_GetElement(objROI, !m_blnWhiteOnBlack, true, 0, m_intThresholdValue,
                m_intFilterMinArea, objROI.ref_ROIWidth * objROI.ref_ROIHeight, false, 0x1F);

            m_intThresholdValue = m_intThresholdValuePrev;

            if (m_objEBlobs.ref_intNumSelectedObject > 0)
                return true;
            else
                return false;
        }
        public bool BuildOnlyLeadObjects_BaseLead(ROI objROI)
        {
            // Define actual threshold value
            //m_intThresholdValuePrev = m_intThresholdValue_BaseLead;
            if (m_intThresholdValue_BaseLead == -4)
                m_intThresholdValue_BaseLead = GetAutoThresholdValue(objROI, 3);

            //2020-09-11 ZJYEOH : Set remove border to false because when lead is longer than ROI then will become missing lead
            m_objEBlobs_BaseLead.BuildLeadObjects_Filter_GetElement(objROI, !m_blnWhiteOnBlack, true, 0, m_intThresholdValue_BaseLead,
                m_intFilterMinArea_BaseLead, objROI.ref_ROIWidth * objROI.ref_ROIHeight, false, 0x1F);

            //m_intThresholdValue_BaseLead = m_intThresholdValuePrev;

            if (m_objEBlobs_BaseLead.ref_intNumSelectedObject > 0)
                return true;
            else
                return false;
        }
        public bool BuildOnlySideLeadObjects_BlackObject(ROI objROI)
        {
            m_objEBlobs.BuildObjects_Filter_GetElement(objROI, !m_blnWhiteOnBlack, true, 0, m_intThresholdValue,
                m_intFilterMinArea, m_intMaxArea, false, 0x1F);
            bool blnDebugImage = false;
            if (blnDebugImage)
            {
                objROI.SaveImage("D:\\TS\\objSampleBlobROI.bmp");//debug
            }
            if (m_objEBlobs.ref_intNumSelectedObject > 0)
                return true;
            else
                return false;
        }

        /// <summary>
        /// Build Lead pitch gap link
        /// </summary>
        /// <param name="blnUpdateTolerance">true = use default pitch gap tolerance, false = use previous pitch gap tolerance</param>
        public void BuildLeadPitchLink(bool blnUpdateTolerance)
        {
            int intCheckCount = m_arrTemplateBlobLeads.Count - 1;
            BlobsFeatures stcFirstBlobsFeatures;
            BlobsFeatures stcSecondBlobsFeatures;

            bool blnFound;
            int intDrawPoint;
            int intPitchCount = 0;
            bool blnUpDownFound;
            bool blnLeftRightFound;
            m_arrPitchGap.Clear();
            for (int i = 0; i < intCheckCount; i++)
            {
                m_stcPitchGap = new PitchGap();
                m_stcPitchGap.intFromLeadNo = i;
                m_stcPitchGap.intToLeadNo = i + 1;
                blnFound = false;
                blnUpDownFound = false;
                blnLeftRightFound = false;
                stcFirstBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                stcSecondBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobLeads[i + 1];

                int intStartX_1 = 0, intStartY_1 = 0, intEndX_1 = 0, intEndY_1 = 0;
                int intStartX_2 = 0, intStartY_2 = 0, intEndX_2 = 0, intEndY_2 = 0;

                switch (m_intLeadROIDirection)
                {
                    case 1: //Top
                        intStartX_1 = (int)(stcFirstBlobsFeatures.fTipCenterX - stcFirstBlobsFeatures.fTipWidth / 2);

                        intEndX_1 = (int)(stcFirstBlobsFeatures.fTipCenterX + stcFirstBlobsFeatures.fTipWidth / 2);

                        intStartY_1 = (int)(stcFirstBlobsFeatures.fTipCenterY);

                        intEndY_1 = (int)(stcFirstBlobsFeatures.fTipCenterY + stcFirstBlobsFeatures.fTipHeight);
                        break;
                    case 2: //Right
                        intStartX_1 = (int)(stcFirstBlobsFeatures.fTipCenterX - stcFirstBlobsFeatures.fTipHeight);

                        intEndX_1 = (int)(stcFirstBlobsFeatures.fTipCenterX);

                        intStartY_1 = (int)(stcFirstBlobsFeatures.fTipCenterY - stcFirstBlobsFeatures.fTipWidth / 2);

                        intEndY_1 = (int)(stcFirstBlobsFeatures.fTipCenterY + stcFirstBlobsFeatures.fTipWidth / 2);
                        break;
                    case 3: //Bottom
                        intStartX_1 = (int)(stcFirstBlobsFeatures.fTipCenterX - stcFirstBlobsFeatures.fTipWidth / 2);

                        intEndX_1 = (int)(stcFirstBlobsFeatures.fTipCenterX + stcFirstBlobsFeatures.fTipWidth / 2);

                        intStartY_1 = (int)(stcFirstBlobsFeatures.fTipCenterY - stcFirstBlobsFeatures.fTipHeight);

                        intEndY_1 = (int)(stcFirstBlobsFeatures.fTipCenterY);
                        break;
                    case 4: //Left
                        intStartX_1 = (int)(stcFirstBlobsFeatures.fTipCenterX);

                        intEndX_1 = (int)(stcFirstBlobsFeatures.fTipCenterX + stcFirstBlobsFeatures.fTipHeight);

                        intStartY_1 = (int)(stcFirstBlobsFeatures.fTipCenterY - stcFirstBlobsFeatures.fTipWidth / 2);

                        intEndY_1 = (int)(stcFirstBlobsFeatures.fTipCenterY + stcFirstBlobsFeatures.fTipWidth / 2);
                        break;
                }

                switch (m_intLeadROIDirection)
                {
                    case 1: //Top
                        intStartX_2 = (int)(stcSecondBlobsFeatures.fTipCenterX - stcSecondBlobsFeatures.fTipWidth / 2);

                        intEndX_2 = (int)(stcSecondBlobsFeatures.fTipCenterX + stcSecondBlobsFeatures.fTipWidth / 2);

                        intStartY_2 = (int)(stcSecondBlobsFeatures.fTipCenterY);

                        intEndY_2 = (int)(stcSecondBlobsFeatures.fTipCenterY + stcSecondBlobsFeatures.fTipHeight);
                        break;
                    case 2: //Right
                        intStartX_2 = (int)(stcSecondBlobsFeatures.fTipCenterX - stcSecondBlobsFeatures.fTipHeight);

                        intEndX_2 = (int)(stcSecondBlobsFeatures.fTipCenterX);

                        intStartY_2 = (int)(stcSecondBlobsFeatures.fTipCenterY - stcSecondBlobsFeatures.fTipWidth / 2);

                        intEndY_2 = (int)(stcSecondBlobsFeatures.fTipCenterY + stcSecondBlobsFeatures.fTipWidth / 2);
                        break;
                    case 3: //Bottom
                        intStartX_2 = (int)(stcSecondBlobsFeatures.fTipCenterX - stcSecondBlobsFeatures.fTipWidth / 2);

                        intEndX_2 = (int)(stcSecondBlobsFeatures.fTipCenterX + stcSecondBlobsFeatures.fTipWidth / 2);

                        intStartY_2 = (int)(stcSecondBlobsFeatures.fTipCenterY - stcSecondBlobsFeatures.fTipHeight);

                        intEndY_2 = (int)(stcSecondBlobsFeatures.fTipCenterY);
                        break;
                    case 4: //Left
                        intStartX_2 = (int)(stcSecondBlobsFeatures.fTipCenterX);

                        intEndX_2 = (int)(stcSecondBlobsFeatures.fTipCenterX + stcSecondBlobsFeatures.fTipHeight);

                        intStartY_2 = (int)(stcSecondBlobsFeatures.fTipCenterY - stcSecondBlobsFeatures.fTipWidth / 2);

                        intEndY_2 = (int)(stcSecondBlobsFeatures.fTipCenterY + stcSecondBlobsFeatures.fTipWidth / 2);
                        break;
                }
                // Check pitch available between up and down Leads
                if ((intStartX_1 >= intStartX_2) && (intStartX_1 <= intEndX_2) ||
                    (intEndX_1 >= intStartX_2) && (intEndX_1 <= intEndX_2) ||
                    (intStartX_2 >= intStartX_1) && (intEndX_2 <= intEndX_1) ||
                    (intEndX_2 >= intStartX_1) && (intEndX_2 <= intEndX_1))
                {
                    blnUpDownFound = true;
                }

                // Check pitch available between left and right Leads
                if ((intStartY_1 >= intStartY_2) && (intStartY_1 <= intEndY_2) ||
                    (intEndY_1 >= intStartY_2) && (intEndY_1 <= intEndY_2) ||
                    (intStartY_2 >= intStartY_1) && (intEndY_2 <= intEndY_1) ||
                    (intEndY_2 >= intStartY_1) && (intEndY_2 <= intEndY_1))
                {
                    blnLeftRightFound = true;
                }


                if ((blnLeftRightFound && !blnUpDownFound) || (!blnLeftRightFound && blnUpDownFound))
                {
                    if (blnUpDownFound)
                    {
                        // Pitch only available if distance gap between Leads > 1 pixel
                        if ((intStartY_2 - intEndY_1) > 1)
                        {
                            intDrawPoint = GetDrawPoint(intStartX_1, intEndX_1, intStartX_2, intEndX_2);
                            m_stcPitchGap.intStartPointX = intDrawPoint;
                            m_stcPitchGap.intEndPointX = intDrawPoint;
                            m_stcPitchGap.intStartPointY = intEndY_1;
                            m_stcPitchGap.intEndPointY = intStartY_2;
                            m_stcPitchGap.fGap = intStartY_2 - intEndY_1;
                            m_stcPitchGap.fPitch = stcSecondBlobsFeatures.fTipCenterY - stcFirstBlobsFeatures.fTipCenterY;
                            m_stcPitchGap.intDirection = 180;
                            //if (blnUpdateTolerance)
                            //    DefinePitchGapTolerance();
                            //else
                            UpdatePreviousPitchToleranceToTemplate(intPitchCount);//UpdatePreviousPitchToleranceToTemplate(); // 2021-06-03 ZJYEOH : Assign previous tolerance according to intPitchGapIndex
                            blnFound = true;
                        }
                        else if ((intStartY_1 - intEndY_2) > 1)
                        {
                            intDrawPoint = GetDrawPoint(intStartX_1, intEndX_1, intStartX_2, intEndX_2);
                            m_stcPitchGap.intStartPointX = intDrawPoint;
                            m_stcPitchGap.intEndPointX = intDrawPoint;
                            m_stcPitchGap.intStartPointY = intStartY_1;
                            m_stcPitchGap.intEndPointY = intEndY_2;
                            m_stcPitchGap.fGap = intStartY_1 - intEndY_2;
                            m_stcPitchGap.fPitch = stcFirstBlobsFeatures.fTipCenterY - stcSecondBlobsFeatures.fTipCenterY;
                            m_stcPitchGap.intDirection = 0;
                            //if (blnUpdateTolerance)
                            //    DefinePitchGapTolerance();
                            //else
                            UpdatePreviousPitchToleranceToTemplate(intPitchCount);//UpdatePreviousPitchToleranceToTemplate(); // 2021-06-03 ZJYEOH : Assign previous tolerance according to intPitchGapIndex
                            blnFound = true;
                        }
                    }
                    else
                    {
                        // Pitch only available if distance gap between Leads > 1 pixel
                        if ((intStartX_2 - intEndX_1) > 1)
                        {
                            intDrawPoint = GetDrawPoint(intStartY_1, intEndY_1, intStartY_2, intEndY_2);
                            m_stcPitchGap.intStartPointX = intEndX_1;
                            m_stcPitchGap.intEndPointX = intStartX_2;
                            m_stcPitchGap.intStartPointY = intDrawPoint;
                            m_stcPitchGap.intEndPointY = intDrawPoint;
                            m_stcPitchGap.fGap = intStartX_2 - intEndX_1;
                            m_stcPitchGap.fPitch = stcSecondBlobsFeatures.fTipCenterX - stcFirstBlobsFeatures.fTipCenterX;
                            m_stcPitchGap.intDirection = 90;
                            //if (blnUpdateTolerance)
                            //    DefinePitchGapTolerance();
                            //else
                            UpdatePreviousPitchToleranceToTemplate(intPitchCount);//UpdatePreviousPitchToleranceToTemplate(); // 2021-06-03 ZJYEOH : Assign previous tolerance according to intPitchGapIndex
                            blnFound = true;
                        }
                        else if ((intStartX_1 - intEndX_2) > 1)
                        {
                            intDrawPoint = GetDrawPoint(intStartY_1, intEndY_1, intStartY_2, intEndY_2);
                            m_stcPitchGap.intStartPointX = intStartX_1;
                            m_stcPitchGap.intEndPointX = intEndX_2;
                            m_stcPitchGap.intStartPointY = intDrawPoint;
                            m_stcPitchGap.intEndPointY = intDrawPoint;
                            m_stcPitchGap.fGap = intStartX_1 - intEndX_2;
                            m_stcPitchGap.fPitch = stcFirstBlobsFeatures.fTipCenterX - stcSecondBlobsFeatures.fTipCenterX;
                            m_stcPitchGap.intDirection = 270;
                            //if (blnUpdateTolerance)
                            //    DefinePitchGapTolerance();
                            //else
                            UpdatePreviousPitchToleranceToTemplate(intPitchCount);//UpdatePreviousPitchToleranceToTemplate(); // 2021-06-03 ZJYEOH : Assign previous tolerance according to intPitchGapIndex
                            blnFound = true;
                        }
                    }
                }

                //// Define Top Gap and Pitch
                //if (((stcFirstBlobsFeatures.intDirection == 0x05) && (stcSecondBlobsFeatures.intDirection == 0x04)) ||
                //    ((stcFirstBlobsFeatures.intDirection == 0x04) && (stcSecondBlobsFeatures.intDirection == 0x04)) ||
                //    ((stcFirstBlobsFeatures.intDirection == 0x04) && (stcSecondBlobsFeatures.intDirection == 0x06)) ||
                //    ((stcFirstBlobsFeatures.intDirection == 0x0D) && (stcSecondBlobsFeatures.intDirection == 0x0C)) ||
                //    ((stcFirstBlobsFeatures.intDirection == 0x0C) && (stcSecondBlobsFeatures.intDirection == 0x0C)) ||
                //    ((stcFirstBlobsFeatures.intDirection == 0x0C) && (stcSecondBlobsFeatures.intDirection == 0x0E)))
                //{
                //    if (stcSecondBlobsFeatures.fStartX > stcFirstBlobsFeatures.fEndX)
                //    {
                //        intDrawPoint = GetDrawPoint(stcFirstBlobsFeatures.intStartY, stcFirstBlobsFeatures.intEndY, stcSecondBlobsFeatures.intStartY, stcSecondBlobsFeatures.intEndY);
                //        m_stcPitchGap.intStartPointX = stcSecondBlobsFeatures.intStartX;
                //        m_stcPitchGap.intEndPointX = stcFirstBlobsFeatures.intEndX;
                //        m_stcPitchGap.intStartPointY = intDrawPoint;
                //        m_stcPitchGap.intEndPointY = intDrawPoint;
                //        //m_stcPitchGap.fGap = stcSecondBlobsFeatures.fStartX - stcFirstBlobsFeatures.fEndX;
                //        m_stcPitchGap.fPitch = stcSecondBlobsFeatures.fLimitCenterX - stcFirstBlobsFeatures.fLimitCenterX;
                //        m_stcPitchGap.intDirection = 90;
                //        if (blnUpdateTolerance)
                //            DefinePitchGapTolerance();
                //        else
                //            UpdatePreviousPitchToleranceToTemplate(intPitchCount);
                //        blnFound = true;
                //    }
                //}
                //// Define Right Gap and Pitch
                //else if (((stcFirstBlobsFeatures.intDirection == 0x06) && (stcSecondBlobsFeatures.intDirection == 0x02)) ||
                //    ((stcFirstBlobsFeatures.intDirection == 0x02) && (stcSecondBlobsFeatures.intDirection == 0x02)) ||
                //    ((stcFirstBlobsFeatures.intDirection == 0x02) && (stcSecondBlobsFeatures.intDirection == 0x0A)) ||
                //    ((stcFirstBlobsFeatures.intDirection == 0x07) && (stcSecondBlobsFeatures.intDirection == 0x03)) ||
                //    ((stcFirstBlobsFeatures.intDirection == 0x03) && (stcSecondBlobsFeatures.intDirection == 0x03)) ||
                //    ((stcFirstBlobsFeatures.intDirection == 0x03) && (stcSecondBlobsFeatures.intDirection == 0x0B)))
                //{
                //    if (stcSecondBlobsFeatures.fStartY > stcFirstBlobsFeatures.fEndY)
                //    {
                //        intDrawPoint = GetDrawPoint(stcFirstBlobsFeatures.intStartX, stcFirstBlobsFeatures.intEndX, stcSecondBlobsFeatures.intStartX, stcSecondBlobsFeatures.intEndX);
                //        m_stcPitchGap.intStartPointY = stcSecondBlobsFeatures.intStartY;
                //        m_stcPitchGap.intEndPointY = stcFirstBlobsFeatures.intEndY;
                //        m_stcPitchGap.intStartPointX = intDrawPoint;
                //        m_stcPitchGap.intEndPointX = intDrawPoint;
                //        //m_stcPitchGap.fGap = stcSecondBlobsFeatures.fStartY - stcFirstBlobsFeatures.fEndY;
                //        m_stcPitchGap.fPitch = stcSecondBlobsFeatures.fLimitCenterY - stcFirstBlobsFeatures.fLimitCenterY;
                //        m_stcPitchGap.intDirection = 180;
                //        if (blnUpdateTolerance)
                //            DefinePitchGapTolerance();
                //        else
                //            UpdatePreviousPitchToleranceToTemplate(intPitchCount);
                //        blnFound = true;
                //    }
                //}
                //// Define Bottom Gap and Pitch
                //else if (((stcFirstBlobsFeatures.intDirection == 0x0A) && (stcSecondBlobsFeatures.intDirection == 0x08)) ||
                //    ((stcFirstBlobsFeatures.intDirection == 0x08) && (stcSecondBlobsFeatures.intDirection == 0x08)) ||
                //    ((stcFirstBlobsFeatures.intDirection == 0x08) && (stcSecondBlobsFeatures.intDirection == 0x09)))
                //{
                //    if (stcFirstBlobsFeatures.fStartX > stcSecondBlobsFeatures.fEndX)
                //    {
                //        intDrawPoint = GetDrawPoint(stcFirstBlobsFeatures.intStartY, stcFirstBlobsFeatures.intEndY, stcSecondBlobsFeatures.intStartY, stcSecondBlobsFeatures.intEndY);
                //        m_stcPitchGap.intStartPointX = stcSecondBlobsFeatures.intEndX;
                //        m_stcPitchGap.intEndPointX = stcFirstBlobsFeatures.intStartX;
                //        m_stcPitchGap.intStartPointY = intDrawPoint;
                //        m_stcPitchGap.intEndPointY = intDrawPoint;
                //        //m_stcPitchGap.fGap = stcFirstBlobsFeatures.fStartX - stcSecondBlobsFeatures.fEndX;
                //        m_stcPitchGap.fPitch = stcFirstBlobsFeatures.fLimitCenterX - stcSecondBlobsFeatures.fLimitCenterX;
                //        m_stcPitchGap.intDirection = 270;
                //        if (blnUpdateTolerance)
                //            DefinePitchGapTolerance();
                //        else
                //            UpdatePreviousPitchToleranceToTemplate(intPitchCount);
                //        blnFound = true;
                //    }
                //}
                //// Define Left Gap and Pitch
                //else if (((stcFirstBlobsFeatures.intDirection == 0x09) && (stcSecondBlobsFeatures.intDirection == 0x01)) ||
                //    ((stcFirstBlobsFeatures.intDirection == 0x01) && (stcSecondBlobsFeatures.intDirection == 0x01)) ||
                //    ((stcFirstBlobsFeatures.intDirection == 0x01) && (stcSecondBlobsFeatures.intDirection == 0x05)))
                //{
                //    if (stcFirstBlobsFeatures.fStartY > stcSecondBlobsFeatures.fEndY)
                //    {
                //        intDrawPoint = GetDrawPoint(stcFirstBlobsFeatures.intStartX, stcFirstBlobsFeatures.intEndX, stcSecondBlobsFeatures.intStartX, stcSecondBlobsFeatures.intEndX);
                //        m_stcPitchGap.intStartPointY = stcSecondBlobsFeatures.intEndY;
                //        m_stcPitchGap.intEndPointY = stcFirstBlobsFeatures.intStartY;
                //        m_stcPitchGap.intStartPointX = intDrawPoint;
                //        m_stcPitchGap.intEndPointX = intDrawPoint;
                //        //m_stcPitchGap.fGap = stcFirstBlobsFeatures.fStartY - stcSecondBlobsFeatures.fEndY;
                //        m_stcPitchGap.fPitch = stcFirstBlobsFeatures.fLimitCenterY - stcSecondBlobsFeatures.fLimitCenterY;
                //        m_stcPitchGap.intDirection = 0;
                //        if (blnUpdateTolerance)
                //            DefinePitchGapTolerance();
                //        else
                //            UpdatePreviousPitchToleranceToTemplate(intPitchCount);
                //        blnFound = true;
                //    }
                //}

                if (blnFound)
                {
                    intPitchCount++;
                    m_arrPitchGap.Add(m_stcPitchGap);
                }

            }
        }

        /// <summary>
        /// Analyzing lead
        /// </summary>
        /// <param name="intLeadPosition">lead position</param>
        public void AnalyingLead_ClosestSizeMethod(int intLeadPosition)
        {
            // Reset blob pitch, gab and direction information
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                m_stcBlobLead.intDirection = -1;
                m_stcBlobLead.intGroupID = intLeadPosition;
                m_stcBlobLead.fPitch = -1;
                m_stcBlobLead.fGap = -1;
                m_stcBlobLead.intNoID = 0;
                m_arrTemplateBlobLeads.RemoveAt(i);
                m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
            }

            ClassifyObjectLengthMode(intLeadPosition);
            ClassifyObjectsToDirectionGroup(intLeadPosition);
            SortObjectNumber(intLeadPosition);
            RearrangeBlobs();

            //m_arrPitchGap.Clear();
        }

        public void AnalyingLead_DefaultToleranceMethod(int intLeadPosition)
        {
            // Reset blob pitch, gab and direction information
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                m_stcBlobLead.intDirection = -1;
                m_stcBlobLead.intGroupID = intLeadPosition;
                m_stcBlobLead.fPitch = -1;
                m_stcBlobLead.fGap = -1;
                m_stcBlobLead.intNoID = 0;
                m_arrTemplateBlobLeads.RemoveAt(i);
                m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
            }

            ClassifyObjectLengthMode(intLeadPosition);
            ClassifyObjectsToDirectionGroup(intLeadPosition);
            SortObjectNumber();
            RearrangeBlobs();

            m_arrPitchGap.Clear();
        }

        public void AnalyingLead_DefaultToleranceMethod(int intLeadPosition, bool blnClockWise, ref int intLeadNo)
        {
            // Reset blob pitch, gab and direction information
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                m_stcBlobLead.intDirection = -1;
                m_stcBlobLead.intGroupID = intLeadPosition;
                m_stcBlobLead.fPitch = -1;
                m_stcBlobLead.fGap = -1;
                m_stcBlobLead.intNoID = 0;
                m_arrTemplateBlobLeads.RemoveAt(i);
                m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
            }

            ClassifyObjectLengthMode(intLeadPosition);
            ClassifyObjectsToDirectionGroup(intLeadPosition);
            SortObjectNumber(intLeadPosition, blnClockWise, ref intLeadNo);
            RearrangeBlobs(intLeadNo);

            m_arrPitchGap.Clear();
        }

        /// <summary>
        /// Check the direction of the Lead (left column, right column, high row, low row)
        /// </summary>
        /// <param name="intLeadPosition">Lead position</param>
        private void ClassifyObjectLengthMode(int intLeadPosition)
        {
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                if (!m_stcBlobLead.blnSelected)
                    continue;

                if (intLeadPosition == 1 || intLeadPosition == 3)
                {
                    m_stcBlobLead.intLengthMode = 1;   // 1 mean length == height
                }
                else if (intLeadPosition == 2 || intLeadPosition == 4)
                {
                    m_stcBlobLead.intLengthMode = 2;   // 2 mean length == width
                }

                m_arrTemplateBlobLeads.RemoveAt(i);
                m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
            }
        }

        /// <summary>
        /// Check the direction of the Lead (left column, right column, high row, low row)
        /// </summary>
        /// <param name="intLeadPosition">Lead position</param>
        private void ClassifyObjectsToDirectionGroup(int intLeadPosition)
        {
            BlobsFeatures stcBlobsFeatures = new BlobsFeatures();
            int intDirectionMask;

            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                if (!m_stcBlobLead.blnSelected)
                    continue;

                intDirectionMask = 0x0F;

                for (int j = 0; j < m_arrTemplateBlobLeads.Count; j++)
                {
                    if (i == j)
                        continue;

                    stcBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobLeads[j];

                    if (!stcBlobsFeatures.blnSelected)
                        continue;

                    if (intLeadPosition != 2 && intLeadPosition != 4)
                    {
                        // Check is left column
                        if ((m_stcBlobLead.intStartX + (int)m_fDefineSizePixel) > (stcBlobsFeatures.intEndX - (int)m_fDefineSizePixel))
                        {
                            intDirectionMask &= ~0x01;
                        }

                        // Check is right column
                        if ((m_stcBlobLead.intEndX - (int)m_fDefineSizePixel) < (stcBlobsFeatures.intStartX + (int)m_fDefineSizePixel))
                        {
                            intDirectionMask &= ~0x02;
                        }
                    }

                    if (intLeadPosition != 1 && intLeadPosition != 3)
                    {
                        // Check is high row
                        if ((m_stcBlobLead.intStartY + (int)m_fDefineSizePixel) > (stcBlobsFeatures.intEndY - (int)m_fDefineSizePixel))
                        {
                            intDirectionMask &= ~0x04;
                        }

                        // Check is low row
                        if ((m_stcBlobLead.intEndY - (int)m_fDefineSizePixel) < (stcBlobsFeatures.intStartY + (int)m_fDefineSizePixel))
                        {
                            intDirectionMask &= ~0x08;
                        }
                    }
                }
                m_stcBlobLead.intDirection = intDirectionMask;
                m_arrTemplateBlobLeads.RemoveAt(i);
                m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
            }
        }

        /// <summary>
        /// Back up all data of blobs features into m_arrTemporaryBlobLeads
        /// </summary>
        public void BackupBlobsFeatures()
        {
            BlobsFeatures stcTemporaryBlobLead;
            m_arrTemporaryBlobLeads = new ArrayList();
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                stcTemporaryBlobLead = new BlobsFeatures();
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                stcTemporaryBlobLead.fArea = m_stcBlobLead.fArea;
                stcTemporaryBlobLead.fCenterX = m_stcBlobLead.fCenterX;
                stcTemporaryBlobLead.fCenterY = m_stcBlobLead.fCenterY;
                stcTemporaryBlobLead.fLimitCenterX = m_stcBlobLead.fLimitCenterX;
                stcTemporaryBlobLead.fLimitCenterY = m_stcBlobLead.fLimitCenterY;
                stcTemporaryBlobLead.fWidth = m_stcBlobLead.fWidth;
                stcTemporaryBlobLead.fHeight = m_stcBlobLead.fHeight;
                stcTemporaryBlobLead.intLengthMode = m_stcBlobLead.intLengthMode;
                stcTemporaryBlobLead.intContourX = m_stcBlobLead.intContourX;
                stcTemporaryBlobLead.intContourY = m_stcBlobLead.intContourY;
                stcTemporaryBlobLead.arrContourX = m_stcBlobLead.arrContourX;
                stcTemporaryBlobLead.arrContourY = m_stcBlobLead.arrContourY;
                stcTemporaryBlobLead.intObjNo = m_stcBlobLead.intObjNo;
                stcTemporaryBlobLead.fStartX = m_stcBlobLead.fStartX;
                stcTemporaryBlobLead.fEndX = m_stcBlobLead.fEndX;
                stcTemporaryBlobLead.fStartY = m_stcBlobLead.fStartY;
                stcTemporaryBlobLead.fEndY = m_stcBlobLead.fEndY;
                stcTemporaryBlobLead.intStartX = m_stcBlobLead.intStartX;
                stcTemporaryBlobLead.intEndX = m_stcBlobLead.intEndX;
                stcTemporaryBlobLead.intStartY = m_stcBlobLead.intStartY;
                stcTemporaryBlobLead.intEndY = m_stcBlobLead.intEndY;
                stcTemporaryBlobLead.blnSelected = m_stcBlobLead.blnSelected;
                stcTemporaryBlobLead.intDirection = m_stcBlobLead.intDirection;
                stcTemporaryBlobLead.intGroupID = m_stcBlobLead.intGroupID;
                stcTemporaryBlobLead.fPitch = m_stcBlobLead.fPitch;
                stcTemporaryBlobLead.fGap = m_stcBlobLead.fGap;
                stcTemporaryBlobLead.intNoID = m_stcBlobLead.intNoID;
                stcTemporaryBlobLead.intSelectedBlob = m_stcBlobLead.intSelectedBlob;
                stcTemporaryBlobLead.arrSelectedBlob = m_stcBlobLead.arrSelectedBlob;

                stcTemporaryBlobLead.intBaseInwardOffset = m_stcBlobLead.intBaseInwardOffset;
                stcTemporaryBlobLead.intTipInwardOffset = m_stcBlobLead.intTipInwardOffset;

                stcTemporaryBlobLead.intAGVROITolerance_Top = m_stcBlobLead.intAGVROITolerance_Top;
                stcTemporaryBlobLead.intAGVROITolerance_Bottom = m_stcBlobLead.intAGVROITolerance_Bottom;
                stcTemporaryBlobLead.intAGVROITolerance_Left = m_stcBlobLead.intAGVROITolerance_Left;
                stcTemporaryBlobLead.intAGVROITolerance_Right = m_stcBlobLead.intAGVROITolerance_Right;

                m_arrTemporaryBlobLeads.Add(stcTemporaryBlobLead);
            }
        }
        public void BackupBlobsFeatures_BaseLead()
        {
            BlobsFeatures stcTemporaryBlobLead;
            m_arrTemporaryBlobLeads_BaseLead = new ArrayList();
            for (int i = 0; i < m_arrTemplateBlobLeads_BaseLead.Count; i++)
            {
                stcTemporaryBlobLead = new BlobsFeatures();
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i];

                stcTemporaryBlobLead.fArea = m_stcBlobLead.fArea;
                stcTemporaryBlobLead.fCenterX = m_stcBlobLead.fCenterX;
                stcTemporaryBlobLead.fCenterY = m_stcBlobLead.fCenterY;
                stcTemporaryBlobLead.fLimitCenterX = m_stcBlobLead.fLimitCenterX;
                stcTemporaryBlobLead.fLimitCenterY = m_stcBlobLead.fLimitCenterY;
                stcTemporaryBlobLead.fWidth = m_stcBlobLead.fWidth;
                stcTemporaryBlobLead.fHeight = m_stcBlobLead.fHeight;
                stcTemporaryBlobLead.intLengthMode = m_stcBlobLead.intLengthMode;
                stcTemporaryBlobLead.intContourX = m_stcBlobLead.intContourX;
                stcTemporaryBlobLead.intContourY = m_stcBlobLead.intContourY;
                stcTemporaryBlobLead.arrContourX = m_stcBlobLead.arrContourX;
                stcTemporaryBlobLead.arrContourY = m_stcBlobLead.arrContourY;
                stcTemporaryBlobLead.intObjNo = m_stcBlobLead.intObjNo;
                stcTemporaryBlobLead.fStartX = m_stcBlobLead.fStartX;
                stcTemporaryBlobLead.fEndX = m_stcBlobLead.fEndX;
                stcTemporaryBlobLead.fStartY = m_stcBlobLead.fStartY;
                stcTemporaryBlobLead.fEndY = m_stcBlobLead.fEndY;
                stcTemporaryBlobLead.intStartX = m_stcBlobLead.intStartX;
                stcTemporaryBlobLead.intEndX = m_stcBlobLead.intEndX;
                stcTemporaryBlobLead.intStartY = m_stcBlobLead.intStartY;
                stcTemporaryBlobLead.intEndY = m_stcBlobLead.intEndY;
                stcTemporaryBlobLead.blnSelected = m_stcBlobLead.blnSelected;
                stcTemporaryBlobLead.intDirection = m_stcBlobLead.intDirection;
                stcTemporaryBlobLead.intGroupID = m_stcBlobLead.intGroupID;
                stcTemporaryBlobLead.fPitch = m_stcBlobLead.fPitch;
                stcTemporaryBlobLead.fGap = m_stcBlobLead.fGap;
                stcTemporaryBlobLead.intNoID = m_stcBlobLead.intNoID;
                stcTemporaryBlobLead.intSelectedBlob = m_stcBlobLead.intSelectedBlob;
                stcTemporaryBlobLead.arrSelectedBlob = m_stcBlobLead.arrSelectedBlob;

                stcTemporaryBlobLead.intBaseInwardOffset = m_stcBlobLead.intBaseInwardOffset;
                stcTemporaryBlobLead.intTipInwardOffset = m_stcBlobLead.intTipInwardOffset;

                stcTemporaryBlobLead.intAGVROITolerance_Top = m_stcBlobLead.intAGVROITolerance_Top;
                stcTemporaryBlobLead.intAGVROITolerance_Bottom = m_stcBlobLead.intAGVROITolerance_Bottom;
                stcTemporaryBlobLead.intAGVROITolerance_Left = m_stcBlobLead.intAGVROITolerance_Left;
                stcTemporaryBlobLead.intAGVROITolerance_Right = m_stcBlobLead.intAGVROITolerance_Right;

                m_arrTemporaryBlobLeads_BaseLead.Add(stcTemporaryBlobLead);
            }
        }

        /// <summary>
        /// Backup all tolerance of blobs features into m_arrBackupTemplateBlobLeads and all tolerance of pitch gap into m_arrTolePitchGap
        /// </summary>
        public void BackupPreviousTolerance()
        {
            m_arrBackupTemplateBlobLeads.Clear();
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                m_stcBackupTemplateBlobLead.intDirection = m_stcBlobLead.intDirection;
                m_stcBackupTemplateBlobLead.intNoID = m_stcBlobLead.intNoID;
                m_stcBackupTemplateBlobLead.intGroupID = m_stcBlobLead.intGroupID;
                m_stcBackupTemplateBlobLead.fStartX = m_stcBlobLead.fStartX;
                m_stcBackupTemplateBlobLead.fStartY = m_stcBlobLead.fStartY;
                m_stcBackupTemplateBlobLead.fEndX = m_stcBlobLead.fEndX;
                m_stcBackupTemplateBlobLead.fEndY = m_stcBlobLead.fEndY;
                m_stcBackupTemplateBlobLead.fLimitCenterX = m_stcBlobLead.fLimitCenterX;
                m_stcBackupTemplateBlobLead.fLimitCenterY = m_stcBlobLead.fLimitCenterY;
                m_stcBackupTemplateBlobLead.fOffSet = m_stcBlobLead.fOffSet;
                m_stcBackupTemplateBlobLead.fSkew = m_stcBlobLead.fSkew;
                m_stcBackupTemplateBlobLead.fVariance = m_stcBlobLead.fVariance;
                m_stcBackupTemplateBlobLead.fMinAGV = m_stcBlobLead.fMinAGV;
                m_stcBackupTemplateBlobLead.fMaxAGV = m_stcBlobLead.fMaxAGV;
                m_stcBackupTemplateBlobLead.fMinWidth = m_stcBlobLead.fMinWidth;
                m_stcBackupTemplateBlobLead.fMaxWidth = m_stcBlobLead.fMaxWidth;
                m_stcBackupTemplateBlobLead.fMinHeight = m_stcBlobLead.fMinHeight;
                m_stcBackupTemplateBlobLead.fMaxHeight = m_stcBlobLead.fMaxHeight;

                m_stcBackupTemplateBlobLead.fMinBaseWidth = m_stcBlobLead.fMinBaseWidth;
                m_stcBackupTemplateBlobLead.fMaxBaseWidth = m_stcBlobLead.fMaxBaseWidth;
                m_stcBackupTemplateBlobLead.fMinBaseHeight = m_stcBlobLead.fMinBaseHeight;
                m_stcBackupTemplateBlobLead.fMaxBaseHeight = m_stcBlobLead.fMaxBaseHeight;
                m_stcBackupTemplateBlobLead.fMinTipWidth = m_stcBlobLead.fMinTipWidth;
                m_stcBackupTemplateBlobLead.fMaxTipWidth = m_stcBlobLead.fMaxTipWidth;
                m_stcBackupTemplateBlobLead.fMinTipHeight = m_stcBlobLead.fMinTipHeight;
                m_stcBackupTemplateBlobLead.fMaxTipHeight = m_stcBlobLead.fMaxTipHeight;

                m_stcBackupTemplateBlobLead.intLengthMode = m_stcBlobLead.intLengthMode;
                m_stcBackupTemplateBlobLead.fLearnArea = m_stcBlobLead.fArea;
                m_stcBackupTemplateBlobLead.fLearnWidth = m_stcBlobLead.fWidth;
                m_stcBackupTemplateBlobLead.fLearnHeight = m_stcBlobLead.fHeight;
                
                m_stcBackupTemplateBlobLead.intBaseInwardOffset = m_stcBlobLead.intBaseInwardOffset;
                m_stcBackupTemplateBlobLead.intTipInwardOffset = m_stcBlobLead.intTipInwardOffset;

                m_stcBackupTemplateBlobLead.intAGVROITolerance_Top = m_stcBlobLead.intAGVROITolerance_Top;
                m_stcBackupTemplateBlobLead.intAGVROITolerance_Bottom = m_stcBlobLead.intAGVROITolerance_Bottom;
                m_stcBackupTemplateBlobLead.intAGVROITolerance_Left = m_stcBlobLead.intAGVROITolerance_Left;
                m_stcBackupTemplateBlobLead.intAGVROITolerance_Right = m_stcBlobLead.intAGVROITolerance_Right;

                m_stcBackupTemplateBlobLead.fWidthOffset = m_stcBlobLead.fWidthOffset;
                m_stcBackupTemplateBlobLead.fLengthOffset = m_stcBlobLead.fLengthOffset;
                m_stcBackupTemplateBlobLead.fPitchOffset = m_stcBlobLead.fPitchOffset;
                m_stcBackupTemplateBlobLead.fGapOffset = m_stcBlobLead.fGapOffset;

                m_arrBackupTemplateBlobLeads.Add(m_stcBackupTemplateBlobLead);
            }

            m_arrTolePitchGap.Clear();
            for (int i = 0; i < m_arrPitchGap.Count; i++)
            {
                m_stcTolePitchGap.fMinPitch = m_arrPitchGap[i].fMinPitch;
                m_stcTolePitchGap.fMaxPitch = m_arrPitchGap[i].fMaxPitch;
                m_stcTolePitchGap.fMinGap = m_arrPitchGap[i].fMinGap;
                m_stcTolePitchGap.fMaxGap = m_arrPitchGap[i].fMaxGap;
                m_arrTolePitchGap.Add(m_stcTolePitchGap);
            }

            m_arrBackupPitchGap.Clear();
            PitchGap stcPitchGap = new PitchGap();
            for (int i = 0; i < m_arrPitchGap.Count; i++)
            {
                stcPitchGap.intFromLeadNo = m_arrPitchGap[i].intFromLeadNo;
                stcPitchGap.intToLeadNo = m_arrPitchGap[i].intToLeadNo;
                stcPitchGap.intDirection = m_arrPitchGap[i].intDirection;
                stcPitchGap.fPitch = m_arrPitchGap[i].fPitch;
                stcPitchGap.fGap = m_arrPitchGap[i].fGap;
                stcPitchGap.fPitchMM = m_arrPitchGap[i].fPitchMM;
                stcPitchGap.fGapMM = m_arrPitchGap[i].fGapMM;
                stcPitchGap.fMinPitch = m_arrPitchGap[i].fMinPitch;
                stcPitchGap.fMaxPitch = m_arrPitchGap[i].fMaxPitch;
                stcPitchGap.fMinGap = m_arrPitchGap[i].fMinGap;
                stcPitchGap.fMaxGap = m_arrPitchGap[i].fMaxGap;
                stcPitchGap.intStartPointX = m_arrPitchGap[i].intStartPointX;
                stcPitchGap.intStartPointY = m_arrPitchGap[i].intStartPointY;
                stcPitchGap.intEndPointX = m_arrPitchGap[i].intEndPointX;
                stcPitchGap.intEndPointY = m_arrPitchGap[i].intEndPointY;
                stcPitchGap.intFailMask = m_arrPitchGap[i].intFailMask;

                m_arrBackupPitchGap.Add(stcPitchGap);
            }
        }
        public void BackupPreviousTolerance_BaseLead()
        {
            m_arrBackupTemplateBlobLeads_BaseLead.Clear();
            for (int i = 0; i < m_arrTemplateBlobLeads_BaseLead.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i];

                m_stcBackupTemplateBlobLead.intDirection = m_stcBlobLead.intDirection;
                m_stcBackupTemplateBlobLead.intNoID = m_stcBlobLead.intNoID;
                m_stcBackupTemplateBlobLead.intGroupID = m_stcBlobLead.intGroupID;
                m_stcBackupTemplateBlobLead.fStartX = m_stcBlobLead.fStartX;
                m_stcBackupTemplateBlobLead.fStartY = m_stcBlobLead.fStartY;
                m_stcBackupTemplateBlobLead.fEndX = m_stcBlobLead.fEndX;
                m_stcBackupTemplateBlobLead.fEndY = m_stcBlobLead.fEndY;
                m_stcBackupTemplateBlobLead.fLimitCenterX = m_stcBlobLead.fLimitCenterX;
                m_stcBackupTemplateBlobLead.fLimitCenterY = m_stcBlobLead.fLimitCenterY;
                m_stcBackupTemplateBlobLead.fOffSet = m_stcBlobLead.fOffSet;
                m_stcBackupTemplateBlobLead.fSkew = m_stcBlobLead.fSkew;
                m_stcBackupTemplateBlobLead.fVariance = m_stcBlobLead.fVariance;
                m_stcBackupTemplateBlobLead.fMinAGV = m_stcBlobLead.fMinAGV;
                m_stcBackupTemplateBlobLead.fMaxAGV = m_stcBlobLead.fMaxAGV;
                m_stcBackupTemplateBlobLead.fMinWidth = m_stcBlobLead.fMinWidth;
                m_stcBackupTemplateBlobLead.fMaxWidth = m_stcBlobLead.fMaxWidth;
                m_stcBackupTemplateBlobLead.fMinHeight = m_stcBlobLead.fMinHeight;
                m_stcBackupTemplateBlobLead.fMaxHeight = m_stcBlobLead.fMaxHeight;

                m_stcBackupTemplateBlobLead.intLengthMode = m_stcBlobLead.intLengthMode;
                m_stcBackupTemplateBlobLead.fLearnArea = m_stcBlobLead.fArea;
                m_stcBackupTemplateBlobLead.fLearnWidth = m_stcBlobLead.fWidth;
                m_stcBackupTemplateBlobLead.fLearnHeight = m_stcBlobLead.fHeight;

                m_stcBackupTemplateBlobLead.fMaxBaseOffset = m_stcBlobLead.fMaxBaseOffset;
                m_stcBackupTemplateBlobLead.fMinBaseArea = m_stcBlobLead.fMinBaseArea;
                m_stcBackupTemplateBlobLead.fMaxBaseArea = m_stcBlobLead.fMaxBaseArea;

                m_arrBackupTemplateBlobLeads_BaseLead.Add(m_stcBackupTemplateBlobLead);
            }
            
        }
        /// <summary>
        /// Draw selected blob 
        /// </summary>
        /// <param name="g">destination image to be drawn</param>
        /// <param name="fScale">scale</param>
        /// <param name="intZoomImageEdgeX">translation factor for panning in the horizontal direction</param>
        /// <param name="intZoomImageEdgeY">translation factor for panning in the vertical direction</param>
        public void DrawObjects(Graphics g, float fDrawingScaleX, float fDrawingScaleY)
        {
            int intColorIndex = 0;
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                if (((BlobsFeatures)m_arrTemplateBlobLeads[i]).blnSelected)
                    m_objEBlobs.DrawSelectedBlob(g, fDrawingScaleX, fDrawingScaleY, intColorIndex, i, ((BlobsFeatures)m_arrTemplateBlobLeads[i]).arrSelectedBlob);

                intColorIndex++;
            }
        }
        public void DrawObjects_BaseLead(Graphics g, float fDrawingScaleX, float fDrawingScaleY)
        {
            int intColorIndex = 0;
            for (int i = 0; i < m_arrTemplateBlobLeads_BaseLead.Count; i++)
            {
                if (((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).blnSelected)
                    m_objEBlobs_BaseLead.DrawSelectedBlob(g, fDrawingScaleX, fDrawingScaleY, intColorIndex, i, ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).arrSelectedBlob);

                intColorIndex++;
            }
        }
        public void DrawAllObjects(Graphics g, float fDrawingScaleX, float fDrawingScaleY)
        {
            int intColorIndex = 0;
                m_objEBlobs.DrawAllSelectedBlob(g, fDrawingScaleX, fDrawingScaleY, intColorIndex);
        }
        public void DrawObjects_Lead3D(Graphics g, float fDrawingScaleX, float fDrawingScaleY)
        {
            int intColorIndex = 0;
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                if (((BlobsFeatures)m_arrTemplateBlobLeads[i]).blnSelected)
                    m_objEBlobs.DrawSelectedBlob(g, fDrawingScaleX, fDrawingScaleY, intColorIndex, i);

                intColorIndex++;
            }
        }

        /// <summary>
        /// Draw pitch gap link
        /// </summary>
        /// <param name="g">destination image to be drawn</param>
        /// <param name="intRoiOrgX">ROI origin X</param>
        /// <param name="intRoiOrgY">ROI origin Y</param>
        /// <param name="fScale">scale</param>
        /// <param name="intZoomImageEdgeX">translation factor for panning in the horizontal direction</param>
        /// <param name="intZoomImageEdgeY">translation factor for panning in the vertical direction</param>
        public void DrawPitchGapLink(Graphics g, float fDrawingScaleX, float fDrawingScaleY, int intRoiOrgX, int intRoiOrgY, Color objColor)
        {
            for (int i = 0; i < m_arrPitchGap.Count; i++)
            {
                g.DrawLine(new Pen(objColor), (int)Math.Round((intRoiOrgX + m_arrPitchGap[i].intStartPointX) * fDrawingScaleX, 0, MidpointRounding.AwayFromZero),
                                               (int)Math.Round((intRoiOrgY + m_arrPitchGap[i].intStartPointY) * fDrawingScaleY, 0, MidpointRounding.AwayFromZero),
                                               (int)Math.Round((intRoiOrgX + m_arrPitchGap[i].intEndPointX) * fDrawingScaleX, 0, MidpointRounding.AwayFromZero),
                                               (int)Math.Round((intRoiOrgY + m_arrPitchGap[i].intEndPointY) * fDrawingScaleY, 0, MidpointRounding.AwayFromZero));
            }
        }

        /// <summary>
        /// Draw selected objects
        /// </summary>
        /// <param name="g">destination image to be drawn</param>
        /// <param name="fScale"></param>
        /// <param name="intZoomImageEdgeX">translation factor for panning in the horizontal direction</param>
        /// <param name="intZoomImageEdgeY">translation factor for panning in the vertical direction</param>
        public void DrawSelectedObjects(Graphics g, float fDrawingScaleX, float fDrawingScaleY)
        {
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                if (((BlobsFeatures)m_arrTemplateBlobLeads[i]).blnSelected)
                    m_objEBlobs.DrawSelectedBlob(g, fDrawingScaleX, fDrawingScaleY, Color.Lime, i, ((BlobsFeatures)m_arrTemplateBlobLeads[i]).arrSelectedBlob);
                else
                    m_objEBlobs.DrawSelectedBlob(g, fDrawingScaleX, fDrawingScaleY, Color.Red, i, ((BlobsFeatures)m_arrTemplateBlobLeads[i]).arrSelectedBlob);
            }
        }
        public void DrawSelectedObjects_BaseLead(Graphics g, float fDrawingScaleX, float fDrawingScaleY)
        {
            for (int i = 0; i < m_arrTemplateBlobLeads_BaseLead.Count; i++)
            {
                if (((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).blnSelected)
                    m_objEBlobs_BaseLead.DrawSelectedBlob(g, fDrawingScaleX, fDrawingScaleY, Color.Lime, i, ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).arrSelectedBlob);
                else
                    m_objEBlobs_BaseLead.DrawSelectedBlob(g, fDrawingScaleX, fDrawingScaleY, Color.Red, i, ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).arrSelectedBlob);
            }
        }
        /// <summary>
        /// Draw template objects
        /// </summary>
        /// <param name="g">destination image to be drawn</param>
        /// <param name="intRoiOrgX">ROI origin X</param>
        /// <param name="intRoiOrgY">ROI origin Y</param>
        /// <param name="fScale"></param>
        /// <param name="intZoomImageEdgeX">translation factor for panning in the horizontal direction</param>
        /// <param name="intZoomImageEdgeY">translation factor for panning in the vertical direction</param>
        public void DrawTemplateObjects(Graphics g, float fDrawingScaleX, float fDrawingScaleY, int intRoiOrgX, int intRoiOrgY)
        {

            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {

                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                System.Drawing.PointF p1 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fLimitCenterX - m_stcBlobLead.fWidth / 2, intRoiOrgY + m_stcBlobLead.fLimitCenterY - m_stcBlobLead.fHeight / 2);
                System.Drawing.PointF p2 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fLimitCenterX + m_stcBlobLead.fWidth / 2, intRoiOrgY + m_stcBlobLead.fLimitCenterY - m_stcBlobLead.fHeight / 2);
                System.Drawing.PointF p3 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fLimitCenterX - m_stcBlobLead.fWidth / 2, intRoiOrgY + m_stcBlobLead.fLimitCenterY + m_stcBlobLead.fHeight / 2);
                System.Drawing.PointF p4 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fLimitCenterX + m_stcBlobLead.fWidth / 2, intRoiOrgY + m_stcBlobLead.fLimitCenterY + m_stcBlobLead.fHeight / 2);

                if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                {
                    p1.X = p1.X * fDrawingScaleX;
                    p1.Y = p1.Y * fDrawingScaleY;
                    p2.X = p2.X * fDrawingScaleX;
                    p2.Y = p2.Y * fDrawingScaleY;
                    p3.X = p3.X * fDrawingScaleX;
                    p3.Y = p3.Y * fDrawingScaleY;
                    p4.X = p4.X * fDrawingScaleX;
                    p4.Y = p4.Y * fDrawingScaleY;
                }


                if (m_stcBlobLead.intLengthMode == 1)
                {
                    g.DrawLine(new Pen(Color.Blue, 2), p1, p2);
                    g.DrawLine(new Pen(Color.Lime, 2), p2, p4);
                    g.DrawLine(new Pen(Color.Blue, 2), p4, p3);
                    g.DrawLine(new Pen(Color.Lime, 2), p3, p1);
                }
                else
                {
                    g.DrawLine(new Pen(Color.Lime, 2), p1, p2);
                    g.DrawLine(new Pen(Color.Blue, 2), p2, p4);
                    g.DrawLine(new Pen(Color.Lime, 2), p4, p3);
                    g.DrawLine(new Pen(Color.Blue, 2), p3, p1);
                }
                g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                    ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterX + intRoiOrgX - 8) * fDrawingScaleX,
                    ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterY + intRoiOrgY - 8) * fDrawingScaleY);
            }
        }

        /// <summary>
        /// Draw template objects
        /// </summary>
        /// <param name="g">destination image to be drawn</param>
        /// <param name="intRoiOrgX">ROI origin X</param>
        /// <param name="intRoiOrgY">ROI origin Y</param>
        /// <param name="fScale"></param>
        /// <param name="intZoomImageEdgeX">translation factor for panning in the horizontal direction</param>
        /// <param name="intZoomImageEdgeY">translation factor for panning in the vertical direction</param>
        public void DrawTemplateObjects_Lead(Graphics g, float fDrawingScaleX, float fDrawingScaleY, int intRoiOrgX, int intRoiOrgY, int intLeadPosition)
        {
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                System.Drawing.PointF p1 = new PointF();
                System.Drawing.PointF p2 = new PointF();
                System.Drawing.PointF p3 = new PointF();
                System.Drawing.PointF p4 = new PointF();
                System.Drawing.PointF p5 = new PointF();
                System.Drawing.PointF p6 = new PointF();

                switch (intLeadPosition)
                {
                    case 1:
                        p1 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX - m_stcBlobLead.fTipWidth / 2, intRoiOrgY + m_stcBlobLead.fTipCenterY + m_stcBlobLead.intTipInwardOffset);
                        p2 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX + m_stcBlobLead.fTipWidth / 2, intRoiOrgY + m_stcBlobLead.fTipCenterY + m_stcBlobLead.intTipInwardOffset);
                        p3 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX - m_stcBlobLead.fBaseWidth / 2, intRoiOrgY + m_stcBlobLead.fBaseCenterY - m_stcBlobLead.intBaseInwardOffset);
                        p4 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX + m_stcBlobLead.fBaseWidth / 2, intRoiOrgY + m_stcBlobLead.fBaseCenterY - m_stcBlobLead.intBaseInwardOffset);
                        p5 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX, intRoiOrgY + m_stcBlobLead.fTipCenterY);
                        p6 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX, intRoiOrgY + m_stcBlobLead.fBaseCenterY);
                        break;
                    case 2:
                        p1 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX + m_stcBlobLead.intBaseInwardOffset, intRoiOrgY + m_stcBlobLead.fBaseCenterY - (m_stcBlobLead.fBaseWidth / 2));
                        p2 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX - m_stcBlobLead.intTipInwardOffset, intRoiOrgY + m_stcBlobLead.fTipCenterY - (m_stcBlobLead.fTipWidth / 2));
                        p3 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX + m_stcBlobLead.intBaseInwardOffset, intRoiOrgY + m_stcBlobLead.fBaseCenterY + (m_stcBlobLead.fBaseWidth / 2));
                        p4 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX - m_stcBlobLead.intTipInwardOffset, intRoiOrgY + m_stcBlobLead.fTipCenterY + (m_stcBlobLead.fTipWidth / 2));
                        p5 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX, intRoiOrgY + m_stcBlobLead.fBaseCenterY);
                        p6 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX, intRoiOrgY + m_stcBlobLead.fTipCenterY);
                        break;
                    case 3:
                        p1 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX - m_stcBlobLead.fBaseWidth / 2, intRoiOrgY + m_stcBlobLead.fBaseCenterY + m_stcBlobLead.intBaseInwardOffset);
                        p2 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX + m_stcBlobLead.fBaseWidth / 2, intRoiOrgY + m_stcBlobLead.fBaseCenterY + m_stcBlobLead.intBaseInwardOffset);
                        p3 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX - m_stcBlobLead.fTipWidth / 2, intRoiOrgY + m_stcBlobLead.fTipCenterY - m_stcBlobLead.intTipInwardOffset);
                        p4 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX + m_stcBlobLead.fTipWidth / 2, intRoiOrgY + m_stcBlobLead.fTipCenterY - m_stcBlobLead.intTipInwardOffset);
                        p5 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX, intRoiOrgY + m_stcBlobLead.fBaseCenterY);
                        p6 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX, intRoiOrgY + m_stcBlobLead.fTipCenterY);
                        break;
                    case 4:
                        p1 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX + m_stcBlobLead.intTipInwardOffset, intRoiOrgY + m_stcBlobLead.fTipCenterY - (m_stcBlobLead.fTipWidth / 2));
                        p2 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX - m_stcBlobLead.intBaseInwardOffset, intRoiOrgY + m_stcBlobLead.fBaseCenterY - (m_stcBlobLead.fBaseWidth / 2));
                        p3 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX + m_stcBlobLead.intTipInwardOffset, intRoiOrgY + m_stcBlobLead.fTipCenterY + (m_stcBlobLead.fTipWidth / 2));
                        p4 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX - m_stcBlobLead.intBaseInwardOffset, intRoiOrgY + m_stcBlobLead.fBaseCenterY + (m_stcBlobLead.fBaseWidth / 2));
                        p5 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX, intRoiOrgY + m_stcBlobLead.fTipCenterY);
                        p6 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX, intRoiOrgY + m_stcBlobLead.fBaseCenterY);
                        break;
                }

                if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                {
                    p1.X = p1.X * fDrawingScaleX;
                    p1.Y = p1.Y * fDrawingScaleY;
                    p2.X = p2.X * fDrawingScaleX;
                    p2.Y = p2.Y * fDrawingScaleY;
                    p3.X = p3.X * fDrawingScaleX;
                    p3.Y = p3.Y * fDrawingScaleY;
                    p4.X = p4.X * fDrawingScaleX;
                    p4.Y = p4.Y * fDrawingScaleY;
                    p5.X = p5.X * fDrawingScaleX;
                    p5.Y = p5.Y * fDrawingScaleY;
                    p6.X = p6.X * fDrawingScaleX;
                    p6.Y = p6.Y * fDrawingScaleY;
                }


                //g.DrawLine(new Pen(Color.Lime, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                //g.DrawLine(new Pen(Color.Lime, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);

                //g.DrawLine(new Pen(Color.Lime, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                //g.DrawLine(new Pen(Color.Lime, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);

                //g.DrawLine(new Pen(Color.Lime, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                //g.DrawLine(new Pen(Color.Lime, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);

                //g.DrawLine(new Pen(Color.Lime, 2), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                //g.DrawLine(new Pen(Color.Lime, 2), p4.X - 3, p4.Y, p4.X + 3, p4.Y);

                //g.DrawLine(new Pen(Color.Lime, 2), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                //g.DrawLine(new Pen(Color.Lime, 2), p5.X - 3, p5.Y, p5.X + 3, p5.Y);

                //g.DrawLine(new Pen(Color.Lime, 2), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                //g.DrawLine(new Pen(Color.Lime, 2), p6.X - 3, p6.Y, p6.X + 3, p6.Y);

                if (m_stcBlobLead.blnTipStartFound)
                {
                    switch (intLeadPosition)
                    {
                        case 1:
                            g.DrawLine(new Pen(Color.Lime, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                            g.DrawLine(new Pen(Color.Lime, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                            break;
                        case 2:
                            g.DrawLine(new Pen(Color.Lime, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                            g.DrawLine(new Pen(Color.Lime, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                            break;
                        case 3:
                            g.DrawLine(new Pen(Color.Lime, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                            g.DrawLine(new Pen(Color.Lime, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                            break;
                        case 4:
                            g.DrawLine(new Pen(Color.Lime, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                            g.DrawLine(new Pen(Color.Lime, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                            break;
                    }
                }
                else
                {
                    switch (intLeadPosition)
                    {
                        case 1:
                            g.DrawLine(new Pen(Color.Red, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                            g.DrawLine(new Pen(Color.Red, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                            break;
                        case 2:
                            g.DrawLine(new Pen(Color.Red, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                            g.DrawLine(new Pen(Color.Red, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                            break;
                        case 3:
                            g.DrawLine(new Pen(Color.Red, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                            g.DrawLine(new Pen(Color.Red, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                            break;
                        case 4:
                            g.DrawLine(new Pen(Color.Red, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                            g.DrawLine(new Pen(Color.Red, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                            break;
                    }
                }

                if (m_stcBlobLead.blnTipCenterFound)
                {
                    switch (intLeadPosition)
                    {
                        case 1:
                            g.DrawLine(new Pen(Color.Lime, 2), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                            g.DrawLine(new Pen(Color.Lime, 2), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                            break;
                        case 2:
                            g.DrawLine(new Pen(Color.Lime, 2), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                            g.DrawLine(new Pen(Color.Lime, 2), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                            break;
                        case 3:
                            g.DrawLine(new Pen(Color.Lime, 2), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                            g.DrawLine(new Pen(Color.Lime, 2), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                            break;
                        case 4:
                            g.DrawLine(new Pen(Color.Lime, 2), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                            g.DrawLine(new Pen(Color.Lime, 2), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                            break;
                    }
                }
                else
                {
                    switch (intLeadPosition)
                    {
                        case 1:
                            g.DrawLine(new Pen(Color.Red, 2), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                            g.DrawLine(new Pen(Color.Red, 2), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                            break;
                        case 2:
                            g.DrawLine(new Pen(Color.Red, 2), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                            g.DrawLine(new Pen(Color.Red, 2), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                            break;
                        case 3:
                            g.DrawLine(new Pen(Color.Red, 2), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                            g.DrawLine(new Pen(Color.Red, 2), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                            break;
                        case 4:
                            g.DrawLine(new Pen(Color.Red, 2), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                            g.DrawLine(new Pen(Color.Red, 2), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                            break;
                    }
                }

                if (m_stcBlobLead.blnTipEndFound)
                {
                    switch (intLeadPosition)
                    {
                        case 1:
                            g.DrawLine(new Pen(Color.Lime, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                            g.DrawLine(new Pen(Color.Lime, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                            break;
                        case 2:
                            g.DrawLine(new Pen(Color.Lime, 2), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                            g.DrawLine(new Pen(Color.Lime, 2), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                            break;
                        case 3:
                            g.DrawLine(new Pen(Color.Lime, 2), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                            g.DrawLine(new Pen(Color.Lime, 2), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                            break;
                        case 4:
                            g.DrawLine(new Pen(Color.Lime, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                            g.DrawLine(new Pen(Color.Lime, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                            break;
                    }
                }
                else
                {
                    switch (intLeadPosition)
                    {
                        case 1:
                            g.DrawLine(new Pen(Color.Red, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                            g.DrawLine(new Pen(Color.Red, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                            break;
                        case 2:
                            g.DrawLine(new Pen(Color.Red, 2), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                            g.DrawLine(new Pen(Color.Red, 2), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                            break;
                        case 3:
                            g.DrawLine(new Pen(Color.Red, 2), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                            g.DrawLine(new Pen(Color.Red, 2), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                            break;
                        case 4:
                            g.DrawLine(new Pen(Color.Red, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                            g.DrawLine(new Pen(Color.Red, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                            break;
                    }
                }

                if (m_stcBlobLead.blnBaseStartFound)
                {
                    switch (intLeadPosition)
                    {
                        case 1:
                            g.DrawLine(new Pen(Color.Lime, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                            g.DrawLine(new Pen(Color.Lime, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                            break;
                        case 2:
                            g.DrawLine(new Pen(Color.Lime, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                            g.DrawLine(new Pen(Color.Lime, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                            break;
                        case 3:
                            g.DrawLine(new Pen(Color.Lime, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                            g.DrawLine(new Pen(Color.Lime, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                            break;
                        case 4:
                            g.DrawLine(new Pen(Color.Lime, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                            g.DrawLine(new Pen(Color.Lime, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                            break;
                    }
                }
                else
                {
                    switch (intLeadPosition)
                    {
                        case 1:
                            g.DrawLine(new Pen(Color.Red, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                            g.DrawLine(new Pen(Color.Red, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                            break;
                        case 2:
                            g.DrawLine(new Pen(Color.Red, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                            g.DrawLine(new Pen(Color.Red, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                            break;
                        case 3:
                            g.DrawLine(new Pen(Color.Red, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                            g.DrawLine(new Pen(Color.Red, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                            break;
                        case 4:
                            g.DrawLine(new Pen(Color.Red, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                            g.DrawLine(new Pen(Color.Red, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                            break;
                    }
                }

                if (m_stcBlobLead.blnBaseCenterFound)
                {
                    switch (intLeadPosition)
                    {
                        case 1:
                            g.DrawLine(new Pen(Color.Lime, 1), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                            g.DrawLine(new Pen(Color.Lime, 1), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                            break;
                        case 2:
                            g.DrawLine(new Pen(Color.Lime, 1), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                            g.DrawLine(new Pen(Color.Lime, 1), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                            break;
                        case 3:
                            g.DrawLine(new Pen(Color.Lime, 1), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                            g.DrawLine(new Pen(Color.Lime, 1), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                            break;
                        case 4:
                            g.DrawLine(new Pen(Color.Lime, 1), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                            g.DrawLine(new Pen(Color.Lime, 1), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                            break;
                    }
                }
                else
                {
                    switch (intLeadPosition)
                    {
                        case 1:
                            g.DrawLine(new Pen(Color.Red, 1), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                            g.DrawLine(new Pen(Color.Red, 1), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                            break;
                        case 2:
                            g.DrawLine(new Pen(Color.Red, 1), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                            g.DrawLine(new Pen(Color.Red, 1), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                            break;
                        case 3:
                            g.DrawLine(new Pen(Color.Red, 1), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                            g.DrawLine(new Pen(Color.Red, 1), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                            break;
                        case 4:
                            g.DrawLine(new Pen(Color.Red, 1), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                            g.DrawLine(new Pen(Color.Red, 1), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                            break;
                    }
                }

                if (m_stcBlobLead.blnBaseEndFound)
                {
                    switch (intLeadPosition)
                    {
                        case 1:
                            g.DrawLine(new Pen(Color.Lime, 1), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                            g.DrawLine(new Pen(Color.Lime, 1), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                            break;
                        case 2:
                            g.DrawLine(new Pen(Color.Lime, 1), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                            g.DrawLine(new Pen(Color.Lime, 1), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                            break;
                        case 3:
                            g.DrawLine(new Pen(Color.Lime, 1), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                            g.DrawLine(new Pen(Color.Lime, 1), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                            break;
                        case 4:
                            g.DrawLine(new Pen(Color.Lime, 1), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                            g.DrawLine(new Pen(Color.Lime, 1), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                            break;
                    }
                }
                else
                {
                    switch (intLeadPosition)
                    {
                        case 1:
                            g.DrawLine(new Pen(Color.Red, 1), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                            g.DrawLine(new Pen(Color.Red, 1), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                            break;
                        case 2:
                            g.DrawLine(new Pen(Color.Red, 1), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                            g.DrawLine(new Pen(Color.Red, 1), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                            break;
                        case 3:
                            g.DrawLine(new Pen(Color.Red, 1), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                            g.DrawLine(new Pen(Color.Red, 1), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                            break;
                        case 4:
                            g.DrawLine(new Pen(Color.Red, 1), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                            g.DrawLine(new Pen(Color.Red, 1), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                            break;
                    }
                }

                g.DrawLine(new Pen(Color.Blue, 1), p5.X, p5.Y, p6.X, p6.Y);

                switch (intLeadPosition)
                {
                    case 1:
                        //g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                        //        ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterX + intRoiOrgX - 8) * fDrawingScaleX,
                        //        ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterY + intRoiOrgY - 40) * fDrawingScaleY);
                        g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                               ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fTipCenterX + intRoiOrgX - 8) * fDrawingScaleX,
                               ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fStartY + intRoiOrgY - m_stcBlobLead.intTipInwardOffset - m_Font.Height - 5) * fDrawingScaleY);
                        break;
                    case 2:
                        //g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                        //        ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterX + intRoiOrgX + 27) * fDrawingScaleX,
                        //        ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterY + intRoiOrgY - 8) * fDrawingScaleY);
                        g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                              ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fEndX + intRoiOrgX + 5) * fDrawingScaleX,
                              ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fTipCenterY + intRoiOrgY - 8) * fDrawingScaleY);
                        break;
                    case 3:
                        //g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                        //        ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterX + intRoiOrgX - 8) * fDrawingScaleX,
                        //        ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterY + intRoiOrgY + 27) * fDrawingScaleY);
                        g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                              ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fTipCenterX + intRoiOrgX - 8) * fDrawingScaleX,
                              ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fEndY + intRoiOrgY + 5) * fDrawingScaleY);
                        break;
                    case 4:
                        //g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                        //        ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterX + intRoiOrgX - 40) * fDrawingScaleX,
                        //        ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterY + intRoiOrgY - 8) * fDrawingScaleY);
                        g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                              ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fStartX - m_stcBlobLead.intTipInwardOffset + intRoiOrgX - (((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString().Length * m_Font.Size) - 5) * fDrawingScaleX,
                              ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fTipCenterY + intRoiOrgY - 8) * fDrawingScaleY);
                        break;
                }
            }

            if (m_fReferencePointEndX != 0 && m_fReferencePointEndY != 0)
            {
                System.Drawing.PointF pRefPoint1 = new PointF();
                System.Drawing.PointF pRefPoint2 = new PointF();
                pRefPoint1 = new System.Drawing.PointF(intRoiOrgX + m_fReferencePointStartX, intRoiOrgY + m_fReferencePointStartY);
                pRefPoint2 = new System.Drawing.PointF(intRoiOrgX + m_fReferencePointEndX, intRoiOrgY + m_fReferencePointEndY);

                if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                {
                    pRefPoint1.X = pRefPoint1.X * fDrawingScaleX;
                    pRefPoint1.Y = pRefPoint1.Y * fDrawingScaleY;
                    pRefPoint2.X = pRefPoint2.X * fDrawingScaleX;
                    pRefPoint2.Y = pRefPoint2.Y * fDrawingScaleY;
                }

                g.DrawLine(new Pen(Color.Cyan, 1), pRefPoint1.X, pRefPoint1.Y - 3, pRefPoint1.X, pRefPoint1.Y + 3);
                g.DrawLine(new Pen(Color.Cyan, 1), pRefPoint1.X - 3, pRefPoint1.Y, pRefPoint1.X + 3, pRefPoint1.Y);

                g.DrawLine(new Pen(Color.Cyan, 1), pRefPoint2.X, pRefPoint2.Y - 3, pRefPoint2.X, pRefPoint2.Y + 3);
                g.DrawLine(new Pen(Color.Cyan, 1), pRefPoint2.X - 3, pRefPoint2.Y, pRefPoint2.X + 3, pRefPoint2.Y);

                g.DrawLine(new Pen(Color.Cyan, 1), pRefPoint1.X, pRefPoint1.Y, pRefPoint2.X, pRefPoint2.Y);
            }
        }

        public void DrawTemplateObjects_Lead_PkgToBase(Graphics g, float fDrawingScaleX, float fDrawingScaleY, int intRoiOrgX, int intRoiOrgY, int intLeadPosition, Color[][] arrColor)
        {
            switch (intLeadPosition)
            {
                case 1:
                    g.DrawLine(new Pen(arrColor[5][0], 1), (m_fCenterX_PackageGaugeM4L - m_fWidth_PackageGaugeM4L / 2) * fDrawingScaleX,
                                               ((m_fCenterY_PackageGaugeM4L - m_fHeight_PackageGaugeM4L / 2) - m_intPkgToBaseTolerance_Top) * fDrawingScaleY,
                                               (m_fCenterX_PackageGaugeM4L + m_fWidth_PackageGaugeM4L / 2) * fDrawingScaleX,
                                               ((m_fCenterY_PackageGaugeM4L - m_fHeight_PackageGaugeM4L / 2) - m_intPkgToBaseTolerance_Top) * fDrawingScaleY);
                    break;
                case 2:
                    g.DrawLine(new Pen(arrColor[5][0], 1), ((m_fCenterX_PackageGaugeM4L + m_fWidth_PackageGaugeM4L / 2) + m_intPkgToBaseTolerance_Right) * fDrawingScaleX,
                                                (m_fCenterY_PackageGaugeM4L - m_fHeight_PackageGaugeM4L / 2) * fDrawingScaleY,
                                                ((m_fCenterX_PackageGaugeM4L + m_fWidth_PackageGaugeM4L / 2) + m_intPkgToBaseTolerance_Right) * fDrawingScaleX,
                                                (m_fCenterY_PackageGaugeM4L + m_fHeight_PackageGaugeM4L / 2) * fDrawingScaleY);
                    break;
                case 3:
                    g.DrawLine(new Pen(arrColor[5][0], 1), (m_fCenterX_PackageGaugeM4L - m_fWidth_PackageGaugeM4L / 2) * fDrawingScaleX,
                                               ((m_fCenterY_PackageGaugeM4L + m_fHeight_PackageGaugeM4L / 2) + m_intPkgToBaseTolerance_Bottom) * fDrawingScaleY,
                                               (m_fCenterX_PackageGaugeM4L + m_fWidth_PackageGaugeM4L / 2) * fDrawingScaleX,
                                               ((m_fCenterY_PackageGaugeM4L + m_fHeight_PackageGaugeM4L / 2) + m_intPkgToBaseTolerance_Bottom) * fDrawingScaleY);
                    break;
                case 4:
                    g.DrawLine(new Pen(arrColor[5][0], 1), ((m_fCenterX_PackageGaugeM4L - m_fWidth_PackageGaugeM4L / 2) - m_intPkgToBaseTolerance_Left) * fDrawingScaleX,
                                                       (m_fCenterY_PackageGaugeM4L - m_fHeight_PackageGaugeM4L / 2) * fDrawingScaleY,
                                                       ((m_fCenterX_PackageGaugeM4L - m_fWidth_PackageGaugeM4L / 2) - m_intPkgToBaseTolerance_Left) * fDrawingScaleX,
                                                       (m_fCenterY_PackageGaugeM4L + m_fHeight_PackageGaugeM4L / 2) * fDrawingScaleY);
                    break;
            }

            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                System.Drawing.PointF p1 = new PointF();
                System.Drawing.PointF p2 = new PointF();
                System.Drawing.PointF p3 = new PointF();
                System.Drawing.PointF p4 = new PointF();
                System.Drawing.PointF p5 = new PointF();
                System.Drawing.PointF p6 = new PointF();

                switch (intLeadPosition)
                {
                    case 1:
                        p1 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX - m_stcBlobLead.fTipWidth / 2, intRoiOrgY + m_stcBlobLead.fTipCenterY + m_stcBlobLead.intTipInwardOffset);
                        p2 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX + m_stcBlobLead.fTipWidth / 2, intRoiOrgY + m_stcBlobLead.fTipCenterY + m_stcBlobLead.intTipInwardOffset);
                        p3 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX - m_stcBlobLead.fBaseWidth / 2, intRoiOrgY + m_stcBlobLead.fBaseCenterY - m_stcBlobLead.intBaseInwardOffset);
                        p4 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX + m_stcBlobLead.fBaseWidth / 2, intRoiOrgY + m_stcBlobLead.fBaseCenterY - m_stcBlobLead.intBaseInwardOffset);
                        p5 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX, intRoiOrgY + m_stcBlobLead.fTipCenterY);
                        p6 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX, intRoiOrgY + m_stcBlobLead.fBaseCenterY);
                        break;
                    case 2:
                        p1 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX + m_stcBlobLead.intBaseInwardOffset, intRoiOrgY + m_stcBlobLead.fBaseCenterY - (m_stcBlobLead.fBaseWidth / 2));
                        p2 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX - m_stcBlobLead.intTipInwardOffset, intRoiOrgY + m_stcBlobLead.fTipCenterY - (m_stcBlobLead.fTipWidth / 2));
                        p3 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX + m_stcBlobLead.intBaseInwardOffset, intRoiOrgY + m_stcBlobLead.fBaseCenterY + (m_stcBlobLead.fBaseWidth / 2));
                        p4 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX - m_stcBlobLead.intTipInwardOffset, intRoiOrgY + m_stcBlobLead.fTipCenterY + (m_stcBlobLead.fTipWidth / 2));
                        p5 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX, intRoiOrgY + m_stcBlobLead.fBaseCenterY);
                        p6 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX, intRoiOrgY + m_stcBlobLead.fTipCenterY);
                        break;
                    case 3:
                        p1 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX - m_stcBlobLead.fBaseWidth / 2, intRoiOrgY + m_stcBlobLead.fBaseCenterY + m_stcBlobLead.intBaseInwardOffset);
                        p2 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX + m_stcBlobLead.fBaseWidth / 2, intRoiOrgY + m_stcBlobLead.fBaseCenterY + m_stcBlobLead.intBaseInwardOffset);
                        p3 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX - m_stcBlobLead.fTipWidth / 2, intRoiOrgY + m_stcBlobLead.fTipCenterY - m_stcBlobLead.intTipInwardOffset);
                        p4 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX + m_stcBlobLead.fTipWidth / 2, intRoiOrgY + m_stcBlobLead.fTipCenterY - m_stcBlobLead.intTipInwardOffset);
                        p5 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX, intRoiOrgY + m_stcBlobLead.fBaseCenterY);
                        p6 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX, intRoiOrgY + m_stcBlobLead.fTipCenterY);
                        break;
                    case 4:
                        p1 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX + m_stcBlobLead.intTipInwardOffset, intRoiOrgY + m_stcBlobLead.fTipCenterY - (m_stcBlobLead.fTipWidth / 2));
                        p2 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX - m_stcBlobLead.intBaseInwardOffset, intRoiOrgY + m_stcBlobLead.fBaseCenterY - (m_stcBlobLead.fBaseWidth / 2));
                        p3 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX + m_stcBlobLead.intTipInwardOffset, intRoiOrgY + m_stcBlobLead.fTipCenterY + (m_stcBlobLead.fTipWidth / 2));
                        p4 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX - m_stcBlobLead.intBaseInwardOffset, intRoiOrgY + m_stcBlobLead.fBaseCenterY + (m_stcBlobLead.fBaseWidth / 2));
                        p5 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX, intRoiOrgY + m_stcBlobLead.fTipCenterY);
                        p6 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX, intRoiOrgY + m_stcBlobLead.fBaseCenterY);
                        break;
                }

                if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                {
                    p1.X = p1.X * fDrawingScaleX;
                    p1.Y = p1.Y * fDrawingScaleY;
                    p2.X = p2.X * fDrawingScaleX;
                    p2.Y = p2.Y * fDrawingScaleY;
                    p3.X = p3.X * fDrawingScaleX;
                    p3.Y = p3.Y * fDrawingScaleY;
                    p4.X = p4.X * fDrawingScaleX;
                    p4.Y = p4.Y * fDrawingScaleY;
                    p5.X = p5.X * fDrawingScaleX;
                    p5.Y = p5.Y * fDrawingScaleY;
                    p6.X = p6.X * fDrawingScaleX;
                    p6.Y = p6.Y * fDrawingScaleY;
                }

                if (m_stcBlobLead.blnTipStartFound)
                {
                    switch (intLeadPosition)
                    {
                        case 1:
                            g.DrawLine(new Pen(Color.Lime, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                            g.DrawLine(new Pen(Color.Lime, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                            break;
                        case 2:
                            g.DrawLine(new Pen(Color.Lime, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                            g.DrawLine(new Pen(Color.Lime, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                            break;
                        case 3:
                            g.DrawLine(new Pen(Color.Lime, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                            g.DrawLine(new Pen(Color.Lime, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                            break;
                        case 4:
                            g.DrawLine(new Pen(Color.Lime, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                            g.DrawLine(new Pen(Color.Lime, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                            break;
                    }
                }
                else
                {
                    switch (intLeadPosition)
                    {
                        case 1:
                            g.DrawLine(new Pen(Color.Red, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                            g.DrawLine(new Pen(Color.Red, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                            break;
                        case 2:
                            g.DrawLine(new Pen(Color.Red, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                            g.DrawLine(new Pen(Color.Red, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                            break;
                        case 3:
                            g.DrawLine(new Pen(Color.Red, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                            g.DrawLine(new Pen(Color.Red, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                            break;
                        case 4:
                            g.DrawLine(new Pen(Color.Red, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                            g.DrawLine(new Pen(Color.Red, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                            break;
                    }
                }

                if (m_stcBlobLead.blnTipCenterFound)
                {
                    switch (intLeadPosition)
                    {
                        case 1:
                            g.DrawLine(new Pen(Color.Lime, 2), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                            g.DrawLine(new Pen(Color.Lime, 2), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                            break;
                        case 2:
                            g.DrawLine(new Pen(Color.Lime, 2), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                            g.DrawLine(new Pen(Color.Lime, 2), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                            break;
                        case 3:
                            g.DrawLine(new Pen(Color.Lime, 2), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                            g.DrawLine(new Pen(Color.Lime, 2), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                            break;
                        case 4:
                            g.DrawLine(new Pen(Color.Lime, 2), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                            g.DrawLine(new Pen(Color.Lime, 2), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                            break;
                    }
                }
                else
                {
                    switch (intLeadPosition)
                    {
                        case 1:
                            g.DrawLine(new Pen(Color.Red, 2), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                            g.DrawLine(new Pen(Color.Red, 2), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                            break;
                        case 2:
                            g.DrawLine(new Pen(Color.Red, 2), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                            g.DrawLine(new Pen(Color.Red, 2), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                            break;
                        case 3:
                            g.DrawLine(new Pen(Color.Red, 2), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                            g.DrawLine(new Pen(Color.Red, 2), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                            break;
                        case 4:
                            g.DrawLine(new Pen(Color.Red, 2), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                            g.DrawLine(new Pen(Color.Red, 2), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                            break;
                    }
                }

                if (m_stcBlobLead.blnTipEndFound)
                {
                    switch (intLeadPosition)
                    {
                        case 1:
                            g.DrawLine(new Pen(Color.Lime, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                            g.DrawLine(new Pen(Color.Lime, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                            break;
                        case 2:
                            g.DrawLine(new Pen(Color.Lime, 2), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                            g.DrawLine(new Pen(Color.Lime, 2), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                            break;
                        case 3:
                            g.DrawLine(new Pen(Color.Lime, 2), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                            g.DrawLine(new Pen(Color.Lime, 2), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                            break;
                        case 4:
                            g.DrawLine(new Pen(Color.Lime, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                            g.DrawLine(new Pen(Color.Lime, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                            break;
                    }
                }
                else
                {
                    switch (intLeadPosition)
                    {
                        case 1:
                            g.DrawLine(new Pen(Color.Red, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                            g.DrawLine(new Pen(Color.Red, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                            break;
                        case 2:
                            g.DrawLine(new Pen(Color.Red, 2), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                            g.DrawLine(new Pen(Color.Red, 2), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                            break;
                        case 3:
                            g.DrawLine(new Pen(Color.Red, 2), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                            g.DrawLine(new Pen(Color.Red, 2), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                            break;
                        case 4:
                            g.DrawLine(new Pen(Color.Red, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                            g.DrawLine(new Pen(Color.Red, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                            break;
                    }
                }

                if (m_stcBlobLead.blnBaseStartFound)
                {
                    switch (intLeadPosition)
                    {
                        case 1:
                            g.DrawLine(new Pen(Color.Lime, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                            g.DrawLine(new Pen(Color.Lime, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                            break;
                        case 2:
                            g.DrawLine(new Pen(Color.Lime, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                            g.DrawLine(new Pen(Color.Lime, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                            break;
                        case 3:
                            g.DrawLine(new Pen(Color.Lime, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                            g.DrawLine(new Pen(Color.Lime, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                            break;
                        case 4:
                            g.DrawLine(new Pen(Color.Lime, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                            g.DrawLine(new Pen(Color.Lime, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                            break;
                    }
                }
                else
                {
                    switch (intLeadPosition)
                    {
                        case 1:
                            g.DrawLine(new Pen(Color.Red, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                            g.DrawLine(new Pen(Color.Red, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                            break;
                        case 2:
                            g.DrawLine(new Pen(Color.Red, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                            g.DrawLine(new Pen(Color.Red, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                            break;
                        case 3:
                            g.DrawLine(new Pen(Color.Red, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                            g.DrawLine(new Pen(Color.Red, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                            break;
                        case 4:
                            g.DrawLine(new Pen(Color.Red, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                            g.DrawLine(new Pen(Color.Red, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                            break;
                    }
                }

                if (m_stcBlobLead.blnBaseCenterFound)
                {
                    switch (intLeadPosition)
                    {
                        case 1:
                            g.DrawLine(new Pen(Color.Lime, 1), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                            g.DrawLine(new Pen(Color.Lime, 1), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                            break;
                        case 2:
                            g.DrawLine(new Pen(Color.Lime, 1), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                            g.DrawLine(new Pen(Color.Lime, 1), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                            break;
                        case 3:
                            g.DrawLine(new Pen(Color.Lime, 1), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                            g.DrawLine(new Pen(Color.Lime, 1), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                            break;
                        case 4:
                            g.DrawLine(new Pen(Color.Lime, 1), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                            g.DrawLine(new Pen(Color.Lime, 1), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                            break;
                    }
                }
                else
                {
                    switch (intLeadPosition)
                    {
                        case 1:
                            g.DrawLine(new Pen(Color.Red, 1), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                            g.DrawLine(new Pen(Color.Red, 1), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                            break;
                        case 2:
                            g.DrawLine(new Pen(Color.Red, 1), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                            g.DrawLine(new Pen(Color.Red, 1), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                            break;
                        case 3:
                            g.DrawLine(new Pen(Color.Red, 1), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                            g.DrawLine(new Pen(Color.Red, 1), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                            break;
                        case 4:
                            g.DrawLine(new Pen(Color.Red, 1), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                            g.DrawLine(new Pen(Color.Red, 1), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                            break;
                    }
                }

                if (m_stcBlobLead.blnBaseEndFound)
                {
                    switch (intLeadPosition)
                    {
                        case 1:
                            g.DrawLine(new Pen(Color.Lime, 1), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                            g.DrawLine(new Pen(Color.Lime, 1), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                            break;
                        case 2:
                            g.DrawLine(new Pen(Color.Lime, 1), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                            g.DrawLine(new Pen(Color.Lime, 1), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                            break;
                        case 3:
                            g.DrawLine(new Pen(Color.Lime, 1), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                            g.DrawLine(new Pen(Color.Lime, 1), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                            break;
                        case 4:
                            g.DrawLine(new Pen(Color.Lime, 1), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                            g.DrawLine(new Pen(Color.Lime, 1), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                            break;
                    }
                }
                else
                {
                    switch (intLeadPosition)
                    {
                        case 1:
                            g.DrawLine(new Pen(Color.Red, 1), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                            g.DrawLine(new Pen(Color.Red, 1), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                            break;
                        case 2:
                            g.DrawLine(new Pen(Color.Red, 1), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                            g.DrawLine(new Pen(Color.Red, 1), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                            break;
                        case 3:
                            g.DrawLine(new Pen(Color.Red, 1), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                            g.DrawLine(new Pen(Color.Red, 1), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                            break;
                        case 4:
                            g.DrawLine(new Pen(Color.Red, 1), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                            g.DrawLine(new Pen(Color.Red, 1), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                            break;
                    }
                }

                g.DrawLine(new Pen(Color.Blue, 1), p5.X, p5.Y, p6.X, p6.Y);

                switch (intLeadPosition)
                {
                    case 1:
                        //g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                        //        ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterX + intRoiOrgX - 8) * fDrawingScaleX,
                        //        ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterY + intRoiOrgY - 40) * fDrawingScaleY);
                        g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                               ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fTipCenterX + intRoiOrgX - 8) * fDrawingScaleX,
                               ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fStartY + intRoiOrgY - m_stcBlobLead.intTipInwardOffset - m_Font.Height - 5) * fDrawingScaleY);
                        break;
                    case 2:
                        //g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                        //        ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterX + intRoiOrgX + 27) * fDrawingScaleX,
                        //        ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterY + intRoiOrgY - 8) * fDrawingScaleY);
                        g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                              ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fEndX + intRoiOrgX + 5) * fDrawingScaleX,
                              ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fTipCenterY + intRoiOrgY - 8) * fDrawingScaleY);
                        break;
                    case 3:
                        //g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                        //        ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterX + intRoiOrgX - 8) * fDrawingScaleX,
                        //        ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterY + intRoiOrgY + 27) * fDrawingScaleY);
                        g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                              ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fTipCenterX + intRoiOrgX - 8) * fDrawingScaleX,
                              ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fEndY + intRoiOrgY + 5) * fDrawingScaleY);
                        break;
                    case 4:
                        //g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                        //        ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterX + intRoiOrgX - 40) * fDrawingScaleX,
                        //        ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterY + intRoiOrgY - 8) * fDrawingScaleY);
                        g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                              ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fStartX - m_stcBlobLead.intTipInwardOffset + intRoiOrgX - (((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString().Length * m_Font.Size) - 5) * fDrawingScaleX,
                              ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fTipCenterY + intRoiOrgY - 8) * fDrawingScaleY);
                        break;
                }
            }

            if (m_fReferencePointEndX != 0 && m_fReferencePointEndY != 0)
            {
                System.Drawing.PointF pRefPoint1 = new PointF();
                System.Drawing.PointF pRefPoint2 = new PointF();
                pRefPoint1 = new System.Drawing.PointF(intRoiOrgX + m_fReferencePointStartX, intRoiOrgY + m_fReferencePointStartY);
                pRefPoint2 = new System.Drawing.PointF(intRoiOrgX + m_fReferencePointEndX, intRoiOrgY + m_fReferencePointEndY);

                if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                {
                    pRefPoint1.X = pRefPoint1.X * fDrawingScaleX;
                    pRefPoint1.Y = pRefPoint1.Y * fDrawingScaleY;
                    pRefPoint2.X = pRefPoint2.X * fDrawingScaleX;
                    pRefPoint2.Y = pRefPoint2.Y * fDrawingScaleY;
                }

                g.DrawLine(new Pen(Color.Cyan, 1), pRefPoint1.X, pRefPoint1.Y - 3, pRefPoint1.X, pRefPoint1.Y + 3);
                g.DrawLine(new Pen(Color.Cyan, 1), pRefPoint1.X - 3, pRefPoint1.Y, pRefPoint1.X + 3, pRefPoint1.Y);

                g.DrawLine(new Pen(Color.Cyan, 1), pRefPoint2.X, pRefPoint2.Y - 3, pRefPoint2.X, pRefPoint2.Y + 3);
                g.DrawLine(new Pen(Color.Cyan, 1), pRefPoint2.X - 3, pRefPoint2.Y, pRefPoint2.X + 3, pRefPoint2.Y);

                g.DrawLine(new Pen(Color.Cyan, 1), pRefPoint1.X, pRefPoint1.Y, pRefPoint2.X, pRefPoint2.Y);
            }
        }

        public void DrawTemplateObjects_Lead3D_Side(Graphics g, float fDrawingScaleX, float fDrawingScaleY, int intRoiOrgX, int intRoiOrgY, int intLeadPosition)
        {
            if (m_intLeadROIDirection == 1 || m_intLeadROIDirection == 3)
            {
                int intLeftX = (int)Math.Round(m_pCornerPoint_Left.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                int intLeftY = (int)Math.Round(m_pCornerPoint_Left.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                int intRightX = (int)Math.Round(m_pCornerPoint_Right.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                int intRightY = (int)Math.Round(m_pCornerPoint_Right.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);

                m_objBaseLine.DrawLineByPoints(g, fDrawingScaleX, fDrawingScaleY, m_pCornerPoint_Left.X, m_pCornerPoint_Right.X, Color.Lime, 1);

                g.DrawLine(new Pen(Color.Blue, 1), intLeftX - 5, intLeftY, intLeftX + 5, intLeftY);
                g.DrawLine(new Pen(Color.Blue, 1), intLeftX, intLeftY - 5, intLeftX, intLeftY + 5);
                g.DrawLine(new Pen(Color.Blue, 1), intRightX - 5, intRightY, intRightX + 5, intRightY);
                g.DrawLine(new Pen(Color.Blue, 1), intRightX, intRightY - 5, intRightX, intRightY + 5);
            }
            else
            {
                int intTopX = (int)Math.Round(m_pCornerPoint_Top.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                int intTopY = (int)Math.Round(m_pCornerPoint_Top.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                int intBottomX = (int)Math.Round(m_pCornerPoint_Bottom.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                int intBottomY = (int)Math.Round(m_pCornerPoint_Bottom.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);

                m_objBaseLine.DrawLineByPoints(g, fDrawingScaleX, fDrawingScaleY, m_pCornerPoint_Top.X, m_pCornerPoint_Bottom.X, Color.Lime, 1);

                g.DrawLine(new Pen(Color.Blue, 1), intTopX - 5, intTopY, intTopX + 5, intTopY);
                g.DrawLine(new Pen(Color.Blue, 1), intTopX, intTopY - 5, intTopX, intTopY + 5);
                g.DrawLine(new Pen(Color.Blue, 1), intBottomX - 5, intBottomY, intBottomX + 5, intBottomY);
                g.DrawLine(new Pen(Color.Blue, 1), intBottomX, intBottomY - 5, intBottomX, intBottomY + 5);
            }
        }

        public void DrawTemplateObjects_Lead3D_Center(Graphics g, float fDrawingScaleX, float fDrawingScaleY, int intRoiOrgX, int intRoiOrgY, int intLeadPosition)
        {
            // Draw center unit package size
            int intTopLeftX = (int)Math.Round(m_pCornerPoint_TopLeft.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
            int intTopLeftY = (int)Math.Round(m_pCornerPoint_TopLeft.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
            int intTopRightX = (int)Math.Round(m_pCornerPoint_TopRight.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
            int intTopRightY = (int)Math.Round(m_pCornerPoint_TopRight.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
            int intBottomLeftX = (int)Math.Round(m_pCornerPoint_BottomLeft.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
            int intBottomleftY = (int)Math.Round(m_pCornerPoint_BottomLeft.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
            int intBottomRightX = (int)Math.Round(m_pCornerPoint_BottomRight.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
            int intBottomRightY = (int)Math.Round(m_pCornerPoint_BottomRight.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);

            g.DrawLine(new Pen(Color.Yellow, 1), intTopLeftX, intTopLeftY, intTopRightX, intTopRightY);
            g.DrawLine(new Pen(Color.Yellow, 1), intTopRightX, intTopRightY, intBottomRightX, intBottomRightY);
            g.DrawLine(new Pen(Color.Yellow, 1), intBottomRightX, intBottomRightY, intBottomLeftX, intBottomleftY);
            g.DrawLine(new Pen(Color.Yellow, 1), intBottomLeftX, intBottomleftY, intTopLeftX, intTopLeftY);

            // Draw center lead tip, base and, width and length.
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                System.Drawing.PointF p1 = new PointF();
                System.Drawing.PointF p2 = new PointF();
                System.Drawing.PointF p3 = new PointF();
                System.Drawing.PointF p4 = new PointF();
                System.Drawing.PointF p5 = new PointF();
                System.Drawing.PointF p6 = new PointF();

                switch (m_stcBlobLead.intDirection)
                {
                    case 4:
                        p1 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX - m_stcBlobLead.fTipWidth / 2, intRoiOrgY + m_stcBlobLead.fTipCenterY + m_stcBlobLead.intTipInwardOffset);
                        p2 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX + m_stcBlobLead.fTipWidth / 2, intRoiOrgY + m_stcBlobLead.fTipCenterY + m_stcBlobLead.intTipInwardOffset);
                        p3 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX - m_stcBlobLead.fBaseWidth / 2, intRoiOrgY + m_stcBlobLead.fBaseCenterY - m_stcBlobLead.intBaseInwardOffset);
                        p4 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX + m_stcBlobLead.fBaseWidth / 2, intRoiOrgY + m_stcBlobLead.fBaseCenterY - m_stcBlobLead.intBaseInwardOffset);
                        p5 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX, intRoiOrgY + m_stcBlobLead.fTipCenterY);
                        p6 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX, intRoiOrgY + m_stcBlobLead.fBaseCenterY);
                        break;
                    case 2:
                        p1 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX + m_stcBlobLead.intBaseInwardOffset, intRoiOrgY + m_stcBlobLead.fBaseCenterY - m_stcBlobLead.fBaseHeight / 2);
                        p2 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX - m_stcBlobLead.intTipInwardOffset, intRoiOrgY + m_stcBlobLead.fTipCenterY - m_stcBlobLead.fTipHeight / 2);
                        p3 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX + m_stcBlobLead.intBaseInwardOffset, intRoiOrgY + m_stcBlobLead.fBaseCenterY + m_stcBlobLead.fBaseHeight / 2);
                        p4 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX - m_stcBlobLead.intTipInwardOffset, intRoiOrgY + m_stcBlobLead.fTipCenterY + m_stcBlobLead.fTipHeight / 2);
                        p5 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX, intRoiOrgY + m_stcBlobLead.fBaseCenterY);
                        p6 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX, intRoiOrgY + m_stcBlobLead.fTipCenterY);
                        break;
                    case 8:
                        p1 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX - m_stcBlobLead.fBaseWidth / 2, intRoiOrgY + m_stcBlobLead.fBaseCenterY + m_stcBlobLead.intBaseInwardOffset);
                        p2 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX + m_stcBlobLead.fBaseWidth / 2, intRoiOrgY + m_stcBlobLead.fBaseCenterY + m_stcBlobLead.intBaseInwardOffset);
                        p3 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX - m_stcBlobLead.fTipWidth / 2, intRoiOrgY + m_stcBlobLead.fTipCenterY - m_stcBlobLead.intTipInwardOffset);
                        p4 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX + m_stcBlobLead.fTipWidth / 2, intRoiOrgY + m_stcBlobLead.fTipCenterY - m_stcBlobLead.intTipInwardOffset);
                        p5 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX, intRoiOrgY + m_stcBlobLead.fBaseCenterY);
                        p6 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX, intRoiOrgY + m_stcBlobLead.fTipCenterY);
                        break;
                    case 1:
                        p1 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX + m_stcBlobLead.intTipInwardOffset, intRoiOrgY + m_stcBlobLead.fTipCenterY - m_stcBlobLead.fTipHeight / 2);
                        p2 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX - m_stcBlobLead.intBaseInwardOffset, intRoiOrgY + m_stcBlobLead.fBaseCenterY - m_stcBlobLead.fBaseHeight / 2);
                        p3 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX + m_stcBlobLead.intTipInwardOffset, intRoiOrgY + m_stcBlobLead.fTipCenterY + m_stcBlobLead.fTipHeight / 2);
                        p4 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX - m_stcBlobLead.intBaseInwardOffset, intRoiOrgY + m_stcBlobLead.fBaseCenterY + m_stcBlobLead.fBaseHeight / 2);
                        p5 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fTipCenterX, intRoiOrgY + m_stcBlobLead.fTipCenterY);
                        p6 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.fBaseCenterX, intRoiOrgY + m_stcBlobLead.fBaseCenterY);
                        break;
                }

                if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                {
                    p1.X = p1.X * fDrawingScaleX;
                    p1.Y = p1.Y * fDrawingScaleY;
                    p2.X = p2.X * fDrawingScaleX;
                    p2.Y = p2.Y * fDrawingScaleY;
                    p3.X = p3.X * fDrawingScaleX;
                    p3.Y = p3.Y * fDrawingScaleY;
                    p4.X = p4.X * fDrawingScaleX;
                    p4.Y = p4.Y * fDrawingScaleY;
                    p5.X = p5.X * fDrawingScaleX;
                    p5.Y = p5.Y * fDrawingScaleY;
                    p6.X = p6.X * fDrawingScaleX;
                    p6.Y = p6.Y * fDrawingScaleY;
                }


                g.DrawLine(new Pen(Color.Lime, 1), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                g.DrawLine(new Pen(Color.Lime, 1), p1.X - 3, p1.Y, p1.X + 3, p1.Y);

                g.DrawLine(new Pen(Color.Lime, 1), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                g.DrawLine(new Pen(Color.Lime, 1), p2.X - 3, p2.Y, p2.X + 3, p2.Y);

                g.DrawLine(new Pen(Color.Lime, 1), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                g.DrawLine(new Pen(Color.Lime, 1), p3.X - 3, p3.Y, p3.X + 3, p3.Y);

                g.DrawLine(new Pen(Color.Lime, 1), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                g.DrawLine(new Pen(Color.Lime, 1), p4.X - 3, p4.Y, p4.X + 3, p4.Y);

                g.DrawLine(new Pen(Color.Lime, 1), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                g.DrawLine(new Pen(Color.Lime, 1), p5.X - 3, p5.Y, p5.X + 3, p5.Y);

                g.DrawLine(new Pen(Color.Lime, 1), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                g.DrawLine(new Pen(Color.Lime, 1), p6.X - 3, p6.Y, p6.X + 3, p6.Y);

                g.DrawLine(new Pen(Color.Blue, 1), p5.X, p5.Y, p6.X, p6.Y);


                // Draw lead lable.
                switch (m_stcBlobLead.intDirection)
                {
                    case 4: // Top
                        g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCenterX + intRoiOrgX - 15) * fDrawingScaleX,
                                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCenterY + intRoiOrgY - 40) * fDrawingScaleY);
                        break;
                    case 2: // Right
                        g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fEndX + intRoiOrgX + 10) * fDrawingScaleX,
                                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCenterY + intRoiOrgY - 15) * fDrawingScaleY);
                        break;
                    case 8: // Bottom
                        g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCenterX + intRoiOrgX - 15) * fDrawingScaleX,
                                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCenterY + intRoiOrgY + 10) * fDrawingScaleY);
                        break;
                    case 1: // Left
                        g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fStartX + intRoiOrgX - 40) * fDrawingScaleX,
                                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fCenterY + intRoiOrgY - 15) * fDrawingScaleY);
                        break;
                }
            }

        }

        /// <summary>
        /// Draw Lead display result
        /// </summary>
        /// <param name="g">destination image to be drawn</param>
        /// <param name="intLeadSelectingNumber">Lead selecting no</param>
        /// <param name="intRoiOrgX">ROI origin X</param>
        /// <param name="intRoiOrgY">ROI origin Y</param>
        /// <param name="fScale"></param>
        /// <param name="intZoomImageEdgeX">translation factor for panning in the horizontal direction</param>
        /// <param name="intZoomImageEdgeY">translation factor for panning in the vertical direction</param>
        public void DrawLeadDisplayResult(Graphics g, float fDrawingScaleX, float fDrawingScaleY, int intLeadSelectingNumber, int intRoiOrgX, int intRoiOrgY, int intLeadPosition, int intSelectedLeadExtraBlobID, 
            bool blnDrawWithCompensateAngle, float fRotateCenterX, float fRotateCenterY, float fCenterUnitCompensateAngle_ForDrawing, ROI objROI)
        {
            lock (m_objLockBlobs)
            {
                if (m_blnLock)
                    return;
                bool blnFail = false;
                Pen redPen = new Pen(Color.Red);
                Pen limePen = new Pen(Color.Lime);
                Pen bluePen = new Pen(Color.Blue);
                if (m_arrSampleBlobLeads.Length != 0 && m_arrSampleBlobLeads[0].fArea == 0)
                {
                    for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
                    {
                        if (m_blnLock)
                            return;
                        if (!blnFail)
                            blnFail = true;
                        m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                        System.Drawing.PointF p1 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.intStartX, intRoiOrgY + m_stcBlobLead.intStartY);
                        System.Drawing.PointF p2 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.intEndX, intRoiOrgY + m_stcBlobLead.intStartY);
                        System.Drawing.PointF p3 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.intStartX, intRoiOrgY + m_stcBlobLead.intEndY);
                        System.Drawing.PointF p4 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.intEndX, intRoiOrgY + m_stcBlobLead.intEndY);

                        if (blnDrawWithCompensateAngle)
                        {
                            Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY, p1, -fCenterUnitCompensateAngle_ForDrawing, ref p1);
                            Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY, p2, -fCenterUnitCompensateAngle_ForDrawing, ref p2);
                            Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY, p3, -fCenterUnitCompensateAngle_ForDrawing, ref p3);
                            Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY, p4, -fCenterUnitCompensateAngle_ForDrawing, ref p4);
                        }

                        if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                        {
                            p1.X = p1.X * fDrawingScaleX;
                            p1.Y = p1.Y * fDrawingScaleY;
                            p2.X = p2.X * fDrawingScaleX;
                            p2.Y = p2.Y * fDrawingScaleY;
                            p3.X = p3.X * fDrawingScaleX;
                            p3.Y = p3.Y * fDrawingScaleY;
                            p4.X = p4.X * fDrawingScaleX;
                            p4.Y = p4.Y * fDrawingScaleY;
                        }

                        g.DrawLine(redPen, p1, p2);
                        g.DrawLine(redPen, p2, p4);
                        g.DrawLine(redPen, p4, p3);
                        g.DrawLine(redPen, p3, p1);
                        g.DrawLine(redPen, p1, p4);
                        g.DrawString(m_stcBlobLead.intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                            (float)(m_stcBlobLead.fLimitCenterX + intRoiOrgX - 8) * fDrawingScaleX,
                            (float)(m_stcBlobLead.fLimitCenterY + intRoiOrgY - 8) * fDrawingScaleY);
                    }
                }
                else
                {
                    //Extra, Join Lead, Excess Lead
                    for (int i = 0; i < m_arrExtraBlobs.Count; i++)
                    {
                        if (m_blnLock)
                            return;
                        if (intSelectedLeadExtraBlobID < 0 && m_arrExtraBlobs[i].ref_intExtraBlobID < Math.Abs(intSelectedLeadExtraBlobID) && m_arrExtraBlobs[i].ref_intExtraBlobID > Math.Abs(intSelectedLeadExtraBlobID + m_arrExtraBlobs.Count))//&& m_arrExtraBlobs[i].ref_intFailCriteria > 0)
                        {
                            System.Drawing.PointF p1 = new System.Drawing.PointF(intRoiOrgX + m_arrExtraBlobs[i].fStartX, intRoiOrgY + m_arrExtraBlobs[i].fStartY);
                            System.Drawing.PointF p2 = new System.Drawing.PointF(intRoiOrgX + m_arrExtraBlobs[i].fEndX, intRoiOrgY + m_arrExtraBlobs[i].fStartY);
                            System.Drawing.PointF p3 = new System.Drawing.PointF(intRoiOrgX + m_arrExtraBlobs[i].fStartX, intRoiOrgY + m_arrExtraBlobs[i].fEndY);
                            System.Drawing.PointF p4 = new System.Drawing.PointF(intRoiOrgX + m_arrExtraBlobs[i].fEndX, intRoiOrgY + m_arrExtraBlobs[i].fEndY);

                            if (blnDrawWithCompensateAngle)
                            {
                                Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY, p1, -fCenterUnitCompensateAngle_ForDrawing, ref p1);
                                Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY, p2, -fCenterUnitCompensateAngle_ForDrawing, ref p2);
                                Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY, p3, -fCenterUnitCompensateAngle_ForDrawing, ref p3);
                                Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY, p4, -fCenterUnitCompensateAngle_ForDrawing, ref p4);
                            }

                            if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                            {
                                p1.X = p1.X * fDrawingScaleX;
                                p1.Y = p1.Y * fDrawingScaleY;
                                p2.X = p2.X * fDrawingScaleX;
                                p2.Y = p2.Y * fDrawingScaleY;
                                p3.X = p3.X * fDrawingScaleX;
                                p3.Y = p3.Y * fDrawingScaleY;
                                p4.X = p4.X * fDrawingScaleX;
                                p4.Y = p4.Y * fDrawingScaleY;
                            }

                            g.DrawLine(new Pen(Color.Yellow), p1, p2);
                            g.DrawLine(new Pen(Color.Yellow), p2, p4);
                            g.DrawLine(new Pen(Color.Yellow), p4, p3);
                            g.DrawLine(new Pen(Color.Yellow), p3, p1);

                        }
                        else if (m_arrExtraBlobs[i].ref_intExtraBlobID == intSelectedLeadExtraBlobID)
                        {
                            System.Drawing.PointF p1 = new System.Drawing.PointF(intRoiOrgX + m_arrExtraBlobs[i].fStartX, intRoiOrgY + m_arrExtraBlobs[i].fStartY);
                            System.Drawing.PointF p2 = new System.Drawing.PointF(intRoiOrgX + m_arrExtraBlobs[i].fEndX, intRoiOrgY + m_arrExtraBlobs[i].fStartY);
                            System.Drawing.PointF p3 = new System.Drawing.PointF(intRoiOrgX + m_arrExtraBlobs[i].fStartX, intRoiOrgY + m_arrExtraBlobs[i].fEndY);
                            System.Drawing.PointF p4 = new System.Drawing.PointF(intRoiOrgX + m_arrExtraBlobs[i].fEndX, intRoiOrgY + m_arrExtraBlobs[i].fEndY);

                            if (blnDrawWithCompensateAngle)
                            {
                                Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY, p1, -fCenterUnitCompensateAngle_ForDrawing, ref p1);
                                Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY, p2, -fCenterUnitCompensateAngle_ForDrawing, ref p2);
                                Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY, p3, -fCenterUnitCompensateAngle_ForDrawing, ref p3);
                                Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY, p4, -fCenterUnitCompensateAngle_ForDrawing, ref p4);
                            }

                            if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                            {
                                p1.X = p1.X * fDrawingScaleX;
                                p1.Y = p1.Y * fDrawingScaleY;
                                p2.X = p2.X * fDrawingScaleX;
                                p2.Y = p2.Y * fDrawingScaleY;
                                p3.X = p3.X * fDrawingScaleX;
                                p3.Y = p3.Y * fDrawingScaleY;
                                p4.X = p4.X * fDrawingScaleX;
                                p4.Y = p4.Y * fDrawingScaleY;
                            }

                            g.DrawLine(new Pen(Color.Yellow), p1, p2);
                            g.DrawLine(new Pen(Color.Yellow), p2, p4);
                            g.DrawLine(new Pen(Color.Yellow), p4, p3);
                            g.DrawLine(new Pen(Color.Yellow), p3, p1);
                            continue;
                        }
                        else
                        {
                            if (m_blnLock)
                                return;

                            System.Drawing.PointF p1 = new System.Drawing.PointF(intRoiOrgX + m_arrExtraBlobs[i].fStartX, intRoiOrgY + m_arrExtraBlobs[i].fStartY);
                            System.Drawing.PointF p2 = new System.Drawing.PointF(intRoiOrgX + m_arrExtraBlobs[i].fEndX, intRoiOrgY + m_arrExtraBlobs[i].fStartY);
                            System.Drawing.PointF p3 = new System.Drawing.PointF(intRoiOrgX + m_arrExtraBlobs[i].fStartX, intRoiOrgY + m_arrExtraBlobs[i].fEndY);
                            System.Drawing.PointF p4 = new System.Drawing.PointF(intRoiOrgX + m_arrExtraBlobs[i].fEndX, intRoiOrgY + m_arrExtraBlobs[i].fEndY);

                            if (blnDrawWithCompensateAngle)
                            {
                                Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY, p1, -fCenterUnitCompensateAngle_ForDrawing, ref p1);
                                Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY, p2, -fCenterUnitCompensateAngle_ForDrawing, ref p2);
                                Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY, p3, -fCenterUnitCompensateAngle_ForDrawing, ref p3);
                                Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY, p4, -fCenterUnitCompensateAngle_ForDrawing, ref p4);
                            }

                            if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                            {
                                p1.X = p1.X * fDrawingScaleX;
                                p1.Y = p1.Y * fDrawingScaleY;
                                p2.X = p2.X * fDrawingScaleX;
                                p2.Y = p2.Y * fDrawingScaleY;
                                p3.X = p3.X * fDrawingScaleX;
                                p3.Y = p3.Y * fDrawingScaleY;
                                p4.X = p4.X * fDrawingScaleX;
                                p4.Y = p4.Y * fDrawingScaleY;
                            }
                            if (m_arrExtraBlobs[i].ref_intFailCriteria > 0)
                            {
                                if (!blnFail)
                                    blnFail = true;
                                g.DrawLine(redPen, p1, p2);
                                g.DrawLine(redPen, p2, p4);
                                g.DrawLine(redPen, p4, p3);
                                g.DrawLine(redPen, p3, p1);
                                g.DrawLine(redPen, p1, p4);
                            }
                            else
                            {
                                g.DrawLine(limePen, p1, p2);
                                g.DrawLine(limePen, p2, p4);
                                g.DrawLine(limePen, p4, p3);
                                g.DrawLine(limePen, p3, p1);
                                //g.DrawLine(limePen, p1, p4);
                            }
                        }
                    }

                    for (int i = 0; i < m_arrSampleBlobLeads.Length; i++)
                    {
                        if (m_blnLock)
                            return;

                        m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                        /*if (i == intLeadSelectingNumber)
                        {
                            m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                            System.Drawing.Point p1 = new System.Drawing.Point(intRoiOrgX + m_stcBlobLead.intStartX, intRoiOrgY + m_stcBlobLead.intStartY);
                            System.Drawing.Point p2 = new System.Drawing.Point(intRoiOrgX + m_stcBlobLead.intEndX, intRoiOrgY + m_stcBlobLead.intStartY);
                            System.Drawing.Point p3 = new System.Drawing.Point(intRoiOrgX + m_stcBlobLead.intStartX, intRoiOrgY + m_stcBlobLead.intEndY);
                            System.Drawing.Point p4 = new System.Drawing.Point(intRoiOrgX + m_stcBlobLead.intEndX, intRoiOrgY + m_stcBlobLead.intEndY);
                            g.DrawLine(new Pen(Color.Lime), p1, p2);
                            g.DrawLine(new Pen(Color.Lime), p2, p4);
                            g.DrawLine(new Pen(Color.Lime), p4, p3);
                            g.DrawLine(new Pen(Color.Lime), p3, p1);
                            g.DrawString(m_stcBlobLead.intNoID.ToString(), m_Font, new SolidBrush(Color.Red), (float)(m_stcBlobLead.fCenterX + intRoiOrgX - 8), (float)(m_stcBlobLead.fCenterY + intRoiOrgY - 8));
                            continue;
                        }*/

                        //Missing Lead
                        if (m_arrSampleBlobLeads[i].intFailMask == 0x04)
                        {
                            if (!blnFail)
                                blnFail = true;
                            m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                            System.Drawing.PointF p1 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.intStartX, intRoiOrgY + m_stcBlobLead.intStartY);
                            System.Drawing.PointF p2 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.intEndX, intRoiOrgY + m_stcBlobLead.intStartY);
                            System.Drawing.PointF p3 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.intStartX, intRoiOrgY + m_stcBlobLead.intEndY);
                            System.Drawing.PointF p4 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.intEndX, intRoiOrgY + m_stcBlobLead.intEndY);

                            if (blnDrawWithCompensateAngle)
                            {
                                Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY, p1, -fCenterUnitCompensateAngle_ForDrawing, ref p1);
                                Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY, p2, -fCenterUnitCompensateAngle_ForDrawing, ref p2);
                                Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY, p3, -fCenterUnitCompensateAngle_ForDrawing, ref p3);
                                Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY, p4, -fCenterUnitCompensateAngle_ForDrawing, ref p4);
                            }

                            if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                            {
                                p1.X = p1.X * fDrawingScaleX;
                                p1.Y = p1.Y * fDrawingScaleY;
                                p2.X = p2.X * fDrawingScaleX;
                                p2.Y = p2.Y * fDrawingScaleY;
                                p3.X = p3.X * fDrawingScaleX;
                                p3.Y = p3.Y * fDrawingScaleY;
                                p4.X = p4.X * fDrawingScaleX;
                                p4.Y = p4.Y * fDrawingScaleY;
                            }

                            g.DrawLine(redPen, p1, p2);
                            g.DrawLine(redPen, p2, p4);
                            g.DrawLine(redPen, p4, p3);
                            g.DrawLine(redPen, p3, p1);
                            g.DrawLine(redPen, p1, p4);

                            switch (intLeadPosition)
                            {
                                case 1:
                                    //g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                                    //        ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterX + intRoiOrgX) * fDrawingScaleX,
                                    //        ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterY + intRoiOrgY - 40) * fDrawingScaleY);
                                    g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                             ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterX + intRoiOrgX - 8) * fDrawingScaleX,
                             ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fStartY + intRoiOrgY - m_stcBlobLead.intTipInwardOffset - m_Font.Height - 5) * fDrawingScaleY);
                                    break;
                                case 2:
                                    //g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                                    //        ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterX + intRoiOrgX + 27) * fDrawingScaleX,
                                    //        ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterY + intRoiOrgY - 8) * fDrawingScaleY);
                                    g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                              ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fEndX + intRoiOrgX + 5) * fDrawingScaleX,
                              ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterY + intRoiOrgY - 8) * fDrawingScaleY);
                                    break;
                                case 3:
                                    //g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                                    //        ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterX + intRoiOrgX) * fDrawingScaleX,
                                    //        ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterY + intRoiOrgY + 27) * fDrawingScaleY);
                                    g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                              ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterX + intRoiOrgX - 8) * fDrawingScaleX,
                              ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fEndY + intRoiOrgY + 5) * fDrawingScaleY);
                                    break;
                                case 4:
                                    //g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                                    //        ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterX + intRoiOrgX - 40) * fDrawingScaleX,
                                    //        ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterY + intRoiOrgY - 8) * fDrawingScaleY);
                                    g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fStartX - m_stcBlobLead.intTipInwardOffset + intRoiOrgX - (((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString().Length * m_Font.Size) - 5) * fDrawingScaleX,
                                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterY + intRoiOrgY - 8) * fDrawingScaleY);
                                    break;
                            }
                        }
                        //Valid Lead
                        //else if (m_arrSampleBlobLeads[i].intFailMask == 0)
                        else if (m_arrSampleBlobLeads[i].intFailMask == 0 && (m_intFailResultMask & 0x1800) == 0)   // 2020 09 29 - CXLim,CCENG: For red drawing mistake
                        {
                            System.Drawing.PointF p1 = new PointF();
                            System.Drawing.PointF p2 = new PointF();
                            System.Drawing.PointF p3 = new PointF();
                            System.Drawing.PointF p4 = new PointF();
                            System.Drawing.PointF p5 = new PointF();
                            System.Drawing.PointF p6 = new PointF();

                            if ((intLeadSelectingNumber == -1) || (i == intLeadSelectingNumber))
                            {

                                switch (intLeadPosition)
                                {
                                    case 1:
                                        p1 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX - m_arrSampleBlobLeads[i].fTipWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY + m_stcBlobLead.intTipInwardOffset);
                                        p2 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX + m_arrSampleBlobLeads[i].fTipWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY + m_stcBlobLead.intTipInwardOffset);
                                        p3 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX - m_arrSampleBlobLeads[i].fBaseWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY - m_stcBlobLead.intBaseInwardOffset);
                                        p4 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX + m_arrSampleBlobLeads[i].fBaseWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY - m_stcBlobLead.intBaseInwardOffset);
                                        p5 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY);
                                        p6 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY);
                                        break;
                                    case 2:
                                        p1 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX + m_stcBlobLead.intBaseInwardOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY - (m_arrSampleBlobLeads[i].fBaseWidth / 2));
                                        p2 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX - m_stcBlobLead.intTipInwardOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY - (m_arrSampleBlobLeads[i].fTipWidth / 2));
                                        p3 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX + m_stcBlobLead.intBaseInwardOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY + (m_arrSampleBlobLeads[i].fBaseWidth / 2));
                                        p4 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX - m_stcBlobLead.intTipInwardOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY + (m_arrSampleBlobLeads[i].fTipWidth / 2));
                                        p5 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY);
                                        p6 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY);
                                        break;
                                    case 3:
                                        p1 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX - m_arrSampleBlobLeads[i].fBaseWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY + m_stcBlobLead.intBaseInwardOffset);
                                        p2 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX + m_arrSampleBlobLeads[i].fBaseWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY + m_stcBlobLead.intBaseInwardOffset);
                                        p3 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX - m_arrSampleBlobLeads[i].fTipWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY - m_stcBlobLead.intTipInwardOffset);
                                        p4 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX + m_arrSampleBlobLeads[i].fTipWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY - m_stcBlobLead.intTipInwardOffset);
                                        p5 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY);
                                        p6 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY);
                                        break;
                                    case 4:
                                        p1 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX + m_stcBlobLead.intTipInwardOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY - (m_arrSampleBlobLeads[i].fTipWidth / 2));
                                        p2 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX - m_stcBlobLead.intBaseInwardOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY - (m_arrSampleBlobLeads[i].fBaseWidth / 2));
                                        p3 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX + m_stcBlobLead.intTipInwardOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY + (m_arrSampleBlobLeads[i].fTipWidth / 2));
                                        p4 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX - m_stcBlobLead.intBaseInwardOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY + (m_arrSampleBlobLeads[i].fBaseWidth / 2));
                                        p5 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY);
                                        p6 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY);
                                        break;
                                }

                                if (blnDrawWithCompensateAngle)
                                {
                                    Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY, p1, -fCenterUnitCompensateAngle_ForDrawing, ref p1);
                                    Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY, p2, -fCenterUnitCompensateAngle_ForDrawing, ref p2);
                                    Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY, p3, -fCenterUnitCompensateAngle_ForDrawing, ref p3);
                                    Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY, p4, -fCenterUnitCompensateAngle_ForDrawing, ref p4);
                                    Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY, p5, -fCenterUnitCompensateAngle_ForDrawing, ref p5);
                                    Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY, p6, -fCenterUnitCompensateAngle_ForDrawing, ref p6);
                                }


                                if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                                {
                                    p1.X = p1.X * fDrawingScaleX;
                                    p1.Y = p1.Y * fDrawingScaleY;
                                    p2.X = p2.X * fDrawingScaleX;
                                    p2.Y = p2.Y * fDrawingScaleY;
                                    p3.X = p3.X * fDrawingScaleX;
                                    p3.Y = p3.Y * fDrawingScaleY;
                                    p4.X = p4.X * fDrawingScaleX;
                                    p4.Y = p4.Y * fDrawingScaleY;
                                    p5.X = p5.X * fDrawingScaleX;
                                    p5.Y = p5.Y * fDrawingScaleY;
                                    p6.X = p6.X * fDrawingScaleX;
                                    p6.Y = p6.Y * fDrawingScaleY;
                                }

                                //g.DrawLine(new Pen(Color.Lime, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                                //g.DrawLine(new Pen(Color.Lime, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);

                                //g.DrawLine(new Pen(Color.Lime, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                                //g.DrawLine(new Pen(Color.Lime, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);

                                //g.DrawLine(new Pen(Color.Lime, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                                //g.DrawLine(new Pen(Color.Lime, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);

                                //g.DrawLine(new Pen(Color.Lime, 2), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                                //g.DrawLine(new Pen(Color.Lime, 2), p4.X - 3, p4.Y, p4.X + 3, p4.Y);

                                //g.DrawLine(new Pen(Color.Lime, 2), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                                //g.DrawLine(new Pen(Color.Lime, 2), p5.X - 3, p5.Y, p5.X + 3, p5.Y);

                                //g.DrawLine(new Pen(Color.Lime, 2), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                                //g.DrawLine(new Pen(Color.Lime, 2), p6.X - 3, p6.Y, p6.X + 3, p6.Y);

                                if (m_arrSampleBlobLeads[i].blnTipStartFound)
                                {
                                    switch (intLeadPosition)
                                    {
                                        case 1:
                                            g.DrawLine(new Pen(Color.Lime, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                                            g.DrawLine(new Pen(Color.Lime, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                                            break;
                                        case 2:
                                            g.DrawLine(new Pen(Color.Lime, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                                            g.DrawLine(new Pen(Color.Lime, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                                            break;
                                        case 3:
                                            g.DrawLine(new Pen(Color.Lime, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                                            g.DrawLine(new Pen(Color.Lime, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                                            break;
                                        case 4:
                                            g.DrawLine(new Pen(Color.Lime, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                                            g.DrawLine(new Pen(Color.Lime, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                                            break;
                                    }
                                }
                                else
                                {
                                    if (m_arrSampleBlobLeads[i].blnTipCenterFound)
                                    {
                                        switch (intLeadPosition)
                                        {
                                            case 1:
                                                g.DrawLine(new Pen(Color.Yellow, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                                                g.DrawLine(new Pen(Color.Yellow, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                                                break;
                                            case 2:
                                                g.DrawLine(new Pen(Color.Yellow, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                                                g.DrawLine(new Pen(Color.Yellow, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                                                break;
                                            case 3:
                                                g.DrawLine(new Pen(Color.Yellow, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                                                g.DrawLine(new Pen(Color.Yellow, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                                                break;
                                            case 4:
                                                g.DrawLine(new Pen(Color.Yellow, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                                                g.DrawLine(new Pen(Color.Yellow, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                                                break;
                                        }
                                    }
                                    else
                                    {
                                        switch (intLeadPosition)
                                        {
                                            case 1:
                                                g.DrawLine(new Pen(Color.Red, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                                                g.DrawLine(new Pen(Color.Red, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                                                break;
                                            case 2:
                                                g.DrawLine(new Pen(Color.Red, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                                                g.DrawLine(new Pen(Color.Red, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                                                break;
                                            case 3:
                                                g.DrawLine(new Pen(Color.Red, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                                                g.DrawLine(new Pen(Color.Red, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                                                break;
                                            case 4:
                                                g.DrawLine(new Pen(Color.Red, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                                                g.DrawLine(new Pen(Color.Red, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                                                break;
                                        }
                                    }
                                }

                                if (m_arrSampleBlobLeads[i].blnTipCenterFound)
                                {
                                    switch (intLeadPosition)
                                    {
                                        case 1:
                                            g.DrawLine(new Pen(Color.Lime, 2), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                                            g.DrawLine(new Pen(Color.Lime, 2), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                                            break;
                                        case 2:
                                            g.DrawLine(new Pen(Color.Lime, 2), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                                            g.DrawLine(new Pen(Color.Lime, 2), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                                            break;
                                        case 3:
                                            g.DrawLine(new Pen(Color.Lime, 2), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                                            g.DrawLine(new Pen(Color.Lime, 2), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                                            break;
                                        case 4:
                                            g.DrawLine(new Pen(Color.Lime, 2), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                                            g.DrawLine(new Pen(Color.Lime, 2), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                                            break;
                                    }
                                }
                                else
                                {
                                    switch (intLeadPosition)
                                    {
                                        case 1:
                                            g.DrawLine(new Pen(Color.Red, 2), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                                            g.DrawLine(new Pen(Color.Red, 2), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                                            break;
                                        case 2:
                                            g.DrawLine(new Pen(Color.Red, 2), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                                            g.DrawLine(new Pen(Color.Red, 2), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                                            break;
                                        case 3:
                                            g.DrawLine(new Pen(Color.Red, 2), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                                            g.DrawLine(new Pen(Color.Red, 2), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                                            break;
                                        case 4:
                                            g.DrawLine(new Pen(Color.Red, 2), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                                            g.DrawLine(new Pen(Color.Red, 2), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                                            break;
                                    }
                                }

                                if (m_arrSampleBlobLeads[i].blnTipEndFound)
                                {
                                    switch (intLeadPosition)
                                    {
                                        case 1:
                                            g.DrawLine(new Pen(Color.Lime, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                                            g.DrawLine(new Pen(Color.Lime, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                                            break;
                                        case 2:
                                            g.DrawLine(new Pen(Color.Lime, 2), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                                            g.DrawLine(new Pen(Color.Lime, 2), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                                            break;
                                        case 3:
                                            g.DrawLine(new Pen(Color.Lime, 2), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                                            g.DrawLine(new Pen(Color.Lime, 2), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                                            break;
                                        case 4:
                                            g.DrawLine(new Pen(Color.Lime, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                                            g.DrawLine(new Pen(Color.Lime, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                                            break;
                                    }
                                }
                                else
                                {
                                    if (m_arrSampleBlobLeads[i].blnTipCenterFound)
                                    {
                                        switch (intLeadPosition)
                                        {
                                            case 1:
                                                g.DrawLine(new Pen(Color.Yellow, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                                                g.DrawLine(new Pen(Color.Yellow, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                                                break;
                                            case 2:
                                                g.DrawLine(new Pen(Color.Yellow, 2), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                                                g.DrawLine(new Pen(Color.Yellow, 2), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                                                break;
                                            case 3:
                                                g.DrawLine(new Pen(Color.Yellow, 2), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                                                g.DrawLine(new Pen(Color.Yellow, 2), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                                                break;
                                            case 4:
                                                g.DrawLine(new Pen(Color.Yellow, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                                                g.DrawLine(new Pen(Color.Yellow, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                                                break;
                                        }
                                    }
                                    else
                                    {
                                        switch (intLeadPosition)
                                        {
                                            case 1:
                                                g.DrawLine(new Pen(Color.Red, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                                                g.DrawLine(new Pen(Color.Red, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                                                break;
                                            case 2:
                                                g.DrawLine(new Pen(Color.Red, 2), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                                                g.DrawLine(new Pen(Color.Red, 2), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                                                break;
                                            case 3:
                                                g.DrawLine(new Pen(Color.Red, 2), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                                                g.DrawLine(new Pen(Color.Red, 2), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                                                break;
                                            case 4:
                                                g.DrawLine(new Pen(Color.Red, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                                                g.DrawLine(new Pen(Color.Red, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                                                break;
                                        }
                                    }
                                }

                                if (m_arrSampleBlobLeads[i].blnBaseStartFound)
                                {
                                    switch (intLeadPosition)
                                    {
                                        case 1:
                                            g.DrawLine(new Pen(Color.Lime, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                                            g.DrawLine(new Pen(Color.Lime, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                                            break;
                                        case 2:
                                            g.DrawLine(new Pen(Color.Lime, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                                            g.DrawLine(new Pen(Color.Lime, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                                            break;
                                        case 3:
                                            g.DrawLine(new Pen(Color.Lime, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                                            g.DrawLine(new Pen(Color.Lime, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                                            break;
                                        case 4:
                                            g.DrawLine(new Pen(Color.Lime, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                                            g.DrawLine(new Pen(Color.Lime, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                                            break;
                                    }
                                }
                                else
                                {
                                    switch (intLeadPosition)
                                    {
                                        case 1:
                                            g.DrawLine(new Pen(Color.Red, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                                            g.DrawLine(new Pen(Color.Red, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                                            break;
                                        case 2:
                                            g.DrawLine(new Pen(Color.Red, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                                            g.DrawLine(new Pen(Color.Red, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                                            break;
                                        case 3:
                                            g.DrawLine(new Pen(Color.Red, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                                            g.DrawLine(new Pen(Color.Red, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                                            break;
                                        case 4:
                                            g.DrawLine(new Pen(Color.Red, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                                            g.DrawLine(new Pen(Color.Red, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                                            break;
                                    }
                                }

                                if (m_arrSampleBlobLeads[i].blnBaseCenterFound)
                                {
                                    switch (intLeadPosition)
                                    {
                                        case 1:
                                            g.DrawLine(new Pen(Color.Lime, 1), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                                            g.DrawLine(new Pen(Color.Lime, 1), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                                            break;
                                        case 2:
                                            g.DrawLine(new Pen(Color.Lime, 1), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                                            g.DrawLine(new Pen(Color.Lime, 1), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                                            break;
                                        case 3:
                                            g.DrawLine(new Pen(Color.Lime, 1), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                                            g.DrawLine(new Pen(Color.Lime, 1), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                                            break;
                                        case 4:
                                            g.DrawLine(new Pen(Color.Lime, 1), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                                            g.DrawLine(new Pen(Color.Lime, 1), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                                            break;
                                    }
                                }
                                else
                                {
                                    switch (intLeadPosition)
                                    {
                                        case 1:
                                            g.DrawLine(new Pen(Color.Red, 1), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                                            g.DrawLine(new Pen(Color.Red, 1), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                                            break;
                                        case 2:
                                            g.DrawLine(new Pen(Color.Red, 1), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                                            g.DrawLine(new Pen(Color.Red, 1), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                                            break;
                                        case 3:
                                            g.DrawLine(new Pen(Color.Red, 1), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                                            g.DrawLine(new Pen(Color.Red, 1), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                                            break;
                                        case 4:
                                            g.DrawLine(new Pen(Color.Red, 1), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                                            g.DrawLine(new Pen(Color.Red, 1), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                                            break;
                                    }
                                }

                                if (m_arrSampleBlobLeads[i].blnBaseEndFound)
                                {
                                    switch (intLeadPosition)
                                    {
                                        case 1:
                                            g.DrawLine(new Pen(Color.Lime, 1), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                                            g.DrawLine(new Pen(Color.Lime, 1), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                                            break;
                                        case 2:
                                            g.DrawLine(new Pen(Color.Lime, 1), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                                            g.DrawLine(new Pen(Color.Lime, 1), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                                            break;
                                        case 3:
                                            g.DrawLine(new Pen(Color.Lime, 1), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                                            g.DrawLine(new Pen(Color.Lime, 1), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                                            break;
                                        case 4:
                                            g.DrawLine(new Pen(Color.Lime, 1), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                                            g.DrawLine(new Pen(Color.Lime, 1), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                                            break;
                                    }
                                }
                                else
                                {
                                    switch (intLeadPosition)
                                    {
                                        case 1:
                                            g.DrawLine(new Pen(Color.Red, 1), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                                            g.DrawLine(new Pen(Color.Red, 1), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                                            break;
                                        case 2:
                                            g.DrawLine(new Pen(Color.Red, 1), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                                            g.DrawLine(new Pen(Color.Red, 1), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                                            break;
                                        case 3:
                                            g.DrawLine(new Pen(Color.Red, 1), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                                            g.DrawLine(new Pen(Color.Red, 1), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                                            break;
                                        case 4:
                                            g.DrawLine(new Pen(Color.Red, 1), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                                            g.DrawLine(new Pen(Color.Red, 1), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                                            break;
                                    }
                                }

                                g.DrawLine(new Pen(Color.Blue, 1), p5.X, p5.Y, p6.X, p6.Y);
                            }
                            else
                            {

                                if (intLeadPosition == 0 || intLeadPosition == 2) //For top and bottom ROI
                                {
                                    g.DrawLine(redPen, p1.X - 2, p1.Y + 2, p1.X + 2, p1.Y + 6);
                                    g.DrawLine(redPen, p1.X - 2, p1.Y + 6, p1.X + 2, p1.Y + 2);

                                    g.DrawLine(redPen, p2.X - 2, p2.Y + 2, p2.X + 2, p2.Y + 6);
                                    g.DrawLine(redPen, p2.X - 2, p2.Y + 6, p2.X + 2, p2.Y + 2);

                                    g.DrawLine(redPen, p3.X - 2, p3.Y - 2, p3.X + 2, p3.Y - 6);
                                    g.DrawLine(redPen, p3.X - 2, p3.Y - 6, p3.X + 2, p3.Y - 2);

                                    g.DrawLine(redPen, p4.X - 2, p4.Y - 2, p4.X + 2, p4.Y - 6);
                                    g.DrawLine(redPen, p4.X - 2, p4.Y - 6, p4.X + 2, p4.Y - 2);

                                    if (intLeadPosition == 0)
                                    {
                                        if (i == 0)
                                        {
                                            g.DrawLine(bluePen, p3.X - 2, p3.Y - 2, p3.X + 2, p3.Y + 2);
                                            g.DrawLine(bluePen, p3.X - 2, p3.Y + 2, p3.X + 2, p3.Y - 2);
                                        }
                                        if (i == m_arrTemplateBlobLeads.Count - 1)
                                        {
                                            g.DrawLine(bluePen, p4.X - 2, p4.Y - 2, p4.X + 2, p4.Y + 2);
                                            g.DrawLine(bluePen, p4.X - 2, p4.Y + 2, p4.X + 2, p4.Y - 2);
                                        }
                                    }
                                    else if (intLeadPosition == 2)
                                    {
                                        if (i == 0)
                                        {
                                            g.DrawLine(bluePen, p1.X - 2, p1.Y - 2, p1.X + 2, p1.Y + 2);
                                            g.DrawLine(bluePen, p1.X - 2, p1.Y + 2, p1.X + 2, p1.Y - 2);
                                        }

                                        if (i == m_arrTemplateBlobLeads.Count - 1)
                                        {
                                            g.DrawLine(bluePen, p2.X - 2, p2.Y - 2, p2.X + 2, p2.Y + 2);
                                            g.DrawLine(bluePen, p2.X - 2, p2.Y + 2, p2.X + 2, p2.Y - 2);
                                        }
                                    }
                                }
                                else //For left and right ROI
                                {
                                    g.DrawLine(redPen, p1.X + 2, p1.Y - 2, p1.X + 6, p1.Y + 2);
                                    g.DrawLine(redPen, p1.X + 6, p1.Y - 2, p1.X + 2, p1.Y + 2);

                                    g.DrawLine(redPen, p2.X - 2, p2.Y - 2, p2.X - 6, p2.Y + 2);
                                    g.DrawLine(redPen, p2.X - 6, p2.Y - 2, p2.X - 2, p2.Y + 2);

                                    g.DrawLine(redPen, p3.X + 2, p3.Y + 2, p3.X + 6, p3.Y - 2);
                                    g.DrawLine(redPen, p3.X + 6, p3.Y + 2, p3.X + 2, p3.Y - 2);

                                    g.DrawLine(redPen, p4.X - 2, p4.Y + 2, p4.X - 6, p4.Y - 2);
                                    g.DrawLine(redPen, p4.X - 6, p4.Y + 2, p4.X - 2, p4.Y - 2);

                                    if (intLeadPosition == 1)
                                    {
                                        if (i == 0)
                                        {
                                            g.DrawLine(bluePen, p1.X - 2, p1.Y - 2, p1.X + 2, p1.Y + 2);
                                            g.DrawLine(bluePen, p1.X - 2, p1.Y + 2, p1.X + 2, p1.Y - 2);
                                        }
                                        if (i == m_arrTemplateBlobLeads.Count - 1)
                                        {
                                            g.DrawLine(bluePen, p3.X - 2, p3.Y - 2, p3.X + 2, p3.Y + 2);
                                            g.DrawLine(bluePen, p3.X - 2, p3.Y + 2, p3.X + 2, p3.Y - 2);
                                        }
                                    }
                                    else if (intLeadPosition == 3)
                                    {
                                        if (i == 0)
                                        {
                                            g.DrawLine(bluePen, p2.X - 2, p2.Y - 2, p2.X + 2, p2.Y + 2);
                                            g.DrawLine(bluePen, p2.X - 2, p2.Y + 2, p2.X + 2, p2.Y - 2);
                                        }

                                        if (i == m_arrTemplateBlobLeads.Count - 1)
                                        {
                                            g.DrawLine(bluePen, p4.X - 2, p4.Y - 2, p4.X + 2, p4.Y + 2);
                                            g.DrawLine(bluePen, p4.X - 2, p4.Y + 2, p4.X + 2, p4.Y - 2);
                                        }
                                    }
                                }
                            }

                            System.Drawing.PointF pR1 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fStartX, intRoiOrgY + m_arrSampleBlobLeads[i].fStartY);
                            System.Drawing.PointF pR2 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fEndX, intRoiOrgY + m_arrSampleBlobLeads[i].fStartY);
                            System.Drawing.PointF pR3 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fStartX, intRoiOrgY + m_arrSampleBlobLeads[i].fEndY);
                            System.Drawing.PointF pS1 = new PointF();
                            System.Drawing.PointF pS2 = new PointF();
                            System.Drawing.PointF pS3 = new PointF();
                            System.Drawing.PointF pS4 = new PointF();

                            float fDrawGapX = 5f / fDrawingScaleX;
                            float fDrwaGapY = 5f / fDrawingScaleY;
                            switch (intLeadPosition)
                            {
                                case 1:
                                    pR1 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX - m_arrSampleBlobLeads[i].fTipWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY + m_stcBlobLead.intTipInwardOffset);
                                    pR2 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY);
                                    pR3 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX + m_arrSampleBlobLeads[i].fTipWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY + m_stcBlobLead.intTipInwardOffset);
                                    pS1 = new PointF(pR1.X - fDrawGapX, pR2.Y - fDrwaGapY);
                                    pS2 = new PointF(pR3.X + fDrawGapX, pR2.Y - fDrwaGapY);
                                    pS3 = new PointF(pR3.X + fDrawGapX, Math.Max(pR1.Y, pR3.Y) + fDrwaGapY);
                                    pS4 = new PointF(pR1.X - fDrawGapX, Math.Max(pR1.Y, pR3.Y) + fDrwaGapY);
                                    break;
                                case 2:
                                    pR1 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX - m_stcBlobLead.intTipInwardOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY - (m_arrSampleBlobLeads[i].fTipWidth / 2));
                                    pR2 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY);
                                    pR3 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX - m_stcBlobLead.intTipInwardOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY + (m_arrSampleBlobLeads[i].fTipWidth / 2));
                                    pS1 = new PointF(Math.Min(pR1.X, pR3.X) - fDrawGapX, pR1.Y - fDrwaGapY);
                                    pS2 = new PointF(pR2.X + fDrawGapX, pR1.Y - fDrwaGapY);
                                    pS3 = new PointF(pR2.X + fDrawGapX, pR3.Y + fDrwaGapY);
                                    pS4 = new PointF(Math.Min(pR1.X, pR3.X) - fDrawGapX, pR3.Y + fDrwaGapY);
                                    break;
                                case 3:
                                    pR1 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX - m_arrSampleBlobLeads[i].fTipWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY - m_stcBlobLead.intTipInwardOffset);
                                    pR2 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY);
                                    pR3 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX + m_arrSampleBlobLeads[i].fTipWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY - m_stcBlobLead.intTipInwardOffset);
                                    pS1 = new PointF(pR1.X - fDrawGapX, Math.Min(pR1.Y, pR3.Y) - fDrwaGapY);
                                    pS2 = new PointF(pR3.X + fDrawGapX, Math.Min(pR1.Y, pR3.Y) - fDrwaGapY);
                                    pS3 = new PointF(pR3.X + fDrawGapX, pR2.Y + fDrwaGapY);
                                    pS4 = new PointF(pR1.X - fDrawGapX, pR2.Y + fDrwaGapY);
                                    break;
                                case 4:
                                    pR1 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX + m_stcBlobLead.intTipInwardOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY - (m_arrSampleBlobLeads[i].fTipWidth / 2));
                                    pR2 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY);
                                    pR3 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX + m_stcBlobLead.intTipInwardOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY + (m_arrSampleBlobLeads[i].fTipWidth / 2));
                                    pS1 = new PointF(pR2.X - fDrawGapX, pR1.Y - fDrwaGapY);
                                    pS2 = new PointF(Math.Max(pR1.X, pR3.X) + fDrawGapX, pR1.Y - fDrwaGapY);
                                    pS3 = new PointF(Math.Max(pR1.X, pR3.X) + fDrawGapX, pR3.Y + fDrwaGapY);
                                    pS4 = new PointF(pR2.X - fDrawGapX, pR3.Y + fDrwaGapY);
                                    break;
                            }

                            if (blnDrawWithCompensateAngle)
                            {
                                Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY, pR1, -fCenterUnitCompensateAngle_ForDrawing, ref pR1);
                                Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY, pR2, -fCenterUnitCompensateAngle_ForDrawing, ref pR2);
                                Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY, pR3, -fCenterUnitCompensateAngle_ForDrawing, ref pR3);
                                Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY, pS1, -fCenterUnitCompensateAngle_ForDrawing, ref pS1);
                                Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY, pS2, -fCenterUnitCompensateAngle_ForDrawing, ref pS2);
                                Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY, pS3, -fCenterUnitCompensateAngle_ForDrawing, ref pS3);
                                Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY, pS4, -fCenterUnitCompensateAngle_ForDrawing, ref pS4);

                            }

                            if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                            {
                                pR1.X = pR1.X * fDrawingScaleX;
                                pR1.Y = pR1.Y * fDrawingScaleY;
                                pR2.X = pR2.X * fDrawingScaleX;
                                pR2.Y = pR2.Y * fDrawingScaleY;
                                pR3.X = pR3.X * fDrawingScaleX;
                                pR3.Y = pR3.Y * fDrawingScaleY;

                                pS1.X = pS1.X * fDrawingScaleX;
                                pS1.Y = pS1.Y * fDrawingScaleY;
                                pS2.X = pS2.X * fDrawingScaleX;
                                pS2.Y = pS2.Y * fDrawingScaleY;
                                pS3.X = pS3.X * fDrawingScaleX;
                                pS3.Y = pS3.Y * fDrawingScaleY;
                                pS4.X = pS4.X * fDrawingScaleX;
                                pS4.Y = pS4.Y * fDrawingScaleY;
                            }

                            g.DrawLine(new Pen(Color.Lime, 1), pS1, pS2);
                            g.DrawLine(new Pen(Color.Lime, 1), pS2, pS3);
                            g.DrawLine(new Pen(Color.Lime, 1), pS3, pS4);
                            g.DrawLine(new Pen(Color.Lime, 1), pS4, pS1);

                            //switch (intLeadPosition)
                            //{
                            //    case 1: // Top

                            //        //g.DrawRectangle(new Pen(Color.Lime, 1), pR1.X - 5, pR2.Y - 5, pR3.X - p1.X + 10, Math.Max(pR1.Y, pR3.Y) - pR2.Y + 10);

                            //        break;
                            //    case 2: // Right

                            //        g.DrawRectangle(new Pen(Color.Lime, 1), Math.Min(pR3.X, pR1.X) - 5, pR1.Y - 5, pR2.X - Math.Min(pR3.X, pR1.X) + 10, pR3.Y - pR1.Y + 10);

                            //        break;
                            //    case 3: // Bottom

                            //        g.DrawRectangle(new Pen(Color.Lime, 1), pR1.X - 5, Math.Min(pR1.Y, pR3.Y) - 5, pR3.X - pR1.X + 10, pR2.Y - Math.Min(pR1.Y, pR3.Y) + 10);

                            //        break;
                            //    case 4: // Left

                            //        g.DrawRectangle(new Pen(Color.Lime, 1), pR2.X - 5, pR1.Y - 5, Math.Max(pR3.X, pR1.X) - pR2.X + 10, pR3.Y - pR1.Y + 10);

                            //        break;
                            //}

                            switch (intLeadPosition)
                            {
                                case 1:
                                    //g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                                    //        (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterX + intRoiOrgX) * fDrawingScaleX,
                                    //        (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterY + intRoiOrgY - 40) * fDrawingScaleY);
                                    g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Lime),
                                 ((float)((SampleBlobsFeatures)m_arrSampleBlobLeads[i]).fCenterX + intRoiOrgX - 8) * fDrawingScaleX,
                                 ((float)((SampleBlobsFeatures)m_arrSampleBlobLeads[i]).fStartY + intRoiOrgY - m_stcBlobLead.intTipInwardOffset - m_Font.Height - 5) * fDrawingScaleY);
                                    break;
                                case 2:
                                    //g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                                    //        (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterX + intRoiOrgX + 27) * fDrawingScaleX,
                                    //        (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterY + intRoiOrgY - 8) * fDrawingScaleY);
                                    g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Lime),
                            ((float)((SampleBlobsFeatures)m_arrSampleBlobLeads[i]).fEndX + intRoiOrgX + 5) * fDrawingScaleX,
                            ((float)((SampleBlobsFeatures)m_arrSampleBlobLeads[i]).fCenterY + intRoiOrgY - 8) * fDrawingScaleY);
                                    break;
                                case 3:
                                    //g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                                    //        (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterX + intRoiOrgX) * fDrawingScaleX,
                                    //        (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterY + intRoiOrgY + 27) * fDrawingScaleY);
                                    g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Lime),
                            ((float)((SampleBlobsFeatures)m_arrSampleBlobLeads[i]).fCenterX + intRoiOrgX - 8) * fDrawingScaleX,
                            ((float)((SampleBlobsFeatures)m_arrSampleBlobLeads[i]).fEndY + intRoiOrgY + 5) * fDrawingScaleY);
                                    break;
                                case 4:
                                    //g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                                    //        (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterX + intRoiOrgX - 40) * fDrawingScaleX,
                                    //        (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterY + intRoiOrgY - 8) * fDrawingScaleY);
                                    g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Lime),
                                ((float)((SampleBlobsFeatures)m_arrSampleBlobLeads[i]).fStartX - m_stcBlobLead.intTipInwardOffset + intRoiOrgX - (((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString().Length * m_Font.Size) - 5) * fDrawingScaleX,
                                ((float)((SampleBlobsFeatures)m_arrSampleBlobLeads[i]).fCenterY + intRoiOrgY - 8) * fDrawingScaleY);
                                    break;
                            }

                            //Draw reference point here
                            if (m_fSampleReferencePointEndX != 0 && m_fSampleReferencePointEndY != 0)
                            {
                                System.Drawing.PointF pRefPoint1 = new PointF();
                                System.Drawing.PointF pRefPoint2 = new PointF();
                                pRefPoint1 = new System.Drawing.PointF(intRoiOrgX + m_fSampleReferencePointStartX, intRoiOrgY + m_fSampleReferencePointStartY);
                                pRefPoint2 = new System.Drawing.PointF(intRoiOrgX + m_fSampleReferencePointEndX, intRoiOrgY + m_fSampleReferencePointEndY);

                                if (blnDrawWithCompensateAngle)
                                {
                                    Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY, pRefPoint1, -fCenterUnitCompensateAngle_ForDrawing, ref pRefPoint1);
                                    Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY, pRefPoint2, -fCenterUnitCompensateAngle_ForDrawing, ref pRefPoint2);
                                }

                                if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                                {
                                    pRefPoint1.X = pRefPoint1.X * fDrawingScaleX;
                                    pRefPoint1.Y = pRefPoint1.Y * fDrawingScaleY;
                                    pRefPoint2.X = pRefPoint2.X * fDrawingScaleX;
                                    pRefPoint2.Y = pRefPoint2.Y * fDrawingScaleY;
                                }

                                g.DrawLine(new Pen(Color.Cyan, 1), pRefPoint1.X, pRefPoint1.Y - 3, pRefPoint1.X, pRefPoint1.Y + 3);
                                g.DrawLine(new Pen(Color.Cyan, 1), pRefPoint1.X - 3, pRefPoint1.Y, pRefPoint1.X + 3, pRefPoint1.Y);

                                g.DrawLine(new Pen(Color.Cyan, 1), pRefPoint2.X, pRefPoint2.Y - 3, pRefPoint2.X, pRefPoint2.Y + 3);
                                g.DrawLine(new Pen(Color.Cyan, 1), pRefPoint2.X - 3, pRefPoint2.Y, pRefPoint2.X + 3, pRefPoint2.Y);

                                g.DrawLine(new Pen(Color.Cyan, 1), pRefPoint1.X, pRefPoint1.Y, pRefPoint2.X, pRefPoint2.Y);
                            }
                        }
                        else
                        {
                            System.Drawing.PointF p1 = new PointF();
                            System.Drawing.PointF p2 = new PointF();
                            System.Drawing.PointF p3 = new PointF();
                            System.Drawing.PointF p4 = new PointF();
                            System.Drawing.PointF p5 = new PointF();
                            System.Drawing.PointF p6 = new PointF();

                            switch (intLeadPosition)
                            {
                                case 1:
                                    p1 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX - m_arrSampleBlobLeads[i].fTipWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY + m_stcBlobLead.intTipInwardOffset);
                                    p2 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX + m_arrSampleBlobLeads[i].fTipWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY + m_stcBlobLead.intTipInwardOffset);
                                    p3 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX - m_arrSampleBlobLeads[i].fBaseWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY - m_stcBlobLead.intBaseInwardOffset);
                                    p4 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX + m_arrSampleBlobLeads[i].fBaseWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY - m_stcBlobLead.intBaseInwardOffset);
                                    p5 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY);
                                    p6 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY);
                                    break;
                                case 2:
                                    p1 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX + m_stcBlobLead.intBaseInwardOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY - (m_arrSampleBlobLeads[i].fBaseWidth / 2));
                                    p2 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX - m_stcBlobLead.intTipInwardOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY - (m_arrSampleBlobLeads[i].fTipWidth / 2));
                                    p3 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX + m_stcBlobLead.intBaseInwardOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY + (m_arrSampleBlobLeads[i].fBaseWidth / 2));
                                    p4 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX - m_stcBlobLead.intTipInwardOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY + (m_arrSampleBlobLeads[i].fTipWidth / 2));
                                    p5 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY);
                                    p6 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY);
                                    break;
                                case 3:
                                    p1 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX - m_arrSampleBlobLeads[i].fBaseWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY + m_stcBlobLead.intBaseInwardOffset);
                                    p2 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX + m_arrSampleBlobLeads[i].fBaseWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY + m_stcBlobLead.intBaseInwardOffset);
                                    p3 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX - m_arrSampleBlobLeads[i].fTipWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY - m_stcBlobLead.intTipInwardOffset);
                                    p4 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX + m_arrSampleBlobLeads[i].fTipWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY - m_stcBlobLead.intTipInwardOffset);
                                    p5 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY);
                                    p6 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY);
                                    break;
                                case 4:
                                    p1 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX + m_stcBlobLead.intTipInwardOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY - (m_arrSampleBlobLeads[i].fTipWidth / 2));
                                    p2 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX - m_stcBlobLead.intBaseInwardOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY - (m_arrSampleBlobLeads[i].fBaseWidth / 2));
                                    p3 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX + m_stcBlobLead.intTipInwardOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY + (m_arrSampleBlobLeads[i].fTipWidth / 2));
                                    p4 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX - m_stcBlobLead.intBaseInwardOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY + (m_arrSampleBlobLeads[i].fBaseWidth / 2));
                                    p5 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY);
                                    p6 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY);
                                    break;
                            }

                            if (blnDrawWithCompensateAngle)
                            {
                                Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY, p1, -fCenterUnitCompensateAngle_ForDrawing, ref p1);
                                Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY, p2, -fCenterUnitCompensateAngle_ForDrawing, ref p2);
                                Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY, p3, -fCenterUnitCompensateAngle_ForDrawing, ref p3);
                                Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY, p4, -fCenterUnitCompensateAngle_ForDrawing, ref p4);
                                Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY, p5, -fCenterUnitCompensateAngle_ForDrawing, ref p5);
                                Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY, p6, -fCenterUnitCompensateAngle_ForDrawing, ref p6);
                            }

                            if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                            {
                                p1.X = p1.X * fDrawingScaleX;
                                p1.Y = p1.Y * fDrawingScaleY;
                                p2.X = p2.X * fDrawingScaleX;
                                p2.Y = p2.Y * fDrawingScaleY;
                                p3.X = p3.X * fDrawingScaleX;
                                p3.Y = p3.Y * fDrawingScaleY;
                                p4.X = p4.X * fDrawingScaleX;
                                p4.Y = p4.Y * fDrawingScaleY;
                                p5.X = p5.X * fDrawingScaleX;
                                p5.Y = p5.Y * fDrawingScaleY;
                                p6.X = p6.X * fDrawingScaleX;
                                p6.Y = p6.Y * fDrawingScaleY;
                            }

                            //g.DrawLine(new Pen(Color.Lime, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                            //g.DrawLine(new Pen(Color.Lime, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);

                            //g.DrawLine(new Pen(Color.Lime, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                            //g.DrawLine(new Pen(Color.Lime, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);

                            //g.DrawLine(new Pen(Color.Lime, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                            //g.DrawLine(new Pen(Color.Lime, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);

                            //g.DrawLine(new Pen(Color.Lime, 2), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                            //g.DrawLine(new Pen(Color.Lime, 2), p4.X - 3, p4.Y, p4.X + 3, p4.Y);

                            //g.DrawLine(new Pen(Color.Lime, 2), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                            //g.DrawLine(new Pen(Color.Lime, 2), p5.X - 3, p5.Y, p5.X + 3, p5.Y);

                            //g.DrawLine(new Pen(Color.Lime, 2), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                            //g.DrawLine(new Pen(Color.Lime, 2), p6.X - 3, p6.Y, p6.X + 3, p6.Y);

                            if (m_arrSampleBlobLeads[i].blnTipStartFound)
                            {
                                switch (intLeadPosition)
                                {
                                    case 1:
                                        g.DrawLine(new Pen(Color.Lime, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                                        g.DrawLine(new Pen(Color.Lime, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                                        break;
                                    case 2:
                                        g.DrawLine(new Pen(Color.Lime, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                                        g.DrawLine(new Pen(Color.Lime, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                                        break;
                                    case 3:
                                        g.DrawLine(new Pen(Color.Lime, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                                        g.DrawLine(new Pen(Color.Lime, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                                        break;
                                    case 4:
                                        g.DrawLine(new Pen(Color.Lime, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                                        g.DrawLine(new Pen(Color.Lime, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                                        break;
                                }
                            }
                            else
                            {
                                switch (intLeadPosition)
                                {
                                    case 1:
                                        g.DrawLine(new Pen(Color.Red, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                                        g.DrawLine(new Pen(Color.Red, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                                        break;
                                    case 2:
                                        g.DrawLine(new Pen(Color.Red, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                                        g.DrawLine(new Pen(Color.Red, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                                        break;
                                    case 3:
                                        g.DrawLine(new Pen(Color.Red, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                                        g.DrawLine(new Pen(Color.Red, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                                        break;
                                    case 4:
                                        g.DrawLine(new Pen(Color.Red, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                                        g.DrawLine(new Pen(Color.Red, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                                        break;
                                }
                            }

                            if (m_arrSampleBlobLeads[i].blnTipCenterFound)
                            {
                                switch (intLeadPosition)
                                {
                                    case 1:
                                        g.DrawLine(new Pen(Color.Lime, 2), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                                        g.DrawLine(new Pen(Color.Lime, 2), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                                        break;
                                    case 2:
                                        g.DrawLine(new Pen(Color.Lime, 2), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                                        g.DrawLine(new Pen(Color.Lime, 2), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                                        break;
                                    case 3:
                                        g.DrawLine(new Pen(Color.Lime, 2), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                                        g.DrawLine(new Pen(Color.Lime, 2), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                                        break;
                                    case 4:
                                        g.DrawLine(new Pen(Color.Lime, 2), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                                        g.DrawLine(new Pen(Color.Lime, 2), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                                        break;
                                }
                            }
                            else
                            {
                                switch (intLeadPosition)
                                {
                                    case 1:
                                        g.DrawLine(new Pen(Color.Red, 2), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                                        g.DrawLine(new Pen(Color.Red, 2), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                                        break;
                                    case 2:
                                        g.DrawLine(new Pen(Color.Red, 2), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                                        g.DrawLine(new Pen(Color.Red, 2), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                                        break;
                                    case 3:
                                        g.DrawLine(new Pen(Color.Red, 2), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                                        g.DrawLine(new Pen(Color.Red, 2), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                                        break;
                                    case 4:
                                        g.DrawLine(new Pen(Color.Red, 2), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                                        g.DrawLine(new Pen(Color.Red, 2), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                                        break;
                                }
                            }

                            if (m_arrSampleBlobLeads[i].blnTipEndFound)
                            {
                                switch (intLeadPosition)
                                {
                                    case 1:
                                        g.DrawLine(new Pen(Color.Lime, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                                        g.DrawLine(new Pen(Color.Lime, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                                        break;
                                    case 2:
                                        g.DrawLine(new Pen(Color.Lime, 2), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                                        g.DrawLine(new Pen(Color.Lime, 2), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                                        break;
                                    case 3:
                                        g.DrawLine(new Pen(Color.Lime, 2), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                                        g.DrawLine(new Pen(Color.Lime, 2), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                                        break;
                                    case 4:
                                        g.DrawLine(new Pen(Color.Lime, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                                        g.DrawLine(new Pen(Color.Lime, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                                        break;
                                }
                            }
                            else
                            {
                                switch (intLeadPosition)
                                {
                                    case 1:
                                        g.DrawLine(new Pen(Color.Red, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                                        g.DrawLine(new Pen(Color.Red, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                                        break;
                                    case 2:
                                        g.DrawLine(new Pen(Color.Red, 2), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                                        g.DrawLine(new Pen(Color.Red, 2), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                                        break;
                                    case 3:
                                        g.DrawLine(new Pen(Color.Red, 2), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                                        g.DrawLine(new Pen(Color.Red, 2), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                                        break;
                                    case 4:
                                        g.DrawLine(new Pen(Color.Red, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                                        g.DrawLine(new Pen(Color.Red, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                                        break;
                                }
                            }

                            if (m_arrSampleBlobLeads[i].blnBaseStartFound)
                            {
                                switch (intLeadPosition)
                                {
                                    case 1:
                                        g.DrawLine(new Pen(Color.Lime, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                                        g.DrawLine(new Pen(Color.Lime, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                                        break;
                                    case 2:
                                        g.DrawLine(new Pen(Color.Lime, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                                        g.DrawLine(new Pen(Color.Lime, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                                        break;
                                    case 3:
                                        g.DrawLine(new Pen(Color.Lime, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                                        g.DrawLine(new Pen(Color.Lime, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                                        break;
                                    case 4:
                                        g.DrawLine(new Pen(Color.Lime, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                                        g.DrawLine(new Pen(Color.Lime, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                                        break;
                                }
                            }
                            else
                            {
                                switch (intLeadPosition)
                                {
                                    case 1:
                                        g.DrawLine(new Pen(Color.Red, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                                        g.DrawLine(new Pen(Color.Red, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                                        break;
                                    case 2:
                                        g.DrawLine(new Pen(Color.Red, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                                        g.DrawLine(new Pen(Color.Red, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                                        break;
                                    case 3:
                                        g.DrawLine(new Pen(Color.Red, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                                        g.DrawLine(new Pen(Color.Red, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                                        break;
                                    case 4:
                                        g.DrawLine(new Pen(Color.Red, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                                        g.DrawLine(new Pen(Color.Red, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                                        break;
                                }
                            }

                            if (m_arrSampleBlobLeads[i].blnBaseCenterFound)
                            {
                                switch (intLeadPosition)
                                {
                                    case 1:
                                        g.DrawLine(new Pen(Color.Lime, 1), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                                        g.DrawLine(new Pen(Color.Lime, 1), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                                        break;
                                    case 2:
                                        g.DrawLine(new Pen(Color.Lime, 1), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                                        g.DrawLine(new Pen(Color.Lime, 1), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                                        break;
                                    case 3:
                                        g.DrawLine(new Pen(Color.Lime, 1), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                                        g.DrawLine(new Pen(Color.Lime, 1), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                                        break;
                                    case 4:
                                        g.DrawLine(new Pen(Color.Lime, 1), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                                        g.DrawLine(new Pen(Color.Lime, 1), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                                        break;
                                }
                            }
                            else
                            {
                                switch (intLeadPosition)
                                {
                                    case 1:
                                        g.DrawLine(new Pen(Color.Red, 1), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                                        g.DrawLine(new Pen(Color.Red, 1), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                                        break;
                                    case 2:
                                        g.DrawLine(new Pen(Color.Red, 1), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                                        g.DrawLine(new Pen(Color.Red, 1), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                                        break;
                                    case 3:
                                        g.DrawLine(new Pen(Color.Red, 1), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                                        g.DrawLine(new Pen(Color.Red, 1), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                                        break;
                                    case 4:
                                        g.DrawLine(new Pen(Color.Red, 1), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                                        g.DrawLine(new Pen(Color.Red, 1), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                                        break;
                                }
                            }

                            if (m_arrSampleBlobLeads[i].blnBaseEndFound)
                            {
                                switch (intLeadPosition)
                                {
                                    case 1:
                                        g.DrawLine(new Pen(Color.Lime, 1), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                                        g.DrawLine(new Pen(Color.Lime, 1), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                                        break;
                                    case 2:
                                        g.DrawLine(new Pen(Color.Lime, 1), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                                        g.DrawLine(new Pen(Color.Lime, 1), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                                        break;
                                    case 3:
                                        g.DrawLine(new Pen(Color.Lime, 1), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                                        g.DrawLine(new Pen(Color.Lime, 1), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                                        break;
                                    case 4:
                                        g.DrawLine(new Pen(Color.Lime, 1), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                                        g.DrawLine(new Pen(Color.Lime, 1), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                                        break;
                                }
                            }
                            else
                            {
                                switch (intLeadPosition)
                                {
                                    case 1:
                                        g.DrawLine(new Pen(Color.Red, 1), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                                        g.DrawLine(new Pen(Color.Red, 1), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                                        break;
                                    case 2:
                                        g.DrawLine(new Pen(Color.Red, 1), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                                        g.DrawLine(new Pen(Color.Red, 1), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                                        break;
                                    case 3:
                                        g.DrawLine(new Pen(Color.Red, 1), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                                        g.DrawLine(new Pen(Color.Red, 1), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                                        break;
                                    case 4:
                                        g.DrawLine(new Pen(Color.Red, 1), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                                        g.DrawLine(new Pen(Color.Red, 1), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                                        break;
                                }
                            }

                            g.DrawLine(new Pen(Color.Blue, 1), p5.X, p5.Y, p6.X, p6.Y);


                            System.Drawing.PointF pR1 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fStartX, intRoiOrgY + m_arrSampleBlobLeads[i].fStartY);
                            System.Drawing.PointF pR2 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fEndX, intRoiOrgY + m_arrSampleBlobLeads[i].fStartY);
                            System.Drawing.PointF pR3 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fStartX, intRoiOrgY + m_arrSampleBlobLeads[i].fEndY);

                            switch (intLeadPosition)
                            {
                                case 1:
                                    pR1 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX - m_arrSampleBlobLeads[i].fTipWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY + m_stcBlobLead.intTipInwardOffset);
                                    pR2 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY);
                                    pR3 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX + m_arrSampleBlobLeads[i].fTipWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY + m_stcBlobLead.intTipInwardOffset);
                                    break;
                                case 2:
                                    pR1 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX - m_stcBlobLead.intTipInwardOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY - (m_arrSampleBlobLeads[i].fTipWidth / 2));
                                    pR2 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY);
                                    pR3 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX - m_stcBlobLead.intTipInwardOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY + (m_arrSampleBlobLeads[i].fTipWidth / 2));
                                    break;
                                case 3:
                                    pR1 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX - m_arrSampleBlobLeads[i].fTipWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY - m_stcBlobLead.intTipInwardOffset);
                                    pR2 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY);
                                    pR3 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX + m_arrSampleBlobLeads[i].fTipWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY - m_stcBlobLead.intTipInwardOffset);
                                    break;
                                case 4:
                                    pR1 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX + m_stcBlobLead.intTipInwardOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY - (m_arrSampleBlobLeads[i].fTipWidth / 2));
                                    pR2 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY);
                                    pR3 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX + m_stcBlobLead.intTipInwardOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY + (m_arrSampleBlobLeads[i].fTipWidth / 2));
                                    break;
                            }

                            if (blnDrawWithCompensateAngle)
                            {
                                Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY, pR1, -fCenterUnitCompensateAngle_ForDrawing, ref pR1);
                                Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY, pR2, -fCenterUnitCompensateAngle_ForDrawing, ref pR2);
                                Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY, pR3, -fCenterUnitCompensateAngle_ForDrawing, ref pR3);
                            }

                            if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                            {
                                pR1.X = pR1.X * fDrawingScaleX;
                                pR1.Y = pR1.Y * fDrawingScaleY;
                                pR2.X = pR2.X * fDrawingScaleX;
                                pR2.Y = pR2.Y * fDrawingScaleY;
                                pR3.X = pR3.X * fDrawingScaleX;
                                pR3.Y = pR3.Y * fDrawingScaleY;
                            }

                            switch (intLeadPosition)
                            {
                                case 1: // Top

                                    g.DrawRectangle(new Pen(Color.Red, 1), pR1.X - 5, pR2.Y - 5, pR3.X - pR1.X + 10, Math.Max(pR1.Y, pR3.Y) - pR2.Y + 10);

                                    break;
                                case 2: // Right

                                    g.DrawRectangle(new Pen(Color.Red, 1), Math.Min(pR3.X, pR1.X) - 5, pR1.Y - 5, pR2.X - Math.Min(pR3.X, pR1.X) + 10, pR3.Y - pR1.Y + 10);

                                    break;
                                case 3: // Bottom

                                    g.DrawRectangle(new Pen(Color.Red, 1), pR1.X - 5, Math.Min(pR1.Y, pR3.Y) - 5, pR3.X - pR1.X + 10, pR2.Y - Math.Min(pR1.Y, pR3.Y) + 10);

                                    break;
                                case 4: // Left

                                    g.DrawRectangle(new Pen(Color.Red, 1), pR2.X - 5, pR1.Y - 5, Math.Max(pR3.X, pR1.X) - pR2.X + 10, pR3.Y - pR1.Y + 10);

                                    break;
                            }

                            //if (i == intLeadSelectingNumber)
                            //{
                            //    g.DrawLine(limePen, p1, p2);
                            //    g.DrawLine(limePen, p2, p4);
                            //    g.DrawLine(limePen, p4, p3);
                            //    g.DrawLine(limePen, p3, p1);
                            //    g.DrawLine(limePen, p1, p4);
                            //}
                            //else
                            //{
                            //    g.DrawLine(redPen, p1, p2);
                            //    g.DrawLine(redPen, p2, p4);
                            //    g.DrawLine(redPen, p4, p3);
                            //    g.DrawLine(redPen, p3, p1);
                            //    g.DrawLine(redPen, p1, p4);
                            //}

                            if (m_blnLock)
                                return;

                            switch (intLeadPosition)
                            {
                                case 1:
                                    //g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                                    //        (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterX + intRoiOrgX) * fDrawingScaleX,
                                    //        (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterY + intRoiOrgY - 40) * fDrawingScaleY);
                                    g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                               ((float)((SampleBlobsFeatures)m_arrSampleBlobLeads[i]).fCenterX + intRoiOrgX - 8) * fDrawingScaleX,
                               ((float)((SampleBlobsFeatures)m_arrSampleBlobLeads[i]).fStartY + intRoiOrgY - m_stcBlobLead.intTipInwardOffset - m_Font.Height - 5) * fDrawingScaleY);
                                    break;
                                case 2:
                                    //g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                                    //        (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterX + intRoiOrgX + 27) * fDrawingScaleX,
                                    //        (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterY + intRoiOrgY - 8) * fDrawingScaleY);
                                    g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                              ((float)((SampleBlobsFeatures)m_arrSampleBlobLeads[i]).fEndX + intRoiOrgX + 5) * fDrawingScaleX,
                              ((float)((SampleBlobsFeatures)m_arrSampleBlobLeads[i]).fCenterY + intRoiOrgY - 8) * fDrawingScaleY);
                                    break;
                                case 3:
                                    //g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                                    //        (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterX + intRoiOrgX) * fDrawingScaleX,
                                    //        (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterY + intRoiOrgY + 27) * fDrawingScaleY);
                                    g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                             ((float)((SampleBlobsFeatures)m_arrSampleBlobLeads[i]).fCenterX + intRoiOrgX - 8) * fDrawingScaleX,
                             ((float)((SampleBlobsFeatures)m_arrSampleBlobLeads[i]).fEndY + intRoiOrgY + 5) * fDrawingScaleY);
                                    break;
                                case 4:
                                    //g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                                    //        (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterX + intRoiOrgX - 40) * fDrawingScaleX,
                                    //        (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterY + intRoiOrgY - 8) * fDrawingScaleY);
                                    g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                               ((float)((SampleBlobsFeatures)m_arrSampleBlobLeads[i]).fStartX - m_stcBlobLead.intTipInwardOffset + intRoiOrgX - (((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString().Length * m_Font.Size) - 5) * fDrawingScaleX,
                               ((float)((SampleBlobsFeatures)m_arrSampleBlobLeads[i]).fCenterY + intRoiOrgY - 8) * fDrawingScaleY);
                                    break;
                            }

                        }

                        //2020 08 14 - CCENG: Draw reference point here
                        if (m_fSampleReferencePointEndX != 0 && m_fSampleReferencePointEndY != 0)
                        {
                            System.Drawing.PointF pRefPoint1 = new PointF();
                            System.Drawing.PointF pRefPoint2 = new PointF();
                            pRefPoint1 = new System.Drawing.PointF(intRoiOrgX + m_fSampleReferencePointStartX, intRoiOrgY + m_fSampleReferencePointStartY);
                            pRefPoint2 = new System.Drawing.PointF(intRoiOrgX + m_fSampleReferencePointEndX, intRoiOrgY + m_fSampleReferencePointEndY);

                            if (blnDrawWithCompensateAngle)
                            {
                                Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY, pRefPoint1, -fCenterUnitCompensateAngle_ForDrawing, ref pRefPoint1);
                                Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY, pRefPoint2, -fCenterUnitCompensateAngle_ForDrawing, ref pRefPoint2);
                            }

                            if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                            {
                                pRefPoint1.X = pRefPoint1.X * fDrawingScaleX;
                                pRefPoint1.Y = pRefPoint1.Y * fDrawingScaleY;
                                pRefPoint2.X = pRefPoint2.X * fDrawingScaleX;
                                pRefPoint2.Y = pRefPoint2.Y * fDrawingScaleY;
                            }

                            g.DrawLine(new Pen(Color.Cyan, 1), pRefPoint1.X, pRefPoint1.Y - 3, pRefPoint1.X, pRefPoint1.Y + 3);
                            g.DrawLine(new Pen(Color.Cyan, 1), pRefPoint1.X - 3, pRefPoint1.Y, pRefPoint1.X + 3, pRefPoint1.Y);

                            g.DrawLine(new Pen(Color.Cyan, 1), pRefPoint2.X, pRefPoint2.Y - 3, pRefPoint2.X, pRefPoint2.Y + 3);
                            g.DrawLine(new Pen(Color.Cyan, 1), pRefPoint2.X - 3, pRefPoint2.Y, pRefPoint2.X + 3, pRefPoint2.Y);

                            g.DrawLine(new Pen(Color.Cyan, 1), pRefPoint1.X, pRefPoint1.Y, pRefPoint2.X, pRefPoint2.Y);
                        }

                        // Draw Average Gray Value ROI
                        if (m_blnWantUseAverageGrayValueMethod && (m_intFailOptionMask & 0x4000) > 0)
                        {
                            //float fStartX = 0, fStartY = 0, fWidth = 0, fHeight = 0;
                            //switch (m_intLeadROIDirection)
                            //{
                            //    case 1: // Top
                            //        fStartX = (intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX - (m_arrSampleBlobLeads[i].fTipWidth / 2) + m_stcBlobLead.intAGVROITolerance_Left) * fDrawingScaleX;
                            //        fStartY = (intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY + m_stcBlobLead.intAGVROITolerance_Top) * fDrawingScaleY;
                            //        fWidth = (m_arrSampleBlobLeads[i].fTipWidth - m_stcBlobLead.intAGVROITolerance_Left - m_stcBlobLead.intAGVROITolerance_Right) * fDrawingScaleX;
                            //        fHeight = (m_arrSampleBlobLeads[i].fTipHeight - m_stcBlobLead.intAGVROITolerance_Top - m_stcBlobLead.intAGVROITolerance_Bottom) * fDrawingScaleY;
                            //        break;
                            //    case 3: // Bottom
                            //        fStartX = (intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX - (m_arrSampleBlobLeads[i].fTipWidth / 2) + m_stcBlobLead.intAGVROITolerance_Left) * fDrawingScaleX;
                            //        fStartY = (intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY - m_arrSampleBlobLeads[i].fTipHeight + m_stcBlobLead.intAGVROITolerance_Top) * fDrawingScaleY;
                            //        fWidth = (m_arrSampleBlobLeads[i].fTipWidth - m_stcBlobLead.intAGVROITolerance_Left - m_stcBlobLead.intAGVROITolerance_Right) * fDrawingScaleX;
                            //        fHeight = (m_arrSampleBlobLeads[i].fTipHeight - m_stcBlobLead.intAGVROITolerance_Top - m_stcBlobLead.intAGVROITolerance_Bottom) * fDrawingScaleY;
                            //        break;
                            //    case 4: // Left
                            //        fStartX = (intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX + m_stcBlobLead.intAGVROITolerance_Left) * fDrawingScaleX;
                            //        fStartY = (intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY - (m_arrSampleBlobLeads[i].fTipWidth / 2) + m_stcBlobLead.intAGVROITolerance_Top) * fDrawingScaleY;
                            //        fWidth = (m_arrSampleBlobLeads[i].fTipHeight - m_stcBlobLead.intAGVROITolerance_Left - m_stcBlobLead.intAGVROITolerance_Right) * fDrawingScaleX;
                            //        fHeight = (m_arrSampleBlobLeads[i].fTipWidth - m_stcBlobLead.intAGVROITolerance_Top - m_stcBlobLead.intAGVROITolerance_Bottom) * fDrawingScaleY;
                            //        break;
                            //    case 2: // Right
                            //        fStartX = (intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX - m_arrSampleBlobLeads[i].fTipHeight + m_stcBlobLead.intAGVROITolerance_Left) * fDrawingScaleX;
                            //        fStartY = (intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY - (m_arrSampleBlobLeads[i].fTipWidth / 2) + m_stcBlobLead.intAGVROITolerance_Top) * fDrawingScaleY;
                            //        fWidth = (m_arrSampleBlobLeads[i].fTipHeight - m_stcBlobLead.intAGVROITolerance_Left - m_stcBlobLead.intAGVROITolerance_Right) * fDrawingScaleX;
                            //        fHeight = (m_arrSampleBlobLeads[i].fTipWidth - m_stcBlobLead.intAGVROITolerance_Top - m_stcBlobLead.intAGVROITolerance_Bottom) * fDrawingScaleY;
                            //        break;
                            //}

                            PointF p1 = new PointF();
                            PointF p2 = new PointF();
                            PointF p3 = new PointF();
                            PointF p4 = new PointF();
                            switch (m_intLeadROIDirection)
                            {
                                case 1: // Top
                                    p1.X = (intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX - (m_arrSampleBlobLeads[i].fTipWidth / 2) + m_stcBlobLead.intAGVROITolerance_Left);
                                    p1.Y = (intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY + m_stcBlobLead.intAGVROITolerance_Top);
                                    p2.X = (intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX + (m_arrSampleBlobLeads[i].fTipWidth / 2) - m_stcBlobLead.intAGVROITolerance_Right);
                                    p2.Y = p1.Y;
                                    p3.X = p2.X;
                                    p3.Y = (intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY + m_arrSampleBlobLeads[i].fTipHeight - m_stcBlobLead.intAGVROITolerance_Bottom);
                                    p4.X = p1.X;
                                    p4.Y = p3.Y;

                                    break;
                                case 3: // Bottom
                                    p1.X = (intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX - (m_arrSampleBlobLeads[i].fTipWidth / 2) + m_stcBlobLead.intAGVROITolerance_Left);
                                    p1.Y = (intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY - m_arrSampleBlobLeads[i].fTipHeight + m_stcBlobLead.intAGVROITolerance_Top);
                                    p2.X = (intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX + (m_arrSampleBlobLeads[i].fTipWidth / 2) - m_stcBlobLead.intAGVROITolerance_Right);
                                    p2.Y = p1.Y;
                                    p3.X = p2.X;
                                    p3.Y = (intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY - m_stcBlobLead.intAGVROITolerance_Bottom);
                                    p4.X = p1.X;
                                    p4.Y = p3.Y;

                                    break;
                                case 4: // Left
                                    p1.X = (intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX + m_stcBlobLead.intAGVROITolerance_Left);
                                    p1.Y = (intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY - (m_arrSampleBlobLeads[i].fTipWidth / 2) + m_stcBlobLead.intAGVROITolerance_Top);
                                    p2.X = (intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX + (m_arrSampleBlobLeads[i].fTipHeight) - m_stcBlobLead.intAGVROITolerance_Right);
                                    p2.Y = p1.Y;
                                    p3.X = p2.X;
                                    p3.Y = (intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY + m_arrSampleBlobLeads[i].fTipWidth / 2 - m_stcBlobLead.intAGVROITolerance_Bottom);
                                    p4.X = p1.X;
                                    p4.Y = p3.Y;
                                    break;
                                case 2: // Right
                                    p1.X = (intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX - m_arrSampleBlobLeads[i].fTipHeight + m_stcBlobLead.intAGVROITolerance_Left);
                                    p1.Y = (intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY - (m_arrSampleBlobLeads[i].fTipWidth / 2) + m_stcBlobLead.intAGVROITolerance_Top);
                                    p2.X = (intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX - m_stcBlobLead.intAGVROITolerance_Right);
                                    p2.Y = p1.Y;
                                    p3.X = p2.X;
                                    p3.Y = (intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY + m_arrSampleBlobLeads[i].fTipWidth / 2 - m_stcBlobLead.intAGVROITolerance_Bottom);
                                    p4.X = p1.X;
                                    p4.Y = p3.Y;
                                    break;
                            }

                            if (blnDrawWithCompensateAngle)
                            {
                                Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY, p1, -fCenterUnitCompensateAngle_ForDrawing, ref p1);
                                Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY, p2, -fCenterUnitCompensateAngle_ForDrawing, ref p2);
                                Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY, p3, -fCenterUnitCompensateAngle_ForDrawing, ref p3);
                                Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY, p4, -fCenterUnitCompensateAngle_ForDrawing, ref p4);
                            }

                            if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                            {
                                p1.X = p1.X * fDrawingScaleX;
                                p1.Y = p1.Y * fDrawingScaleY;
                                p2.X = p2.X * fDrawingScaleX;
                                p2.Y = p2.Y * fDrawingScaleY;
                                p3.X = p3.X * fDrawingScaleX;
                                p3.Y = p3.Y * fDrawingScaleY;
                                p4.X = p4.X * fDrawingScaleX;
                                p4.Y = p4.Y * fDrawingScaleY;
                            }

                            g.DrawLine(new Pen(Color.Turquoise, 1), p1, p2);
                            g.DrawLine(new Pen(Color.Turquoise, 1), p2, p3);
                            g.DrawLine(new Pen(Color.Turquoise, 1), p3, p4);
                            g.DrawLine(new Pen(Color.Turquoise, 1), p4, p1);

                        }
                    }
                }

                //for (int i = 0; i < m_arrLeadDefectList.Count; i++)
                //{
                //    if (m_blnLock)
                //        return;

                //    g.DrawRectangle(redPen, (m_arrLeadDefectList[i].ref_fCenterX - m_arrLeadDefectList[i].ref_fWidth / 2) * fDrawingScaleX,
                //                            (m_arrLeadDefectList[i].ref_fCenterY - m_arrLeadDefectList[i].ref_fHeight / 2) * fDrawingScaleY,
                //                            m_arrLeadDefectList[i].ref_fWidth * fDrawingScaleX, m_arrLeadDefectList[i].ref_fHeight * fDrawingScaleY);
                //}

                for (int i = 0; i < m_arrFailPitchGapList.Count; i++)
                {
                    if (m_blnLock)
                        return;
                    if (!blnFail)
                        blnFail = true;
                    g.DrawLine(redPen, (float)(m_arrFailPitchGapList[i].intStartPointX - 5) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intStartPointY - 5) * fDrawingScaleY,
                                       (float)(m_arrFailPitchGapList[i].intStartPointX + 5) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intStartPointY + 5) * fDrawingScaleY);
                    g.DrawLine(redPen, (float)(m_arrFailPitchGapList[i].intStartPointX + 5) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intStartPointY - 5) * fDrawingScaleY,
                                       (float)(m_arrFailPitchGapList[i].intStartPointX - 5) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intStartPointY + 5) * fDrawingScaleY);
                    g.DrawLine(redPen, (float)(m_arrFailPitchGapList[i].intEndPointX - 5) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intEndPointY - 5) * fDrawingScaleY,
                                       (float)(m_arrFailPitchGapList[i].intEndPointX + 5) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intEndPointY + 5) * fDrawingScaleY);
                    g.DrawLine(redPen, (float)(m_arrFailPitchGapList[i].intEndPointX + 5) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intEndPointY - 5) * fDrawingScaleY,
                                       (float)(m_arrFailPitchGapList[i].intEndPointX - 5) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intEndPointY + 5) * fDrawingScaleY);
                    g.DrawLine(redPen, (float)(m_arrFailPitchGapList[i].intStartPointX) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intStartPointY) * fDrawingScaleY,
                                       (float)(m_arrFailPitchGapList[i].intEndPointX) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intEndPointY) * fDrawingScaleY);
                }

                if (blnFail && !m_blnLock)
                {
                    objROI.DrawROI(g, fDrawingScaleX, fDrawingScaleY, false, Color.Red);
                }
            }
        }
        public void DrawBaseLeadDisplayResult(Graphics g, float fDrawingScaleX, float fDrawingScaleY, int intLeadSelectingNumber, int intRoiOrgX, int intRoiOrgY, int intLeadPosition, int intSelectedLeadExtraBlobID)
        {
            lock (m_objLockBlobs)
            {
                if (m_blnLock)
                    return;

                Pen redPen = new Pen(Color.Red);
                Pen limePen = new Pen(Color.Lime);
                Pen bluePen = new Pen(Color.Blue);
                if (m_arrSampleBlobLeads_BaseLead.Length != 0 && m_arrSampleBlobLeads_BaseLead[0].fArea == 0)
                {
                    for (int i = 0; i < m_arrTemplateBlobLeads_BaseLead.Count; i++)
                    {
                        if (m_blnLock)
                            return;

                        m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i];
                        System.Drawing.PointF p1 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.intStartX, intRoiOrgY + m_stcBlobLead.intStartY);
                        System.Drawing.PointF p2 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.intEndX, intRoiOrgY + m_stcBlobLead.intStartY);
                        System.Drawing.PointF p3 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.intStartX, intRoiOrgY + m_stcBlobLead.intEndY);
                        System.Drawing.PointF p4 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.intEndX, intRoiOrgY + m_stcBlobLead.intEndY);

                        if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                        {
                            p1.X = p1.X * fDrawingScaleX;
                            p1.Y = p1.Y * fDrawingScaleY;
                            p2.X = p2.X * fDrawingScaleX;
                            p2.Y = p2.Y * fDrawingScaleY;
                            p3.X = p3.X * fDrawingScaleX;
                            p3.Y = p3.Y * fDrawingScaleY;
                            p4.X = p4.X * fDrawingScaleX;
                            p4.Y = p4.Y * fDrawingScaleY;
                        }

                        g.DrawLine(redPen, p1, p2);
                        g.DrawLine(redPen, p2, p4);
                        g.DrawLine(redPen, p4, p3);
                        g.DrawLine(redPen, p3, p1);
                        g.DrawLine(redPen, p1, p4);
                        g.DrawString(m_stcBlobLead.intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                            (float)(m_stcBlobLead.fLimitCenterX + intRoiOrgX - 8) * fDrawingScaleX,
                            (float)(m_stcBlobLead.fLimitCenterY + intRoiOrgY - 8) * fDrawingScaleY);
                    }
                }
                else
                {
                    for (int i = 0; i < m_arrSampleBlobLeads_BaseLead.Length; i++)
                    {
                        if (m_blnLock)
                            return;

                        m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i];
                      
                        //Valid Lead
                        if (m_arrSampleBlobLeads_BaseLead[i].intFailMask == 0)
                        {
                            System.Drawing.PointF p1 = new System.Drawing.PointF(intRoiOrgX + ((SampleBlobsFeatures)m_arrSampleBlobLeads_BaseLead[i]).fStartX, intRoiOrgY + ((SampleBlobsFeatures)m_arrSampleBlobLeads_BaseLead[i]).fStartY);
                            System.Drawing.PointF p2 = new System.Drawing.PointF(intRoiOrgX + ((SampleBlobsFeatures)m_arrSampleBlobLeads_BaseLead[i]).fEndX, intRoiOrgY + ((SampleBlobsFeatures)m_arrSampleBlobLeads_BaseLead[i]).fStartY);
                            System.Drawing.PointF p3 = new System.Drawing.PointF(intRoiOrgX + ((SampleBlobsFeatures)m_arrSampleBlobLeads_BaseLead[i]).fStartX, intRoiOrgY + ((SampleBlobsFeatures)m_arrSampleBlobLeads_BaseLead[i]).fEndY);
                            System.Drawing.PointF p4 = new System.Drawing.PointF(intRoiOrgX + ((SampleBlobsFeatures)m_arrSampleBlobLeads_BaseLead[i]).fEndX, intRoiOrgY + ((SampleBlobsFeatures)m_arrSampleBlobLeads_BaseLead[i]).fEndY);

                            if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                            {
                                p1.X = p1.X * fDrawingScaleX;
                                p1.Y = p1.Y * fDrawingScaleY;
                                p2.X = p2.X * fDrawingScaleX;
                                p2.Y = p2.Y * fDrawingScaleY;
                                p3.X = p3.X * fDrawingScaleX;
                                p3.Y = p3.Y * fDrawingScaleY;
                                p4.X = p4.X * fDrawingScaleX;
                                p4.Y = p4.Y * fDrawingScaleY;
                            }

                            g.DrawLine(limePen, p1, p2);
                            g.DrawLine(limePen, p2, p4);
                            g.DrawLine(limePen, p4, p3);
                            g.DrawLine(limePen, p3, p1);
                            g.DrawLine(limePen, p1, p4);
                           
                            switch (intLeadPosition)
                            {
                                case 1:
                                    g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Lime),
                                 ((float)((SampleBlobsFeatures)m_arrSampleBlobLeads_BaseLead[i]).fCenterX + intRoiOrgX - 8) * fDrawingScaleX,
                                 ((float)((SampleBlobsFeatures)m_arrSampleBlobLeads_BaseLead[i]).fStartY + intRoiOrgY - m_stcBlobLead.intTipInwardOffset - m_Font.Height - 5) * fDrawingScaleY);
                                    break;
                                case 2:
                                    g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Lime),
                            ((float)((SampleBlobsFeatures)m_arrSampleBlobLeads_BaseLead[i]).fEndX + intRoiOrgX + 5) * fDrawingScaleX,
                            ((float)((SampleBlobsFeatures)m_arrSampleBlobLeads_BaseLead[i]).fCenterY + intRoiOrgY - 8) * fDrawingScaleY);
                                    break;
                                case 3:
                                    g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Lime),
                            ((float)((SampleBlobsFeatures)m_arrSampleBlobLeads_BaseLead[i]).fCenterX + intRoiOrgX - 8) * fDrawingScaleX,
                            ((float)((SampleBlobsFeatures)m_arrSampleBlobLeads_BaseLead[i]).fEndY + intRoiOrgY + 5) * fDrawingScaleY);
                                    break;
                                case 4:
                                    g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Lime),
                                ((float)((SampleBlobsFeatures)m_arrSampleBlobLeads_BaseLead[i]).fStartX - m_stcBlobLead.intTipInwardOffset + intRoiOrgX - (((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).intNoID.ToString().Length * m_Font.Size) - 5) * fDrawingScaleX,
                                ((float)((SampleBlobsFeatures)m_arrSampleBlobLeads_BaseLead[i]).fCenterY + intRoiOrgY - 8) * fDrawingScaleY);
                                    break;
                            }

                        }
                        else
                        {
                            System.Drawing.PointF p1 = new System.Drawing.PointF(intRoiOrgX + ((SampleBlobsFeatures)m_arrSampleBlobLeads_BaseLead[i]).fStartX, intRoiOrgY + ((SampleBlobsFeatures)m_arrSampleBlobLeads_BaseLead[i]).fStartY);
                            System.Drawing.PointF p2 = new System.Drawing.PointF(intRoiOrgX + ((SampleBlobsFeatures)m_arrSampleBlobLeads_BaseLead[i]).fEndX, intRoiOrgY + ((SampleBlobsFeatures)m_arrSampleBlobLeads_BaseLead[i]).fStartY);
                            System.Drawing.PointF p3 = new System.Drawing.PointF(intRoiOrgX + ((SampleBlobsFeatures)m_arrSampleBlobLeads_BaseLead[i]).fStartX, intRoiOrgY + ((SampleBlobsFeatures)m_arrSampleBlobLeads_BaseLead[i]).fEndY);
                            System.Drawing.PointF p4 = new System.Drawing.PointF(intRoiOrgX + ((SampleBlobsFeatures)m_arrSampleBlobLeads_BaseLead[i]).fEndX, intRoiOrgY + ((SampleBlobsFeatures)m_arrSampleBlobLeads_BaseLead[i]).fEndY);

                            if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                            {
                                p1.X = p1.X * fDrawingScaleX;
                                p1.Y = p1.Y * fDrawingScaleY;
                                p2.X = p2.X * fDrawingScaleX;
                                p2.Y = p2.Y * fDrawingScaleY;
                                p3.X = p3.X * fDrawingScaleX;
                                p3.Y = p3.Y * fDrawingScaleY;
                                p4.X = p4.X * fDrawingScaleX;
                                p4.Y = p4.Y * fDrawingScaleY;
                            }

                            g.DrawLine(redPen, p1, p2);
                            g.DrawLine(redPen, p2, p4);
                            g.DrawLine(redPen, p4, p3);
                            g.DrawLine(redPen, p3, p1);
                            g.DrawLine(redPen, p1, p4);

                            if (m_blnLock)
                                return;

                            switch (intLeadPosition)
                            {
                                case 1:
                                    g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                               ((float)((SampleBlobsFeatures)m_arrSampleBlobLeads_BaseLead[i]).fCenterX + intRoiOrgX - 8) * fDrawingScaleX,
                               ((float)((SampleBlobsFeatures)m_arrSampleBlobLeads_BaseLead[i]).fStartY + intRoiOrgY - m_Font.Height - 5) * fDrawingScaleY);
                                    break;
                                case 2:
                                    g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                              ((float)((SampleBlobsFeatures)m_arrSampleBlobLeads_BaseLead[i]).fEndX + intRoiOrgX + 5) * fDrawingScaleX,
                              ((float)((SampleBlobsFeatures)m_arrSampleBlobLeads_BaseLead[i]).fCenterY + intRoiOrgY - 8) * fDrawingScaleY);
                                    break;
                                case 3:
                                    g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                             ((float)((SampleBlobsFeatures)m_arrSampleBlobLeads_BaseLead[i]).fCenterX + intRoiOrgX - 8) * fDrawingScaleX,
                             ((float)((SampleBlobsFeatures)m_arrSampleBlobLeads_BaseLead[i]).fEndY + intRoiOrgY + 5) * fDrawingScaleY);
                                    break;
                                case 4:
                                    g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                               ((float)((SampleBlobsFeatures)m_arrSampleBlobLeads_BaseLead[i]).fStartX + intRoiOrgX - (((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).intNoID.ToString().Length * m_Font.Size) - 5) * fDrawingScaleX,
                               ((float)((SampleBlobsFeatures)m_arrSampleBlobLeads_BaseLead[i]).fCenterY + intRoiOrgY - 8) * fDrawingScaleY);
                                    break;
                            }

                        }
                        
                    }
                }
            }
        }
        public void DrawLeadDisplayResult_PkgToBase(Graphics g, float fDrawingScaleX, float fDrawingScaleY, int intLeadSelectingNumber, int intRoiOrgX, int intRoiOrgY, int intLeadPosition, int intSelectedLeadExtraBlobID, Color[][] arrColor, ROI objROI)
        {
            lock (m_objLockBlobs)
            {
                if (m_blnLock)
                    return;
                bool blnFail = false;
                switch (intLeadPosition)
                {
                    case 1:
                        g.DrawLine(new Pen(arrColor[5][0], 1), (m_fCenterX_PackageGaugeM4L - m_fWidth_PackageGaugeM4L / 2) * fDrawingScaleX,
                                                   ((m_fCenterY_PackageGaugeM4L - m_fHeight_PackageGaugeM4L / 2) - m_intPkgToBaseTolerance_Top) * fDrawingScaleY,
                                                   (m_fCenterX_PackageGaugeM4L + m_fWidth_PackageGaugeM4L / 2) * fDrawingScaleX,
                                                   ((m_fCenterY_PackageGaugeM4L - m_fHeight_PackageGaugeM4L / 2) - m_intPkgToBaseTolerance_Top) * fDrawingScaleY);
                        break;
                    case 2:
                        g.DrawLine(new Pen(arrColor[5][0], 1), ((m_fCenterX_PackageGaugeM4L + m_fWidth_PackageGaugeM4L / 2) + m_intPkgToBaseTolerance_Right) * fDrawingScaleX,
                                                    (m_fCenterY_PackageGaugeM4L - m_fHeight_PackageGaugeM4L / 2) * fDrawingScaleY,
                                                    ((m_fCenterX_PackageGaugeM4L + m_fWidth_PackageGaugeM4L / 2) + m_intPkgToBaseTolerance_Right) * fDrawingScaleX,
                                                    (m_fCenterY_PackageGaugeM4L + m_fHeight_PackageGaugeM4L / 2) * fDrawingScaleY);
                        break;
                    case 3:
                        g.DrawLine(new Pen(arrColor[5][0], 1), (m_fCenterX_PackageGaugeM4L - m_fWidth_PackageGaugeM4L / 2) * fDrawingScaleX,
                                                   ((m_fCenterY_PackageGaugeM4L + m_fHeight_PackageGaugeM4L / 2) + m_intPkgToBaseTolerance_Bottom) * fDrawingScaleY,
                                                   (m_fCenterX_PackageGaugeM4L + m_fWidth_PackageGaugeM4L / 2) * fDrawingScaleX,
                                                   ((m_fCenterY_PackageGaugeM4L + m_fHeight_PackageGaugeM4L / 2) + m_intPkgToBaseTolerance_Bottom) * fDrawingScaleY);
                        break;
                    case 4:
                        g.DrawLine(new Pen(arrColor[5][0], 1), ((m_fCenterX_PackageGaugeM4L - m_fWidth_PackageGaugeM4L / 2) - m_intPkgToBaseTolerance_Left) * fDrawingScaleX,
                                                           (m_fCenterY_PackageGaugeM4L - m_fHeight_PackageGaugeM4L / 2) * fDrawingScaleY,
                                                           ((m_fCenterX_PackageGaugeM4L - m_fWidth_PackageGaugeM4L / 2) - m_intPkgToBaseTolerance_Left) * fDrawingScaleX,
                                                           (m_fCenterY_PackageGaugeM4L + m_fHeight_PackageGaugeM4L / 2) * fDrawingScaleY);
                        break;
                }

                Pen redPen = new Pen(Color.Red);
                Pen limePen = new Pen(Color.Lime);
                Pen bluePen = new Pen(Color.Blue);
                if (m_arrSampleBlobLeads.Length != 0 && m_arrSampleBlobLeads[0].fArea == 0)
                {
                    for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
                    {
                        if (m_blnLock)
                            return;

                        m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                        System.Drawing.PointF p1 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.intStartX, intRoiOrgY + m_stcBlobLead.intStartY);
                        System.Drawing.PointF p2 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.intEndX, intRoiOrgY + m_stcBlobLead.intStartY);
                        System.Drawing.PointF p3 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.intStartX, intRoiOrgY + m_stcBlobLead.intEndY);
                        System.Drawing.PointF p4 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.intEndX, intRoiOrgY + m_stcBlobLead.intEndY);

                        if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                        {
                            p1.X = p1.X * fDrawingScaleX;
                            p1.Y = p1.Y * fDrawingScaleY;
                            p2.X = p2.X * fDrawingScaleX;
                            p2.Y = p2.Y * fDrawingScaleY;
                            p3.X = p3.X * fDrawingScaleX;
                            p3.Y = p3.Y * fDrawingScaleY;
                            p4.X = p4.X * fDrawingScaleX;
                            p4.Y = p4.Y * fDrawingScaleY;
                        }
                        if (!blnFail)
                            blnFail = true;
                        g.DrawLine(redPen, p1, p2);
                        g.DrawLine(redPen, p2, p4);
                        g.DrawLine(redPen, p4, p3);
                        g.DrawLine(redPen, p3, p1);
                        g.DrawLine(redPen, p1, p4);
                        g.DrawString(m_stcBlobLead.intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                            (float)(m_stcBlobLead.fLimitCenterX + intRoiOrgX - 8) * fDrawingScaleX,
                            (float)(m_stcBlobLead.fLimitCenterY + intRoiOrgY - 8) * fDrawingScaleY);
                    }
                }
                else
                {
                    //Extra, Join Lead, Excess Lead
                    for (int i = 0; i < m_arrExtraBlobs.Count; i++)
                    {
                        if (m_blnLock)
                            return;
                        if (intSelectedLeadExtraBlobID < 0 && m_arrExtraBlobs[i].ref_intExtraBlobID < Math.Abs(intSelectedLeadExtraBlobID) && m_arrExtraBlobs[i].ref_intExtraBlobID > Math.Abs(intSelectedLeadExtraBlobID + m_arrExtraBlobs.Count))//&& m_arrExtraBlobs[i].ref_intFailCriteria > 0)
                        {
                            System.Drawing.PointF p1 = new System.Drawing.PointF(intRoiOrgX + m_arrExtraBlobs[i].fStartX, intRoiOrgY + m_arrExtraBlobs[i].fStartY);
                            System.Drawing.PointF p2 = new System.Drawing.PointF(intRoiOrgX + m_arrExtraBlobs[i].fEndX, intRoiOrgY + m_arrExtraBlobs[i].fStartY);
                            System.Drawing.PointF p3 = new System.Drawing.PointF(intRoiOrgX + m_arrExtraBlobs[i].fStartX, intRoiOrgY + m_arrExtraBlobs[i].fEndY);
                            System.Drawing.PointF p4 = new System.Drawing.PointF(intRoiOrgX + m_arrExtraBlobs[i].fEndX, intRoiOrgY + m_arrExtraBlobs[i].fEndY);

                            if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                            {
                                p1.X = p1.X * fDrawingScaleX;
                                p1.Y = p1.Y * fDrawingScaleY;
                                p2.X = p2.X * fDrawingScaleX;
                                p2.Y = p2.Y * fDrawingScaleY;
                                p3.X = p3.X * fDrawingScaleX;
                                p3.Y = p3.Y * fDrawingScaleY;
                                p4.X = p4.X * fDrawingScaleX;
                                p4.Y = p4.Y * fDrawingScaleY;
                            }

                            g.DrawLine(new Pen(Color.Yellow), p1, p2);
                            g.DrawLine(new Pen(Color.Yellow), p2, p4);
                            g.DrawLine(new Pen(Color.Yellow), p4, p3);
                            g.DrawLine(new Pen(Color.Yellow), p3, p1);

                        }
                        else if (m_arrExtraBlobs[i].ref_intExtraBlobID == intSelectedLeadExtraBlobID)
                        {
                            System.Drawing.PointF p1 = new System.Drawing.PointF(intRoiOrgX + m_arrExtraBlobs[i].fStartX, intRoiOrgY + m_arrExtraBlobs[i].fStartY);
                            System.Drawing.PointF p2 = new System.Drawing.PointF(intRoiOrgX + m_arrExtraBlobs[i].fEndX, intRoiOrgY + m_arrExtraBlobs[i].fStartY);
                            System.Drawing.PointF p3 = new System.Drawing.PointF(intRoiOrgX + m_arrExtraBlobs[i].fStartX, intRoiOrgY + m_arrExtraBlobs[i].fEndY);
                            System.Drawing.PointF p4 = new System.Drawing.PointF(intRoiOrgX + m_arrExtraBlobs[i].fEndX, intRoiOrgY + m_arrExtraBlobs[i].fEndY);

                            if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                            {
                                p1.X = p1.X * fDrawingScaleX;
                                p1.Y = p1.Y * fDrawingScaleY;
                                p2.X = p2.X * fDrawingScaleX;
                                p2.Y = p2.Y * fDrawingScaleY;
                                p3.X = p3.X * fDrawingScaleX;
                                p3.Y = p3.Y * fDrawingScaleY;
                                p4.X = p4.X * fDrawingScaleX;
                                p4.Y = p4.Y * fDrawingScaleY;
                            }

                            g.DrawLine(new Pen(Color.Yellow), p1, p2);
                            g.DrawLine(new Pen(Color.Yellow), p2, p4);
                            g.DrawLine(new Pen(Color.Yellow), p4, p3);
                            g.DrawLine(new Pen(Color.Yellow), p3, p1);
                            continue;
                        }
                        else
                        {
                            if (m_blnLock)
                                return;

                            System.Drawing.PointF p1 = new System.Drawing.PointF(intRoiOrgX + m_arrExtraBlobs[i].fStartX, intRoiOrgY + m_arrExtraBlobs[i].fStartY);
                            System.Drawing.PointF p2 = new System.Drawing.PointF(intRoiOrgX + m_arrExtraBlobs[i].fEndX, intRoiOrgY + m_arrExtraBlobs[i].fStartY);
                            System.Drawing.PointF p3 = new System.Drawing.PointF(intRoiOrgX + m_arrExtraBlobs[i].fStartX, intRoiOrgY + m_arrExtraBlobs[i].fEndY);
                            System.Drawing.PointF p4 = new System.Drawing.PointF(intRoiOrgX + m_arrExtraBlobs[i].fEndX, intRoiOrgY + m_arrExtraBlobs[i].fEndY);

                            if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                            {
                                p1.X = p1.X * fDrawingScaleX;
                                p1.Y = p1.Y * fDrawingScaleY;
                                p2.X = p2.X * fDrawingScaleX;
                                p2.Y = p2.Y * fDrawingScaleY;
                                p3.X = p3.X * fDrawingScaleX;
                                p3.Y = p3.Y * fDrawingScaleY;
                                p4.X = p4.X * fDrawingScaleX;
                                p4.Y = p4.Y * fDrawingScaleY;
                            }
                            if (m_arrExtraBlobs[i].ref_intFailCriteria > 0)
                            {
                                if (!blnFail)
                                    blnFail = true;
                                g.DrawLine(redPen, p1, p2);
                                g.DrawLine(redPen, p2, p4);
                                g.DrawLine(redPen, p4, p3);
                                g.DrawLine(redPen, p3, p1);
                                g.DrawLine(redPen, p1, p4);
                            }
                            else
                            {
                                g.DrawLine(limePen, p1, p2);
                                g.DrawLine(limePen, p2, p4);
                                g.DrawLine(limePen, p4, p3);
                                g.DrawLine(limePen, p3, p1);
                                //g.DrawLine(limePen, p1, p4);
                            }
                        }
                    }

                    for (int i = 0; i < m_arrSampleBlobLeads.Length; i++)
                    {
                        if (m_blnLock)
                            return;

                        m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                        /*if (i == intLeadSelectingNumber)
                        {
                            m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                            System.Drawing.Point p1 = new System.Drawing.Point(intRoiOrgX + m_stcBlobLead.intStartX, intRoiOrgY + m_stcBlobLead.intStartY);
                            System.Drawing.Point p2 = new System.Drawing.Point(intRoiOrgX + m_stcBlobLead.intEndX, intRoiOrgY + m_stcBlobLead.intStartY);
                            System.Drawing.Point p3 = new System.Drawing.Point(intRoiOrgX + m_stcBlobLead.intStartX, intRoiOrgY + m_stcBlobLead.intEndY);
                            System.Drawing.Point p4 = new System.Drawing.Point(intRoiOrgX + m_stcBlobLead.intEndX, intRoiOrgY + m_stcBlobLead.intEndY);
                            g.DrawLine(new Pen(Color.Lime), p1, p2);
                            g.DrawLine(new Pen(Color.Lime), p2, p4);
                            g.DrawLine(new Pen(Color.Lime), p4, p3);
                            g.DrawLine(new Pen(Color.Lime), p3, p1);
                            g.DrawString(m_stcBlobLead.intNoID.ToString(), m_Font, new SolidBrush(Color.Red), (float)(m_stcBlobLead.fCenterX + intRoiOrgX - 8), (float)(m_stcBlobLead.fCenterY + intRoiOrgY - 8));
                            continue;
                        }*/

                        //Missing Lead
                        if (m_arrSampleBlobLeads[i].intFailMask == 0x04)
                        {
                            if (!blnFail)
                                blnFail = true;
                            m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                            System.Drawing.PointF p1 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.intStartX, intRoiOrgY + m_stcBlobLead.intStartY);
                            System.Drawing.PointF p2 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.intEndX, intRoiOrgY + m_stcBlobLead.intStartY);
                            System.Drawing.PointF p3 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.intStartX, intRoiOrgY + m_stcBlobLead.intEndY);
                            System.Drawing.PointF p4 = new System.Drawing.PointF(intRoiOrgX + m_stcBlobLead.intEndX, intRoiOrgY + m_stcBlobLead.intEndY);
                            if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                            {
                                p1.X = p1.X * fDrawingScaleX;
                                p1.Y = p1.Y * fDrawingScaleY;
                                p2.X = p2.X * fDrawingScaleX;
                                p2.Y = p2.Y * fDrawingScaleY;
                                p3.X = p3.X * fDrawingScaleX;
                                p3.Y = p3.Y * fDrawingScaleY;
                                p4.X = p4.X * fDrawingScaleX;
                                p4.Y = p4.Y * fDrawingScaleY;
                            }

                            g.DrawLine(redPen, p1, p2);
                            g.DrawLine(redPen, p2, p4);
                            g.DrawLine(redPen, p4, p3);
                            g.DrawLine(redPen, p3, p1);
                            g.DrawLine(redPen, p1, p4);

                            switch (intLeadPosition)
                            {
                                case 1:
                                    //g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                                    //        ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterX + intRoiOrgX) * fDrawingScaleX,
                                    //        ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterY + intRoiOrgY - 40) * fDrawingScaleY);
                                    g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                             ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterX + intRoiOrgX - 8) * fDrawingScaleX,
                             ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fStartY + intRoiOrgY - m_stcBlobLead.intTipInwardOffset - m_Font.Height - 5) * fDrawingScaleY);
                                    break;
                                case 2:
                                    //g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                                    //        ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterX + intRoiOrgX + 27) * fDrawingScaleX,
                                    //        ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterY + intRoiOrgY - 8) * fDrawingScaleY);
                                    g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                              ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fEndX + intRoiOrgX + 5) * fDrawingScaleX,
                              ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterY + intRoiOrgY - 8) * fDrawingScaleY);
                                    break;
                                case 3:
                                    //g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                                    //        ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterX + intRoiOrgX) * fDrawingScaleX,
                                    //        ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterY + intRoiOrgY + 27) * fDrawingScaleY);
                                    g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                              ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterX + intRoiOrgX - 8) * fDrawingScaleX,
                              ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fEndY + intRoiOrgY + 5) * fDrawingScaleY);
                                    break;
                                case 4:
                                    //g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                                    //        ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterX + intRoiOrgX - 40) * fDrawingScaleX,
                                    //        ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterY + intRoiOrgY - 8) * fDrawingScaleY);
                                    g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fStartX - m_stcBlobLead.intTipInwardOffset + intRoiOrgX - (((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString().Length * m_Font.Size) - 5) * fDrawingScaleX,
                                ((float)((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterY + intRoiOrgY - 8) * fDrawingScaleY);
                                    break;
                            }
                        }
                        //Valid Lead
                        else if (m_arrSampleBlobLeads[i].intFailMask == 0)
                        {
                            System.Drawing.PointF p1 = new PointF();
                            System.Drawing.PointF p2 = new PointF();
                            System.Drawing.PointF p3 = new PointF();
                            System.Drawing.PointF p4 = new PointF();
                            System.Drawing.PointF p5 = new PointF();
                            System.Drawing.PointF p6 = new PointF();

                            if ((intLeadSelectingNumber == -1) || (i == intLeadSelectingNumber))
                            {

                                switch (intLeadPosition)
                                {
                                    case 1:
                                        p1 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX - m_arrSampleBlobLeads[i].fTipWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY + m_stcBlobLead.intTipInwardOffset);
                                        p2 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX + m_arrSampleBlobLeads[i].fTipWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY + m_stcBlobLead.intTipInwardOffset);
                                        p3 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX - m_arrSampleBlobLeads[i].fBaseWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY - m_stcBlobLead.intBaseInwardOffset);
                                        p4 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX + m_arrSampleBlobLeads[i].fBaseWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY - m_stcBlobLead.intBaseInwardOffset);
                                        p5 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY);
                                        p6 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY);
                                        break;
                                    case 2:
                                        p1 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX + m_stcBlobLead.intBaseInwardOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY - (m_arrSampleBlobLeads[i].fBaseWidth / 2));
                                        p2 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX - m_stcBlobLead.intTipInwardOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY - (m_arrSampleBlobLeads[i].fTipWidth / 2));
                                        p3 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX + m_stcBlobLead.intBaseInwardOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY + (m_arrSampleBlobLeads[i].fBaseWidth / 2));
                                        p4 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX - m_stcBlobLead.intTipInwardOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY + (m_arrSampleBlobLeads[i].fTipWidth / 2));
                                        p5 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY);
                                        p6 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY);
                                        break;
                                    case 3:
                                        p1 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX - m_arrSampleBlobLeads[i].fBaseWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY + m_stcBlobLead.intBaseInwardOffset);
                                        p2 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX + m_arrSampleBlobLeads[i].fBaseWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY + m_stcBlobLead.intBaseInwardOffset);
                                        p3 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX - m_arrSampleBlobLeads[i].fTipWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY - m_stcBlobLead.intTipInwardOffset);
                                        p4 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX + m_arrSampleBlobLeads[i].fTipWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY - m_stcBlobLead.intTipInwardOffset);
                                        p5 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY);
                                        p6 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY);
                                        break;
                                    case 4:
                                        p1 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX + m_stcBlobLead.intTipInwardOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY - (m_arrSampleBlobLeads[i].fTipWidth / 2));
                                        p2 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX - m_stcBlobLead.intBaseInwardOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY - (m_arrSampleBlobLeads[i].fBaseWidth / 2));
                                        p3 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX + m_stcBlobLead.intTipInwardOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY + (m_arrSampleBlobLeads[i].fTipWidth / 2));
                                        p4 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX - m_stcBlobLead.intBaseInwardOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY + (m_arrSampleBlobLeads[i].fBaseWidth / 2));
                                        p5 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY);
                                        p6 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY);
                                        break;
                                }

                                if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                                {
                                    p1.X = p1.X * fDrawingScaleX;
                                    p1.Y = p1.Y * fDrawingScaleY;
                                    p2.X = p2.X * fDrawingScaleX;
                                    p2.Y = p2.Y * fDrawingScaleY;
                                    p3.X = p3.X * fDrawingScaleX;
                                    p3.Y = p3.Y * fDrawingScaleY;
                                    p4.X = p4.X * fDrawingScaleX;
                                    p4.Y = p4.Y * fDrawingScaleY;
                                    p5.X = p5.X * fDrawingScaleX;
                                    p5.Y = p5.Y * fDrawingScaleY;
                                    p6.X = p6.X * fDrawingScaleX;
                                    p6.Y = p6.Y * fDrawingScaleY;
                                }

                                //g.DrawLine(new Pen(Color.Lime, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                                //g.DrawLine(new Pen(Color.Lime, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);

                                //g.DrawLine(new Pen(Color.Lime, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                                //g.DrawLine(new Pen(Color.Lime, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);

                                //g.DrawLine(new Pen(Color.Lime, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                                //g.DrawLine(new Pen(Color.Lime, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);

                                //g.DrawLine(new Pen(Color.Lime, 2), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                                //g.DrawLine(new Pen(Color.Lime, 2), p4.X - 3, p4.Y, p4.X + 3, p4.Y);

                                //g.DrawLine(new Pen(Color.Lime, 2), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                                //g.DrawLine(new Pen(Color.Lime, 2), p5.X - 3, p5.Y, p5.X + 3, p5.Y);

                                //g.DrawLine(new Pen(Color.Lime, 2), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                                //g.DrawLine(new Pen(Color.Lime, 2), p6.X - 3, p6.Y, p6.X + 3, p6.Y);

                                if (m_arrSampleBlobLeads[i].blnTipStartFound)
                                {
                                    switch (intLeadPosition)
                                    {
                                        case 1:
                                            g.DrawLine(new Pen(Color.Lime, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                                            g.DrawLine(new Pen(Color.Lime, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                                            break;
                                        case 2:
                                            g.DrawLine(new Pen(Color.Lime, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                                            g.DrawLine(new Pen(Color.Lime, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                                            break;
                                        case 3:
                                            g.DrawLine(new Pen(Color.Lime, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                                            g.DrawLine(new Pen(Color.Lime, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                                            break;
                                        case 4:
                                            g.DrawLine(new Pen(Color.Lime, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                                            g.DrawLine(new Pen(Color.Lime, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                                            break;
                                    }
                                }
                                else
                                {
                                    switch (intLeadPosition)
                                    {
                                        case 1:
                                            g.DrawLine(new Pen(Color.Red, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                                            g.DrawLine(new Pen(Color.Red, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                                            break;
                                        case 2:
                                            g.DrawLine(new Pen(Color.Red, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                                            g.DrawLine(new Pen(Color.Red, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                                            break;
                                        case 3:
                                            g.DrawLine(new Pen(Color.Red, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                                            g.DrawLine(new Pen(Color.Red, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                                            break;
                                        case 4:
                                            g.DrawLine(new Pen(Color.Red, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                                            g.DrawLine(new Pen(Color.Red, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                                            break;
                                    }
                                }

                                if (m_arrSampleBlobLeads[i].blnTipCenterFound)
                                {
                                    switch (intLeadPosition)
                                    {
                                        case 1:
                                            g.DrawLine(new Pen(Color.Lime, 2), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                                            g.DrawLine(new Pen(Color.Lime, 2), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                                            break;
                                        case 2:
                                            g.DrawLine(new Pen(Color.Lime, 2), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                                            g.DrawLine(new Pen(Color.Lime, 2), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                                            break;
                                        case 3:
                                            g.DrawLine(new Pen(Color.Lime, 2), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                                            g.DrawLine(new Pen(Color.Lime, 2), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                                            break;
                                        case 4:
                                            g.DrawLine(new Pen(Color.Lime, 2), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                                            g.DrawLine(new Pen(Color.Lime, 2), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                                            break;
                                    }
                                }
                                else
                                {
                                    switch (intLeadPosition)
                                    {
                                        case 1:
                                            g.DrawLine(new Pen(Color.Red, 2), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                                            g.DrawLine(new Pen(Color.Red, 2), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                                            break;
                                        case 2:
                                            g.DrawLine(new Pen(Color.Red, 2), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                                            g.DrawLine(new Pen(Color.Red, 2), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                                            break;
                                        case 3:
                                            g.DrawLine(new Pen(Color.Red, 2), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                                            g.DrawLine(new Pen(Color.Red, 2), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                                            break;
                                        case 4:
                                            g.DrawLine(new Pen(Color.Red, 2), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                                            g.DrawLine(new Pen(Color.Red, 2), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                                            break;
                                    }
                                }

                                if (m_arrSampleBlobLeads[i].blnTipEndFound)
                                {
                                    switch (intLeadPosition)
                                    {
                                        case 1:
                                            g.DrawLine(new Pen(Color.Lime, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                                            g.DrawLine(new Pen(Color.Lime, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                                            break;
                                        case 2:
                                            g.DrawLine(new Pen(Color.Lime, 2), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                                            g.DrawLine(new Pen(Color.Lime, 2), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                                            break;
                                        case 3:
                                            g.DrawLine(new Pen(Color.Lime, 2), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                                            g.DrawLine(new Pen(Color.Lime, 2), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                                            break;
                                        case 4:
                                            g.DrawLine(new Pen(Color.Lime, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                                            g.DrawLine(new Pen(Color.Lime, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                                            break;
                                    }
                                }
                                else
                                {
                                    switch (intLeadPosition)
                                    {
                                        case 1:
                                            g.DrawLine(new Pen(Color.Red, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                                            g.DrawLine(new Pen(Color.Red, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                                            break;
                                        case 2:
                                            g.DrawLine(new Pen(Color.Red, 2), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                                            g.DrawLine(new Pen(Color.Red, 2), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                                            break;
                                        case 3:
                                            g.DrawLine(new Pen(Color.Red, 2), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                                            g.DrawLine(new Pen(Color.Red, 2), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                                            break;
                                        case 4:
                                            g.DrawLine(new Pen(Color.Red, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                                            g.DrawLine(new Pen(Color.Red, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                                            break;
                                    }
                                }

                                if (m_arrSampleBlobLeads[i].blnBaseStartFound)
                                {
                                    switch (intLeadPosition)
                                    {
                                        case 1:
                                            g.DrawLine(new Pen(Color.Lime, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                                            g.DrawLine(new Pen(Color.Lime, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                                            break;
                                        case 2:
                                            g.DrawLine(new Pen(Color.Lime, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                                            g.DrawLine(new Pen(Color.Lime, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                                            break;
                                        case 3:
                                            g.DrawLine(new Pen(Color.Lime, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                                            g.DrawLine(new Pen(Color.Lime, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                                            break;
                                        case 4:
                                            g.DrawLine(new Pen(Color.Lime, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                                            g.DrawLine(new Pen(Color.Lime, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                                            break;
                                    }
                                }
                                else
                                {
                                    if (!m_arrSampleBlobLeads[i].blnBaseEndFound)
                                    {
                                        switch (intLeadPosition)
                                        {
                                            case 1:
                                                g.DrawLine(new Pen(Color.Red, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                                                g.DrawLine(new Pen(Color.Red, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                                                break;
                                            case 2:
                                                g.DrawLine(new Pen(Color.Red, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                                                g.DrawLine(new Pen(Color.Red, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                                                break;
                                            case 3:
                                                g.DrawLine(new Pen(Color.Red, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                                                g.DrawLine(new Pen(Color.Red, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                                                break;
                                            case 4:
                                                g.DrawLine(new Pen(Color.Red, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                                                g.DrawLine(new Pen(Color.Red, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                                                break;
                                        }
                                    }
                                }

                                //if (m_arrSampleBlobLeads[i].blnBaseCenterFound)
                                //{
                                    switch (intLeadPosition)
                                    {
                                        case 1:
                                            g.DrawLine(new Pen(Color.Lime, 1), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                                            g.DrawLine(new Pen(Color.Lime, 1), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                                            break;
                                        case 2:
                                            g.DrawLine(new Pen(Color.Lime, 1), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                                            g.DrawLine(new Pen(Color.Lime, 1), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                                            break;
                                        case 3:
                                            g.DrawLine(new Pen(Color.Lime, 1), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                                            g.DrawLine(new Pen(Color.Lime, 1), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                                            break;
                                        case 4:
                                            g.DrawLine(new Pen(Color.Lime, 1), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                                            g.DrawLine(new Pen(Color.Lime, 1), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                                            break;
                                    }
                                //}
                                //else
                                //{
                                //    switch (intLeadPosition)
                                //    {
                                //        case 1:
                                //            g.DrawLine(new Pen(Color.Red, 1), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                                //            g.DrawLine(new Pen(Color.Red, 1), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                                //            break;
                                //        case 2:
                                //            g.DrawLine(new Pen(Color.Red, 1), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                                //            g.DrawLine(new Pen(Color.Red, 1), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                                //            break;
                                //        case 3:
                                //            g.DrawLine(new Pen(Color.Red, 1), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                                //            g.DrawLine(new Pen(Color.Red, 1), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                                //            break;
                                //        case 4:
                                //            g.DrawLine(new Pen(Color.Red, 1), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                                //            g.DrawLine(new Pen(Color.Red, 1), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                                //            break;
                                //    }
                                //}

                                if (m_arrSampleBlobLeads[i].blnBaseEndFound)
                                {
                                    switch (intLeadPosition)
                                    {
                                        case 1:
                                            g.DrawLine(new Pen(Color.Lime, 1), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                                            g.DrawLine(new Pen(Color.Lime, 1), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                                            break;
                                        case 2:
                                            g.DrawLine(new Pen(Color.Lime, 1), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                                            g.DrawLine(new Pen(Color.Lime, 1), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                                            break;
                                        case 3:
                                            g.DrawLine(new Pen(Color.Lime, 1), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                                            g.DrawLine(new Pen(Color.Lime, 1), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                                            break;
                                        case 4:
                                            g.DrawLine(new Pen(Color.Lime, 1), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                                            g.DrawLine(new Pen(Color.Lime, 1), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                                            break;
                                    }
                                }
                                else
                                {
                                    if (!m_arrSampleBlobLeads[i].blnBaseStartFound)
                                    {
                                        switch (intLeadPosition)
                                        {
                                            case 1:
                                                g.DrawLine(new Pen(Color.Red, 1), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                                                g.DrawLine(new Pen(Color.Red, 1), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                                                break;
                                            case 2:
                                                g.DrawLine(new Pen(Color.Red, 1), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                                                g.DrawLine(new Pen(Color.Red, 1), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                                                break;
                                            case 3:
                                                g.DrawLine(new Pen(Color.Red, 1), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                                                g.DrawLine(new Pen(Color.Red, 1), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                                                break;
                                            case 4:
                                                g.DrawLine(new Pen(Color.Red, 1), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                                                g.DrawLine(new Pen(Color.Red, 1), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                                                break;
                                        }
                                    }
                                }

                                g.DrawLine(new Pen(Color.Blue, 1), p5.X, p5.Y, p6.X, p6.Y);
                            }
                            else
                            {

                                if (intLeadPosition == 0 || intLeadPosition == 2) //For top and bottom ROI
                                {
                                    g.DrawLine(redPen, p1.X - 2, p1.Y + 2, p1.X + 2, p1.Y + 6);
                                    g.DrawLine(redPen, p1.X - 2, p1.Y + 6, p1.X + 2, p1.Y + 2);

                                    g.DrawLine(redPen, p2.X - 2, p2.Y + 2, p2.X + 2, p2.Y + 6);
                                    g.DrawLine(redPen, p2.X - 2, p2.Y + 6, p2.X + 2, p2.Y + 2);

                                    g.DrawLine(redPen, p3.X - 2, p3.Y - 2, p3.X + 2, p3.Y - 6);
                                    g.DrawLine(redPen, p3.X - 2, p3.Y - 6, p3.X + 2, p3.Y - 2);

                                    g.DrawLine(redPen, p4.X - 2, p4.Y - 2, p4.X + 2, p4.Y - 6);
                                    g.DrawLine(redPen, p4.X - 2, p4.Y - 6, p4.X + 2, p4.Y - 2);

                                    if (intLeadPosition == 0)
                                    {
                                        if (i == 0)
                                        {
                                            g.DrawLine(bluePen, p3.X - 2, p3.Y - 2, p3.X + 2, p3.Y + 2);
                                            g.DrawLine(bluePen, p3.X - 2, p3.Y + 2, p3.X + 2, p3.Y - 2);
                                        }
                                        if (i == m_arrTemplateBlobLeads.Count - 1)
                                        {
                                            g.DrawLine(bluePen, p4.X - 2, p4.Y - 2, p4.X + 2, p4.Y + 2);
                                            g.DrawLine(bluePen, p4.X - 2, p4.Y + 2, p4.X + 2, p4.Y - 2);
                                        }
                                    }
                                    else if (intLeadPosition == 2)
                                    {
                                        if (i == 0)
                                        {
                                            g.DrawLine(bluePen, p1.X - 2, p1.Y - 2, p1.X + 2, p1.Y + 2);
                                            g.DrawLine(bluePen, p1.X - 2, p1.Y + 2, p1.X + 2, p1.Y - 2);
                                        }

                                        if (i == m_arrTemplateBlobLeads.Count - 1)
                                        {
                                            g.DrawLine(bluePen, p2.X - 2, p2.Y - 2, p2.X + 2, p2.Y + 2);
                                            g.DrawLine(bluePen, p2.X - 2, p2.Y + 2, p2.X + 2, p2.Y - 2);
                                        }
                                    }
                                }
                                else //For left and right ROI
                                {
                                    g.DrawLine(redPen, p1.X + 2, p1.Y - 2, p1.X + 6, p1.Y + 2);
                                    g.DrawLine(redPen, p1.X + 6, p1.Y - 2, p1.X + 2, p1.Y + 2);

                                    g.DrawLine(redPen, p2.X - 2, p2.Y - 2, p2.X - 6, p2.Y + 2);
                                    g.DrawLine(redPen, p2.X - 6, p2.Y - 2, p2.X - 2, p2.Y + 2);

                                    g.DrawLine(redPen, p3.X + 2, p3.Y + 2, p3.X + 6, p3.Y - 2);
                                    g.DrawLine(redPen, p3.X + 6, p3.Y + 2, p3.X + 2, p3.Y - 2);

                                    g.DrawLine(redPen, p4.X - 2, p4.Y + 2, p4.X - 6, p4.Y - 2);
                                    g.DrawLine(redPen, p4.X - 6, p4.Y + 2, p4.X - 2, p4.Y - 2);

                                    if (intLeadPosition == 1)
                                    {
                                        if (i == 0)
                                        {
                                            g.DrawLine(bluePen, p1.X - 2, p1.Y - 2, p1.X + 2, p1.Y + 2);
                                            g.DrawLine(bluePen, p1.X - 2, p1.Y + 2, p1.X + 2, p1.Y - 2);
                                        }
                                        if (i == m_arrTemplateBlobLeads.Count - 1)
                                        {
                                            g.DrawLine(bluePen, p3.X - 2, p3.Y - 2, p3.X + 2, p3.Y + 2);
                                            g.DrawLine(bluePen, p3.X - 2, p3.Y + 2, p3.X + 2, p3.Y - 2);
                                        }
                                    }
                                    else if (intLeadPosition == 3)
                                    {
                                        if (i == 0)
                                        {
                                            g.DrawLine(bluePen, p2.X - 2, p2.Y - 2, p2.X + 2, p2.Y + 2);
                                            g.DrawLine(bluePen, p2.X - 2, p2.Y + 2, p2.X + 2, p2.Y - 2);
                                        }

                                        if (i == m_arrTemplateBlobLeads.Count - 1)
                                        {
                                            g.DrawLine(bluePen, p4.X - 2, p4.Y - 2, p4.X + 2, p4.Y + 2);
                                            g.DrawLine(bluePen, p4.X - 2, p4.Y + 2, p4.X + 2, p4.Y - 2);
                                        }
                                    }
                                }
                            }

                            System.Drawing.PointF pR1 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fStartX, intRoiOrgY + m_arrSampleBlobLeads[i].fStartY);
                            System.Drawing.PointF pR2 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fEndX, intRoiOrgY + m_arrSampleBlobLeads[i].fStartY);
                            System.Drawing.PointF pR3 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fStartX, intRoiOrgY + m_arrSampleBlobLeads[i].fEndY);

                            switch (intLeadPosition)
                            {
                                case 1:
                                    pR1 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX - m_arrSampleBlobLeads[i].fTipWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY + m_stcBlobLead.intTipInwardOffset);
                                    pR2 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY);
                                    pR3 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX + m_arrSampleBlobLeads[i].fTipWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY + m_stcBlobLead.intTipInwardOffset);
                                    break;
                                case 2:
                                    pR1 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX - m_stcBlobLead.intTipInwardOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY - (m_arrSampleBlobLeads[i].fTipWidth / 2));
                                    pR2 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY);
                                    pR3 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX - m_stcBlobLead.intTipInwardOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY + (m_arrSampleBlobLeads[i].fTipWidth / 2));
                                    break;
                                case 3:
                                    pR1 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX - m_arrSampleBlobLeads[i].fTipWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY - m_stcBlobLead.intTipInwardOffset);
                                    pR2 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY);
                                    pR3 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX + m_arrSampleBlobLeads[i].fTipWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY - m_stcBlobLead.intTipInwardOffset);
                                    break;
                                case 4:
                                    pR1 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX + m_stcBlobLead.intTipInwardOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY - (m_arrSampleBlobLeads[i].fTipWidth / 2));
                                    pR2 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY);
                                    pR3 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX + m_stcBlobLead.intTipInwardOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY + (m_arrSampleBlobLeads[i].fTipWidth / 2));
                                    break;
                            }

                            if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                            {
                                pR1.X = pR1.X * fDrawingScaleX;
                                pR1.Y = pR1.Y * fDrawingScaleY;
                                pR2.X = pR2.X * fDrawingScaleX;
                                pR2.Y = pR2.Y * fDrawingScaleY;
                                pR3.X = pR3.X * fDrawingScaleX;
                                pR3.Y = pR3.Y * fDrawingScaleY;
                            }

                            switch (intLeadPosition)
                            {
                                case 1: // Top

                                    g.DrawRectangle(new Pen(Color.Lime, 1), pR1.X - 5, pR2.Y - 5, pR3.X - p1.X + 10, Math.Max(pR1.Y, pR3.Y) - pR2.Y + 10);

                                    break;
                                case 2: // Right

                                    g.DrawRectangle(new Pen(Color.Lime, 1), Math.Min(pR3.X, pR1.X) - 5, pR1.Y - 5, pR2.X - Math.Min(pR3.X, pR1.X) + 10, pR3.Y - pR1.Y + 10);

                                    break;
                                case 3: // Bottom

                                    g.DrawRectangle(new Pen(Color.Lime, 1), pR1.X - 5, Math.Min(pR1.Y, pR3.Y) - 5, pR3.X - pR1.X + 10, pR2.Y - Math.Min(pR1.Y, pR3.Y) + 10);

                                    break;
                                case 4: // Left

                                    g.DrawRectangle(new Pen(Color.Lime, 1), pR2.X - 5, pR1.Y - 5, Math.Max(pR3.X, pR1.X) - pR2.X + 10, pR3.Y - pR1.Y + 10);

                                    break;
                            }

                            switch (intLeadPosition)
                            {
                                case 1:
                                    //g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                                    //        (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterX + intRoiOrgX) * fDrawingScaleX,
                                    //        (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterY + intRoiOrgY - 40) * fDrawingScaleY);
                                    g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Lime),
                                 ((float)((SampleBlobsFeatures)m_arrSampleBlobLeads[i]).fCenterX + intRoiOrgX - 8) * fDrawingScaleX,
                                 ((float)((SampleBlobsFeatures)m_arrSampleBlobLeads[i]).fStartY + intRoiOrgY - m_stcBlobLead.intTipInwardOffset - m_Font.Height - 5) * fDrawingScaleY);
                                    break;
                                case 2:
                                    //g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                                    //        (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterX + intRoiOrgX + 27) * fDrawingScaleX,
                                    //        (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterY + intRoiOrgY - 8) * fDrawingScaleY);
                                    g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Lime),
                            ((float)((SampleBlobsFeatures)m_arrSampleBlobLeads[i]).fEndX + intRoiOrgX + 5) * fDrawingScaleX,
                            ((float)((SampleBlobsFeatures)m_arrSampleBlobLeads[i]).fCenterY + intRoiOrgY - 8) * fDrawingScaleY);
                                    break;
                                case 3:
                                    //g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                                    //        (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterX + intRoiOrgX) * fDrawingScaleX,
                                    //        (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterY + intRoiOrgY + 27) * fDrawingScaleY);
                                    g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Lime),
                            ((float)((SampleBlobsFeatures)m_arrSampleBlobLeads[i]).fCenterX + intRoiOrgX - 8) * fDrawingScaleX,
                            ((float)((SampleBlobsFeatures)m_arrSampleBlobLeads[i]).fEndY + intRoiOrgY + 5) * fDrawingScaleY);
                                    break;
                                case 4:
                                    //g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                                    //        (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterX + intRoiOrgX - 40) * fDrawingScaleX,
                                    //        (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterY + intRoiOrgY - 8) * fDrawingScaleY);
                                    g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Lime),
                                ((float)((SampleBlobsFeatures)m_arrSampleBlobLeads[i]).fStartX - m_stcBlobLead.intTipInwardOffset + intRoiOrgX - (((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString().Length * m_Font.Size) - 5) * fDrawingScaleX,
                                ((float)((SampleBlobsFeatures)m_arrSampleBlobLeads[i]).fCenterY + intRoiOrgY - 8) * fDrawingScaleY);
                                    break;
                            }

                            //Draw reference point here
                            if (m_fSampleReferencePointEndX != 0 && m_fSampleReferencePointEndY != 0)
                            {
                                System.Drawing.PointF pRefPoint1 = new PointF();
                                System.Drawing.PointF pRefPoint2 = new PointF();
                                pRefPoint1 = new System.Drawing.PointF(intRoiOrgX + m_fSampleReferencePointStartX, intRoiOrgY + m_fSampleReferencePointStartY);
                                pRefPoint2 = new System.Drawing.PointF(intRoiOrgX + m_fSampleReferencePointEndX, intRoiOrgY + m_fSampleReferencePointEndY);

                                if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                                {
                                    pRefPoint1.X = pRefPoint1.X * fDrawingScaleX;
                                    pRefPoint1.Y = pRefPoint1.Y * fDrawingScaleY;
                                    pRefPoint2.X = pRefPoint2.X * fDrawingScaleX;
                                    pRefPoint2.Y = pRefPoint2.Y * fDrawingScaleY;
                                }

                                g.DrawLine(new Pen(Color.Cyan, 1), pRefPoint1.X, pRefPoint1.Y - 3, pRefPoint1.X, pRefPoint1.Y + 3);
                                g.DrawLine(new Pen(Color.Cyan, 1), pRefPoint1.X - 3, pRefPoint1.Y, pRefPoint1.X + 3, pRefPoint1.Y);

                                g.DrawLine(new Pen(Color.Cyan, 1), pRefPoint2.X, pRefPoint2.Y - 3, pRefPoint2.X, pRefPoint2.Y + 3);
                                g.DrawLine(new Pen(Color.Cyan, 1), pRefPoint2.X - 3, pRefPoint2.Y, pRefPoint2.X + 3, pRefPoint2.Y);

                                g.DrawLine(new Pen(Color.Cyan, 1), pRefPoint1.X, pRefPoint1.Y, pRefPoint2.X, pRefPoint2.Y);
                            }
                        }
                        else
                        {
                            System.Drawing.PointF p1 = new PointF();
                            System.Drawing.PointF p2 = new PointF();
                            System.Drawing.PointF p3 = new PointF();
                            System.Drawing.PointF p4 = new PointF();
                            System.Drawing.PointF p5 = new PointF();
                            System.Drawing.PointF p6 = new PointF();

                            switch (intLeadPosition)
                            {
                                case 1:
                                    p1 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX - m_arrSampleBlobLeads[i].fTipWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY + m_stcBlobLead.intTipInwardOffset);
                                    p2 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX + m_arrSampleBlobLeads[i].fTipWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY + m_stcBlobLead.intTipInwardOffset);
                                    p3 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX - m_arrSampleBlobLeads[i].fBaseWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY - m_stcBlobLead.intBaseInwardOffset);
                                    p4 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX + m_arrSampleBlobLeads[i].fBaseWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY - m_stcBlobLead.intBaseInwardOffset);
                                    p5 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY);
                                    p6 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY);
                                    break;
                                case 2:
                                    p1 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX + m_stcBlobLead.intBaseInwardOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY - (m_arrSampleBlobLeads[i].fBaseWidth / 2));
                                    p2 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX - m_stcBlobLead.intTipInwardOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY - (m_arrSampleBlobLeads[i].fTipWidth / 2));
                                    p3 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX + m_stcBlobLead.intBaseInwardOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY + (m_arrSampleBlobLeads[i].fBaseWidth / 2));
                                    p4 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX - m_stcBlobLead.intTipInwardOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY + (m_arrSampleBlobLeads[i].fTipWidth / 2));
                                    p5 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY);
                                    p6 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY);
                                    break;
                                case 3:
                                    p1 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX - m_arrSampleBlobLeads[i].fBaseWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY + m_stcBlobLead.intBaseInwardOffset);
                                    p2 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX + m_arrSampleBlobLeads[i].fBaseWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY + m_stcBlobLead.intBaseInwardOffset);
                                    p3 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX - m_arrSampleBlobLeads[i].fTipWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY - m_stcBlobLead.intTipInwardOffset);
                                    p4 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX + m_arrSampleBlobLeads[i].fTipWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY - m_stcBlobLead.intTipInwardOffset);
                                    p5 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY);
                                    p6 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY);
                                    break;
                                case 4:
                                    p1 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX + m_stcBlobLead.intTipInwardOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY - (m_arrSampleBlobLeads[i].fTipWidth / 2));
                                    p2 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX - m_stcBlobLead.intBaseInwardOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY - (m_arrSampleBlobLeads[i].fBaseWidth / 2));
                                    p3 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX + m_stcBlobLead.intTipInwardOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY + (m_arrSampleBlobLeads[i].fTipWidth / 2));
                                    p4 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX - m_stcBlobLead.intBaseInwardOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY + (m_arrSampleBlobLeads[i].fBaseWidth / 2));
                                    p5 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY);
                                    p6 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fBaseCenterX, intRoiOrgY + m_arrSampleBlobLeads[i].fBaseCenterY);
                                    break;
                            }

                            if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                            {
                                p1.X = p1.X * fDrawingScaleX;
                                p1.Y = p1.Y * fDrawingScaleY;
                                p2.X = p2.X * fDrawingScaleX;
                                p2.Y = p2.Y * fDrawingScaleY;
                                p3.X = p3.X * fDrawingScaleX;
                                p3.Y = p3.Y * fDrawingScaleY;
                                p4.X = p4.X * fDrawingScaleX;
                                p4.Y = p4.Y * fDrawingScaleY;
                                p5.X = p5.X * fDrawingScaleX;
                                p5.Y = p5.Y * fDrawingScaleY;
                                p6.X = p6.X * fDrawingScaleX;
                                p6.Y = p6.Y * fDrawingScaleY;
                            }

                            //g.DrawLine(new Pen(Color.Lime, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                            //g.DrawLine(new Pen(Color.Lime, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);

                            //g.DrawLine(new Pen(Color.Lime, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                            //g.DrawLine(new Pen(Color.Lime, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);

                            //g.DrawLine(new Pen(Color.Lime, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                            //g.DrawLine(new Pen(Color.Lime, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);

                            //g.DrawLine(new Pen(Color.Lime, 2), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                            //g.DrawLine(new Pen(Color.Lime, 2), p4.X - 3, p4.Y, p4.X + 3, p4.Y);

                            //g.DrawLine(new Pen(Color.Lime, 2), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                            //g.DrawLine(new Pen(Color.Lime, 2), p5.X - 3, p5.Y, p5.X + 3, p5.Y);

                            //g.DrawLine(new Pen(Color.Lime, 2), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                            //g.DrawLine(new Pen(Color.Lime, 2), p6.X - 3, p6.Y, p6.X + 3, p6.Y);

                            if (m_arrSampleBlobLeads[i].blnTipStartFound)
                            {
                                switch (intLeadPosition)
                                {
                                    case 1:
                                        g.DrawLine(new Pen(Color.Lime, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                                        g.DrawLine(new Pen(Color.Lime, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                                        break;
                                    case 2:
                                        g.DrawLine(new Pen(Color.Lime, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                                        g.DrawLine(new Pen(Color.Lime, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                                        break;
                                    case 3:
                                        g.DrawLine(new Pen(Color.Lime, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                                        g.DrawLine(new Pen(Color.Lime, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                                        break;
                                    case 4:
                                        g.DrawLine(new Pen(Color.Lime, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                                        g.DrawLine(new Pen(Color.Lime, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                                        break;
                                }
                            }
                            else
                            {
                                switch (intLeadPosition)
                                {
                                    case 1:
                                        g.DrawLine(new Pen(Color.Red, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                                        g.DrawLine(new Pen(Color.Red, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                                        break;
                                    case 2:
                                        g.DrawLine(new Pen(Color.Red, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                                        g.DrawLine(new Pen(Color.Red, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                                        break;
                                    case 3:
                                        g.DrawLine(new Pen(Color.Red, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                                        g.DrawLine(new Pen(Color.Red, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                                        break;
                                    case 4:
                                        g.DrawLine(new Pen(Color.Red, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                                        g.DrawLine(new Pen(Color.Red, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                                        break;
                                }
                            }

                            if (m_arrSampleBlobLeads[i].blnTipCenterFound)
                            {
                                switch (intLeadPosition)
                                {
                                    case 1:
                                        g.DrawLine(new Pen(Color.Lime, 2), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                                        g.DrawLine(new Pen(Color.Lime, 2), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                                        break;
                                    case 2:
                                        g.DrawLine(new Pen(Color.Lime, 2), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                                        g.DrawLine(new Pen(Color.Lime, 2), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                                        break;
                                    case 3:
                                        g.DrawLine(new Pen(Color.Lime, 2), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                                        g.DrawLine(new Pen(Color.Lime, 2), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                                        break;
                                    case 4:
                                        g.DrawLine(new Pen(Color.Lime, 2), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                                        g.DrawLine(new Pen(Color.Lime, 2), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                                        break;
                                }
                            }
                            else
                            {
                                switch (intLeadPosition)
                                {
                                    case 1:
                                        g.DrawLine(new Pen(Color.Red, 2), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                                        g.DrawLine(new Pen(Color.Red, 2), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                                        break;
                                    case 2:
                                        g.DrawLine(new Pen(Color.Red, 2), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                                        g.DrawLine(new Pen(Color.Red, 2), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                                        break;
                                    case 3:
                                        g.DrawLine(new Pen(Color.Red, 2), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                                        g.DrawLine(new Pen(Color.Red, 2), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                                        break;
                                    case 4:
                                        g.DrawLine(new Pen(Color.Red, 2), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                                        g.DrawLine(new Pen(Color.Red, 2), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                                        break;
                                }
                            }

                            if (m_arrSampleBlobLeads[i].blnTipEndFound)
                            {
                                switch (intLeadPosition)
                                {
                                    case 1:
                                        g.DrawLine(new Pen(Color.Lime, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                                        g.DrawLine(new Pen(Color.Lime, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                                        break;
                                    case 2:
                                        g.DrawLine(new Pen(Color.Lime, 2), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                                        g.DrawLine(new Pen(Color.Lime, 2), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                                        break;
                                    case 3:
                                        g.DrawLine(new Pen(Color.Lime, 2), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                                        g.DrawLine(new Pen(Color.Lime, 2), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                                        break;
                                    case 4:
                                        g.DrawLine(new Pen(Color.Lime, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                                        g.DrawLine(new Pen(Color.Lime, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                                        break;
                                }
                            }
                            else
                            {
                                switch (intLeadPosition)
                                {
                                    case 1:
                                        g.DrawLine(new Pen(Color.Red, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                                        g.DrawLine(new Pen(Color.Red, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                                        break;
                                    case 2:
                                        g.DrawLine(new Pen(Color.Red, 2), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                                        g.DrawLine(new Pen(Color.Red, 2), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                                        break;
                                    case 3:
                                        g.DrawLine(new Pen(Color.Red, 2), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                                        g.DrawLine(new Pen(Color.Red, 2), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                                        break;
                                    case 4:
                                        g.DrawLine(new Pen(Color.Red, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                                        g.DrawLine(new Pen(Color.Red, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                                        break;
                                }
                            }

                            if (m_arrSampleBlobLeads[i].blnBaseStartFound)
                            {
                                switch (intLeadPosition)
                                {
                                    case 1:
                                        g.DrawLine(new Pen(Color.Lime, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                                        g.DrawLine(new Pen(Color.Lime, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                                        break;
                                    case 2:
                                        g.DrawLine(new Pen(Color.Lime, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                                        g.DrawLine(new Pen(Color.Lime, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                                        break;
                                    case 3:
                                        g.DrawLine(new Pen(Color.Lime, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                                        g.DrawLine(new Pen(Color.Lime, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                                        break;
                                    case 4:
                                        g.DrawLine(new Pen(Color.Lime, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                                        g.DrawLine(new Pen(Color.Lime, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                                        break;
                                }
                            }
                            else
                            {
                                switch (intLeadPosition)
                                {
                                    case 1:
                                        g.DrawLine(new Pen(Color.Red, 2), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                                        g.DrawLine(new Pen(Color.Red, 2), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                                        break;
                                    case 2:
                                        g.DrawLine(new Pen(Color.Red, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                                        g.DrawLine(new Pen(Color.Red, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                                        break;
                                    case 3:
                                        g.DrawLine(new Pen(Color.Red, 2), p1.X, p1.Y - 3, p1.X, p1.Y + 3);
                                        g.DrawLine(new Pen(Color.Red, 2), p1.X - 3, p1.Y, p1.X + 3, p1.Y);
                                        break;
                                    case 4:
                                        g.DrawLine(new Pen(Color.Red, 2), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                                        g.DrawLine(new Pen(Color.Red, 2), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                                        break;
                                }
                            }

                            if (m_arrSampleBlobLeads[i].blnBaseCenterFound)
                            {
                                switch (intLeadPosition)
                                {
                                    case 1:
                                        g.DrawLine(new Pen(Color.Lime, 1), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                                        g.DrawLine(new Pen(Color.Lime, 1), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                                        break;
                                    case 2:
                                        g.DrawLine(new Pen(Color.Lime, 1), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                                        g.DrawLine(new Pen(Color.Lime, 1), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                                        break;
                                    case 3:
                                        g.DrawLine(new Pen(Color.Lime, 1), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                                        g.DrawLine(new Pen(Color.Lime, 1), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                                        break;
                                    case 4:
                                        g.DrawLine(new Pen(Color.Lime, 1), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                                        g.DrawLine(new Pen(Color.Lime, 1), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                                        break;
                                }
                            }
                            else
                            {
                                switch (intLeadPosition)
                                {
                                    case 1:
                                        g.DrawLine(new Pen(Color.Red, 1), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                                        g.DrawLine(new Pen(Color.Red, 1), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                                        break;
                                    case 2:
                                        g.DrawLine(new Pen(Color.Red, 1), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                                        g.DrawLine(new Pen(Color.Red, 1), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                                        break;
                                    case 3:
                                        g.DrawLine(new Pen(Color.Red, 1), p5.X, p5.Y - 3, p5.X, p5.Y + 3);
                                        g.DrawLine(new Pen(Color.Red, 1), p5.X - 3, p5.Y, p5.X + 3, p5.Y);
                                        break;
                                    case 4:
                                        g.DrawLine(new Pen(Color.Red, 1), p6.X, p6.Y - 3, p6.X, p6.Y + 3);
                                        g.DrawLine(new Pen(Color.Red, 1), p6.X - 3, p6.Y, p6.X + 3, p6.Y);
                                        break;
                                }
                            }

                            if (m_arrSampleBlobLeads[i].blnBaseEndFound)
                            {
                                switch (intLeadPosition)
                                {
                                    case 1:
                                        g.DrawLine(new Pen(Color.Lime, 1), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                                        g.DrawLine(new Pen(Color.Lime, 1), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                                        break;
                                    case 2:
                                        g.DrawLine(new Pen(Color.Lime, 1), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                                        g.DrawLine(new Pen(Color.Lime, 1), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                                        break;
                                    case 3:
                                        g.DrawLine(new Pen(Color.Lime, 1), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                                        g.DrawLine(new Pen(Color.Lime, 1), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                                        break;
                                    case 4:
                                        g.DrawLine(new Pen(Color.Lime, 1), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                                        g.DrawLine(new Pen(Color.Lime, 1), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                                        break;
                                }
                            }
                            else
                            {
                                switch (intLeadPosition)
                                {
                                    case 1:
                                        g.DrawLine(new Pen(Color.Red, 1), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                                        g.DrawLine(new Pen(Color.Red, 1), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                                        break;
                                    case 2:
                                        g.DrawLine(new Pen(Color.Red, 1), p3.X, p3.Y - 3, p3.X, p3.Y + 3);
                                        g.DrawLine(new Pen(Color.Red, 1), p3.X - 3, p3.Y, p3.X + 3, p3.Y);
                                        break;
                                    case 3:
                                        g.DrawLine(new Pen(Color.Red, 1), p2.X, p2.Y - 3, p2.X, p2.Y + 3);
                                        g.DrawLine(new Pen(Color.Red, 1), p2.X - 3, p2.Y, p2.X + 3, p2.Y);
                                        break;
                                    case 4:
                                        g.DrawLine(new Pen(Color.Red, 1), p4.X, p4.Y - 3, p4.X, p4.Y + 3);
                                        g.DrawLine(new Pen(Color.Red, 1), p4.X - 3, p4.Y, p4.X + 3, p4.Y);
                                        break;
                                }
                            }

                            g.DrawLine(new Pen(Color.Blue, 1), p5.X, p5.Y, p6.X, p6.Y);


                            System.Drawing.PointF pR1 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fStartX, intRoiOrgY + m_arrSampleBlobLeads[i].fStartY);
                            System.Drawing.PointF pR2 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fEndX, intRoiOrgY + m_arrSampleBlobLeads[i].fStartY);
                            System.Drawing.PointF pR3 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fStartX, intRoiOrgY + m_arrSampleBlobLeads[i].fEndY);

                            switch (intLeadPosition)
                            {
                                case 1:
                                    pR1 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX - m_arrSampleBlobLeads[i].fTipWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY + m_stcBlobLead.intTipInwardOffset);
                                    pR2 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY);
                                    pR3 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX + m_arrSampleBlobLeads[i].fTipWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY + m_stcBlobLead.intTipInwardOffset);
                                    break;
                                case 2:
                                    pR1 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX - m_stcBlobLead.intTipInwardOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY - (m_arrSampleBlobLeads[i].fTipWidth / 2));
                                    pR2 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY);
                                    pR3 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX - m_stcBlobLead.intTipInwardOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY + (m_arrSampleBlobLeads[i].fTipWidth / 2));
                                    break;
                                case 3:
                                    pR1 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX - m_arrSampleBlobLeads[i].fTipWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY - m_stcBlobLead.intTipInwardOffset);
                                    pR2 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY);
                                    pR3 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX + m_arrSampleBlobLeads[i].fTipWidth / 2, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY - m_stcBlobLead.intTipInwardOffset);
                                    break;
                                case 4:
                                    pR1 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX + m_stcBlobLead.intTipInwardOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY - (m_arrSampleBlobLeads[i].fTipWidth / 2));
                                    pR2 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY);
                                    pR3 = new System.Drawing.PointF(intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX + m_stcBlobLead.intTipInwardOffset, intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY + (m_arrSampleBlobLeads[i].fTipWidth / 2));
                                    break;
                            }

                            if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                            {
                                pR1.X = pR1.X * fDrawingScaleX;
                                pR1.Y = pR1.Y * fDrawingScaleY;
                                pR2.X = pR2.X * fDrawingScaleX;
                                pR2.Y = pR2.Y * fDrawingScaleY;
                                pR3.X = pR3.X * fDrawingScaleX;
                                pR3.Y = pR3.Y * fDrawingScaleY;
                            }

                            switch (intLeadPosition)
                            {
                                case 1: // Top

                                    g.DrawRectangle(new Pen(Color.Red, 1), pR1.X - 5, pR2.Y - 5, pR3.X - pR1.X + 10, Math.Max(pR1.Y, pR3.Y) - pR2.Y + 10);

                                    break;
                                case 2: // Right

                                    g.DrawRectangle(new Pen(Color.Red, 1), Math.Min(pR3.X, pR1.X) - 5, pR1.Y - 5, pR2.X - Math.Min(pR3.X, pR1.X) + 10, pR3.Y - pR1.Y + 10);

                                    break;
                                case 3: // Bottom

                                    g.DrawRectangle(new Pen(Color.Red, 1), pR1.X - 5, Math.Min(pR1.Y, pR3.Y) - 5, pR3.X - pR1.X + 10, pR2.Y - Math.Min(pR1.Y, pR3.Y) + 10);

                                    break;
                                case 4: // Left

                                    g.DrawRectangle(new Pen(Color.Red, 1), pR2.X - 5, pR1.Y - 5, Math.Max(pR3.X, pR1.X) - pR2.X + 10, pR3.Y - pR1.Y + 10);

                                    break;
                            }

                            //if (i == intLeadSelectingNumber)
                            //{
                            //    g.DrawLine(limePen, p1, p2);
                            //    g.DrawLine(limePen, p2, p4);
                            //    g.DrawLine(limePen, p4, p3);
                            //    g.DrawLine(limePen, p3, p1);
                            //    g.DrawLine(limePen, p1, p4);
                            //}
                            //else
                            //{
                            //    g.DrawLine(redPen, p1, p2);
                            //    g.DrawLine(redPen, p2, p4);
                            //    g.DrawLine(redPen, p4, p3);
                            //    g.DrawLine(redPen, p3, p1);
                            //    g.DrawLine(redPen, p1, p4);
                            //}

                            if (m_blnLock)
                                return;

                            switch (intLeadPosition)
                            {
                                case 1:
                                    //g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                                    //        (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterX + intRoiOrgX) * fDrawingScaleX,
                                    //        (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterY + intRoiOrgY - 40) * fDrawingScaleY);
                                    g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                               ((float)((SampleBlobsFeatures)m_arrSampleBlobLeads[i]).fCenterX + intRoiOrgX - 8) * fDrawingScaleX,
                               ((float)((SampleBlobsFeatures)m_arrSampleBlobLeads[i]).fStartY + intRoiOrgY - m_stcBlobLead.intTipInwardOffset - m_Font.Height - 5) * fDrawingScaleY);
                                    break;
                                case 2:
                                    //g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                                    //        (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterX + intRoiOrgX + 27) * fDrawingScaleX,
                                    //        (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterY + intRoiOrgY - 8) * fDrawingScaleY);
                                    g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                              ((float)((SampleBlobsFeatures)m_arrSampleBlobLeads[i]).fEndX + intRoiOrgX + 5) * fDrawingScaleX,
                              ((float)((SampleBlobsFeatures)m_arrSampleBlobLeads[i]).fCenterY + intRoiOrgY - 8) * fDrawingScaleY);
                                    break;
                                case 3:
                                    //g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                                    //        (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterX + intRoiOrgX) * fDrawingScaleX,
                                    //        (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterY + intRoiOrgY + 27) * fDrawingScaleY);
                                    g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                             ((float)((SampleBlobsFeatures)m_arrSampleBlobLeads[i]).fCenterX + intRoiOrgX - 8) * fDrawingScaleX,
                             ((float)((SampleBlobsFeatures)m_arrSampleBlobLeads[i]).fEndY + intRoiOrgY + 5) * fDrawingScaleY);
                                    break;
                                case 4:
                                    //g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                                    //        (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterX + intRoiOrgX - 40) * fDrawingScaleX,
                                    //        (((BlobsFeatures)m_arrTemplateBlobLeads[i]).fLimitCenterY + intRoiOrgY - 8) * fDrawingScaleY);
                                    g.DrawString(((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                               ((float)((SampleBlobsFeatures)m_arrSampleBlobLeads[i]).fStartX - m_stcBlobLead.intTipInwardOffset + intRoiOrgX - (((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID.ToString().Length * m_Font.Size) - 5) * fDrawingScaleX,
                               ((float)((SampleBlobsFeatures)m_arrSampleBlobLeads[i]).fCenterY + intRoiOrgY - 8) * fDrawingScaleY);
                                    break;
                            }

                        }

                        // Draw Average Gray Value ROI
                        if (m_blnWantUseAverageGrayValueMethod && (m_intFailOptionMask & 0x4000) > 0)
                        {
                            float fStartX = 0, fStartY = 0, fWidth = 0, fHeight = 0;
                            switch (m_intLeadROIDirection)
                            {
                                case 1: // Top
                                    fStartX = (intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX - (m_arrSampleBlobLeads[i].fTipWidth / 2) + m_stcBlobLead.intAGVROITolerance_Left) * fDrawingScaleX;
                                    fStartY = (intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY + m_stcBlobLead.intAGVROITolerance_Top) * fDrawingScaleY;
                                    fWidth = (m_arrSampleBlobLeads[i].fTipWidth - m_stcBlobLead.intAGVROITolerance_Left - m_stcBlobLead.intAGVROITolerance_Right) * fDrawingScaleX;
                                    fHeight = (m_arrSampleBlobLeads[i].fTipHeight - m_stcBlobLead.intAGVROITolerance_Top - m_stcBlobLead.intAGVROITolerance_Bottom) * fDrawingScaleY;
                                    break;
                                case 3: // Bottom
                                    fStartX = (intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX - (m_arrSampleBlobLeads[i].fTipWidth / 2) + m_stcBlobLead.intAGVROITolerance_Left) * fDrawingScaleX;
                                    fStartY = (intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY - m_arrSampleBlobLeads[i].fTipHeight + m_stcBlobLead.intAGVROITolerance_Top) * fDrawingScaleY;
                                    fWidth = (m_arrSampleBlobLeads[i].fTipWidth - m_stcBlobLead.intAGVROITolerance_Left - m_stcBlobLead.intAGVROITolerance_Right) * fDrawingScaleX;
                                    fHeight = (m_arrSampleBlobLeads[i].fTipHeight - m_stcBlobLead.intAGVROITolerance_Top - m_stcBlobLead.intAGVROITolerance_Bottom) * fDrawingScaleY;
                                    break;
                                case 4: // Left
                                    fStartX = (intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX + m_stcBlobLead.intAGVROITolerance_Left) * fDrawingScaleX;
                                    fStartY = (intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY - (m_arrSampleBlobLeads[i].fTipWidth / 2) + m_stcBlobLead.intAGVROITolerance_Top) * fDrawingScaleY;
                                    fWidth = (m_arrSampleBlobLeads[i].fTipHeight - m_stcBlobLead.intAGVROITolerance_Left - m_stcBlobLead.intAGVROITolerance_Right) * fDrawingScaleX;
                                    fHeight = (m_arrSampleBlobLeads[i].fTipWidth - m_stcBlobLead.intAGVROITolerance_Top - m_stcBlobLead.intAGVROITolerance_Bottom) * fDrawingScaleY;
                                    break;
                                case 2: // Right
                                    fStartX = (intRoiOrgX + m_arrSampleBlobLeads[i].fTipCenterX - m_arrSampleBlobLeads[i].fTipHeight + m_stcBlobLead.intAGVROITolerance_Left) * fDrawingScaleX;
                                    fStartY = (intRoiOrgY + m_arrSampleBlobLeads[i].fTipCenterY - (m_arrSampleBlobLeads[i].fTipWidth / 2) + m_stcBlobLead.intAGVROITolerance_Top) * fDrawingScaleY;
                                    fWidth = (m_arrSampleBlobLeads[i].fTipHeight - m_stcBlobLead.intAGVROITolerance_Left - m_stcBlobLead.intAGVROITolerance_Right) * fDrawingScaleX;
                                    fHeight = (m_arrSampleBlobLeads[i].fTipWidth - m_stcBlobLead.intAGVROITolerance_Top - m_stcBlobLead.intAGVROITolerance_Bottom) * fDrawingScaleY;
                                    break;
                            }
                            g.DrawRectangle(new Pen(Color.Turquoise, 1), fStartX, fStartY, fWidth, fHeight);
                        }
                    }
                }

                //for (int i = 0; i < m_arrLeadDefectList.Count; i++)
                //{
                //    if (m_blnLock)
                //        return;

                //    g.DrawRectangle(redPen, (m_arrLeadDefectList[i].ref_fCenterX - m_arrLeadDefectList[i].ref_fWidth / 2) * fDrawingScaleX,
                //                            (m_arrLeadDefectList[i].ref_fCenterY - m_arrLeadDefectList[i].ref_fHeight / 2) * fDrawingScaleY,
                //                            m_arrLeadDefectList[i].ref_fWidth * fDrawingScaleX, m_arrLeadDefectList[i].ref_fHeight * fDrawingScaleY);
                //}

                for (int i = 0; i < m_arrFailPitchGapList.Count; i++)
                {
                    if (m_blnLock)
                        return;
                    if (!blnFail)
                        blnFail = true;
                    g.DrawLine(redPen, (float)(m_arrFailPitchGapList[i].intStartPointX - 5) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intStartPointY - 5) * fDrawingScaleY,
                                       (float)(m_arrFailPitchGapList[i].intStartPointX + 5) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intStartPointY + 5) * fDrawingScaleY);
                    g.DrawLine(redPen, (float)(m_arrFailPitchGapList[i].intStartPointX + 5) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intStartPointY - 5) * fDrawingScaleY,
                                       (float)(m_arrFailPitchGapList[i].intStartPointX - 5) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intStartPointY + 5) * fDrawingScaleY);
                    g.DrawLine(redPen, (float)(m_arrFailPitchGapList[i].intEndPointX - 5) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intEndPointY - 5) * fDrawingScaleY,
                                       (float)(m_arrFailPitchGapList[i].intEndPointX + 5) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intEndPointY + 5) * fDrawingScaleY);
                    g.DrawLine(redPen, (float)(m_arrFailPitchGapList[i].intEndPointX + 5) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intEndPointY - 5) * fDrawingScaleY,
                                       (float)(m_arrFailPitchGapList[i].intEndPointX - 5) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intEndPointY + 5) * fDrawingScaleY);
                    g.DrawLine(redPen, (float)(m_arrFailPitchGapList[i].intStartPointX) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intStartPointY) * fDrawingScaleY,
                                       (float)(m_arrFailPitchGapList[i].intEndPointX) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intEndPointY) * fDrawingScaleY);
                }

                if (blnFail && !m_blnLock)
                {
                    objROI.DrawROI(g, fDrawingScaleX, fDrawingScaleY, false, Color.Red);
                }
            }
        }

        /// <summary>
        /// Rearrange selected blobs 
        /// </summary>
        public void RearrangeBlobs()
        {
            int intBlobsFeatureCount = m_arrTemplateBlobLeads.Count;
            BlobsFeatures[] arrBlobsFeatures = new BlobsFeatures[intBlobsFeatureCount];
            int intNoID;

            // Copy selected blobs from global list (keep previous record) into temporary list
            for (int i = 0; i < intBlobsFeatureCount; i++)
            {
                if (!((BlobsFeatures)m_arrTemplateBlobLeads[i]).blnSelected)
                    continue;

                intNoID = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID - 1;
                if (intNoID >= 0 && intNoID < arrBlobsFeatures.Length)
                    arrBlobsFeatures[intNoID] = (BlobsFeatures)m_arrTemplateBlobLeads[i];
            }

            // delete global list 
            m_arrTemplateBlobLeads = new ArrayList();

            // Copy selected blobs from temporary list into global list.
            for (int i = 0; i < arrBlobsFeatures.Length; i++)
            {
                if (arrBlobsFeatures[i].blnSelected)
                {
                    m_stcBlobLead = (BlobsFeatures)arrBlobsFeatures[i];
                    m_arrTemplateBlobLeads.Add(m_stcBlobLead);
                }
            }
        }
        public void RearrangeBlobs_BaseLead(int intLeadCurrNo, int intTotalBlobCount)
        {
            int intBlobsFeatureCount = m_arrTemplateBlobLeads_BaseLead.Count;
            BlobsFeatures[] arrBlobsFeatures = new BlobsFeatures[intBlobsFeatureCount];
            int intNoID;
            
            // Copy selected blobs from global list (keep previous record) into temporary list
            for (int i = 0; i < intBlobsFeatureCount; i++)
            {
                if (!((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).blnSelected)
                    continue;

                //intNoID = ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).intNoID - (intLeadCurrNo - arrBlobsFeatures.Length);

                if (m_intFirstLead == m_intLeadROIDirection)
                    intNoID = ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).intNoID - 1;
                else
                    intNoID = ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).intNoID - intTotalBlobCount + arrBlobsFeatures.Length - 1;

                if (intNoID >= 0 && intNoID < arrBlobsFeatures.Length)
                    arrBlobsFeatures[intNoID] = (BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i];
            }

            // delete global list 
            m_arrTemplateBlobLeads_BaseLead = new ArrayList();

            // Copy selected blobs from temporary list into global list.
            for (int i = 0; i < arrBlobsFeatures.Length; i++)
            {
                if (arrBlobsFeatures[i].blnSelected)
                {
                    m_stcBlobLead = (BlobsFeatures)arrBlobsFeatures[i];
                    m_arrTemplateBlobLeads_BaseLead.Add(m_stcBlobLead);
                }
            }
        }
        public void RearrangeBlobs(int intLeadCurrNo)
        {
            int intBlobsFeatureCount = m_arrTemplateBlobLeads.Count;
            BlobsFeatures[] arrBlobsFeatures = new BlobsFeatures[intBlobsFeatureCount];
            int intNoID;

            // Copy selected blobs from global list (keep previous record) into temporary list
            for (int i = 0; i < intBlobsFeatureCount; i++)
            {
                if (!((BlobsFeatures)m_arrTemplateBlobLeads[i]).blnSelected)
                    continue;

                intNoID = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).intNoID - (intLeadCurrNo - arrBlobsFeatures.Length);
                if (intNoID >= 0 && intNoID < arrBlobsFeatures.Length)
                    arrBlobsFeatures[intNoID] = (BlobsFeatures)m_arrTemplateBlobLeads[i];
            }

            // delete global list 
            m_arrTemplateBlobLeads = new ArrayList();

            // Copy selected blobs from temporary list into global list.
            for (int i = 0; i < arrBlobsFeatures.Length; i++)
            {
                if (arrBlobsFeatures[i].blnSelected)
                {
                    m_stcBlobLead = (BlobsFeatures)arrBlobsFeatures[i];
                    m_arrTemplateBlobLeads.Add(m_stcBlobLead);
                }
            }
        }

        /// <summary>
        /// Initialize sample data by init m_arrSampleBlobLeads and m_arrExtraBlobs
        /// </summary>
        public void ResetInspectionData()
        {
            m_pUnitCenterPoint.X = 0;
            m_pUnitCenterPoint.Y = 0;
            m_intFailResultMask = 0;
            m_fSampleLengthMinMM = -999;
            m_fSampleLengthMaxMM = -999;
            m_fSampleLengthVarianceMM = -999;
            m_fLeadSpanResultMM = -999;
            m_fLeadUnitSpanTipCenterXY = -999;
            //m_intFailPkgResultMask = 0;

            m_arrSampleBlobLeads = new SampleBlobsFeatures[m_arrTemplateBlobLeads.Count];
            m_arrSampleBlobLeads_BaseLead = new SampleBlobsFeatures[m_arrTemplateBlobLeads_BaseLead.Count];
            m_arrExtraBlobs = new List<SampleExtraBlobsFeatures>();
            //m_arrLeadDefectList = new List<Defect>();
            m_arrFailPitchGapList = new List<PitchGap>();
            m_intTemplateMatchStatus = new int[0];
            m_intSampleMatchNumber = new int[0];
            m_arrSampleMatchNumber.Clear();
            m_intTemplateMatchStatus_BaseLead = new int[0];
            m_intSampleMatchNumber_BaseLead = new int[0];
            for (int i = 0; i < m_arrPitchGap.Count; i++)
            {
                m_stcPitchGap = m_arrPitchGap[i];
                m_stcPitchGap.intFailMask = 0;
                m_stcPitchGap.fPitchMM = -999f;
                m_stcPitchGap.fGapMM = -999f;
                m_arrPitchGap.RemoveAt(i);
                m_arrPitchGap.Insert(i, m_stcPitchGap);
            }

            m_intTemplateMatchStatus = new int[m_arrTemplateBlobLeads.Count];
            m_intTemplateMatchStatus_BaseLead = new int[m_arrTemplateBlobLeads_BaseLead.Count];
            m_fSampleReferencePointStartX = -999; // objROI.ref_ROIWidth;   // 2020 08 14 - CCENG - change m_fSampleReferencePoint Start End X Y change to -999 to indicate inspection fail or not before set this variable.
            m_fSampleReferencePointStartY = -999; // objROI.ref_ROIHeight;
            m_fSampleReferencePointEndX = -999; // 0;
            m_fSampleReferencePointEndY = -999; // 0;
            m_fSampleLeadMinSpanStart = -999;
            m_fSampleLeadMaxSpanStart = -999;
            m_fSampleLeadMinSpanEnd = -999;
            m_fSampleLeadMaxSpanEnd = -999;

            for (int i = 0; i < m_arrSampleBlobLeads.Length; i++)
            {
                m_arrSampleBlobLeads[i].fOffSet = -999;
                m_arrSampleBlobLeads[i].fSkew = -999;
                m_arrSampleBlobLeads[i].fArea = -999;
                m_arrSampleBlobLeads[i].fWidth = -999;
                m_arrSampleBlobLeads[i].fHeight = -999;
                m_arrSampleBlobLeads[i].fPitch = -999;
                m_arrSampleBlobLeads[i].fGap = -999;
                m_arrSampleBlobLeads[i].intFailMask = 0;
                m_arrSampleBlobLeads[i].fStartX = -999;
                m_arrSampleBlobLeads[i].fStartY = -999;
                m_arrSampleBlobLeads[i].fEndX = -999;
                m_arrSampleBlobLeads[i].fEndY = -999;
                m_arrSampleBlobLeads[i].fCenterX = -999;
                m_arrSampleBlobLeads[i].fCenterY = -999;
                m_arrSampleBlobLeads[i].intContourIndex = -1;

                m_arrSampleBlobLeads[i].fOffSetMM = -999;
                m_arrSampleBlobLeads[i].fSkewMM = -999;
                m_arrSampleBlobLeads[i].fAreaMM = -999;
                m_arrSampleBlobLeads[i].fWidthMM = -999;
                m_arrSampleBlobLeads[i].fHeightMM = -999;
                m_arrSampleBlobLeads[i].fBaseWidthMM = -999;
                m_arrSampleBlobLeads[i].fBaseHeightMM = -999;
                m_arrSampleBlobLeads[i].fTipWidthMM = -999;
                m_arrSampleBlobLeads[i].fTipHeightMM = -999;
                m_arrSampleBlobLeads[i].fPitchMM = -999;
                m_arrSampleBlobLeads[i].fGapMM = -999;
                m_arrSampleBlobLeads[i].fAGV = -999;

                m_arrSampleBlobLeads[i].fBaseCenterX = -999;
                m_arrSampleBlobLeads[i].fBaseCenterY = -999;
                m_arrSampleBlobLeads[i].fTipCenterX = -999;
                m_arrSampleBlobLeads[i].fTipCenterY = -999;
                m_arrSampleBlobLeads[i].fBaseWidth = -999;
                m_arrSampleBlobLeads[i].fBaseHeight = -999;
                m_arrSampleBlobLeads[i].fTipWidth = -999;
                m_arrSampleBlobLeads[i].fTipHeight = -999;

                m_arrSampleBlobLeads[i].blnBaseStartFound = false;
                m_arrSampleBlobLeads[i].blnBaseEndFound = false;
            }
            for (int i = 0; i < m_arrSampleBlobLeads_BaseLead.Length; i++)
            {
                m_arrSampleBlobLeads_BaseLead[i].fOffSet = -999;
                m_arrSampleBlobLeads_BaseLead[i].fSkew = -999;
                m_arrSampleBlobLeads_BaseLead[i].fArea = -999;
                m_arrSampleBlobLeads_BaseLead[i].fWidth = -999;
                m_arrSampleBlobLeads_BaseLead[i].fHeight = -999;
                m_arrSampleBlobLeads_BaseLead[i].intFailMask = 0;
                m_arrSampleBlobLeads_BaseLead[i].fStartX = -999;
                m_arrSampleBlobLeads_BaseLead[i].fStartY = -999;
                m_arrSampleBlobLeads_BaseLead[i].fEndX = -999;
                m_arrSampleBlobLeads_BaseLead[i].fEndY = -999;
                m_arrSampleBlobLeads_BaseLead[i].fCenterX = -999;
                m_arrSampleBlobLeads_BaseLead[i].fCenterY = -999;
                m_arrSampleBlobLeads_BaseLead[i].intContourIndex = -1;

                m_arrSampleBlobLeads_BaseLead[i].fOffSetMM = -999;
                m_arrSampleBlobLeads_BaseLead[i].fSkewMM = -999;
                m_arrSampleBlobLeads_BaseLead[i].fAreaMM = -999;
                m_arrSampleBlobLeads_BaseLead[i].fWidthMM = -999;
                m_arrSampleBlobLeads_BaseLead[i].fHeightMM = -999;
            }
            //m_arrPkgDefectList.Clear();

            m_fUnitCenterX = 0;
            m_fUnitCenterY = 0;
        }
        public void ResetNoInspectionData()
        {
            if (m_arrLeadPointGaugeStartX.Count > 0)
            {
                m_arrLeadPointGaugeStartX.Clear();
                m_arrLeadPointGaugeStartY.Clear();
                m_arrLeadPointGaugeTolerance.Clear();
                m_arrLeadPointGaugeAngle.Clear();
                m_arrLeadEdgeGaugePoints.Clear();
                m_arrLeadEdgeGaugePointsFound.Clear();
                m_arrLeadEdgeGaugePointsPosition.Clear();
                m_arrLeadEdgeGaugePointsIDNo.Clear();
            }
        }
        /// <summary>
        /// Assign all data from previous backup m_arrTemporaryBlobLeads to m_arrTemplateBlobLeads (current template)
        /// </summary>
        public void ReverseBlobs()
        {
            BlobsFeatures stcBlobLead;
            BlobsFeatures stcTemporaryBlobLead;
            m_arrTemplateBlobLeads = new ArrayList();
            for (int i = 0; i < m_arrTemporaryBlobLeads.Count; i++)
            {
                stcBlobLead = new BlobsFeatures();
                stcTemporaryBlobLead = (BlobsFeatures)m_arrTemporaryBlobLeads[i];

                stcBlobLead.fArea = stcTemporaryBlobLead.fArea;
                stcBlobLead.fCenterX = stcTemporaryBlobLead.fCenterX;
                stcBlobLead.fCenterY = stcTemporaryBlobLead.fCenterY;
                stcBlobLead.fLimitCenterX = stcTemporaryBlobLead.fLimitCenterX;
                stcBlobLead.fLimitCenterY = stcTemporaryBlobLead.fLimitCenterY;
                stcBlobLead.fWidth = stcTemporaryBlobLead.fWidth;
                stcBlobLead.fHeight = stcTemporaryBlobLead.fHeight;
                stcBlobLead.intLengthMode = stcTemporaryBlobLead.intLengthMode;
                stcBlobLead.intContourX = stcTemporaryBlobLead.intContourX;
                stcBlobLead.intContourY = stcTemporaryBlobLead.intContourY;
                stcBlobLead.arrContourX = stcTemporaryBlobLead.arrContourX;
                stcBlobLead.arrContourY = stcTemporaryBlobLead.arrContourY;
                stcBlobLead.intObjNo = stcTemporaryBlobLead.intObjNo;
                stcBlobLead.fStartX = stcTemporaryBlobLead.fStartX;
                stcBlobLead.fEndX = stcTemporaryBlobLead.fEndX;
                stcBlobLead.fStartY = stcTemporaryBlobLead.fStartY;
                stcBlobLead.fEndY = stcTemporaryBlobLead.fEndY;
                stcBlobLead.intStartX = stcTemporaryBlobLead.intStartX;
                stcBlobLead.intEndX = stcTemporaryBlobLead.intEndX;
                stcBlobLead.intStartY = stcTemporaryBlobLead.intStartY;
                stcBlobLead.intEndY = stcTemporaryBlobLead.intEndY;
                stcBlobLead.blnSelected = stcTemporaryBlobLead.blnSelected;
                stcBlobLead.intDirection = stcTemporaryBlobLead.intDirection;
                stcBlobLead.intGroupID = stcTemporaryBlobLead.intGroupID;
                stcBlobLead.fPitch = stcTemporaryBlobLead.fPitch;
                stcBlobLead.fGap = stcTemporaryBlobLead.fGap;
                stcBlobLead.intNoID = stcTemporaryBlobLead.intNoID;
                stcBlobLead.intSelectedBlob = stcTemporaryBlobLead.intSelectedBlob;
                stcBlobLead.arrSelectedBlob = stcTemporaryBlobLead.arrSelectedBlob;

                stcBlobLead.intBaseInwardOffset = stcTemporaryBlobLead.intBaseInwardOffset;
                stcBlobLead.intTipInwardOffset = stcTemporaryBlobLead.intTipInwardOffset;

                stcBlobLead.intAGVROITolerance_Top = stcTemporaryBlobLead.intAGVROITolerance_Top;
                stcBlobLead.intAGVROITolerance_Bottom = stcTemporaryBlobLead.intAGVROITolerance_Bottom;
                stcBlobLead.intAGVROITolerance_Left = stcTemporaryBlobLead.intAGVROITolerance_Left;
                stcBlobLead.intAGVROITolerance_Right = stcTemporaryBlobLead.intAGVROITolerance_Right;

                m_arrTemplateBlobLeads.Add(stcBlobLead);
            }
        }
        public void ReverseBlobs_BaseLead()
        {
            BlobsFeatures stcBlobLead;
            BlobsFeatures stcTemporaryBlobLead;
            m_arrTemplateBlobLeads_BaseLead = new ArrayList();
            for (int i = 0; i < m_arrTemporaryBlobLeads_BaseLead.Count; i++)
            {
                stcBlobLead = new BlobsFeatures();
                stcTemporaryBlobLead = (BlobsFeatures)m_arrTemporaryBlobLeads_BaseLead[i];

                stcBlobLead.fArea = stcTemporaryBlobLead.fArea;
                stcBlobLead.fCenterX = stcTemporaryBlobLead.fCenterX;
                stcBlobLead.fCenterY = stcTemporaryBlobLead.fCenterY;
                stcBlobLead.fLimitCenterX = stcTemporaryBlobLead.fLimitCenterX;
                stcBlobLead.fLimitCenterY = stcTemporaryBlobLead.fLimitCenterY;
                stcBlobLead.fWidth = stcTemporaryBlobLead.fWidth;
                stcBlobLead.fHeight = stcTemporaryBlobLead.fHeight;
                stcBlobLead.intLengthMode = stcTemporaryBlobLead.intLengthMode;
                stcBlobLead.intContourX = stcTemporaryBlobLead.intContourX;
                stcBlobLead.intContourY = stcTemporaryBlobLead.intContourY;
                stcBlobLead.arrContourX = stcTemporaryBlobLead.arrContourX;
                stcBlobLead.arrContourY = stcTemporaryBlobLead.arrContourY;
                stcBlobLead.intObjNo = stcTemporaryBlobLead.intObjNo;
                stcBlobLead.fStartX = stcTemporaryBlobLead.fStartX;
                stcBlobLead.fEndX = stcTemporaryBlobLead.fEndX;
                stcBlobLead.fStartY = stcTemporaryBlobLead.fStartY;
                stcBlobLead.fEndY = stcTemporaryBlobLead.fEndY;
                stcBlobLead.intStartX = stcTemporaryBlobLead.intStartX;
                stcBlobLead.intEndX = stcTemporaryBlobLead.intEndX;
                stcBlobLead.intStartY = stcTemporaryBlobLead.intStartY;
                stcBlobLead.intEndY = stcTemporaryBlobLead.intEndY;
                stcBlobLead.blnSelected = stcTemporaryBlobLead.blnSelected;
                stcBlobLead.intDirection = stcTemporaryBlobLead.intDirection;
                stcBlobLead.intGroupID = stcTemporaryBlobLead.intGroupID;
                stcBlobLead.fPitch = stcTemporaryBlobLead.fPitch;
                stcBlobLead.fGap = stcTemporaryBlobLead.fGap;
                stcBlobLead.intNoID = stcTemporaryBlobLead.intNoID;
                stcBlobLead.intSelectedBlob = stcTemporaryBlobLead.intSelectedBlob;
                stcBlobLead.arrSelectedBlob = stcTemporaryBlobLead.arrSelectedBlob;

                stcBlobLead.intBaseInwardOffset = stcTemporaryBlobLead.intBaseInwardOffset;
                stcBlobLead.intTipInwardOffset = stcTemporaryBlobLead.intTipInwardOffset;

                stcBlobLead.intAGVROITolerance_Top = stcTemporaryBlobLead.intAGVROITolerance_Top;
                stcBlobLead.intAGVROITolerance_Bottom = stcTemporaryBlobLead.intAGVROITolerance_Bottom;
                stcBlobLead.intAGVROITolerance_Left = stcTemporaryBlobLead.intAGVROITolerance_Left;
                stcBlobLead.intAGVROITolerance_Right = stcTemporaryBlobLead.intAGVROITolerance_Right;

                m_arrTemplateBlobLeads_BaseLead.Add(stcBlobLead);
            }
        }
        /// <summary>
        /// Select template objects
        /// </summary>
        /// <param name="p1">rectangle start point</param>
        /// <param name="p2">rectangle stop point</param>
        /// <param name="intROIX">total offset X</param>
        /// <param name="intROIY">total offset Y</param>
        public void SelectTemplateObjects(System.Drawing.Point p1, System.Drawing.Point p2, int intROIX, int intROIY)
        {
            int intOrgX, intOrgY, intWidth, intHeight;

            if (p1.X < p2.X)
            {
                intOrgX = p1.X;
                intWidth = p2.X - p1.X;
            }
            else
            {
                intOrgX = p2.X;
                intWidth = p1.X - p2.X;
            }
            if (p1.Y < p2.Y)
            {
                intOrgY = p1.Y;
                intHeight = p2.Y - p1.Y;
            }
            else
            {
                intOrgY = p2.Y;
                intHeight = p1.Y - p2.Y;
            }

            intOrgX -= intROIX;
            intOrgY -= intROIY;

            // new method
            p1 = new System.Drawing.Point(p1.X - intROIX, p1.Y - intROIY);
            p2 = new System.Drawing.Point(p2.X - intROIX, p2.Y - intROIY);

            List<int> arrSelectedIndex = new List<int>();
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                //if ((m_stcBlobLead.fCenterX >= intOrgX) &&
                //    (m_stcBlobLead.fCenterX <= (intOrgX + intWidth)) &&
                //    (m_stcBlobLead.fCenterY >= intOrgY) &&
                //    (m_stcBlobLead.fCenterY <= (intOrgY + intHeight)))
                //{
                //    m_stcBlobLead.blnSelected = true;
                //}
                bool blnFound = false;
                for (int x = p1.X; x < p2.X; x++)
                {
                    for (int y = p1.Y; y < p2.Y; y++)
                    {
                        if ((x >= m_stcBlobLead.fStartX) &&
                               (x <= m_stcBlobLead.fEndX) &&
                               (y >= m_stcBlobLead.fStartY) &&
                               (y <= m_stcBlobLead.fEndY))
                        {
                            m_stcBlobLead.blnSelected = true;
                            blnFound = true;
                            break;
                        }
                    }

                    if (blnFound)
                        break;
                }

                if (blnFound)
                    arrSelectedIndex.Add(i);
                //m_arrTemplateBlobLeads.RemoveAt(i);
                //m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
            }

            for (int i = 0; i < arrSelectedIndex.Count; i++)
            {
                bool blnOverlap = false;
                bool blnSmall = false;
                for (int j = 0; j < arrSelectedIndex.Count; j++)
                {
                    if (i == j)
                        continue;

                    BlobsFeatures objBlob1 = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                    BlobsFeatures objBlob2 = (BlobsFeatures)m_arrTemplateBlobLeads[j];

                    // check is blob overlap with other blobs (using 4 corner points matching methodology)?
                    if ((((objBlob1.fStartX > objBlob2.fStartX) &&
                        (objBlob1.fStartX < objBlob2.fEndX) &&
                        (objBlob1.fStartY > objBlob2.fStartY) &&
                        (objBlob1.fStartY < objBlob2.fEndY)) ||
                        ((objBlob1.fStartX > objBlob2.fStartX) &&
                        (objBlob1.fStartX < objBlob2.fEndX) &&
                        (objBlob1.fEndY > objBlob2.fStartY) &&
                        (objBlob1.fEndY < objBlob2.fEndY)) ||
                        ((objBlob1.fEndX > objBlob2.fStartX) &&
                        (objBlob1.fEndX < objBlob2.fEndX) &&
                        (objBlob1.fStartY > objBlob2.fStartY) &&
                        (objBlob1.fStartY < objBlob2.fEndY)) ||
                        ((objBlob1.fEndX > objBlob2.fStartX) &&
                        (objBlob1.fEndX < objBlob2.fEndX) &&
                        (objBlob1.fEndY > objBlob2.fStartY) &&
                        (objBlob1.fEndY < objBlob2.fEndY))) ||

                        (((objBlob2.fStartX > objBlob1.fStartX) &&
                        (objBlob2.fStartX < objBlob1.fEndX) &&
                        (objBlob2.fStartY > objBlob1.fStartY) &&
                        (objBlob2.fStartY < objBlob1.fEndY)) ||
                        ((objBlob2.fStartX > objBlob1.fStartX) &&
                        (objBlob2.fStartX < objBlob1.fEndX) &&
                        (objBlob2.fEndY > objBlob1.fStartY) &&
                        (objBlob2.fEndY < objBlob1.fEndY)) ||
                        ((objBlob2.fEndX > objBlob1.fStartX) &&
                        (objBlob2.fEndX < objBlob1.fEndX) &&
                        (objBlob2.fStartY > objBlob1.fStartY) &&
                        (objBlob2.fStartY < objBlob1.fEndY)) ||
                        ((objBlob2.fEndX > objBlob1.fStartX) &&
                        (objBlob2.fEndX < objBlob1.fEndX) &&
                        (objBlob2.fEndY > objBlob1.fStartY) &&
                        (objBlob2.fEndY < objBlob1.fEndY))))

                    {
                        // check is blob1 size smaller than blob2
                        if (((objBlob1.fEndX - objBlob1.fStartX) * (objBlob1.fEndY - objBlob1.fStartY)) >
                            ((objBlob2.fEndX - objBlob2.fStartX) * (objBlob2.fEndY - objBlob2.fStartY)))
                        {
                            blnOverlap = true;  // no select
                            break;
                        }
                    }
                }

                if (!blnOverlap)
                {
                    m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[arrSelectedIndex[i]];
                    m_stcBlobLead.blnSelected = true;
                    m_arrTemplateBlobLeads.RemoveAt(arrSelectedIndex[i]);
                    m_arrTemplateBlobLeads.Insert(arrSelectedIndex[i], m_stcBlobLead);
                }
            }
        }
        public void SelectTemplateObjects_BaseLead(System.Drawing.Point p1, System.Drawing.Point p2, int intROIX, int intROIY)
        {
            int intOrgX, intOrgY, intWidth, intHeight;

            if (p1.X < p2.X)
            {
                intOrgX = p1.X;
                intWidth = p2.X - p1.X;
            }
            else
            {
                intOrgX = p2.X;
                intWidth = p1.X - p2.X;
            }
            if (p1.Y < p2.Y)
            {
                intOrgY = p1.Y;
                intHeight = p2.Y - p1.Y;
            }
            else
            {
                intOrgY = p2.Y;
                intHeight = p1.Y - p2.Y;
            }

            intOrgX -= intROIX;
            intOrgY -= intROIY;

            // new method
            p1 = new System.Drawing.Point(p1.X - intROIX, p1.Y - intROIY);
            p2 = new System.Drawing.Point(p2.X - intROIX, p2.Y - intROIY);

            List<int> arrSelectedIndex = new List<int>();
            for (int i = 0; i < m_arrTemplateBlobLeads_BaseLead.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i];
                //if ((m_stcBlobLead.fCenterX >= intOrgX) &&
                //    (m_stcBlobLead.fCenterX <= (intOrgX + intWidth)) &&
                //    (m_stcBlobLead.fCenterY >= intOrgY) &&
                //    (m_stcBlobLead.fCenterY <= (intOrgY + intHeight)))
                //{
                //    m_stcBlobLead.blnSelected = true;
                //}
                bool blnFound = false;
                for (int x = p1.X; x < p2.X; x++)
                {
                    for (int y = p1.Y; y < p2.Y; y++)
                    {
                        if ((x >= m_stcBlobLead.fStartX) &&
                               (x <= m_stcBlobLead.fEndX) &&
                               (y >= m_stcBlobLead.fStartY) &&
                               (y <= m_stcBlobLead.fEndY))
                        {
                            m_stcBlobLead.blnSelected = true;
                            blnFound = true;
                            break;
                        }
                    }

                    if (blnFound)
                        break;
                }

                if (blnFound)
                    arrSelectedIndex.Add(i);
                //m_arrTemplateBlobLeads.RemoveAt(i);
                //m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
            }

            for (int i = 0; i < arrSelectedIndex.Count; i++)
            {
                bool blnOverlap = false;
                bool blnSmall = false;
                for (int j = 0; j < arrSelectedIndex.Count; j++)
                {
                    if (i == j)
                        continue;

                    BlobsFeatures objBlob1 = (BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i];
                    BlobsFeatures objBlob2 = (BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[j];

                    // check is blob overlap with other blobs (using 4 corner points matching methodology)?
                    if ((((objBlob1.fStartX > objBlob2.fStartX) &&
                        (objBlob1.fStartX < objBlob2.fEndX) &&
                        (objBlob1.fStartY > objBlob2.fStartY) &&
                        (objBlob1.fStartY < objBlob2.fEndY)) ||
                        ((objBlob1.fStartX > objBlob2.fStartX) &&
                        (objBlob1.fStartX < objBlob2.fEndX) &&
                        (objBlob1.fEndY > objBlob2.fStartY) &&
                        (objBlob1.fEndY < objBlob2.fEndY)) ||
                        ((objBlob1.fEndX > objBlob2.fStartX) &&
                        (objBlob1.fEndX < objBlob2.fEndX) &&
                        (objBlob1.fStartY > objBlob2.fStartY) &&
                        (objBlob1.fStartY < objBlob2.fEndY)) ||
                        ((objBlob1.fEndX > objBlob2.fStartX) &&
                        (objBlob1.fEndX < objBlob2.fEndX) &&
                        (objBlob1.fEndY > objBlob2.fStartY) &&
                        (objBlob1.fEndY < objBlob2.fEndY))) ||

                        (((objBlob2.fStartX > objBlob1.fStartX) &&
                        (objBlob2.fStartX < objBlob1.fEndX) &&
                        (objBlob2.fStartY > objBlob1.fStartY) &&
                        (objBlob2.fStartY < objBlob1.fEndY)) ||
                        ((objBlob2.fStartX > objBlob1.fStartX) &&
                        (objBlob2.fStartX < objBlob1.fEndX) &&
                        (objBlob2.fEndY > objBlob1.fStartY) &&
                        (objBlob2.fEndY < objBlob1.fEndY)) ||
                        ((objBlob2.fEndX > objBlob1.fStartX) &&
                        (objBlob2.fEndX < objBlob1.fEndX) &&
                        (objBlob2.fStartY > objBlob1.fStartY) &&
                        (objBlob2.fStartY < objBlob1.fEndY)) ||
                        ((objBlob2.fEndX > objBlob1.fStartX) &&
                        (objBlob2.fEndX < objBlob1.fEndX) &&
                        (objBlob2.fEndY > objBlob1.fStartY) &&
                        (objBlob2.fEndY < objBlob1.fEndY))))

                    {
                        // check is blob1 size smaller than blob2
                        if (((objBlob1.fEndX - objBlob1.fStartX) * (objBlob1.fEndY - objBlob1.fStartY)) >
                            ((objBlob2.fEndX - objBlob2.fStartX) * (objBlob2.fEndY - objBlob2.fStartY)))
                        {
                            blnOverlap = true;  // no select
                            break;
                        }
                    }
                }

                if (!blnOverlap)
                {
                    m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[arrSelectedIndex[i]];
                    m_stcBlobLead.blnSelected = true;
                    m_arrTemplateBlobLeads_BaseLead.RemoveAt(arrSelectedIndex[i]);
                    m_arrTemplateBlobLeads_BaseLead.Insert(arrSelectedIndex[i], m_stcBlobLead);
                }
            }
        }
        /// <summary>
        /// Compare to find new selected blobs and replace new selected blobs data into m_arrTemplateBlobLeads
        /// </summary>
        public void CompareSelectedBlobs()
        {
            float fCenterX, fCenterY, fStartX, fStartY, fEndX, fEndY;
            bool blnSelect;

            for (int i = 0; i < m_arrTemporaryBlobLeads.Count; i++)
            {
                fCenterX = ((BlobsFeatures)m_arrTemporaryBlobLeads[i]).fLimitCenterX;
                fCenterY = ((BlobsFeatures)m_arrTemporaryBlobLeads[i]).fLimitCenterY;

                for (int j = 0; j < m_arrTemplateBlobLeads.Count; j++)
                {
                    fStartX = ((BlobsFeatures)m_arrTemplateBlobLeads[j]).fStartX;
                    fStartY = ((BlobsFeatures)m_arrTemplateBlobLeads[j]).fStartY;

                    fEndX = ((BlobsFeatures)m_arrTemplateBlobLeads[j]).fEndX;
                    fEndY = ((BlobsFeatures)m_arrTemplateBlobLeads[j]).fEndY;

                    blnSelect = ((BlobsFeatures)m_arrTemplateBlobLeads[j]).blnSelected;

                    if ((fCenterX >= fStartX && fCenterX <= fEndX) && (fCenterY >= fStartY && fCenterY <= fEndY))// && blnSelect)
                    {
                        BlobsFeatures objBlobsFeatures = (BlobsFeatures)m_arrTemporaryBlobLeads[i];
                        objBlobsFeatures.blnSelected = blnSelect;// true;
                        m_arrTemporaryBlobLeads.RemoveAt(i);
                        m_arrTemporaryBlobLeads.Insert(i, objBlobsFeatures);
                    }
                }
            }

            m_arrTemplateBlobLeads.Clear();

            for (int v = 0; v < m_arrTemporaryBlobLeads.Count; v++)
            {
                BlobsFeatures stcBlobsFeatures = new BlobsFeatures();

                stcBlobsFeatures.fArea = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).fArea;
                stcBlobsFeatures.fCenterX = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).fCenterX;
                stcBlobsFeatures.fCenterY = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).fCenterY;
                stcBlobsFeatures.fLimitCenterX = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).fLimitCenterX;
                stcBlobsFeatures.fLimitCenterY = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).fLimitCenterY;
                stcBlobsFeatures.fWidth = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).fWidth;
                stcBlobsFeatures.fHeight = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).fHeight;
                stcBlobsFeatures.intLengthMode = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).intLengthMode;
                stcBlobsFeatures.intContourX = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).intContourX;
                stcBlobsFeatures.intContourY = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).intContourY;
                stcBlobsFeatures.arrContourX = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).arrContourX;
                stcBlobsFeatures.arrContourY = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).arrContourY;
                stcBlobsFeatures.intObjNo = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).intObjNo;
                stcBlobsFeatures.fStartX = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).fStartX;
                stcBlobsFeatures.fEndX = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).fEndX;
                stcBlobsFeatures.fStartY = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).fStartY;
                stcBlobsFeatures.fEndY = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).fEndY;
                stcBlobsFeatures.intStartX = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).intStartX;
                stcBlobsFeatures.intEndX = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).intEndX;
                stcBlobsFeatures.intStartY = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).intStartY;
                stcBlobsFeatures.intEndY = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).intEndY;
                stcBlobsFeatures.blnSelected = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).blnSelected;
                stcBlobsFeatures.intDirection = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).intDirection;
                stcBlobsFeatures.intGroupID = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).intGroupID;
                stcBlobsFeatures.fPitch = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).fPitch;
                stcBlobsFeatures.fGap = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).fGap;
                stcBlobsFeatures.intNoID = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).intNoID;
                stcBlobsFeatures.intSelectedBlob = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).intSelectedBlob;
                stcBlobsFeatures.arrSelectedBlob = ((BlobsFeatures)m_arrTemporaryBlobLeads[v]).arrSelectedBlob;
                m_arrTemplateBlobLeads.Add(stcBlobsFeatures);
            }
        }
        public void CompareSelectedBlobs_BaseLead()
        {
            float fCenterX, fCenterY, fStartX, fStartY, fEndX, fEndY;
            bool blnSelect;

            for (int i = 0; i < m_arrTemporaryBlobLeads_BaseLead.Count; i++)
            {
                fCenterX = ((BlobsFeatures)m_arrTemporaryBlobLeads_BaseLead[i]).fLimitCenterX;
                fCenterY = ((BlobsFeatures)m_arrTemporaryBlobLeads_BaseLead[i]).fLimitCenterY;

                for (int j = 0; j < m_arrTemplateBlobLeads_BaseLead.Count; j++)
                {
                    fStartX = ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[j]).fStartX;
                    fStartY = ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[j]).fStartY;

                    fEndX = ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[j]).fEndX;
                    fEndY = ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[j]).fEndY;

                    blnSelect = ((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[j]).blnSelected;

                    if ((fCenterX >= fStartX && fCenterX <= fEndX) && (fCenterY >= fStartY && fCenterY <= fEndY))// && blnSelect)
                    {
                        BlobsFeatures objBlobsFeatures = (BlobsFeatures)m_arrTemporaryBlobLeads_BaseLead[i];
                        objBlobsFeatures.blnSelected = blnSelect;//true;
                        m_arrTemporaryBlobLeads_BaseLead.RemoveAt(i);
                        m_arrTemporaryBlobLeads_BaseLead.Insert(i, objBlobsFeatures);
                    }
                }
            }

            m_arrTemplateBlobLeads_BaseLead.Clear();

            for (int v = 0; v < m_arrTemporaryBlobLeads_BaseLead.Count; v++)
            {
                BlobsFeatures stcBlobsFeatures = new BlobsFeatures();

                stcBlobsFeatures.fArea = ((BlobsFeatures)m_arrTemporaryBlobLeads_BaseLead[v]).fArea;
                stcBlobsFeatures.fCenterX = ((BlobsFeatures)m_arrTemporaryBlobLeads_BaseLead[v]).fCenterX;
                stcBlobsFeatures.fCenterY = ((BlobsFeatures)m_arrTemporaryBlobLeads_BaseLead[v]).fCenterY;
                stcBlobsFeatures.fLimitCenterX = ((BlobsFeatures)m_arrTemporaryBlobLeads_BaseLead[v]).fLimitCenterX;
                stcBlobsFeatures.fLimitCenterY = ((BlobsFeatures)m_arrTemporaryBlobLeads_BaseLead[v]).fLimitCenterY;
                stcBlobsFeatures.fWidth = ((BlobsFeatures)m_arrTemporaryBlobLeads_BaseLead[v]).fWidth;
                stcBlobsFeatures.fHeight = ((BlobsFeatures)m_arrTemporaryBlobLeads_BaseLead[v]).fHeight;
                stcBlobsFeatures.intLengthMode = ((BlobsFeatures)m_arrTemporaryBlobLeads_BaseLead[v]).intLengthMode;
                stcBlobsFeatures.intContourX = ((BlobsFeatures)m_arrTemporaryBlobLeads_BaseLead[v]).intContourX;
                stcBlobsFeatures.intContourY = ((BlobsFeatures)m_arrTemporaryBlobLeads_BaseLead[v]).intContourY;
                stcBlobsFeatures.arrContourX = ((BlobsFeatures)m_arrTemporaryBlobLeads_BaseLead[v]).arrContourX;
                stcBlobsFeatures.arrContourY = ((BlobsFeatures)m_arrTemporaryBlobLeads_BaseLead[v]).arrContourY;
                stcBlobsFeatures.intObjNo = ((BlobsFeatures)m_arrTemporaryBlobLeads_BaseLead[v]).intObjNo;
                stcBlobsFeatures.fStartX = ((BlobsFeatures)m_arrTemporaryBlobLeads_BaseLead[v]).fStartX;
                stcBlobsFeatures.fEndX = ((BlobsFeatures)m_arrTemporaryBlobLeads_BaseLead[v]).fEndX;
                stcBlobsFeatures.fStartY = ((BlobsFeatures)m_arrTemporaryBlobLeads_BaseLead[v]).fStartY;
                stcBlobsFeatures.fEndY = ((BlobsFeatures)m_arrTemporaryBlobLeads_BaseLead[v]).fEndY;
                stcBlobsFeatures.intStartX = ((BlobsFeatures)m_arrTemporaryBlobLeads_BaseLead[v]).intStartX;
                stcBlobsFeatures.intEndX = ((BlobsFeatures)m_arrTemporaryBlobLeads_BaseLead[v]).intEndX;
                stcBlobsFeatures.intStartY = ((BlobsFeatures)m_arrTemporaryBlobLeads_BaseLead[v]).intStartY;
                stcBlobsFeatures.intEndY = ((BlobsFeatures)m_arrTemporaryBlobLeads_BaseLead[v]).intEndY;
                stcBlobsFeatures.blnSelected = ((BlobsFeatures)m_arrTemporaryBlobLeads_BaseLead[v]).blnSelected;
                stcBlobsFeatures.intDirection = ((BlobsFeatures)m_arrTemporaryBlobLeads_BaseLead[v]).intDirection;
                stcBlobsFeatures.intGroupID = ((BlobsFeatures)m_arrTemporaryBlobLeads_BaseLead[v]).intGroupID;
                stcBlobsFeatures.fPitch = ((BlobsFeatures)m_arrTemporaryBlobLeads_BaseLead[v]).fPitch;
                stcBlobsFeatures.fGap = ((BlobsFeatures)m_arrTemporaryBlobLeads_BaseLead[v]).fGap;
                stcBlobsFeatures.intNoID = ((BlobsFeatures)m_arrTemporaryBlobLeads_BaseLead[v]).intNoID;
                stcBlobsFeatures.intSelectedBlob = ((BlobsFeatures)m_arrTemporaryBlobLeads_BaseLead[v]).intSelectedBlob;
                stcBlobsFeatures.arrSelectedBlob = ((BlobsFeatures)m_arrTemporaryBlobLeads_BaseLead[v]).arrSelectedBlob;
                m_arrTemplateBlobLeads_BaseLead.Add(stcBlobsFeatures);
            }
        }
        public void SetTemplateBlobsFeatures(int intNoID, int intGroupID, float fArea, int intLengthMode,
            int intContourX, int intContourY, int[] arrContourX, int[] arrContourY,
            int intStartX, int intStartY, int intEndX, int intEndY,
            float fStartX, float fStartY, float fEndX, float fEndY,
            int intDirection, int intSide,
            float fCenterX, float fCenterY, float fLimitCenterX, float fLimitCenterY,
            float fWidth, float fHeight,
            float fBaseWidth, float fBaseHeight, float fBaseCenterX, float fBaseCenterY,
            float fTipWidth, float fTipHeight, float fTipCenterX, float fTipCenterY,
            bool blnSelected, float fLeftDistance,
            float fRightDistance, float fTopDistance, float fBottomDistance,
            float fXDistance, float fYDistance,
            float fPitch, float fGap, float fOffSet, float fSkew,
            float fMinWidth, float fMaxWidth, float fMinHeight, float fMaxHeight,
            float fMinBaseWidth, float fMaxBaseWidth, float fMinBaseHeight, float fMaxBaseHeight,
            float fMinTipWidth, float fMaxTipWidth, float fMinTipHeight, float fMaxTipHeight,
            float fMinPitch, float fMaxPitch, float fMinGap, float fMaxGap, float fVariance, float fMinAGV, float fMaxAGV, int intBaseInwardOffset, int intTipInwardOffset,
            int intAGVROITolerance_Top, int intAGVROITolerance_Right, int intAGVROITolerance_Bottom, int intAGVROITolerance_Left,
            float fWidthOffset, float fLengthOffset, float fPitchOffset, float fGapOffset)
        {
            m_stcBlobLead.intNoID = intNoID;
            m_stcBlobLead.intGroupID = intGroupID;
            m_stcBlobLead.fArea = fArea;
            m_stcBlobLead.intLengthMode = intLengthMode;
            m_stcBlobLead.intContourX = intContourX;
            m_stcBlobLead.intContourY = intContourY;
            m_stcBlobLead.arrContourX = arrContourX;
            m_stcBlobLead.arrContourY = arrContourY;
            m_stcBlobLead.intStartX = intStartX;
            m_stcBlobLead.intStartY = intStartY;
            m_stcBlobLead.intEndX = intEndX;
            m_stcBlobLead.intEndY = intEndY;
            m_stcBlobLead.fStartX = fStartX;
            m_stcBlobLead.fStartY = fStartY;
            m_stcBlobLead.fEndX = fEndX;
            m_stcBlobLead.fEndY = fEndY;
            m_stcBlobLead.intDirection = intDirection;
            m_stcBlobLead.intSide = intSide;
            m_stcBlobLead.fCenterX = fCenterX;
            m_stcBlobLead.fCenterY = fCenterY;
            m_stcBlobLead.fLimitCenterX = fLimitCenterX;
            m_stcBlobLead.fLimitCenterY = fLimitCenterY;
            m_stcBlobLead.fWidth = fWidth;
            m_stcBlobLead.fHeight = fHeight;
            m_stcBlobLead.fBaseWidth = fBaseWidth;
            m_stcBlobLead.fBaseHeight = fBaseHeight;
            m_stcBlobLead.fBaseCenterX = fBaseCenterX;
            m_stcBlobLead.fBaseCenterY = fBaseCenterY;
            m_stcBlobLead.fTipWidth = fTipWidth;
            m_stcBlobLead.fTipHeight = fTipHeight;
            m_stcBlobLead.fTipCenterX = fTipCenterX;
            m_stcBlobLead.fTipCenterY = fTipCenterY;
            m_stcBlobLead.blnSelected = blnSelected;
            m_stcBlobLead.fLeftDistance = fLeftDistance;
            m_stcBlobLead.fRightDistance = fRightDistance;
            m_stcBlobLead.fTopDistance = fTopDistance;
            m_stcBlobLead.fBottomDistance = fBottomDistance;
            m_stcBlobLead.fXDistance = fXDistance;
            m_stcBlobLead.fYDistance = fYDistance;
            m_stcBlobLead.fPitch = fPitch;
            m_stcBlobLead.fGap = fGap;

            m_stcBlobLead.fOffSet = fOffSet;
            m_stcBlobLead.fSkew = fSkew;
            m_stcBlobLead.fMinWidth = fMinWidth;
            m_stcBlobLead.fMaxWidth = fMaxWidth;
            m_stcBlobLead.fMinHeight = fMinHeight;
            m_stcBlobLead.fMaxHeight = fMaxHeight;

            m_stcBlobLead.fMinBaseWidth = fMinBaseWidth;
            m_stcBlobLead.fMaxBaseWidth = fMaxBaseWidth;
            m_stcBlobLead.fMinBaseHeight = fMinBaseHeight;
            m_stcBlobLead.fMaxBaseHeight = fMaxBaseHeight;
            m_stcBlobLead.fMinTipWidth = fMinTipWidth;
            m_stcBlobLead.fMaxTipWidth = fMaxTipWidth;
            m_stcBlobLead.fMinTipHeight = fMinTipHeight;
            m_stcBlobLead.fMaxTipHeight = fMaxTipHeight;

            m_stcBlobLead.fMinPitch = fMinPitch;
            m_stcBlobLead.fMaxPitch = fMaxPitch;
            m_stcBlobLead.fMinGap = fMinGap;
            m_stcBlobLead.fMaxGap = fMaxGap;

            m_stcBlobLead.fVariance = fVariance;

            m_stcBlobLead.fMinAGV = fMinAGV;
            m_stcBlobLead.fMaxAGV = fMaxAGV;

            m_stcBlobLead.intBaseInwardOffset = intBaseInwardOffset;
            m_stcBlobLead.intTipInwardOffset = intTipInwardOffset;

            m_stcBlobLead.intAGVROITolerance_Top = intAGVROITolerance_Top;
            m_stcBlobLead.intAGVROITolerance_Right = intAGVROITolerance_Right;
            m_stcBlobLead.intAGVROITolerance_Bottom = intAGVROITolerance_Bottom;
            m_stcBlobLead.intAGVROITolerance_Left = intAGVROITolerance_Left;

            m_stcBlobLead.fWidthOffset = fWidthOffset;
            m_stcBlobLead.fLengthOffset = fLengthOffset;
            m_stcBlobLead.fPitchOffset = fPitchOffset;
            m_stcBlobLead.fGapOffset = fGapOffset;

            m_arrTemplateBlobLeads.Add(m_stcBlobLead);
        }
        public void SetTemplateBlobsFeatures_BaseLead(int intNoID, int intGroupID, float fArea, int intLengthMode,
           int intContourX, int intContourY, int[] arrContourX, int[] arrContourY,
           int intStartX, int intStartY, int intEndX, int intEndY,
           float fStartX, float fStartY, float fEndX, float fEndY,
           int intDirection, int intSide,
           float fCenterX, float fCenterY, float fLimitCenterX, float fLimitCenterY,
           float fWidth, float fHeight,
           float fBaseWidth, float fBaseHeight, float fBaseCenterX, float fBaseCenterY,
           float fTipWidth, float fTipHeight, float fTipCenterX, float fTipCenterY,
           bool blnSelected, float fLeftDistance,
           float fRightDistance, float fTopDistance, float fBottomDistance,
           float fXDistance, float fYDistance,
           float fMaxBaseOffset, float fMinBaseArea, float fMaxBaseArea)
        {
            m_stcBlobLead.intNoID = intNoID;
            m_stcBlobLead.intGroupID = intGroupID;
            m_stcBlobLead.fArea = fArea;
            m_stcBlobLead.intLengthMode = intLengthMode;
            m_stcBlobLead.intContourX = intContourX;
            m_stcBlobLead.intContourY = intContourY;
            m_stcBlobLead.arrContourX = arrContourX;
            m_stcBlobLead.arrContourY = arrContourY;
            m_stcBlobLead.intStartX = intStartX;
            m_stcBlobLead.intStartY = intStartY;
            m_stcBlobLead.intEndX = intEndX;
            m_stcBlobLead.intEndY = intEndY;
            m_stcBlobLead.fStartX = fStartX;
            m_stcBlobLead.fStartY = fStartY;
            m_stcBlobLead.fEndX = fEndX;
            m_stcBlobLead.fEndY = fEndY;
            m_stcBlobLead.intDirection = intDirection;
            m_stcBlobLead.intSide = intSide;
            m_stcBlobLead.fCenterX = fCenterX;
            m_stcBlobLead.fCenterY = fCenterY;
            m_stcBlobLead.fLimitCenterX = fLimitCenterX;
            m_stcBlobLead.fLimitCenterY = fLimitCenterY;
            m_stcBlobLead.fWidth = fWidth;
            m_stcBlobLead.fHeight = fHeight;
            m_stcBlobLead.fBaseWidth = fBaseWidth;
            m_stcBlobLead.fBaseHeight = fBaseHeight;
            m_stcBlobLead.fBaseCenterX = fBaseCenterX;
            m_stcBlobLead.fBaseCenterY = fBaseCenterY;
            m_stcBlobLead.fTipWidth = fTipWidth;
            m_stcBlobLead.fTipHeight = fTipHeight;
            m_stcBlobLead.fTipCenterX = fTipCenterX;
            m_stcBlobLead.fTipCenterY = fTipCenterY;
            m_stcBlobLead.blnSelected = blnSelected;
            m_stcBlobLead.fLeftDistance = fLeftDistance;
            m_stcBlobLead.fRightDistance = fRightDistance;
            m_stcBlobLead.fTopDistance = fTopDistance;
            m_stcBlobLead.fBottomDistance = fBottomDistance;
            m_stcBlobLead.fXDistance = fXDistance;
            m_stcBlobLead.fYDistance = fYDistance;

            m_stcBlobLead.fMaxBaseOffset = fMaxBaseOffset;
            m_stcBlobLead.fMinBaseArea = fMinBaseArea;
            m_stcBlobLead.fMaxBaseArea = fMaxBaseArea;

            m_arrTemplateBlobLeads_BaseLead.Add(m_stcBlobLead);
        }

        public void SetCalibrationData(float fPixelPerMMX, float fPixelPerMMY,
            float fSizeOffSetX, float fSizeOffSetY, int intUnitMode)
        {
            m_fMMPerPixelX = 1 / fPixelPerMMX;
            m_fMMPerPixelY = 1 / fPixelPerMMY;
            m_fAreaMMPerPixel = 1 / (fPixelPerMMX * fPixelPerMMY);

            m_fSizeOffSetX = fSizeOffSetX;
            m_fSizeOffSetY = fSizeOffSetY;

            // MM to Pixel formula
            m_fMMToPixelXValue = fPixelPerMMX;
            m_fMMToPixelYValue = fPixelPerMMY;
            m_fMMtoPixelAreaValue = fPixelPerMMX * fPixelPerMMY;

            // MM to Micron or Mil formula
            switch (intUnitMode)
            {
                case 1: // mm
                    m_fMMToUnitValue = 1;
                    m_fMMToUnitValueArea = 1;
                    m_intDecimal = 4;
                    m_intDecimal2 = 6;
                    break;
                case 2: // mil
                    m_fMMToUnitValue = 1 / 0.0254f;
                    m_fMMToUnitValueArea = 1 / (0.0254f * 0.0254f);
                    m_intDecimal = 4;
                    m_intDecimal2 = 6;
                    break;
                case 3: // micron
                    m_fMMToUnitValue = 1000;
                    m_fMMToUnitValueArea = 1000000;
                    m_intDecimal = 2;
                    m_intDecimal2 = 2;
                    break;
            }
        }

        /// <summary>
        /// Define pitch gap
        /// </summary>
        /// <param name="intPitchGapIndex">pitch gap index</param>
        /// <param name="intFromLeadNo">from Lead no</param>
        /// <param name="intToLeadNo">to Lead no</param>
        public void SetPitchGap(int intPitchGapIndex, int intFromLeadNo, int intToLeadNo)
        {
            int intFromNo, intToNo;
            if (intFromLeadNo < intToLeadNo)
            {
                intFromNo = intFromLeadNo;
                intToNo = intToLeadNo;
            }
            else
            {
                intFromNo = intToLeadNo;
                intToNo = intFromLeadNo;
            }

            if (DefinePitchGap(intPitchGapIndex, intFromNo, intToNo))
            {

                if ((intFromLeadNo > intToLeadNo) && !CheckPitchGapLinkInLeadAlready(intToLeadNo))
                {
                    m_stcPitchGap.intFromLeadNo = intToLeadNo;
                    m_stcPitchGap.intToLeadNo = intFromLeadNo;
                }
                else
                {
                    m_stcPitchGap.intFromLeadNo = intFromLeadNo;
                    m_stcPitchGap.intToLeadNo = intToLeadNo;
                }

                if (intPitchGapIndex < m_arrPitchGap.Count)
                {
                    m_arrPitchGap.RemoveAt(intPitchGapIndex);
                    m_arrPitchGap.Insert(intPitchGapIndex, m_stcPitchGap);
                }
                else
                {
                    m_arrPitchGap.Insert(intPitchGapIndex, m_stcPitchGap);
                }
            }

        }
        public void SetPitchGap(int intFromLeadNo, int intToLeadNo)
        {
            int intPitchGapIndex = -1;
            for (int i = 0; i < m_arrPitchGap.Count; i++)
            {
                if (intFromLeadNo == m_arrPitchGap[i].intFromLeadNo)
                    intPitchGapIndex = i;
            }

            if (intToLeadNo < 0) // Mean User set to NA 
            {
                if (intPitchGapIndex >= 0 && intPitchGapIndex < m_arrPitchGap.Count)
                    m_arrPitchGap.RemoveAt(intPitchGapIndex);
            }
            else
            {

                int intFromNo, intToNo;
                if (intFromLeadNo < intToLeadNo)
                {
                    intFromNo = intFromLeadNo;
                    intToNo = intToLeadNo;
                }
                else
                {
                    intFromNo = intToLeadNo;
                    intToNo = intFromLeadNo;
                }

                if (DefinePitchGap(m_arrPitchGap.Count, intFromNo, intToNo))
                {

                    if ((intFromLeadNo > intToLeadNo) && !CheckPitchGapLinkInLeadAlready(intToLeadNo))
                    {
                        m_stcPitchGap.intFromLeadNo = intToLeadNo;
                        m_stcPitchGap.intToLeadNo = intFromLeadNo;
                    }
                    else
                    {
                        m_stcPitchGap.intFromLeadNo = intFromLeadNo;
                        m_stcPitchGap.intToLeadNo = intToLeadNo;
                    }

                    //if (intPitchGapIndex < m_arrPitchGap.Count)
                    if (intPitchGapIndex < 0)
                    {
                        m_arrPitchGap.Insert(m_arrPitchGap.Count, m_stcPitchGap);
                    }
                    else
                    {
                        m_arrPitchGap.RemoveAt(intPitchGapIndex);
                        m_arrPitchGap.Insert(intPitchGapIndex, m_stcPitchGap);
                    }
                }
            }
        }
        /// <summary>
        /// Set min pitch, max pitch, min gap, max gap into certain pitch gap
        /// </summary>
        /// <param name="intPitchGapIndex">pitch gap index</param>
        /// <param name="fMinPitch">min pitch</param>
        /// <param name="fMaxPitch">max pitch</param>
        /// <param name="fMinGap">min gap</param>
        /// <param name="fMaxGap">max gap</param>
        public void SetPitchGapData(int intPitchGapIndex, int intFromLeadNo, int intToLeadNo, float fMinPitch, float fMaxPitch, float fMinGap, float fMaxGap)
        {
            // Get pitch gap array index. (Note: Pitch gap array not sequential with template array)
            int i;
            for (i = 0; i < m_arrPitchGap.Count; i++)
            {
                //if (m_arrPitchGap[intPitchGapIndex].intFromLeadNo == intPitchGapIndex)
                if (m_arrPitchGap[i].intFromLeadNo == intFromLeadNo &&
                    m_arrPitchGap[i].intToLeadNo == intToLeadNo)
                {
                    intPitchGapIndex = i;
                    break;
                }
            }

            // return if index not found
            if (i == m_arrPitchGap.Count)
                return;

            // Update pitch gap with latest information
            m_stcPitchGap = m_arrPitchGap[intPitchGapIndex];
            m_stcPitchGap.fMinPitch = fMinPitch / m_fMMToUnitValue;
            m_stcPitchGap.fMaxPitch = fMaxPitch / m_fMMToUnitValue;
            m_stcPitchGap.fMinGap = fMinGap / m_fMMToUnitValue;
            m_stcPitchGap.fMaxGap = fMaxGap / m_fMMToUnitValue;
            m_arrPitchGap.RemoveAt(i);
            m_arrPitchGap.Insert(i, m_stcPitchGap);

        }

        /// <summary>
        /// Set min pitch, max pitch, min gap, max gap into certain pitch gap
        /// </summary>
        /// <param name="intPitchGapIndex">pitch gap index</param>
        /// <param name="fMinPitch">min pitch</param>
        /// <param name="fMaxPitch">max pitch</param>
        /// <param name="fMinGap">min gap</param>
        /// <param name="fMaxGap">max gap</param>
        public void SetPitchGapDataFrom(int intPitchGapIndex, float fMinPitch, float fMaxPitch, float fMinGap, float fMaxGap)
        {
            for (int i = 0; i < m_arrPitchGap.Count; i++)
            {
                if (intPitchGapIndex == m_arrPitchGap[i].intFromLeadNo)
                {
                    m_stcPitchGap = m_arrPitchGap[i];
                    m_stcPitchGap.fMinPitch = fMinPitch / m_fMMToUnitValue;
                    m_stcPitchGap.fMaxPitch = fMaxPitch / m_fMMToUnitValue;
                    m_stcPitchGap.fMinGap = fMinGap / m_fMMToUnitValue;
                    m_stcPitchGap.fMaxGap = fMaxGap / m_fMMToUnitValue;

                    m_arrPitchGap.RemoveAt(i);
                    m_arrPitchGap.Insert(i, m_stcPitchGap);

                }
            }
        }

        public void SaveLead(string strPath, bool blnNewFile, string strSectionName, bool blnNewSection)
        {
            XmlParser objFile = new XmlParser(strPath, blnNewFile);

            objFile.WriteSectionElement(strSectionName, blnNewSection);

            ////objFile.WriteElement1Value("OrientSetting", true);
            ////objFile.WriteElement2Value("MatchMinScore", m_smVisionInfo.g_arrLeadOrient[i].ref_fMinScore);

            // Save LeadSetting
            objFile.WriteElement1Value("LeadSetting", "");

            objFile.WriteElement2Value("WantInspectBaseLead", m_blnWantInspectBaseLead); 

            objFile.WriteElement2Value("WantInspectLead", m_blnInspectLead);

            objFile.WriteElement2Value("MaskThickness", m_intMaskThickness);
            objFile.WriteElement2Value("LineOffset", m_intLineOffset);

            objFile.WriteElement2Value("ImageViewNo", m_intImageViewNo);
            objFile.WriteElement2Value("BaseLeadImageViewNo", m_intBaseLeadImageViewNo); 
            objFile.WriteElement2Value("ThresholdValue", m_intThresholdValue);
            objFile.WriteElement2Value("ThresholdValue_BaseLead", m_intThresholdValue_BaseLead); 
            //objFile.WriteElement2Value("LeadDirection", m_intLeadDirection);
            objFile.WriteElement2Value("NumberOfLead", m_intNumberOfLead);
            objFile.WriteElement2Value("LeadSelected", m_blnSelected);
            objFile.WriteElement2Value("MinArea", m_intFilterMinArea);
            objFile.WriteElement2Value("MinArea_BaseLead", m_intFilterMinArea_BaseLead); 
            objFile.WriteElement2Value("FailMask", m_intFailOptionMask);
            objFile.WriteElement2Value("LeadStartX", m_fLeadRangeStartX);
            objFile.WriteElement2Value("LeadStartY", m_fLeadRangeStartY);
            objFile.WriteElement2Value("LeadEndX", m_fLeadRangeEndX);
            objFile.WriteElement2Value("LeadEndY", m_fLeadRangeEndY);
            objFile.WriteElement2Value("ReferencePointStartX", m_fReferencePointStartX);
            objFile.WriteElement2Value("ReferencePointStartY", m_fReferencePointStartY);
            objFile.WriteElement2Value("ReferencePointEndX", m_fReferencePointEndX);
            objFile.WriteElement2Value("ReferencePointEndY", m_fReferencePointEndY);
            objFile.WriteElement2Value("LeadMinSpanStart", m_fLeadMinSpanStart);
            objFile.WriteElement2Value("LeadMaxSpanStart", m_fLeadMaxSpanStart);
            objFile.WriteElement2Value("LeadMinSpanEnd", m_fLeadMinSpanEnd);
            objFile.WriteElement2Value("LeadMaxSpanEnd", m_fLeadMaxSpanEnd);
            objFile.WriteElement2Value("ExtraLeadSetArea", m_fExtraLeadSetArea);
            objFile.WriteElement2Value("TotalExtraLeadSetArea", m_fTotalExtraLeadSetArea);
            objFile.WriteElement2Value("ExtraLeadSetLength", m_fExtraLeadSetLength);
            objFile.WriteElement2Value("TemplateLengthVarianceMaxLimit", m_fTemplateLengthVarianceMaxLimit);
            objFile.WriteElement2Value("TemplateLeadMinSpanLimit", m_fTemplateLeadMinSpanLimit);
            objFile.WriteElement2Value("TemplateLeadMaxSpanLimit", m_fTemplateLeadMaxSpanLimit);
            objFile.WriteElement2Value("WantUseGaugeMeasureLeadDimension", m_blnWantUseGaugeMeasureLeadDimension);
            objFile.WriteElement2Value("WantUsePkgToBaseTolerance", m_blnWantUsePkgToBaseTolerance);
            objFile.WriteElement2Value("WantUseAverageGrayValueMethod", m_blnWantUseAverageGrayValueMethod);
            objFile.WriteElement2Value("WantPocketDontCareAreaFix_Lead", m_blnWantPocketDontCareAreaFix_Lead);
            objFile.WriteElement2Value("WantPocketDontCareAreaManual_Lead", m_blnWantPocketDontCareAreaManual_Lead);
            objFile.WriteElement2Value("WantPocketDontCareAreaAuto_Lead", m_blnWantPocketDontCareAreaAuto_Lead);
            objFile.WriteElement2Value("WantPocketDontCareAreaBlob_Lead", m_blnWantPocketDontCareAreaBlob_Lead);
            objFile.WriteElement2Value("PocketDontCareMethod", m_intPocketDontCareMethod);
            objFile.WriteElement2Value("WantCheckExtraLeadLength", m_blnWantCheckExtraLeadLength);
            objFile.WriteElement2Value("WantCheckExtraLeadArea", m_blnWantCheckExtraLeadArea);
            objFile.WriteElement2Value("WantUseAGVMasking", m_blnWantUseAGVMasking); 
            objFile.WriteElement2Value("RotationMethod", m_intRotationMethod);
            objFile.WriteElement2Value("LeadAngleTolerance", m_intLeadAngleTolerance);

            objFile.WriteElement2Value("PkgToBaseTolerance_Top", m_intPkgToBaseTolerance_Top);
            objFile.WriteElement2Value("PkgToBaseTolerance_Right", m_intPkgToBaseTolerance_Right);
            objFile.WriteElement2Value("PkgToBaseTolerance_Bottom", m_intPkgToBaseTolerance_Bottom);
            objFile.WriteElement2Value("PkgToBaseTolerance_Left", m_intPkgToBaseTolerance_Left);

            objFile.WriteElement2Value("ManualPocketReferenceOffsetX", m_fManualPocketReferenceOffsetX);
            objFile.WriteElement2Value("ManualPocketReferenceOffsetY", m_fManualPocketReferenceOffsetY);
            objFile.WriteElement2Value("AutoPocketReferenceOffsetX", m_fAutoPocketReferenceOffsetX);
            objFile.WriteElement2Value("AutoPocketReferenceOffsetY", m_fAutoPocketReferenceOffsetY);

            objFile.WriteElement2Value("PatternROIOffsetX", m_fPatternROIOffsetX);
            objFile.WriteElement2Value("PatternROIOffsetY", m_fPatternROIOffsetY);

            objFile.WriteElement2Value("LeadROITolerance_Top", m_intLeadROITolerance_Top);
            objFile.WriteElement2Value("LeadROITolerance_Right", m_intLeadROITolerance_Right);
            objFile.WriteElement2Value("LeadROITolerance_Bottom", m_intLeadROITolerance_Bottom);
            objFile.WriteElement2Value("LeadROITolerance_Left", m_intLeadROITolerance_Left);

            objFile.WriteElement2Value("FlipToOppositeFunction", m_blnFlipToOppositeFunction);
            objFile.WriteElement2Value("DontCareBlobThreshold", m_intDontCareBlobThreshold);
            objFile.WriteElement2Value("MinShadowArea", m_intMinShadowArea);
            objFile.WriteElement2Value("MaxShadowArea", m_intMaxShadowArea);
            objFile.WriteElement2Value("MaxShadowWidth", m_intMaxShadowWidth);
            objFile.WriteElement2Value("DontCareBlobROIInward", m_intDontCareBlobROIInward);

            //objFile.WriteElement2Value("BaseOffset", m_intBaseOffset);
            //objFile.WriteElement2Value("TipOffset", m_intTipOffset);
            objFile.WriteElement2Value("ClockWise", m_blnClockWise);
            objFile.WriteElement2Value("Lead1", m_intFirstLead);

            // Save BlobsFeatures
            string strBlobsFeatures = GetBlobsFeaturesAllData();
            string[] strFeature = strBlobsFeatures.Split('#');
            int intBlobsCount = GetBlobsFeaturesNumber();
            int intFeatureIndex = 0;
            int intContourLength = 0;
            objFile.WriteElement2Value("BlobsFeaturesCount", intBlobsCount);
            for (int v = 0; v < intBlobsCount; v++)
            {
                objFile.WriteElement1Value("BlobsFeatures" + v, "");
                objFile.WriteElement2Value("NoID", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("GroupNo", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("Area", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("LengthMode", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("ContourX", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("ContourY", strFeature[intFeatureIndex++]);

                intContourLength = Convert.ToInt32(strFeature[intFeatureIndex]);
                objFile.WriteElement2Value("ContourLength", strFeature[intFeatureIndex++]);

                for (int j = 0; j < intContourLength; j++)
                {
                    objFile.WriteElement2Value("ContourX" + j.ToString(), strFeature[intFeatureIndex++]);
                    objFile.WriteElement2Value("ContourY" + j.ToString(), strFeature[intFeatureIndex++]);
                }

                objFile.WriteElement2Value("StartX", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("StartY", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("EndX", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("EndY", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("fStartX", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("fStartY", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("fEndX", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("fEndY", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("Direction", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("LeadSide", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("GravityCenterX", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("GravityCenterY", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("LimitCenterX", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("LimitCenterY", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("Width", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("Height", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("BaseWidth", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("BaseHeight", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("BaseCenterX", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("BaseCenterY", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("TipWidth", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("TipHeight", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("TipCenterX", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("TipCenterY", strFeature[intFeatureIndex++]);

                if (strFeature[intFeatureIndex++] == "True")
                    objFile.WriteElement2Value("Selected", true);
                else
                    objFile.WriteElement2Value("Selected", false);
                objFile.WriteElement2Value("LeftDistance", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("RightDistance", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("TopDistance", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("BottomDistance", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("XDistance", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("YDistance", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("Pitch", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("Gap", strFeature[intFeatureIndex++]);

                objFile.WriteElement2Value("OffSet", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("Skew", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("MinWidth", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("MaxWidth", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("MinHeight", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("MaxHeight", strFeature[intFeatureIndex++]);

                objFile.WriteElement2Value("MinBaseWidth", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("MaxBaseWidth", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("MinBaseHeight", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("MaxBaseHeight", strFeature[intFeatureIndex++]);

                objFile.WriteElement2Value("MinTipWidth", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("MaxTipWidth", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("MinTipHeight", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("MaxTipHeight", strFeature[intFeatureIndex++]);

                objFile.WriteElement2Value("MinPitch", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("MaxPitch", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("MinGap", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("MaxGap", strFeature[intFeatureIndex++]);

                objFile.WriteElement2Value("Variance", strFeature[intFeatureIndex++]);

                objFile.WriteElement2Value("MinAGV", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("MaxAGV", strFeature[intFeatureIndex++]);

                objFile.WriteElement2Value("BaseInwardOffset", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("TipInwardOffset", strFeature[intFeatureIndex++]);

                objFile.WriteElement2Value("AGVROITolerance_Top", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("AGVROITolerance_Right", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("AGVROITolerance_Bottom", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("AGVROITolerance_Left", strFeature[intFeatureIndex++]);

                objFile.WriteElement2Value("WidthOffset", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("LengthOffset", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("PitchOffset", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("GapOffset", strFeature[intFeatureIndex++]);

            }

            // Save BlobsFeatures For Base Lead
            string strBlobsFeatures_BaseLead = GetBlobsFeaturesAllData_BaseLead();
            string[] strFeature_BaseLead = strBlobsFeatures_BaseLead.Split('#');
            int intBlobsCount_BaseLead = GetBlobsFeaturesNumber_BaseLead();
            int intFeatureIndex_BaseLead = 0;
            int intContourLength_BaseLead = 0;
            objFile.WriteElement2Value("BlobsFeaturesCount_BaseLead", intBlobsCount_BaseLead);
            for (int v = 0; v < intBlobsCount_BaseLead; v++)
            {
                objFile.WriteElement1Value("BlobsFeatures_BaseLead" + v, "");
                objFile.WriteElement2Value("NoID", strFeature_BaseLead[intFeatureIndex_BaseLead++]);
                objFile.WriteElement2Value("GroupNo", strFeature_BaseLead[intFeatureIndex_BaseLead++]);
                objFile.WriteElement2Value("Area", strFeature_BaseLead[intFeatureIndex_BaseLead++]);
                objFile.WriteElement2Value("LengthMode", strFeature_BaseLead[intFeatureIndex_BaseLead++]);
                objFile.WriteElement2Value("ContourX", strFeature_BaseLead[intFeatureIndex_BaseLead++]);
                objFile.WriteElement2Value("ContourY", strFeature_BaseLead[intFeatureIndex_BaseLead++]);

                intContourLength_BaseLead = Convert.ToInt32(strFeature_BaseLead[intFeatureIndex_BaseLead]);
                objFile.WriteElement2Value("ContourLength", strFeature_BaseLead[intFeatureIndex_BaseLead++]);

                for (int j = 0; j < intContourLength_BaseLead; j++)
                {
                    objFile.WriteElement2Value("ContourX" + j.ToString(), strFeature_BaseLead[intFeatureIndex_BaseLead++]);
                    objFile.WriteElement2Value("ContourY" + j.ToString(), strFeature_BaseLead[intFeatureIndex_BaseLead++]);
                }

                objFile.WriteElement2Value("StartX", strFeature_BaseLead[intFeatureIndex_BaseLead++]);
                objFile.WriteElement2Value("StartY", strFeature_BaseLead[intFeatureIndex_BaseLead++]);
                objFile.WriteElement2Value("EndX", strFeature_BaseLead[intFeatureIndex_BaseLead++]);
                objFile.WriteElement2Value("EndY", strFeature_BaseLead[intFeatureIndex_BaseLead++]);
                objFile.WriteElement2Value("fStartX", strFeature_BaseLead[intFeatureIndex_BaseLead++]);
                objFile.WriteElement2Value("fStartY", strFeature_BaseLead[intFeatureIndex_BaseLead++]);
                objFile.WriteElement2Value("fEndX", strFeature_BaseLead[intFeatureIndex_BaseLead++]);
                objFile.WriteElement2Value("fEndY", strFeature_BaseLead[intFeatureIndex_BaseLead++]);
                objFile.WriteElement2Value("Direction", strFeature_BaseLead[intFeatureIndex_BaseLead++]);
                objFile.WriteElement2Value("LeadSide", strFeature_BaseLead[intFeatureIndex_BaseLead++]);
                objFile.WriteElement2Value("GravityCenterX", strFeature_BaseLead[intFeatureIndex_BaseLead++]);
                objFile.WriteElement2Value("GravityCenterY", strFeature_BaseLead[intFeatureIndex_BaseLead++]);
                objFile.WriteElement2Value("LimitCenterX", strFeature_BaseLead[intFeatureIndex_BaseLead++]);
                objFile.WriteElement2Value("LimitCenterY", strFeature_BaseLead[intFeatureIndex_BaseLead++]);
                objFile.WriteElement2Value("Width", strFeature_BaseLead[intFeatureIndex_BaseLead++]);
                objFile.WriteElement2Value("Height", strFeature_BaseLead[intFeatureIndex_BaseLead++]);
                objFile.WriteElement2Value("BaseWidth", strFeature_BaseLead[intFeatureIndex_BaseLead++]);
                objFile.WriteElement2Value("BaseHeight", strFeature_BaseLead[intFeatureIndex_BaseLead++]);
                objFile.WriteElement2Value("BaseCenterX", strFeature_BaseLead[intFeatureIndex_BaseLead++]);
                objFile.WriteElement2Value("BaseCenterY", strFeature_BaseLead[intFeatureIndex_BaseLead++]);
                objFile.WriteElement2Value("TipWidth", strFeature_BaseLead[intFeatureIndex_BaseLead++]);
                objFile.WriteElement2Value("TipHeight", strFeature_BaseLead[intFeatureIndex_BaseLead++]);
                objFile.WriteElement2Value("TipCenterX", strFeature_BaseLead[intFeatureIndex_BaseLead++]);
                objFile.WriteElement2Value("TipCenterY", strFeature_BaseLead[intFeatureIndex_BaseLead++]);

                if (strFeature_BaseLead[intFeatureIndex_BaseLead++] == "True")
                    objFile.WriteElement2Value("Selected", true);
                else
                    objFile.WriteElement2Value("Selected", false);
                objFile.WriteElement2Value("LeftDistance", strFeature_BaseLead[intFeatureIndex_BaseLead++]);
                objFile.WriteElement2Value("RightDistance", strFeature_BaseLead[intFeatureIndex_BaseLead++]);
                objFile.WriteElement2Value("TopDistance", strFeature_BaseLead[intFeatureIndex_BaseLead++]);
                objFile.WriteElement2Value("BottomDistance", strFeature_BaseLead[intFeatureIndex_BaseLead++]);
                objFile.WriteElement2Value("XDistance", strFeature_BaseLead[intFeatureIndex_BaseLead++]);
                objFile.WriteElement2Value("YDistance", strFeature_BaseLead[intFeatureIndex_BaseLead++]);

                objFile.WriteElement2Value("MaxBaseOffset", strFeature_BaseLead[intFeatureIndex_BaseLead++]);

                objFile.WriteElement2Value("MinBaseArea", strFeature_BaseLead[intFeatureIndex_BaseLead++]);
                objFile.WriteElement2Value("MaxBaseArea", strFeature_BaseLead[intFeatureIndex_BaseLead++]);

            }

            int intIndex = 0;
            string strPitchGapData;
            string[] strPitchGapDataRow;
            int intTotalPitchGap = GetTotalPitchGap();
            objFile.WriteElement2Value("PitchGapCount", intTotalPitchGap);
            for (int q = 0; q < intTotalPitchGap; q++)
            {
                intIndex = 0;
                strPitchGapData = GetMicronPitchGapData(q);
                strPitchGapDataRow = strPitchGapData.Split('#');

                objFile.WriteElement1Value("PitchGap" + q, "");
                objFile.WriteElement2Value("FromLeadNo", strPitchGapDataRow[intIndex++]);
                objFile.WriteElement2Value("ToLeadNo", strPitchGapDataRow[intIndex++]);
                objFile.WriteElement2Value("MinPitch", strPitchGapDataRow[intIndex++]);
                objFile.WriteElement2Value("MaxPitch", strPitchGapDataRow[intIndex++]);
                objFile.WriteElement2Value("MinGap", strPitchGapDataRow[intIndex++]);
                objFile.WriteElement2Value("MaxGap", strPitchGapDataRow[intIndex++]);
                objFile.WriteElement2Value("Gap", strPitchGapDataRow[intIndex++]);
                objFile.WriteElement2Value("Pitch", strPitchGapDataRow[intIndex++]);
                objFile.WriteElement2Value("StartX", strPitchGapDataRow[intIndex++]);
                objFile.WriteElement2Value("StartY", strPitchGapDataRow[intIndex++]);
                objFile.WriteElement2Value("EndX", strPitchGapDataRow[intIndex++]);
                objFile.WriteElement2Value("EndY", strPitchGapDataRow[intIndex++]);
                objFile.WriteElement2Value("Direction", strPitchGapDataRow[intIndex++]);
            }

            objFile.WriteElement2Value("UnitWidth", m_fUnitWidth);
            objFile.WriteElement2Value("UnitHeight", m_fUnitHeight);
            objFile.WriteElement2Value("UnitThickness", m_fUnitThickness);
            objFile.WriteElement2Value("UnitWidthMin", m_fUnitWidthMin);
            objFile.WriteElement2Value("UnitWidthMax", m_fUnitWidthMax);
            objFile.WriteElement2Value("UnitHeightMin", m_fUnitHeightMin);
            objFile.WriteElement2Value("UnitHeightMax", m_fUnitHeightMax);
            objFile.WriteElement2Value("UnitThicknessMin", m_fUnitThicknessMin);
            objFile.WriteElement2Value("UnitThicknessMax", m_fUnitThicknessMax);

            objFile.WriteElement2Value("UnitSizeLength", m_fUnitSizeLength);
            objFile.WriteElement2Value("CrackLength", m_fCrackLength);
            objFile.WriteElement2Value("ScratchLength", m_fScratchLength);
            objFile.WriteElement2Value("ContaminationLength", m_fContaminationLength);
            objFile.WriteElement2Value("SolderMeltLength", m_fSolderMeltLength);
            objFile.WriteElement2Value("VoidLength", m_fVoidLength);
            objFile.WriteElement2Value("MoldFlashLength", m_fMoldFlashLength);
            objFile.WriteElement2Value("InCompletePlateLength", m_fInCompletePlateLength);
            objFile.WriteElement2Value("LeadBrokenLength", m_fLeadBrokenLength);


            objFile.WriteElement2Value("MPTolerance", m_intMPTolerance);

            objFile.WriteEndElement();
        }

        public void SaveLead_SECSGEM(string strPath, string strSectionName, string strVisionName, bool blnSECSGEMFileExist, int intSECSGEMMaxNoOfCoplanPad)
        {
            //XmlParser objFile = new XmlParser(strPath, blnNewFile);

            //objFile.WriteSectionElement(strSectionName, blnNewSection);

            ////objFile.WriteElement1Value("OrientSetting", true);
            ////objFile.WriteElement2Value("MatchMinScore", m_smVisionInfo.g_arrLeadOrient[i].ref_fMinScore);

            XmlParser objFile = new XmlParser(strPath, "SECSGEMData");
            objFile.WriteRootElement("SECSGEMData");

            // Save LeadSetting
            //objFile.WriteElement1Value("LeadSetting", "");

            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_WantInspectBaseLead", m_blnWantInspectBaseLead); 

            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_WantInspectLead", m_blnInspectLead);

            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_MaskThickness", m_intMaskThickness);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_LineOffset", m_intLineOffset);

            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_ImageViewNo", m_intImageViewNo);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_BaseLeadImageViewNo", m_intBaseLeadImageViewNo); 
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_ThresholdValue", m_intThresholdValue);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_ThresholdValue_BaseLead", m_intThresholdValue_BaseLead); 
            //objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_LeadDirection", m_intLeadDirection);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_NumberOfLead", m_intNumberOfLead);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_LeadSelected", m_blnSelected);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_MinArea", m_intFilterMinArea);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_MinArea_BaseLead", m_intFilterMinArea_BaseLead); 
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_FailMask", m_intFailOptionMask);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_LeadStartX", m_fLeadRangeStartX);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_LeadStartY", m_fLeadRangeStartY);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_LeadEndX", m_fLeadRangeEndX);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_LeadEndY", m_fLeadRangeEndY);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_ReferencePointStartX", m_fReferencePointStartX);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_ReferencePointStartY", m_fReferencePointStartY);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_ReferencePointEndX", m_fReferencePointEndX);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_ReferencePointEndY", m_fReferencePointEndY);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_LeadMinSpanStart", m_fLeadMinSpanStart);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_LeadMaxSpanStart", m_fLeadMaxSpanStart);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_LeadMinSpanEnd", m_fLeadMinSpanEnd);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_LeadMaxSpanEnd", m_fLeadMaxSpanEnd);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_ExtraLeadSetArea", m_fExtraLeadSetArea);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_TotalExtraLeadSetArea", m_fTotalExtraLeadSetArea);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_ExtraLeadSetLength", m_fExtraLeadSetLength);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_TemplateLeadMinSpanLimit", m_fTemplateLeadMinSpanLimit);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_TemplateLeadMaxSpanLimit", m_fTemplateLeadMaxSpanLimit);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_WantUseGaugeMeasureLeadDimension", m_blnWantUseGaugeMeasureLeadDimension);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_WantUseAverageGrayValueMethod", m_blnWantUseAverageGrayValueMethod);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_WantPocketDontCareAreaFix_Lead", m_blnWantPocketDontCareAreaFix_Lead);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_WantPocketDontCareAreaManual_Lead", m_blnWantPocketDontCareAreaManual_Lead);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_WantPocketDontCareAreaAuto_Lead", m_blnWantPocketDontCareAreaAuto_Lead);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_WantPocketDontCareAreaBlob_Lead", m_blnWantPocketDontCareAreaBlob_Lead);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_PocketDontCareMethod", m_intPocketDontCareMethod);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_WantUseAGVMasking", m_blnWantUseAGVMasking); 
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_WantUsePkgToBaseTolerance", m_blnWantUsePkgToBaseTolerance);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_WantCheckExtraLeadLength", m_blnWantCheckExtraLeadLength);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_WantCheckExtraLeadArea", m_blnWantCheckExtraLeadArea);

            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_RotationMethod", m_intRotationMethod);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_LeadAngleTolerance", m_intLeadAngleTolerance);

            //objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_BaseOffset", m_intBaseOffset);
            //objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_TipOffset", m_intTipOffset);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_ClockWise", m_blnClockWise);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_Lead1", m_intFirstLead);

            // Save BlobsFeatures
            string strBlobsFeatures = GetBlobsFeaturesAllData();
            string[] strFeature = strBlobsFeatures.Split('#');
            int intBlobsCount = GetBlobsFeaturesNumber();
            int intFeatureIndex = 0;
            int intContourLength = 0;
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_BlobsFeaturesCount", intBlobsCount);
            for (int v = 0; v < intSECSGEMMaxNoOfCoplanPad; v++)
            {
                if (intBlobsCount > v)
                {
                    //objFile.WriteElement1Value("BlobsFeatures" + v, "");
                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_NoID", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_GroupNo", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_Area", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_LengthMode", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_ContourX", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_ContourY", strFeature[intFeatureIndex++]);

                    //intContourLength = Convert.ToInt32(strFeature[intFeatureIndex]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_ContourLength", strFeature[intFeatureIndex++]);

                    //for (int j = 0; j < 10; j++)
                    //{
                    //    if (intContourLength > j)
                    //    {
                    //        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_ContourX" + j.ToString(), strFeature[intFeatureIndex++]);
                    //        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_ContourY" + j.ToString(), strFeature[intFeatureIndex++]);
                    //    }
                    //    else
                    //    {
                    //        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_ContourX" + j.ToString(), "NA");
                    //        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_ContourY" + j.ToString(), "NA");
                    //    }
                    //}

                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_StartX", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_StartY", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_EndX", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_EndY", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_fStartX", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_fStartY", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_fEndX", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_fEndY", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_Direction", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_LeadSide", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_GravityCenterX", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_GravityCenterY", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_LimitCenterX", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_LimitCenterY", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_Width", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_Height", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_BaseWidth", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_BaseHeight", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_BaseCenterX", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_BaseCenterY", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_TipWidth", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_TipHeight", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_TipCenterX", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_TipCenterY", strFeature[intFeatureIndex++]);

                    if (strFeature[intFeatureIndex++] == "True")
                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_Selected", true);
                    else
                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_Selected", false);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_LeftDistance", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_RightDistance", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_TopDistance", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_BottomDistance", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_XDistance", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_YDistance", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_Pitch", strFeature[intFeatureIndex++]);

                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_OffSet", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinWidth", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxWidth", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinHeight", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxHeight", strFeature[intFeatureIndex++]);

                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinBaseWidth", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxBaseWidth", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinBaseHeight", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxBaseHeight", strFeature[intFeatureIndex++]);

                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinTipWidth", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxTipWidth", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinTipHeight", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxTipHeight", strFeature[intFeatureIndex++]);

                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinPitch", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxPitch", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinGap", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxGap", strFeature[intFeatureIndex++]);

                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_Variance", strFeature[intFeatureIndex++]);

                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinAGV", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxAGV", strFeature[intFeatureIndex++]);

                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_BaseInwardOffset", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_TipInwardOffset", strFeature[intFeatureIndex++]);

                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_AGVROITolerance_Top", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_AGVROITolerance_Right", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_AGVROITolerance_Bottom", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_AGVROITolerance_Left", strFeature[intFeatureIndex++]);

                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_WidthOffset", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_LengthOffset", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PitchOffset", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_GapOffset", strFeature[intFeatureIndex++]);
                    
                }
                else
                {
                    if (!blnSECSGEMFileExist)
                    {
                        //objFile.WriteElement1Value("BlobsFeatures" + v, "");
                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_NoID", "NA");
                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_GroupNo", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_Area", "NA");
                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_LengthMode", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_ContourX", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_ContourY", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_ContourLength", "NA");

                        //for (int j = 0; j < 10; j++)
                        //{
                        //    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_ContourX" + j.ToString(), "NA");
                        //    objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_ContourY" + j.ToString(), "NA");
                        //}

                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_StartX", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_StartY", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_EndX", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_EndY", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_fStartX", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_fStartY", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_fEndX", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_fEndY", "NA");
                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_Direction", "NA");
                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_LeadSide", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_GravityCenterX", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_GravityCenterY", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_LimitCenterX", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_LimitCenterY", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_Width", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_Height", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_BaseWidth", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_BaseHeight", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_BaseCenterX", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_BaseCenterY", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_TipWidth", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_TipHeight", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_TipCenterX", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_TipCenterY", "NA");

                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_Selected", "NA");

                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_LeftDistance", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_RightDistance", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_TopDistance", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_BottomDistance", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_XDistance", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_YDistance", "NA");
                        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_Pitch", "NA");

                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_OffSet", "NA");
                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinWidth", "NA");
                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxWidth", "NA");
                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinHeight", "NA");
                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxHeight", "NA");

                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinBaseWidth", "NA");
                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxBaseWidth", "NA");
                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinBaseHeight", "NA");
                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxBaseHeight", "NA");

                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinTipWidth", "NA");
                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxTipWidth", "NA");
                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinTipHeight", "NA");
                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxTipHeight", "NA");

                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinPitch", "NA");
                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxPitch", "NA");
                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinGap", "NA");
                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxGap", "NA");

                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_Variance", "NA");

                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinAGV", "NA");
                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxAGV", "NA");

                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_BaseInwardOffset", "NA");
                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_TipInwardOffset", "NA");

                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_AGVROITolerance_Top", "NA");
                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_AGVROITolerance_Right", "NA");
                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_AGVROITolerance_Bottom", "NA");
                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_AGVROITolerance_Left", "NA");

                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_WidthOffset", "NA");
                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_LengthOffset", "NA");
                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PitchOffset", "NA");
                        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_BlobsFeatures" + v + "_GapOffset", "NA");

                    }
                }
            }

            //int intIndex = 0;
            //string strPitchGapData;
            //string[] strPitchGapDataRow;
            int intTotalPitchGap = GetTotalPitchGap();
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_PitchGapCount", intTotalPitchGap);
            //for (int q = 0; q < 10; q++)
            //{
            //    if (intTotalPitchGap > q)
            //    {
            //        intIndex = 0;
            //        strPitchGapData = GetMicronPitchGapData(q);
            //        strPitchGapDataRow = strPitchGapData.Split('#');

            //        //objFile.WriteElement1Value("PitchGap" + q, "");
            //        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_PitchGap" + q + "_FromLeadNo", strPitchGapDataRow[intIndex++]);
            //        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_PitchGap" + q + "_ToLeadNo", strPitchGapDataRow[intIndex++]);
            //        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_PitchGap" + q + "_MinPitch", strPitchGapDataRow[intIndex++]);
            //        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_PitchGap" + q + "_MaxPitch", strPitchGapDataRow[intIndex++]);
            //        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_PitchGap" + q + "_MinGap", strPitchGapDataRow[intIndex++]);
            //        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_PitchGap" + q + "_MaxGap", strPitchGapDataRow[intIndex++]);
            //        //objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_PitchGap" + q + "_Gap", strPitchGapDataRow[intIndex++]);
            //        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_PitchGap" + q + "_Pitch", strPitchGapDataRow[intIndex++]);
            //        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_PitchGap" + q + "_StartX", strPitchGapDataRow[intIndex++]);
            //        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_PitchGap" + q + "_StartY", strPitchGapDataRow[intIndex++]);
            //        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_PitchGap" + q + "_EndX", strPitchGapDataRow[intIndex++]);
            //        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_PitchGap" + q + "_EndY", strPitchGapDataRow[intIndex++]);
            //        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_PitchGap" + q + "_Direction", strPitchGapDataRow[intIndex++]);
            //    }
            //    else
            //    {
            //        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_PitchGap" + q + "_FromLeadNo", "NA");
            //        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_PitchGap" + q + "_ToLeadNo", "NA");
            //        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_PitchGap" + q + "_MinPitch", "NA");
            //        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_PitchGap" + q + "_MaxPitch", "NA");
            //        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_PitchGap" + q + "_Pitch", "NA");
            //        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_PitchGap" + q + "_StartX", "NA");
            //        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_PitchGap" + q + "_StartY", "NA");
            //        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_PitchGap" + q + "_EndX", "NA");
            //        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_PitchGap" + q + "_EndY", "NA");
            //        objFile.WriteElementValue(strVisionName + " _LeadSetting_" + strSectionName + "_PitchGap" + q + "_Direction", "NA");
            //    }
            //}

            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_UnitWidth", m_fUnitWidth);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_UnitHeight", m_fUnitHeight);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_UnitThickness", m_fUnitThickness);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_UnitWidthMin", m_fUnitWidthMin);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_UnitWidthMax", m_fUnitWidthMax);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_UnitHeightMin", m_fUnitHeightMin);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_UnitHeightMax", m_fUnitHeightMax);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_UnitThicknessMin", m_fUnitThicknessMin);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_UnitThicknessMax", m_fUnitThicknessMax);

            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_UnitSizeLength", m_fUnitSizeLength);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_CrackLength", m_fCrackLength);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_ScratchLength", m_fScratchLength);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_ContaminationLength", m_fContaminationLength);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_SolderMeltLength", m_fSolderMeltLength);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_VoidLength", m_fVoidLength);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_MoldFlashLength", m_fMoldFlashLength);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_InCompletePlateLength", m_fInCompletePlateLength);
            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_LeadBrokenLength", m_fLeadBrokenLength);


            objFile.WriteElementValue(strVisionName + "_LeadSetting_" + strSectionName + "_MPTolerance", m_intMPTolerance);

            objFile.WriteEndElement();
        }

        public void SaveLead3D(string strPath, bool blnNewFile, string strSectionName, bool blnNewSection)
        {
            XmlParser objFile = new XmlParser(strPath, blnNewFile);

            objFile.WriteSectionElement(strSectionName, blnNewSection);

            ////objFile.WriteElement1Value("OrientSetting", true);
            ////objFile.WriteElement2Value("MatchMinScore", m_smVisionInfo.g_arrLeadOrient[i].ref_fMinScore);

            // Save LeadSetting
            objFile.WriteElement1Value("LeadSetting", "");
            objFile.WriteElement2Value("ThresholdValue", m_intThresholdValue);
            //objFile.WriteElement2Value("LeadDirection", m_intLeadDirection);
            objFile.WriteElement2Value("NumberOfLead", m_intNumberOfLead);
            objFile.WriteElement2Value("NumberOfLead_Top", m_intNumberOfLead_Top);
            objFile.WriteElement2Value("NumberOfLead_Bottom", m_intNumberOfLead_Bottom);
            objFile.WriteElement2Value("NumberOfLead_Left", m_intNumberOfLead_Left);
            objFile.WriteElement2Value("NumberOfLead_Right", m_intNumberOfLead_Right);
            objFile.WriteElement2Value("LeadSelected", m_blnSelected);
            objFile.WriteElement2Value("MinArea", m_intFilterMinArea);
            objFile.WriteElement2Value("LeadStartX", m_fLeadRangeStartX);
            objFile.WriteElement2Value("LeadStartY", m_fLeadRangeStartY);
            objFile.WriteElement2Value("LeadEndX", m_fLeadRangeEndX);
            objFile.WriteElement2Value("LeadEndY", m_fLeadRangeEndY);
            objFile.WriteElement2Value("ReferencePointStartX", m_fReferencePointStartX);
            objFile.WriteElement2Value("ReferencePointStartY", m_fReferencePointStartY);
            objFile.WriteElement2Value("ReferencePointEndX", m_fReferencePointEndX);
            objFile.WriteElement2Value("ReferencePointEndY", m_fReferencePointEndX);
            //objFile.WriteElement2Value("BaseOffset", m_intBaseOffset);
            //objFile.WriteElement2Value("TipOffset", m_intTipOffset);
            objFile.WriteElement2Value("ClockWise", m_blnClockWise);
            objFile.WriteElement2Value("Lead1", m_intFirstLead);
            objFile.WriteElement2Value("BaseLineTrimFromEdge", m_intBaseLineTrimFromEdge);
            objFile.WriteElement2Value("BaseLineSteps", m_intBaseLineSteps);
            objFile.WriteElement2Value("WhiteOnBlack", m_blnWhiteOnBlack);
            //objFile.WriteElement2Value("FailMask", m_intFailOptionMask);
            //objFile.WriteElement2Value("FailPkgMask", m_intFailPkgOptionMask);

            //objFile.WriteElement2Value("DefaultPixelTolerance", m_fDefaultPixelTolerance);
            //objFile.WriteElement2Value("LeadSizeHalfWidthTolerance", m_intLeadSizeHalfWidthTolerance);
            //objFile.WriteElement2Value("TightSettingThresholdTolerance", m_intTightSettingThresholdTolerance);
            //objFile.WriteElement2Value("TightSettingTolerance", m_fTightSettingTolerance);
            //objFile.WriteElement2Value("SensitivityOnLeadMethod", m_intSensitivityOnLeadMethod);
            //objFile.WriteElement2Value("SensitivityOnLeadValue", m_intSensitivityOnLeadValue);
            //objFile.WriteElement2Value("EmptyMinScore", m_fEmptyMinScore);
            //objFile.WriteElement2Value("UseEmtpyUnitThreshold", m_bUseEmptyUnitThreshold);
            //objFile.WriteElement2Value("WantGaugeMeasurePkgSize", m_blnWantGaugeMeasurePkgSize);
            //objFile.WriteElement2Value("EmptyAreaLimit", m_intEmptyAreaLimit);
            //objFile.WriteElement2Value("EmptyThreshold", m_intEmptyThreshold);
            //objFile.WriteElement2Value("EmptyAreaColorTransition", m_intEmptyAreaColorTransition);
            //objFile.WriteElement2Value("LeadPRSScore", m_fLeadPRSScore);
            //objFile.WriteElement2Value("UnitAngleLimit", m_fUnitAngleLimit);
            //objFile.WriteElement2Value("PosToleranceX", m_fPosToleranceX);
            //objFile.WriteElement2Value("PosToleranceY", m_fPosToleranceY);
            //objFile.WriteElement2Value("ImageGain", m_fImageGain);
            //objFile.WriteElement2Value("GaugeSizeImageIndex", m_intGaugeSizeImageIndex);
            //objFile.WriteElement2Value("CheckLeadDimensionImageIndex", m_intCheckLeadDimensionImageIndex);
            //objFile.WriteElement2Value("WantTightSetting", m_blnWantTightSetting);
            //objFile.WriteElement2Value("WantConsiderLeadImage2", m_blnWantConsiderLeadImage2);
            //objFile.WriteElement2Value("WantPRUnitLocationBeforeGauge", m_blnWantPRUnitLocationBeforeGauge);
            //objFile.WriteElement2Value("WantUseGaugeMeasureDimension", m_blnWantUseGaugeMeasureDimension);
            //objFile.WriteElement2Value("WantUseClosestSizeDefineTolerance", m_blnWantUseClosestSizeDefineTolerance);
            //objFile.WriteElement2Value("WantAutoGauge", m_blnWantAutoGauge);
            //objFile.WriteElement2Value("WantRotateSideLeadImage", m_blnWantRotateSideLeadImage);

            //objFile.WriteElement2Value("WantCheckExtraLeadLength", m_blnWantCheckExtraLeadLength);
            //objFile.WriteElement2Value("WantCheckExtraLeadArea", m_blnWantCheckExtraLeadArea);
            //objFile.WriteElement2Value("WantCheckBrokenLeadLength", m_blnWantCheckBrokenLeadLength);
            //objFile.WriteElement2Value("WantCheckBrokenLeadArea", m_blnWantCheckBrokenLeadArea);
            //objFile.WriteElement2Value("WantCheckExcessLeadLength", m_blnWantCheckExcessLeadLength);
            //objFile.WriteElement2Value("WantCheckExcessLeadArea", m_blnWantCheckExcessLeadArea);

            // Save BlobsFeatures
            string strBlobsFeatures = GetBlobsFeaturesAllData();
            string[] strFeature = strBlobsFeatures.Split('#');
            int intBlobsCount = GetBlobsFeaturesNumber();
            int intFeatureIndex = 0;
            int intContourLength = 0;
            objFile.WriteElement2Value("BlobsFeaturesCount", intBlobsCount);
            for (int v = 0; v < intBlobsCount; v++)
            {
                objFile.WriteElement1Value("BlobsFeatures" + v, "");
                objFile.WriteElement2Value("NoID", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("GroupNo", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("Area", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("LengthMode", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("ContourX", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("ContourY", strFeature[intFeatureIndex++]);

                intContourLength = Convert.ToInt32(strFeature[intFeatureIndex]);
                objFile.WriteElement2Value("ContourLength", strFeature[intFeatureIndex++]);

                for (int j = 0; j < intContourLength; j++)
                {
                    objFile.WriteElement2Value("ContourX" + j.ToString(), strFeature[intFeatureIndex++]);
                    objFile.WriteElement2Value("ContourY" + j.ToString(), strFeature[intFeatureIndex++]);
                }

                objFile.WriteElement2Value("StartX", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("StartY", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("EndX", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("EndY", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("fStartX", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("fStartY", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("fEndX", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("fEndY", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("Direction", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("LeadSide", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("GravityCenterX", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("GravityCenterY", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("LimitCenterX", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("LimitCenterY", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("Width", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("Height", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("BaseWidth", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("BaseHeight", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("BaseCenterX", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("BaseCenterY", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("TipWidth", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("TipHeight", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("TipCenterX", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("TipCenterY", strFeature[intFeatureIndex++]);
                if (strFeature[intFeatureIndex++] == "True")
                    objFile.WriteElement2Value("Selected", true);
                else
                    objFile.WriteElement2Value("Selected", false);
                objFile.WriteElement2Value("LeftDistance", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("RightDistance", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("TopDistance", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("BottomDistance", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("XDistance", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("YDistance", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("Pitch", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("Gap", strFeature[intFeatureIndex++]);

                objFile.WriteElement2Value("OffSet", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("Skew", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("MinWidth", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("MaxWidth", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("MinHeight", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("MaxHeight", strFeature[intFeatureIndex++]);

                objFile.WriteElement2Value("MinBaseWidth", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("MaxBaseWidth", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("MinBaseHeight", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("MaxBaseHeight", strFeature[intFeatureIndex++]);

                objFile.WriteElement2Value("MinTipWidth", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("MaxTipWidth", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("MinTipHeight", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("MaxTipHeight", strFeature[intFeatureIndex++]);

                objFile.WriteElement2Value("MinPitch", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("MaxPitch", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("MinGap", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("MaxGap", strFeature[intFeatureIndex++]);

                objFile.WriteElement2Value("Variance", strFeature[intFeatureIndex++]);

                objFile.WriteElement2Value("MinAGV", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("MaxAGV", strFeature[intFeatureIndex++]);

                objFile.WriteElement2Value("BaseInwardOffset", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("TipInwardOffset", strFeature[intFeatureIndex++]);

                objFile.WriteElement2Value("WidthOffset", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("LengthOffset", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("PitchOffset", strFeature[intFeatureIndex++]);
                objFile.WriteElement2Value("GapOffset", strFeature[intFeatureIndex++]);

            }

            int intIndex = 0;
            string strPitchGapData;
            string[] strPitchGapDataRow;
            int intTotalPitchGap = GetTotalPitchGap();
            objFile.WriteElement2Value("PitchGapCount", intTotalPitchGap);
            for (int q = 0; q < intTotalPitchGap; q++)
            {
                intIndex = 0;
                strPitchGapData = GetMicronPitchGapData(q);
                strPitchGapDataRow = strPitchGapData.Split('#');

                objFile.WriteElement1Value("PitchGap" + q, "");
                objFile.WriteElement2Value("FromLeadNo", strPitchGapDataRow[intIndex++]);
                objFile.WriteElement2Value("ToLeadNo", strPitchGapDataRow[intIndex++]);
                objFile.WriteElement2Value("MinPitch", strPitchGapDataRow[intIndex++]);
                objFile.WriteElement2Value("MaxPitch", strPitchGapDataRow[intIndex++]);
                objFile.WriteElement2Value("MinGap", strPitchGapDataRow[intIndex++]);
                objFile.WriteElement2Value("MaxGap", strPitchGapDataRow[intIndex++]);
                objFile.WriteElement2Value("Gap", strPitchGapDataRow[intIndex++]);
                objFile.WriteElement2Value("Pitch", strPitchGapDataRow[intIndex++]);
                objFile.WriteElement2Value("StartX", strPitchGapDataRow[intIndex++]);
                objFile.WriteElement2Value("StartY", strPitchGapDataRow[intIndex++]);
                objFile.WriteElement2Value("EndX", strPitchGapDataRow[intIndex++]);
                objFile.WriteElement2Value("EndY", strPitchGapDataRow[intIndex++]);
                objFile.WriteElement2Value("Direction", strPitchGapDataRow[intIndex++]);
            }

            objFile.WriteElement2Value("UnitWidth", m_fUnitWidth);
            objFile.WriteElement2Value("UnitHeight", m_fUnitHeight);
            objFile.WriteElement2Value("UnitThickness", m_fUnitThickness);
            objFile.WriteElement2Value("UnitWidthMin", m_fUnitWidthMin);
            objFile.WriteElement2Value("UnitWidthMax", m_fUnitWidthMax);
            objFile.WriteElement2Value("UnitHeightMin", m_fUnitHeightMin);
            objFile.WriteElement2Value("UnitHeightMax", m_fUnitHeightMax);
            objFile.WriteElement2Value("UnitThicknessMin", m_fUnitThicknessMin);
            objFile.WriteElement2Value("UnitThicknessMax", m_fUnitThicknessMax);

            objFile.WriteElement2Value("UnitSizeLength", m_fUnitSizeLength);
            objFile.WriteElement2Value("CrackLength", m_fCrackLength);
            objFile.WriteElement2Value("ScratchLength", m_fScratchLength);
            objFile.WriteElement2Value("ContaminationLength", m_fContaminationLength);
            objFile.WriteElement2Value("SolderMeltLength", m_fSolderMeltLength);
            objFile.WriteElement2Value("VoidLength", m_fVoidLength);
            objFile.WriteElement2Value("MoldFlashLength", m_fMoldFlashLength);
            objFile.WriteElement2Value("InCompletePlateLength", m_fInCompletePlateLength);
            objFile.WriteElement2Value("LeadBrokenLength", m_fLeadBrokenLength);


            objFile.WriteElement2Value("MPTolerance", m_intMPTolerance);

            objFile.WriteEndElement();
        }

        public void SaveLeadTemplateImage(string strFolderPath, ImageDrawing objLearnRotatedImage, ImageDrawing objLearnRotatedImage_BaseLead, List<ROI> arrLeadROIs, int intLeadIndex)
        {
            // Save Template Search ROI Image
            //arrLeadROIs[0].SaveImage(strFolderPath + "SearchROITemplate" + intLeadIndex + ".bmp");
            //arrLeadROIs[2].SaveImage(strFolderPath + "PackageROITemplate" + intLeadIndex + ".bmp");

            // ---------------------- Save Image for package inspection used ----------------------------------------------------------------------------------------------------

            //// Copy learn image to a temporary image memory so that the temporary image can be modified without bother the
            //ImageDrawing objImage = new ImageDrawing();
            //objLearnRotatedImage.CopyTo(ref objImage);
            //ROI objTempROI = new ROI();
            //objTempROI.LoadROISetting(
            //arrLeadROIs[0].ref_ROITotalX,
            //arrLeadROIs[0].ref_ROITotalY,
            //arrLeadROIs[0].ref_ROIWidth,
            //arrLeadROIs[0].ref_ROIHeight);
            //objTempROI.AttachImage(objImage);

            ////Save Dilate Image
            //ImageDrawing.DilateImage(arrLeadROIs[0], ref objTempROI, 2);
            //for (int q = 1; q < arrLeadROIs.Count; q++)
            //{
            //    ROI objDunCare = new ROI();
            //    objDunCare.LoadROISetting(arrLeadROIs[q].ref_ROIPositionX, arrLeadROIs[q].ref_ROIPositionY,
            //                              arrLeadROIs[q].ref_ROIWidth, arrLeadROIs[q].ref_ROIHeight);
            //    objDunCare.AttachImage(objTempROI);
            //    objDunCare.FillROI(255);

            //    objDunCare.Dispose();
            //}

            SaveLeadIndividualImage(strFolderPath, objLearnRotatedImage, arrLeadROIs, intLeadIndex);

            ROI objUnitROI = new ROI();

            objUnitROI.LoadROISetting(
            arrLeadROIs[0].ref_ROITotalX,
            arrLeadROIs[0].ref_ROITotalY,
            arrLeadROIs[0].ref_ROIWidth,
            arrLeadROIs[0].ref_ROIHeight);

            //objUnitROI.LoadROISetting((int)Math.Round(arrLeadROIs[0].ref_ROITotalX + m_fLeadRangeStartX, 0, MidpointRounding.AwayFromZero), (int)Math.Round(arrLeadROIs[0].ref_ROITotalY + m_fLeadRangeStartY, 0, MidpointRounding.AwayFromZero),
            //            (int)Math.Round(m_fLeadRangeEndX - m_fLeadRangeStartX, 0, MidpointRounding.AwayFromZero), (int)Math.Round(m_fLeadRangeEndY - m_fLeadRangeStartY, 0, MidpointRounding.AwayFromZero));
            objUnitROI.AttachImage(objLearnRotatedImage);

            objUnitROI.SaveImage(strFolderPath + "UnitTemplate" + intLeadIndex + ".bmp");

            if (m_blnWantInspectBaseLead)
            {
                objUnitROI.AttachImage(objLearnRotatedImage_BaseLead);

                objUnitROI.SaveImage(strFolderPath + "UnitTemplate_BaseLead" + intLeadIndex + ".bmp");
            }
            ROI objPatternROI = new ROI();
            int MinX = int.MaxValue, MinY = int.MaxValue, MaxX = 0, MaxY = 0;
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                if (((BlobsFeatures)m_arrTemplateBlobLeads[i]).intStartX < MinX)
                    MinX = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).intStartX;

                if (((BlobsFeatures)m_arrTemplateBlobLeads[i]).intStartY < MinY)
                    MinY = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).intStartY;

                if (((BlobsFeatures)m_arrTemplateBlobLeads[i]).intEndX > MaxX)
                    MaxX = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).intEndX;

                if (((BlobsFeatures)m_arrTemplateBlobLeads[i]).intEndY > MaxY)
                    MaxY = ((BlobsFeatures)m_arrTemplateBlobLeads[i]).intEndY;
            }

            if (m_arrTemplateBlobLeads.Count > 0)
            {
                // 2021 08 23 - CCENG: set the pattern size wider 5 pixels will make the pattern matching more stable.
                objPatternROI.LoadROISetting(
                arrLeadROIs[0].ref_ROIPositionX + MinX - 5,
                arrLeadROIs[0].ref_ROIPositionY + MinY - 5,
                MaxX - MinX + 10,
                MaxY - MinY + 10);

                //arrLeadROIs[0].SaveImage("D:\\TS\\arrLeadROI[0].bmp");

                // 2021 08 23 - CCENG: the tolerance value may have negative value if user drag the lead ROI too near to lead. The negative happen bcos of the 5 pixels wider for objPatternROI.
                m_intLeadROITolerance_Top = objPatternROI.ref_ROIPositionY - arrLeadROIs[0].ref_ROIPositionY;
                m_intLeadROITolerance_Right = (arrLeadROIs[0].ref_ROIPositionX + arrLeadROIs[0].ref_ROIWidth) - (objPatternROI.ref_ROIPositionX + objPatternROI.ref_ROIWidth);
                m_intLeadROITolerance_Bottom = (arrLeadROIs[0].ref_ROIPositionY + arrLeadROIs[0].ref_ROIHeight) - (objPatternROI.ref_ROIPositionY + objPatternROI.ref_ROIHeight);
                m_intLeadROITolerance_Left = objPatternROI.ref_ROIPositionX - arrLeadROIs[0].ref_ROIPositionX;

                //m_intLeadROITolerance_Top = MinY;
                //m_intLeadROITolerance_Right = arrLeadROIs[0].ref_ROIWidth - MaxX;
                //m_intLeadROITolerance_Bottom = arrLeadROIs[0].ref_ROIHeight - MaxY;
                //m_intLeadROITolerance_Left = MinX;

            }
            else
            {
                objPatternROI.LoadROISetting(
            arrLeadROIs[0].ref_ROITotalX,
            arrLeadROIs[0].ref_ROITotalY,
            arrLeadROIs[0].ref_ROIWidth,
            arrLeadROIs[0].ref_ROIHeight);

                m_intLeadROITolerance_Top = 0;
                m_intLeadROITolerance_Right = 0;
                m_intLeadROITolerance_Bottom = 0;
                m_intLeadROITolerance_Left = 0;

            }

            objPatternROI.AttachImage(objLearnRotatedImage);
            //objPatternROI.SaveImage("D:\\objPatternROI.bmp");
            SaveUnitPattern(objPatternROI, strFolderPath, intLeadIndex);

            m_fPatternROIOffsetX = objUnitROI.ref_ROICenterX - objPatternROI.ref_ROICenterX;
            m_fPatternROIOffsetY = objUnitROI.ref_ROICenterY - objPatternROI.ref_ROICenterY;

            objUnitROI.Dispose();
            objPatternROI.Dispose();
            //objTempROI.Dispose();
            //objImage.Dispose();
        }

        public void SaveUnitPattern(ROI objUnitROI, string strFolderPath, int intLeadIndex)
        {

            if (objUnitROI.ref_ROIWidth == 0 || objUnitROI.ref_ROIHeight == 0)
                return;

            try
            {
#if (Debug_2_12 || Release_2_12)
                m_objMatcher.AdvancedLearning = false; // 2020-09-23 ZJYEOH : If set to true when MIN MAX angle both are same sign(++/--) then will have error
#endif
                m_objMatcher.DontCareThreshold = 1;
                m_objMatcher.LearnPattern(objUnitROI.ref_ROI);

                //m_objFinder.Learn(objUnitROI.ref_ROI);
            }
            catch (Exception ex)
            {

            }

            m_objMatcher.Save(strFolderPath + "UnitMatcher" + intLeadIndex.ToString() + ".mch");
            //m_objFinder.Save(strFolderPath + "UnitFinder" + intLeadIndex.ToString() + ".fnd");
        }

        public void LearnManualPocketReferencePattern(ROI objUnitROI)
        {

            if (objUnitROI.ref_ROIWidth == 0 || objUnitROI.ref_ROIHeight == 0)
                return;

            try
            {
#if (Debug_2_12 || Release_2_12)
                m_objManualPocketMatcher.AdvancedLearning = false; // 2020-09-23 ZJYEOH : If set to true when MIN MAX angle both are same sign(++/--) then will have error
#endif
                m_objManualPocketMatcher.DontCareThreshold = 1;
                m_objManualPocketMatcher.LearnPattern(objUnitROI.ref_ROI);

                //m_objFinder.Learn(objUnitROI.ref_ROI);
            }
            catch (Exception ex)
            {

            }

        }
        public void LearnAutoPocketReferencePattern(ROI objUnitROI)
        {

            if (objUnitROI.ref_ROIWidth == 0 || objUnitROI.ref_ROIHeight == 0)
                return;

            try
            {
#if (Debug_2_12 || Release_2_12)
                m_objAutoPocketMatcher.AdvancedLearning = false; // 2020-09-23 ZJYEOH : If set to true when MIN MAX angle both are same sign(++/--) then will have error
#endif
                m_objAutoPocketMatcher.DontCareThreshold = 1;
                m_objAutoPocketMatcher.LearnPattern(objUnitROI.ref_ROI);

                //m_objFinder.Learn(objUnitROI.ref_ROI);
            }
            catch (Exception ex)
            {

            }

        }
        public void SaveManualPocketReferencePattern(ROI objUnitROI, string strFolderPath, int intLeadIndex)
        {

            if (objUnitROI.ref_ROIWidth == 0 || objUnitROI.ref_ROIHeight == 0)
                return;

            try
            {
#if (Debug_2_12 || Release_2_12)
                m_objManualPocketMatcher.AdvancedLearning = false; // 2020-09-23 ZJYEOH : If set to true when MIN MAX angle both are same sign(++/--) then will have error
#endif
                m_objManualPocketMatcher.DontCareThreshold = 1;
                m_objManualPocketMatcher.LearnPattern(objUnitROI.ref_ROI);

                //m_objFinder.Learn(objUnitROI.ref_ROI);
            }
            catch (Exception ex)
            {

            }

            m_objManualPocketMatcher.Save(strFolderPath + "ManualPocketMatcher" + intLeadIndex.ToString() + ".mch");
            //m_objFinder.Save(strFolderPath + "UnitFinder" + intLeadIndex.ToString() + ".fnd");
        }
        public void SaveAutoPocketReferencePattern(ROI objUnitROI, string strFolderPath, int intLeadIndex)
        {

            if (objUnitROI.ref_ROIWidth == 0 || objUnitROI.ref_ROIHeight == 0)
                return;

            try
            {
#if (Debug_2_12 || Release_2_12)
                m_objAutoPocketMatcher.AdvancedLearning = false; // 2020-09-23 ZJYEOH : If set to true when MIN MAX angle both are same sign(++/--) then will have error
#endif
                m_objAutoPocketMatcher.DontCareThreshold = 1;
                m_objAutoPocketMatcher.LearnPattern(objUnitROI.ref_ROI);

                //m_objFinder.Learn(objUnitROI.ref_ROI);
            }
            catch (Exception ex)
            {

            }

            m_objAutoPocketMatcher.Save(strFolderPath + "AutoPocketMatcher" + intLeadIndex.ToString() + ".mch");
            //m_objFinder.Save(strFolderPath + "UnitFinder" + intLeadIndex.ToString() + ".fnd");
        }
        private bool IsPixelInBlobContourArea(int intBlobIndex, int intPixelX, int intPixelY)
        {
            if (intBlobIndex >= m_arrTemplateContour.Length)
                return false;

            bool blnAboveX1 = false, blnBelowX2 = false, blnAboveY1 = false, blnBelowY2 = false;
            for (int j = 0; j < m_arrTemplateContour[intBlobIndex].ref_pvContourList.Count; j++)
            {
                EBW8PathVector pv = m_arrTemplateContour[intBlobIndex].ref_pvContourList[j];
                int intNumElements = (int)pv.NumElements;

                for (int i = 0; i < intNumElements; i++)
                {
                    if (intPixelX == pv.GetElement(i).X)
                    {
                        if (intPixelY >= pv.GetElement(i).Y)
                            blnAboveY1 = true;

                        if (intPixelY <= pv.GetElement(i).Y)
                            blnBelowY2 = true;
                    }

                    if (intPixelY == pv.GetElement(i).Y)
                    {
                        if (intPixelX >= pv.GetElement(i).X)
                            blnAboveX1 = true;

                        if (intPixelX <= pv.GetElement(i).X)
                            blnBelowX2 = true;
                    }
                }

                if (blnAboveX1 && blnBelowX2 && blnAboveY1 && blnBelowY2)
                    return true;
                else
                    blnAboveX1 = blnBelowX2 = blnAboveY1 = blnBelowY2 = false;
            }

            return false;
        }

        private void SaveLeadIndividualImage(string strFolderPath, ImageDrawing objLearnRotatedImage, List<ROI> arrLeadROIs, int intLeadIndex)
        {
            if (m_arrTemplateContour == null)
                return;
            int intBlobsCount = GetBlobsFeaturesNumber();   // Get number of pad

            if (intBlobsCount <= 0)
                return;

            // Clear all previous template pad individual image 
            string[] strFileList = Directory.GetFiles(strFolderPath, "Lead" + intLeadIndex.ToString() + "_*.bmp");
            foreach (string strFile in strFileList)
            {
                if (File.Exists(strFile))
                {
                    File.Delete(strFile);
                }
            }

            ImageDrawing objUnitImage = new ImageDrawing(true);
            ROI objUnitROI = new ROI();
            int intBlobStartX = 0;
            int intBlobStartY = 0;
            int intBlobEndX = 0;
            int intBlobEndY = 0;
            EBW8 px = new EBW8();
            px.Value = 255; // White color pixel value

            List<List<int>> arrElementX = new List<List<int>>();
            List<List<int>> arrElementY = new List<List<int>>();
            for (int intBlobIndex = 0; intBlobIndex < intBlobsCount; intBlobIndex++)
            {
                arrElementX.Add(new List<int>());
                arrElementY.Add(new List<int>());

                if (intBlobIndex >= m_arrTemplateContour[0].ref_pvContourList.Count)
                    continue;


                EBW8PathVector pv = m_arrTemplateContour[0].ref_pvContourList[intBlobIndex];
                int intNumElements = (int)pv.NumElements;

                for (int i = 0; i < intNumElements; i++)
                {
                    arrElementX[intBlobIndex].Add(pv.GetElement(i).X);
                    arrElementY[intBlobIndex].Add(pv.GetElement(i).Y);
                }
            }

            // Scan other blobs
            for (int j = 0; j < intBlobsCount; j++)
            {
                arrLeadROIs[0].CopyToImage(ref objUnitImage);
                objUnitROI.AttachImage(objUnitImage);
                objUnitROI.LoadROISetting(
                                    0, 0,
                                    arrLeadROIs[0].ref_ROIWidth,
                                    arrLeadROIs[0].ref_ROIHeight);

                EasyImage.GainOffset(objUnitROI.ref_ROI, objUnitROI.ref_ROI, 1f, -255f);

                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[j];
                intBlobStartX = m_stcBlobLead.intStartX;
                intBlobStartY = m_stcBlobLead.intStartY;
                intBlobEndX = m_stcBlobLead.intEndX;
                intBlobEndY = m_stcBlobLead.intEndY;

                // Scan blobs (rectangle limit size) each pixel
                for (int x = intBlobStartX; x < intBlobEndX; x++)
                {
                    for (int y = intBlobStartY; y < intBlobEndY; y++)
                    {
                        bool blnAboveX1 = false, blnBelowX2 = false, blnAboveY1 = false, blnBelowY2 = false;
                        int intNumElements = arrElementX[j].Count;
                        for (int i = 0; i < intNumElements; i++)
                        {
                            if (x == arrElementX[j][i])
                            {
                                if (y >= arrElementY[j][i])
                                    blnAboveY1 = true;

                                if (y <= arrElementY[j][i])
                                    blnBelowY2 = true;
                            }

                            if (y == arrElementY[j][i])
                            {
                                if (x >= arrElementX[j][i])
                                    blnAboveX1 = true;

                                if (x <= arrElementX[j][i])
                                    blnBelowX2 = true;
                            }
                        }
                        // Make sure the pixel is in the blob contour area
                        if (blnAboveX1 && blnBelowX2 && blnAboveY1 && blnBelowY2)
                        {
                            // change the pixel value to white
                            objUnitImage.ref_objMainImage.SetPixel(px, x, y);
                        }
                    }
                }

                objUnitImage.SaveImage(strFolderPath + "Lead" + intLeadIndex + "_" + j.ToString() + ".bmp");
            }
            objUnitImage.Dispose();
        }

        public void LoadUnitPattern(string strPath)
        {
            if (File.Exists(strPath))
                m_objMatcher.Load(strPath);
        }
        public void LoadManualPocketReferencePattern(string strPath)
        {
            if (File.Exists(strPath))
                m_objManualPocketMatcher.Load(strPath);
        }
        public void LoadAutoPocketReferencePattern(string strPath)
        {
            if (File.Exists(strPath))
                m_objAutoPocketMatcher.Load(strPath);
        }
        public void LoadUnitFinder(string strPath)
        {
            //if (File.Exists(strPath))
            //    m_objFinder.Load(strPath);
        }

        public bool FindManualPocketReferencePattern(ROI objSearchROI, ref PointF pPocketCenterPoint)
        {
            if (!m_objManualPocketMatcher.PatternLearnt)
                return false;

            m_objManualPocketMatcher.MinAngle = -2;
            m_objManualPocketMatcher.MaxAngle = 2;

            m_objManualPocketMatcher.MaxPositions = 2;
            m_objManualPocketMatcher.FinalReduction = 2;
            m_objManualPocketMatcher.Interpolate = true;

            m_objManualPocketMatcher.Match(objSearchROI.ref_ROI);

            if (m_objManualPocketMatcher.NumPositions > 0)
            {
                if (m_objManualPocketMatcher.GetPosition(0).Score > 0.5)
                {
                    pPocketCenterPoint = new Point(Convert.ToInt32(objSearchROI.ref_ROITotalX + m_objManualPocketMatcher.GetPosition(0).CenterX),
                                    Convert.ToInt32(objSearchROI.ref_ROITotalY + m_objManualPocketMatcher.GetPosition(0).CenterY));

                    //objPocketDontCareROI.LoadROISetting((int)Math.Round((pPocketCenterPoint.X - m_fManualPocketReferenceOffsetX) - (objPocketDontCareROI.ref_ROIWidth / 2)),
                    //    (int)Math.Round((pPocketCenterPoint.Y - m_fPocketReferenceOffsetY) - (objPocketDontCareROI.ref_ROIHeight / 2)), objPocketDontCareROI.ref_ROIWidth, objPocketDontCareROI.ref_ROIHeight);


                }
                else
                    return false;
            }
            else
                return false;
            return true;
        }
        public bool FindAutoPocketReferencePattern(ROI objSearchROI, ref PointF pPocketCenterPoint)
        {
            if (!m_objAutoPocketMatcher.PatternLearnt)
                return false;

            m_objAutoPocketMatcher.MinAngle = -2;
            m_objAutoPocketMatcher.MaxAngle = 2;

            m_objAutoPocketMatcher.MaxPositions = 2;
            m_objAutoPocketMatcher.FinalReduction = 2;
            m_objAutoPocketMatcher.Interpolate = true;

            m_objAutoPocketMatcher.Match(objSearchROI.ref_ROI);

            if (m_objAutoPocketMatcher.NumPositions > 0)
            {
                if (m_objAutoPocketMatcher.GetPosition(0).Score > 0.5)
                {
                    pPocketCenterPoint = new Point(Convert.ToInt32(objSearchROI.ref_ROITotalX + m_objAutoPocketMatcher.GetPosition(0).CenterX),
                                    Convert.ToInt32(objSearchROI.ref_ROITotalY + m_objAutoPocketMatcher.GetPosition(0).CenterY));

                    //objPocketDontCareROI.LoadROISetting((int)Math.Round((pPocketCenterPoint.X - m_fManualPocketReferenceOffsetX) - (objPocketDontCareROI.ref_ROIWidth / 2)),
                    //    (int)Math.Round((pPocketCenterPoint.Y - m_fPocketReferenceOffsetY) - (objPocketDontCareROI.ref_ROIHeight / 2)), objPocketDontCareROI.ref_ROIWidth, objPocketDontCareROI.ref_ROIHeight);


                }
                else
                    return false;
            }
            else
                return false;
            return true;
        }
        public bool FindUnitUsingPRS(ROI objSearchROI, int intAngleTolerance, bool blnFastMode, int intLeadIndex, ROI objLeadROI)
        {
            /*
             * Accuracy is not good when FastMode is true
             */

            //2021-09-07 ZJYEOH: Need to Reset to zero before inspection
            m_pUnitCenterPoint = new Point(0, 0);

            if (!m_objMatcher.PatternLearnt)
                return false;

            m_objMatcher.MinAngle = -intAngleTolerance;
            m_objMatcher.MaxAngle = intAngleTolerance;

            // 2021 08 04 - CCENG: Change Max Position from 2 to 3 to solve the 3L case.
            m_objMatcher.MaxPositions = 3;  
            if (blnFastMode)
                m_objMatcher.FinalReduction = 6;
            else
                m_objMatcher.FinalReduction = 1;
            m_objMatcher.Interpolate = true;

            m_objMatcher.Match(objSearchROI.ref_ROI);
            //objSearchROI.SaveImage("D:\\TS\\objSearchROI.bmp");
            //m_objMatcher.Save("D:\\TS\\m_objMatcher.mch");
            if (m_objMatcher.NumPositions > 0)
            {
#if (Debug_2_12 || Release_2_12)
                for (uint i = 0; i < m_objMatcher.NumPositions; i++)
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                for (int i = 0; i < m_objMatcher.NumPositions; i++)
#endif

                {
                    //if (m_objMatcher.GetPosition(i).Score > 0.5)  // 2020 08 07 - CCENG
                    {
                        switch (intLeadIndex)
                        {
                            case 1: // Top
                                if (m_pUnitCenterPoint.X == 0 && m_pUnitCenterPoint.Y == 0)
                                {
                                    m_pUnitCenterPoint = new Point(Convert.ToInt32(objSearchROI.ref_ROITotalX + m_objMatcher.GetPosition(i).CenterX),
                                        Convert.ToInt32(objSearchROI.ref_ROITotalY + m_objMatcher.GetPosition(i).CenterY));
                                    m_fUnitScore = m_objMatcher.GetPosition(i).Score;
                                    m_fUnitAngle = m_objMatcher.GetPosition(i).Angle;
                                }
                                else
                                {
                                    // 2020 08 07 - CCENG: Sometime first pattern does not mean it is match the correct object bcos correct object has damaged.
                                    //                     If first pattern is out of Lead Inspect ROI region, then can consider second pattern center point.
                                    if ((m_pUnitCenterPoint.Y - objLeadROI.ref_ROIHeight / 2) > Convert.ToInt32(objLeadROI.ref_ROITotalY + objLeadROI.ref_ROIHeight))
                                    {
                                        if (m_pUnitCenterPoint.Y > Convert.ToInt32(objSearchROI.ref_ROITotalY + m_objMatcher.GetPosition(i).CenterY))
                                        {
                                            m_pUnitCenterPoint = new Point(Convert.ToInt32(objSearchROI.ref_ROITotalX + m_objMatcher.GetPosition(i).CenterX),
                                                Convert.ToInt32(objSearchROI.ref_ROITotalY + m_objMatcher.GetPosition(i).CenterY));
                                            m_fUnitScore = m_objMatcher.GetPosition(i).Score;
                                            m_fUnitAngle = m_objMatcher.GetPosition(i).Angle;
                                        }
                                    }
                                }

                                // 2019-10-05 ZJYEOH : Final Check if pattern found is out of Lead inspect ROI region then use back Lead inspect ROI Center Point
                                // 2021 08 04 - CCENG: Change from i == 1 to i == last object.
                                if (m_objMatcher.NumPositions == 1 || i == (m_objMatcher.NumPositions - 1))
                                {
                                    if ((m_pUnitCenterPoint.Y - objLeadROI.ref_ROIHeight / 2) > Convert.ToInt32(objLeadROI.ref_ROITotalY + objLeadROI.ref_ROIHeight))
                                    {
                                        m_pUnitCenterPoint = new Point(Convert.ToInt32(m_pUnitCenterPoint.X),
                                            Convert.ToInt32(objLeadROI.ref_ROITotalY + objLeadROI.ref_ROIHeight / 2));
                                    }
                                }
                                break;
                            case 2:  // Right
                                if (m_pUnitCenterPoint.X == 0 && m_pUnitCenterPoint.Y == 0)
                                {
                                    m_pUnitCenterPoint = new Point(Convert.ToInt32(objSearchROI.ref_ROITotalX + m_objMatcher.GetPosition(i).CenterX),
                                        Convert.ToInt32(objSearchROI.ref_ROITotalY + m_objMatcher.GetPosition(i).CenterY));
                                    m_fUnitScore = m_objMatcher.GetPosition(i).Score;
                                    m_fUnitAngle = m_objMatcher.GetPosition(i).Angle;
                                }
                                else
                                {
                                    // 2020 08 07 - CCENG: Sometime first pattern does not mean it is match the correct object bcos correct object has damaged.
                                    //                     If first pattern is out of Lead Inspect ROI region, then can consider second pattern center point.
                                    if ((m_pUnitCenterPoint.X + objLeadROI.ref_ROIWidth / 2) < Convert.ToInt32(objLeadROI.ref_ROITotalX))
                                    {
                                        if (m_pUnitCenterPoint.X < Convert.ToInt32(objSearchROI.ref_ROITotalX + m_objMatcher.GetPosition(i).CenterX))
                                        {
                                            m_pUnitCenterPoint = new Point(Convert.ToInt32(objSearchROI.ref_ROITotalX + m_objMatcher.GetPosition(i).CenterX),
                                                Convert.ToInt32(objSearchROI.ref_ROITotalY + m_objMatcher.GetPosition(i).CenterY));
                                            m_fUnitScore = m_objMatcher.GetPosition(i).Score;
                                            m_fUnitAngle = m_objMatcher.GetPosition(i).Angle;
                                        }
                                    }
                                }

                                // 2019-10-05 ZJYEOH : Final Check if pattern found is out of Lead inspect ROI region then use back Lead inspect ROI Center Point
                                if (m_objMatcher.NumPositions == 1 || i == (m_objMatcher.NumPositions - 1))
                                {
                                    if ((m_pUnitCenterPoint.X + objLeadROI.ref_ROIWidth / 2) < Convert.ToInt32(objLeadROI.ref_ROITotalX))
                                    {
                                        m_pUnitCenterPoint = new Point(Convert.ToInt32(objLeadROI.ref_ROITotalX + objLeadROI.ref_ROIWidth / 2),
                                            Convert.ToInt32(m_pUnitCenterPoint.Y));
                                    }
                                }
                                break;
                            case 3:  // Bottom
                                if (m_pUnitCenterPoint.X == 0 && m_pUnitCenterPoint.Y == 0)
                                {
                                    m_pUnitCenterPoint = new Point(Convert.ToInt32(objSearchROI.ref_ROITotalX + m_objMatcher.GetPosition(i).CenterX),
                                        Convert.ToInt32(objSearchROI.ref_ROITotalY + m_objMatcher.GetPosition(i).CenterY));
                                    m_fUnitScore = m_objMatcher.GetPosition(i).Score;
                                    m_fUnitAngle = m_objMatcher.GetPosition(i).Angle;
                                }
                                else
                                {
                                    // 2020 08 07 - CCENG: Sometime first pattern does not mean it is match the correct object bcos correct object has damaged.
                                    //                     If first pattern is out of Lead Inspect ROI region, then can consider second pattern center point.
                                    if ((m_pUnitCenterPoint.Y + objLeadROI.ref_ROIHeight / 2) < Convert.ToInt32(objLeadROI.ref_ROITotalY))
                                    {
                                        if (m_pUnitCenterPoint.Y < Convert.ToInt32(objSearchROI.ref_ROITotalY + m_objMatcher.GetPosition(i).CenterY))
                                        {
                                            m_pUnitCenterPoint = new Point(Convert.ToInt32(objSearchROI.ref_ROITotalX + m_objMatcher.GetPosition(i).CenterX),
                                                Convert.ToInt32(objSearchROI.ref_ROITotalY + m_objMatcher.GetPosition(i).CenterY));
                                            m_fUnitScore = m_objMatcher.GetPosition(i).Score;
                                            m_fUnitAngle = m_objMatcher.GetPosition(i).Angle;
                                        }
                                    }
                                }

                                // 2019-10-05 ZJYEOH : Final Check if pattern found is out of Lead inspect ROI region then use back Lead inspect ROI Center Point
                                if (m_objMatcher.NumPositions == 1 || i == (m_objMatcher.NumPositions - 1))
                                {
                                    if ((m_pUnitCenterPoint.Y + objLeadROI.ref_ROIHeight / 2) < Convert.ToInt32(objLeadROI.ref_ROITotalY))
                                    {
                                        m_pUnitCenterPoint = new Point(Convert.ToInt32(m_pUnitCenterPoint.X),
                                            Convert.ToInt32(objLeadROI.ref_ROITotalY + objLeadROI.ref_ROIHeight / 2));
                                    }
                                }
                                break;
                            case 4:  // Left
                                if (m_pUnitCenterPoint.X == 0 && m_pUnitCenterPoint.Y == 0)
                                {
                                    m_pUnitCenterPoint = new Point(Convert.ToInt32(objSearchROI.ref_ROITotalX + m_objMatcher.GetPosition(i).CenterX),
                                        Convert.ToInt32(objSearchROI.ref_ROITotalY + m_objMatcher.GetPosition(i).CenterY));
                                    m_fUnitScore = m_objMatcher.GetPosition(i).Score;
                                    m_fUnitAngle = m_objMatcher.GetPosition(i).Angle;
                                }
                                else
                                {
                                    // 2020 08 07 - CCENG: Sometime first pattern does not mean it is match the correct object bcos correct object has damaged.
                                    //                     If first pattern is out of Lead Inspect ROI region, then can consider second pattern center point.
                                    if ((m_pUnitCenterPoint.X - objLeadROI.ref_ROIWidth / 2) > Convert.ToInt32(objLeadROI.ref_ROITotalX + objLeadROI.ref_ROIWidth))
                                    {
                                        if (m_pUnitCenterPoint.X > Convert.ToInt32(objSearchROI.ref_ROITotalX + m_objMatcher.GetPosition(i).CenterX))
                                        {
                                            m_pUnitCenterPoint = new Point(Convert.ToInt32(objSearchROI.ref_ROITotalX + m_objMatcher.GetPosition(i).CenterX),
                                                Convert.ToInt32(objSearchROI.ref_ROITotalY + m_objMatcher.GetPosition(i).CenterY));
                                            m_fUnitScore = m_objMatcher.GetPosition(i).Score;
                                            m_fUnitAngle = m_objMatcher.GetPosition(i).Angle;
                                        }
                                    }
                                }

                                // 2019-10-05 ZJYEOH : Final Check if pattern found is out of Lead inspect ROI region then use back Lead inspect ROI Center Point
                                if (m_objMatcher.NumPositions == 1 || i == (m_objMatcher.NumPositions - 1))
                                {
                                    if ((m_pUnitCenterPoint.X - objLeadROI.ref_ROIWidth / 2) > Convert.ToInt32(objLeadROI.ref_ROITotalX + objLeadROI.ref_ROIWidth))
                                    {
                                        m_pUnitCenterPoint = new Point(Convert.ToInt32(objLeadROI.ref_ROITotalX + objLeadROI.ref_ROIWidth / 2),
                                            Convert.ToInt32(m_pUnitCenterPoint.Y));
                                    }
                                }
                                break;
                        }
                    }
                }

                if (m_pUnitCenterPoint.X != 0 || m_pUnitCenterPoint.Y != 0)
                    return true;
            }

            return false;
        }

        //public bool FindUnitUsingFinder(ROI objSearchROI, int intAngleTolerance, bool blnFastMode)
        //{
        //    /*
        //     * Accuracy is not good when FastMode is true
        //     */

        //    if (!m_objFinder.LearningDone)
        //        return false;

        //    m_objFinder.AngleTolerance = intAngleTolerance;
        //    m_objFinder.MaxInstances = 5;
        //    m_objFinder.Interpolate = true;

        //    EFoundPattern[] EFoundResult = m_objFinder.Find(objSearchROI.ref_ROI);

        //    if (EFoundResult.Length > 0)     // if macthing result hit the min score, its position will be 1 or more
        //    {
        //        if (EFoundResult[0].Score < 0.5)
        //            return false;

        //        m_pUnitCenterPoint = new PointF(objSearchROI.ref_ROITotalX + EFoundResult[0].Center.X,
        //                                        objSearchROI.ref_ROITotalY + EFoundResult[0].Center.Y);

        //        m_fUnitAngle = EFoundResult[0].Angle;
        //        return true;
        //    }
        //    else
        //        return false;
        //}

        public void LoadLead(string strPath, string strSectionName, int intImageCount)
        {
            XmlParser objFile = new XmlParser(strPath);

            objFile.GetFirstSection(strSectionName);

            // Load Lead General Setting
            objFile.GetSecondSection("LeadSetting");
            m_blnWantInspectBaseLead = objFile.GetValueAsBoolean("WantInspectBaseLead", false, 2);

            m_blnInspectLead = objFile.GetValueAsBoolean("WantInspectLead", false, 2);

            m_intMaskThickness = objFile.GetValueAsInt("MaskThickness", 0, 2);
            m_intLineOffset = objFile.GetValueAsInt("LineOffset", 0, 2);

            int intLeadImage = 0;
            if (intImageCount > 1)
                intLeadImage = 1;
            m_intImageViewNo = objFile.GetValueAsInt("ImageViewNo", intLeadImage, 2);//0
            if (intImageCount > 2)
                intLeadImage = 2;
            m_intBaseLeadImageViewNo = objFile.GetValueAsInt("BaseLeadImageViewNo", intLeadImage, 2);//0
            m_intThresholdValue = objFile.GetValueAsInt("ThresholdValue", -4, 2);
            m_intThresholdValue_BaseLead = objFile.GetValueAsInt("ThresholdValue_BaseLead", -4, 2);
            //m_intLeadDirection = objFile.GetValueAsInt("LeadDirection", 0, 2);   // 0=Horizontal, 1=Vertical
            m_intNumberOfLead = objFile.GetValueAsInt("NumberOfLead", 1, 2);
            m_blnSelected = objFile.GetValueAsBoolean("LeadSelected", true, 2);
            //m_intBaseOffset = objFile.GetValueAsInt("BaseOffset", 0, 2);
            //m_intTipOffset = objFile.GetValueAsInt("TipOffset", 0, 2);
            m_intFilterMinArea = objFile.GetValueAsInt("MinArea", 20, 2);
            m_intFilterMinArea_BaseLead = objFile.GetValueAsInt("MinArea_BaseLead", 20, 2);
            m_intFailOptionMask = objFile.GetValueAsInt("FailMask", 0, 2);
            m_fLeadRangeStartX = objFile.GetValueAsFloat("LeadStartX", 0, 2);
            m_fLeadRangeStartY = objFile.GetValueAsFloat("LeadStartY", 0, 2);
            m_fLeadRangeEndX = objFile.GetValueAsFloat("LeadEndX", 0, 2);
            m_fLeadRangeEndY = objFile.GetValueAsFloat("LeadEndY", 0, 2);
            m_fReferencePointStartX = objFile.GetValueAsFloat("ReferencePointStartX", 0, 2);
            m_fReferencePointStartY = objFile.GetValueAsFloat("ReferencePointStartY", 0, 2);
            m_fReferencePointEndX = objFile.GetValueAsFloat("ReferencePointEndX", 0, 2);
            m_fReferencePointEndY = objFile.GetValueAsFloat("ReferencePointEndY", 0, 2);
            m_fLeadMinSpanStart = objFile.GetValueAsFloat("LeadMinSpanStart", 0, 2);
            m_fLeadMaxSpanStart = objFile.GetValueAsFloat("LeadMaxSpanStart", 0, 2);
            m_fLeadMinSpanEnd = objFile.GetValueAsFloat("LeadMinSpanEnd", 0, 2);
            m_fLeadMaxSpanEnd = objFile.GetValueAsFloat("LeadMaxSpanEnd", 0, 2);
            m_fExtraLeadSetArea = objFile.GetValueAsFloat("ExtraLeadSetArea", 0, 2);
            m_fTotalExtraLeadSetArea = objFile.GetValueAsFloat("TotalExtraLeadSetArea", 0, 2);
            m_fExtraLeadSetLength = objFile.GetValueAsFloat("ExtraLeadSetLength", 0, 2);
            m_fTemplateLengthVarianceMaxLimit = objFile.GetValueAsFloat("TemplateLengthVarianceMaxLimit", 0, 2);
            m_fTemplateLeadMinSpanLimit = objFile.GetValueAsFloat("TemplateLeadMinSpanLimit", 0, 2);
            m_fTemplateLeadMaxSpanLimit = objFile.GetValueAsFloat("TemplateLeadMaxSpanLimit", 0, 2);
            m_blnWantUseGaugeMeasureLeadDimension = objFile.GetValueAsBoolean("WantUseGaugeMeasureLeadDimension", false, 2);
            m_blnWantUseAverageGrayValueMethod = objFile.GetValueAsBoolean("WantUseAverageGrayValueMethod", false, 2);
            m_blnWantPocketDontCareAreaFix_Lead = objFile.GetValueAsBoolean("WantPocketDontCareAreaFix_Lead", false, 2);
            m_blnWantPocketDontCareAreaManual_Lead = objFile.GetValueAsBoolean("WantPocketDontCareAreaManual_Lead", false, 2);
            m_blnWantPocketDontCareAreaAuto_Lead = objFile.GetValueAsBoolean("WantPocketDontCareAreaAuto_Lead", false, 2);
            m_blnWantPocketDontCareAreaBlob_Lead = objFile.GetValueAsBoolean("WantPocketDontCareAreaBlob_Lead", false, 2);
            m_intPocketDontCareMethod = objFile.GetValueAsInt("PocketDontCareMethod", 0, 2);
            m_blnWantUsePkgToBaseTolerance = objFile.GetValueAsBoolean("WantUsePkgToBaseTolerance", false, 2);
            m_blnWantUseAGVMasking = objFile.GetValueAsBoolean("WantUseAGVMasking", true, 2);

            m_intRotationMethod = objFile.GetValueAsInt("RotationMethod", 0, 2);
            
            if (!m_blnGotPackage && m_intRotationMethod != 2)
                m_blnWantUsePkgToBaseTolerance = false;

            m_intLeadAngleTolerance = objFile.GetValueAsInt("LeadAngleTolerance", 10, 2);

            m_blnWantCheckExtraLeadLength = objFile.GetValueAsBoolean("WantCheckExtraLeadLength", false, 2);
            m_blnWantCheckExtraLeadArea = objFile.GetValueAsBoolean("WantCheckExtraLeadArea", false, 2);

            m_intPkgToBaseTolerance_Top = objFile.GetValueAsInt("PkgToBaseTolerance_Top", 0, 2);
            m_intPkgToBaseTolerance_Right = objFile.GetValueAsInt("PkgToBaseTolerance_Right", 0, 2);
            m_intPkgToBaseTolerance_Bottom = objFile.GetValueAsInt("PkgToBaseTolerance_Bottom", 0, 2);
            m_intPkgToBaseTolerance_Left = objFile.GetValueAsInt("PkgToBaseTolerance_Left", 0, 2);

            m_fManualPocketReferenceOffsetX = objFile.GetValueAsInt("ManualPocketReferenceOffsetX", 0, 2);
            m_fManualPocketReferenceOffsetY = objFile.GetValueAsInt("ManualPocketReferenceOffsetY", 0, 2);
            m_fAutoPocketReferenceOffsetX = objFile.GetValueAsInt("AutoPocketReferenceOffsetX", 0, 2);
            m_fAutoPocketReferenceOffsetY = objFile.GetValueAsInt("AutoPocketReferenceOffsetY", 0, 2);

            m_fPatternROIOffsetX = objFile.GetValueAsFloat("PatternROIOffsetX", 0, 2);
            m_fPatternROIOffsetY = objFile.GetValueAsFloat("PatternROIOffsetY", 0, 2);

            m_intLeadROITolerance_Top = objFile.GetValueAsInt("LeadROITolerance_Top", 0, 2);
            m_intLeadROITolerance_Right = objFile.GetValueAsInt("LeadROITolerance_Right", 0, 2);
            m_intLeadROITolerance_Bottom = objFile.GetValueAsInt("LeadROITolerance_Bottom", 0, 2);
            m_intLeadROITolerance_Left = objFile.GetValueAsInt("LeadROITolerance_Left", 0, 2);

            m_blnFlipToOppositeFunction = objFile.GetValueAsBoolean("FlipToOppositeFunction", false, 2);
            m_intDontCareBlobThreshold = objFile.GetValueAsInt("DontCareBlobThreshold", 125, 2);
            m_intMinShadowArea = objFile.GetValueAsInt("MinShadowArea", 0, 2);
            m_intMaxShadowArea = objFile.GetValueAsInt("MaxShadowArea", 500, 2);
            m_intMaxShadowWidth = objFile.GetValueAsInt("MaxShadowWidth", 10, 2);
            m_intDontCareBlobROIInward = objFile.GetValueAsInt("DontCareBlobROIInward", 0, 2);

            m_blnClockWise = objFile.GetValueAsBoolean("ClockWise", true, 2);
            m_intFirstLead = objFile.GetValueAsInt("Lead1", 1, 2);

            // Load lead Blobs Features
            int intBlobsCount = objFile.GetValueAsInt("BlobsFeaturesCount", 0, 2);
            int intContourLength = 0;
            int[] arrContourX;
            int[] arrContourY;
            ClearTemplateBlobsFeatures();
            for (int intBlobIndex = 0; intBlobIndex < intBlobsCount; intBlobIndex++)
            {
                objFile.GetSecondSection("BlobsFeatures" + intBlobIndex);

                intContourLength = objFile.GetValueAsInt("ContourLength", 0, 2);

                arrContourX = new int[intContourLength];
                arrContourY = new int[intContourLength];

                for (int j = 0; j < intContourLength; j++)
                {
                    arrContourX[j] = objFile.GetValueAsInt("ContourX" + j.ToString(), 0, 2);
                    arrContourY[j] = objFile.GetValueAsInt("ContourY" + j.ToString(), 0, 2);
                }

                SetTemplateBlobsFeatures(
                    objFile.GetValueAsInt("NoID", 0, 2),
                    objFile.GetValueAsInt("GroupNo", 0, 2),
                    objFile.GetValueAsFloat("Area", 0, 2),
                    objFile.GetValueAsInt("LengthMode", 0, 2),
                    objFile.GetValueAsInt("ContourX", 0, 2),
                    objFile.GetValueAsInt("ContourY", 0, 2),
                    arrContourX,
                    arrContourY,
                    objFile.GetValueAsInt("StartX", 0, 2),
                    objFile.GetValueAsInt("StartY", 0, 2),
                    objFile.GetValueAsInt("EndX", 0, 2),
                    objFile.GetValueAsInt("EndY", 0, 2),
                    objFile.GetValueAsFloat("fStartX", 0, 2),
                    objFile.GetValueAsFloat("fStartY", 0, 2),
                    objFile.GetValueAsFloat("fEndX", 0, 2),
                    objFile.GetValueAsFloat("fEndY", 0, 2),
                    objFile.GetValueAsInt("Direction", 0, 2),
                    objFile.GetValueAsInt("LeadSide", 0, 2),
                    objFile.GetValueAsFloat("GravityCenterX", 0, 2),
                    objFile.GetValueAsFloat("GravityCenterY", 0, 2),
                    objFile.GetValueAsFloat("LimitCenterX", 0, 2),
                    objFile.GetValueAsFloat("LimitCenterY", 0, 2),
                    objFile.GetValueAsFloat("Width", 0, 2),
                    objFile.GetValueAsFloat("Height", 0, 2),
                    objFile.GetValueAsFloat("BaseWidth", 0, 2),
                    objFile.GetValueAsFloat("BaseHeight", 0, 2),
                    objFile.GetValueAsFloat("BaseCenterX", 0, 2),
                    objFile.GetValueAsFloat("BaseCenterY", 0, 2),
                    objFile.GetValueAsFloat("TipWidth", 0, 2),
                    objFile.GetValueAsFloat("TipHeight", 0, 2),
                    objFile.GetValueAsFloat("TipCenterX", 0, 2),
                    objFile.GetValueAsFloat("TipCenterY", 0, 2),
                    objFile.GetValueAsBoolean("Selected", false, 2),
                    objFile.GetValueAsFloat("LeftDistance", 0, 2),
                    objFile.GetValueAsFloat("RightDistance", 0, 2),
                    objFile.GetValueAsFloat("TopDistance", 0, 2),
                    objFile.GetValueAsFloat("BottomDistance", 0, 2),
                    objFile.GetValueAsFloat("XDistance", 0, 2),
                    objFile.GetValueAsFloat("YDistance", 0, 2),
                    objFile.GetValueAsFloat("Pitch", 0, 2),
                    objFile.GetValueAsFloat("Gap", 0, 2),

                    objFile.GetValueAsFloat("OffSet", 0, 2),
                    objFile.GetValueAsFloat("Skew", 0, 2),
                    objFile.GetValueAsFloat("MinWidth", 0, 2),
                    objFile.GetValueAsFloat("MaxWidth", 0, 2),
                    objFile.GetValueAsFloat("MinHeight", 0, 2),
                    objFile.GetValueAsFloat("MaxHeight", 0, 2),
                    objFile.GetValueAsFloat("MinBaseWidth", 0, 2),
                    objFile.GetValueAsFloat("MaxBaseWidth", 0, 2),
                    objFile.GetValueAsFloat("MinBaseHeight", 0, 2),
                    objFile.GetValueAsFloat("MaxBaseHeight", 0, 2),
                    objFile.GetValueAsFloat("MinTipWidth", 0, 2),
                    objFile.GetValueAsFloat("MaxTipWidth", 0, 2),
                    objFile.GetValueAsFloat("MinTipHeight", 0, 2),
                    objFile.GetValueAsFloat("MaxTipHeight", 0, 2),
                    objFile.GetValueAsFloat("MinPitch", 0, 2),
                    objFile.GetValueAsFloat("MaxPitch", 0, 2),
                    objFile.GetValueAsFloat("MinGap", 0, 2),
                    objFile.GetValueAsFloat("MaxGap", 0, 2),
                    objFile.GetValueAsFloat("Variance", 0, 2),
                    objFile.GetValueAsFloat("MinAGV", 0, 2),
                    objFile.GetValueAsFloat("MaxAGV", 0, 2),
                    objFile.GetValueAsInt("BaseInwardOffset", 0, 2),
                    objFile.GetValueAsInt("TipInwardOffset", 0, 2),
                    objFile.GetValueAsInt("AGVROITolerance_Top", 0, 2),
                    objFile.GetValueAsInt("AGVROITolerance_Right", 0, 2),
                    objFile.GetValueAsInt("AGVROITolerance_Bottom", 0, 2),
                    objFile.GetValueAsInt("AGVROITolerance_Left", 0, 2),
                    objFile.GetValueAsFloat("WidthOffset", 0, 2),
                    objFile.GetValueAsFloat("LengthOffset", 0, 2),
                    objFile.GetValueAsFloat("PitchOffset", 0, 2),
                    objFile.GetValueAsFloat("GapOffset", 0, 2)
                    );
            }

            // Load lead Blobs Features
            int intBlobsCount_BaseLead = objFile.GetValueAsInt("BlobsFeaturesCount_BaseLead", 0, 2);
            int intContourLength_BaseLead = 0;
            int[] arrContourX_BaseLead;
            int[] arrContourY_BaseLead;
            ClearTemplateBlobsFeatures_BaseLead();
            for (int intBlobIndex = 0; intBlobIndex < intBlobsCount_BaseLead; intBlobIndex++)
            {
                objFile.GetSecondSection("BlobsFeatures_BaseLead" + intBlobIndex);

                intContourLength_BaseLead = objFile.GetValueAsInt("ContourLength", 0, 2);

                arrContourX_BaseLead = new int[intContourLength_BaseLead];
                arrContourY_BaseLead = new int[intContourLength_BaseLead];

                for (int j = 0; j < intContourLength_BaseLead; j++)
                {
                    arrContourX_BaseLead[j] = objFile.GetValueAsInt("ContourX" + j.ToString(), 0, 2);
                    arrContourY_BaseLead[j] = objFile.GetValueAsInt("ContourY" + j.ToString(), 0, 2);
                }

                SetTemplateBlobsFeatures_BaseLead(
                    objFile.GetValueAsInt("NoID", 0, 2),
                    objFile.GetValueAsInt("GroupNo", 0, 2),
                    objFile.GetValueAsFloat("Area", 0, 2),
                    objFile.GetValueAsInt("LengthMode", 0, 2),
                    objFile.GetValueAsInt("ContourX", 0, 2),
                    objFile.GetValueAsInt("ContourY", 0, 2),
                    arrContourX_BaseLead,
                    arrContourY_BaseLead,
                    objFile.GetValueAsInt("StartX", 0, 2),
                    objFile.GetValueAsInt("StartY", 0, 2),
                    objFile.GetValueAsInt("EndX", 0, 2),
                    objFile.GetValueAsInt("EndY", 0, 2),
                    objFile.GetValueAsFloat("fStartX", 0, 2),
                    objFile.GetValueAsFloat("fStartY", 0, 2),
                    objFile.GetValueAsFloat("fEndX", 0, 2),
                    objFile.GetValueAsFloat("fEndY", 0, 2),
                    objFile.GetValueAsInt("Direction", 0, 2),
                    objFile.GetValueAsInt("LeadSide", 0, 2),
                    objFile.GetValueAsFloat("GravityCenterX", 0, 2),
                    objFile.GetValueAsFloat("GravityCenterY", 0, 2),
                    objFile.GetValueAsFloat("LimitCenterX", 0, 2),
                    objFile.GetValueAsFloat("LimitCenterY", 0, 2),
                    objFile.GetValueAsFloat("Width", 0, 2),
                    objFile.GetValueAsFloat("Height", 0, 2),
                    objFile.GetValueAsFloat("BaseWidth", 0, 2),
                    objFile.GetValueAsFloat("BaseHeight", 0, 2),
                    objFile.GetValueAsFloat("BaseCenterX", 0, 2),
                    objFile.GetValueAsFloat("BaseCenterY", 0, 2),
                    objFile.GetValueAsFloat("TipWidth", 0, 2),
                    objFile.GetValueAsFloat("TipHeight", 0, 2),
                    objFile.GetValueAsFloat("TipCenterX", 0, 2),
                    objFile.GetValueAsFloat("TipCenterY", 0, 2),
                    objFile.GetValueAsBoolean("Selected", false, 2),
                    objFile.GetValueAsFloat("LeftDistance", 0, 2),
                    objFile.GetValueAsFloat("RightDistance", 0, 2),
                    objFile.GetValueAsFloat("TopDistance", 0, 2),
                    objFile.GetValueAsFloat("BottomDistance", 0, 2),
                    objFile.GetValueAsFloat("XDistance", 0, 2),
                    objFile.GetValueAsFloat("YDistance", 0, 2),
                    objFile.GetValueAsFloat("MaxBaseOffset", 0, 2),
                    objFile.GetValueAsFloat("MinBaseArea", 0, 2),
                    objFile.GetValueAsFloat("MaxBaseArea", 0, 2)
                    );
            }

            // Load Pitch Gap
            int intPitchGapCount = objFile.GetValueAsInt("PitchGapCount", 0, 2);
            ClearTemplatePitchGap();
            for (int intPitchGapIndex = 0; intPitchGapIndex < intPitchGapCount; intPitchGapIndex++)
            {
                objFile.GetSecondSection("PitchGap" + intPitchGapIndex);

                //float gg = objFile.GetValueAsFloat("Gap", 0, 2);
                float pp = objFile.GetValueAsFloat("Pitch", 0, 2);
                SetPitchGapData(
                    objFile.GetValueAsInt("FromLeadNo", 0, 2),
                    objFile.GetValueAsInt("ToLeadNo", 0, 2),
                    objFile.GetValueAsFloat("MinPitch", 0, 2),
                    objFile.GetValueAsFloat("MaxPitch", 0, 2),
                    objFile.GetValueAsFloat("MinGap", 0, 2),
                    objFile.GetValueAsFloat("MaxGap", 0, 2),
                    objFile.GetValueAsFloat("Pitch", 0, 2),
                    objFile.GetValueAsFloat("Gap", 0, 2),
                    objFile.GetValueAsInt("StartX", 0, 2),
                    objFile.GetValueAsInt("StartY", 0, 2),
                    objFile.GetValueAsInt("EndX", 0, 2),
                    objFile.GetValueAsInt("EndY", 0, 2),
                    objFile.GetValueAsInt("Direction", 0, 2));
            }

            m_fUnitWidth = objFile.GetValueAsFloat("UnitWidth", 0, 2);
            m_fUnitHeight = objFile.GetValueAsFloat("UnitHeight", 0, 2);
            m_fUnitThickness = objFile.GetValueAsFloat("UnitThickness", 0, 2);
            m_fUnitWidthMin = objFile.GetValueAsFloat("UnitWidthMin", 0, 2);
            m_fUnitWidthMax = objFile.GetValueAsFloat("UnitWidthMax", 0, 2);
            m_fUnitHeightMin = objFile.GetValueAsFloat("UnitHeightMin", 0, 2);
            m_fUnitHeightMax = objFile.GetValueAsFloat("UnitHeightMax", 0, 2);
            m_fUnitThicknessMin = objFile.GetValueAsFloat("UnitThicknessMin", 0, 2);
            m_fUnitThicknessMax = objFile.GetValueAsFloat("UnitThicknessMax", 0, 2);

            m_fUnitSizeLength = objFile.GetValueAsFloat("UnitSizeLength", 0, 2);
            m_fCrackLength = objFile.GetValueAsFloat("CrackLength", 0, 2);
            m_fScratchLength = objFile.GetValueAsFloat("ScratchLength", 0, 2);
            m_fContaminationLength = objFile.GetValueAsFloat("ContaminationLength", 0, 2);
            m_fSolderMeltLength = objFile.GetValueAsFloat("SolderMeltLength", 0, 2);
            m_fVoidLength = objFile.GetValueAsFloat("VoidLength", 0, 2);
            m_fMoldFlashLength = objFile.GetValueAsFloat("MoldFlashLength", 0, 2);
            m_fInCompletePlateLength = objFile.GetValueAsFloat("InCompletePlateLength", 0, 2);
            m_fLeadBrokenLength = objFile.GetValueAsFloat("LeadBrokenLength", 0, 2);

            m_intMPTolerance = objFile.GetValueAsInt("MPTolerance", 3, 2);

        }
        public void LoadPitchGapLinkTemporary()
        {
            m_arrPitchGap.Clear();
            
            for (int i = 0; i < m_arrBackupPitchGap.Count; i++)
            {
                PitchGap stcPitchGapPrev = (PitchGap)m_arrBackupPitchGap[i];

                if (stcPitchGapPrev.intFromLeadNo >= m_arrTemplateBlobLeads.Count || stcPitchGapPrev.intToLeadNo >= m_arrTemplateBlobLeads.Count)
                    continue;

                int intFormLeadNo = stcPitchGapPrev.intFromLeadNo;

                bool blnAllowChange = true;
                int intToLeadNo = stcPitchGapPrev.intToLeadNo;

                if (intFormLeadNo == intToLeadNo)
                {

                    blnAllowChange = false;
                }
                else if (CheckPitchGapLinkExist(intFormLeadNo, intToLeadNo))
                {
                    blnAllowChange = false;
                }
                else if (CheckPitchGapLinkInLeadAlready(intFormLeadNo))
                {
                    //blnAllowChange = false;
                }
                else if (!CheckPitchGapLinkAvailable(intFormLeadNo, intToLeadNo))
                {
                    blnAllowChange = false;
                }

                if (blnAllowChange)
                {
                    SetPitchGap(intFormLeadNo, intToLeadNo);
                }
            }
        }
        public void LoadLead3D(string strPath, string strSectionName)
        {
            XmlParser objFile = new XmlParser(strPath);

            objFile.GetFirstSection(strSectionName);

            // Load Lead General Setting
            objFile.GetSecondSection("LeadSetting");
            m_intThresholdValue = objFile.GetValueAsInt("ThresholdValue", -4, 2);
            //m_intLeadDirection = objFile.GetValueAsInt("LeadDirection", 0, 2);   // 0=Horizontal, 1=Vertical
            m_intNumberOfLead = objFile.GetValueAsInt("NumberOfLead", 0, 2);
            m_intNumberOfLead_Top = objFile.GetValueAsInt("NumberOfLead_Top", 0, 2);
            m_intNumberOfLead_Bottom = objFile.GetValueAsInt("NumberOfLead_Bottom", 0, 2);
            m_intNumberOfLead_Left = objFile.GetValueAsInt("NumberOfLead_Left", 0, 2);
            m_intNumberOfLead_Right = objFile.GetValueAsInt("NumberOfLead_Right", 0, 2);
            m_blnSelected = objFile.GetValueAsBoolean("LeadSelected", true, 2);
            //m_intBaseOffset = objFile.GetValueAsInt("BaseOffset", 0, 2);
            //m_intTipOffset = objFile.GetValueAsInt("TipOffset", 0, 2);
            m_intBaseLineTrimFromEdge = objFile.GetValueAsInt("BaseLineTrimFromEdge", 6, 2);
            m_intBaseLineSteps = objFile.GetValueAsInt("BaseLineSteps", 1, 2);
            m_blnWhiteOnBlack = objFile.GetValueAsBoolean("WhiteOnBlack", true, 2);
            m_intFilterMinArea = objFile.GetValueAsInt("MinArea", 20, 2);
            m_fLeadRangeStartX = objFile.GetValueAsFloat("LeadStartX", 0, 2);
            m_fLeadRangeStartY = objFile.GetValueAsFloat("LeadStartY", 0, 2);
            m_fLeadRangeEndX = objFile.GetValueAsFloat("LeadEndX", 0, 2);
            m_fLeadRangeEndY = objFile.GetValueAsFloat("LeadEndY", 0, 2);
            m_fReferencePointStartX = objFile.GetValueAsFloat("ReferencePointStartX", 0, 2);
            m_fReferencePointStartY = objFile.GetValueAsFloat("ReferencePointStartY", 0, 2);
            m_fReferencePointEndX = objFile.GetValueAsFloat("ReferencePointEndX", 0, 2);
            m_fReferencePointEndY = objFile.GetValueAsFloat("ReferencePointEndY", 0, 2);
            m_blnClockWise = objFile.GetValueAsBoolean("ClockWise", true, 2);
            m_intFirstLead = objFile.GetValueAsInt("Lead1", 1, 2);

            // Load lead Blobs Features
            int intBlobsCount = objFile.GetValueAsInt("BlobsFeaturesCount", 0, 2);
            int intContourLength = 0;
            int[] arrContourX;
            int[] arrContourY;
            ClearTemplateBlobsFeatures();
            for (int intBlobIndex = 0; intBlobIndex < intBlobsCount; intBlobIndex++)
            {
                objFile.GetSecondSection("BlobsFeatures" + intBlobIndex);

                intContourLength = objFile.GetValueAsInt("ContourLength", 0, 2);

                arrContourX = new int[intContourLength];
                arrContourY = new int[intContourLength];

                for (int j = 0; j < intContourLength; j++)
                {
                    arrContourX[j] = objFile.GetValueAsInt("ContourX" + j.ToString(), 0, 2);
                    arrContourY[j] = objFile.GetValueAsInt("ContourY" + j.ToString(), 0, 2);
                }

                SetTemplateBlobsFeatures(
                    objFile.GetValueAsInt("NoID", 0, 2),
                    objFile.GetValueAsInt("GroupNo", 0, 2),
                    objFile.GetValueAsFloat("Area", 0, 2),
                    objFile.GetValueAsInt("LengthMode", 0, 2),
                    objFile.GetValueAsInt("ContourX", 0, 2),
                    objFile.GetValueAsInt("ContourY", 0, 2),
                    arrContourX,
                    arrContourY,
                    objFile.GetValueAsInt("StartX", 0, 2),
                    objFile.GetValueAsInt("StartY", 0, 2),
                    objFile.GetValueAsInt("EndX", 0, 2),
                    objFile.GetValueAsInt("EndY", 0, 2),
                    objFile.GetValueAsFloat("fStartX", 0, 2),
                    objFile.GetValueAsFloat("fStartY", 0, 2),
                    objFile.GetValueAsFloat("fEndX", 0, 2),
                    objFile.GetValueAsFloat("fEndY", 0, 2),
                    objFile.GetValueAsInt("Direction", 0, 2),
                    objFile.GetValueAsInt("LeadSide", 0, 2),
                    objFile.GetValueAsFloat("GravityCenterX", 0, 2),
                    objFile.GetValueAsFloat("GravityCenterY", 0, 2),
                    objFile.GetValueAsFloat("LimitCenterX", 0, 2),
                    objFile.GetValueAsFloat("LimitCenterY", 0, 2),
                    objFile.GetValueAsFloat("Width", 0, 2),
                    objFile.GetValueAsFloat("Height", 0, 2),
                    objFile.GetValueAsFloat("BaseWidth", 0, 2),
                    objFile.GetValueAsFloat("BaseHeight", 0, 2),
                    objFile.GetValueAsFloat("BaseCenterX", 0, 2),
                    objFile.GetValueAsFloat("BaseCenterY", 0, 2),
                    objFile.GetValueAsFloat("TipWidth", 0, 2),
                    objFile.GetValueAsFloat("TipHeight", 0, 2),
                    objFile.GetValueAsFloat("TipCenterX", 0, 2),
                    objFile.GetValueAsFloat("TipCenterY", 0, 2),
                    objFile.GetValueAsBoolean("Selected", false, 2),
                    objFile.GetValueAsFloat("LeftDistance", 0, 2),
                    objFile.GetValueAsFloat("RightDistance", 0, 2),
                    objFile.GetValueAsFloat("TopDistance", 0, 2),
                    objFile.GetValueAsFloat("BottomDistance", 0, 2),
                    objFile.GetValueAsFloat("XDistance", 0, 2),
                    objFile.GetValueAsFloat("YDistance", 0, 2),
                    objFile.GetValueAsFloat("Pitch", 0, 2),
                    objFile.GetValueAsFloat("Gap", 0, 2),
                    objFile.GetValueAsFloat("OffSet", 0, 2),
                    objFile.GetValueAsFloat("Skew", 0, 2),
                    objFile.GetValueAsFloat("MinWidth", 0, 2),
                    objFile.GetValueAsFloat("MaxWidth", 0, 2),
                    objFile.GetValueAsFloat("MinHeight", 0, 2),
                    objFile.GetValueAsFloat("MaxHeight", 0, 2),
                    objFile.GetValueAsFloat("MinBaseWidth", 0, 2),
                    objFile.GetValueAsFloat("MaxBaseWidth", 0, 2),
                    objFile.GetValueAsFloat("MinBaseHeight", 0, 2),
                    objFile.GetValueAsFloat("MaxBaseHeight", 0, 2),
                    objFile.GetValueAsFloat("MinTipWidth", 0, 2),
                    objFile.GetValueAsFloat("MaxTipWidth", 0, 2),
                    objFile.GetValueAsFloat("MinTipHeight", 0, 2),
                    objFile.GetValueAsFloat("MaxTipHeight", 0, 2),
                    objFile.GetValueAsFloat("MinPitch", 0, 2),
                    objFile.GetValueAsFloat("MaxPitch", 0, 2),
                    objFile.GetValueAsFloat("MinGap", 0, 2),
                    objFile.GetValueAsFloat("MaxGap", 0, 2),
                    objFile.GetValueAsFloat("Variance", 0, 2),
                    objFile.GetValueAsFloat("MinAGV", 0, 2),
                    objFile.GetValueAsFloat("MaxAGV", 0, 2),
                    objFile.GetValueAsInt("BaseInwardOffset", 0, 2),
                    objFile.GetValueAsInt("TipInwardOffset", 0, 2),
                    objFile.GetValueAsInt("AGVROITolerance_Top", 0, 2),
                    objFile.GetValueAsInt("AGVROITolerance_Right", 0, 2),
                    objFile.GetValueAsInt("AGVROITolerance_Bottom", 0, 2),
                    objFile.GetValueAsInt("AGVROITolerance_Left", 0, 2),
                    objFile.GetValueAsFloat("WidthOffset", 0, 2),
                    objFile.GetValueAsFloat("LengthOffset", 0, 2),
                    objFile.GetValueAsFloat("PitchOffset", 0, 2),
                    objFile.GetValueAsFloat("GapOffset", 0, 2)
                    );
            }

            // Load Pitch Gap
            int intPitchGapCount = objFile.GetValueAsInt("PitchGapCount", 0, 2);
            ClearTemplatePitchGap();
            for (int intPitchGapIndex = 0; intPitchGapIndex < intPitchGapCount; intPitchGapIndex++)
            {
                objFile.GetSecondSection("PitchGap" + intPitchGapIndex);

                //float gg = objFile.GetValueAsFloat("Gap", 0, 2);
                float pp = objFile.GetValueAsFloat("Pitch", 0, 2);
                SetPitchGapData(
                    objFile.GetValueAsInt("FromLeadNo", 0, 2),
                    objFile.GetValueAsInt("ToLeadNo", 0, 2),
                    objFile.GetValueAsFloat("MinPitch", 0, 2),
                    objFile.GetValueAsFloat("MaxPitch", 0, 2),
                    objFile.GetValueAsFloat("MinGap", 0, 2),
                    objFile.GetValueAsFloat("MaxGap", 0, 2),
                    objFile.GetValueAsFloat("Pitch", 0, 2),
                    objFile.GetValueAsFloat("Gap", 0, 2),
                    objFile.GetValueAsInt("StartX", 0, 2),
                    objFile.GetValueAsInt("StartY", 0, 2),
                    objFile.GetValueAsInt("EndX", 0, 2),
                    objFile.GetValueAsInt("EndY", 0, 2),
                    objFile.GetValueAsInt("Direction", 0, 2));
            }

            m_fUnitWidth = objFile.GetValueAsFloat("UnitWidth", 0, 2);
            m_fUnitHeight = objFile.GetValueAsFloat("UnitHeight", 0, 2);
            m_fUnitThickness = objFile.GetValueAsFloat("UnitThickness", 0, 2);
            m_fUnitWidthMin = objFile.GetValueAsFloat("UnitWidthMin", 0, 2);
            m_fUnitWidthMax = objFile.GetValueAsFloat("UnitWidthMax", 0, 2);
            m_fUnitHeightMin = objFile.GetValueAsFloat("UnitHeightMin", 0, 2);
            m_fUnitHeightMax = objFile.GetValueAsFloat("UnitHeightMax", 0, 2);
            m_fUnitThicknessMin = objFile.GetValueAsFloat("UnitThicknessMin", 0, 2);
            m_fUnitThicknessMax = objFile.GetValueAsFloat("UnitThicknessMax", 0, 2);

            m_fUnitSizeLength = objFile.GetValueAsFloat("UnitSizeLength", 0, 2);
            m_fCrackLength = objFile.GetValueAsFloat("CrackLength", 0, 2);
            m_fScratchLength = objFile.GetValueAsFloat("ScratchLength", 0, 2);
            m_fContaminationLength = objFile.GetValueAsFloat("ContaminationLength", 0, 2);
            m_fSolderMeltLength = objFile.GetValueAsFloat("SolderMeltLength", 0, 2);
            m_fVoidLength = objFile.GetValueAsFloat("VoidLength", 0, 2);
            m_fMoldFlashLength = objFile.GetValueAsFloat("MoldFlashLength", 0, 2);
            m_fInCompletePlateLength = objFile.GetValueAsFloat("InCompletePlateLength", 0, 2);
            m_fLeadBrokenLength = objFile.GetValueAsFloat("LeadBrokenLength", 0, 2);

            m_intMPTolerance = objFile.GetValueAsInt("MPTolerance", 3, 2);

        }

        public void LoadLeadTemplateImage(string strFolderPath, int intLeadIndex)
        {
            ROI objROI = new ROI();

            if (File.Exists(strFolderPath + "UnitTemplate" + intLeadIndex + ".bmp"))
            {
                if (!objROI.LoadImage(strFolderPath + "UnitTemplate" + intLeadIndex + ".bmp", false))
                    return;

                DefineTemplateLeadContour2(objROI);
            }

            //if (File.Exists(strFolderPath + "UnitTemplate" + intLeadIndex + ".bmp"))
            //    AddTemplateImage(strFolderPath + "UnitTemplate" + intLeadIndex + ".bmp");

            for (int i = 0; i < m_arrImgLeadImage.Count; i++)
            {
                if (m_arrImgLeadImage[i] != null)
                    m_arrImgLeadImage[i].Dispose();
            }

            m_arrImgLeadImage.Clear();
            int intBlobsCount = GetBlobsFeaturesNumber();
            for (int i = 0; i < intBlobsCount; i++)
            {
                if (File.Exists(strFolderPath + "Lead" + intLeadIndex.ToString() + "_" + i.ToString() + ".bmp"))
                {
                    m_arrImgLeadImage.Add(new EImageBW8());
                    m_arrImgLeadImage[i].Load(strFolderPath + "Lead" + intLeadIndex.ToString() + "_" + i.ToString() + ".bmp");
                }
            }

            LoadUnitPattern(strFolderPath + "UnitMatcher" + intLeadIndex.ToString() + ".mch");
            LoadManualPocketReferencePattern(strFolderPath + "ManualPocketMatcher" + 0.ToString() + ".mch");
            LoadAutoPocketReferencePattern(strFolderPath + "AutoPocketMatcher" + 0.ToString() + ".mch");
            //LoadUnitFinder(strFolderPath + "UnitFinder" + intLeadIndex.ToString() + ".fnd");
            objROI.Dispose();
        }

        /// <summary>
        /// Define template tolerance either use default tolerance or use previous tolerance
        /// </summary>
        /// <param name="blnUseDefault">true = use default tolerance, false = use previous tolerance</param>
        public void DefineTolerance(bool blnUseDefault)
        {
            if (blnUseDefault)
                DefineLeadDefaultTolerance();
            else
                UpdatePreviousToleranceToTemplate();
        }

        public void DefineTolerance2()
        {
            UpdatePreviousToleranceToTemplate();
        }

        public void DefineLeadDefaultTolerance()
        {
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
            }

            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                // Use Pixel to calculate default setting
                m_stcBlobLead.fOffSet = 0.030f;
                m_stcBlobLead.fSkew = 0.030f;

                m_stcBlobLead.fMinWidth = Math.Max(0, m_stcBlobLead.fWidth / m_fMMToPixelXValue - 0.030f);
                m_stcBlobLead.fMaxWidth = m_stcBlobLead.fWidth / m_fMMToPixelXValue + 0.030f;

                m_stcBlobLead.fMinHeight = Math.Max(0, m_stcBlobLead.fHeight / m_fMMToPixelXValue - 0.030f);
                m_stcBlobLead.fMaxHeight = m_stcBlobLead.fHeight / m_fMMToPixelXValue + 0.030f;

                m_stcBlobLead.fMinBaseWidth = Math.Max(0, m_stcBlobLead.fBaseWidth / m_fMMToPixelXValue - 0.030f);
                m_stcBlobLead.fMaxBaseWidth = m_stcBlobLead.fBaseWidth / m_fMMToPixelXValue + 0.030f;

                m_stcBlobLead.fMinBaseHeight = Math.Max(0, m_stcBlobLead.fBaseHeight / m_fMMToPixelXValue - 0.030f);
                m_stcBlobLead.fMaxBaseHeight = m_stcBlobLead.fBaseHeight / m_fMMToPixelXValue + 0.030f;

                m_stcBlobLead.fMinTipWidth = Math.Max(0, m_stcBlobLead.fTipWidth / m_fMMToPixelXValue - 0.030f);
                m_stcBlobLead.fMaxTipWidth = m_stcBlobLead.fTipWidth / m_fMMToPixelXValue + 0.030f;

                m_stcBlobLead.fMinTipHeight = Math.Max(0, m_stcBlobLead.fTipHeight / m_fMMToPixelXValue - 0.030f);
                m_stcBlobLead.fMaxTipHeight = m_stcBlobLead.fTipHeight / m_fMMToPixelXValue + 0.030f;

                m_stcBlobLead.fMinPitch = 0;
                m_stcBlobLead.fMaxPitch = 1;
                m_stcBlobLead.fMinGap = 0;
                m_stcBlobLead.fMaxGap = 1;

                m_stcBlobLead.fVariance = m_fLengthVariance / m_fMMToPixelXValue + 0.030f;

                m_stcBlobLead.fMinAGV = 100;
                m_stcBlobLead.fMaxAGV = 200;

                m_arrTemplateBlobLeads.RemoveAt(i);
                m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
            }
        }

        /// <summary>
        /// Define pitch gap
        /// </summary>
        /// <param name="intPitchGapIndex">pitch gap index</param>
        /// <param name="intFromLeadNo">from Lead no</param>
        /// <param name="intToLeadNo">to Lead no</param>
        private bool DefinePitchGap(int intPitchGapIndex, int intFromLeadNo, int intToLeadNo)
        {
            if ((intFromLeadNo < m_arrTemplateBlobLeads.Count) && (intToLeadNo < m_arrTemplateBlobLeads.Count))
            {
                int intDrawPoint;
                bool blnUpDownFound = false;
                bool blnLeftRightFound = false;
                BlobsFeatures stcFromBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobLeads[intFromLeadNo];
                BlobsFeatures stcToBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobLeads[intToLeadNo];

                int intStartX_From = 0, intStartY_From = 0, intEndX_From = 0, intEndY_From = 0;
                int intStartX_To = 0, intStartY_To = 0, intEndX_To = 0, intEndY_To = 0;

                switch (m_intLeadROIDirection)
                {
                    case 1: //Top
                        intStartX_From = (int)(stcFromBlobsFeatures.fTipCenterX - stcFromBlobsFeatures.fTipWidth / 2);

                        intEndX_From = (int)(stcFromBlobsFeatures.fTipCenterX + stcFromBlobsFeatures.fTipWidth / 2);

                        intStartY_From = (int)(stcFromBlobsFeatures.fTipCenterY);

                        intEndY_From = (int)(stcFromBlobsFeatures.fTipCenterY + stcFromBlobsFeatures.fTipHeight);
                        break;
                    case 2: //Right
                        intStartX_From = (int)(stcFromBlobsFeatures.fTipCenterX - stcFromBlobsFeatures.fTipHeight);

                        intEndX_From = (int)(stcFromBlobsFeatures.fTipCenterX);

                        intStartY_From = (int)(stcFromBlobsFeatures.fTipCenterY - stcFromBlobsFeatures.fTipWidth / 2);

                        intEndY_From = (int)(stcFromBlobsFeatures.fTipCenterY + stcFromBlobsFeatures.fTipWidth / 2);
                        break;
                    case 3: //Bottom
                        intStartX_From = (int)(stcFromBlobsFeatures.fTipCenterX - stcFromBlobsFeatures.fTipWidth / 2);

                        intEndX_From = (int)(stcFromBlobsFeatures.fTipCenterX + stcFromBlobsFeatures.fTipWidth / 2);

                        intStartY_From = (int)(stcFromBlobsFeatures.fTipCenterY - stcFromBlobsFeatures.fTipHeight);

                        intEndY_From = (int)(stcFromBlobsFeatures.fTipCenterY);
                        break;
                    case 4: //Left
                        intStartX_From = (int)(stcFromBlobsFeatures.fTipCenterX);

                        intEndX_From = (int)(stcFromBlobsFeatures.fTipCenterX + stcFromBlobsFeatures.fTipHeight);

                        intStartY_From = (int)(stcFromBlobsFeatures.fTipCenterY - stcFromBlobsFeatures.fTipWidth / 2);

                        intEndY_From = (int)(stcFromBlobsFeatures.fTipCenterY + stcFromBlobsFeatures.fTipWidth / 2);
                        break;
                }

                switch (m_intLeadROIDirection)
                {
                    case 1: //Top
                        intStartX_To = (int)(stcToBlobsFeatures.fTipCenterX - stcToBlobsFeatures.fTipWidth / 2);

                        intEndX_To = (int)(stcToBlobsFeatures.fTipCenterX + stcToBlobsFeatures.fTipWidth / 2);

                        intStartY_To = (int)(stcToBlobsFeatures.fTipCenterY);

                        intEndY_To = (int)(stcToBlobsFeatures.fTipCenterY + stcToBlobsFeatures.fTipHeight);
                        break;
                    case 2: //Right
                        intStartX_To = (int)(stcToBlobsFeatures.fTipCenterX - stcToBlobsFeatures.fTipHeight);

                        intEndX_To = (int)(stcToBlobsFeatures.fTipCenterX);

                        intStartY_To = (int)(stcToBlobsFeatures.fTipCenterY - stcToBlobsFeatures.fTipWidth / 2);

                        intEndY_To = (int)(stcToBlobsFeatures.fTipCenterY + stcToBlobsFeatures.fTipWidth / 2);
                        break;
                    case 3: //Bottom
                        intStartX_To = (int)(stcToBlobsFeatures.fTipCenterX - stcToBlobsFeatures.fTipWidth / 2);

                        intEndX_To = (int)(stcToBlobsFeatures.fTipCenterX + stcToBlobsFeatures.fTipWidth / 2);

                        intStartY_To = (int)(stcToBlobsFeatures.fTipCenterY - stcToBlobsFeatures.fTipHeight);

                        intEndY_To = (int)(stcToBlobsFeatures.fTipCenterY);
                        break;
                    case 4: //Left
                        intStartX_To = (int)(stcToBlobsFeatures.fTipCenterX);

                        intEndX_To = (int)(stcToBlobsFeatures.fTipCenterX + stcToBlobsFeatures.fTipHeight);

                        intStartY_To = (int)(stcToBlobsFeatures.fTipCenterY - stcToBlobsFeatures.fTipWidth / 2);

                        intEndY_To = (int)(stcToBlobsFeatures.fTipCenterY + stcToBlobsFeatures.fTipWidth / 2);
                        break;
                }


                //// Check pitch available between up and down Leads
                //if ((stcFromBlobsFeatures.intStartX >= stcToBlobsFeatures.intStartX) && (stcFromBlobsFeatures.intStartX <= stcToBlobsFeatures.intEndX) ||
                //    (stcFromBlobsFeatures.intEndX >= stcToBlobsFeatures.intStartX) && (stcFromBlobsFeatures.intEndX <= stcToBlobsFeatures.intEndX) ||
                //    (stcToBlobsFeatures.intStartX >= stcFromBlobsFeatures.intStartX) && (stcToBlobsFeatures.intEndX <= stcFromBlobsFeatures.intEndX) ||
                //    (stcToBlobsFeatures.intEndX >= stcFromBlobsFeatures.intStartX) && (stcToBlobsFeatures.intEndX <= stcFromBlobsFeatures.intEndX))
                //{
                //    blnUpDownFound = true;
                //}

                //// Check pitch available between left and right Leads
                //if ((stcFromBlobsFeatures.intStartY >= stcToBlobsFeatures.intStartY) && (stcFromBlobsFeatures.intStartY <= stcToBlobsFeatures.intEndY) ||
                //    (stcFromBlobsFeatures.intEndY >= stcToBlobsFeatures.intStartY) && (stcFromBlobsFeatures.intEndY <= stcToBlobsFeatures.intEndY) ||
                //    (stcToBlobsFeatures.intStartY >= stcFromBlobsFeatures.intStartY) && (stcToBlobsFeatures.intEndY <= stcFromBlobsFeatures.intEndY) ||
                //    (stcToBlobsFeatures.intEndY >= stcFromBlobsFeatures.intStartY) && (stcToBlobsFeatures.intEndY <= stcFromBlobsFeatures.intEndY))
                //{
                //    blnLeftRightFound = true;
                //}

                // Check pitch available between up and down Leads
                if ((intStartX_From >= intStartX_To) && (intStartX_From <= intEndX_To) ||
                    (intEndX_From >= intStartX_To) && (intEndX_From <= intEndX_To) ||
                    (intStartX_To >= intStartX_From) && (intEndX_To <= intEndX_From) ||
                    (intEndX_To >= intStartX_From) && (intEndX_To <= intEndX_From))
                {
                    blnUpDownFound = true;
                }

                // Check pitch available between left and right Leads
                if ((intStartY_From >= intStartY_To) && (intStartY_From <= intEndY_To) ||
                    (intEndY_From >= intStartY_To) && (intEndY_From <= intEndY_To) ||
                    (intStartY_To >= intStartY_From) && (intEndY_To <= intEndY_From) ||
                    (intEndY_To >= intStartY_From) && (intEndY_To <= intEndY_From))
                {
                    blnLeftRightFound = true;
                }

                // Pitch only available in up down or left right only
                if ((blnLeftRightFound && !blnUpDownFound) || (!blnLeftRightFound && blnUpDownFound))
                {
                    if (blnUpDownFound)
                    {
                        //// Pitch only available if distance gap between Leads > 1 pixel
                        //if ((stcToBlobsFeatures.intStartY - stcFromBlobsFeatures.intEndY) > 1)
                        //{
                        //    intDrawPoint = GetDrawPoint(stcFromBlobsFeatures.intStartX, stcFromBlobsFeatures.intEndX, stcToBlobsFeatures.intStartX, stcToBlobsFeatures.intEndX);
                        //    m_stcPitchGap.intStartPointX = intDrawPoint;
                        //    m_stcPitchGap.intEndPointX = intDrawPoint;
                        //    m_stcPitchGap.intStartPointY = stcFromBlobsFeatures.intEndY;
                        //    m_stcPitchGap.intEndPointY = stcToBlobsFeatures.intStartY;
                        //    //m_stcPitchGap.fGap = stcToBlobsFeatures.intStartY - stcFromBlobsFeatures.intEndY;
                        //    m_stcPitchGap.fPitch = stcToBlobsFeatures.fTipCenterY - stcFromBlobsFeatures.fTipCenterY;
                        //    m_stcPitchGap.intDirection = 180;
                        //    DefinePitchGapTolerance();
                        //    return true;
                        //}
                        //else if ((stcFromBlobsFeatures.intStartY - stcToBlobsFeatures.intEndY) > 1)
                        //{
                        //    intDrawPoint = GetDrawPoint(stcFromBlobsFeatures.intStartX, stcFromBlobsFeatures.intEndX, stcToBlobsFeatures.intStartX, stcToBlobsFeatures.intEndX);
                        //    m_stcPitchGap.intStartPointX = intDrawPoint;
                        //    m_stcPitchGap.intEndPointX = intDrawPoint;
                        //    m_stcPitchGap.intStartPointY = stcFromBlobsFeatures.intStartY;
                        //    m_stcPitchGap.intEndPointY = stcToBlobsFeatures.intEndY;
                        //    //m_stcPitchGap.fGap = stcFromBlobsFeatures.intStartY - stcToBlobsFeatures.intEndY;
                        //    m_stcPitchGap.fPitch = stcFromBlobsFeatures.fTipCenterY - stcToBlobsFeatures.fTipCenterY;
                        //    m_stcPitchGap.intDirection = 0;
                        //    DefinePitchGapTolerance();
                        //    return true;
                        //}
                        //else
                        //{
                        //    return false;
                        //}

                        // Pitch only available if distance gap between Leads > 1 pixel
                        if ((intStartY_To - intEndY_From) > 1)
                        {
                            intDrawPoint = GetDrawPoint(intStartX_From, intEndX_From, intStartX_To, intEndX_To);
                            m_stcPitchGap.intStartPointX = intDrawPoint;
                            m_stcPitchGap.intEndPointX = intDrawPoint;
                            m_stcPitchGap.intStartPointY = intEndY_From;
                            m_stcPitchGap.intEndPointY = intStartY_To;
                            m_stcPitchGap.fGap = intStartY_To - intEndY_From;
                            m_stcPitchGap.fPitch = stcToBlobsFeatures.fTipCenterY - stcFromBlobsFeatures.fTipCenterY;
                            m_stcPitchGap.intDirection = 180;
                            //DefinePitchGapTolerance();
                            UpdatePreviousPitchToleranceToTemplate(intPitchGapIndex);//UpdatePreviousPitchToleranceToTemplate(); // 2021-06-03 ZJYEOH : Assign previous tolerance according to intPitchGapIndex
                            return true;
                        }
                        else if ((intStartY_From - intEndY_To) > 1)
                        {
                            intDrawPoint = GetDrawPoint(intStartX_From, intEndX_From, intStartX_To, intEndX_To);
                            m_stcPitchGap.intStartPointX = intDrawPoint;
                            m_stcPitchGap.intEndPointX = intDrawPoint;
                            m_stcPitchGap.intStartPointY = intStartY_From;
                            m_stcPitchGap.intEndPointY = intEndY_To;
                            m_stcPitchGap.fGap = intStartY_From - intEndY_To;
                            m_stcPitchGap.fPitch = stcFromBlobsFeatures.fTipCenterY - stcToBlobsFeatures.fTipCenterY;
                            m_stcPitchGap.intDirection = 0;
                            //DefinePitchGapTolerance();
                            UpdatePreviousPitchToleranceToTemplate(intPitchGapIndex);//UpdatePreviousPitchToleranceToTemplate(); // 2021-06-03 ZJYEOH : Assign previous tolerance according to intPitchGapIndex
                            return true;
                        }
                        else
                        {
                            return false;
                        }
                    }
                    else
                    {
                        //// Pitch only available if distance gap between Leads > 1 pixel
                        //if ((stcToBlobsFeatures.intStartX - stcFromBlobsFeatures.intEndX) > 1)
                        //{
                        //    intDrawPoint = GetDrawPoint(stcFromBlobsFeatures.intStartY, stcFromBlobsFeatures.intEndY, stcToBlobsFeatures.intStartY, stcToBlobsFeatures.intEndY);
                        //    m_stcPitchGap.intStartPointX = stcFromBlobsFeatures.intEndX;
                        //    m_stcPitchGap.intEndPointX = stcToBlobsFeatures.intStartX;
                        //    m_stcPitchGap.intStartPointY = intDrawPoint;
                        //    m_stcPitchGap.intEndPointY = intDrawPoint;
                        //    //m_stcPitchGap.fGap = stcToBlobsFeatures.intStartX - stcFromBlobsFeatures.intEndX;
                        //    m_stcPitchGap.fPitch = stcToBlobsFeatures.fTipCenterX - stcFromBlobsFeatures.fTipCenterX;
                        //    m_stcPitchGap.intDirection = 90;
                        //    DefinePitchGapTolerance();
                        //    return true;
                        //}
                        //else if ((stcFromBlobsFeatures.intStartX - stcToBlobsFeatures.intEndX) > 1)
                        //{
                        //    intDrawPoint = GetDrawPoint(stcFromBlobsFeatures.intStartY, stcFromBlobsFeatures.intEndY, stcToBlobsFeatures.intStartY, stcToBlobsFeatures.intEndY);
                        //    m_stcPitchGap.intStartPointX = stcFromBlobsFeatures.intStartX;
                        //    m_stcPitchGap.intEndPointX = stcToBlobsFeatures.intEndX;
                        //    m_stcPitchGap.intStartPointY = intDrawPoint;
                        //    m_stcPitchGap.intEndPointY = intDrawPoint;
                        //    //m_stcPitchGap.fGap = stcFromBlobsFeatures.intStartX - stcToBlobsFeatures.intEndX;
                        //    m_stcPitchGap.fPitch = stcFromBlobsFeatures.fTipCenterX - stcToBlobsFeatures.fTipCenterX;
                        //    DefinePitchGapTolerance();
                        //    m_stcPitchGap.intDirection = 270;
                        //    return true;
                        //}
                        //else
                        //{
                        //    return false;
                        //}

                        // Pitch only available if distance gap between Leads > 1 pixel
                        if ((intStartX_To - intEndX_From) > 1)
                        {
                            intDrawPoint = GetDrawPoint(intStartY_From, intEndY_From, intStartY_To, intEndY_To);
                            m_stcPitchGap.intStartPointX = intEndX_From;
                            m_stcPitchGap.intEndPointX = intStartX_To;
                            m_stcPitchGap.intStartPointY = intDrawPoint;
                            m_stcPitchGap.intEndPointY = intDrawPoint;
                            m_stcPitchGap.fGap = intStartX_To - intEndX_From;
                            m_stcPitchGap.fPitch = stcToBlobsFeatures.fTipCenterX - stcFromBlobsFeatures.fTipCenterX;
                            m_stcPitchGap.intDirection = 90;
                            //DefinePitchGapTolerance();
                            UpdatePreviousPitchToleranceToTemplate(intPitchGapIndex);//UpdatePreviousPitchToleranceToTemplate(); // 2021-06-03 ZJYEOH : Assign previous tolerance according to intPitchGapIndex
                            return true;
                        }
                        else if ((intStartX_From - intEndX_To) > 1)
                        {
                            intDrawPoint = GetDrawPoint(intStartY_From, intEndY_From, intStartY_To, intEndY_To);
                            m_stcPitchGap.intStartPointX = intStartX_From;
                            m_stcPitchGap.intEndPointX = intEndX_To;
                            m_stcPitchGap.intStartPointY = intDrawPoint;
                            m_stcPitchGap.intEndPointY = intDrawPoint;
                            m_stcPitchGap.fGap = intStartX_From - intEndX_To;
                            m_stcPitchGap.fPitch = stcFromBlobsFeatures.fTipCenterX - stcToBlobsFeatures.fTipCenterX;
                            //DefinePitchGapTolerance();
                            UpdatePreviousPitchToleranceToTemplate(intPitchGapIndex);//UpdatePreviousPitchToleranceToTemplate(); // 2021-06-03 ZJYEOH : Assign previous tolerance according to intPitchGapIndex
                            m_stcPitchGap.intDirection = 270;
                            return true;
                        }
                        else
                        {
                            return false;
                        }
                    }
                }
                else
                    return false;
            }
            return true;
        }

        /// <summary>
        /// Update previous pitch gap tolerance into current template
        /// </summary>
        /// <param name="intIndex">m_arrTolePitchGap index</param>
        private void UpdatePreviousPitchToleranceToTemplate()
        {
            PitchGap stcBackupPitchGap = new PitchGap();

            int intSelectedIndex = -1;
            float fDiffSmallestArea = float.MaxValue;
            for (int i = 0; i < m_arrBackupPitchGap.Count; i++)
            {
                stcBackupPitchGap = (PitchGap)m_arrBackupPitchGap[i];

                // Get smallest different pitch size between current and previous learn pitch size.
                if (Math.Abs(m_stcPitchGap.fPitch - ((PitchGap)stcBackupPitchGap).fPitch) < fDiffSmallestArea)
                {
                    fDiffSmallestArea = Math.Abs(m_stcPitchGap.fPitch - ((PitchGap)stcBackupPitchGap).fPitch);
                    intSelectedIndex = i;
                }

            }
            if (intSelectedIndex >= 0)
            {
                m_stcTolePitchGap = (TolerancePitchGap)m_arrTolePitchGap[intSelectedIndex];

                m_stcPitchGap.fMinGap = m_stcTolePitchGap.fMinGap;
                m_stcPitchGap.fMaxGap = m_stcTolePitchGap.fMaxGap;
                m_stcPitchGap.fMinPitch = m_stcTolePitchGap.fMinPitch;
                m_stcPitchGap.fMaxPitch = m_stcTolePitchGap.fMaxPitch;
            }
        }
        private void UpdatePreviousPitchToleranceToTemplate(int intSelectedIndex)
        {
            if (intSelectedIndex >= 0 && intSelectedIndex < m_arrTolePitchGap.Count)
            {
                m_stcTolePitchGap = (TolerancePitchGap)m_arrTolePitchGap[intSelectedIndex];

                m_stcPitchGap.fMinGap = m_stcTolePitchGap.fMinGap;
                m_stcPitchGap.fMaxGap = m_stcTolePitchGap.fMaxGap;
                m_stcPitchGap.fMinPitch = m_stcTolePitchGap.fMinPitch;
                m_stcPitchGap.fMaxPitch = m_stcTolePitchGap.fMaxPitch;
            }
        }
        /// <summary>
        /// Define default pitch gap tolerance
        /// </summary>
        private void DefinePitchGapTolerance()
        {
            m_stcPitchGap.fMinGap = (m_stcPitchGap.fGap - m_fDefaultPixelTolerance) / m_fMMToPixelXValue;
            m_stcPitchGap.fMaxGap = (m_stcPitchGap.fGap + m_fDefaultPixelTolerance) / m_fMMToPixelXValue;
            m_stcPitchGap.fMinPitch = (m_stcPitchGap.fPitch - m_fDefaultPixelTolerance) / m_fMMToPixelXValue;
            m_stcPitchGap.fMaxPitch = (m_stcPitchGap.fPitch + m_fDefaultPixelTolerance) / m_fMMToPixelXValue;
        }

        private void InitLeadInspectionData(ROI objROI, int intNumSelectedObject)
        {
            m_intTemplateMatchStatus = new int[m_arrTemplateBlobLeads.Count];
            m_intSampleMatchNumber = new int[intNumSelectedObject];
            m_fSampleLeadRangeStartX = objROI.ref_ROIWidth;
            m_fSampleLeadRangeStartY = objROI.ref_ROIHeight;
            m_fSampleLeadRangeEndX = 0;
            m_fSampleLeadRangeEndY = 0;
            m_fSampleReferencePointStartX = -999; // objROI.ref_ROIWidth;   // 2020 08 14 - CCENG - change m_fSampleReferencePoint Start End X Y change to -999 to indicate inspection fail or not before set this variable.
            m_fSampleReferencePointStartY = -999; // objROI.ref_ROIHeight;
            m_fSampleReferencePointEndX = -999; // 0;
            m_fSampleReferencePointEndY = -999; // 0;
            m_fSampleLeadMinSpanStart = -999;
            m_fSampleLeadMaxSpanStart = -999;
            m_fSampleLeadMinSpanEnd = -999;
            m_fSampleLeadMaxSpanEnd = -999;

            for (int k = 0; k < intNumSelectedObject; k++)
            {
                m_intSampleMatchNumber[k] = -1;
            }

            for (int i = 0; i < m_arrSampleBlobLeads.Length; i++)
            {
                m_arrSampleBlobLeads[i].fOffSet = -999;
                m_arrSampleBlobLeads[i].fSkew = -999;
                m_arrSampleBlobLeads[i].fArea = -999;
                m_arrSampleBlobLeads[i].fWidth = -999;
                m_arrSampleBlobLeads[i].fHeight = -999;
                m_arrSampleBlobLeads[i].fPitch = -999;
                m_arrSampleBlobLeads[i].fGap = -999;
                m_arrSampleBlobLeads[i].intFailMask = 0;
                m_arrSampleBlobLeads[i].fStartX = -999;
                m_arrSampleBlobLeads[i].fStartY = -999;
                m_arrSampleBlobLeads[i].fEndX = -999;
                m_arrSampleBlobLeads[i].fEndY = -999;
                m_arrSampleBlobLeads[i].fCenterX = -999;
                m_arrSampleBlobLeads[i].fCenterY = -999;
                m_arrSampleBlobLeads[i].intContourIndex = -1;

                m_arrSampleBlobLeads[i].fOffSetMM = -999;
                m_arrSampleBlobLeads[i].fSkewMM = -999;
                m_arrSampleBlobLeads[i].fAreaMM = -999;
                m_arrSampleBlobLeads[i].fWidthMM = -999;
                m_arrSampleBlobLeads[i].fHeightMM = -999;
                m_arrSampleBlobLeads[i].fBaseWidthMM = -999;
                m_arrSampleBlobLeads[i].fBaseHeightMM = -999;
                m_arrSampleBlobLeads[i].fTipWidthMM = -999;
                m_arrSampleBlobLeads[i].fTipHeightMM = -999;
                m_arrSampleBlobLeads[i].fPitchMM = -999;
                m_arrSampleBlobLeads[i].fGapMM = -999;
                m_arrSampleBlobLeads[i].fAGV = -999;

                m_arrSampleBlobLeads[i].fBaseCenterX = -999;
                m_arrSampleBlobLeads[i].fBaseCenterY = -999;
                m_arrSampleBlobLeads[i].fTipCenterX = -999;
                m_arrSampleBlobLeads[i].fTipCenterY = -999;
                m_arrSampleBlobLeads[i].fBaseWidth = -999;
                m_arrSampleBlobLeads[i].fBaseHeight = -999;
                m_arrSampleBlobLeads[i].fTipWidth = -999;
                m_arrSampleBlobLeads[i].fTipHeight = -999;
            }
        }
        private void InitLeadInspectionData_BaseLead(ROI objROI, int intNumSelectedObject)
        {
            m_intTemplateMatchStatus_BaseLead = new int[m_arrTemplateBlobLeads_BaseLead.Count];
            m_intSampleMatchNumber_BaseLead = new int[intNumSelectedObject];
            for (int k = 0; k < intNumSelectedObject; k++)
            {
                m_intSampleMatchNumber_BaseLead[k] = -1;
            }

            for (int i = 0; i < m_arrSampleBlobLeads_BaseLead.Length; i++)
            {
                m_arrSampleBlobLeads_BaseLead[i].fOffSet = -999;
                m_arrSampleBlobLeads_BaseLead[i].fSkew = -999;
                m_arrSampleBlobLeads_BaseLead[i].fArea = -999;
                m_arrSampleBlobLeads_BaseLead[i].fWidth = -999;
                m_arrSampleBlobLeads_BaseLead[i].fHeight = -999;
                m_arrSampleBlobLeads_BaseLead[i].fPitch = -999;
                m_arrSampleBlobLeads_BaseLead[i].fGap = -999;
                m_arrSampleBlobLeads_BaseLead[i].intFailMask = 0;
                m_arrSampleBlobLeads_BaseLead[i].fStartX = -999;
                m_arrSampleBlobLeads_BaseLead[i].fStartY = -999;
                m_arrSampleBlobLeads_BaseLead[i].fEndX = -999;
                m_arrSampleBlobLeads_BaseLead[i].fEndY = -999;
                m_arrSampleBlobLeads_BaseLead[i].fCenterX = -999;
                m_arrSampleBlobLeads_BaseLead[i].fCenterY = -999;
                m_arrSampleBlobLeads_BaseLead[i].intContourIndex = -1;

                m_arrSampleBlobLeads_BaseLead[i].fOffSetMM = -999;
                m_arrSampleBlobLeads_BaseLead[i].fSkewMM = -999;
                m_arrSampleBlobLeads_BaseLead[i].fAreaMM = -999;
                m_arrSampleBlobLeads_BaseLead[i].fWidthMM = -999;
                m_arrSampleBlobLeads_BaseLead[i].fHeightMM = -999;
            }
        }
        private void InitLeadInspectionData_Lead3D(ROI objROI)
        {
            m_intTemplateMatchStatus = new int[m_arrTemplateBlobLeads.Count];
            m_fSampleLeadRangeStartX = objROI.ref_ROIWidth;
            m_fSampleLeadRangeStartY = objROI.ref_ROIHeight;
            m_fSampleLeadRangeEndX = 0;
            m_fSampleLeadRangeEndY = 0;
            m_fSampleReferencePointStartX = objROI.ref_ROIWidth;
            m_fSampleReferencePointStartY = objROI.ref_ROIHeight;
            m_fSampleReferencePointEndX = 0;
            m_fSampleReferencePointEndY = 0;

            for (int i = 0; i < m_arrSampleBlobLeads.Length; i++)
            {
                m_arrSampleBlobLeads[i].fOffSet = -999;
                m_arrSampleBlobLeads[i].fArea = -999;
                m_arrSampleBlobLeads[i].fWidth = -999;
                m_arrSampleBlobLeads[i].fHeight = -999;
                m_arrSampleBlobLeads[i].fPitch = -999;
                m_arrSampleBlobLeads[i].fGap = -999;
                m_arrSampleBlobLeads[i].intFailMask = 0;
                m_arrSampleBlobLeads[i].fStartX = -999;
                m_arrSampleBlobLeads[i].fStartY = -999;
                m_arrSampleBlobLeads[i].fEndX = -999;
                m_arrSampleBlobLeads[i].fEndY = -999;
                m_arrSampleBlobLeads[i].fCenterX = -999;
                m_arrSampleBlobLeads[i].fCenterY = -999;
                m_arrSampleBlobLeads[i].intContourIndex = -1;

                m_arrSampleBlobLeads[i].fOffSetMM = -999;
                m_arrSampleBlobLeads[i].fAreaMM = -999;
                m_arrSampleBlobLeads[i].fWidthMM = -999;
                m_arrSampleBlobLeads[i].fHeightMM = -999;
                m_arrSampleBlobLeads[i].fPitchMM = -999;
                m_arrSampleBlobLeads[i].fGapMM = -999;

                m_arrSampleBlobLeads[i].fBaseCenterX = -999;
                m_arrSampleBlobLeads[i].fBaseCenterY = -999;
                m_arrSampleBlobLeads[i].fTipCenterX = -999;
                m_arrSampleBlobLeads[i].fTipCenterY = -999;
                m_arrSampleBlobLeads[i].fBaseWidth = -999;
                m_arrSampleBlobLeads[i].fBaseHeight = -999;
                m_arrSampleBlobLeads[i].fTipWidth = -999;
                m_arrSampleBlobLeads[i].fTipHeight = -999;
            }
        }
        public bool InspectBaseLead(ROI objROI, List<ROI> arrLeadROIs, List<List<PointF>> arrDontCare)
        {
            bool blnWantDebug = false;
            m_blnLock = true;

            lock (m_objLockBlobs)
            {
                HiPerfTimer t1 = new HiPerfTimer();
                t1.Start();
                string strTrack = "";
                float fTimingPrev = 0;
                float fTiming = 0;

                // 2020 10 12 - CCENG: Add img processing Open to filter noise surrouding base lead 
                EasyImage.Open(objROI.ref_ROI, objROI.ref_ROI, 1);

                //Draw don't care ROI edge to make sure Don't Care Area is not inspected
                for (int k = 1; k < arrLeadROIs.Count; k++)
                {
                    arrLeadROIs[k].AttachImage(objROI);    // objROI == m_smVisionInfo.g_arrInspectLeadROI[intLeadIndex]
                    arrLeadROIs[k].DrawDontCareEdge(0);
                }
                //System.Threading.Thread.Sleep(3); // 2020 08 14 - CCENG: old code. 
                
                // Build Lead as blobs objects and holes
                m_objEBlobs_BaseLead.CleanAllBlobs();

                if (blnWantDebug)
                {
                    objROI.SaveImage("D:\\TS\\objROI.bmp");
                }

                //WriteDebug("C");
                BuildOnlyLeadObjects_BaseLead(objROI);

                fTiming = t1.Timing;
                strTrack += ", 1=" + (fTiming - fTimingPrev).ToString();
                fTimingPrev = fTiming;

                //WriteDebug("A");
                // Init data base on ROI and Blobs size
                int intNumSelectedObject = m_objEBlobs_BaseLead.ref_intNumSelectedObject;
                if (intNumSelectedObject == 0 && m_arrTemplateBlobLeads_BaseLead.Count > 0)   // Missing Lead if template got Leads but sample is empty
                {
                    for (int i = 0; i < m_arrTemplateBlobLeads_BaseLead.Count; i++)
                    {
                        m_intFailResultMask |= 0x04;
                        m_arrSampleBlobLeads_BaseLead[i].intFailMask |= 0x04;
                    }
                    m_blnLock = false;
                    return false;
                }

                InitLeadInspectionData_BaseLead(objROI, intNumSelectedObject);

                LeadTestStage1_BaseLead(objROI, arrDontCare);

                fTiming = t1.Timing;
                strTrack += ", 2=" + (fTiming - fTimingPrev).ToString();
                fTimingPrev = fTiming;
                
                m_blnLock = false;

                if (m_intFailResultMask == 0)
                    return true;
                else
                    return false;
            }
        }
        /// <summary>
        /// Perform Lead inspection
        /// </summary>
        /// <param name="objImage">main image</param>
        /// <param name="objROI">Lead ROI</param>
        /// <param name="arrDontCare">dont care area start and end point</param>
        public bool InspectLead(ROI objROI, List<ROI> arrLeadROIs, List<List<PointF>> arrDontCare)
        {
            m_blnLock = true;

            lock (m_objLockBlobs)
            {
                HiPerfTimer t1 = new HiPerfTimer();
                t1.Start();
                string strTrack = "";
                float fTimingPrev = 0;
                float fTiming = 0;


                //if (m_intSensitivityOnLeadMethod == 1)   // Split or segment object
                //{
                //    EasyImage.OpenBox(objROI.ref_ROI, objROI.ref_ROI, m_intSensitivityOnLeadValue);
                //}
                //else if (m_intSensitivityOnLeadMethod == 2)  // Merge object
                //{
                //    EasyImage.CloseBox(objROI.ref_ROI, objROI.ref_ROI, m_intSensitivityOnLeadValue);
                //}

                //Draw don't care ROI edge to make sure Don't Care Area is not inspected
                for (int k = 1; k < arrLeadROIs.Count; k++)
                {
                    arrLeadROIs[k].AttachImage(objROI);    // objROI == m_smVisionInfo.g_arrInspectLeadROI[intLeadIndex]
                    arrLeadROIs[k].DrawDontCareEdge(0);
                }
                //System.Threading.Thread.Sleep(3); // 2020 08 14 - CCENG: old code. 

                //// Define actual threshold value
                //m_intThresholdValuePrev = m_intThresholdValue;
                //if (m_intThresholdValue == -4)
                //    m_intThresholdValue = GetAutoThresholdValue(objROI, 3);

                //if (m_blnWantTightSetting)
                //{
                //    /*
                //     * When Setting is tight, mean unit easiy fail.
                //     *  - When test run for Pass unit, set tight to true for the first time filtering. and set tight to false for the subsequence 3x test run.
                //     *     - when setting is tight, minus 25 to current threshold value for white area inspection (Foreignn Material, Excess Area, dimension)
                //     *     - when setting is tight, add 25 to current threshold value for black area inspection (Lead broken Area)
                //     */
                //    m_intDarkThresholdValue = m_intThresholdValue + m_intTightSettingThresholdTolerance;
                //    if (m_intDarkThresholdValue > 254)
                //        m_intDarkThresholdValue = 254;

                //    m_intThresholdValue -= m_intTightSettingThresholdTolerance;
                //    if (m_intThresholdValue < 1)
                //        m_intThresholdValue = 1;
                //}
                //else
                //{
                //    m_intDarkThresholdValue = m_intThresholdValue;
                //}

                // Build Lead as blobs objects and holes
                m_objEBlobs.CleanAllBlobs();

                //WriteDebug("C");
                BuildOnlyLeadObjects(objROI);

                fTiming = t1.Timing;
                strTrack += ", 1=" + (fTiming - fTimingPrev).ToString();
                fTimingPrev = fTiming;

                //WriteDebug("A");
                // Init data base on ROI and Blobs size
                int intNumSelectedObject = m_objEBlobs.ref_intNumSelectedObject;
                if (intNumSelectedObject == 0 && m_arrTemplateBlobLeads.Count > 0)   // Missing Lead if template got Leads but sample is empty
                {
                    for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
                    {
                        m_intFailResultMask |= 0x04;
                        m_arrSampleBlobLeads[i].intFailMask |= 0x04;
                    }
                    m_blnLock = false;
                    return false;
                }

                InitLeadInspectionData(objROI, intNumSelectedObject);

                LeadTestStage1(objROI, arrDontCare);

                fTiming = t1.Timing;
                strTrack += ", 2=" + (fTiming - fTimingPrev).ToString();
                fTimingPrev = fTiming;

                //CheckReferencePoint(); // 2019-10-15 ZJYEOH : Temporary hide CheckReferencePoint() first because our spec dont have

                //WriteDebug("F");
                if (m_blnWantUsePkgToBaseTolerance)
                    CheckDimension_PkgToBase(objROI);
                else
                    CheckDimension(objROI);

                CheckReferencePoint();

                CheckAverageGrayValue(objROI);

                CheckVariance(objROI);

                CheckSpan(objROI);

                //WriteDebug("G");
                CheckPitchGap(objROI);

                fTiming = t1.Timing;
                strTrack += ", 3=" + (fTiming - fTimingPrev).ToString();
                fTimingPrev = fTiming;

                //// Create a blobs backup for inspection result drawing
                //m_intThresholdValue = m_intThresholdValuePrev;

                ////WriteDebug("K");

                //if (strTrack.Length > 0)
                //{
                //    TrackLog objTL2 = new TrackLog("D:\\TS\\");
                //    objTL2.WriteLine(strTrack);
                //}

                m_blnLock = false;

                if (m_intFailResultMask == 0)
                    return true;
                else
                    return false;
            }
        }
        public bool InspectLead_ForBaseLineRotation(ROI objROI, List<ROI> arrLeadROIs, List<List<PointF>> arrDontCare)
        {
            m_blnLock = true;

            //objROI.SaveImage("D:\\TS\\1.objROI.bmp");
            //arrLeadROIs[0].SaveImage("D:\\TS\\1.arrLeadROIs.bmp");

            lock (m_objLockBlobs)
            {
                HiPerfTimer t1 = new HiPerfTimer();
                t1.Start();
                string strTrack = "";
                float fTimingPrev = 0;
                float fTiming = 0;


                //if (m_intSensitivityOnLeadMethod == 1)   // Split or segment object
                //{
                //    EasyImage.OpenBox(objROI.ref_ROI, objROI.ref_ROI, m_intSensitivityOnLeadValue);
                //}
                //else if (m_intSensitivityOnLeadMethod == 2)  // Merge object
                //{
                //    EasyImage.CloseBox(objROI.ref_ROI, objROI.ref_ROI, m_intSensitivityOnLeadValue);
                //}

                //Draw don't care ROI edge to make sure Don't Care Area is not inspected
                for (int k = 1; k < arrLeadROIs.Count; k++)
                {
                    arrLeadROIs[k].AttachImage(objROI);    // objROI == m_smVisionInfo.g_arrInspectLeadROI[intLeadIndex]
                    arrLeadROIs[k].DrawDontCareEdge(0);
                }
                System.Threading.Thread.Sleep(3);

                //// Define actual threshold value
                //m_intThresholdValuePrev = m_intThresholdValue;
                //if (m_intThresholdValue == -4)
                //    m_intThresholdValue = GetAutoThresholdValue(objROI, 3);

                //if (m_blnWantTightSetting)
                //{
                //    /*
                //     * When Setting is tight, mean unit easiy fail.
                //     *  - When test run for Pass unit, set tight to true for the first time filtering. and set tight to false for the subsequence 3x test run.
                //     *     - when setting is tight, minus 25 to current threshold value for white area inspection (Foreignn Material, Excess Area, dimension)
                //     *     - when setting is tight, add 25 to current threshold value for black area inspection (Lead broken Area)
                //     */
                //    m_intDarkThresholdValue = m_intThresholdValue + m_intTightSettingThresholdTolerance;
                //    if (m_intDarkThresholdValue > 254)
                //        m_intDarkThresholdValue = 254;

                //    m_intThresholdValue -= m_intTightSettingThresholdTolerance;
                //    if (m_intThresholdValue < 1)
                //        m_intThresholdValue = 1;
                //}
                //else
                //{
                //    m_intDarkThresholdValue = m_intThresholdValue;
                //}

                // Build Lead as blobs objects and holes
                m_objEBlobs.CleanAllBlobs();

                //WriteDebug("C");
                BuildOnlyLeadObjects(objROI);

                fTiming = t1.Timing;
                strTrack += ", 1=" + (fTiming - fTimingPrev).ToString();
                fTimingPrev = fTiming;

                //WriteDebug("A");
                // Init data base on ROI and Blobs size
                int intNumSelectedObject = m_objEBlobs.ref_intNumSelectedObject;
                if (intNumSelectedObject == 0 && m_arrTemplateBlobLeads.Count > 0)   // Missing Lead if template got Leads but sample is empty
                {
                    m_blnLock = false;
                    return false;
                }
                else if (m_arrTemplateBlobLeads.Count == 1) //2021-05-26 ZJYEOH : will ignore the base line if only one lead
                {
                    m_blnLock = false;
                    return false;
                }

                InitLeadInspectionData(objROI, intNumSelectedObject);

                LeadTestStage1(objROI, arrDontCare);

                fTiming = t1.Timing;
                strTrack += ", 2=" + (fTiming - fTimingPrev).ToString();
                fTimingPrev = fTiming;

                //CheckReferencePoint(); // 2019-10-15 ZJYEOH : Temporary hide CheckReferencePoint() first because our spec dont have

                //WriteDebug("F");
                if (m_blnWantUsePkgToBaseTolerance)
                    CheckDimension_PkgToBase(objROI);
                else
                    CheckDimension(objROI);

                CheckReferencePoint();
                
                m_blnLock = false;

                //if (m_intFailResultMask == 0)
                    return true;
                //else
                //    return false;
            }
        }
        /// <summary>
        /// Undo selected object or deselect m_arrTemplateBlobLeads object
        /// </summary>
        public void UndoSelectedObject()
        {
            UndoSelectedObject(m_arrTemplateBlobLeads);
        }
        public void UndoSelectedObject_BaseLead()
        {
            UndoSelectedObject(m_arrTemplateBlobLeads_BaseLead);
        }
        /// <summary>
        /// Undo selected object or deselect object
        /// </summary>
        /// <param name="arrBlobsFeatures">blobs features</param>
        public void UndoSelectedObject(ArrayList arrBlobsFeatures)
        {
            for (int i = 0; i < arrBlobsFeatures.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)arrBlobsFeatures[i];
                m_stcBlobLead.blnSelected = false;
                arrBlobsFeatures.RemoveAt(i);
                arrBlobsFeatures.Insert(i, m_stcBlobLead);
            }
        }

        /// <summary>
        /// Update previous tolerance to current template
        /// </summary>
        public void UpdatePreviousToleranceToTemplate()
        {
            // check is count tally? if tally, then read template index by sequence. If no tally, then then look for closest area blobs first.
            bool blnTally = m_arrBackupTemplateBlobLeads.Count == GetSelectedObjectNumber();

            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                if (!((BlobsFeatures)m_arrTemplateBlobLeads[i]).blnSelected)
                    continue;

                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                int intSelectedIndex;
                if (blnTally)
                {
                    intSelectedIndex = i;
                }
                else
                {
                    //Loop to look for tolerance setting that have previous blob learn area closest to current blob learn area.
                    intSelectedIndex = -1;
                    float fDiffSmallestArea = float.MaxValue;
                    for (int j = 0; j < m_arrBackupTemplateBlobLeads.Count; j++)  // Loop previous blobs tolerance list
                    {
                        m_stcBackupTemplateBlobLead = (ToleranceBlobsFeatures)m_arrBackupTemplateBlobLeads[j];

                        // Get smallest different area between current and previous learn blob area.
                        if (Math.Abs(m_stcBlobLead.fArea - m_stcBackupTemplateBlobLead.fLearnArea) < fDiffSmallestArea)
                        {
                            fDiffSmallestArea = Math.Abs(m_stcBlobLead.fArea - m_stcBackupTemplateBlobLead.fLearnArea);
                            intSelectedIndex = j;
                        }
                    }
                }

                if (intSelectedIndex >= 0)  // If found the closest area blob
                {
                    // Copy the previous tolerance setting into current learn blob tolerance setting
                    m_stcBackupTemplateBlobLead = (ToleranceBlobsFeatures)m_arrBackupTemplateBlobLeads[intSelectedIndex];

                    m_stcBlobLead.fOffSet = m_stcBackupTemplateBlobLead.fOffSet;
                    m_stcBlobLead.fSkew = m_stcBackupTemplateBlobLead.fSkew;
                    m_stcBlobLead.fVariance = m_stcBackupTemplateBlobLead.fVariance;
                    m_stcBlobLead.fMinAGV = m_stcBackupTemplateBlobLead.fMinAGV;
                    m_stcBlobLead.fMaxAGV = m_stcBackupTemplateBlobLead.fMaxAGV;

                    //if (m_stcBlobLead.intLengthMode == m_stcBackupTemplateBlobLead.intLengthMode)
                    //{
                    m_stcBlobLead.fMinWidth = m_stcBackupTemplateBlobLead.fMinWidth;
                    m_stcBlobLead.fMaxWidth = m_stcBackupTemplateBlobLead.fMaxWidth;
                    m_stcBlobLead.fMinHeight = m_stcBackupTemplateBlobLead.fMinHeight;
                    m_stcBlobLead.fMaxHeight = m_stcBackupTemplateBlobLead.fMaxHeight;

                    m_stcBlobLead.fMinBaseWidth = m_stcBackupTemplateBlobLead.fMinBaseWidth;
                    m_stcBlobLead.fMaxBaseWidth = m_stcBackupTemplateBlobLead.fMaxBaseWidth;
                    m_stcBlobLead.fMinBaseHeight = m_stcBackupTemplateBlobLead.fMinBaseHeight;
                    m_stcBlobLead.fMaxBaseHeight = m_stcBackupTemplateBlobLead.fMaxBaseHeight;

                    m_stcBlobLead.fMinTipWidth = m_stcBackupTemplateBlobLead.fMinTipWidth;
                    m_stcBlobLead.fMaxTipWidth = m_stcBackupTemplateBlobLead.fMaxTipWidth;
                    m_stcBlobLead.fMinTipHeight = m_stcBackupTemplateBlobLead.fMinTipHeight;
                    m_stcBlobLead.fMaxTipHeight = m_stcBackupTemplateBlobLead.fMaxTipHeight;
                    //}
                    //else
                    //{
                    //    m_stcBlobLead.fMinWidth = m_stcBackupTemplateBlobLead.fMinHeight;
                    //    m_stcBlobLead.fMaxWidth = m_stcBackupTemplateBlobLead.fMaxHeight;
                    //    m_stcBlobLead.fMinHeight = m_stcBackupTemplateBlobLead.fMinWidth;
                    //    m_stcBlobLead.fMaxHeight = m_stcBackupTemplateBlobLead.fMaxWidth;

                    //    m_stcBlobLead.fMinBaseWidth = m_stcBackupTemplateBlobLead.fMinBaseHeight;
                    //    m_stcBlobLead.fMaxBaseWidth = m_stcBackupTemplateBlobLead.fMaxBaseHeight;
                    //    m_stcBlobLead.fMinBaseHeight = m_stcBackupTemplateBlobLead.fMinBaseWidth;
                    //    m_stcBlobLead.fMaxBaseHeight = m_stcBackupTemplateBlobLead.fMaxBaseWidth;

                    //    m_stcBlobLead.fMinTipWidth = m_stcBackupTemplateBlobLead.fMinTipHeight;
                    //    m_stcBlobLead.fMaxTipWidth = m_stcBackupTemplateBlobLead.fMaxTipHeight;
                    //    m_stcBlobLead.fMinTipHeight = m_stcBackupTemplateBlobLead.fMinTipWidth;
                    //    m_stcBlobLead.fMaxTipHeight = m_stcBackupTemplateBlobLead.fMaxTipWidth;
                    //}
                    m_stcBlobLead.intBaseInwardOffset = m_stcBackupTemplateBlobLead.intBaseInwardOffset;
                    m_stcBlobLead.intTipInwardOffset = m_stcBackupTemplateBlobLead.intTipInwardOffset;

                    m_stcBlobLead.intAGVROITolerance_Top = m_stcBackupTemplateBlobLead.intAGVROITolerance_Top;
                    m_stcBlobLead.intAGVROITolerance_Right = m_stcBackupTemplateBlobLead.intAGVROITolerance_Right;
                    m_stcBlobLead.intAGVROITolerance_Bottom = m_stcBackupTemplateBlobLead.intAGVROITolerance_Bottom;
                    m_stcBlobLead.intAGVROITolerance_Left = m_stcBackupTemplateBlobLead.intAGVROITolerance_Left;
                    
                    m_stcBlobLead.fWidthOffset = m_stcBackupTemplateBlobLead.fWidthOffset;
                    m_stcBlobLead.fLengthOffset = m_stcBackupTemplateBlobLead.fLengthOffset;
                    m_stcBlobLead.fPitchOffset = m_stcBackupTemplateBlobLead.fPitchOffset;
                    m_stcBlobLead.fGapOffset = m_stcBackupTemplateBlobLead.fGapOffset;

                }

                m_arrTemplateBlobLeads.RemoveAt(i);
                m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
            }
        }
        public void SetPreviousToleranceToTemplate()
        {
           
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                if (!((BlobsFeatures)m_arrTemplateBlobLeads[i]).blnSelected)
                    continue;

                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                
                if (i >= 0)  // If found the closest area blob
                {
                    // Copy the previous tolerance setting into current learn blob tolerance setting
                    m_stcBackupTemplateBlobLead = (ToleranceBlobsFeatures)m_arrBackupTemplateBlobLeads[i];

                    m_stcBlobLead.fOffSet = m_stcBackupTemplateBlobLead.fOffSet;
                    m_stcBlobLead.fSkew = m_stcBackupTemplateBlobLead.fSkew;
                    m_stcBlobLead.fVariance = m_stcBackupTemplateBlobLead.fVariance;
                    m_stcBlobLead.fMinAGV = m_stcBackupTemplateBlobLead.fMinAGV;
                    m_stcBlobLead.fMaxAGV = m_stcBackupTemplateBlobLead.fMaxAGV;

                    //if (m_stcBlobLead.intLengthMode == m_stcBackupTemplateBlobLead.intLengthMode)
                    //{
                    m_stcBlobLead.fMinWidth = m_stcBackupTemplateBlobLead.fMinWidth;
                    m_stcBlobLead.fMaxWidth = m_stcBackupTemplateBlobLead.fMaxWidth;
                    m_stcBlobLead.fMinHeight = m_stcBackupTemplateBlobLead.fMinHeight;
                    m_stcBlobLead.fMaxHeight = m_stcBackupTemplateBlobLead.fMaxHeight;

                    m_stcBlobLead.fMinBaseWidth = m_stcBackupTemplateBlobLead.fMinBaseWidth;
                    m_stcBlobLead.fMaxBaseWidth = m_stcBackupTemplateBlobLead.fMaxBaseWidth;
                    m_stcBlobLead.fMinBaseHeight = m_stcBackupTemplateBlobLead.fMinBaseHeight;
                    m_stcBlobLead.fMaxBaseHeight = m_stcBackupTemplateBlobLead.fMaxBaseHeight;

                    m_stcBlobLead.fMinTipWidth = m_stcBackupTemplateBlobLead.fMinTipWidth;
                    m_stcBlobLead.fMaxTipWidth = m_stcBackupTemplateBlobLead.fMaxTipWidth;
                    m_stcBlobLead.fMinTipHeight = m_stcBackupTemplateBlobLead.fMinTipHeight;
                    m_stcBlobLead.fMaxTipHeight = m_stcBackupTemplateBlobLead.fMaxTipHeight;
                    //}
                    //else
                    //{
                    //    m_stcBlobLead.fMinWidth = m_stcBackupTemplateBlobLead.fMinHeight;
                    //    m_stcBlobLead.fMaxWidth = m_stcBackupTemplateBlobLead.fMaxHeight;
                    //    m_stcBlobLead.fMinHeight = m_stcBackupTemplateBlobLead.fMinWidth;
                    //    m_stcBlobLead.fMaxHeight = m_stcBackupTemplateBlobLead.fMaxWidth;

                    //    m_stcBlobLead.fMinBaseWidth = m_stcBackupTemplateBlobLead.fMinBaseHeight;
                    //    m_stcBlobLead.fMaxBaseWidth = m_stcBackupTemplateBlobLead.fMaxBaseHeight;
                    //    m_stcBlobLead.fMinBaseHeight = m_stcBackupTemplateBlobLead.fMinBaseWidth;
                    //    m_stcBlobLead.fMaxBaseHeight = m_stcBackupTemplateBlobLead.fMaxBaseWidth;

                    //    m_stcBlobLead.fMinTipWidth = m_stcBackupTemplateBlobLead.fMinTipHeight;
                    //    m_stcBlobLead.fMaxTipWidth = m_stcBackupTemplateBlobLead.fMaxTipHeight;
                    //    m_stcBlobLead.fMinTipHeight = m_stcBackupTemplateBlobLead.fMinTipWidth;
                    //    m_stcBlobLead.fMaxTipHeight = m_stcBackupTemplateBlobLead.fMaxTipWidth;
                    //}
                    m_stcBlobLead.intBaseInwardOffset = m_stcBackupTemplateBlobLead.intBaseInwardOffset;
                    m_stcBlobLead.intTipInwardOffset = m_stcBackupTemplateBlobLead.intTipInwardOffset;

                    m_stcBlobLead.intAGVROITolerance_Top = m_stcBackupTemplateBlobLead.intAGVROITolerance_Top;
                    m_stcBlobLead.intAGVROITolerance_Right = m_stcBackupTemplateBlobLead.intAGVROITolerance_Right;
                    m_stcBlobLead.intAGVROITolerance_Bottom = m_stcBackupTemplateBlobLead.intAGVROITolerance_Bottom;
                    m_stcBlobLead.intAGVROITolerance_Left = m_stcBackupTemplateBlobLead.intAGVROITolerance_Left;

                    m_stcBlobLead.fWidthOffset = m_stcBackupTemplateBlobLead.fWidthOffset;
                    m_stcBlobLead.fLengthOffset = m_stcBackupTemplateBlobLead.fLengthOffset;
                    m_stcBlobLead.fPitchOffset = m_stcBackupTemplateBlobLead.fPitchOffset;
                    m_stcBlobLead.fGapOffset = m_stcBackupTemplateBlobLead.fGapOffset;

                }

                m_arrTemplateBlobLeads.RemoveAt(i);
                m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
            }
        }
        public void UpdatePreviousToleranceToTemplate_BaseLead()
        {
            // check is count tally? if tally, then read template index by sequence. If no tally, then then look for closest area blobs first.
            bool blnTally = m_arrBackupTemplateBlobLeads_BaseLead.Count == GetSelectedObjectNumber_BaseLead();

            for (int i = 0; i < m_arrTemplateBlobLeads_BaseLead.Count; i++)
            {
                if (!((BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i]).blnSelected)
                    continue;

                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i];

                int intSelectedIndex;
                if (blnTally)
                {
                    intSelectedIndex = i;
                }
                else
                {
                    //Loop to look for tolerance setting that have previous blob learn area closest to current blob learn area.
                    intSelectedIndex = -1;
                    float fDiffSmallestArea = float.MaxValue;
                    for (int j = 0; j < m_arrBackupTemplateBlobLeads_BaseLead.Count; j++)  // Loop previous blobs tolerance list
                    {
                        m_stcBackupTemplateBlobLead = (ToleranceBlobsFeatures)m_arrBackupTemplateBlobLeads_BaseLead[j];

                        // Get smallest different area between current and previous learn blob area.
                        if (Math.Abs(m_stcBlobLead.fArea - m_stcBackupTemplateBlobLead.fLearnArea) < fDiffSmallestArea)
                        {
                            fDiffSmallestArea = Math.Abs(m_stcBlobLead.fArea - m_stcBackupTemplateBlobLead.fLearnArea);
                            intSelectedIndex = j;
                        }
                    }
                }

                if (intSelectedIndex >= 0)  // If found the closest area blob
                {
                    // Copy the previous tolerance setting into current learn blob tolerance setting
                    m_stcBackupTemplateBlobLead = (ToleranceBlobsFeatures)m_arrBackupTemplateBlobLeads_BaseLead[intSelectedIndex];

                    m_stcBlobLead.fMaxBaseOffset = m_stcBackupTemplateBlobLead.fMaxBaseOffset;
                    m_stcBlobLead.fMinBaseArea = m_stcBackupTemplateBlobLead.fMinBaseArea;
                    m_stcBlobLead.fMaxBaseArea = m_stcBackupTemplateBlobLead.fMaxBaseArea;
                    
                }

                m_arrTemplateBlobLeads_BaseLead.RemoveAt(i);
                m_arrTemplateBlobLeads_BaseLead.Insert(i, m_stcBlobLead);
            }
        }
        /// <summary>
        /// Update data(mm) in blobs features
        /// </summary>
        /// <param name="intSelectedIndex">blobs feature index</param>
        /// <param name="fOffSet">offset</param>
        /// <param name="fMinArea">min area</param>
        /// <param name="fMaxArea">max area</param>
        /// <param name="fMinWidth">min width</param>
        /// <param name="fMaxWidth">max width</param>
        /// <param name="fMinHeight">min height</param>
        /// <param name="fMaxHeight">max height</param>
        /// <param name="fMinPitch">min pitch</param>
        /// <param name="fMaxPitch">max pitch</param>
        /// <param name="fMinGap">min gap</param>
        /// <param name="fMaxGap">max gap</param>
        /// <param name="fMaxBroken">max hole</param>
        public void UpdateBlobFeatureToPixel(int intSelectedIndex, float fOffSet, float fSkew,
            float fMinTipWidth, float fMaxTipWidth, float fMinTipHeight, float fMaxTipHeight,
            float fMinPitch, float fMaxPitch, float fMinGap, float fMaxGap, float fVariance, float fMinAGV, float fMaxAGV)//,
            //float fWidthOffset, float fLengthOffset, float fPitchOffset, float fGapOffset)
        {
            m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[intSelectedIndex];

            m_stcBlobLead.fOffSet = fOffSet / m_fMMToUnitValue;
            m_stcBlobLead.fSkew = fSkew / m_fMMToUnitValue;
            //m_stcBlobLead.fMinArea = fMinArea / m_fMMToUnitValueArea;
            //m_stcBlobLead.fMaxArea = fMaxArea / m_fMMToUnitValueArea;

            m_stcBlobLead.fMinTipWidth = fMinTipWidth / m_fMMToUnitValue;
            m_stcBlobLead.fMaxTipWidth = fMaxTipWidth / m_fMMToUnitValue;
            m_stcBlobLead.fMinTipHeight = fMinTipHeight / m_fMMToUnitValue;
            m_stcBlobLead.fMaxTipHeight = fMaxTipHeight / m_fMMToUnitValue;

            m_stcBlobLead.fMinPitch = fMinPitch / m_fMMToUnitValue;
            m_stcBlobLead.fMaxPitch = fMaxPitch / m_fMMToUnitValue;
            m_stcBlobLead.fMinGap = fMinGap / m_fMMToUnitValue;
            m_stcBlobLead.fMaxGap = fMaxGap / m_fMMToUnitValue;

            m_stcBlobLead.fVariance = fVariance / m_fMMToUnitValue;

            m_stcBlobLead.fMinAGV = fMinAGV;
            m_stcBlobLead.fMaxAGV = fMaxAGV;

            //m_stcBlobLead.fWidthOffset = fWidthOffset / m_fMMToUnitValue;
            //m_stcBlobLead.fLengthOffset = fLengthOffset / m_fMMToUnitValue;
            //m_stcBlobLead.fPitchOffset = fPitchOffset / m_fMMToUnitValue;
            //m_stcBlobLead.fGapOffset = fGapOffset / m_fMMToUnitValue;

            m_arrTemplateBlobLeads.RemoveAt(intSelectedIndex);
            m_arrTemplateBlobLeads.Insert(intSelectedIndex, m_stcBlobLead);
        }
        public void UpdateLeadOffsetSettingValueToPixel(int intSelectedIndex, float fWidthOffset, float fLengthOffset, float fPitchOffset, float fGapOffset)
        {
            m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[intSelectedIndex];
            
            m_stcBlobLead.fWidthOffset = fWidthOffset / m_fMMToUnitValue;
            m_stcBlobLead.fLengthOffset = fLengthOffset / m_fMMToUnitValue;
            m_stcBlobLead.fPitchOffset = fPitchOffset / m_fMMToUnitValue;
            m_stcBlobLead.fGapOffset = fGapOffset / m_fMMToUnitValue;

            m_arrTemplateBlobLeads.RemoveAt(intSelectedIndex);
            m_arrTemplateBlobLeads.Insert(intSelectedIndex, m_stcBlobLead);
        }
        public void UpdateLeadOffsetSettingValueToPixel(int intSelectedIndex, int intFeature, float fValue)
        {
            m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[intSelectedIndex];

            switch (intFeature)
            {
                case 0:
                    m_stcBlobLead.fWidthOffset = fValue / m_fMMToUnitValue;
                    break;
                case 1:
                    m_stcBlobLead.fLengthOffset = fValue / m_fMMToUnitValue;
                    break;
                case 2:
                    m_stcBlobLead.fPitchOffset = fValue / m_fMMToUnitValue;
                    break;
                case 3:
                    m_stcBlobLead.fGapOffset = fValue / m_fMMToUnitValue;
                    break;
            }

            m_arrTemplateBlobLeads.RemoveAt(intSelectedIndex);
            m_arrTemplateBlobLeads.Insert(intSelectedIndex, m_stcBlobLead);
        }
        public void UpdateBlobFeatureToPixel_BaseLead(int intSelectedIndex, float fMaxBaseOffset, float fMinBaseArea, float fMaxBaseArea)
        {
            m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[intSelectedIndex];

            m_stcBlobLead.fMaxBaseOffset = fMaxBaseOffset / m_fMMToUnitValue;
         
            m_stcBlobLead.fMinBaseArea = fMinBaseArea / m_fMMToUnitValueArea;
            m_stcBlobLead.fMaxBaseArea = fMaxBaseArea / m_fMMToUnitValueArea;

            m_arrTemplateBlobLeads_BaseLead.RemoveAt(intSelectedIndex);
            m_arrTemplateBlobLeads_BaseLead.Insert(intSelectedIndex, m_stcBlobLead);
        }
        public void UpdateBlobFeatureToPixel_NoPitchGap(int intSelectedIndex, float fOffSet, float fMinWidth, float fMaxWidth, float fMinHeight, float fMaxHeight)
        {
            m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[intSelectedIndex];

            m_stcBlobLead.fOffSet = fOffSet / m_fMMToUnitValue;
            //m_stcBlobLead.fMinArea = fMinArea / m_fMMToUnitValueArea;
            //m_stcBlobLead.fMaxArea = fMaxArea / m_fMMToUnitValueArea;

            m_stcBlobLead.fMinWidth = fMinWidth / m_fMMToUnitValue;
            m_stcBlobLead.fMaxWidth = fMaxWidth / m_fMMToUnitValue;
            m_stcBlobLead.fMinHeight = fMinHeight / m_fMMToUnitValue;
            m_stcBlobLead.fMaxHeight = fMaxHeight / m_fMMToUnitValue;

            //m_stcBlobLead.fMaxBroken = fMaxBroken / m_fMMToUnitValueArea;
            //m_stcBlobLead.fMaxBrokenLength = fMaxBrokenLength / m_fMMToUnitValue;

            m_arrTemplateBlobLeads.RemoveAt(intSelectedIndex);
            m_arrTemplateBlobLeads.Insert(intSelectedIndex, m_stcBlobLead);
        }

        //private void UpdateBlobSizeAndCenterPointWithGauge(ROI objROI,
        //                                                         float fOriCenterX, float fOriCenterY,
        //                                                         ref float fWidth, ref float fHeight,
        //                                                         ref float fNewCenterX, ref float fNewCenterY,
        //                                                         int intThresholdValuebool, bool blnHorizontal,
        //                                                         int intFixPointXY)
        //{
        //    List<PointF> arrGaugeMeasurePoints = new List<PointF>();


        //    if (blnHorizontal)
        //    {
        //        // Get Lead left point
        //        m_objPointGauge.SetGaugePlacement(objROI.ref_ROI.TotalOrgX + fOriCenterX - fWidth / 2, objROI.ref_ROI.TotalOrgY + intFixPointXY, Math.Min(fWidth / 4, 15), 180);
        //        m_objPointGauge.Measure(objROI);
        //        arrGaugeMeasurePoints.Add(m_objPointGauge.GetMeasurePoint(0));
        //        if (m_objPointGauge.ref_intMeasuredPointCount == 0) // 01-10-2019 ZJYEOH: Measure again with longer length if cannot found any point
        //        {
        //            m_objPointGauge.SetGaugePlacement(objROI.ref_ROI.TotalOrgX + fOriCenterX - fWidth / 2, objROI.ref_ROI.TotalOrgY + intFixPointXY, Math.Max(fWidth / 4, 15), 180);
        //            m_objPointGauge.Measure(objROI);
        //            arrGaugeMeasurePoints[arrGaugeMeasurePoints.Count - 1] = m_objPointGauge.GetMeasurePoint(0);
        //            if (m_objPointGauge.ref_intMeasuredPointCount == 0) // 01-10-2019 ZJYEOH: Measure again with longer length if cannot found any point
        //            {
        //                m_objPointGauge.SetGaugePlacement(objROI.ref_ROI.TotalOrgX + fOriCenterX - fWidth / 2, objROI.ref_ROI.TotalOrgY + intFixPointXY, fWidth / 2, 180);
        //                m_objPointGauge.Measure(objROI);
        //                arrGaugeMeasurePoints[arrGaugeMeasurePoints.Count - 1] = m_objPointGauge.GetMeasurePoint(0);
        //            }
        //        }
        //        // Get Lead right point
        //        m_objPointGauge.SetGaugePlacement(objROI.ref_ROI.TotalOrgX + fOriCenterX + fWidth / 2, objROI.ref_ROI.TotalOrgY + intFixPointXY, Math.Min(fWidth / 4, 15), 0);
        //        m_objPointGauge.Measure(objROI);
        //        arrGaugeMeasurePoints.Add(m_objPointGauge.GetMeasurePoint(0));
        //        if (m_objPointGauge.ref_intMeasuredPointCount == 0) // 01-10-2019 ZJYEOH: Measure again with longer length if cannot found any point
        //        {
        //            m_objPointGauge.SetGaugePlacement(objROI.ref_ROI.TotalOrgX + fOriCenterX + fWidth / 2, objROI.ref_ROI.TotalOrgY + intFixPointXY, Math.Max(fWidth / 4, 15), 0);
        //            m_objPointGauge.Measure(objROI);
        //            arrGaugeMeasurePoints[arrGaugeMeasurePoints.Count - 1] = m_objPointGauge.GetMeasurePoint(0);
        //            if (m_objPointGauge.ref_intMeasuredPointCount == 0) // 01-10-2019 ZJYEOH: Measure again with longer length if cannot found any point
        //            {
        //                m_objPointGauge.SetGaugePlacement(objROI.ref_ROI.TotalOrgX + fOriCenterX + fWidth / 2, objROI.ref_ROI.TotalOrgY + intFixPointXY, fWidth / 2, 0);
        //                m_objPointGauge.Measure(objROI);
        //                arrGaugeMeasurePoints[arrGaugeMeasurePoints.Count - 1] = m_objPointGauge.GetMeasurePoint(0);
        //            }
        //        }

        //        if ((((arrGaugeMeasurePoints[1].X + arrGaugeMeasurePoints[0].X) / 2) - objROI.ref_ROI.TotalOrgX) > 0)
        //        {
        //            if (arrGaugeMeasurePoints[0].X > 0 && arrGaugeMeasurePoints[1].X > 0)
        //                fWidth = arrGaugeMeasurePoints[1].X - arrGaugeMeasurePoints[0].X;
        //            if (arrGaugeMeasurePoints[0].X > 0 && arrGaugeMeasurePoints[1].X > 0)
        //                fNewCenterX = ((arrGaugeMeasurePoints[1].X + arrGaugeMeasurePoints[0].X) / 2) - objROI.ref_ROI.TotalOrgX;

        //            fNewCenterY = fOriCenterY;
        //        }
        //    }
        //    else
        //    {
        //        // Get Lead top edge point
        //        m_objPointGauge.SetGaugePlacement(objROI.ref_ROI.TotalOrgX + intFixPointXY, objROI.ref_ROI.TotalOrgY + fOriCenterY - fHeight / 2, Math.Min(fHeight / 4, 15), -90);
        //        m_objPointGauge.Measure(objROI);
        //        arrGaugeMeasurePoints.Add(m_objPointGauge.GetMeasurePoint(0));

        //        if (m_objPointGauge.ref_intMeasuredPointCount == 0) // 01-10-2019 ZJYEOH: Measure again with longer length if cannot found any point
        //        {
        //            m_objPointGauge.SetGaugePlacement(objROI.ref_ROI.TotalOrgX + intFixPointXY, objROI.ref_ROI.TotalOrgY + fOriCenterY - fHeight / 2, Math.Max(fHeight / 4, 15), -90);
        //            m_objPointGauge.Measure(objROI);
        //            arrGaugeMeasurePoints[arrGaugeMeasurePoints.Count - 1] = m_objPointGauge.GetMeasurePoint(0);
        //            if (m_objPointGauge.ref_intMeasuredPointCount == 0) // 01-10-2019 ZJYEOH: Measure again with longer length if cannot found any point
        //            {
        //                m_objPointGauge.SetGaugePlacement(objROI.ref_ROI.TotalOrgX + intFixPointXY, objROI.ref_ROI.TotalOrgY + fOriCenterY - fHeight / 2, fHeight / 2, -90);
        //                m_objPointGauge.Measure(objROI);
        //                arrGaugeMeasurePoints[arrGaugeMeasurePoints.Count - 1] = m_objPointGauge.GetMeasurePoint(0);
        //            }
        //        }

        //        // Get Lead bottom edge point
        //        m_objPointGauge.SetGaugePlacement(objROI.ref_ROI.TotalOrgX + intFixPointXY, objROI.ref_ROI.TotalOrgY + fOriCenterY + fHeight / 2, Math.Min(fHeight / 4, 15), 90);
        //        m_objPointGauge.Measure(objROI);
        //        arrGaugeMeasurePoints.Add(m_objPointGauge.GetMeasurePoint(0));
        //        if (m_objPointGauge.ref_intMeasuredPointCount == 0) // 01-10-2019 ZJYEOH: Measure again with longer length if cannot found any point
        //        {
        //            m_objPointGauge.SetGaugePlacement(objROI.ref_ROI.TotalOrgX + intFixPointXY, objROI.ref_ROI.TotalOrgY + fOriCenterY + fHeight / 2, Math.Max(fHeight / 4, 15), 90);
        //            m_objPointGauge.Measure(objROI);
        //            arrGaugeMeasurePoints[arrGaugeMeasurePoints.Count - 1] = m_objPointGauge.GetMeasurePoint(0);
        //            if (m_objPointGauge.ref_intMeasuredPointCount == 0) // 01-10-2019 ZJYEOH: Measure again with longer length if cannot found any point
        //            {
        //                m_objPointGauge.SetGaugePlacement(objROI.ref_ROI.TotalOrgX + intFixPointXY, objROI.ref_ROI.TotalOrgY + fOriCenterY + fHeight / 2, fHeight / 2, 90);
        //                m_objPointGauge.Measure(objROI);
        //                arrGaugeMeasurePoints[arrGaugeMeasurePoints.Count - 1] = m_objPointGauge.GetMeasurePoint(0);
        //            }
        //        }

        //        if ((((arrGaugeMeasurePoints[1].Y + arrGaugeMeasurePoints[0].Y) / 2) - objROI.ref_ROI.TotalOrgY) > 0)
        //        {
        //            if (arrGaugeMeasurePoints[0].Y > 0 && arrGaugeMeasurePoints[1].Y > 0)
        //                fHeight = arrGaugeMeasurePoints[1].Y - arrGaugeMeasurePoints[0].Y;
        //            fNewCenterX = fOriCenterX;
        //            if (arrGaugeMeasurePoints[0].Y > 0 && arrGaugeMeasurePoints[1].Y > 0)
        //                fNewCenterY = ((arrGaugeMeasurePoints[1].Y + arrGaugeMeasurePoints[0].Y) / 2) - objROI.ref_ROI.TotalOrgY;
        //        }
        //    }
        //}

        /// <summary>
        /// Define template Lead contour
        /// </summary>
        /// <param name="objROI">ROI</param>
        public void DefineTemplateLeadContour2(ROI objROI)
        {
            int intThresholdValue;
            if (m_intThresholdValue == -4)
                intThresholdValue = ROI.GetAutoThresholdValue(objROI, 3);
            else
                intThresholdValue = m_intThresholdValue;

            m_arrTemplateContour = new Contour[m_arrTemplateBlobLeads.Count];
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_arrTemplateContour[i] = new Contour();
                for (int j = 0; j < ((BlobsFeatures)m_arrTemplateBlobLeads[i]).arrContourX.Length; j++)
                {
                    m_arrTemplateContour[i].BuildContour(objROI, ((BlobsFeatures)m_arrTemplateBlobLeads[i]).arrContourX[j],
                                                     ((BlobsFeatures)m_arrTemplateBlobLeads[i]).arrContourY[j],
                                                     intThresholdValue, m_objEBlobs.ref_intConnexity);
                }
            }
        }

        /// <summary>
        /// Match sample objects with m_arrTemplateBlobLeads
        /// </summary>
        /// <param name="fStartX">start X position</param>
        /// <param name="fStartY">start Y position</param>
        /// <param name="fEndX">end X position</param>
        /// <param name="fEndY">end Y position</param>
        /// <param name="fCenterX">center X position</param>
        /// <param name="fCenterY">center Y position</param>
        /// <returns>m_arrTemplateBlobLeads object match index</returns>
        private List<int> MatchTemplateObjects(float fStartX, float fStartY, float fEndX, float fEndY, float fCenterX, float fCenterY)
        {
            /*
             * Template and sample Leads will easily match each other when intToleranceOffSet is high.
             * Template may match with wrong sample Leads when intToleranceOffSet is high. 
             */

            List<int> arrMatch = new List<int>();
            int intToleranceOffSet = 15;
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                // Check is sample gravity center point in template area or not
                if ((fCenterX >= m_stcBlobLead.intStartX - intToleranceOffSet) &&
                    (fCenterX <= m_stcBlobLead.intEndX + intToleranceOffSet) &&
                    (fCenterY >= m_stcBlobLead.intStartY - intToleranceOffSet) &&
                    (fCenterY <= m_stcBlobLead.intEndY + intToleranceOffSet))
                {
                    arrMatch.Add(i);
                }
                // Check is template gravity center point in sample area or not
                else if ((m_stcBlobLead.fCenterX >= fStartX - intToleranceOffSet) &&
                    (m_stcBlobLead.fCenterX <= fEndX + intToleranceOffSet) &&
                    (m_stcBlobLead.fCenterY >= fStartY - intToleranceOffSet) &&
                    (m_stcBlobLead.fCenterY <= fEndY + intToleranceOffSet))
                {
                    arrMatch.Add(i);
                }
            }

            return arrMatch;
        }

        private int MatchTemplateObjects_BasedOnPositionAndSize(float fStartX, float fStartY, float fEndX, float fEndY, float fCenterX, float fCenterY, float fWidth, float fHeight)
        {
            int intToleranceOffSet = 15;
            bool blnMatch = false;
            float fClosestSize = float.MaxValue;
            int intClosestSizeIndex = -1;

            for (int i = 0; i < m_arrBackupTemplateBlobLeads.Count; i++)
            {
                if (blnMatch)
                    blnMatch = false;

                m_stcBackupTemplateBlobLead = (ToleranceBlobsFeatures)m_arrBackupTemplateBlobLeads[i];

                // Check is sample gravity center point in template area or not
                if ((fCenterX >= m_stcBackupTemplateBlobLead.fStartX - intToleranceOffSet) &&
                    (fCenterX <= m_stcBackupTemplateBlobLead.fEndX + intToleranceOffSet) &&
                    (fCenterY >= m_stcBackupTemplateBlobLead.fStartY - intToleranceOffSet) &&
                    (fCenterY <= m_stcBackupTemplateBlobLead.fEndY + intToleranceOffSet))
                {
                    blnMatch = true;
                }
                // Check is template gravity center point in sample area or not
                else
                {
                    float fCenterX2 = (m_stcBackupTemplateBlobLead.fStartX + m_stcBackupTemplateBlobLead.fEndX) / 2;
                    float fCenterY2 = (m_stcBackupTemplateBlobLead.fStartY + m_stcBackupTemplateBlobLead.fEndY) / 2;

                    if ((fCenterX2 >= fStartX - intToleranceOffSet) &&
                    (fCenterX2 <= fEndX + intToleranceOffSet) &&
                    (fCenterY2 >= fStartY - intToleranceOffSet) &&
                    (fCenterY2 <= fEndY + intToleranceOffSet))
                    {
                        blnMatch = true;
                    }
                }

                if (blnMatch)
                {
                    if ((Math.Abs(fWidth - m_stcBackupTemplateBlobLead.fLearnWidth) / m_stcBackupTemplateBlobLead.fLearnWidth < 0.2) &&
                        (Math.Abs(fHeight - m_stcBackupTemplateBlobLead.fLearnWidth) / m_stcBackupTemplateBlobLead.fLearnHeight < 0.2))
                    {
                        return i;
                    }
                }

                float fDiffSize = Math.Abs(fWidth - m_stcBackupTemplateBlobLead.fLearnWidth) + Math.Abs(fHeight - m_stcBackupTemplateBlobLead.fLearnHeight);

                if (fDiffSize < fClosestSize)
                {
                    fClosestSize = fDiffSize;
                    intClosestSizeIndex = i;
                }
            }

            return intClosestSizeIndex;
        }

        /// <summary>
        /// Check whether all previous blobs are matched with current selected blobs
        /// </summary>
        /// <returns>true = all previous blobs match, false = otherwise</returns>
        public bool MatchPrevSettings()
        {
            float fStartX, fStartY, fEndX, fEndY, fCenterX, fCenterY;
            int intCount = 0, intNo;

            for (int i = 0; i < m_arrBackupTemplateBlobLeads.Count; i++)
            {
                m_stcBackupTemplateBlobLead = (ToleranceBlobsFeatures)m_arrBackupTemplateBlobLeads[i];

                fStartX = m_stcBackupTemplateBlobLead.fStartX;
                fStartY = m_stcBackupTemplateBlobLead.fStartY;
                fEndX = m_stcBackupTemplateBlobLead.fEndX;
                fEndY = m_stcBackupTemplateBlobLead.fEndY;
                fCenterX = m_stcBackupTemplateBlobLead.fLimitCenterX;
                fCenterY = m_stcBackupTemplateBlobLead.fLimitCenterY;

                // Get current blobs number
                List<int> arrMatch = MatchTemplateObjects(fStartX, fStartY, fEndX, fEndY, fCenterX, fCenterY);

                if (arrMatch.Count == 0)
                    continue;
                else if (arrMatch.Count > 1)
                    intNo = -2;
                else
                    intNo = arrMatch[0];

                if (intNo >= 0)
                {
                    m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[intNo];
                    m_stcBackupTemplateBlobLead = (ToleranceBlobsFeatures)m_arrBackupTemplateBlobLeads[i];

                    m_stcBlobLead.intDirection = m_stcBackupTemplateBlobLead.intDirection;
                    m_stcBlobLead.intNoID = m_stcBackupTemplateBlobLead.intNoID;
                    m_stcBlobLead.intLengthMode = m_stcBackupTemplateBlobLead.intLengthMode;
                    m_arrTemplateBlobLeads.RemoveAt(intNo);
                    m_arrTemplateBlobLeads.Insert(intNo, m_stcBlobLead);
                    intCount++;
                }
            }

            // All previous blobs are matched with current selected blobs
            if (intCount == m_arrBackupTemplateBlobLeads.Count)
                return true;

            return false;
        }
        public bool MatchPrevSettings_BaseLead()
        {
            float fStartX, fStartY, fEndX, fEndY, fCenterX, fCenterY;
            int intCount = 0, intNo;

            for (int i = 0; i < m_arrTemplateBlobLeads_BaseLead.Count; i++)
            {
                BlobsFeatures stcTemplateBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads_BaseLead[i];

                if (!stcTemplateBlobLead.blnSelected)
                    continue;
                fStartX = stcTemplateBlobLead.fStartX;
                fStartY = stcTemplateBlobLead.fStartY;
                fEndX = stcTemplateBlobLead.fEndX;
                fEndY = stcTemplateBlobLead.fEndY;
                fCenterX = stcTemplateBlobLead.fLimitCenterX;
                fCenterY = stcTemplateBlobLead.fLimitCenterY;

                // Get current blobs number
                List<int> arrMatch = MatchTemplateObjects(fStartX, fStartY, fEndX, fEndY, fCenterX, fCenterY);

                if (arrMatch.Count == 0)
                    continue;
                else if (arrMatch.Count > 1)
                    intNo = -2;
                else
                    intNo = arrMatch[0];

                if (intNo >= 0)
                {
                    m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[intNo];

                    stcTemplateBlobLead.intDirection = m_stcBlobLead.intDirection;
                    stcTemplateBlobLead.intNoID = m_stcBlobLead.intNoID;
                    stcTemplateBlobLead.intLengthMode = m_stcBlobLead.intLengthMode;
                    m_arrTemplateBlobLeads_BaseLead.RemoveAt(i);
                    m_arrTemplateBlobLeads_BaseLead.Insert(i, stcTemplateBlobLead);
                    intCount++;
                }
            }

            // All previous blobs are matched with current selected blobs
            if (intCount == m_arrTemplateBlobLeads.Count)
                return true;

            return false;
        }
        public void MatchPrevSettings_AutoGenerate()
        {
            float fStartX, fStartY, fEndX, fEndY, fCenterX, fCenterY, fWidth, fHeight;
            int intCount = 0, intNo;

            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                if (!((BlobsFeatures)m_arrTemplateBlobLeads[i]).blnSelected)
                    continue;

                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                fStartX = m_stcBlobLead.fStartX;
                fStartY = m_stcBlobLead.fStartY;
                fEndX = m_stcBlobLead.fEndX;
                fEndY = m_stcBlobLead.fEndY;
                fCenterX = m_stcBlobLead.fLimitCenterX;
                fCenterY = m_stcBlobLead.fLimitCenterY;
                fWidth = m_stcBlobLead.fWidth;

                // Get current blobs number
                int intMatchTemplateBlobLeadIndex = MatchTemplateObjects_BasedOnPositionAndSize(m_stcBlobLead.fStartX, m_stcBlobLead.fStartY,
                                                                                m_stcBlobLead.fEndX, m_stcBlobLead.fEndY,
                                                                                fCenterX, fCenterY,
                                                                                m_stcBlobLead.fWidth, m_stcBlobLead.fHeight);

                if (intMatchTemplateBlobLeadIndex >= 0)
                {
                    m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                    m_stcBackupTemplateBlobLead = (ToleranceBlobsFeatures)m_arrBackupTemplateBlobLeads[intMatchTemplateBlobLeadIndex];

                    m_stcBlobLead.intDirection = m_stcBackupTemplateBlobLead.intDirection;
                    m_stcBlobLead.intNoID = m_stcBackupTemplateBlobLead.intNoID;
                    m_stcBlobLead.intGroupID = m_stcBackupTemplateBlobLead.intGroupID;
                    m_stcBlobLead.fOffSet = m_stcBackupTemplateBlobLead.fOffSet;
                    m_stcBlobLead.fSkew = m_stcBackupTemplateBlobLead.fSkew;
                    m_stcBlobLead.fVariance = m_stcBackupTemplateBlobLead.fVariance;

                    m_stcBlobLead.fMinAGV = m_stcBackupTemplateBlobLead.fMinAGV;
                    m_stcBlobLead.fMaxAGV = m_stcBackupTemplateBlobLead.fMaxAGV;

                    m_stcBlobLead.fMinWidth = m_stcBackupTemplateBlobLead.fMinWidth;
                    m_stcBlobLead.fMaxWidth = m_stcBackupTemplateBlobLead.fMaxWidth;
                    m_stcBlobLead.fMinHeight = m_stcBackupTemplateBlobLead.fMinHeight;
                    m_stcBlobLead.fMaxHeight = m_stcBackupTemplateBlobLead.fMaxHeight;

                    m_stcBlobLead.fMinBaseWidth = m_stcBackupTemplateBlobLead.fMinBaseWidth;
                    m_stcBlobLead.fMaxBaseWidth = m_stcBackupTemplateBlobLead.fMaxBaseWidth;
                    m_stcBlobLead.fMinBaseHeight = m_stcBackupTemplateBlobLead.fMinBaseHeight;
                    m_stcBlobLead.fMaxBaseHeight = m_stcBackupTemplateBlobLead.fMaxBaseHeight;

                    m_stcBlobLead.fMinTipWidth = m_stcBackupTemplateBlobLead.fMinTipWidth;
                    m_stcBlobLead.fMaxTipWidth = m_stcBackupTemplateBlobLead.fMaxTipWidth;
                    m_stcBlobLead.fMinTipHeight = m_stcBackupTemplateBlobLead.fMinTipHeight;
                    m_stcBlobLead.fMaxTipHeight = m_stcBackupTemplateBlobLead.fMaxTipHeight;
                    
                    m_stcBlobLead.fWidthOffset = m_stcBackupTemplateBlobLead.fWidthOffset;
                    m_stcBlobLead.fLengthOffset = m_stcBackupTemplateBlobLead.fLengthOffset;
                    m_stcBlobLead.fPitchOffset = m_stcBackupTemplateBlobLead.fPitchOffset;
                    m_stcBlobLead.fGapOffset = m_stcBackupTemplateBlobLead.fGapOffset;

                    m_stcBlobLead.blnSelected = true;

                    m_arrTemplateBlobLeads.RemoveAt(i);
                    m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
                }
                else
                {
                    // Generate default setting


                }

            }
        }

        /// <summary>
        /// Check whether sample object width fall within template width settings 
        /// </summary>
        /// <param name="intBlobsFeatureIndex">blobs feature index</param>
        /// <param name="fBaseWidth">Base width</param>
        /// <param name="fTipWidth">Tip width</param>
        /// <returns>true = valid width, false = invalid width</returns>
        private bool MatchTemplateObjectsWidth(int intBlobsFeatureIndex, float fTipWidth)
        {
            m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[intBlobsFeatureIndex];

            if (m_blnWantTightSetting)
            {
                if ((fTipWidth >= Math.Round(m_stcBlobLead.fMinTipWidth + m_fTightSettingTolerance, 4)) && (fTipWidth <= Math.Round(m_stcBlobLead.fMaxTipWidth - m_fTightSettingTolerance, 4)))
                    return true;
                else
                    return false;
            }
            else
            {

                if ((fTipWidth >= Math.Round(m_stcBlobLead.fMinTipWidth, 4)) && (fTipWidth <= Math.Round(m_stcBlobLead.fMaxTipWidth, 4)))
                    return true;
                else
                    return false;
            }
        }

        /// <summary>
        /// Check whether sample object width fall within template width settings 
        /// </summary>
        /// <param name="intBlobsFeatureIndex">blobs feature index</param>
        /// <param name="fBaseWidth">Base width</param>
        /// <param name="fTipWidth">Tip width</param>
        /// <returns>true = valid width, false = invalid width</returns>
        private bool MatchTemplateObjectsWidth(int intBlobsFeatureIndex, float fBaseWidth, float fTipWidth)
        {
            m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[intBlobsFeatureIndex];

            if (m_blnWantTightSetting)
            {
                if ((fBaseWidth >= Math.Round(m_stcBlobLead.fMinBaseWidth + m_fTightSettingTolerance, 4)) && (fBaseWidth <= Math.Round(m_stcBlobLead.fMaxBaseWidth - m_fTightSettingTolerance, 4)) &&
                    (fTipWidth >= Math.Round(m_stcBlobLead.fMinTipWidth + m_fTightSettingTolerance, 4)) && (fTipWidth <= Math.Round(m_stcBlobLead.fMaxTipWidth - m_fTightSettingTolerance, 4)))
                    return true;
                else
                    return false;
            }
            else
            {

                if ((fBaseWidth >= Math.Round(m_stcBlobLead.fMinBaseWidth, 4)) && (fBaseWidth <= Math.Round(m_stcBlobLead.fMaxBaseWidth, 4)) &&
                    (fTipWidth >= Math.Round(m_stcBlobLead.fMinTipWidth, 4)) && (fTipWidth <= Math.Round(m_stcBlobLead.fMaxTipWidth, 4)))
                    return true;
                else
                    return false;
            }
        }

        /// <summary>
        /// Check whether sample object height fall within template height settings 
        /// </summary>
        /// <param name="intBlobsFeatureIndex">blobs feature index</param>
        /// <param name="fHeight">height</param>
        /// <returns>true = valid height, false = invalid height</returns>
        private bool MatchTemplateObjectsHeight(int intBlobsFeatureIndex, float fBaseHeight, float fTipHeight)
        {
            m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[intBlobsFeatureIndex];

            if (m_blnWantTightSetting)
            {
                if ((fBaseHeight >= Math.Round(m_stcBlobLead.fMinHeight + m_fTightSettingTolerance, 4)) && (fBaseHeight <= Math.Round(m_stcBlobLead.fMaxHeight - m_fTightSettingTolerance, 4)) &&
                    (fTipHeight >= Math.Round(m_stcBlobLead.fMinHeight + m_fTightSettingTolerance, 4)) && (fTipHeight <= Math.Round(m_stcBlobLead.fMaxHeight - m_fTightSettingTolerance, 4)))
                    return true;
                else
                    return false;
            }
            else
            {
                if ((fBaseHeight >= Math.Round(m_stcBlobLead.fMinHeight, 4)) && (fBaseHeight <= Math.Round(m_stcBlobLead.fMaxHeight, 4)) &&
                    (fTipHeight >= Math.Round(m_stcBlobLead.fMinHeight, 4)) && (fTipHeight <= Math.Round(m_stcBlobLead.fMaxHeight, 4)))

                    return true;
                else
                    return false;
            }
        }


        /// <summary>
        /// Check whether sample object height fall within template height settings 
        /// </summary>
        /// <param name="intBlobsFeatureIndex">blobs feature index</param>
        /// <param name="fHeight">height</param>
        /// <returns>true = valid height, false = invalid height</returns>
        private bool MatchTemplateObjectsHeight(int intBlobsFeatureIndex, float fTipHeight)
        {
            m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[intBlobsFeatureIndex];

            if (m_blnWantTightSetting)
            {
                if ((fTipHeight >= Math.Round(m_stcBlobLead.fMinTipHeight + m_fTightSettingTolerance, 4)) && (fTipHeight <= Math.Round(m_stcBlobLead.fMaxTipHeight - m_fTightSettingTolerance, 4)))
                    return true;
                else
                    return false;
            }
            else
            {
                if ((fTipHeight >= Math.Round(m_stcBlobLead.fMinTipHeight, 4)) && (fTipHeight <= Math.Round(m_stcBlobLead.fMaxTipHeight, 4)))

                    return true;
                else
                    return false;
            }
        }

        /// <summary>
        /// Check whether sample object reference point fall within template reference point tolerance
        /// </summary>
        /// <returns>true = valid reference point, false = invalid reference point</returns>
        private bool MatchTemplateObjectsReferencePoint()
        {
            //Define a condition for tolerance
            int intToleranceOffSet = 10;

            if (m_fSampleReferencePointStartX == m_fSampleReferencePointEndX)
            {
                if (m_blnWantTightSetting)
                {
                    if ((m_fSampleReferencePointStartX >= Math.Round(m_fReferencePointStartX - intToleranceOffSet + m_fTightSettingTolerance, 4, MidpointRounding.AwayFromZero)) && (m_fSampleReferencePointStartX <= Math.Round(m_fReferencePointStartX + intToleranceOffSet - m_fTightSettingTolerance, 4, MidpointRounding.AwayFromZero)) &&
                        (m_fSampleReferencePointStartY >= Math.Round(m_fReferencePointStartY - intToleranceOffSet + m_fTightSettingTolerance, 4, MidpointRounding.AwayFromZero)) && (m_fSampleReferencePointStartY <= Math.Round(m_fReferencePointStartY + intToleranceOffSet - m_fTightSettingTolerance, 4, MidpointRounding.AwayFromZero)) &&
                        (m_fSampleReferencePointEndY >= Math.Round(m_fReferencePointEndY - intToleranceOffSet + m_fTightSettingTolerance, 4, MidpointRounding.AwayFromZero)) && (m_fSampleReferencePointEndY <= Math.Round(m_fReferencePointEndY + intToleranceOffSet - m_fTightSettingTolerance, 4, MidpointRounding.AwayFromZero)))
                        return true;
                    else
                        return false;
                }
                else
                {
                    if ((m_fSampleReferencePointStartX >= Math.Round(m_fReferencePointStartX - intToleranceOffSet, 4, MidpointRounding.AwayFromZero)) && (m_fSampleReferencePointStartX <= Math.Round(m_fReferencePointStartX + intToleranceOffSet, 4, MidpointRounding.AwayFromZero)) &&
                        (m_fSampleReferencePointStartY >= Math.Round(m_fReferencePointStartY - intToleranceOffSet, 4, MidpointRounding.AwayFromZero)) && (m_fSampleReferencePointStartY <= Math.Round(m_fReferencePointStartY + intToleranceOffSet, 4, MidpointRounding.AwayFromZero)) &&
                        (m_fSampleReferencePointEndY >= Math.Round(m_fReferencePointEndY - intToleranceOffSet, 4, MidpointRounding.AwayFromZero)) && (m_fSampleReferencePointEndY <= Math.Round(m_fReferencePointEndY + intToleranceOffSet, 4, MidpointRounding.AwayFromZero)))
                        return true;
                    else
                        return false;
                }
            }
            else
            {
                if (m_blnWantTightSetting)
                {
                    if ((m_fSampleReferencePointStartY >= Math.Round(m_fReferencePointStartY - intToleranceOffSet + m_fTightSettingTolerance, 4, MidpointRounding.AwayFromZero)) && (m_fSampleReferencePointStartY <= Math.Round(m_fReferencePointStartY + intToleranceOffSet - m_fTightSettingTolerance, 4, MidpointRounding.AwayFromZero)) &&
                        (m_fSampleReferencePointStartX >= Math.Round(m_fReferencePointStartX - intToleranceOffSet + m_fTightSettingTolerance, 4, MidpointRounding.AwayFromZero)) && (m_fSampleReferencePointStartX <= Math.Round(m_fReferencePointStartX + intToleranceOffSet - m_fTightSettingTolerance, 4, MidpointRounding.AwayFromZero)) &&
                        (m_fSampleReferencePointEndX >= Math.Round(m_fReferencePointEndX - intToleranceOffSet + m_fTightSettingTolerance, 4, MidpointRounding.AwayFromZero)) && (m_fSampleReferencePointEndX <= Math.Round(m_fReferencePointEndX + intToleranceOffSet - m_fTightSettingTolerance, 4, MidpointRounding.AwayFromZero)))
                        return true;
                    else
                        return false;
                }
                else
                {
                    if ((m_fSampleReferencePointStartY >= Math.Round(m_fReferencePointStartY - intToleranceOffSet, 4, MidpointRounding.AwayFromZero)) && (m_fSampleReferencePointStartY <= Math.Round(m_fReferencePointStartY + intToleranceOffSet, 4, MidpointRounding.AwayFromZero)) &&
                        (m_fSampleReferencePointStartX >= Math.Round(m_fReferencePointStartX - intToleranceOffSet, 4, MidpointRounding.AwayFromZero)) && (m_fSampleReferencePointStartX <= Math.Round(m_fReferencePointStartX + intToleranceOffSet, 4, MidpointRounding.AwayFromZero)) &&
                        (m_fSampleReferencePointEndX >= Math.Round(m_fReferencePointEndX - intToleranceOffSet, 4, MidpointRounding.AwayFromZero)) && (m_fSampleReferencePointEndX <= Math.Round(m_fReferencePointEndX + intToleranceOffSet, 4, MidpointRounding.AwayFromZero)))
                        return true;
                    else
                        return false;
                }
            }
        }
        private List<int> MatchTemplateObjects_Inspection_BaseLead(ROI objROI, float fStartX, float fStartY,
            float fEndX, float fEndY, float fWidth, float fHeight,
            float fBaseWidth, float fBaseHeight,
            float fTipWidth, float fTipHeight,
            float fCenterX, float fCenterY, int intArea)
        {
            int intToleranceOffSet = 10;
            int intToleranceOut = 3;
            List<int> arrMatch = new List<int>();
            try
            {
                // 2020 10 14- CCENG: Use m_arrSampleBlobLeads to scan bcos if sample lead length longer than template lead length, then may miss out the matching.
                //for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
                //{
                //    m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                //    //if (m_stcBlobLead.fTipWidth < 20 || m_stcBlobLead.fTipHeight < 20 || m_stcBlobLead.fBaseWidth < 20 || m_stcBlobLead.fBaseHeight < 20)
                //    //    intToleranceOffSet = 10;
                //    //else
                //    //    intToleranceOffSet = 0;

                //    // Check is sample gravity center point in template area or not
                //    if ((fCenterX >= m_stcBlobLead.intStartX - intToleranceOffSet) && // Use center point check the matching btw sample and template is not enough especially when size is small. Miss matching may happen.
                //        (fCenterX <= m_stcBlobLead.intEndX + intToleranceOffSet) &&
                //        (fCenterY >= m_stcBlobLead.intStartY - intToleranceOffSet) &&
                //        (fCenterY <= m_stcBlobLead.intEndY + intToleranceOffSet))
                //    {
                //        arrMatch.Add(i);

                //    }
                //    // Check is template gravity center point in sample area or not
                //    else if ((m_stcBlobLead.fCenterX >= fStartX - intToleranceOffSet) &&
                //        (m_stcBlobLead.fCenterX <= fEndX + intToleranceOffSet) &&
                //        (m_stcBlobLead.fCenterY >= fStartY - intToleranceOffSet) &&
                //        (m_stcBlobLead.fCenterY <= fEndY + intToleranceOffSet))
                //    {
                //        arrMatch.Add(i);
                //    }
                //}


                for (int i = 0; i < m_arrSampleBlobLeads.Length; i++)
                {
                    SampleBlobsFeatures objSampleBlobsFeatures = (SampleBlobsFeatures)m_arrSampleBlobLeads[i];

                    //if (m_stcBlobLead.fTipWidth < 20 || m_stcBlobLead.fTipHeight < 20 || m_stcBlobLead.fBaseWidth < 20 || m_stcBlobLead.fBaseHeight < 20)
                    //    intToleranceOffSet = 10;
                    //else
                    //    intToleranceOffSet = 0;

                    // Check is sample gravity center point in template area or not
                    if ((fCenterX >= objSampleBlobsFeatures.fStartX - intToleranceOffSet) && // Use center point check the matching btw sample and template is not enough especially when size is small. Miss matching may happen.
                        (fCenterX <= objSampleBlobsFeatures.fEndX + intToleranceOffSet) &&
                        (fCenterY >= objSampleBlobsFeatures.fStartY - intToleranceOffSet) &&
                        (fCenterY <= objSampleBlobsFeatures.fEndY + intToleranceOffSet))
                    {
                        arrMatch.Add(i);

                    }
                    // Check is template gravity center point in sample area or not
                    else if ((objSampleBlobsFeatures.fCenterX >= fStartX - intToleranceOffSet) &&
                        (objSampleBlobsFeatures.fCenterX <= fEndX + intToleranceOffSet) &&
                        (objSampleBlobsFeatures.fCenterY >= fStartY - intToleranceOffSet) &&
                        (objSampleBlobsFeatures.fCenterY <= fEndY + intToleranceOffSet))
                    {
                        arrMatch.Add(i);
                    }
                }
            }
            catch (Exception ex)
            {
                TrackLog objTL = new TrackLog();
                objTL.WriteLine("MatchTemplateObjects3 Exception Error: " + ex.ToString());
            }

            return arrMatch;
        }
        private List<int> MatchTemplateObjects_Inspection(ROI objROI, float fStartX, float fStartY,
            float fEndX, float fEndY, float fWidth, float fHeight,
            float fBaseWidth, float fBaseHeight,
            float fTipWidth, float fTipHeight,
            float fCenterX, float fCenterY, int intArea)
        {
            int intToleranceOffSet = 10;
            int intToleranceOut = 3;
            List<int> arrMatch = new List<int>();
            bool blnDoubleCheck = false;
            try
            {
                //for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
                //{
                //    m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                //    if (m_stcBlobLead.fWidth < 20 || m_stcBlobLead.fHeight < 20)
                //        intToleranceOffSet = 10;
                //    else
                //        intToleranceOffSet = 0;

                //    // Check is sample gravity center point in template area or not
                //    if ((fCenterX >= m_stcBlobLead.intStartX - intToleranceOffSet) && // Use center point check the matching btw sample and template is not enough especially when size is small. Miss matching may happen.
                //        (fCenterX <= m_stcBlobLead.intEndX + intToleranceOffSet) &&
                //        (fCenterY >= m_stcBlobLead.intStartY - intToleranceOffSet) &&
                //        (fCenterY <= m_stcBlobLead.intEndY + intToleranceOffSet))
                //    {
                //        arrMatch.Add(i);

                //        if (!blnDoubleCheck)
                //            if ((Math.Abs(fCenterX - m_stcBlobLead.fCenterX) > 10) ||
                //                (Math.Abs(fCenterY - m_stcBlobLead.fCenterY) > 10) ||
                //                (Math.Abs(fWidth - m_stcBlobLead.fWidth) > 10) ||
                //                (Math.Abs(fHeight - m_stcBlobLead.fHeight) > 10))
                //            {
                //                blnDoubleCheck = true;
                //            }
                //    }
                //    // Check is template gravity center point in sample area or not
                //    else if ((m_stcBlobLead.fCenterX >= fStartX - intToleranceOffSet) &&
                //        (m_stcBlobLead.fCenterX <= fEndX + intToleranceOffSet) &&
                //        (m_stcBlobLead.fCenterY >= fStartY - intToleranceOffSet) &&
                //        (m_stcBlobLead.fCenterY <= fEndY + intToleranceOffSet))
                //    {
                //        arrMatch.Add(i);

                //        if (!blnDoubleCheck)
                //            if ((Math.Abs(fCenterX - m_stcBlobLead.fCenterX) > 5) ||
                //                (Math.Abs(fCenterY - m_stcBlobLead.fCenterY) > 5) ||
                //                (Math.Abs(fWidth - m_stcBlobLead.fWidth) > 5) ||
                //                (Math.Abs(fHeight - m_stcBlobLead.fHeight) > 5))
                //            {
                //                blnDoubleCheck = true;
                //            }
                //    }
                //}

                //---------------------------- Check Tip and base ----------------------------
                for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
                {
                    m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                    if (m_stcBlobLead.fTipWidth < 20 || m_stcBlobLead.fTipHeight < 20 || m_stcBlobLead.fBaseWidth < 20 || m_stcBlobLead.fBaseHeight < 20)
                        intToleranceOffSet = 10;
                    else
                        intToleranceOffSet = 0;

                    // Check is sample gravity center point in template area or not
                    if ((fCenterX >= m_stcBlobLead.intStartX - intToleranceOffSet) && // Use center point check the matching btw sample and template is not enough especially when size is small. Miss matching may happen.
                        (fCenterX <= m_stcBlobLead.intEndX + intToleranceOffSet) &&
                        (fCenterY >= m_stcBlobLead.intStartY - intToleranceOffSet) &&
                        (fCenterY <= m_stcBlobLead.intEndY + intToleranceOffSet))
                    {
                        arrMatch.Add(i);

                        if (!blnDoubleCheck)
                            if ((Math.Abs(fCenterX - m_stcBlobLead.fCenterX) > 10) ||
                                (Math.Abs(fCenterY - m_stcBlobLead.fCenterY) > 10) ||
                                (Math.Abs(fTipWidth - m_stcBlobLead.fTipWidth) > 10) ||
                                (Math.Abs(fTipHeight - m_stcBlobLead.fTipHeight) > 10) ||
                                (Math.Abs(fBaseWidth - m_stcBlobLead.fBaseWidth) > 10) ||
                                (Math.Abs(fBaseHeight - m_stcBlobLead.fBaseHeight) > 10))
                            {
                                blnDoubleCheck = true;
                            }
                    }
                    // Check is template gravity center point in sample area or not
                    else if ((m_stcBlobLead.fCenterX >= fStartX - intToleranceOffSet) &&
                        (m_stcBlobLead.fCenterX <= fEndX + intToleranceOffSet) &&
                        (m_stcBlobLead.fCenterY >= fStartY - intToleranceOffSet) &&
                        (m_stcBlobLead.fCenterY <= fEndY + intToleranceOffSet))
                    {
                        arrMatch.Add(i);

                        if (!blnDoubleCheck)
                            if ((Math.Abs(fCenterX - m_stcBlobLead.fCenterX) > 5) ||
                                (Math.Abs(fCenterY - m_stcBlobLead.fCenterY) > 5) ||
                                (Math.Abs(fTipWidth - m_stcBlobLead.fTipWidth) > 5) ||
                                (Math.Abs(fTipHeight - m_stcBlobLead.fTipHeight) > 5) ||
                                (Math.Abs(fBaseWidth - m_stcBlobLead.fBaseWidth) > 5) ||
                                (Math.Abs(fBaseHeight - m_stcBlobLead.fBaseHeight) > 5))
                            {
                                blnDoubleCheck = true;
                            }
                    }
                }
            }
            catch (Exception ex)
            {
                TrackLog objTL = new TrackLog();
                objTL.WriteLine("MatchTemplateObjects3 Exception Error: " + ex.ToString());
            }


            bool blnDebugImage = false;

            // Double check
            if (blnDoubleCheck)
            {
                ROI objSampBlobROI = new ROI();
                objSampBlobROI.AttachImage(objROI);
                objSampBlobROI.LoadROISetting((int)fStartX, (int)fStartY, (int)(fEndX - fStartX), (int)(fEndY - fStartY));

                if (blnDebugImage)
                {
                    objSampBlobROI.SaveImage("D:\\TS\\objSampleBlobROI.bmp");// debug
                }

                ROI objTempBlobROI = new ROI();

                // Double check is match index correct or not by using sample and templete blobs subtraction
                for (int i = 0; i < arrMatch.Count; i++)
                {
                    //m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[arrMatch[i]];
                    //objTempBlobROI.ref_ROI.Detach();
                    //objTempBlobROI.ref_ROI.Attach(m_arrImgLeadImage[arrMatch[i]]);
                    //objTempBlobROI.LoadROISetting(m_stcBlobLead.intStartX, m_stcBlobLead.intStartY,
                    //                              (m_stcBlobLead.intEndX - m_stcBlobLead.intStartX),
                    //                              (m_stcBlobLead.intEndY - m_stcBlobLead.intStartY));

                    if (blnDebugImage)
                    {
                        m_arrImgLeadImage[arrMatch[i]].Save("D:\\TS\\m_arrImgLeadImage" + arrMatch[i].ToString() + ".bmp");// debug
                        objTempBlobROI.SaveImage("D:\\TS\\objTempBlobROI.bmp");// debug
                    }

                    //if (!IsObjectStickTogether(objROI, objSampBlobROI, objTempBlobROI, intArea, fCenterX, fCenterY))
                    //{
                    //    // Remove from list if no stick together
                    //    arrMatch.RemoveAt(i);
                    //    i--;
                    //}
                }
                objSampBlobROI.Dispose();
                objTempBlobROI.Dispose();
            }

            return arrMatch;
        }

        /// <summary>
        /// Remove certain pitch gap 
        /// </summary>
        /// <param name="intPitchGapIndex">pitch gap index</param>
        public void DeletePitchGap(int intPitchGapIndex)
        {
            if (intPitchGapIndex >= m_arrPitchGap.Count)
                return;

            m_arrPitchGap.RemoveAt(intPitchGapIndex);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="objROI"></param>
        /// <param name="intDirectionIndex"></param>
        public bool FindUnitBaseLine2(ROI objROI, float fCenterLeadsRangeStartX, float fCenterLeadsRangeStartY, float fCenterLeadsRangeEndX, float fCenterLeadsRangeEndY)
        {
            /* Top ROI for example:
             * 1. Get center point of base line. 
             *      - Attach line guage on unit base line with line gauge position at center of ROI width, guage length 20 only.
             * 2. After get the center point, get the center blob
             *      - attach a small ROI base line based on the center point. 
             *      - The small ROI width size same as Top search ROI. 
             *      - The small ROI height is around 10 pixels only. Height must not over than unit side line height.
             *      - build blob and get the center blob.
             * 3. Get base line angle.
             * 4. 
             */

            if (m_arrTemplateBlobLeads.Count == 0)
                return false;

            // Constant Variables
            int intBodyEdgeOffsetFromBase = 20;

            // Get unit body from template blob 
            int intLineGaugeIndex = m_intLeadROIDirection - 1;

            BlobsFeatures stcBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobLeads[0];

            bool blnGetBaselinePointOK = false;
            PointF pBaselinePoint = new PointF();
            if (m_intLeadROIDirection == 2 || m_intLeadROIDirection == 4) //m_intLeadDirection == 0    // Horizontal
            {

                switch (m_intLeadROIDirection)
                {
                    case 1: // Top ROI
                        {
                            m_arrLineGauge[intLineGaugeIndex].SetGaugePlacement(objROI.ref_ROITotalX + stcBlobsFeatures.fLimitCenterX,
                                                                                objROI.ref_ROITotalY + stcBlobsFeatures.fStartY,
                                                                                stcBlobsFeatures.fHeight, 20, 0);
                            m_arrLineGauge[intLineGaugeIndex].ref_GaugeThreshold = 10;

                            m_arrLineGauge[intLineGaugeIndex].Measure(objROI);

                            blnGetBaselinePointOK = m_arrLineGauge[intLineGaugeIndex].GetMeasurementSampleCenterPoints(objROI, 10, ref pBaselinePoint);
                        }
                        break;
                    case 2: // Right ROI
                        {
                            if (m_intNumberOfLead_Left == 1 && m_intNumberOfLead_Right == 1)
                            {
                                m_arrLineGauge[intLineGaugeIndex].SetGaugePlacement(objROI.ref_ROITotalX + stcBlobsFeatures.fEndX,
                                                        objROI.ref_ROITotalY + stcBlobsFeatures.fLimitCenterY,
                                                        stcBlobsFeatures.fWidth, (fCenterLeadsRangeEndY - fCenterLeadsRangeStartY) * 1.5f, 90);
                                m_arrLineGauge[intLineGaugeIndex].ref_GaugeThreshold = 10;

                                m_arrLineGauge[intLineGaugeIndex].Measure(objROI);

                                blnGetBaselinePointOK = m_arrLineGauge[intLineGaugeIndex].GetMeasurementSampleDeepestPoints(objROI, 10, ref pBaselinePoint);
                            }
                            else
                            {
                                m_arrLineGauge[intLineGaugeIndex].SetGaugePlacement(objROI.ref_ROITotalX + stcBlobsFeatures.fEndX,
                                                                                    objROI.ref_ROITotalY + stcBlobsFeatures.fLimitCenterY,
                                                                                    stcBlobsFeatures.fWidth, fCenterLeadsRangeEndY - fCenterLeadsRangeStartY, 90);
                                m_arrLineGauge[intLineGaugeIndex].ref_GaugeThreshold = 10;

                                m_arrLineGauge[intLineGaugeIndex].Measure(objROI);

                                blnGetBaselinePointOK = m_arrLineGauge[intLineGaugeIndex].GetMeasurementSampleDeepestPoints(objROI, 10, ref pBaselinePoint);
                            }
                        }
                        break;
                    case 3: // Bottom ROI
                        {
                            m_arrLineGauge[intLineGaugeIndex].SetGaugePlacement(objROI.ref_ROITotalX + stcBlobsFeatures.fLimitCenterX,
                                                                                objROI.ref_ROITotalY + stcBlobsFeatures.fEndY,
                                                                                stcBlobsFeatures.fHeight, 20, 180);
                            m_arrLineGauge[intLineGaugeIndex].ref_GaugeThreshold = 10;

                            m_arrLineGauge[intLineGaugeIndex].Measure(objROI);

                            blnGetBaselinePointOK = m_arrLineGauge[intLineGaugeIndex].GetMeasurementSampleCenterPoints(objROI, 10, ref pBaselinePoint);
                        }
                        break;
                    case 4: // Left ROI
                        {
                            if (m_intNumberOfLead_Left == 1 && m_intNumberOfLead_Right == 1)
                            {
                                m_arrLineGauge[intLineGaugeIndex].SetGaugePlacement(objROI.ref_ROITotalX + stcBlobsFeatures.fStartX,
                                                                                   objROI.ref_ROITotalY + stcBlobsFeatures.fLimitCenterY,
                                                          stcBlobsFeatures.fWidth, (fCenterLeadsRangeEndY - fCenterLeadsRangeStartY) * 1.5f, -90);
                                m_arrLineGauge[intLineGaugeIndex].ref_GaugeThreshold = 10;

                                m_arrLineGauge[intLineGaugeIndex].Measure(objROI);

                                blnGetBaselinePointOK = m_arrLineGauge[intLineGaugeIndex].GetMeasurementSampleDeepestPoints(objROI, 10, ref pBaselinePoint);

                            }
                            else
                            {
                                m_arrLineGauge[intLineGaugeIndex].SetGaugePlacement(objROI.ref_ROITotalX + stcBlobsFeatures.fStartX,
                                                                                    objROI.ref_ROITotalY + stcBlobsFeatures.fLimitCenterY,
                                                                                        stcBlobsFeatures.fWidth, fCenterLeadsRangeEndY - fCenterLeadsRangeStartY, -90);
                                m_arrLineGauge[intLineGaugeIndex].ref_GaugeThreshold = 10;

                                m_arrLineGauge[intLineGaugeIndex].Measure(objROI);

                                blnGetBaselinePointOK = m_arrLineGauge[intLineGaugeIndex].GetMeasurementSampleDeepestPoints(objROI, 10, ref pBaselinePoint);
                            }
                        }
                        break;
                    default:
                        return false;   // no center ROI because no base line measurement for center ROI.
                }
            }
            else if (m_intLeadROIDirection == 1 || m_intLeadROIDirection == 3) //else
            {
                //Vertical Leads
                switch (m_intLeadROIDirection)
                {
                    case 1: // Top ROI
                        {
                            if (m_intNumberOfLead_Left == 1 && m_intNumberOfLead_Right == 1)
                            {
                                m_arrLineGauge[intLineGaugeIndex].SetGaugePlacement(objROI.ref_ROITotalX + stcBlobsFeatures.fLimitCenterX,
                                                                                    objROI.ref_ROITotalY + stcBlobsFeatures.fStartY,
                                                                                    stcBlobsFeatures.fHeight, (fCenterLeadsRangeEndX - fCenterLeadsRangeStartX) * 1.5f, 0);
                                m_arrLineGauge[intLineGaugeIndex].ref_GaugeThreshold = 10;

                                m_arrLineGauge[intLineGaugeIndex].Measure(objROI);

                                blnGetBaselinePointOK = m_arrLineGauge[intLineGaugeIndex].GetMeasurementSampleDeepestPoints(objROI, 10, ref pBaselinePoint);
                            }
                            else
                            {
                                m_arrLineGauge[intLineGaugeIndex].SetGaugePlacement(objROI.ref_ROITotalX + stcBlobsFeatures.fLimitCenterX,
                                                                                        objROI.ref_ROITotalY + stcBlobsFeatures.fStartY,
                                                                                        stcBlobsFeatures.fHeight, fCenterLeadsRangeEndX - fCenterLeadsRangeStartX, 0);
                                m_arrLineGauge[intLineGaugeIndex].ref_GaugeThreshold = 10;

                                m_arrLineGauge[intLineGaugeIndex].Measure(objROI);

                                blnGetBaselinePointOK = m_arrLineGauge[intLineGaugeIndex].GetMeasurementSampleDeepestPoints(objROI, 10, ref pBaselinePoint);
                            }
                        }
                        break;
                    case 2: // Right ROI
                        {
                            m_arrLineGauge[intLineGaugeIndex].SetGaugePlacement(objROI.ref_ROITotalX + stcBlobsFeatures.fEndX,
                                                    objROI.ref_ROITotalY + stcBlobsFeatures.fLimitCenterY,
                                                    stcBlobsFeatures.fWidth, 20, 0);
                            m_arrLineGauge[intLineGaugeIndex].ref_GaugeThreshold = 10;

                            m_arrLineGauge[intLineGaugeIndex].Measure(objROI);

                            blnGetBaselinePointOK = m_arrLineGauge[intLineGaugeIndex].GetMeasurementSampleCenterPoints(objROI, 10, ref pBaselinePoint);

                        }
                        break;
                    case 3: // Bottom ROI
                        {
                            if (m_intNumberOfLead_Left == 1 && m_intNumberOfLead_Right == 1)
                            {
                                m_arrLineGauge[intLineGaugeIndex].SetGaugePlacement(objROI.ref_ROITotalX + stcBlobsFeatures.fLimitCenterX,
                                                                                    objROI.ref_ROITotalY + stcBlobsFeatures.fEndY,
                                                                                    stcBlobsFeatures.fHeight, (fCenterLeadsRangeEndX - fCenterLeadsRangeStartX) * 1.5f, 180);
                                m_arrLineGauge[intLineGaugeIndex].ref_GaugeThreshold = 10;

                                m_arrLineGauge[intLineGaugeIndex].Measure(objROI);

                                blnGetBaselinePointOK = m_arrLineGauge[intLineGaugeIndex].GetMeasurementSampleDeepestPoints(objROI, 10, ref pBaselinePoint);

                            }
                            else
                            {
                                m_arrLineGauge[intLineGaugeIndex].SetGaugePlacement(objROI.ref_ROITotalX + stcBlobsFeatures.fLimitCenterX,
                                                                                    objROI.ref_ROITotalY + stcBlobsFeatures.fEndY,
                                                                                    stcBlobsFeatures.fHeight, fCenterLeadsRangeEndX - fCenterLeadsRangeStartX, 180);
                                m_arrLineGauge[intLineGaugeIndex].ref_GaugeThreshold = 10;

                                m_arrLineGauge[intLineGaugeIndex].Measure(objROI);

                                blnGetBaselinePointOK = m_arrLineGauge[intLineGaugeIndex].GetMeasurementSampleDeepestPoints(objROI, 10, ref pBaselinePoint);
                            }
                        }
                        break;
                    case 4: // Left ROI
                        {
                            m_arrLineGauge[intLineGaugeIndex].SetGaugePlacement(objROI.ref_ROITotalX + stcBlobsFeatures.fStartX,
                                                                                objROI.ref_ROITotalY + stcBlobsFeatures.fLimitCenterY,
                                                                                stcBlobsFeatures.fWidth, 20, -90);
                            m_arrLineGauge[intLineGaugeIndex].ref_GaugeThreshold = 10;

                            m_arrLineGauge[intLineGaugeIndex].Measure(objROI);

                            blnGetBaselinePointOK = m_arrLineGauge[intLineGaugeIndex].GetMeasurementSampleCenterPoints(objROI, 10, ref pBaselinePoint);
                        }
                        break;
                    default:
                        return false;   // no center ROI because no base line measurement for center ROI.
                }
            }

            if (blnGetBaselinePointOK)
            {
                float fStartX = 0, fStartY = 0, fEndX = 0, fEndY = 0, fCenterX = 0, fCenterY = 0, fWidth = 0, fHeight = 0;
                int intLocalROITolerance = 5;
                switch (m_intLeadROIDirection)
                {
                    case 1: // Top ROI
                        {
                            m_objLocalROI.AttachImage(objROI);
                            m_objLocalROI.LoadROISetting(0, (int)pBaselinePoint.Y - intLocalROITolerance - objROI.ref_ROITotalY, objROI.ref_ROIWidth, intBodyEdgeOffsetFromBase + intLocalROITolerance);

                            BuildOnlySideLeadObjects_BlackObject(m_objLocalROI);

                            // Get center blobs information
                            if (m_objEBlobs.ref_intNumSelectedObject == 1)
                            {
                                fStartX = m_objEBlobs.ref_arrLimitCenterX[0] - m_objEBlobs.ref_arrWidth[0] / 2;
                                fStartY = m_objEBlobs.ref_arrLimitCenterY[0] - m_objEBlobs.ref_arrHeight[0] / 2;
                                fEndX = m_objEBlobs.ref_arrLimitCenterX[0] + m_objEBlobs.ref_arrWidth[0] / 2;
                                fEndY = m_objEBlobs.ref_arrLimitCenterY[0] + m_objEBlobs.ref_arrHeight[0] / 2;
                                fCenterX = m_objEBlobs.ref_arrLimitCenterX[0];
                                fCenterY = m_objEBlobs.ref_arrLimitCenterY[0];
                                fWidth = m_objEBlobs.ref_arrWidth[0];
                                fHeight = m_objEBlobs.ref_arrHeight[0];
                            }
                            else
                            {
                                float fMinStartX = float.MaxValue;
                                float fMaxEndX = float.MinValue;
                                for (int i = 0; i < m_objEBlobs.ref_intNumSelectedObject; i++)
                                {
                                    fStartX = m_objEBlobs.ref_arrLimitCenterX[i] - m_objEBlobs.ref_arrWidth[i] / 2;
                                    fEndX = m_objEBlobs.ref_arrLimitCenterX[i] + m_objEBlobs.ref_arrWidth[i] / 2;

                                    if (fMinStartX > fStartX)
                                        fMinStartX = fStartX;   // get smallest start x

                                    if (fMaxEndX < fEndX)
                                        fMaxEndX = fEndX;       // get biggest end x
                                }

                                int intSelectedObjectInddex = -1;
                                float fNearestCenter = float.MaxValue;
                                float fNorminalCenterX = (fMinStartX + fMaxEndX) / 2;
                                for (int i = 0; i < m_objEBlobs.ref_intNumSelectedObject; i++)
                                {
                                    if (fNearestCenter > Math.Abs(m_objEBlobs.ref_arrLimitCenterX[i] - fNorminalCenterX))
                                    {
                                        fNearestCenter = Math.Abs(m_objEBlobs.ref_arrLimitCenterX[i] - fNorminalCenterX);
                                        intSelectedObjectInddex = i;
                                    }
                                }

                                fStartX = m_objEBlobs.ref_arrLimitCenterX[intSelectedObjectInddex] - m_objEBlobs.ref_arrWidth[intSelectedObjectInddex] / 2;
                                fStartY = m_objEBlobs.ref_arrLimitCenterY[intSelectedObjectInddex] - m_objEBlobs.ref_arrHeight[intSelectedObjectInddex] / 2;
                                fEndX = m_objEBlobs.ref_arrLimitCenterX[intSelectedObjectInddex] + m_objEBlobs.ref_arrWidth[intSelectedObjectInddex] / 2;
                                fEndY = m_objEBlobs.ref_arrLimitCenterY[intSelectedObjectInddex] + m_objEBlobs.ref_arrHeight[intSelectedObjectInddex] / 2;
                                fCenterX = m_objEBlobs.ref_arrLimitCenterX[intSelectedObjectInddex];
                                fCenterY = m_objEBlobs.ref_arrLimitCenterY[intSelectedObjectInddex];
                                fWidth = m_objEBlobs.ref_arrWidth[intSelectedObjectInddex];
                                fHeight = m_objEBlobs.ref_arrHeight[intSelectedObjectInddex];

                            }
                            m_arrLineGauge[intLineGaugeIndex].SetGaugePlacement(m_objLocalROI.ref_ROITotalX + fCenterX,
                                                    pBaselinePoint.Y, 10, fWidth, 0);

                            m_arrLineGauge[intLineGaugeIndex].Measure(m_objLocalROI);


                            m_objBaseLine.CalculateStraightLine(new PointF(m_arrLineGauge[intLineGaugeIndex].ref_ObjectCenterX, m_arrLineGauge[intLineGaugeIndex].ref_ObjectCenterY), m_arrLineGauge[intLineGaugeIndex].ref_ObjectAngle + 90);   // The CalculateStraightLine need angle parameter start from straight line Y, but the line gauge start from straight line X. So need to add 90deg.
                            m_objEdgeLine_Left.CalculateStraightLine(new PointF(m_objLocalROI.ref_ROITotalX + fStartX, m_objLocalROI.ref_ROITotalY + fEndY), 0);
                            m_objEdgeLine_Right.CalculateStraightLine(new PointF(m_objLocalROI.ref_ROITotalX + fEndX, m_objLocalROI.ref_ROITotalY + fEndY), 0);

                            m_fBaseLineAngle = m_arrLineGauge[intLineGaugeIndex].ref_ObjectAngle;
                            m_pCornerPoint_Left = Line.GetCrossPoint(m_objBaseLine, m_objEdgeLine_Left);
                            m_pCornerPoint_Right = Line.GetCrossPoint(m_objBaseLine, m_objEdgeLine_Right);
                        }
                        break;
                    case 2: // Right ROI
                        {
                            m_objLocalROI.AttachImage(objROI);
                            m_objLocalROI.LoadROISetting((int)pBaselinePoint.X - intBodyEdgeOffsetFromBase * 2 - objROI.ref_ROITotalX, 0,
                                                        intLocalROITolerance + intBodyEdgeOffsetFromBase * 2, objROI.ref_ROIHeight);

                            BuildOnlySideLeadObjects_BlackObject(m_objLocalROI);

                            // Get center blobs information
                            if (m_objEBlobs.ref_intNumSelectedObject == 1)
                            {
                                fStartX = m_objEBlobs.ref_arrLimitCenterX[0] - m_objEBlobs.ref_arrWidth[0] / 2;
                                fStartY = m_objEBlobs.ref_arrLimitCenterY[0] - m_objEBlobs.ref_arrHeight[0] / 2;
                                fEndX = m_objEBlobs.ref_arrLimitCenterX[0] + m_objEBlobs.ref_arrWidth[0] / 2;
                                fEndY = m_objEBlobs.ref_arrLimitCenterY[0] + m_objEBlobs.ref_arrHeight[0] / 2;
                                fCenterX = m_objEBlobs.ref_arrLimitCenterX[0];
                                fCenterY = m_objEBlobs.ref_arrLimitCenterY[0];
                                fWidth = m_objEBlobs.ref_arrWidth[0];
                                fHeight = m_objEBlobs.ref_arrHeight[0];
                            }
                            else
                            {
                                float fMinStartX = float.MaxValue;
                                float fMaxEndX = float.MinValue;
                                for (int i = 0; i < m_objEBlobs.ref_intNumSelectedObject; i++)
                                {
                                    fStartX = m_objEBlobs.ref_arrLimitCenterX[i] - m_objEBlobs.ref_arrWidth[i] / 2;
                                    fEndX = m_objEBlobs.ref_arrLimitCenterX[i] + m_objEBlobs.ref_arrWidth[i] / 2;

                                    if (fMinStartX > fStartX)
                                        fMinStartX = fStartX;   // get smallest start x

                                    if (fMaxEndX < fEndX)
                                        fMaxEndX = fEndX;       // get biggest end x
                                }

                                int intSelectedObjectInddex = -1;
                                float fNearestCenter = float.MaxValue;
                                float fNorminalCenterX = (fMinStartX + fMaxEndX) / 2;
                                for (int i = 0; i < m_objEBlobs.ref_intNumSelectedObject; i++)
                                {
                                    if (fNearestCenter > Math.Abs(m_objEBlobs.ref_arrLimitCenterX[i] - fNorminalCenterX))
                                    {
                                        fNearestCenter = Math.Abs(m_objEBlobs.ref_arrLimitCenterX[i] - fNorminalCenterX);
                                        intSelectedObjectInddex = i;
                                    }
                                }

                                fStartX = m_objEBlobs.ref_arrLimitCenterX[intSelectedObjectInddex] - m_objEBlobs.ref_arrWidth[intSelectedObjectInddex] / 2;
                                fStartY = m_objEBlobs.ref_arrLimitCenterY[intSelectedObjectInddex] - m_objEBlobs.ref_arrHeight[intSelectedObjectInddex] / 2;
                                fEndX = m_objEBlobs.ref_arrLimitCenterX[intSelectedObjectInddex] + m_objEBlobs.ref_arrWidth[intSelectedObjectInddex] / 2;
                                fEndY = m_objEBlobs.ref_arrLimitCenterY[intSelectedObjectInddex] + m_objEBlobs.ref_arrHeight[intSelectedObjectInddex] / 2;
                                fCenterX = m_objEBlobs.ref_arrLimitCenterX[intSelectedObjectInddex];
                                fCenterY = m_objEBlobs.ref_arrLimitCenterY[intSelectedObjectInddex];
                                fWidth = m_objEBlobs.ref_arrWidth[intSelectedObjectInddex];
                                fHeight = m_objEBlobs.ref_arrHeight[intSelectedObjectInddex];

                            }
                            m_arrLineGauge[intLineGaugeIndex].SetGaugePlacement(pBaselinePoint.X,
                                                                                m_objLocalROI.ref_ROITotalY + fCenterY,
                                                                                10, fHeight, 90);

                            m_arrLineGauge[intLineGaugeIndex].Measure(m_objLocalROI);


                            m_objBaseLine.CalculateStraightLine(new PointF(m_arrLineGauge[intLineGaugeIndex].ref_ObjectCenterX, m_arrLineGauge[intLineGaugeIndex].ref_ObjectCenterY), m_arrLineGauge[intLineGaugeIndex].ref_ObjectAngle);
                            m_objEdgeLine_Top.CalculateStraightLine(new PointF(m_objLocalROI.ref_ROITotalX + fStartX, m_objLocalROI.ref_ROITotalY + fStartY), 90);
                            m_objEdgeLine_Bottom.CalculateStraightLine(new PointF(m_objLocalROI.ref_ROITotalX + fStartX, m_objLocalROI.ref_ROITotalY + fEndY), 90);

                            m_fBaseLineAngle = m_arrLineGauge[intLineGaugeIndex].ref_ObjectAngle;
                            m_pCornerPoint_Top = Line.GetCrossPoint(m_objBaseLine, m_objEdgeLine_Top);
                            m_pCornerPoint_Bottom = Line.GetCrossPoint(m_objBaseLine, m_objEdgeLine_Bottom);
                        }
                        break;
                    case 3: // Bottom ROI
                        {
                            m_objLocalROI.AttachImage(objROI);
                            m_objLocalROI.LoadROISetting(0, (int)pBaselinePoint.Y - intBodyEdgeOffsetFromBase - objROI.ref_ROITotalY,
                                                        objROI.ref_ROIWidth, intBodyEdgeOffsetFromBase + intLocalROITolerance);

                            BuildOnlySideLeadObjects_BlackObject(m_objLocalROI);

                            // Get center blobs information
                            if (m_objEBlobs.ref_intNumSelectedObject == 1)
                            {
                                fStartX = m_objEBlobs.ref_arrLimitCenterX[0] - m_objEBlobs.ref_arrWidth[0] / 2;
                                fStartY = m_objEBlobs.ref_arrLimitCenterY[0] - m_objEBlobs.ref_arrHeight[0] / 2;
                                fEndX = m_objEBlobs.ref_arrLimitCenterX[0] + m_objEBlobs.ref_arrWidth[0] / 2;
                                fEndY = m_objEBlobs.ref_arrLimitCenterY[0] + m_objEBlobs.ref_arrHeight[0] / 2;
                                fCenterX = m_objEBlobs.ref_arrLimitCenterX[0];
                                fCenterY = m_objEBlobs.ref_arrLimitCenterY[0];
                                fWidth = m_objEBlobs.ref_arrWidth[0];
                                fHeight = m_objEBlobs.ref_arrHeight[0];
                            }
                            else
                            {
                                float fMinStartX = float.MaxValue;
                                float fMaxEndX = float.MinValue;
                                for (int i = 0; i < m_objEBlobs.ref_intNumSelectedObject; i++)
                                {
                                    fStartX = m_objEBlobs.ref_arrLimitCenterX[i] - m_objEBlobs.ref_arrWidth[i] / 2;
                                    fEndX = m_objEBlobs.ref_arrLimitCenterX[i] + m_objEBlobs.ref_arrWidth[i] / 2;

                                    if (fMinStartX > fStartX)
                                        fMinStartX = fStartX;   // get smallest start x

                                    if (fMaxEndX < fEndX)
                                        fMaxEndX = fEndX;       // get biggest end x
                                }

                                int intSelectedObjectInddex = -1;
                                float fNearestCenter = float.MaxValue;
                                float fNorminalCenterX = (fMinStartX + fMaxEndX) / 2;
                                for (int i = 0; i < m_objEBlobs.ref_intNumSelectedObject; i++)
                                {
                                    if (fNearestCenter > Math.Abs(m_objEBlobs.ref_arrLimitCenterX[i] - fNorminalCenterX))
                                    {
                                        fNearestCenter = Math.Abs(m_objEBlobs.ref_arrLimitCenterX[i] - fNorminalCenterX);
                                        intSelectedObjectInddex = i;
                                    }
                                }

                                fStartX = m_objEBlobs.ref_arrLimitCenterX[intSelectedObjectInddex] - m_objEBlobs.ref_arrWidth[intSelectedObjectInddex] / 2;
                                fStartY = m_objEBlobs.ref_arrLimitCenterY[intSelectedObjectInddex] - m_objEBlobs.ref_arrHeight[intSelectedObjectInddex] / 2;
                                fEndX = m_objEBlobs.ref_arrLimitCenterX[intSelectedObjectInddex] + m_objEBlobs.ref_arrWidth[intSelectedObjectInddex] / 2;
                                fEndY = m_objEBlobs.ref_arrLimitCenterY[intSelectedObjectInddex] + m_objEBlobs.ref_arrHeight[intSelectedObjectInddex] / 2;
                                fCenterX = m_objEBlobs.ref_arrLimitCenterX[intSelectedObjectInddex];
                                fCenterY = m_objEBlobs.ref_arrLimitCenterY[intSelectedObjectInddex];
                                fWidth = m_objEBlobs.ref_arrWidth[intSelectedObjectInddex];
                                fHeight = m_objEBlobs.ref_arrHeight[intSelectedObjectInddex];

                            }
                            m_arrLineGauge[intLineGaugeIndex].SetGaugePlacement(m_objLocalROI.ref_ROITotalX + fCenterX,
                                                    pBaselinePoint.Y, 10, fWidth, 180);

                            m_arrLineGauge[intLineGaugeIndex].Measure(m_objLocalROI);


                            m_objBaseLine.CalculateStraightLine(new PointF(m_arrLineGauge[intLineGaugeIndex].ref_ObjectCenterX, m_arrLineGauge[intLineGaugeIndex].ref_ObjectCenterY), m_arrLineGauge[intLineGaugeIndex].ref_ObjectAngle + 90);   // The CalculateStraightLine need angle parameter start from straight line Y, but the line gauge start from straight line X. So need to add 90deg.
                            m_objEdgeLine_Left.CalculateStraightLine(new PointF(m_objLocalROI.ref_ROITotalX + fStartX, m_objLocalROI.ref_ROITotalY + fEndY), 0);
                            m_objEdgeLine_Right.CalculateStraightLine(new PointF(m_objLocalROI.ref_ROITotalX + fEndX, m_objLocalROI.ref_ROITotalY + fEndY), 0);

                            m_fBaseLineAngle = m_arrLineGauge[intLineGaugeIndex].ref_ObjectAngle;
                            m_pCornerPoint_Left = Line.GetCrossPoint(m_objBaseLine, m_objEdgeLine_Left);
                            m_pCornerPoint_Right = Line.GetCrossPoint(m_objBaseLine, m_objEdgeLine_Right);
                        }
                        break;
                    case 4: // Left ROI
                        {
                            m_objLocalROI.AttachImage(objROI);
                            m_objLocalROI.LoadROISetting((int)pBaselinePoint.X - intLocalROITolerance - objROI.ref_ROITotalX, 0,
                                                        intLocalROITolerance + intBodyEdgeOffsetFromBase * 2, objROI.ref_ROIHeight);

                            BuildOnlySideLeadObjects_BlackObject(m_objLocalROI);

                            // Get center blobs information
                            if (m_objEBlobs.ref_intNumSelectedObject == 1)
                            {
                                fStartX = m_objEBlobs.ref_arrLimitCenterX[0] - m_objEBlobs.ref_arrWidth[0] / 2;
                                fStartY = m_objEBlobs.ref_arrLimitCenterY[0] - m_objEBlobs.ref_arrHeight[0] / 2;
                                fEndX = m_objEBlobs.ref_arrLimitCenterX[0] + m_objEBlobs.ref_arrWidth[0] / 2;
                                fEndY = m_objEBlobs.ref_arrLimitCenterY[0] + m_objEBlobs.ref_arrHeight[0] / 2;
                                fCenterX = m_objEBlobs.ref_arrLimitCenterX[0];
                                fCenterY = m_objEBlobs.ref_arrLimitCenterY[0];
                                fWidth = m_objEBlobs.ref_arrWidth[0];
                                fHeight = m_objEBlobs.ref_arrHeight[0];
                            }
                            else
                            {
                                float fMinStartX = float.MaxValue;
                                float fMaxEndX = float.MinValue;
                                for (int i = 0; i < m_objEBlobs.ref_intNumSelectedObject; i++)
                                {
                                    fStartX = m_objEBlobs.ref_arrLimitCenterX[i] - m_objEBlobs.ref_arrWidth[i] / 2;
                                    fEndX = m_objEBlobs.ref_arrLimitCenterX[i] + m_objEBlobs.ref_arrWidth[i] / 2;

                                    if (fMinStartX > fStartX)
                                        fMinStartX = fStartX;   // get smallest start x

                                    if (fMaxEndX < fEndX)
                                        fMaxEndX = fEndX;       // get biggest end x
                                }

                                int intSelectedObjectInddex = -1;
                                float fNearestCenter = float.MaxValue;
                                float fNorminalCenterX = (fMinStartX + fMaxEndX) / 2;
                                for (int i = 0; i < m_objEBlobs.ref_intNumSelectedObject; i++)
                                {
                                    if (fNearestCenter > Math.Abs(m_objEBlobs.ref_arrLimitCenterX[i] - fNorminalCenterX))
                                    {
                                        fNearestCenter = Math.Abs(m_objEBlobs.ref_arrLimitCenterX[i] - fNorminalCenterX);
                                        intSelectedObjectInddex = i;
                                    }
                                }

                                fStartX = m_objEBlobs.ref_arrLimitCenterX[intSelectedObjectInddex] - m_objEBlobs.ref_arrWidth[intSelectedObjectInddex] / 2;
                                fStartY = m_objEBlobs.ref_arrLimitCenterY[intSelectedObjectInddex] - m_objEBlobs.ref_arrHeight[intSelectedObjectInddex] / 2;
                                fEndX = m_objEBlobs.ref_arrLimitCenterX[intSelectedObjectInddex] + m_objEBlobs.ref_arrWidth[intSelectedObjectInddex] / 2;
                                fEndY = m_objEBlobs.ref_arrLimitCenterY[intSelectedObjectInddex] + m_objEBlobs.ref_arrHeight[intSelectedObjectInddex] / 2;
                                fCenterX = m_objEBlobs.ref_arrLimitCenterX[intSelectedObjectInddex];
                                fCenterY = m_objEBlobs.ref_arrLimitCenterY[intSelectedObjectInddex];
                                fWidth = m_objEBlobs.ref_arrWidth[intSelectedObjectInddex];
                                fHeight = m_objEBlobs.ref_arrHeight[intSelectedObjectInddex];

                            }
                            m_arrLineGauge[intLineGaugeIndex].SetGaugePlacement(pBaselinePoint.X,
                                                                                m_objLocalROI.ref_ROITotalY + fCenterY,
                                                                                10, fHeight, -90);

                            m_arrLineGauge[intLineGaugeIndex].Measure(m_objLocalROI);


                            m_objBaseLine.CalculateStraightLine(new PointF(m_arrLineGauge[intLineGaugeIndex].ref_ObjectCenterX, m_arrLineGauge[intLineGaugeIndex].ref_ObjectCenterY), m_arrLineGauge[intLineGaugeIndex].ref_ObjectAngle);   // The CalculateStraightLine need angle parameter start from straight line Y, but the line gauge start from straight line X. So need to add 90deg.
                            m_objEdgeLine_Top.CalculateStraightLine(new PointF(m_objLocalROI.ref_ROITotalX + fEndX, m_objLocalROI.ref_ROITotalY + fStartY), 90);
                            m_objEdgeLine_Bottom.CalculateStraightLine(new PointF(m_objLocalROI.ref_ROITotalX + fEndX, m_objLocalROI.ref_ROITotalY + fEndY), 90);

                            m_fBaseLineAngle = m_arrLineGauge[intLineGaugeIndex].ref_ObjectAngle;
                            m_pCornerPoint_Top = Line.GetCrossPoint(m_objBaseLine, m_objEdgeLine_Top);
                            m_pCornerPoint_Bottom = Line.GetCrossPoint(m_objBaseLine, m_objEdgeLine_Bottom);
                        }
                        break;
                    default:
                        return false;   // no center ROI because no base line measurement for center ROI.
                }



            }



            return true;

        }

        public bool InspectLead3D_Center(ROI objROI)
        {
            m_blnLock = true;

            lock (m_objLockBlobs)
            {
                // Define actual threshold value
                m_intThresholdValuePrev = m_intThresholdValue;
                if (m_intThresholdValue == -4)
                    m_intThresholdValue = GetAutoThresholdValue(objROI, 3);

                InitLeadInspectionData_Lead3D(objROI);

                for (int r = 0; r < 2; r++) // Loop 2 to check top left or right bottom
                {
                    int intNumberOfLeads = 0;
                    if (m_intLeadROIDirection == 2 || m_intLeadROIDirection == 4) //m_intLeadDirection == 0   // Horizontal Leads
                    {
                        m_objLocalROI.AttachImage(objROI);

                        if (r == 0)
                        {
                            // Set single leads ROI
                            m_objLocalROI.LoadROISetting(0,
                                                       0,
                                                       (int)Math.Round(m_pCornerPoint_Center.X - m_fCenterUnitWidth / 2 - objROI.ref_ROITotalX, 0, MidpointRounding.AwayFromZero),
                                                       objROI.ref_ROIHeight);

                            intNumberOfLeads = m_intNumberOfLead_Left;
                        }
                        else
                        {
                            // Set single leads ROI
                            m_objLocalROI.LoadROISetting((int)Math.Round(m_pCornerPoint_Center.X + m_fCenterUnitWidth / 2 - objROI.ref_ROITotalX, 0, MidpointRounding.AwayFromZero),
                                                         0,
                                                         objROI.ref_ROIWidth - (int)Math.Round(m_pCornerPoint_Center.X + m_fCenterUnitWidth / 2 - objROI.ref_ROITotalX, 0, MidpointRounding.AwayFromZero),
                                                         objROI.ref_ROIHeight);

                            intNumberOfLeads = m_intNumberOfLead_Right;
                        }
                    }
                    else if (m_intLeadROIDirection == 1 || m_intLeadROIDirection == 3) //else // Vertical leads
                    {

                    }

                    m_objEBlobs.BuildObjects_Filter_GetElement(m_objLocalROI, !m_blnWhiteOnBlack, true, 0, m_intThresholdValue,
                       (int)Math.Floor(m_fBlobsMinArea), m_intMaxArea, false, 0x0F);

                    // Check blobs is empty
                    int intNumSelectedObject = m_objEBlobs.ref_intNumSelectedObject;
                    if (intNumSelectedObject == 0 && intNumberOfLeads > 0)   // Missing Lead if template got Leads but sample is empty
                    {
                        for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
                        {
                            m_intFailResultMask |= 0x04;
                            m_arrSampleBlobLeads[i].intFailMask |= 0x04;
                        }
                        m_blnLock = false;
                        return false;
                    }

                    Lead3DTestStage1(m_objLocalROI, intNumberOfLeads);

                }

                // Missing Lead if template got Leads but sample is empty
                for (int i = 0; i < m_arrSampleBlobLeads.Length; i++)
                {
                    if (m_arrSampleBlobLeads[i].fArea == -999)
                    {
                        m_intFailResultMask |= 0x04;
                        m_arrSampleBlobLeads[i].intFailMask |= 0x04;
                    }
                }

                // Check Dimension
                CheckDimension_Lead3D(objROI);


                m_intThresholdValue = m_intThresholdValuePrev;

                m_blnLock = false;

                if (m_intFailResultMask == 0)
                    return true;
                else
                    return false;

            }
        }

        public bool FindUnitBaseLine(ROI objROI)
        {
            /* Top ROI for example:
             * 1. Get center point of base line. 
             *      - Attach line guage on unit base line with line gauge position at center of ROI width, guage length 20 only.
             * 2. After get the center point, get the center blob
             *      - attach a small ROI base line based on the center point. 
             *      - The small ROI width size same as Top search ROI. 
             *      - The small ROI height is around 10 pixels only. Height must not over than unit side line height.
             *      - build blob and get the center blob.
             * 3. Get base line angle.
             * 4. 
             */

            if (m_arrTemplateBlobLeads.Count == 0)
                return false;

            // Constant Variables
            int intBodyEdgeOffsetFromBase = 20;
            // Get unit body from template blob 
            int intLineGaugeIndex = m_intLeadROIDirection - 1;

            if (m_blnWhiteOnBlack)
                m_blnWhiteOnBlack = false;  // Side base line image is always black on white

            BlobsFeatures stcBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobLeads[0];  // First blob is the side ROI unit blob.

            bool blnGetBaselinePointOK = false;
            PointF pBaselinePoint = new PointF();
            float fStartX = 0, fStartY = 0, fEndX = 0, fEndY = 0, fCenterX = 0, fCenterY = 0, fWidth = 0, fHeight = 0;
            int intLocalROITolerance = 5;
            if (m_intLeadROIDirection == 2 || m_intLeadROIDirection == 4) //m_intLeadDirection == 0    // Horizontal
            {

                switch (m_intLeadROIDirection)
                {
                    case 1: // Top ROI
                        {
                            // ------- Get outer point ------------------------
                            m_arrLineGauge[intLineGaugeIndex].SetGaugePlacement(objROI.ref_ROITotalX + stcBlobsFeatures.fLimitCenterX,
                                                    objROI.ref_ROITotalY + stcBlobsFeatures.fStartY,
                                                    stcBlobsFeatures.fHeight, 20, 0);
                            m_arrLineGauge[intLineGaugeIndex].ref_GaugeThreshold = 10;

                            m_arrLineGauge[intLineGaugeIndex].Measure(objROI);

                            blnGetBaselinePointOK = m_arrLineGauge[intLineGaugeIndex].GetMeasurementSampleCenterPoints(objROI, 10, ref pBaselinePoint);

                            // -------- Get center blob --------------------------------------
                            m_objLocalROI.AttachImage(objROI);
                            m_objLocalROI.LoadROISetting(0, (int)pBaselinePoint.Y - intLocalROITolerance - objROI.ref_ROITotalY, objROI.ref_ROIWidth, intBodyEdgeOffsetFromBase + intLocalROITolerance);

                            BuildOnlySideLeadObjects_BlackObject(m_objLocalROI);

                            // Get center blobs information
                            if (m_objEBlobs.ref_intNumSelectedObject == 1)
                            {
                                fStartX = m_objEBlobs.ref_arrLimitCenterX[0] - m_objEBlobs.ref_arrWidth[0] / 2;
                                fStartY = m_objEBlobs.ref_arrLimitCenterY[0] - m_objEBlobs.ref_arrHeight[0] / 2;
                                fEndX = m_objEBlobs.ref_arrLimitCenterX[0] + m_objEBlobs.ref_arrWidth[0] / 2;
                                fEndY = m_objEBlobs.ref_arrLimitCenterY[0] + m_objEBlobs.ref_arrHeight[0] / 2;
                                fCenterX = m_objEBlobs.ref_arrLimitCenterX[0];
                                fCenterY = m_objEBlobs.ref_arrLimitCenterY[0];
                                fWidth = m_objEBlobs.ref_arrWidth[0];
                                fHeight = m_objEBlobs.ref_arrHeight[0];
                            }
                            else
                            {
                                float fMinStartX = float.MaxValue;
                                float fMaxEndX = float.MinValue;
                                for (int i = 0; i < m_objEBlobs.ref_intNumSelectedObject; i++)
                                {
                                    fStartX = m_objEBlobs.ref_arrLimitCenterX[i] - m_objEBlobs.ref_arrWidth[i] / 2;
                                    fEndX = m_objEBlobs.ref_arrLimitCenterX[i] + m_objEBlobs.ref_arrWidth[i] / 2;

                                    if (fMinStartX > fStartX)
                                        fMinStartX = fStartX;   // get smallest start x

                                    if (fMaxEndX < fEndX)
                                        fMaxEndX = fEndX;       // get biggest end x
                                }

                                int intSelectedObjectInddex = -1;
                                float fNearestCenter = float.MaxValue;
                                float fNorminalCenterX = (fMinStartX + fMaxEndX) / 2;
                                for (int i = 0; i < m_objEBlobs.ref_intNumSelectedObject; i++)
                                {
                                    if (fNearestCenter > Math.Abs(m_objEBlobs.ref_arrLimitCenterX[i] - fNorminalCenterX))
                                    {
                                        fNearestCenter = Math.Abs(m_objEBlobs.ref_arrLimitCenterX[i] - fNorminalCenterX);
                                        intSelectedObjectInddex = i;
                                    }
                                }

                                fStartX = m_objEBlobs.ref_arrLimitCenterX[intSelectedObjectInddex] - m_objEBlobs.ref_arrWidth[intSelectedObjectInddex] / 2;
                                fStartY = m_objEBlobs.ref_arrLimitCenterY[intSelectedObjectInddex] - m_objEBlobs.ref_arrHeight[intSelectedObjectInddex] / 2;
                                fEndX = m_objEBlobs.ref_arrLimitCenterX[intSelectedObjectInddex] + m_objEBlobs.ref_arrWidth[intSelectedObjectInddex] / 2;
                                fEndY = m_objEBlobs.ref_arrLimitCenterY[intSelectedObjectInddex] + m_objEBlobs.ref_arrHeight[intSelectedObjectInddex] / 2;
                                fCenterX = m_objEBlobs.ref_arrLimitCenterX[intSelectedObjectInddex];
                                fCenterY = m_objEBlobs.ref_arrLimitCenterY[intSelectedObjectInddex];
                                fWidth = m_objEBlobs.ref_arrWidth[intSelectedObjectInddex];
                                fHeight = m_objEBlobs.ref_arrHeight[intSelectedObjectInddex];

                            }

                            // Remeasure on center blob to get base line.
                            m_arrLineGauge[intLineGaugeIndex].SetGaugePlacement(m_objLocalROI.ref_ROITotalX + fCenterX,
                                                    pBaselinePoint.Y, 10, fWidth, 0);

                            m_arrLineGauge[intLineGaugeIndex].Measure(m_objLocalROI);

                            //---------------------- vitrox sequence ---------------------------------------------------------------------
                            //m_arrLineGauge[intLineGaugeIndex].ref_GaugeThreshold = 10;

                            //m_arrLineGauge[intLineGaugeIndex].SetGaugePlacement(objROI.ref_ROITotalX + stcBlobsFeatures.fLimitCenterX,
                            //                                                    objROI.ref_ROITotalY + stcBlobsFeatures.fStartY,
                            //                                                    stcBlobsFeatures.fHeight, stcBlobsFeatures.fWidth - m_intBaseLineTrimFromEdge * 2, 0);


                            //m_arrLineGauge[intLineGaugeIndex].Measure(objROI);

                            //for (int i = 0; i < m_intBaseLineSteps; i++)
                            //{
                            //    float fBaseLineReferencePointY = m_arrLineGauge[intLineGaugeIndex].ref_ObjectCenterY;
                            //    float fLineGaugeTolerance = (objROI.ref_ROITotalY + stcBlobsFeatures.fEndY - fBaseLineReferencePointY) / 2;
                            //    m_arrLineGauge[intLineGaugeIndex].SetGaugePlacement(objROI.ref_ROITotalX + stcBlobsFeatures.fLimitCenterX,
                            //                                                        fBaseLineReferencePointY + fLineGaugeTolerance,
                            //                                                        fLineGaugeTolerance, stcBlobsFeatures.fWidth - m_intBaseLineTrimFromEdge * 2, 0);

                            //    m_arrLineGauge[intLineGaugeIndex].Measure(objROI);
                            //}

                            //pBaselinePoint = new PointF(m_arrLineGauge[intLineGaugeIndex].ref_ObjectCenterX, m_arrLineGauge[intLineGaugeIndex].ref_ObjectCenterY);

                            //blnGetBaselinePointOK = true;
                        }
                        break;
                    case 2: // Right ROI
                        {
                            m_arrLineGauge[intLineGaugeIndex].ref_GaugeThreshold = 10;

                            m_arrLineGauge[intLineGaugeIndex].SetGaugePlacement(objROI.ref_ROITotalX + stcBlobsFeatures.fEndX,
                                                                                objROI.ref_ROITotalY + stcBlobsFeatures.fLimitCenterY,
                                                                                stcBlobsFeatures.fWidth, stcBlobsFeatures.fHeight - m_intBaseLineTrimFromEdge * 2, 90);

                            m_arrLineGauge[intLineGaugeIndex].Measure(objROI);

                            for (int i = 0; i < m_intBaseLineSteps; i++)
                            {
                                float fBaseLineReferencePointX = m_arrLineGauge[intLineGaugeIndex].ref_ObjectCenterX;
                                float fLineGaugeTolerance = (fBaseLineReferencePointX - objROI.ref_ROITotalX + stcBlobsFeatures.fStartX) / 2;
                                m_arrLineGauge[intLineGaugeIndex].SetGaugePlacement(fBaseLineReferencePointX - fLineGaugeTolerance,
                                                                                    objROI.ref_ROITotalY + stcBlobsFeatures.fLimitCenterY,
                                                                                    fLineGaugeTolerance, stcBlobsFeatures.fHeight - m_intBaseLineTrimFromEdge * 2, 90);

                                m_arrLineGauge[intLineGaugeIndex].Measure(objROI);
                            }

                            pBaselinePoint = new PointF(m_arrLineGauge[intLineGaugeIndex].ref_ObjectCenterX, m_arrLineGauge[intLineGaugeIndex].ref_ObjectCenterY);

                            blnGetBaselinePointOK = true;
                        }
                        break;
                    case 3: // Bottom ROI
                        {
                            // ------- Get outer point ------------------------
                            m_arrLineGauge[intLineGaugeIndex].SetGaugePlacement(objROI.ref_ROITotalX + stcBlobsFeatures.fLimitCenterX,
                                                    objROI.ref_ROITotalY + stcBlobsFeatures.fEndY,
                                                    stcBlobsFeatures.fHeight, 20, 180);
                            m_arrLineGauge[intLineGaugeIndex].ref_GaugeThreshold = 10;

                            m_arrLineGauge[intLineGaugeIndex].Measure(objROI);

                            blnGetBaselinePointOK = m_arrLineGauge[intLineGaugeIndex].GetMeasurementSampleCenterPoints(objROI, 10, ref pBaselinePoint);

                            // -------- Get center blob --------------------------------------
                            m_objLocalROI.AttachImage(objROI);
                            m_objLocalROI.LoadROISetting(0, (int)pBaselinePoint.Y - intBodyEdgeOffsetFromBase - objROI.ref_ROITotalY,
                                                        objROI.ref_ROIWidth, intBodyEdgeOffsetFromBase + intLocalROITolerance);

                            BuildOnlySideLeadObjects_BlackObject(m_objLocalROI);

                            // Get center blobs information
                            if (m_objEBlobs.ref_intNumSelectedObject == 1)
                            {
                                fStartX = m_objEBlobs.ref_arrLimitCenterX[0] - m_objEBlobs.ref_arrWidth[0] / 2;
                                fStartY = m_objEBlobs.ref_arrLimitCenterY[0] - m_objEBlobs.ref_arrHeight[0] / 2;
                                fEndX = m_objEBlobs.ref_arrLimitCenterX[0] + m_objEBlobs.ref_arrWidth[0] / 2;
                                fEndY = m_objEBlobs.ref_arrLimitCenterY[0] + m_objEBlobs.ref_arrHeight[0] / 2;
                                fCenterX = m_objEBlobs.ref_arrLimitCenterX[0];
                                fCenterY = m_objEBlobs.ref_arrLimitCenterY[0];
                                fWidth = m_objEBlobs.ref_arrWidth[0];
                                fHeight = m_objEBlobs.ref_arrHeight[0];
                            }
                            else
                            {
                                float fMinStartX = float.MaxValue;
                                float fMaxEndX = float.MinValue;
                                for (int i = 0; i < m_objEBlobs.ref_intNumSelectedObject; i++)
                                {
                                    fStartX = m_objEBlobs.ref_arrLimitCenterX[i] - m_objEBlobs.ref_arrWidth[i] / 2;
                                    fEndX = m_objEBlobs.ref_arrLimitCenterX[i] + m_objEBlobs.ref_arrWidth[i] / 2;

                                    if (fMinStartX > fStartX)
                                        fMinStartX = fStartX;   // get smallest start x

                                    if (fMaxEndX < fEndX)
                                        fMaxEndX = fEndX;       // get biggest end x
                                }

                                int intSelectedObjectInddex = -1;
                                float fNearestCenter = float.MaxValue;
                                float fNorminalCenterX = (fMinStartX + fMaxEndX) / 2;
                                for (int i = 0; i < m_objEBlobs.ref_intNumSelectedObject; i++)
                                {
                                    if (fNearestCenter > Math.Abs(m_objEBlobs.ref_arrLimitCenterX[i] - fNorminalCenterX))
                                    {
                                        fNearestCenter = Math.Abs(m_objEBlobs.ref_arrLimitCenterX[i] - fNorminalCenterX);
                                        intSelectedObjectInddex = i;
                                    }
                                }

                                fStartX = m_objEBlobs.ref_arrLimitCenterX[intSelectedObjectInddex] - m_objEBlobs.ref_arrWidth[intSelectedObjectInddex] / 2;
                                fStartY = m_objEBlobs.ref_arrLimitCenterY[intSelectedObjectInddex] - m_objEBlobs.ref_arrHeight[intSelectedObjectInddex] / 2;
                                fEndX = m_objEBlobs.ref_arrLimitCenterX[intSelectedObjectInddex] + m_objEBlobs.ref_arrWidth[intSelectedObjectInddex] / 2;
                                fEndY = m_objEBlobs.ref_arrLimitCenterY[intSelectedObjectInddex] + m_objEBlobs.ref_arrHeight[intSelectedObjectInddex] / 2;
                                fCenterX = m_objEBlobs.ref_arrLimitCenterX[intSelectedObjectInddex];
                                fCenterY = m_objEBlobs.ref_arrLimitCenterY[intSelectedObjectInddex];
                                fWidth = m_objEBlobs.ref_arrWidth[intSelectedObjectInddex];
                                fHeight = m_objEBlobs.ref_arrHeight[intSelectedObjectInddex];

                            }

                            // Remeasure to get base line
                            m_arrLineGauge[intLineGaugeIndex].SetGaugePlacement(m_objLocalROI.ref_ROITotalX + fCenterX,
                                                    pBaselinePoint.Y, 10, fWidth, 180);

                            m_arrLineGauge[intLineGaugeIndex].Measure(m_objLocalROI);

                            // ---------------------- Vitrox sequennce -------------------------------------------------------------------------
                            //m_arrLineGauge[intLineGaugeIndex].ref_GaugeThreshold = 10;

                            //m_arrLineGauge[intLineGaugeIndex].SetGaugePlacement(objROI.ref_ROITotalX + stcBlobsFeatures.fLimitCenterX, 
                            //                                                    objROI.ref_ROITotalY + stcBlobsFeatures.fEndY,
                            //                                                    stcBlobsFeatures.fHeight, stcBlobsFeatures.fWidth - m_intBaseLineTrimFromEdge * 2 , 180);

                            //m_arrLineGauge[intLineGaugeIndex].Measure(objROI);

                            //for (int i = 0; i < m_intBaseLineSteps; i++)
                            //{
                            //    float fBaseLineReferencePointY = m_arrLineGauge[intLineGaugeIndex].ref_ObjectCenterY;
                            //    float fLineGaugeTolerance = (fBaseLineReferencePointY - objROI.ref_ROITotalY + stcBlobsFeatures.fStartY) / 2;
                            //    m_arrLineGauge[intLineGaugeIndex].SetGaugePlacement(objROI.ref_ROITotalX + stcBlobsFeatures.fLimitCenterX,
                            //                                                        fBaseLineReferencePointY - fLineGaugeTolerance,
                            //                                                        fLineGaugeTolerance, stcBlobsFeatures.fWidth - m_intBaseLineTrimFromEdge * 2, 180);

                            //    m_arrLineGauge[intLineGaugeIndex].Measure(objROI);
                            //}

                            pBaselinePoint = new PointF(m_arrLineGauge[intLineGaugeIndex].ref_ObjectCenterX, m_arrLineGauge[intLineGaugeIndex].ref_ObjectCenterY);

                            blnGetBaselinePointOK = true;
                        }
                        break;
                    case 4: // Left ROI
                        {
                            m_arrLineGauge[intLineGaugeIndex].ref_GaugeThreshold = 10;

                            m_arrLineGauge[intLineGaugeIndex].SetGaugePlacement(objROI.ref_ROITotalX + stcBlobsFeatures.fStartX,
                                                                                objROI.ref_ROITotalY + stcBlobsFeatures.fLimitCenterY,
                                                                                    stcBlobsFeatures.fWidth, stcBlobsFeatures.fHeight - m_intBaseLineTrimFromEdge * 2, -90);


                            m_arrLineGauge[intLineGaugeIndex].Measure(objROI);

                            for (int i = 0; i < m_intBaseLineSteps; i++)
                            {
                                float fBaseLineReferencePointX = m_arrLineGauge[intLineGaugeIndex].ref_ObjectCenterX;
                                float fLineGaugeTolerance = (objROI.ref_ROITotalX + stcBlobsFeatures.fEndX - fBaseLineReferencePointX) / 2;
                                m_arrLineGauge[intLineGaugeIndex].SetGaugePlacement(fBaseLineReferencePointX + fLineGaugeTolerance,
                                                                                    objROI.ref_ROITotalY + stcBlobsFeatures.fLimitCenterY,
                                                                                    fLineGaugeTolerance, stcBlobsFeatures.fHeight - m_intBaseLineTrimFromEdge * 2, -90);

                                m_arrLineGauge[intLineGaugeIndex].Measure(objROI);
                            }

                            pBaselinePoint = new PointF(m_arrLineGauge[intLineGaugeIndex].ref_ObjectCenterX, m_arrLineGauge[intLineGaugeIndex].ref_ObjectCenterY);

                            blnGetBaselinePointOK = true;
                        }
                        break;
                    default:
                        return false;   // no center ROI because no base line measurement for center ROI.
                }
            }
            else if (m_intLeadROIDirection == 1 || m_intLeadROIDirection == 3) //else
            {

                switch (m_intLeadROIDirection)
                {
                    case 1: // Top ROI
                        {
                        }
                        break;
                    case 2: // Right ROI
                        {
                        }
                        break;
                    case 3: // Bottom ROI
                        {
                        }
                        break;
                    case 4: // Left ROI
                        {
                        }
                        break;
                    default:
                        return false;   // no center ROI because no base line measurement for center ROI.
                }
            }

            if (blnGetBaselinePointOK)
            {
                switch (m_intLeadROIDirection)
                {
                    case 1: // Top ROI
                        {
                            m_objBaseLine.CalculateStraightLine(new PointF(m_arrLineGauge[intLineGaugeIndex].ref_ObjectCenterX,
                                                                           m_arrLineGauge[intLineGaugeIndex].ref_ObjectCenterY),
                                                                           m_arrLineGauge[intLineGaugeIndex].ref_ObjectAngle + 90);   // The CalculateStraightLine need angle parameter start from straight line Y, but the line gauge start from straight line X. So need to add 90deg.

                            m_objEdgeLine_Left.CalculateStraightLine(new PointF(m_arrLineGauge[intLineGaugeIndex].ref_GaugeCenterX -
                                                                               m_arrLineGauge[intLineGaugeIndex].ref_GaugeLength / 2,
                                                                               m_arrLineGauge[intLineGaugeIndex].ref_GaugeCenterY),
                                                                               0);

                            m_objEdgeLine_Right.CalculateStraightLine(new PointF(m_arrLineGauge[intLineGaugeIndex].ref_GaugeCenterX +
                                                                                  m_arrLineGauge[intLineGaugeIndex].ref_GaugeLength / 2,
                                                                                  m_arrLineGauge[intLineGaugeIndex].ref_GaugeCenterY),
                                                                                  0);

                            m_fBaseLineAngle = m_arrLineGauge[intLineGaugeIndex].ref_ObjectAngle;
                            m_pCornerPoint_Left = Line.GetCrossPoint(m_objBaseLine, m_objEdgeLine_Left);
                            m_pCornerPoint_Right = Line.GetCrossPoint(m_objBaseLine, m_objEdgeLine_Right);
                        }
                        break;
                    case 2: // Right ROI
                        {
                            m_objBaseLine.CalculateStraightLine(new PointF(m_arrLineGauge[intLineGaugeIndex].ref_ObjectCenterX,
                                                                           m_arrLineGauge[intLineGaugeIndex].ref_ObjectCenterY),
                                                                           m_arrLineGauge[intLineGaugeIndex].ref_ObjectAngle);

                            m_objEdgeLine_Top.CalculateStraightLine(new PointF(m_arrLineGauge[intLineGaugeIndex].ref_GaugeCenterX,
                                                                               m_arrLineGauge[intLineGaugeIndex].ref_GaugeCenterY -
                                                                               m_arrLineGauge[intLineGaugeIndex].ref_GaugeLength / 2),
                                                                               90);

                            m_objEdgeLine_Bottom.CalculateStraightLine(new PointF(m_arrLineGauge[intLineGaugeIndex].ref_GaugeCenterX,
                                                                               m_arrLineGauge[intLineGaugeIndex].ref_GaugeCenterY +
                                                                               m_arrLineGauge[intLineGaugeIndex].ref_GaugeLength / 2),
                                                                               90);

                            m_fBaseLineAngle = m_arrLineGauge[intLineGaugeIndex].ref_ObjectAngle;
                            m_pCornerPoint_Top = Line.GetCrossPoint(m_objBaseLine, m_objEdgeLine_Top);
                            m_pCornerPoint_Bottom = Line.GetCrossPoint(m_objBaseLine, m_objEdgeLine_Bottom);
                        }
                        break;
                    case 3: // Bottom ROI
                        {
                            m_objBaseLine.CalculateStraightLine(new PointF(m_arrLineGauge[intLineGaugeIndex].ref_ObjectCenterX,
                                                                           m_arrLineGauge[intLineGaugeIndex].ref_ObjectCenterY),
                                                                           m_arrLineGauge[intLineGaugeIndex].ref_ObjectAngle + 90);   // The CalculateStraightLine need angle parameter start from straight line Y, but the line gauge start from straight line X. So need to add 90deg.

                            m_objEdgeLine_Left.CalculateStraightLine(new PointF(m_arrLineGauge[intLineGaugeIndex].ref_GaugeCenterX -
                                                                               m_arrLineGauge[intLineGaugeIndex].ref_GaugeLength / 2,
                                                                               m_arrLineGauge[intLineGaugeIndex].ref_GaugeCenterY),
                                                                               0);

                            m_objEdgeLine_Right.CalculateStraightLine(new PointF(m_arrLineGauge[intLineGaugeIndex].ref_GaugeCenterX +
                                                                                  m_arrLineGauge[intLineGaugeIndex].ref_GaugeLength / 2,
                                                                                  m_arrLineGauge[intLineGaugeIndex].ref_GaugeCenterY),
                                                                                  0);

                            m_fBaseLineAngle = m_arrLineGauge[intLineGaugeIndex].ref_ObjectAngle;
                            m_pCornerPoint_Left = Line.GetCrossPoint(m_objBaseLine, m_objEdgeLine_Left);
                            m_pCornerPoint_Right = Line.GetCrossPoint(m_objBaseLine, m_objEdgeLine_Right);
                        }
                        break;
                    case 4: // Left ROI
                        {
                            m_objBaseLine.CalculateStraightLine(new PointF(m_arrLineGauge[intLineGaugeIndex].ref_ObjectCenterX,
                                                                           m_arrLineGauge[intLineGaugeIndex].ref_ObjectCenterY),
                                                                           m_arrLineGauge[intLineGaugeIndex].ref_ObjectAngle);   // The CalculateStraightLine need angle parameter start from straight line Y, but the line gauge start from straight line X. So need to add 90deg.

                            m_objEdgeLine_Top.CalculateStraightLine(new PointF(m_arrLineGauge[intLineGaugeIndex].ref_GaugeCenterX,
                                                                               m_arrLineGauge[intLineGaugeIndex].ref_GaugeCenterY -
                                                                               m_arrLineGauge[intLineGaugeIndex].ref_GaugeLength / 2), 90);

                            m_objEdgeLine_Bottom.CalculateStraightLine(new PointF(m_arrLineGauge[intLineGaugeIndex].ref_GaugeCenterX,
                                                                               m_arrLineGauge[intLineGaugeIndex].ref_GaugeCenterY +
                                                                               m_arrLineGauge[intLineGaugeIndex].ref_GaugeLength / 2), 90);

                            m_fBaseLineAngle = m_arrLineGauge[intLineGaugeIndex].ref_ObjectAngle;
                            m_pCornerPoint_Top = Line.GetCrossPoint(m_objBaseLine, m_objEdgeLine_Top);
                            m_pCornerPoint_Bottom = Line.GetCrossPoint(m_objBaseLine, m_objEdgeLine_Bottom);
                        }
                        break;
                    default:
                        return false;   // no center ROI because no base line measurement for center ROI.
                }



            }

            return true;
        }

        public void DefineCenterUnitEdge(PointF pTopLeftCorner, PointF pTopRightCorner,
                                         PointF pRightTopCorner, PointF pRightBottomCorner,
                                         PointF pBottomLeftCorner, PointF pBottomRightCorner,
                                         PointF pLeftTopCorner, PointF pLeftBottomCorner)
        {
            Line objTopLeftLine = new Line();
            objTopLeftLine.CalculateStraightLine(pTopLeftCorner, 0);
            Line objLeftTopLine = new Line();
            objLeftTopLine.CalculateStraightLine(pLeftTopCorner, 90);
            m_pCornerPoint_TopLeft = Line.GetCrossPoint(objTopLeftLine, objLeftTopLine);

            Line objTopRightLine = new Line();
            objTopRightLine.CalculateStraightLine(pTopRightCorner, 0);
            Line objRightTopLine = new Line();
            objRightTopLine.CalculateStraightLine(pRightTopCorner, 90);
            m_pCornerPoint_TopRight = Line.GetCrossPoint(objTopRightLine, objRightTopLine);

            Line objBottomLeftLine = new Line();
            objBottomLeftLine.CalculateStraightLine(pBottomLeftCorner, 0);
            Line objLeftBottomLine = new Line();
            objLeftBottomLine.CalculateStraightLine(pLeftBottomCorner, 90);
            m_pCornerPoint_BottomLeft = Line.GetCrossPoint(objBottomLeftLine, objLeftBottomLine);

            Line objBottomRightLine = new Line();
            objBottomRightLine.CalculateStraightLine(pBottomRightCorner, 0);
            Line objRightBottomLine = new Line();
            objRightBottomLine.CalculateStraightLine(pRightBottomCorner, 90);
            m_pCornerPoint_BottomRight = Line.GetCrossPoint(objBottomRightLine, objRightBottomLine);

            Line objTopLine = new Line();
            objTopLine.CalculateStraightLine(m_pCornerPoint_TopLeft, m_pCornerPoint_TopRight);
            float fTopAngle;
            if (objTopLine.ref_dAngle < 0)
                fTopAngle = -90 - (float)objTopLine.ref_dAngle;
            else
                fTopAngle = 90 - (float)objTopLine.ref_dAngle;
            Line objBottomLine = new Line();
            objBottomLine.CalculateStraightLine(m_pCornerPoint_BottomLeft, m_pCornerPoint_BottomRight);
            float fBottomAngle;
            if (objBottomLine.ref_dAngle < 0)
                fBottomAngle = -90 - (float)objBottomLine.ref_dAngle;
            else
                fBottomAngle = 90 - (float)objBottomLine.ref_dAngle;
            Line objLeftLine = new Line();
            objLeftLine.CalculateStraightLine(m_pCornerPoint_TopLeft, m_pCornerPoint_BottomLeft);
            float fLeftAngle = (float)objLeftLine.ref_dAngle;
            Line objRightLine = new Line();
            objRightLine.CalculateStraightLine(m_pCornerPoint_TopRight, m_pCornerPoint_BottomRight);
            float fRightAngle = (float)objRightLine.ref_dAngle;

            m_fCenterUnitAngle = (fTopAngle + fBottomAngle + fLeftAngle + fRightAngle) / 4;
            m_fCenterUnitWidth = (Math2.GetDistanceBtw2Points(m_pCornerPoint_TopLeft, m_pCornerPoint_TopRight) +
                                  Math2.GetDistanceBtw2Points(m_pCornerPoint_BottomLeft, m_pCornerPoint_BottomRight)) / 2;
            m_fCenterUnitHeight = (Math2.GetDistanceBtw2Points(m_pCornerPoint_TopLeft, m_pCornerPoint_BottomLeft) +
                                   Math2.GetDistanceBtw2Points(m_pCornerPoint_TopRight, m_pCornerPoint_BottomRight)) / 2;

            Line objLine1 = new Line();
            objLine1.CalculateStraightLine(m_pCornerPoint_TopLeft, m_pCornerPoint_BottomRight);
            Line objLine2 = new Line();
            objLine2.CalculateStraightLine(m_pCornerPoint_TopRight, m_pCornerPoint_BottomLeft);

            m_pCornerPoint_Center = Line.GetCrossPoint(objLine1, objLine2);

        }

        public void DefineCenterLeadsRange(ref float fStartX, ref float fStartY, ref float fEndX, ref float fEndY)
        {
            BlobsFeatures stcBlobsFeatures;
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                stcBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                if (fStartX > stcBlobsFeatures.fStartX)
                    fStartX = stcBlobsFeatures.fStartX;

                if (fStartY > stcBlobsFeatures.fStartY)
                    fStartY = stcBlobsFeatures.fStartY;

                if (fEndX < stcBlobsFeatures.fEndX)
                    fEndX = stcBlobsFeatures.fEndX;

                if (fEndY < stcBlobsFeatures.fEndY)
                    fEndY = stcBlobsFeatures.fEndY;
            }
        }

        public void FindLeads(ROI objROI)
        {
            m_arrTemplateBlobLeads.Clear();

            if (m_intLeadROIDirection == 2 || m_intLeadROIDirection == 4) //m_intLeadDirection == 0    // Horizontal Leads
            {
                m_objLocalROI.AttachImage(objROI);
                m_objLocalROI.LoadROISetting(0,
                                             0,
                                            (int)Math.Max(m_pCornerPoint_TopLeft.X, m_pCornerPoint_BottomLeft.X) - objROI.ref_ROITotalX,
                                            objROI.ref_ROIHeight);

                BuildOnlyLeadObjects(m_objLocalROI);
                SetBlobsFeaturesToArray_CenterLead3D_SingleSide(m_objEBlobs, m_arrTemplateBlobLeads, m_objLocalROI, m_intNumberOfLead_Left, 1);

                m_objLocalROI.LoadROISetting((int)Math.Min(m_pCornerPoint_TopRight.X, m_pCornerPoint_BottomRight.X) - objROI.ref_ROITotalX,
                                              0,
                                              objROI.ref_ROITotalX + objROI.ref_ROIWidth - (int)Math.Min(m_pCornerPoint_TopRight.X, m_pCornerPoint_BottomRight.X),
                                              objROI.ref_ROIHeight);
                BuildOnlyLeadObjects(m_objLocalROI);
                SetBlobsFeaturesToArray_CenterLead3D_SingleSide(m_objEBlobs, m_arrTemplateBlobLeads, m_objLocalROI, m_intNumberOfLead_Right, 2);
            }
        }

        public void SortObjectNumber_Lead3D()
        {
            int intNoID = 1;
            BlobsFeatures stcBlobsFeatures = new BlobsFeatures();
            int[] intDirectionOrder = { -1, -1, -1, -1 };

#region Set Direction Sequence
            bool blnTopFound = false;
            bool blnBottomFound = false;
            bool blnLeftFound = false;
            bool blnRightFound = false;
            int intOneColumn = 0;
            int intOneRow = 0;
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                if (!m_stcBlobLead.blnSelected)
                    continue;

                if (m_stcBlobLead.intDirection == 1)
                    blnLeftFound = true;

                if (m_stcBlobLead.intDirection == 2)
                    blnRightFound = true;

                if (m_stcBlobLead.intDirection == 4)
                    blnTopFound = true;

                if (m_stcBlobLead.intDirection == 8)
                    blnBottomFound = true;
            }

            int intIndex = 0;
            switch (m_intFirstLead)
            {
                case 0: // Top
                    {
                        if (m_blnClockWise)
                        {
                            intDirectionOrder[intIndex++] = 4;
                            intDirectionOrder[intIndex++] = 2;
                            intDirectionOrder[intIndex++] = 8;
                            intDirectionOrder[intIndex++] = 1;
                        }
                        else
                        {
                            intDirectionOrder[intIndex++] = 4;
                            intDirectionOrder[intIndex++] = 1;
                            intDirectionOrder[intIndex++] = 8;
                            intDirectionOrder[intIndex++] = 2;
                        }
                    }
                    break;
                case 1: // Right
                    {
                        if (m_blnClockWise)
                        {
                            intDirectionOrder[intIndex++] = 2;
                            intDirectionOrder[intIndex++] = 8;
                            intDirectionOrder[intIndex++] = 1;
                            intDirectionOrder[intIndex++] = 4;
                        }
                        else
                        {
                            intDirectionOrder[intIndex++] = 2;
                            intDirectionOrder[intIndex++] = 4;
                            intDirectionOrder[intIndex++] = 1;
                            intDirectionOrder[intIndex++] = 8;
                        }
                    }
                    break;
                case 2: //Bottom
                    {
                        if (m_blnClockWise)
                        {
                            intDirectionOrder[intIndex++] = 8;
                            intDirectionOrder[intIndex++] = 1;
                            intDirectionOrder[intIndex++] = 4;
                            intDirectionOrder[intIndex++] = 2;
                        }
                        else
                        {
                            intDirectionOrder[intIndex++] = 8;
                            intDirectionOrder[intIndex++] = 2;
                            intDirectionOrder[intIndex++] = 4;
                            intDirectionOrder[intIndex++] = 1;
                        }
                    }
                    break;
                case 3: // Right
                    {
                        if (m_blnClockWise)
                        {
                            intDirectionOrder[intIndex++] = 1;
                            intDirectionOrder[intIndex++] = 4;
                            intDirectionOrder[intIndex++] = 2;
                            intDirectionOrder[intIndex++] = 8;
                        }
                        else
                        {
                            intDirectionOrder[intIndex++] = 1;
                            intDirectionOrder[intIndex++] = 8;
                            intDirectionOrder[intIndex++] = 2;
                            intDirectionOrder[intIndex++] = 4;
                        }
                    }
                    break;
            }

#endregion

#region Known Direction
            for (int d = 0; d < intDirectionOrder.Length; d++)
            {
                if (intDirectionOrder[d] == -1)
                    continue;

                for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)

                {
                    m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                    if (!m_stcBlobLead.blnSelected)
                        continue;

                    if (m_stcBlobLead.intDirection == intDirectionOrder[d])
                    {
                        m_stcBlobLead.intNoID = intNoID;

                        for (int j = 0; j < i; j++)
                        {
                            stcBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobLeads[j];

                            if (!stcBlobsFeatures.blnSelected)
                                continue;

                            if (stcBlobsFeatures.intDirection == intDirectionOrder[d])
                            {
                                if ((intDirectionOrder[d] == 5) || (intDirectionOrder[d] == 4) || (intDirectionOrder[d] == 6) || (intDirectionOrder[d] == 12) || (intDirectionOrder[d] == 13) || (intDirectionOrder[d] == 14))
                                {
                                    if (m_blnClockWise)
                                    {
                                        if (m_stcBlobLead.intStartX < stcBlobsFeatures.intStartX)
                                        {
                                            if (m_stcBlobLead.intNoID > stcBlobsFeatures.intNoID)
                                                m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                        }
                                    }
                                    else
                                    {
                                        if (m_stcBlobLead.intStartX > stcBlobsFeatures.intStartX)
                                        {
                                            if (m_stcBlobLead.intNoID > stcBlobsFeatures.intNoID)
                                                m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                        }
                                    }
                                }
                                else if ((intDirectionOrder[d] == 2) || (intDirectionOrder[d] == 0) || (intDirectionOrder[d] == 7) || (intDirectionOrder[d] == 3) || (intDirectionOrder[d] == 11))
                                {
                                    if (m_blnClockWise)
                                    {
                                        if (m_stcBlobLead.intStartY < stcBlobsFeatures.intStartY)
                                        {
                                            if (m_stcBlobLead.intNoID > stcBlobsFeatures.intNoID)
                                                m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                        }
                                    }
                                    else
                                    {
                                        if (m_stcBlobLead.intStartY > stcBlobsFeatures.intStartY)
                                        {
                                            if (m_stcBlobLead.intNoID > stcBlobsFeatures.intNoID)
                                                m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                        }
                                    }
                                }
                                else if ((intDirectionOrder[d] == 10) || (intDirectionOrder[d] == 8) || (intDirectionOrder[d] == 9))
                                {
                                    if (m_blnClockWise)
                                    {
                                        if (m_stcBlobLead.intStartX > stcBlobsFeatures.intStartX)
                                        {
                                            if (m_stcBlobLead.intNoID > stcBlobsFeatures.intNoID)
                                                m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                        }
                                    }
                                    else
                                    {
                                        if (m_stcBlobLead.intStartX < stcBlobsFeatures.intStartX)
                                        {
                                            if (m_stcBlobLead.intNoID > stcBlobsFeatures.intNoID)
                                                m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                        }
                                    }
                                }
                                else
                                {
                                    if (m_blnClockWise)
                                    {
                                        if (m_stcBlobLead.intStartY > stcBlobsFeatures.intStartY)
                                        {
                                            if (m_stcBlobLead.intNoID > stcBlobsFeatures.intNoID)
                                                m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                        }
                                    }
                                    else
                                    {
                                        if (m_stcBlobLead.intStartY < stcBlobsFeatures.intStartY)
                                        {
                                            if (m_stcBlobLead.intNoID > stcBlobsFeatures.intNoID)
                                                m_stcBlobLead.intNoID = stcBlobsFeatures.intNoID;
                                        }
                                    }
                                }
                            }
                        }

                        for (int j = 0; j < i; j++)
                        {
                            stcBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobLeads[j];
                            if (stcBlobsFeatures.intDirection == intDirectionOrder[d])
                            {
                                if (m_stcBlobLead.intNoID <= stcBlobsFeatures.intNoID)
                                {
                                    stcBlobsFeatures.intNoID++;
                                    m_arrTemplateBlobLeads.RemoveAt(j);
                                    m_arrTemplateBlobLeads.Insert(j, stcBlobsFeatures);
                                }
                            }
                        }
                        intNoID++;

                        m_arrTemplateBlobLeads.RemoveAt(i);
                        m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
                    }
                }
            }
#endregion

#region Unknown Direction

            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                if (!m_stcBlobLead.blnSelected)
                    continue;

                if (m_stcBlobLead.intNoID == 0)
                {
                    m_stcBlobLead.intNoID = intNoID;
                    m_arrTemplateBlobLeads.RemoveAt(i);
                    m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
                    intNoID++;
                }
            }

            List<string> arrData = new List<string>();
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                arrData.Add(m_stcBlobLead.fLimitCenterX.ToString() + ", " + m_stcBlobLead.fLimitCenterY.ToString() + ", " + m_stcBlobLead.intDirection.ToString() + ", " + m_stcBlobLead.intNoID.ToString());
            }

#endregion

#region Sort m_arrTemplateBlobLeads according to lable 

            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                int intSelectedIndex = -1;
                int intSmallestID = m_arrTemplateBlobLeads.Count;
                for (int j = i; j < m_arrTemplateBlobLeads.Count; j++)
                {
                    m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[j];

                    if (intSmallestID > m_stcBlobLead.intNoID)
                    {
                        intSelectedIndex = j;
                        intSmallestID = m_stcBlobLead.intNoID;
                    }
                }

                if (intSelectedIndex >= 0)
                {
                    m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[intSelectedIndex];
                    m_arrTemplateBlobLeads.RemoveAt(intSelectedIndex);
                    m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
                }
            }

#endregion
        }

        public void SaveLeadToleranceToFile(string strPath, bool blnNewFile, string strSectionName, bool blnNewSection)
        {
            XmlParser objFile = new XmlParser(strPath, blnNewFile);

            objFile.WriteSectionElement(strSectionName, blnNewSection);

            objFile.WriteElement1Value("LeadMinSpanLimit", m_fTemplateLeadMinSpanLimit);
            objFile.WriteElement1Value("LeadMaxSpanLimit", m_fTemplateLeadMaxSpanLimit);
            objFile.WriteElement1Value("TotalLeads", m_arrTemplateBlobLeads.Count);

            for (int p = 0; p < m_arrTemplateBlobLeads.Count; p++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[p];

                objFile.WriteElement1Value("Lead" + p.ToString(), "");
                objFile.WriteElement2Value("MaxOffset", m_stcBlobLead.fOffSet);
                objFile.WriteElement2Value("MaxSkew", m_stcBlobLead.fSkew);
                objFile.WriteElement2Value("MinWidth", m_stcBlobLead.fMinTipWidth);
                objFile.WriteElement2Value("MaxWidth", m_stcBlobLead.fMaxTipWidth);
                objFile.WriteElement2Value("MinHeight", m_stcBlobLead.fMinTipHeight);
                objFile.WriteElement2Value("MaxHeight", m_stcBlobLead.fMaxTipHeight);
                objFile.WriteElement2Value("MinPitch", m_stcBlobLead.fMinPitch);
                objFile.WriteElement2Value("MaxPitch", m_stcBlobLead.fMaxPitch);
                objFile.WriteElement2Value("MinGap", m_stcBlobLead.fMinGap);
                objFile.WriteElement2Value("MaxGap", m_stcBlobLead.fMaxGap);
                objFile.WriteElement2Value("MaxVariance", m_stcBlobLead.fVariance);
                objFile.WriteElement2Value("MinAGV", m_stcBlobLead.fMinAGV);
                objFile.WriteElement2Value("MaxAGV", m_stcBlobLead.fMaxAGV);
                objFile.WriteElement2Value("LengthMode", m_stcBlobLead.intLengthMode);
            }


            objFile.WriteEndElement();
        }

        public void LoadLeadToleranceFromFile(string strFilePath, string strSectionName)
        {
            XmlParser objFile = new XmlParser(strFilePath);

            objFile.GetFirstSection(strSectionName);

            m_fTemplateLeadMinSpanLimit = objFile.GetValueAsFloat("LeadMinSpanLimit", 3f, 1);
            m_fTemplateLeadMaxSpanLimit = objFile.GetValueAsFloat("LeadMaxSpanLimit", 4f, 1);

            int intTotalLeads = objFile.GetValueAsInt("TotalLeads", 0, 1);

            if (m_arrTemplateBlobLeads.Count == intTotalLeads)
            {
                for (int p = 0; p < intTotalLeads; p++)
                {
                    m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[p];

                    objFile.GetSecondSection("Lead" + p.ToString());
                    m_stcBlobLead.fOffSet = objFile.GetValueAsFloat("MaxOffset", 0, 2);
                    m_stcBlobLead.fSkew = objFile.GetValueAsFloat("MaxSkew", 0, 2);
                    m_stcBlobLead.fMinWidth = objFile.GetValueAsFloat("MinWidth", 0, 2);
                    m_stcBlobLead.fMaxWidth = objFile.GetValueAsFloat("MaxWidth", 0, 2);
                    m_stcBlobLead.fMinHeight = objFile.GetValueAsFloat("MinHeight", 0, 2);
                    m_stcBlobLead.fMaxHeight = objFile.GetValueAsFloat("MaxHeight", 0, 2);
                    m_stcBlobLead.fMinPitch = objFile.GetValueAsFloat("MinPitch", 0, 2);
                    m_stcBlobLead.fMaxPitch = objFile.GetValueAsFloat("MaxPitch", 0, 2);
                    m_stcBlobLead.fMinGap = objFile.GetValueAsFloat("MinGap", 0, 2);
                    m_stcBlobLead.fMaxGap = objFile.GetValueAsFloat("MaxGap", 0, 2);
                    m_stcBlobLead.fVariance = objFile.GetValueAsFloat("MaxVariance", 0, 2);
                    m_stcBlobLead.fMinAGV = objFile.GetValueAsFloat("MinAGV", 0, 2);
                    m_stcBlobLead.fMaxAGV = objFile.GetValueAsFloat("MaxAGV", 0, 2);
                    m_stcBlobLead.intLengthMode = objFile.GetValueAsInt("LengthMode", 0, 2);

                    m_arrTemplateBlobLeads[p] = m_stcBlobLead;
                }
            }
        }
        public List<List<string>> GetDefectList()
        {

            List<List<string>> arrDefectList = new List<List<string>>();

            int intCount = 0;
            if (m_arrExtraBlobs == null)
                return arrDefectList;
            //Join, extra, contamination
            for (int i = 0; i < m_arrExtraBlobs.Count; i++)
            {
                arrDefectList.Add(new List<string>());
                arrDefectList[intCount].Add(m_arrExtraBlobs[i].ref_intFailCriteria.ToString());
                if (m_arrExtraBlobs[i].ref_fWidthFailValue == -999 && m_arrExtraBlobs[i].ref_fHeightFailValue == -999)
                    arrDefectList[intCount].Add("Total Contamination");
                else
                    arrDefectList[intCount].Add("Contamination");
                arrDefectList[intCount].Add(m_arrExtraBlobs[i].ref_fWidthFailValue.ToString("F4"));
                arrDefectList[intCount].Add(m_arrExtraBlobs[i].ref_fHeightFailValue.ToString("F4"));
                arrDefectList[intCount].Add(m_arrExtraBlobs[i].ref_fAreaFailValue.ToString("F6"));
                intCount++;
            }

            ////Broken, scratch
            //for (int i = 0; i < m_arrPadDefectList.Count; i++)
            //{
            //    arrDefectList.Add(new List<string>());
            //    arrDefectList[intCount].Add(m_arrPadDefectList[i].ref_intFailCriteria.ToString());
            //    arrDefectList[intCount].Add(m_arrPadDefectList[i].ref_strName);
            //    arrDefectList[intCount].Add(m_arrPadDefectList[i].ref_fWidthInMM.ToString("F4"));
            //    arrDefectList[intCount].Add(m_arrPadDefectList[i].ref_fHeightInMM.ToString("F4"));
            //    arrDefectList[intCount].Add(m_arrPadDefectList[i].ref_fAreaInMM2.ToString("F6"));
            //    intCount++;
            //}

            return arrDefectList;
        }

        public void SetBaseInwardOffset(int LeadID, int OffsetValue)
        {
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                BlobsFeatures stcTemporaryBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                if (m_arrBackupTemplateBlobLeads.Count > 0 && i < m_arrBackupTemplateBlobLeads.Count)
                    m_stcBackupTemplateBlobLead = (ToleranceBlobsFeatures)m_arrBackupTemplateBlobLeads[i];
                if (m_arrTemporaryBlobLeads.Count > 0)
                    stcTemporaryBlobLead = (BlobsFeatures)m_arrTemporaryBlobLeads[i];
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                if (m_stcBlobLead.intNoID == LeadID + 1)
                {
                    stcTemporaryBlobLead.intBaseInwardOffset = OffsetValue;
                    m_stcBackupTemplateBlobLead.intBaseInwardOffset = OffsetValue;
                    m_stcBlobLead.intBaseInwardOffset = OffsetValue;
                    m_arrTemplateBlobLeads.RemoveAt(i);
                    m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
                    if (m_arrBackupTemplateBlobLeads.Count > 0 && i < m_arrBackupTemplateBlobLeads.Count)
                    {
                        m_arrBackupTemplateBlobLeads.RemoveAt(i);
                        m_arrBackupTemplateBlobLeads.Insert(i, m_stcBackupTemplateBlobLead);
                    }
                    if (m_arrTemporaryBlobLeads.Count > 0)
                    {
                        m_arrTemporaryBlobLeads.RemoveAt(i);
                        m_arrTemporaryBlobLeads.Insert(i, stcTemporaryBlobLead);
                    }
                }
            }
        }

        public void SetTipInwardOffset(int LeadID, int OffsetValue)
        {
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                BlobsFeatures stcTemporaryBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                if (m_arrBackupTemplateBlobLeads.Count > 0 && i < m_arrBackupTemplateBlobLeads.Count)
                    m_stcBackupTemplateBlobLead = (ToleranceBlobsFeatures)m_arrBackupTemplateBlobLeads[i];
                if (m_arrTemporaryBlobLeads.Count > 0)
                    stcTemporaryBlobLead = (BlobsFeatures)m_arrTemporaryBlobLeads[i];
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];
                if (m_stcBlobLead.intNoID == LeadID + 1)
                {
                    stcTemporaryBlobLead.intBaseInwardOffset = OffsetValue;
                    m_stcBackupTemplateBlobLead.intTipInwardOffset = OffsetValue;
                    m_stcBlobLead.intTipInwardOffset = OffsetValue;
                    m_arrTemplateBlobLeads.RemoveAt(i);
                    m_arrTemplateBlobLeads.Insert(i, m_stcBlobLead);
                    if (m_arrBackupTemplateBlobLeads.Count > 0 && i < m_arrBackupTemplateBlobLeads.Count)
                    {
                        m_arrBackupTemplateBlobLeads.RemoveAt(i);
                        m_arrBackupTemplateBlobLeads.Insert(i, m_stcBackupTemplateBlobLead);
                    }
                    if (m_arrTemporaryBlobLeads.Count > 0)
                    {
                        m_arrTemporaryBlobLeads.RemoveAt(i);
                        m_arrTemporaryBlobLeads.Insert(i, stcTemporaryBlobLead);
                    }
                }
            }
        }

        public int GetBaseInwardOffset(int LeadID)
        {
            int OffsetValue = -1;
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                if (m_stcBlobLead.intNoID != LeadID + 1)
                    continue;

                return m_stcBlobLead.intBaseInwardOffset;
            }
            return OffsetValue;
        }

        public int GetTipInwardOffset(int LeadID)
        {
            int OffsetValue = -1;
            for (int i = 0; i < m_arrTemplateBlobLeads.Count; i++)
            {
                m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[i];

                if (m_stcBlobLead.intNoID != LeadID + 1)
                    continue;

                return m_stcBlobLead.intTipInwardOffset;
            }
            return OffsetValue;
        }

        public void RestoreInwardOffsetFromTempBlob()
        {
            if (m_arrTemporaryBlobLeads.Count != m_arrTemporaryBlobLeads.Count)
                return;

            BlobsFeatures stcBlobLead;
            BlobsFeatures stcTemporaryBlobLead;
            for (int i = 0; i < m_arrTemporaryBlobLeads.Count; i++)
            {
                stcBlobLead = new BlobsFeatures();
                stcTemporaryBlobLead = (BlobsFeatures)m_arrTemporaryBlobLeads[i];

                stcBlobLead.intBaseInwardOffset = stcTemporaryBlobLead.intBaseInwardOffset;
                stcBlobLead.intTipInwardOffset = stcTemporaryBlobLead.intTipInwardOffset;
            }
        }

        public void CopySettingToSettingPointGauge()
        {
            m_objSettingPointGauge.ref_objPointGauge.SetCenterXY(m_objPointGauge.ref_objPointGauge.CenterX, m_objPointGauge.ref_objPointGauge.CenterY);
            m_objSettingPointGauge.ref_objPointGauge.MinAmplitude = m_objPointGauge.ref_objPointGauge.MinAmplitude;
            m_objSettingPointGauge.ref_objPointGauge.MinArea = m_objPointGauge.ref_objPointGauge.MinArea;
            m_objSettingPointGauge.ref_objPointGauge.Smoothing = m_objPointGauge.ref_objPointGauge.Smoothing;
            m_objSettingPointGauge.ref_objPointGauge.Thickness = m_objPointGauge.ref_objPointGauge.Thickness;
            m_objSettingPointGauge.ref_objPointGauge.Threshold = m_objPointGauge.ref_objPointGauge.Threshold;
            m_objSettingPointGauge.ref_objPointGauge.TransitionType = m_objPointGauge.ref_objPointGauge.TransitionType;
            m_objSettingPointGauge.ref_objPointGauge.TransitionChoice = m_objPointGauge.ref_objPointGauge.TransitionChoice;
            m_objSettingPointGauge.ref_objPointGauge.Tolerance = m_objPointGauge.ref_objPointGauge.Tolerance;
            m_objSettingPointGauge.ref_objPointGauge.Angle = m_objPointGauge.ref_objPointGauge.Angle;

            for (int i = 0; i < m_arrPointGauge.Count; i++)
            {
                if (i >= m_arrSettingPointGauge.Count)
                {
                    m_arrSettingPointGauge.Add(new List<PGauge>());
                }

                for (int j = 0; j < m_arrPointGauge[i].Count; j++)
                {
                    if (j >= m_arrSettingPointGauge[i].Count)
                    {
                        m_arrSettingPointGauge[i].Add(new PGauge());
                    }

                    m_arrSettingPointGauge[i][j].ref_objPointGauge.SetCenterXY(m_arrPointGauge[i][j].ref_objPointGauge.CenterX, m_arrPointGauge[i][j].ref_objPointGauge.CenterY);
                    m_arrSettingPointGauge[i][j].ref_objPointGauge.MinAmplitude = m_arrPointGauge[i][j].ref_objPointGauge.MinAmplitude;
                    m_arrSettingPointGauge[i][j].ref_objPointGauge.MinArea = m_arrPointGauge[i][j].ref_objPointGauge.MinArea;
                    m_arrSettingPointGauge[i][j].ref_objPointGauge.Smoothing = m_arrPointGauge[i][j].ref_objPointGauge.Smoothing;
                    m_arrSettingPointGauge[i][j].ref_objPointGauge.Thickness = m_arrPointGauge[i][j].ref_objPointGauge.Thickness;
                    m_arrSettingPointGauge[i][j].ref_objPointGauge.Threshold = m_arrPointGauge[i][j].ref_objPointGauge.Threshold;
                    m_arrSettingPointGauge[i][j].ref_objPointGauge.TransitionType = m_arrPointGauge[i][j].ref_objPointGauge.TransitionType;
                    m_arrSettingPointGauge[i][j].ref_objPointGauge.TransitionChoice = m_arrPointGauge[i][j].ref_objPointGauge.TransitionChoice;
                    m_arrSettingPointGauge[i][j].ref_objPointGauge.Tolerance = m_arrPointGauge[i][j].ref_objPointGauge.Tolerance;
                    m_arrSettingPointGauge[i][j].ref_objPointGauge.Angle = m_arrPointGauge[i][j].ref_objPointGauge.Angle;
                }
            }

        }

        public void CopySettingToSettingPointGauge(int intLeadIndex, int intDirectionIndex)
        {
            if (intLeadIndex >= m_arrPointGauge.Count)
                return;

            if (intDirectionIndex >= m_arrPointGauge[intLeadIndex].Count)
                return;

            m_objSettingPointGauge.ref_objPointGauge.SetCenterXY(m_arrPointGauge[intLeadIndex][intDirectionIndex].ref_objPointGauge.CenterX, m_arrPointGauge[intLeadIndex][intDirectionIndex].ref_objPointGauge.CenterY);
            m_objSettingPointGauge.ref_objPointGauge.MinAmplitude = m_arrPointGauge[intLeadIndex][intDirectionIndex].ref_objPointGauge.MinAmplitude;
            m_objSettingPointGauge.ref_objPointGauge.MinArea = m_arrPointGauge[intLeadIndex][intDirectionIndex].ref_objPointGauge.MinArea;
            m_objSettingPointGauge.ref_objPointGauge.Smoothing = m_arrPointGauge[intLeadIndex][intDirectionIndex].ref_objPointGauge.Smoothing;
            m_objSettingPointGauge.ref_objPointGauge.Thickness = m_arrPointGauge[intLeadIndex][intDirectionIndex].ref_objPointGauge.Thickness;
            m_objSettingPointGauge.ref_objPointGauge.Threshold = m_arrPointGauge[intLeadIndex][intDirectionIndex].ref_objPointGauge.Threshold;
            m_objSettingPointGauge.ref_objPointGauge.TransitionType = m_arrPointGauge[intLeadIndex][intDirectionIndex].ref_objPointGauge.TransitionType;
            m_objSettingPointGauge.ref_objPointGauge.TransitionChoice = m_arrPointGauge[intLeadIndex][intDirectionIndex].ref_objPointGauge.TransitionChoice;
            m_objSettingPointGauge.ref_objPointGauge.Tolerance = m_arrPointGauge[intLeadIndex][intDirectionIndex].ref_objPointGauge.Tolerance;
            m_objSettingPointGauge.ref_objPointGauge.Angle = m_arrPointGauge[intLeadIndex][intDirectionIndex].ref_objPointGauge.Angle;
        }

        public void SetPointGaugePlacement_UsingInspectedLeadPointGaugePosition(int intLeadIndex, int intDirectionIndex)
        {
            //intDirectionIndex:
            //    TipStart = 0
            //    TipCenter = 1
            //    TipEnd = 2
            //    BaseStart = 3
            //    BaseCenter = 4
            //    BaseEnd = 5
            // 2020 11 12 - CCENG: change point index to 
            // BaseCenter = 0
            // BaseStart = 1
            // BaseEnd = 2
            // Tip Center = 3
            // Tip Start = 4
            // Tip End = 5     


            if (intLeadIndex < 0)
                return;

            if (intLeadIndex >= m_arrLeadPointGaugeStartX.Count)
                return;

            if (intDirectionIndex >= m_arrLeadPointGaugeStartX[intLeadIndex].Count)
                return;

            m_objSettingPointGauge.SetGaugePlacement(m_arrLeadPointGaugeStartX[intLeadIndex][intDirectionIndex],
                m_arrLeadPointGaugeStartY[intLeadIndex][intDirectionIndex],
                m_arrLeadPointGaugeTolerance[intLeadIndex][intDirectionIndex],
                m_arrLeadPointGaugeAngle[intLeadIndex][intDirectionIndex]
                );

        }

        public void DrawPointGauge_AllLeadsPoint(Graphics g, float fScaleX, float fScaleY, 
            bool blnSetToAllROIs, bool blnSetToAllLeads, bool blnSetToAllPoints, 
            int intSelectedROIIndex, int intSelectedLeadIndex, int intSelectedPointIndex)
        {
            //For m_arrLead3DEdgeGaugePoints second array
            //    BaseCenter = 0
            //    BaseStart = 1
            //    BaseEnd = 2
            //    TipCenter = 3
            //    TipStart = 4
            //    TipEnd = 5
            try
            {
                for (int i = 0; i < m_arrLeadEdgeGaugePoints.Count; i++)
                {
                    if (m_arrLeadEdgeGaugePoints[i].Count > 0)
                    {
                        switch (m_arrLeadEdgeGaugePointsPosition[i])
                        {
                            case 1: // Top
                                g.DrawString(m_arrLeadEdgeGaugePointsIDNo[i].ToString(), m_Font, new SolidBrush(Color.Red),
                                            m_arrLeadEdgeGaugePoints[i][3].X * fScaleX,
                                            m_arrLeadEdgeGaugePoints[i][3].Y * fScaleY - 15);
                                break;
                            case 2: // Right
                                g.DrawString(m_arrLeadEdgeGaugePointsIDNo[i].ToString(), m_Font, new SolidBrush(Color.Red),
                                            m_arrLeadEdgeGaugePoints[i][3].X * fScaleX + 5,
                                            m_arrLeadEdgeGaugePoints[i][3].Y * fScaleY);
                                break;
                            case 3: // Bottom
                                g.DrawString(m_arrLeadEdgeGaugePointsIDNo[i].ToString(), m_Font, new SolidBrush(Color.Red),
                                            m_arrLeadEdgeGaugePoints[i][3].X * fScaleX,
                                            m_arrLeadEdgeGaugePoints[i][3].Y * fScaleY + 5);
                                break;
                            case 4: // Left
                                g.DrawString(m_arrLeadEdgeGaugePointsIDNo[i].ToString(), m_Font, new SolidBrush(Color.Red),
                                            m_arrLeadEdgeGaugePoints[i][3].X * fScaleX - 15,
                                            m_arrLeadEdgeGaugePoints[i][3].Y * fScaleY);
                                break;
                        }
                    }

                    if (blnSetToAllROIs || (!blnSetToAllROIs && intSelectedROIIndex == m_intLeadROIDirection))
                    {
                        if (blnSetToAllLeads || (!blnSetToAllLeads && i == intSelectedLeadIndex))
                        {


                            for (int j = 0; j < m_arrLeadEdgeGaugePoints[i].Count; j++)
                            {
                                if (blnSetToAllPoints || (!blnSetToAllPoints && j == intSelectedPointIndex))
                                {
                                    if (m_arrLeadEdgeGaugePointsFound[i][j])
                                    {
                                        g.DrawLine(new Pen(Color.Lime, 2f), m_arrLeadEdgeGaugePoints[i][j].X * fScaleX - 5,
                                                                        m_arrLeadEdgeGaugePoints[i][j].Y * fScaleY,
                                                                        m_arrLeadEdgeGaugePoints[i][j].X * fScaleX + 5,
                                                                        m_arrLeadEdgeGaugePoints[i][j].Y * fScaleY);

                                        g.DrawLine(new Pen(Color.Lime, 2f), m_arrLeadEdgeGaugePoints[i][j].X * fScaleX,
                                                                        m_arrLeadEdgeGaugePoints[i][j].Y * fScaleY - 5,
                                                                        m_arrLeadEdgeGaugePoints[i][j].X * fScaleX,
                                                                        m_arrLeadEdgeGaugePoints[i][j].Y * fScaleY + 5);
                                    }
                                    else
                                    {
                                        g.DrawLine(new Pen(Color.Red, 2f), m_arrLeadEdgeGaugePoints[i][j].X * fScaleX - 5,
                                                                          m_arrLeadEdgeGaugePoints[i][j].Y * fScaleY,
                                                                          m_arrLeadEdgeGaugePoints[i][j].X * fScaleX + 5,
                                                                          m_arrLeadEdgeGaugePoints[i][j].Y * fScaleY);

                                        g.DrawLine(new Pen(Color.Red, 2f), m_arrLeadEdgeGaugePoints[i][j].X * fScaleX,
                                                                        m_arrLeadEdgeGaugePoints[i][j].Y * fScaleY - 5,
                                                                        m_arrLeadEdgeGaugePoints[i][j].X * fScaleX,
                                                                        m_arrLeadEdgeGaugePoints[i][j].Y * fScaleY + 5);
                                    }
                                }
                            }
                        }
                    }
                    
                }


                m_objSettingPointGauge.DrawGauge(g);

            }
            catch
            {

            }
        }

        private void AddPointGaugePlacementToArray(float fCenterX, float fCenterY, float fTolerance, float fAngle, int LeadIndex)
        {
            //    TipStart = 0
            //    TipCenter = 1
            //    TipEnd = 2
            //    BaseStart = 3
            //    BaseCenter = 4
            //    BaseEnd = 5
            // 2020 11 12 - CCENG: change point index to 
            // BaseCenter = 0
            // BaseStart = 1
            // BaseEnd = 2
            // Tip Center = 3
            // Tip Start = 4
            // Tip End = 5     

            //m_arrLeadPointGaugeStartX.Add(new List<float>());
            m_arrLeadPointGaugeStartX[LeadIndex].Add(fCenterX);
            m_arrLeadPointGaugeStartX[LeadIndex].Add(-1); // .Count-1
            m_arrLeadPointGaugeStartX[LeadIndex].Add(-1);
            m_arrLeadPointGaugeStartX[LeadIndex].Add(-1);
            m_arrLeadPointGaugeStartX[LeadIndex].Add(-1);
            m_arrLeadPointGaugeStartX[LeadIndex].Add(-1);

            //m_arrLeadPointGaugeStartY.Add(new List<float>());
            m_arrLeadPointGaugeStartY[LeadIndex].Add(fCenterY);
            m_arrLeadPointGaugeStartY[LeadIndex].Add(-1);
            m_arrLeadPointGaugeStartY[LeadIndex].Add(-1);
            m_arrLeadPointGaugeStartY[LeadIndex].Add(-1);
            m_arrLeadPointGaugeStartY[LeadIndex].Add(-1);
            m_arrLeadPointGaugeStartY[LeadIndex].Add(-1);

            //m_arrLeadPointGaugeTolerance.Add(new List<float>());
            m_arrLeadPointGaugeTolerance[LeadIndex].Add(fTolerance);
            m_arrLeadPointGaugeTolerance[LeadIndex].Add(-1);
            m_arrLeadPointGaugeTolerance[LeadIndex].Add(-1);
            m_arrLeadPointGaugeTolerance[LeadIndex].Add(-1);
            m_arrLeadPointGaugeTolerance[LeadIndex].Add(-1);
            m_arrLeadPointGaugeTolerance[LeadIndex].Add(-1);

            //m_arrLeadPointGaugeAngle.Add(new List<float>());
            m_arrLeadPointGaugeAngle[LeadIndex].Add(fAngle);
            m_arrLeadPointGaugeAngle[LeadIndex].Add(-1);
            m_arrLeadPointGaugeAngle[LeadIndex].Add(-1);
            m_arrLeadPointGaugeAngle[LeadIndex].Add(-1);
            m_arrLeadPointGaugeAngle[LeadIndex].Add(-1);
            m_arrLeadPointGaugeAngle[LeadIndex].Add(-1);
        }

        private void SetPointGaugePlacementToArray(float fCenterX, float fCenterY, float fTolerance, float fAngle, int intPosition, int LeadIndex)
        {
            //    TipStart = 0
            //    TipCenter = 1
            //    TipEnd = 2
            //    BaseStart = 3
            //    BaseCenter = 4
            //    BaseEnd = 5
            // 2020 11 12 - CCENG: change point index to 
            // BaseCenter = 0
            // BaseStart = 1
            // BaseEnd = 2
            // Tip Center = 3
            // Tip Start = 4
            // Tip End = 5     

            m_arrLeadPointGaugeStartX[LeadIndex][intPosition] = fCenterX;
            m_arrLeadPointGaugeStartY[LeadIndex][intPosition] = fCenterY;
            m_arrLeadPointGaugeTolerance[LeadIndex][intPosition] = fTolerance;
            m_arrLeadPointGaugeAngle[LeadIndex][intPosition] = fAngle;
        }
        private void AddPointGaugePlacementToArray_Inspection(float fCenterX, float fCenterY, float fTolerance, float fAngle, int LeadIndex)
        {
            //    TipStart = 0
            //    TipCenter = 1
            //    TipEnd = 2
            //    BaseStart = 3
            //    BaseCenter = 4
            //    BaseEnd = 5
            // 2020 11 12 - CCENG: change point index to 
            // BaseCenter = 0
            // BaseStart = 1
            // BaseEnd = 2
            // Tip Center = 3
            // Tip Start = 4
            // Tip End = 5     

            m_arrLeadPointGaugeStartX[LeadIndex].Add(fCenterX);
            m_arrLeadPointGaugeStartX[LeadIndex].Add(-1);
            m_arrLeadPointGaugeStartX[LeadIndex].Add(-1);
            m_arrLeadPointGaugeStartX[LeadIndex].Add(-1);
            m_arrLeadPointGaugeStartX[LeadIndex].Add(-1);
            m_arrLeadPointGaugeStartX[LeadIndex].Add(-1);

            m_arrLeadPointGaugeStartY[LeadIndex].Add(fCenterY);
            m_arrLeadPointGaugeStartY[LeadIndex].Add(-1);
            m_arrLeadPointGaugeStartY[LeadIndex].Add(-1);
            m_arrLeadPointGaugeStartY[LeadIndex].Add(-1);
            m_arrLeadPointGaugeStartY[LeadIndex].Add(-1);
            m_arrLeadPointGaugeStartY[LeadIndex].Add(-1);

            m_arrLeadPointGaugeTolerance[LeadIndex].Add(fTolerance);
            m_arrLeadPointGaugeTolerance[LeadIndex].Add(-1);
            m_arrLeadPointGaugeTolerance[LeadIndex].Add(-1);
            m_arrLeadPointGaugeTolerance[LeadIndex].Add(-1);
            m_arrLeadPointGaugeTolerance[LeadIndex].Add(-1);
            m_arrLeadPointGaugeTolerance[LeadIndex].Add(-1);

            m_arrLeadPointGaugeAngle[LeadIndex].Add(fAngle);
            m_arrLeadPointGaugeAngle[LeadIndex].Add(-1);
            m_arrLeadPointGaugeAngle[LeadIndex].Add(-1);
            m_arrLeadPointGaugeAngle[LeadIndex].Add(-1);
            m_arrLeadPointGaugeAngle[LeadIndex].Add(-1);
            m_arrLeadPointGaugeAngle[LeadIndex].Add(-1);
        }

        private void SetPointGaugePlacementToArray_Inspection(float fCenterX, float fCenterY, float fTolerance, float fAngle, int intPosition, int LeadIndex)
        {
            //    TipStart = 0
            //    TipCenter = 1
            //    TipEnd = 2
            //    BaseStart = 3
            //    BaseCenter = 4
            //    BaseEnd = 5
            // 2020 11 12 - CCENG: change point index to 
            // BaseCenter = 0
            // BaseStart = 1
            // BaseEnd = 2
            // Tip Center = 3
            // Tip Start = 4
            // Tip End = 5     

            m_arrLeadPointGaugeStartX[LeadIndex][intPosition] = fCenterX;
            m_arrLeadPointGaugeStartY[LeadIndex][intPosition] = fCenterY;
            m_arrLeadPointGaugeTolerance[LeadIndex][intPosition] = fTolerance;
            m_arrLeadPointGaugeAngle[LeadIndex][intPosition] = fAngle;
        }

        public void AssignLineGaugeDataFromPackageGaugeM4L(float CenterX, float CenterY, float Width, float Height, float Angle)
        {
            m_fCenterX_PackageGaugeM4L = CenterX;
            m_fCenterY_PackageGaugeM4L = CenterY;
            m_fWidth_PackageGaugeM4L = Width;
            m_fHeight_PackageGaugeM4L = Height;
            m_fAngle_PackageGaugeM4L = Angle;
        }

        public void GetAGVROIToleranceValue(int intLeadID, ref int intTolTop, ref int intTolRight, ref int intTolBottom, ref int intTolLeft)
        {
            if (intLeadID > m_arrTemplateBlobLeads.Count)
                return;

            m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[intLeadID];

            intTolTop = m_stcBlobLead.intAGVROITolerance_Top;
            intTolRight = m_stcBlobLead.intAGVROITolerance_Right;
            intTolBottom = m_stcBlobLead.intAGVROITolerance_Bottom;
            intTolLeft = m_stcBlobLead.intAGVROITolerance_Left;

        }
        public void SetAGVROIToleranceValue(int intLeadID, int intDirection, int intTolValue)
        {
            if (intLeadID > m_arrTemplateBlobLeads.Count)
                return;
            BlobsFeatures stcBlobsFeatures = new BlobsFeatures();
            m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[intLeadID];

            switch (intDirection)
            {
                case 1:
                    m_stcBlobLead.intAGVROITolerance_Top = intTolValue;
                    break;
                case 2:
                    m_stcBlobLead.intAGVROITolerance_Right = intTolValue;
                    break;
                case 3:
                    m_stcBlobLead.intAGVROITolerance_Bottom = intTolValue;
                    break;
                case 4:
                    m_stcBlobLead.intAGVROITolerance_Left = intTolValue;
                    break;
            }
            stcBlobsFeatures = m_stcBlobLead;
            m_arrTemplateBlobLeads[intLeadID] = stcBlobsFeatures;

        }
        public int GetSampleLeadTipWidth(int intLeadIndex)
        {
            if (m_arrSampleBlobLeads.Length > intLeadIndex)
                return Convert.ToInt32(((SampleBlobsFeatures)m_arrSampleBlobLeads[intLeadIndex]).fTipWidth);
            else
                return 0;
        }
        public int GetSampleLeadTipLength(int intLeadIndex)
        {
            if (m_arrSampleBlobLeads.Length > intLeadIndex)
                return Convert.ToInt32(((SampleBlobsFeatures)m_arrSampleBlobLeads[intLeadIndex]).fTipHeight);
            else
                return 0;
        }
        public void DrawAGVROITolerance(Graphics g, float fScaleX, float fScaleY, int intLeadIndex, int intROIX, int intROIY, Color objColor)
        {
            if (m_arrSampleBlobLeads == null)
                return;

            if (intLeadIndex >= m_arrSampleBlobLeads.Length)
                return;
            float fStartX = 0, fStartY = 0, fWidth = 0, fHeight = 0;

            SampleBlobsFeatures m_stcSampleBlobLead = (SampleBlobsFeatures)m_arrSampleBlobLeads[intLeadIndex];
            m_stcBlobLead = (BlobsFeatures)m_arrTemplateBlobLeads[intLeadIndex];
            switch (m_intLeadROIDirection)
            {
                case 1: // Top
                    fStartX = (intROIX + m_stcSampleBlobLead.fTipCenterX - (m_stcSampleBlobLead.fTipWidth / 2) + m_stcBlobLead.intAGVROITolerance_Left) * fScaleX;
                    fStartY = (intROIY + m_stcSampleBlobLead.fTipCenterY + m_stcBlobLead.intAGVROITolerance_Top) * fScaleY;
                    fWidth = (m_stcSampleBlobLead.fTipWidth - m_stcBlobLead.intAGVROITolerance_Left - m_stcBlobLead.intAGVROITolerance_Right) * fScaleX;
                    fHeight = (m_stcSampleBlobLead.fTipHeight - m_stcBlobLead.intAGVROITolerance_Top - m_stcBlobLead.intAGVROITolerance_Bottom) * fScaleY;
                    break;
                case 3: // Bottom
                    fStartX = (intROIX + m_stcSampleBlobLead.fTipCenterX - (m_stcSampleBlobLead.fTipWidth / 2) + m_stcBlobLead.intAGVROITolerance_Left) * fScaleX;
                    fStartY = (intROIY + m_stcSampleBlobLead.fTipCenterY - m_stcSampleBlobLead.fTipHeight + m_stcBlobLead.intAGVROITolerance_Top) * fScaleY;
                    fWidth = (m_stcSampleBlobLead.fTipWidth - m_stcBlobLead.intAGVROITolerance_Left - m_stcBlobLead.intAGVROITolerance_Right) * fScaleX;
                    fHeight = (m_stcSampleBlobLead.fTipHeight - m_stcBlobLead.intAGVROITolerance_Top - m_stcBlobLead.intAGVROITolerance_Bottom) * fScaleY;
                    break;
                case 4: // Left
                    fStartX = (intROIX + m_stcSampleBlobLead.fTipCenterX + m_stcBlobLead.intAGVROITolerance_Left) * fScaleX;
                    fStartY = (intROIY + m_stcSampleBlobLead.fTipCenterY - (m_stcSampleBlobLead.fTipWidth / 2) + m_stcBlobLead.intAGVROITolerance_Top) * fScaleY;
                    fWidth = (m_stcSampleBlobLead.fTipHeight - m_stcBlobLead.intAGVROITolerance_Left - m_stcBlobLead.intAGVROITolerance_Right) * fScaleX;
                    fHeight = (m_stcSampleBlobLead.fTipWidth - m_stcBlobLead.intAGVROITolerance_Top - m_stcBlobLead.intAGVROITolerance_Bottom) * fScaleY;
                    break;
                case 2: // Right
                    fStartX = (intROIX + m_stcSampleBlobLead.fTipCenterX - m_stcSampleBlobLead.fTipHeight + m_stcBlobLead.intAGVROITolerance_Left) * fScaleX;
                    fStartY = (intROIY + m_stcSampleBlobLead.fTipCenterY - (m_stcSampleBlobLead.fTipWidth / 2) + m_stcBlobLead.intAGVROITolerance_Top) * fScaleY;
                    fWidth = (m_stcSampleBlobLead.fTipHeight - m_stcBlobLead.intAGVROITolerance_Left - m_stcBlobLead.intAGVROITolerance_Right) * fScaleX;
                    fHeight = (m_stcSampleBlobLead.fTipWidth - m_stcBlobLead.intAGVROITolerance_Top - m_stcBlobLead.intAGVROITolerance_Bottom) * fScaleY;
                    break;
            }
            g.DrawRectangle(new Pen(objColor, 1), fStartX, fStartY, fWidth, fHeight);
        }
        
        public void DrawAutoMaskingPocketObject(Graphics g, float fScaleX, float fScaleY, int intROIX, int intROIY, List<List<ROI>> arrROIs)
        {
            if (m_objAutoPocketMatcher.NumPositions > 0)
            {
                if (arrROIs.Count > 0)
                {
                    if (arrROIs[0].Count > 0)
                    {
                        arrROIs[0][0].DrawROI(g, fScaleX, fScaleY, false, 0);
                    }
                }
                if (m_objAutoPocketMatcher.GetPosition(0).Score > 0.5)
                {
                    g.DrawRectangle(new Pen(Color.Yellow, 1), (intROIX + m_objAutoPocketMatcher.GetPosition(0).CenterX - (m_objAutoPocketMatcher.PatternWidth / 2)) * fScaleX,
                          (intROIY + m_objAutoPocketMatcher.GetPosition(0).CenterY - (m_objAutoPocketMatcher.PatternHeight / 2)) * fScaleY,
                          m_objAutoPocketMatcher.PatternWidth * fScaleX, m_objAutoPocketMatcher.PatternHeight * fScaleY);

                    if (arrROIs[m_intLeadROIDirection].Count > 0)
                    {
                        
                        int m_intWidthLimit = arrROIs[m_intLeadROIDirection][0].ref_ROIWidth;
                        int m_intHeightLimit = arrROIs[m_intLeadROIDirection][0].ref_ROIHeight;
                        int m_intStartX = (int)Math.Round((intROIX + m_objAutoPocketMatcher.GetPosition(0).CenterX - m_fAutoPocketReferenceOffsetX) - (arrROIs[m_intLeadROIDirection][0].ref_ROIWidth / 2));
                        int m_intStartY = (int)Math.Round((intROIY + m_objAutoPocketMatcher.GetPosition(0).CenterY - m_fAutoPocketReferenceOffsetY) - (arrROIs[m_intLeadROIDirection][0].ref_ROIHeight / 2));

                        if (m_intLeadROIDirection == 1)
                        {
                            float intStartY = m_objPocketEdgeGauge.ref_objLine.GetPointY(m_intStartX);
                            float intEndY = m_objPocketEdgeGauge.ref_objLine.GetPointY(m_intStartX + m_intWidthLimit);
                            if (!float.IsNaN(intStartY) && !float.IsInfinity(intStartY) && !float.IsNaN(intEndY) && !float.IsInfinity(intEndY))
                            {
                                g.FillRectangle(new SolidBrush(Color.White), m_intStartX * fScaleX,
                              (int)Math.Round(intStartY + m_intLineOffset) * fScaleY,
                              m_intWidthLimit * fScaleX,
                              m_intMaskThickness * fScaleY);
                            }
                        }
                        else if (m_intLeadROIDirection == 2)
                        {
                            float intStartX = m_objPocketEdgeGauge.ref_objLine.GetPointX(m_intStartY);
                            float intEndX = m_objPocketEdgeGauge.ref_objLine.GetPointX(m_intStartY + m_intHeightLimit);
                            if (!float.IsNaN(intStartX) && !float.IsInfinity(intStartX) && !float.IsNaN(intEndX) && !float.IsInfinity(intEndX))
                            {
                                g.FillRectangle(new SolidBrush(Color.White), (int)Math.Round(intStartX - m_intLineOffset - m_intMaskThickness) * fScaleX,
                              m_intStartY * fScaleY,
                              m_intMaskThickness * fScaleX,
                              m_intHeightLimit * fScaleY);
                            }
                        }
                        else if (m_intLeadROIDirection == 3)
                        {
                            float intStartY = m_objPocketEdgeGauge.ref_objLine.GetPointY(m_intStartX);
                            float intEndY = m_objPocketEdgeGauge.ref_objLine.GetPointY(m_intStartX + m_intWidthLimit);
                            if (!float.IsNaN(intStartY) && !float.IsInfinity(intStartY) && !float.IsNaN(intEndY) && !float.IsInfinity(intEndY))
                            {
                                g.FillRectangle(new SolidBrush(Color.White), m_intStartX * fScaleX,
                              (int)Math.Round(intStartY - m_intLineOffset - m_intMaskThickness) * fScaleY,
                              m_intWidthLimit * fScaleX,
                              m_intMaskThickness * fScaleY);
                            }
                        }
                        else if (m_intLeadROIDirection == 4)
                        {
                            float intStartX = m_objPocketEdgeGauge.ref_objLine.GetPointX(m_intStartY);
                            float intEndX = m_objPocketEdgeGauge.ref_objLine.GetPointX(m_intStartY + m_intHeightLimit);
                            if (!float.IsNaN(intStartX) && !float.IsInfinity(intStartX) && !float.IsNaN(intEndX) && !float.IsInfinity(intEndX))
                            {
                                g.FillRectangle(new SolidBrush(Color.White), (int)Math.Round(intStartX + m_intLineOffset) * fScaleX,
                           m_intStartY * fScaleY,
                           m_intMaskThickness * fScaleX,
                           m_intHeightLimit * fScaleY);
                            }
                        }

                        arrROIs[m_intLeadROIDirection][0].DrawROI(g, fScaleX, fScaleY, false, 6);

                    }
                }
                else
                {
                    g.DrawRectangle(new Pen(Color.Red, 1), (intROIX + m_objAutoPocketMatcher.GetPosition(0).CenterX - (m_objAutoPocketMatcher.PatternWidth / 2)) * fScaleX,
                       (intROIY + m_objAutoPocketMatcher.GetPosition(0).CenterY - (m_objAutoPocketMatcher.PatternHeight / 2)) * fScaleY,
                       m_objAutoPocketMatcher.PatternWidth * fScaleX, m_objAutoPocketMatcher.PatternHeight * fScaleY);
                }
            }
           
        }
        public void DrawManualMaskingPocketObject(Graphics g, float fScaleX, float fScaleY, int intROIX, int intROIY, List<List<ROI>> arrROIs)
        {
            if (m_objManualPocketMatcher.NumPositions > 0)
            {
                if (arrROIs.Count > 0)
                {
                    if (arrROIs[0].Count > 0)
                    {
                        arrROIs[0][0].DrawROI(g, fScaleX, fScaleY, false, 0);
                    }
                }
                if (m_objManualPocketMatcher.GetPosition(0).Score > 0.5)
                {
                    g.DrawRectangle(new Pen(Color.Yellow, 1), (intROIX + m_objManualPocketMatcher.GetPosition(0).CenterX - (m_objManualPocketMatcher.PatternWidth / 2)) * fScaleX,
                          (intROIY + m_objManualPocketMatcher.GetPosition(0).CenterY - (m_objManualPocketMatcher.PatternHeight / 2)) * fScaleY,
                          m_objManualPocketMatcher.PatternWidth * fScaleX, m_objManualPocketMatcher.PatternHeight * fScaleY);

                    if (arrROIs[m_intLeadROIDirection].Count > 0)
                    {

                        int m_intWidthLimit = arrROIs[m_intLeadROIDirection][0].ref_ROIWidth;
                        int m_intHeightLimit = arrROIs[m_intLeadROIDirection][0].ref_ROIHeight;
                        int m_intStartX = (int)Math.Round((intROIX + m_objManualPocketMatcher.GetPosition(0).CenterX - m_fManualPocketReferenceOffsetX) - (arrROIs[m_intLeadROIDirection][0].ref_ROIWidth / 2));
                        int m_intStartY = (int)Math.Round((intROIY + m_objManualPocketMatcher.GetPosition(0).CenterY - m_fManualPocketReferenceOffsetY) - (arrROIs[m_intLeadROIDirection][0].ref_ROIHeight / 2));

                        g.FillRectangle(new SolidBrush(Color.White), m_intStartX * fScaleX,
                              m_intStartY * fScaleY,
                              m_intWidthLimit * fScaleX,
                              m_intHeightLimit * fScaleY);
                      
                        arrROIs[m_intLeadROIDirection][0].DrawROI(g, fScaleX, fScaleY, false, 6);

                    }
                }
                else
                {
                    g.DrawRectangle(new Pen(Color.Red, 1), (intROIX + m_objManualPocketMatcher.GetPosition(0).CenterX - (m_objManualPocketMatcher.PatternWidth / 2)) * fScaleX,
                       (intROIY + m_objManualPocketMatcher.GetPosition(0).CenterY - (m_objManualPocketMatcher.PatternHeight / 2)) * fScaleY,
                       m_objManualPocketMatcher.PatternWidth * fScaleX, m_objManualPocketMatcher.PatternHeight * fScaleY);
                }
            }

        }
        public bool GetWantInspectLead()
        {
            return m_blnInspectLead;
        }
        public void SetWantInspectLead(bool bWantInspectLead)
        {
            m_blnInspectLead = bWantInspectLead;
        }
        public string GetUnitLengthVarianceFailTestDisplayResult()
        {
            string strFailMessage = "";

            if ((m_intFailResultMask & 0x800) > 0)
            {
                if (m_fSampleLengthVarianceMM > m_fTemplateLengthVarianceMaxLimit)
                {
                    strFailMessage += "*Unit Length Variance Fail. Set=" + m_fTemplateLengthVarianceMaxLimit.ToString() + "mm, Result=" + m_fSampleLengthVarianceMM.ToString("F4") + "mm";
                }
            }

            return strFailMessage;
        }

        public void CalculateUnitCenterPointReferingToLeadBaseCenterY(float fTopBaseCenterY, float fBottomBaseCenterY)
        {
            m_fUnitCenterY = (fTopBaseCenterY + fBottomBaseCenterY) / 2;
        }

        public void CalculateUnitCenterPointReferingToLeadBaseCenterX(float fTopBaseCenterX, float fBottomBaseCenterX)
        {
            m_fUnitCenterY = (fTopBaseCenterX + fBottomBaseCenterX) / 2;
        }

        public PointF GetSampleLeadBaseCenterPoint(bool blnFindTop)
        {
            if (m_arrSampleBlobLeads != null && m_arrSampleBlobLeads.Length > 0)
            {
                PointF pTopLeft;
                if (blnFindTop)
                    pTopLeft = new PointF(0, float.MaxValue);
                else
                    pTopLeft = new PointF(float.MaxValue, 0);
                for (int i = 0; i < m_arrSampleBlobLeads.Length; i++)
                {
                    if (blnFindTop)
                    {
                        if (m_arrSampleBlobLeads[i].fBaseCenterY < pTopLeft.Y)
                            pTopLeft = new PointF(m_arrSampleBlobLeads[i].fBaseCenterX, m_arrSampleBlobLeads[i].fBaseCenterY);
                    }
                    else
                    {
                        if (m_arrSampleBlobLeads[i].fBaseCenterX < pTopLeft.X)
                            pTopLeft = new PointF(m_arrSampleBlobLeads[i].fBaseCenterX, m_arrSampleBlobLeads[i].fBaseCenterY);
                    }
                }

                return pTopLeft;
            }
            else
                return new PointF(0, 0);
        }
        public PointF GetSampleLeadBaseCenterPoint_MostInside()
        {
            if (m_arrSampleBlobLeads != null && m_arrSampleBlobLeads.Length > 0)
            {
                PointF pPoint = new PointF(0, 0);

                switch (m_intLeadROIDirection)
                {
                    case 1:
                        pPoint = new PointF(0, float.MinValue);
                        for (int i = 0; i < m_arrSampleBlobLeads.Length; i++)
                        {
                            if (m_arrSampleBlobLeads[i].fBaseCenterY > pPoint.Y)
                                pPoint = new PointF(m_arrSampleBlobLeads[i].fBaseCenterX, m_arrSampleBlobLeads[i].fBaseCenterY);
                        }
                        break;
                    case 2:
                        pPoint = new PointF(float.MinValue, 0);
                        for (int i = 0; i < m_arrSampleBlobLeads.Length; i++)
                        {
                            if (m_arrSampleBlobLeads[i].fBaseCenterX > pPoint.X)
                                pPoint = new PointF(m_arrSampleBlobLeads[i].fBaseCenterX, m_arrSampleBlobLeads[i].fBaseCenterY);
                        }
                        break;
                    case 3:
                        pPoint = new PointF(0, float.MaxValue);
                        for (int i = 0; i < m_arrSampleBlobLeads.Length; i++)
                        {
                            if (m_arrSampleBlobLeads[i].fBaseCenterY < pPoint.Y)
                                pPoint = new PointF(m_arrSampleBlobLeads[i].fBaseCenterX, m_arrSampleBlobLeads[i].fBaseCenterY);
                        }
                        break;
                    case 4:
                        pPoint = new PointF(float.MaxValue, 0);
                        for (int i = 0; i < m_arrSampleBlobLeads.Length; i++)
                        {
                            if (m_arrSampleBlobLeads[i].fBaseCenterX < pPoint.X)
                                pPoint = new PointF(m_arrSampleBlobLeads[i].fBaseCenterX, m_arrSampleBlobLeads[i].fBaseCenterY);
                        }
                        break;
                }


                return pPoint;
            }
            else
                return new PointF(0, 0);
        }
        public void GetSampleLeadArea(int intLeadIndex, ref float fStartX, ref float fStartY, ref float fEndX, ref float fEndY)
        {
            if (intLeadIndex < m_arrSampleBlobLeads.Length)
            {
                if (m_intLeadROIDirection == 1 || m_intLeadROIDirection == 3)
                {
                    fStartX = Math.Min(m_arrSampleBlobLeads[intLeadIndex].fBaseCenterX - m_arrSampleBlobLeads[intLeadIndex].fBaseWidth / 2,
                                       m_arrSampleBlobLeads[intLeadIndex].fTipCenterX - m_arrSampleBlobLeads[intLeadIndex].fTipWidth / 2);

                    fStartY = Math.Min(m_arrSampleBlobLeads[intLeadIndex].fBaseCenterY,
                                       m_arrSampleBlobLeads[intLeadIndex].fTipCenterY);

                    fEndX = Math.Max(m_arrSampleBlobLeads[intLeadIndex].fBaseCenterX + m_arrSampleBlobLeads[intLeadIndex].fBaseWidth / 2,
                                       m_arrSampleBlobLeads[intLeadIndex].fTipCenterX + m_arrSampleBlobLeads[intLeadIndex].fTipWidth / 2);

                    fStartY = Math.Max(m_arrSampleBlobLeads[intLeadIndex].fBaseCenterY,
                                       m_arrSampleBlobLeads[intLeadIndex].fTipCenterY);
                }
                else
                {
                    fStartY = Math.Min(m_arrSampleBlobLeads[intLeadIndex].fBaseCenterY - m_arrSampleBlobLeads[intLeadIndex].fBaseWidth / 2,
                                       m_arrSampleBlobLeads[intLeadIndex].fTipCenterY - m_arrSampleBlobLeads[intLeadIndex].fTipWidth / 2);

                    fStartX = Math.Min(m_arrSampleBlobLeads[intLeadIndex].fBaseCenterX,
                                       m_arrSampleBlobLeads[intLeadIndex].fTipCenterX);

                    fEndY = Math.Max(m_arrSampleBlobLeads[intLeadIndex].fBaseCenterY + m_arrSampleBlobLeads[intLeadIndex].fBaseWidth / 2,
                                       m_arrSampleBlobLeads[intLeadIndex].fTipCenterY + m_arrSampleBlobLeads[intLeadIndex].fTipWidth / 2);

                    fStartX = Math.Max(m_arrSampleBlobLeads[intLeadIndex].fBaseCenterX,
                                       m_arrSampleBlobLeads[intLeadIndex].fTipCenterX);
                }
            }
        }

        public void GetSampleLeadArea(int intLeadIndex, int intROITotalX, int intROITotalY,
                                 float fRotateCenterX, float fRotateCenterY, float fRotateAngle, ref float fStartX, ref float fStartY, ref float fEndX, ref float fEndY, ref int intLeadDirection)
        {
            if (intLeadIndex < m_arrSampleBlobLeads.Length)
            {
                intLeadDirection = m_intLeadROIDirection;

                if (m_intLeadROIDirection == 1 || m_intLeadROIDirection == 3)
                {
                    fStartX = intROITotalX + Math.Min(m_arrSampleBlobLeads[intLeadIndex].fBaseCenterX - m_arrSampleBlobLeads[intLeadIndex].fBaseWidth / 2,
                                       m_arrSampleBlobLeads[intLeadIndex].fTipCenterX - m_arrSampleBlobLeads[intLeadIndex].fTipWidth / 2);

                    fStartY = intROITotalY + Math.Min(m_arrSampleBlobLeads[intLeadIndex].fBaseCenterY,
                                       m_arrSampleBlobLeads[intLeadIndex].fTipCenterY);

                    fEndX = intROITotalX + Math.Max(m_arrSampleBlobLeads[intLeadIndex].fBaseCenterX + m_arrSampleBlobLeads[intLeadIndex].fBaseWidth / 2,
                                       m_arrSampleBlobLeads[intLeadIndex].fTipCenterX + m_arrSampleBlobLeads[intLeadIndex].fTipWidth / 2);

                    fEndY = intROITotalY + Math.Max(m_arrSampleBlobLeads[intLeadIndex].fBaseCenterY,
                                       m_arrSampleBlobLeads[intLeadIndex].fTipCenterY);

                    float fMinX = -1;
                    float fMinY = -1;
                    float fMaxX = -1;
                    float fMaxY = -1;
                    float fX = fStartX;
                    float fY = fStartY;
                    Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY,
                                                                 fStartX, fStartY,
                                                                 -fRotateAngle,
                                                                 ref fX, ref fY);
                    fMinX = fX;
                    fMinY = fY;
                    fMaxX = fX;
                    fMaxY = fY;

                    fX = fEndX;
                    fY = fStartY;
                    Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY,
                                                                 fEndX, fStartY,
                                                                 -fRotateAngle,
                                                                 ref fX, ref fY);
                    if (fMinX > fX)
                        fMinX = fX;
                    if (fMinY > fY)
                        fMinY = fY;
                    if (fMaxX < fX)
                        fMaxX = fX;
                    if (fMaxY < fY)
                        fMaxY = fY;

                    fX = fEndX;
                    fY = fEndY;
                    Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY,
                                                                 fEndX, fEndY,
                                                                 -fRotateAngle,
                                                                 ref fX, ref fY);
                    if (fMinX > fX)
                        fMinX = fX;
                    if (fMinY > fY)
                        fMinY = fY;
                    if (fMaxX < fX)
                        fMaxX = fX;
                    if (fMaxY < fY)
                        fMaxY = fY;

                    fX = fStartX;
                    fY = fEndY;
                    Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY,
                                                                 fStartX, fEndY,
                                                                 -fRotateAngle,
                                                                 ref fX, ref fY);
                    if (fMinX > fX)
                        fMinX = fX;
                    if (fMinY > fY)
                        fMinY = fY;
                    if (fMaxX < fX)
                        fMaxX = fX;
                    if (fMaxY < fY)
                        fMaxY = fY;

                    fStartX = fMinX;
                    fStartY = fMinY;
                    fEndX = fMaxX;
                    fEndY = fMaxY;
                }
                else
                {
                    fStartY = intROITotalY + Math.Min(m_arrSampleBlobLeads[intLeadIndex].fBaseCenterY - m_arrSampleBlobLeads[intLeadIndex].fBaseWidth / 2,
                                       m_arrSampleBlobLeads[intLeadIndex].fTipCenterY - m_arrSampleBlobLeads[intLeadIndex].fTipWidth / 2);

                    fStartX = intROITotalX + Math.Min(m_arrSampleBlobLeads[intLeadIndex].fBaseCenterX,
                                       m_arrSampleBlobLeads[intLeadIndex].fTipCenterX);

                    fEndY = intROITotalY + Math.Max(m_arrSampleBlobLeads[intLeadIndex].fBaseCenterY + m_arrSampleBlobLeads[intLeadIndex].fBaseWidth / 2,
                                       m_arrSampleBlobLeads[intLeadIndex].fTipCenterY + m_arrSampleBlobLeads[intLeadIndex].fTipWidth / 2);

                    fStartX = intROITotalX + Math.Max(m_arrSampleBlobLeads[intLeadIndex].fBaseCenterX,
                                       m_arrSampleBlobLeads[intLeadIndex].fTipCenterX);

                    float fMinX = -1;
                    float fMinY = -1;
                    float fMaxX = -1;
                    float fMaxY = -1;
                    float fX = fStartX;
                    float fY = fStartY;
                    Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY,
                                                                 fStartX, fStartY,
                                                                 -fRotateAngle,
                                                                 ref fX, ref fY);
                    fMinX = fX;
                    fMinY = fY;
                    fMaxX = fX;
                    fMaxY = fY;

                    fX = fEndX;
                    fY = fStartY;
                    Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY,
                                                                 fEndX, fStartY,
                                                                 -fRotateAngle,
                                                                 ref fX, ref fY);
                    if (fMinX > fX)
                        fMinX = fX;
                    if (fMinY > fY)
                        fMinY = fY;
                    if (fMaxX < fX)
                        fMaxX = fX;
                    if (fMaxY < fY)
                        fMaxY = fY;

                    fX = fEndX;
                    fY = fEndY;
                    Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY,
                                                                 fEndX, fEndY,
                                                                 -fRotateAngle,
                                                                 ref fX, ref fY);
                    if (fMinX > fX)
                        fMinX = fX;
                    if (fMinY > fY)
                        fMinY = fY;
                    if (fMaxX < fX)
                        fMaxX = fX;
                    if (fMaxY < fY)
                        fMaxY = fY;

                    fX = fStartX;
                    fY = fEndY;
                    Math2.GetNewXYAfterRotate_360deg(fRotateCenterX, fRotateCenterY,
                                                                 fStartX, fEndY,
                                                                 -fRotateAngle,
                                                                 ref fX, ref fY);
                    if (fMinX > fX)
                        fMinX = fX;
                    if (fMinY > fY)
                        fMinY = fY;
                    if (fMaxX < fX)
                        fMaxX = fX;
                    if (fMaxY < fY)
                        fMaxY = fY;

                    fStartX = fMinX;
                    fStartY = fMinY;
                    fEndX = fMaxX;
                    fEndY = fMaxY;
                }
            }
        }

        public void LoadArrayPointGauge(string strPath)
        {
            //for (int i = 0; i < m_arrPointGauge.Count; i++)
            for (int i = 0; i < m_intNumberOfLead; i++)
            {
                if (i >= m_arrPointGauge.Count)
                {
                    m_arrPointGauge.Add(new List<PGauge>());
                }

                for (int j = 0; j < 6; j++)
                {
                    if (j >= m_arrPointGauge[i].Count)
                    {
                        m_arrPointGauge[i].Add(new PGauge());
                    }

                    // 2020 11 11 - CCENG: i is lead number. j is base tip point number.
                    m_arrPointGauge[i][j].LoadPointGauge(strPath, "Lead" + m_intLeadROIDirection.ToString() + "_" + i.ToString() + "_" + j.ToString());
                }
            }

        }

        public void SaveArrayPointGauge(string strPath)
        {
            //for (int i = 0; i < m_arrPointGauge.Count; i++)
            for (int i = 0; i < m_intNumberOfLead; i++)
            {
                if (i >= m_arrPointGauge.Count)
                    break;

                for (int j = 0; j < 6; j++)
                {
                    if (j >= m_arrPointGauge[i].Count)
                        break;

                    // 2020 11 11 - CCENG: i is lead number. j is base tip point number.
                    m_arrPointGauge[i][j].SavePointGauge(strPath, false, "Lead" + m_intLeadROIDirection.ToString() + "_" + i.ToString() + "_" + j.ToString(), true, true);
                }
            }

        }

    }
}
