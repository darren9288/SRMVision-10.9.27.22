using System;
using System.Collections;
using System.Collections.Generic;
using System.Drawing;
using System.Text;
#if (Debug_2_12 || Release_2_12)
using Euresys.Open_eVision_2_12;
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
using Euresys.Open_eVision_1_2;
#endif
using Common;
using System.IO;

namespace VisionProcessing
{
    public class Package
    {
        #region constant variables

        private const int m_intFeature = 0x0F;
        private const int m_intConnexity = 4;

        #endregion

        #region enum

        public enum eDefect {
            Crack = 0,
            ChipBright = 1,
            Bright = 2,
            MoldFlash = 3,
            Dark = 4,
            Void = 5,
            ChipDark = 6,
            Dark2 = 7,
            Dark3 =8,
            Dark4 =9
        };

        public enum eWantDefect
        {
            Crack = 0,
            Chip = 1,
            Scratches = 2,
            MoldFlash = 3,
            Contamination = 4,
            Void = 5,
            Dark = 6,
            Bright = 7,
            ChipBright = 8,
            ChipDark = 9,
            Dark2 = 10,
            Dark3 =11,
            Dark4 = 12
        };

        public enum eDirection
        {
            Top,
            Bottom,
            Left,
            Right
        };
        #endregion

        #region Member Variables
        //Color
        private int m_intColorDefectLinkMethod = 0; // 0: No Link, 1: Nearest Neighbour
        private int m_intColorDefectLinkTolerance = 10;
        private EColorLookup m_objColorLookupYSH = new EColorLookup();
        private EColorLookup m_objColorLookupLSH = new EColorLookup();
        private EColorLookup m_objColorLookupRGB = new EColorLookup();
        private EBlobs m_objColorBlobs = new EBlobs();
        private List<string> m_arrDefectColorThresName = new List<string>();
        private List<int> m_arrDefectColorSystem = new List<int>(); // 0:HSL, 1:RGB, 2:Saturation
        private List<int> m_arrDefectCloseIteration = new List<int>();
        private List<bool> m_arrDefectInvertBlackWhite = new List<bool>();
        private List<int[]> m_arrDefectColor = new List<int[]>();
        private List<int[]> m_arrDefectColorTolerance = new List<int[]>();
        private List<int> m_arrDefectColorMinArea = new List<int>();
        private List<int> m_arrDefectType = new List<int>(); //0:Defect, 1:Good
        private List<int> m_arrDefectDontCareMode = new List<int>(); //0:None, 1:Mark Area, 2:Package Area, 3:Manual Area
        private List<int> m_arrDefectColorInspection_Top = new List<int>();
        private List<int> m_arrDefectColorInspection_Right = new List<int>();
        private List<int> m_arrDefectColorInspection_Bottom = new List<int>();
        private List<int> m_arrDefectColorInspection_Left = new List<int>();
        private List<int> m_arrDefectImageNo = new List<int>();
        private List<int> m_arrDefectColorInspectionFailCondition = new List<int>(); // 0:OR, 1:AND
        private List<float> m_arrDefectColorInspectionWidth = new List<float>();
        private List<float> m_arrDefectColorInspectionLength = new List<float>();
        private List<float> m_arrDefectColorInspectionMinArea = new List<float>();
        private List<float> m_arrDefectColorInspectionMaxArea = new List<float>();
        private List<float> m_arrDefectColorInspectionTotalArea = new List<float>();
        private int m_intSelectedCopThresIndex = 0;
        private int[] m_intCopperColor = new int[3];
        private int[] m_intCopperColorTolerance = new int[3];
        // 0x01 : Threshold Set 1 Length
        // 0x02 : Threshold Set 1 Area
        // 0x04 : Threshold Set 2 Length
        // 0x08 : Threshold Set 2 Area
        // 0x10 : Threshold Set 3 Length
        // 0x20 : Threshold Set 3 Area
        // 0x40 : Threshold Set 4 Length
        // 0x80 : Threshold Set 4 Area
        // 0x100 : Threshold Set 5 Length
        // 0x200 : Threshold Set 5 Area
        private int m_intFailColorOptionMask = 0;
        private int m_intFailColorResultMask = 0; // 0x01 : Threshold Set 1, 0x02 : Threshold Set 2, 0x04 : Threshold Set 3, 0x08 : Threshold Set 4, 0x10 : Threshold Set 5
        struct ColorDefect
        {
            public string ref_strName;
            public float ref_fStartX;
            public float ref_fStartY;
            public float ref_fEndX;
            public float ref_fEndY;
            public float ref_fWidth;        // Keep defect pixel value for drawing
            public float ref_fHeight;       // Keep defect pixel value for drawing
            public float ref_fArea;
            public float ref_fAngle;
            public float ref_fCenterX;
            public float ref_fCenterY;
            public float ref_fFailValue;    // Keep fail value for display message
            public float ref_fWidthFailValue;
            public float ref_fHeightFailValue;
            public float ref_fAreaFailValue;
            public int ref_intBlobNo;
            // 0x01: Threshold Set 1
            // 0x02: Threshold Set 2
            // 0x04: Threshold Set 3
            // 0x08: Threshold Set 4
            // 0x10: Threshold Set 5
            public int ref_intFailMask;
            public int ref_intFailCriteria; // 0x01:width, 0x02:Height, 0x04:Area
            public int ref_intImageNo;
            public float ref_fWidthInMM;
            public float ref_fHeightInMM;
            public float ref_fAreaInMM2;

            public bool ref_blnFailTotalArea;
        }
        private ImageDrawing[] m_arrPackageColorDontCareImage = new ImageDrawing[5];
        private List<ColorDefect> m_arrColorDefectList = new List<ColorDefect>();

        private int m_intVisionIndex = 0;
        private int m_intFailedImage = 1;

        private float m_fWidthOffsetMM = 0;
        private float m_fHeightOffsetMM = 0;

        private bool m_blnInspectPackage;
        private bool m_blnViewUnitPosition = false;
        private bool m_blnPkgSizeInspectionDone = false;
        private bool m_blnDrawPkgGaugeResult = false;
        private bool m_blnPkgDefectInspectionDone = false;
        private bool m_blnUseDetailDefectCriteria = false;
        private bool m_blnSquareUnit = false;

        private int m_intMarkViewMinArea = 20;
        private int m_intPkgViewMinArea = 20;
        private int m_intChipView1MinArea = 20;
        private int m_intChipView2MinArea = 20;
        private int m_intVoidViewMinArea = 20;
        private int m_intMoldFlashMinArea = 20;
        private int m_intCrackViewMinArea = 20;
        private int m_intBrightFieldMinArea = 20;
        private int m_intDarkFieldMinArea = 20;
        private int m_intDarkField2MinArea = 20;
        private int m_intDarkField3MinArea = 20;
        private int m_intDarkField4MinArea = 20;

        private int m_intMarkViewLowThreshold = 50;
        private int m_intMarkViewHighThreshold = 200;
        private int m_intPkgViewThreshold = 50;
        private int m_intChipView1Threshold = -4;
        private int m_intChipView2Threshold = -4;
        private int m_intVoidViewThreshold = -4;
        private int m_intMoldFlashThreshold = -4;
        private int m_intCrackViewThreshold = -4;
        private int m_intCrackViewLowThreshold = 50;
        private int m_intCrackViewHighThreshold = 200;
        private int m_intBrightFieldLowThreshold = 50;
        private int m_intBrightFieldHighThreshold = 255;
        private int m_intDarkFieldLowThreshold = 50;
        private int m_intDarkFieldHighThreshold = 255;
        private int m_intDarkField2LowThreshold = 50;
        private int m_intDarkField2HighThreshold = 255;
        private int m_intDarkField3LowThreshold = 50;
        private int m_intDarkField3HighThreshold = 255;
        private int m_intDarkField4LowThreshold = 50;
        private int m_intDarkField4HighThreshold = 255;

        private int m_intStartPixelFromEdge = 1;
        private int m_intStartPixelFromRight = 1;
        private int m_intStartPixelFromBottom = 1;
        private int m_intStartPixelFromLeft = 1;
        private int m_intStartPixelFromEdge_DarkField2 = 1;
        private int m_intStartPixelFromRight_DarkField2 = 1;
        private int m_intStartPixelFromBottom_DarkField2 = 1;
        private int m_intStartPixelFromLeft_DarkField2 = 1;
        private int m_intStartPixelFromEdge_DarkField3 = 1;
        private int m_intStartPixelFromRight_DarkField3 = 1;
        private int m_intStartPixelFromBottom_DarkField3 = 1;
        private int m_intStartPixelFromLeft_DarkField3 = 1;
        private int m_intStartPixelFromEdge_DarkField4 = 1;
        private int m_intStartPixelFromRight_DarkField4 = 1;
        private int m_intStartPixelFromBottom_DarkField4 = 1;
        private int m_intStartPixelFromLeft_DarkField4 = 1;
        private int m_intStartPixelFromEdge_Chip = 1;
        private int m_intStartPixelFromRight_Chip = 1;
        private int m_intStartPixelFromBottom_Chip = 1;
        private int m_intStartPixelFromLeft_Chip = 1;
        private int m_intStartPixelExtendFromEdge_Chip = 1;
        private int m_intStartPixelExtendFromRight_Chip = 1;
        private int m_intStartPixelExtendFromBottom_Chip = 1;
        private int m_intStartPixelExtendFromLeft_Chip = 1;
        private int m_intStartPixelFromEdge_Mold = 1;
        private int m_intStartPixelFromRight_Mold = 1;
        private int m_intStartPixelFromBottom_Mold = 1;
        private int m_intStartPixelFromLeft_Mold = 1;
        private int m_intStartPixelFromEdgeInner_Mold = 1;
        private int m_intStartPixelFromRightInner_Mold = 1;
        private int m_intStartPixelFromBottomInner_Mold = 1;
        private int m_intStartPixelFromLeftInner_Mold = 1;

        private int m_intStartPixelFromEdge_Dark = 1;
        private int m_intStartPixelFromRight_Dark = 1;
        private int m_intStartPixelFromBottom_Dark = 1;
        private int m_intStartPixelFromLeft_Dark = 1;
        private int m_intStartPixelFromEdge_Chip_Dark = 1;
        private int m_intStartPixelFromRight_Chip_Dark = 1;
        private int m_intStartPixelFromBottom_Chip_Dark = 1;
        private int m_intStartPixelFromLeft_Chip_Dark = 1;
        private int m_intStartPixelExtendFromEdge_Chip_Dark = 1;
        private int m_intStartPixelExtendFromRight_Chip_Dark = 1;
        private int m_intStartPixelExtendFromBottom_Chip_Dark = 1;
        private int m_intStartPixelExtendFromLeft_Chip_Dark = 1;
        /* m_intPkgFailMask
         * ----------------
         * 0x01=Crack, 
         * 0x02=Chipped Off, 
         * 0x04=Scratches, 
         * 0x08=Mold Flash, 
         * 0x10=Contamination, 
         * 0x20=Void, 
         * 0x100 = bright field, 
         * 0x200 = dark field
         */
        private int m_intPkgFailMask = 0;
        /* m_intPkgFailResultMask
        * ----------------
        * 0x01=Crack, 
        * 0x02=Chipped Off, 
        * 0x04=Scratches, 
        * 0x08=Mold Flash, 
        * 0x10=Contamination, 
        * 0x20=Void, 
        * 0x100 = bright field, 
        * 0x200 = dark field
        * 0x400 = dark field 2
        */
        private int m_intPkgFailResultMask = 0;
        private int m_intUseOtherGaugeMeasurePackage = 0; //0=Use own package gauge, 1=Use Orient gauge, 2=Use Mark gauge
        private float m_fUnitSurfaceOffsetX = 0;      // Offset ROI X between Unit PR Center Point X and Unit Surface Package Gauge X
        private float m_fUnitSurfaceOffsetY = 0;      // Offset ROI X between Unit PR Center Point Y and Unit Surface Package Gauge Y
        private float m_fUnitSizeTolerance = 0.2f;
        private float m_fTemplateUnitSizeX = 0;
        private float m_fTemplateUnitSizeY = 0;
        private float m_fUnitWidthMin;      // in mm
        private float m_fUnitWidthMax;
        private float m_fUnitHeightMin;
        private float m_fUnitHeightMax;
        private float m_fUnitAngleMax;
        private float m_fSittingWidthMin;
        private float m_fSittingWidthMax;
        private float m_fSittingHeightMin;
        private float m_fSittingHeightMax;
        private float m_fUnitResultWidth;
        private float m_fUnitResultHeight;
        private bool[] m_blnLineResultOK = new bool[4];
        private float m_fPackageResultWidth_px;    // in pixel
        private float m_fPackageResultHeight_px;   // in pixel
        private float m_fPackageResultCenterX;  // in pixel
        private float m_fPackageResultCenterY;  // in pixel
        private float m_fPackageResultAngle;
        private string m_strErrorMessage = "";
        private ArrayList m_arrMarkDefectList = new ArrayList();
        private ArrayList m_arrPackageDefectList = new ArrayList();
        private ArrayList m_arrDefectList = new ArrayList();
        private ArrayList m_arrDefectList2 = new ArrayList();
        private float[] m_arrDefectHorizontal = new float[10];  // use eDefect enum
        private float[] m_arrDefectVertical = new float[10];    // use eDefect enum
        private float[] m_arrDefectArea = new float[10];        // use eDefect enum
        private float[] m_arrDefectTotalArea = new float[10];   // use eDefect enum
        private bool[] m_arrWantDefectLength = new bool[15];    // use eWantDefect enum
        private bool[] m_arrWantDefectArea = new bool[15];      // use eWantDefect enum
        private int m_intBrightDefectDimensionFailCondition = 0; // 0:OR, 1:AND
        private int m_intDarkDefectDimensionFailCondition = 0; // 0:OR, 1:AND
        private int m_intDark2DefectDimensionFailCondition = 0; // 0:OR, 1:AND
        private int m_intDark3DefectDimensionFailCondition = 0; // 0:OR, 1:AND
        private int m_intDark4DefectDimensionFailCondition = 0; // 0:OR, 1:AND
        private int m_intCrackDarkDefectDimensionFailCondition = 0; // 0:OR, 1:AND
        private int m_intChippedBrightDefectDimensionFailCondition = 0; // 0:OR, 1:AND
        private int m_intChippedDarkDefectDimensionFailCondition = 0; // 0:OR, 1:AND
        private bool m_blnSeperateBrightDarkROITolerance = false;
        private bool m_blnSeperateDarkField2DefectSetting = false;
        private bool m_blnSeperateDarkField3DefectSetting = false;
        private bool m_blnSeperateDarkField4DefectSetting = false;
        private bool m_blnSeperateCrackDefectSetting = false;
        private int m_intBrightDefectLinkTolerance= 10;
        private int m_intDarkDefectLinkTolerance= 10;
        private int m_intDark2DefectLinkTolerance = 10;
        private int m_intDark3DefectLinkTolerance = 10;
        private int m_intDark4DefectLinkTolerance = 10;
        private int m_intCrackDefectLinkTolerance = 10;
        private int m_intMoldFlashDefectLinkTolerance = 10;
        private bool m_blnWantLinkBrightDefect = false;
        private bool m_blnWantLinkDarkDefect = false;
        private bool m_blnWantLinkDark2Defect = false;
        private bool m_blnWantLinkDark3Defect = false;
        private bool m_blnWantLinkDark4Defect = false;
        private bool m_blnWantLinkCrackDefect = false;
        private bool m_blnWantLinkMoldFlashDefect = false;
        private bool m_blnSeperateVoidDefectSetting = false;
        private bool m_blnSeperateMoldFlashDefectSetting = false;
        private bool m_blnSeperateChippedOffDefectSetting = false;
        private int m_intChippedOffDefectInspectionMethod = 0; //0:Separate 4 Sides, 1:All Together
        private List<ArrayList> m_arrLinePoints = new List<ArrayList>();       // Top, Bottom, Left, Right
        private EBlobs m_objPackageEBlobs = new EBlobs();
        private EBlobs m_objMarkViewEBlobs = new EBlobs();
        private EBlobs m_objEBlobs = new EBlobs();
        private EBlobs m_objImage1MoldFlashBlobs = new EBlobs();
        private List<List<List<ROI>>> m_arrMarkMaskROI = new List<List<List<ROI>>>();
        private List<ROI> m_arrSideROI = new List<ROI>();
        private List<int> m_arrGrabImageIndex = new List<int>();   // Record grab image index for different defect checking. // 0: Unit Edge, 1: Mark, 2: Bright, 3: Dark, 4: Dark 2, 5: Mold Flash
        private ImageDrawing m_objChippedOffImage = new ImageDrawing();
        private ImageDrawing m_objVoidViewImage = new ImageDrawing();
        private List<List<PointF>> m_arrDontCareArea = new List<List<PointF>>();
        private bool m_blnPkgViewFailTotalArea = false;
        private bool m_blnCrackChipViewFailTotalArea = false;
        private bool m_blnMarkViewFailTotalArea = false;
        private bool m_blnBrightChipDefect = false;
        // 2021 07 27 - CCENG: True : direct check blob area size is it bigger than setting. False : Before check size, need to double check is blob near to inward ROI or not.
        //                   : Previously outward ROI cannot set inside the package, this make formula of "checking blob near to inward ROI" very important.
        //                   : But now allow outward ROI set inside the package, then basic ROI shouldd be good enough and easier.
        private bool m_blnBasicChipCheckingMode = false;

        //font properties
        private Font m_FontMatched = new Font("Tahoma", 8);
        private SolidBrush m_BrushMatched = new SolidBrush(Color.GreenYellow);

        // Calibration
        private float m_fMMPerPixelX = 1;
        private float m_fMMPerPixelY = 1;
        private float m_fMMToPixelXValue = 1;
        private float m_fMMToPixelYValue = 1;
        private float m_fMMtoPixelAreaValue = 1;

        private float m_fMMToUnitValue = 1;
        private float m_fMMToUnitValueArea = 1;

        // PR
        private EMatcher m_objUnitPRMatcher;


        #endregion

        #region Properties
        //Color
        public int ref_intColorDefectLinkMethod { get { return m_intColorDefectLinkMethod; } set { m_intColorDefectLinkMethod = value; } }
        public int ref_intColorDefectLinkTolerance { get { return m_intColorDefectLinkTolerance; } set { m_intColorDefectLinkTolerance = value; } }
        public List<string> ref_arrDefectColorThresName { get { return m_arrDefectColorThresName; } set { m_arrDefectColorThresName = value; } }
        public List<int> ref_arrDefectColorSystem { get { return m_arrDefectColorSystem; } set { m_arrDefectColorSystem = value; } }
        public List<int> ref_arrDefectCloseIteration { get { return m_arrDefectCloseIteration; } set { m_arrDefectCloseIteration = value; } }
        public List<bool> ref_arrDefectInvertBlackWhite { get { return m_arrDefectInvertBlackWhite; } set { m_arrDefectInvertBlackWhite = value; } }
        public List<int[]> ref_arrDefectColor { get { return m_arrDefectColor; } set { m_arrDefectColor = value; } }
        public List<int[]> ref_arrDefectColorTolerance { get { return m_arrDefectColorTolerance; } set { m_arrDefectColorTolerance = value; } }
        public List<int> ref_arrDefectColorMinArea { get { return m_arrDefectColorMinArea; } set { m_arrDefectColorMinArea = value; } }
        public List<int> ref_arrDefectType { get { return m_arrDefectType; } set { m_arrDefectType = value; } }
        public List<int> ref_arrDefectImageNo { get { return m_arrDefectImageNo; } set { m_arrDefectImageNo = value; } }
        public List<int> ref_arrDefectDontCareMode { get { return m_arrDefectDontCareMode; } set { m_arrDefectDontCareMode = value; } }
        public List<int> ref_arrDefectColorInspection_Top { get { return m_arrDefectColorInspection_Top; } set { m_arrDefectColorInspection_Top = value; } }
        public List<int> ref_arrDefectColorInspection_Right { get { return m_arrDefectColorInspection_Right; } set { m_arrDefectColorInspection_Right = value; } }
        public List<int> ref_arrDefectColorInspection_Bottom { get { return m_arrDefectColorInspection_Bottom; } set { m_arrDefectColorInspection_Bottom = value; } }
        public List<int> ref_arrDefectColorInspection_Left { get { return m_arrDefectColorInspection_Left; } set { m_arrDefectColorInspection_Left = value; } }
        public List<int> ref_arrDefectColorInspectionFailCondition { get { return m_arrDefectColorInspectionFailCondition; } set { m_arrDefectColorInspectionFailCondition = value; } }
        public List<float> ref_arrDefectColorInspectionWidth { get { return m_arrDefectColorInspectionWidth; } set { m_arrDefectColorInspectionWidth = value; } }
        public List<float> ref_arrDefectColorInspectionLength { get { return m_arrDefectColorInspectionLength; } set { m_arrDefectColorInspectionLength = value; } }
        public List<float> ref_arrDefectColorInspectionMinArea { get { return m_arrDefectColorInspectionMinArea; } set { m_arrDefectColorInspectionMinArea = value; } }
        public List<float> ref_arrDefectColorInspectionMaxArea { get { return m_arrDefectColorInspectionMaxArea; } set { m_arrDefectColorInspectionMaxArea = value; } }
        public List<float> ref_arrDefectColorInspectionTotalArea { get { return m_arrDefectColorInspectionTotalArea; } set { m_arrDefectColorInspectionTotalArea = value; } }
        public int[] ref_intCopperColor { get { return m_intCopperColor; } set { m_intCopperColor = value; } }
        public int[] ref_intCopperColorTolerance { get { return m_intCopperColorTolerance; } set { m_intCopperColorTolerance = value; } }
        public int ref_intFailColorOptionMask { get { return m_intFailColorOptionMask; } set { m_intFailColorOptionMask = value; } }
        public int ref_intFailColorResultMask { get { return m_intFailColorResultMask; } set { m_intFailColorResultMask = value; } }

        // public int ref_intFailedImage { set { m_intFailedImage = value; } get { return m_intFailedImage; } }
        public float ref_fWidthOffsetMM { set { m_fWidthOffsetMM = value; } get { return m_fWidthOffsetMM; } }
        public float ref_fHeightOffsetMM { set { m_fHeightOffsetMM = value; } get { return m_fHeightOffsetMM; } }
        public bool ref_blnViewUnitPosition { set { m_blnViewUnitPosition = value; } get { return m_blnViewUnitPosition; } }
        public bool ref_blnPkgSizeInspectionDone { set { m_blnPkgSizeInspectionDone = value; } get { return m_blnPkgSizeInspectionDone; } }
        public bool ref_blnDrawPkgGaugeResult { set { m_blnDrawPkgGaugeResult = value; } get { return m_blnDrawPkgGaugeResult; } }
        
        public bool ref_blnPkgDefectInspectionDone { set { m_blnPkgDefectInspectionDone = value; } get { return m_blnPkgDefectInspectionDone; } }
        public int ref_intBrightDefectLinkTolerance { set { m_intBrightDefectLinkTolerance = value; } get { return m_intBrightDefectLinkTolerance; } }
        public int ref_intDarkDefectLinkTolerance { set { m_intDarkDefectLinkTolerance = value; } get { return m_intDarkDefectLinkTolerance; } }
        public int ref_intDark2DefectLinkTolerance { set { m_intDark2DefectLinkTolerance = value; } get { return m_intDark2DefectLinkTolerance; } }
        public int ref_intDark3DefectLinkTolerance { set { m_intDark3DefectLinkTolerance = value; } get { return m_intDark3DefectLinkTolerance; } }
        public int ref_intDark4DefectLinkTolerance { set { m_intDark4DefectLinkTolerance = value; } get { return m_intDark4DefectLinkTolerance; } }
        public int ref_intCrackDefectLinkTolerance { set { m_intCrackDefectLinkTolerance = value; } get { return m_intCrackDefectLinkTolerance; } }
        public int ref_intMoldFlashDefectLinkTolerance { set { m_intMoldFlashDefectLinkTolerance = value; } get { return m_intMoldFlashDefectLinkTolerance; } }
        public bool ref_blnWantLinkBrightDefect { set { m_blnWantLinkBrightDefect = value; } get { return m_blnWantLinkBrightDefect; } }
        public bool ref_blnWantLinkDarkDefect { set { m_blnWantLinkDarkDefect = value; } get { return m_blnWantLinkDarkDefect; } }
        public bool ref_blnWantLinkDark2Defect { set { m_blnWantLinkDark2Defect = value; } get { return m_blnWantLinkDark2Defect; } }
        public bool ref_blnWantLinkDark3Defect { set { m_blnWantLinkDark3Defect = value; } get { return m_blnWantLinkDark3Defect; } }
        public bool ref_blnWantLinkDark4Defect { set { m_blnWantLinkDark4Defect = value; } get { return m_blnWantLinkDark4Defect; } }
        public bool ref_blnWantLinkCrackDefect { set { m_blnWantLinkCrackDefect = value; } get { return m_blnWantLinkCrackDefect; } }
        public bool ref_blnWantLinkMoldFlashDefect { set { m_blnWantLinkMoldFlashDefect = value; } get { return m_blnWantLinkMoldFlashDefect; } }
        public bool ref_blnSeperateBrightDarkROITolerance { set { m_blnSeperateBrightDarkROITolerance = value; } get { return m_blnSeperateBrightDarkROITolerance; } }
        public bool ref_blnSeperateDarkField2DefectSetting { set { m_blnSeperateDarkField2DefectSetting = value; } get { return m_blnSeperateDarkField2DefectSetting; } }
        public bool ref_blnSeperateDarkField3DefectSetting { set { m_blnSeperateDarkField3DefectSetting = value; } get { return m_blnSeperateDarkField3DefectSetting; } }
        public bool ref_blnSeperateDarkField4DefectSetting { set { m_blnSeperateDarkField4DefectSetting = value; } get { return m_blnSeperateDarkField4DefectSetting; } }
        public bool ref_blnSeperateCrackDefectSetting { set { m_blnSeperateCrackDefectSetting = value; } get { return m_blnSeperateCrackDefectSetting; } }
        public bool ref_blnSeperateVoidDefectSetting { set { m_blnSeperateVoidDefectSetting = value; } get { return m_blnSeperateVoidDefectSetting; } }
        public bool ref_blnSeperateMoldFlashDefectSetting { set { m_blnSeperateMoldFlashDefectSetting = value; } get { return m_blnSeperateMoldFlashDefectSetting; } }
        public bool ref_blnSeperateChippedOffDefectSetting { set { m_blnSeperateChippedOffDefectSetting = value; } get { return m_blnSeperateChippedOffDefectSetting; } }
        public int ref_intChippedOffDefectInspectionMethod { set { m_intChippedOffDefectInspectionMethod = value; } get { return m_intChippedOffDefectInspectionMethod; } }
        public float ref_fPackageResultWidth_px { set { m_fPackageResultWidth_px = value; } get { return m_fPackageResultWidth_px; } }
        public float ref_fPackageResultHeight_px { set { m_fPackageResultHeight_px = value; } get { return m_fPackageResultHeight_px; } }
        public float ref_fPackageResultCenterX { set { m_fPackageResultCenterX = value; } get { return m_fPackageResultCenterX; } }
        public float ref_fPackageResultCenterY { set { m_fPackageResultCenterY = value; } get { return m_fPackageResultCenterY; } }
        public float ref_fPackageResultAngle { set { m_fPackageResultAngle = value; } get { return m_fPackageResultAngle; } }
        public int ref_intBrightDefectDimensionFailCondition { set { m_intBrightDefectDimensionFailCondition = value; } get { return m_intBrightDefectDimensionFailCondition; } }
        public int ref_intDarkDefectDimensionFailCondition { set { m_intDarkDefectDimensionFailCondition = value; } get { return m_intDarkDefectDimensionFailCondition; } }
        public int ref_intDark2DefectDimensionFailCondition { set { m_intDark2DefectDimensionFailCondition = value; } get { return m_intDark2DefectDimensionFailCondition; } }
        public int ref_intDark3DefectDimensionFailCondition { set { m_intDark3DefectDimensionFailCondition = value; } get { return m_intDark3DefectDimensionFailCondition; } }
        public int ref_intDark4DefectDimensionFailCondition { set { m_intDark4DefectDimensionFailCondition = value; } get { return m_intDark4DefectDimensionFailCondition; } }
        public int ref_intCrackDarkDefectDimensionFailCondition { set { m_intCrackDarkDefectDimensionFailCondition = value; } get { return m_intCrackDarkDefectDimensionFailCondition; } }
        public int ref_intChippedBrightDefectDimensionFailCondition { set { m_intChippedBrightDefectDimensionFailCondition = value; } get { return m_intChippedBrightDefectDimensionFailCondition; } }
        public int ref_intChippedDarkDefectDimensionFailCondition { set { m_intChippedDarkDefectDimensionFailCondition = value; } get { return m_intChippedDarkDefectDimensionFailCondition; } }
        public bool ref_blnUseDetailDefectCriteria { set { m_blnUseDetailDefectCriteria = value; } get { return m_blnUseDetailDefectCriteria; } }
        public bool ref_blnSquareUnit { set { m_blnSquareUnit = value; } get { return m_blnSquareUnit; } }
        
        public int ref_intMarkViewMinArea
        {
            set
            {
                m_intMarkViewMinArea = value;
                m_objMarkViewEBlobs.ref_intMinAreaLimit = value;
            }
            get
            {
                return m_intMarkViewMinArea;
            }
        }
        public int ref_intPkgViewMinArea
        {
            set
            {
                m_intPkgViewMinArea = value;
                m_objPackageEBlobs.ref_intMinAreaLimit = value;
            }
            get
            {
                return m_intPkgViewMinArea;
            }
        }
        public int ref_intChipView1MinArea { set { m_intChipView1MinArea = value; } get { return m_intChipView1MinArea; } }
        public int ref_intChipView2MinArea { set { m_intChipView2MinArea = value; } get { return m_intChipView2MinArea; } }

        public int ref_intVoidViewMinArea { set { m_intVoidViewMinArea = value; } get { return m_intVoidViewMinArea; } }
        public int ref_intMoldFlashMinArea { set { m_intMoldFlashMinArea = value; } get { return m_intMoldFlashMinArea; } }
        public int ref_intCrackViewMinArea { set { m_intCrackViewMinArea = value; } get { return m_intCrackViewMinArea; } }
        public int ref_intBrightFieldMinArea { set { m_intBrightFieldMinArea = value; } get { return m_intBrightFieldMinArea; } }
        public int ref_intDarkFieldMinArea { set { m_intDarkFieldMinArea = value; } get { return m_intDarkFieldMinArea; } }
        public int ref_intDarkField2MinArea { set { m_intDarkField2MinArea = value; } get { return m_intDarkField2MinArea; } }
        public int ref_intDarkField3MinArea { set { m_intDarkField3MinArea = value; } get { return m_intDarkField3MinArea; } }
        public int ref_intDarkField4MinArea { set { m_intDarkField4MinArea = value; } get { return m_intDarkField4MinArea; } }

        public int ref_intMarkViewHighThreshold
        {
            set
            {
                m_intMarkViewHighThreshold = m_objMarkViewEBlobs.ref_intAbsoluteHighThreshold = value;
            }
            get
            {
                return m_intMarkViewHighThreshold;
            }
        }
        public int ref_intMarkViewLowThreshold
        {
            set
            {
                m_intMarkViewLowThreshold = m_objMarkViewEBlobs.ref_intAbsoluteLowThreshold = value;
            }
            get
            {
                return m_intMarkViewLowThreshold;
            }
        }
        public int ref_intPkgViewThreshold
        {
            set
            {
                m_intPkgViewThreshold = m_objPackageEBlobs.ref_intAbsoluteThreshold = value;
            }
            get
            {
                return m_intPkgViewThreshold;
            }
        }
        public int ref_intChipView1Threshold { set { m_intChipView1Threshold = value; } get { return m_intChipView1Threshold; } }
        public int ref_intChipView2Threshold { set { m_intChipView2Threshold = value; } get { return m_intChipView2Threshold; } }
        public int ref_intVoidViewThreshold { set { m_intVoidViewThreshold = value; } get { return m_intVoidViewThreshold; } }
        public int ref_intMoldFlashThreshold { set { m_intMoldFlashThreshold = value; } get { return m_intMoldFlashThreshold; } }
        public int ref_intCrackViewThreshold { set { m_intCrackViewThreshold = value; } get { return m_intCrackViewThreshold; } }
        public int ref_intCrackViewLowThreshold { set { m_intCrackViewLowThreshold = value; } get { return m_intCrackViewLowThreshold; } }
        public int ref_intCrackViewHighThreshold { set { m_intCrackViewHighThreshold = value; } get { return m_intCrackViewHighThreshold; } }
        public int ref_intBrightFieldLowThreshold { set { m_intBrightFieldLowThreshold = value; } get { return m_intBrightFieldLowThreshold; } }
        public int ref_intBrightFieldHighThreshold { set { m_intBrightFieldHighThreshold = value; } get { return m_intBrightFieldHighThreshold; } }
        public int ref_intDarkFieldLowThreshold { set { m_intDarkFieldLowThreshold = value; } get { return m_intDarkFieldLowThreshold; } }
        public int ref_intDarkFieldHighThreshold { set { m_intDarkFieldHighThreshold = value; } get { return m_intDarkFieldHighThreshold; } }
        public int ref_intDarkField2LowThreshold { set { m_intDarkField2LowThreshold = value; } get { return m_intDarkField2LowThreshold; } }
        public int ref_intDarkField2HighThreshold { set { m_intDarkField2HighThreshold = value; } get { return m_intDarkField2HighThreshold; } }
        public int ref_intDarkField3LowThreshold { set { m_intDarkField3LowThreshold = value; } get { return m_intDarkField3LowThreshold; } }
        public int ref_intDarkField3HighThreshold { set { m_intDarkField3HighThreshold = value; } get { return m_intDarkField3HighThreshold; } }
        public int ref_intDarkField4LowThreshold { set { m_intDarkField4LowThreshold = value; } get { return m_intDarkField4LowThreshold; } }
        public int ref_intDarkField4HighThreshold { set { m_intDarkField4HighThreshold = value; } get { return m_intDarkField4HighThreshold; } }

        public int ref_intStartPixelFromEdge { set { m_intStartPixelFromEdge = value; } get { return m_intStartPixelFromEdge; } }
        public int ref_intStartPixelFromRight { set { m_intStartPixelFromRight = value; } get { return m_intStartPixelFromRight; } }
        public int ref_intStartPixelFromBottom { set { m_intStartPixelFromBottom = value; } get { return m_intStartPixelFromBottom; } }
        public int ref_intStartPixelFromLeft { set { m_intStartPixelFromLeft = value; } get { return m_intStartPixelFromLeft; } }
        public int ref_intStartPixelFromEdge_DarkField2 { set { m_intStartPixelFromEdge_DarkField2 = value; } get { return m_intStartPixelFromEdge_DarkField2; } }
        public int ref_intStartPixelFromRight_DarkField2 { set { m_intStartPixelFromRight_DarkField2 = value; } get { return m_intStartPixelFromRight_DarkField2; } }
        public int ref_intStartPixelFromBottom_DarkField2 { set { m_intStartPixelFromBottom_DarkField2 = value; } get { return m_intStartPixelFromBottom_DarkField2; } }
        public int ref_intStartPixelFromLeft_DarkField2 { set { m_intStartPixelFromLeft_DarkField2 = value; } get { return m_intStartPixelFromLeft_DarkField2; } }
        public int ref_intStartPixelFromEdge_DarkField3 { set { m_intStartPixelFromEdge_DarkField3 = value; } get { return m_intStartPixelFromEdge_DarkField3; } }
        public int ref_intStartPixelFromRight_DarkField3 { set { m_intStartPixelFromRight_DarkField3 = value; } get { return m_intStartPixelFromRight_DarkField3; } }
        public int ref_intStartPixelFromBottom_DarkField3 { set { m_intStartPixelFromBottom_DarkField3 = value; } get { return m_intStartPixelFromBottom_DarkField3; } }
        public int ref_intStartPixelFromLeft_DarkField3 { set { m_intStartPixelFromLeft_DarkField3 = value; } get { return m_intStartPixelFromLeft_DarkField3; } }
        public int ref_intStartPixelFromEdge_DarkField4 { set { m_intStartPixelFromEdge_DarkField4 = value; } get { return m_intStartPixelFromEdge_DarkField4; } }
        public int ref_intStartPixelFromRight_DarkField4 { set { m_intStartPixelFromRight_DarkField4 = value; } get { return m_intStartPixelFromRight_DarkField4; } }
        public int ref_intStartPixelFromBottom_DarkField4 { set { m_intStartPixelFromBottom_DarkField4 = value; } get { return m_intStartPixelFromBottom_DarkField4; } }
        public int ref_intStartPixelFromLeft_DarkField4 { set { m_intStartPixelFromLeft_DarkField4 = value; } get { return m_intStartPixelFromLeft_DarkField4; } }
        public int ref_intStartPixelExtendFromEdge_Chip { set { m_intStartPixelExtendFromEdge_Chip = value; } get { return m_intStartPixelExtendFromEdge_Chip; } }
        public int ref_intStartPixelExtendFromRight_Chip { set { m_intStartPixelExtendFromRight_Chip = value; } get { return m_intStartPixelExtendFromRight_Chip; } }
        public int ref_intStartPixelExtendFromBottom_Chip { set { m_intStartPixelExtendFromBottom_Chip = value; } get { return m_intStartPixelExtendFromBottom_Chip; } }
        public int ref_intStartPixelExtendFromLeft_Chip { set { m_intStartPixelExtendFromLeft_Chip = value; } get { return m_intStartPixelExtendFromLeft_Chip; } }
        public int ref_intStartPixelFromEdge_Chip { set { m_intStartPixelFromEdge_Chip = value; } get { return m_intStartPixelFromEdge_Chip; } }
        public int ref_intStartPixelFromRight_Chip { set { m_intStartPixelFromRight_Chip = value; } get { return m_intStartPixelFromRight_Chip; } }
        public int ref_intStartPixelFromBottom_Chip { set { m_intStartPixelFromBottom_Chip = value; } get { return m_intStartPixelFromBottom_Chip; } }
        public int ref_intStartPixelFromLeft_Chip { set { m_intStartPixelFromLeft_Chip = value; } get { return m_intStartPixelFromLeft_Chip; } }
        public int ref_intStartPixelFromEdge_Mold { set { m_intStartPixelFromEdge_Mold = value; } get { return m_intStartPixelFromEdge_Mold; } }
        public int ref_intStartPixelFromRight_Mold { set { m_intStartPixelFromRight_Mold = value; } get { return m_intStartPixelFromRight_Mold; } }
        public int ref_intStartPixelFromBottom_Mold { set { m_intStartPixelFromBottom_Mold = value; } get { return m_intStartPixelFromBottom_Mold; } }
        public int ref_intStartPixelFromLeft_Mold { set { m_intStartPixelFromLeft_Mold = value; } get { return m_intStartPixelFromLeft_Mold; } }
        public int ref_intStartPixelFromEdgeInner_Mold { set { m_intStartPixelFromEdgeInner_Mold = value; } get { return m_intStartPixelFromEdgeInner_Mold; } }
        public int ref_intStartPixelFromRightInner_Mold { set { m_intStartPixelFromRightInner_Mold = value; } get { return m_intStartPixelFromRightInner_Mold; } }
        public int ref_intStartPixelFromBottomInner_Mold { set { m_intStartPixelFromBottomInner_Mold = value; } get { return m_intStartPixelFromBottomInner_Mold; } }
        public int ref_intStartPixelFromLeftInner_Mold { set { m_intStartPixelFromLeftInner_Mold = value; } get { return m_intStartPixelFromLeftInner_Mold; } }
        public int ref_intStartPixelFromEdge_Dark { set { m_intStartPixelFromEdge_Dark = value; } get { return m_intStartPixelFromEdge_Dark; } }
        public int ref_intStartPixelFromRight_Dark { set { m_intStartPixelFromRight_Dark = value; } get { return m_intStartPixelFromRight_Dark; } }
        public int ref_intStartPixelFromBottom_Dark { set { m_intStartPixelFromBottom_Dark = value; } get { return m_intStartPixelFromBottom_Dark; } }
        public int ref_intStartPixelFromLeft_Dark { set { m_intStartPixelFromLeft_Dark = value; } get { return m_intStartPixelFromLeft_Dark; } }
        public int ref_intStartPixelFromEdge_Chip_Dark { set { m_intStartPixelFromEdge_Chip_Dark = value; } get { return m_intStartPixelFromEdge_Chip_Dark; } }
        public int ref_intStartPixelFromRight_Chip_Dark { set { m_intStartPixelFromRight_Chip_Dark = value; } get { return m_intStartPixelFromRight_Chip_Dark; } }
        public int ref_intStartPixelFromBottom_Chip_Dark { set { m_intStartPixelFromBottom_Chip_Dark = value; } get { return m_intStartPixelFromBottom_Chip_Dark; } }
        public int ref_intStartPixelFromLeft_Chip_Dark { set { m_intStartPixelFromLeft_Chip_Dark = value; } get { return m_intStartPixelFromLeft_Chip_Dark; } }
        public int ref_intStartPixelExtendFromEdge_Chip_Dark { set { m_intStartPixelExtendFromEdge_Chip_Dark = value; } get { return m_intStartPixelExtendFromEdge_Chip_Dark; } }
        public int ref_intStartPixelExtendFromRight_Chip_Dark { set { m_intStartPixelExtendFromRight_Chip_Dark = value; } get { return m_intStartPixelExtendFromRight_Chip_Dark; } }
        public int ref_intStartPixelExtendFromBottom_Chip_Dark { set { m_intStartPixelExtendFromBottom_Chip_Dark = value; } get { return m_intStartPixelExtendFromBottom_Chip_Dark; } }
        public int ref_intStartPixelExtendFromLeft_Chip_Dark { set { m_intStartPixelExtendFromLeft_Chip_Dark = value; } get { return m_intStartPixelExtendFromLeft_Chip_Dark; } }


        public int ref_intFailMask { set { m_intPkgFailMask = value; } get { return m_intPkgFailMask; } }
        public int ref_intFailResultMask { set { m_intPkgFailResultMask = value; } get { return m_intPkgFailResultMask; } }
        public int ref_intUseOtherGaugeMeasurePackage { set { m_intUseOtherGaugeMeasurePackage = value; } get { return m_intUseOtherGaugeMeasurePackage; } }
        public float ref_fUnitSizeTolerance { set { m_fUnitSizeTolerance = value; } get { return m_fUnitSizeTolerance; } }
        //public float ref_fTemplateUnitSizeX { set { m_fUnitWidthMin = value; } get { return m_fUnitWidthMin; } } //ZJYEOH 31-12-2018: m_fTemplateUnitSizeX changed to m_fUnitWidthMin
        //public float ref_fTemplateUnitSizeY { set { m_fUnitHeightMin = value; } get { return m_fUnitHeightMin; } }//ZJYEOH 31-12-2018: m_fTemplateUnitSizeY changed to m_fUnitHeightMin
        public float ref_fTemplateUnitSizeX { set { m_fTemplateUnitSizeX = value; } get { return m_fTemplateUnitSizeX; } } //CCENG: 05-03-2020: Use back m_fTemplateUnitSizeX
        public float ref_fTemplateUnitSizeY { set { m_fTemplateUnitSizeY = value; } get { return m_fTemplateUnitSizeY; } } //CCENG: 05-03-2020: Use back m_fTemplateUnitSizeY
        public string ref_strErrorMessage { set { m_strErrorMessage = value; } get { return m_strErrorMessage; } }
        public ArrayList ref_arrDefectList { get { return m_arrDefectList; } }
        public ArrayList ref_arrMarkDefectList { get { return m_arrMarkDefectList; } }
        public List<ROI> ref_arrSideROI { get { return m_arrSideROI; } }
        public float ref_fUnitWidthMin { get { return m_fUnitWidthMin; } set { m_fUnitWidthMin = value; } }
        public float ref_fUnitWidthMax { get { return m_fUnitWidthMax; } set { m_fUnitWidthMax = value; } }
        public float ref_fUnitHeightMin { get { return m_fUnitHeightMin; } set { m_fUnitHeightMin = value; } }
        public float ref_fUnitHeightMax { get { return m_fUnitHeightMax; } set { m_fUnitHeightMax = value; } }
        public float ref_fUnitAngleMax { get { return m_fUnitAngleMax; } set { m_fUnitAngleMax = value; } }
        public float ref_fUnitResultWidth { get { return m_fUnitResultWidth; } set { m_fUnitResultWidth = value; } }
        public float ref_fUnitResultHeight { get { return m_fUnitResultHeight; } set { m_fUnitResultHeight = value; } }
        public float ref_fUnitSurfaceOffsetX { get { return m_fUnitSurfaceOffsetX; } set { m_fUnitSurfaceOffsetX = value; } }
        public float ref_fUnitSurfaceOffsetY { get { return m_fUnitSurfaceOffsetY; } set { m_fUnitSurfaceOffsetY = value; } }

        public bool[] ref_blnLineResultOK { get { return m_blnLineResultOK; } }

        #endregion

        //HiPerfTimer m_T1 = new HiPerfTimer();
        //public string m_strTrack = "";
        //float m_fTimingPrev = 0;
        //float m_fTiming = 0;
        //int debugCount = 0;
        struct Defect
        {
            public string ref_strName;
            public float ref_fDimX;
            public float ref_fDimY;
            public float ref_fArea;
            public float ref_fCenterX;
            public float ref_fCenterY;
            public float ref_fAngle;
            public int ref_intBlobNo;
            public int ref_intLengthMode;   // 0 = Height, 1 = width
            public int ref_intFailMask; // 0x01=Fail WitdhInMM, 0x02=Fail HeightInMM, 0x04= Fail AreaInMM2
            public int ref_intFailedImage;
        }



        public Package(int intVisionIndex, int intImageWidth, int intImageHeight)
        {
            if (m_objColorLookupYSH.ColorSystemOut != EColorSystem.Ysh)
                m_objColorLookupYSH.ConvertFromRgb(EColorSystem.Ysh);
            if (m_objColorLookupLSH.ColorSystemOut != EColorSystem.Lsh)
                m_objColorLookupLSH.ConvertFromRgb(EColorSystem.Lsh);
            if (m_objColorLookupRGB.ColorSystemOut != EColorSystem.Rgb)
                m_objColorLookupRGB.ConvertFromRgb(EColorSystem.Rgb);
            for (int i = 0; i < m_arrPackageColorDontCareImage.Length; i++)
            {
                m_arrPackageColorDontCareImage[i] = new ImageDrawing(true, intImageWidth, intImageHeight);
            }
            m_objEBlobs.ref_intAbsoluteThreshold = 125;
            m_objEBlobs.ref_intConnexity = m_intConnexity;
            m_objEBlobs.ref_intCriteria = m_intFeature;   // area and object center
            m_objEBlobs.ref_intMinAreaLimit = 20;
            m_objEBlobs.ref_intMaxAreaLimit = 15000;

            m_intVisionIndex = intVisionIndex;
        }



        //public bool DoInspection(RectGauge objPackageGauge, // Gauge to measure unit edge and size
        //                         ROI objUnitROI,    // For chip test
        //                         ROI objPackageROI,
        //                         ImageDrawing objChipImage, // Image use to check chipped off 
        //                         ImageDrawing objCrackImage, // Image from top light source to check crack
        //                         ImageDrawing objPkgImage, // Package image
        //                         ImageDrawing objPkgImage2)// Image from zero angle light source to check precise defect

        public void SetCalibrationData(float fPixelPerMMX, float fPixelPerMMY, int intUnitMode)
        {
            // MM to Pixel formula
            m_fMMPerPixelX = 1 / fPixelPerMMX;
            m_fMMPerPixelY = 1 / fPixelPerMMY;
            m_fMMToPixelXValue = fPixelPerMMX;
            m_fMMToPixelYValue = fPixelPerMMY;
            m_fMMtoPixelAreaValue = fPixelPerMMX * fPixelPerMMY;

            // MM to Micron or Mil formula
            switch (intUnitMode)
            {
                case 1: // mm
                    m_fMMToUnitValue = 1;
                    m_fMMToUnitValueArea = 1;
                    break;
                case 2: // mil
                    m_fMMToUnitValue = 1 / 0.0254f;
                    m_fMMToUnitValueArea = 1 / (0.0254f * 0.0254f);
                    break;
                case 3: // micron
                    m_fMMToUnitValue = 1000;
                    m_fMMToUnitValueArea = 1000000;
                    break;

            }


        }

        //public bool DoInspection_MOPkg(RectGauge objView1Gauge,         // use to measure unit edge
        // RectGauge objView2Gauge,
        // ROI objMarkViewROI,                // Package Test on first image
        // ROI objPkgViewROI,                 // Package Test on second image
        // ROI objChipUnitROI,                // Chipped off test
        // ROI objCrackViewROI,               // Crack test
        // ROI objChipUnitROI2,               // Chipped off test on third image
        // ImageDrawing m_objMarkViewImage,   // First package image
        // ImageDrawing m_objPkgViewImage,    // Second package image (option)
        // ImageDrawing m_objCrackViewImage)  // Image from Top light source
        //{
        //    //if (objMarkViewROI != null)
        //    //    objMarkViewROI.SaveImage("D:\\TS\\1-objMarkViewROI.bmp");
        //    //if (objPkgViewROI != null)
        //    //    objPkgViewROI.SaveImage("D:\\TS\\2-objPkgViewROI.bmp");
        //    //if (objChipUnitROI != null)
        //    //    objChipUnitROI.SaveImage("D:\\TS\\3-objChipUnitROI.bmp");
        //    //if (objCrackViewROI != null)
        //    //    objCrackViewROI.SaveImage("D:\\TS\\4-objCrackViewROI.bmp");
        //    //if (objChipUnitROI2 != null)
        //    //    objChipUnitROI2.SaveImage("D:\\TS\\5-objChipUnitROI2.bmp");
        //    //if (m_objMarkViewImage != null)
        //    //    m_objMarkViewImage.SaveImage("D:\\TS\\6-m_objMarkViewImage.bmp");
        //    //if (m_objPkgViewImage != null)
        //    //    m_objPkgViewImage.SaveImage("D:\\TS\\7-m_objPkgViewImage.bmp");
        //    //if (m_objCrackViewImage != null)
        //    //    m_objCrackViewImage.SaveImage("D:\\TS\\8-m_objCrackViewImage.bmp");

        //    m_strErrorMessage = "";
        //    m_arrDefectList.Clear();
        //    m_arrMarkDefectList.Clear();
        //    m_arrPackageDefectList.Clear();

        //    // Check is unit size under tolerance setting or not0
        //    if (!CheckUnitEdge(objView1Gauge))
        //        return false;

        //    // Check chipped off 
        //    if ((m_intPkgFailMask & 0x02) > 0)
        //    {
        //        // In package view image
        //        objChipUnitROI.CopyToImage(ref m_objChippedOffImage);
        //        if (!InspectChipPackage(objView1Gauge.ref_ObjectCenterX, objView1Gauge.ref_ObjectCenterY,
        //                                  objView1Gauge.ref_ObjectWidth, objView1Gauge.ref_ObjectHeight,
        //                                  m_objChippedOffImage, m_intChipView1Threshold, objChipUnitROI.ref_ROITotalX, objChipUnitROI.ref_ROITotalY, 0, 0))
        //            return false;

        //        // In Crack View image
        //        if (objChipUnitROI2 != null)
        //        {
        //            objChipUnitROI2.CopyToImage(ref m_objChippedOffImage);
        //            // 2019 01 21 - CCENG:  Use objView1Gauge center point instead of objView2Gauge 
        //            //                      bcos objView1Gauge measurement result will use for image 3 (crack image).
        //            if (!InspectChipPackage(objView1Gauge.ref_ObjectCenterX, objView1Gauge.ref_ObjectCenterY,
        //                                  objView1Gauge.ref_ObjectWidth, objView1Gauge.ref_ObjectHeight,
        //                                  m_objChippedOffImage, m_intChipView2Threshold, objChipUnitROI2.ref_ROITotalX, objChipUnitROI2.ref_ROITotalY, 255, 1))
        //                return false;
        //        }
        //    }


        //    // Check package defect on first image (scratches/Contamination)
        //    if ((m_intPkgFailMask & 0x14) > 0)
        //    {
        //        if (objMarkViewROI != null)
        //            if (!InspectMarkView(objMarkViewROI))
        //                return false;

        //        // Check package defect on second image
        //        if (objPkgViewROI != null)
        //        {
        //            if (!InspectPackageView(objPkgViewROI))
        //                return false;
        //        }
        //    }

        //    // Check crack  (Hide temporary for overkill test)
        //    if ((m_intPkgFailMask & 0x01) > 0)
        //        if (!InspectCrackView(objCrackViewROI))
        //            return false;

        //    return true;
        //}


        public bool DoInspection_PackageSizeOnly(RectGaugeM4L objGauge, bool bWantCheckPackageAngle)         // use to measure unit edge
        {
            // Should Validate gauge score? (but where is the score setting???)
            m_fPackageResultWidth_px = objGauge.ref_fRectWidth;
            m_fPackageResultHeight_px = objGauge.ref_fRectHeight;
            m_fPackageResultCenterX = objGauge.ref_pRectCenterPoint.X;
            m_fPackageResultCenterY = objGauge.ref_pRectCenterPoint.Y;
            m_fPackageResultAngle = objGauge.ref_fRectAngle;
            m_blnLineResultOK = objGauge.ref_arrLineResultOK;

            if (m_blnSquareUnit)
            {
                m_fUnitResultWidth = (objGauge.ref_fRectWidth * m_fMMPerPixelX + m_fWidthOffsetMM) * m_fMMToUnitValue;
                m_fUnitResultHeight = (objGauge.ref_fRectHeight * m_fMMPerPixelY + m_fHeightOffsetMM) * m_fMMToUnitValue;
            }
            else
            {
                if ((objGauge.ref_fRectWidth * m_fMMPerPixelX * m_fMMToUnitValue <= (objGauge.ref_fRectHeight * m_fMMPerPixelY * m_fMMToUnitValue)))
                {
                    m_fUnitResultWidth = (objGauge.ref_fRectWidth * m_fMMPerPixelX + m_fWidthOffsetMM) * m_fMMToUnitValue;
                    m_fUnitResultHeight = (objGauge.ref_fRectHeight * m_fMMPerPixelY + m_fHeightOffsetMM) * m_fMMToUnitValue;
                }
                else
                {
                    m_fUnitResultHeight = (objGauge.ref_fRectWidth * m_fMMPerPixelX + m_fHeightOffsetMM) * m_fMMToUnitValue;
                    m_fUnitResultWidth = (objGauge.ref_fRectHeight * m_fMMPerPixelY + m_fWidthOffsetMM) * m_fMMToUnitValue;

                }
            }
            //m_fUnitResultWidth = objGauge.ref_fRectWidth * m_fMMPerPixelX * m_fMMToUnitValue;
            //m_fUnitResultHeight = objGauge.ref_fRectHeight * m_fMMPerPixelY * m_fMMToUnitValue;

            bool blnResult = true;

            if ((m_intPkgFailMask & 0x1000) > 0)
            {
                if (m_fUnitResultWidth < m_fUnitWidthMin)
                {
                    blnResult = false;
                    m_strErrorMessage += "*Package Width Fail. Set min=" + m_fUnitWidthMin.ToString() +
                                          " Result= " + m_fUnitResultWidth.ToString("F4");
                }

                if (m_fUnitResultWidth > m_fUnitWidthMax)
                {
                    blnResult = false;
                    m_strErrorMessage += "*Package Width Fail. Set max= " + m_fUnitWidthMax.ToString() +
                                          " Result= " + m_fUnitResultWidth.ToString("F4");
                }

                if (m_fUnitResultHeight < m_fUnitHeightMin)
                {
                    blnResult = false;
                    m_strErrorMessage += "*Package Length Fail. Set min=" + m_fUnitHeightMin.ToString() +
                                          " Result= " + m_fUnitResultHeight.ToString("F4");
                }

                if (m_fUnitResultHeight > m_fUnitHeightMax)
                {
                    blnResult = false;
                    m_strErrorMessage += "*Package Length Fail. Set max= " + m_fUnitHeightMax.ToString() +
                                          " Result= " + m_fUnitResultHeight.ToString("F4");
                }
            }

            if (bWantCheckPackageAngle)
            {
                if ((m_intPkgFailMask & 0x2000) > 0)
                {
                    if (Math.Abs(m_fPackageResultAngle) > m_fUnitAngleMax)
                    {
                        blnResult = false;
                        m_strErrorMessage += "*Package Angle Fail. Set max= " + m_fUnitAngleMax.ToString() + " deg" +
                                              " Result= " + m_fPackageResultAngle.ToString("F4") + " deg";
                    }
                }
            }
            //  m_strTrack += ", X=" + (m_fUnitResultWidth * m_fMMToPixelXValue).ToString() + ", Y=" + (m_fUnitResultHeight * m_fMMToPixelYValue).ToString();
            //  m_strTrack += ", Xmm=" + m_fUnitResultWidth.ToString() + ", Ymm=" + m_fUnitResultHeight.ToString();

            m_blnPkgSizeInspectionDone = true;
            return blnResult;
        }

        public bool DoInspection_MarkLightView(ROI objMarkViewROI,                // Package Test on first image
                                               ImageDrawing m_objMarkViewImage)   // First package image

        {
            //if (objMarkViewROI != null)
            //    objMarkViewROI.SaveImage("D:\\TS\\1-objMarkViewROI.bmp");
            //if (m_objMarkViewImage != null)
            //    m_objMarkViewImage.SaveImage("D:\\TS\\6-m_objMarkViewImage.bmp");

            // Check package defect on first image (scratches/Contamination)
            if ((m_intPkgFailMask & 0x14) > 0)
            {
                if (objMarkViewROI != null)
                    if (!InspectMarkView(objMarkViewROI))
                        return false;

            }

            return true;
        }
        

        public bool DoInspection_SideLightView(//RectGauge objUnitEdgeGauge,
                                               float fGaugeCenterX, float fGaugeCenterY, float fGaugeWidth, float fGaugeHeight,
                                               ROI objPkgViewROI,                 // Package Test on second image
                                               ROI objChipUnitROI,                // Chipped off test
                                               ImageDrawing m_objPkgViewImage,    // Second package image (option)
                                               ROI objMoldFlashROI)
        {
            //if (objPkgViewROI != null)
            //    objPkgViewROI.SaveImage("D:\\TS\\2-objPkgViewROI.bmp");
            //if (objChipUnitROI != null)
            //    objChipUnitROI.SaveImage("D:\\TS\\3-objChipUnitROI.bmp");
            //if (m_objPkgViewImage != null)
            //    m_objPkgViewImage.SaveImage("D:\\TS\\7-m_objPkgViewImage.bmp");

            // Check chipped off 
            if ((m_intPkgFailMask & 0x02) > 0)
            {
                // In package view image
                objChipUnitROI.CopyToImage(ref m_objChippedOffImage);
                m_blnBrightChipDefect = true;
                if (!InspectChipPackage_Area(fGaugeCenterX, fGaugeCenterY,
                                          fGaugeWidth, fGaugeHeight,
                                          m_objChippedOffImage, m_intChipView1Threshold, objChipUnitROI.ref_ROITotalX, objChipUnitROI.ref_ROITotalY, 0, 0))
                    return false;
            }


            // Check package defect on first image (scratches/Contamination)
            if ((m_intPkgFailMask & 0x14) > 0)
            {
                // Check package defect on second image
                if (objPkgViewROI != null)
                {
                    if (!InspectPackageView(objPkgViewROI))
                        return false;
                }
            }

            // Check Mold Flash
            if ((m_intPkgFailMask & 0x08) > 0)
            {
                if (objMoldFlashROI != null)
                {
                    if (m_blnWantLinkMoldFlashDefect)
                    {
                        if (!InspectMoldFlash_WithLinkFunction(objMoldFlashROI))
                        {
                            objMoldFlashROI.Dispose();
                            return false;
                        }
                    }
                    else
                    {
                        if (!InspectMoldFlash(objMoldFlashROI))
                        {
                            objMoldFlashROI.Dispose();
                            return false;
                        }
                    }
                    objMoldFlashROI.Dispose();
                }
            }

            return true;
        }

        public bool DoInspection_SideLightView(//RectGaugeM4L objUnitEdgeGauge,
                                               float fGaugeCenterX, float fGaugeCenterY, float fGaugeWidth, float fGaugeHeight,
                                               ROI objPkgViewROI,                 // Package Test on second image
                                               ROI objChipUnitROI,                // Chipped off test
                                               ImageDrawing m_objPkgViewImage,    // Second package image (option)
                                               ROI objMoldFlashROI,
                                               ROI objPkgViewROI_DarkField2, // Dark Field 2 ROI)
                                               ROI objPkgViewROI_DarkField3,
                                               ROI objPkgViewROI_DarkField4,
                                               ImageDrawing objWhiteImage, ImageDrawing objBlackImage)              

        {
            bool blnWantDebug = false;
            if (blnWantDebug)
            {
                if (objPkgViewROI != null)
                    objPkgViewROI.SaveImage("D:\\TS\\2-objPkgViewROI.bmp");
                if (objChipUnitROI != null)
                    objChipUnitROI.SaveImage("D:\\TS\\3-objChipUnitROI.bmp");
                if (objMoldFlashROI != null)
                    objMoldFlashROI.SaveImage("D:\\TS\\4-objMoldFlashROI.bmp");
                if (objPkgViewROI_DarkField2 != null)
                    objPkgViewROI_DarkField2.SaveImage("D:\\TS\\5-objPkgViewROI_DarkField2.bmp");
                if (objPkgViewROI_DarkField3 != null)
                    objPkgViewROI_DarkField3.SaveImage("D:\\TS\\5-objPkgViewROI_DarkField3.bmp");
                if (objPkgViewROI_DarkField4 != null)
                    objPkgViewROI_DarkField4.SaveImage("D:\\TS\\5-objPkgViewROI_DarkField4.bmp");
                if (m_objPkgViewImage != null)
                    m_objPkgViewImage.SaveImage("D:\\TS\\7-m_objPkgViewImage.bmp");
            }

            //if (m_blnUseDetailDefectCriteria)
            //{
            //    // Check chipped off 
            //    if ((m_intPkgFailMask & 0x02) > 0)
            //    {
            //        // In package view image
            //        objChipUnitROI.CopyToImage(ref m_objChippedOffImage);
            //        if (!InspectChipPackage_Area(fGaugeCenterX, fGaugeCenterY,
            //                                  fGaugeWidth, fGaugeHeight,
            //                                  m_objChippedOffImage, m_intChipView1Threshold, objChipUnitROI.ref_ROITotalX, objChipUnitROI.ref_ROITotalY, 0, 0))
            //            return false;
            //    }


            //    // Check package defect on first image (scratches/Contamination)
            //    if ((m_intPkgFailMask & 0x14) > 0)
            //    {
            //        // Check package defect on second image
            //        if (objPkgViewROI != null)
            //        {
            //            if (!InspectPackageView(objPkgViewROI))
            //                return false;
            //        }
            //    }

            //    // Check Mold Flash
            //    if ((m_intPkgFailMask & 0x08) > 0)
            //    {
            //        if (objMoldFlashROI != null)
            //        {
            //            if (m_blnWantLinkMoldFlashDefect)
            //            {
            //                if (!InspectMoldFlash_WithLinkFunction(objMoldFlashROI))
            //                {
            //                    objMoldFlashROI.Dispose();
            //                    return false;
            //                }
            //            }
            //            else
            //            {
            //                if (!InspectMoldFlash(objMoldFlashROI))
            //                {
            //                    objMoldFlashROI.Dispose();
            //                    return false;
            //                }
            //            }
            //            objMoldFlashROI.Dispose();
            //        }
            //    }
            //}
            //else
            {
                // Check Brigth Field
                if ((m_intPkgFailMask & 0x100) > 0)
                {
                    if (objPkgViewROI != null)
                    {
                        if (m_blnWantLinkBrightDefect)
                        {
                            if (!InspectionImage12BrightFieldDefect_WithLinkFunction(objPkgViewROI))
                                return false;
                        }
                        else
                        {
                            if (!InspectionImage12BrightFieldDefect(objPkgViewROI))
                                return false;
                        }
                    }
                }

                //Check chipped off
                if (m_blnSeperateChippedOffDefectSetting)
                {
                    // Check chipped off 
                    if ((m_intPkgFailMask & 0x02) > 0 && (m_arrWantDefectArea[(int)eWantDefect.ChipBright] || m_arrWantDefectLength[(int)eWantDefect.ChipBright]))
                    {
                        m_blnBrightChipDefect = true;
                        // In package view image
                        objChipUnitROI.CopyToImage(ref m_objChippedOffImage);
                        if (m_intChippedOffDefectInspectionMethod == 0)
                        {
                            if (!InspectChipPackage_Area(fGaugeCenterX, fGaugeCenterY,
                                                  fGaugeWidth, fGaugeHeight,
                                                      m_objChippedOffImage, m_intChipView1Threshold, objChipUnitROI.ref_ROITotalX, objChipUnitROI.ref_ROITotalY, 0, 0))
                                return false;
                        }
                        else
                        {
                            if (!InspectChipPackage_Area_NoSeparateDirection(fGaugeCenterX, fGaugeCenterY,
                                                  fGaugeWidth, fGaugeHeight,
                                                      m_objChippedOffImage, m_intChipView1Threshold, objChipUnitROI.ref_ROITotalX, objChipUnitROI.ref_ROITotalY, 0, 0, objWhiteImage, objBlackImage))
                                return false;
                        }
                    }
                }

                // Check Mold Flash
                if (m_blnSeperateMoldFlashDefectSetting)
                {
                    if ((m_intPkgFailMask & 0x08) > 0)
                    {
                        if (objMoldFlashROI != null)
                        {
                            if (m_blnWantLinkMoldFlashDefect)
                            {
                                if (!InspectMoldFlash_WithLinkFunction(objMoldFlashROI))
                                {
                                    objMoldFlashROI.Dispose();
                                    return false;
                                }
                            }
                            else
                            {
                                if (!InspectMoldFlash(objMoldFlashROI))
                                {
                                    objMoldFlashROI.Dispose();
                                    return false;
                                }
                            }
                            objMoldFlashROI.Dispose();
                        }
                    }
                }

                //bool m_blnDarkField2 = m_blnSeperateDarkField2DefectSetting;
                //bool m_blnDarkField3 = m_blnSeperateDarkField3DefectSetting;
                //bool m_blnDarkField4 = m_blnSeperateDarkField4DefectSetting;

                // Check Dark Field 2
                if (m_blnSeperateDarkField2DefectSetting)
                {
                    //m_blnSeperateDarkField3DefectSetting = false;
                    //m_blnSeperateDarkField4DefectSetting = false;

                    if ((m_intPkgFailMask & 0x400) > 0)
                    {
                        if (objPkgViewROI_DarkField2 != null)
                        {
                            if (m_blnWantLinkDark2Defect)
                            {
                                if (!InspectionImage12DarkField2Defect_WithLinkFunction(objPkgViewROI_DarkField2, 2))
                                {
                                    //m_blnSeperateDarkField3DefectSetting = m_blnDarkField3;
                                    //m_blnSeperateDarkField4DefectSetting = m_blnDarkField4;
                                    return false;
                                }
                            }
                            else
                            {
                                if (!InspectionImage12DarkField2Defect(objPkgViewROI_DarkField2, 2))
                                {
                                    //m_blnSeperateDarkField3DefectSetting = m_blnDarkField3;
                                    //m_blnSeperateDarkField4DefectSetting = m_blnDarkField4;
                                    return false;
                                }
                            }
                        }
                    }

                    //m_blnSeperateDarkField3DefectSetting = m_blnDarkField3;
                    //m_blnSeperateDarkField4DefectSetting = m_blnDarkField4;
                }

                if (m_blnSeperateDarkField3DefectSetting)
                {
                    //m_blnSeperateDarkField2DefectSetting = false;
                    //m_blnSeperateDarkField4DefectSetting = false;

                    if ((m_intPkgFailMask & 0x800) > 0)
                    {
                        if (objPkgViewROI_DarkField3 != null)
                        {
                            if (m_blnWantLinkDark3Defect)
                            {
                                if (!InspectionImage12DarkField2Defect_WithLinkFunction(objPkgViewROI_DarkField3, 3))
                                {
                                    //m_blnSeperateDarkField2DefectSetting = m_blnDarkField2;
                                    //m_blnSeperateDarkField4DefectSetting = m_blnDarkField4;
                                    return false;
                                }
                            }
                            else
                            {
                                if (!InspectionImage12DarkField2Defect(objPkgViewROI_DarkField3, 3))
                                {
                                    //m_blnSeperateDarkField2DefectSetting = m_blnDarkField2;
                                    //m_blnSeperateDarkField4DefectSetting = m_blnDarkField4;
                                    return false;
                                }
                            }
                        }
                    }

                    //m_blnSeperateDarkField2DefectSetting = m_blnDarkField2;
                    //m_blnSeperateDarkField4DefectSetting = m_blnDarkField4;
                }

                if (m_blnSeperateDarkField4DefectSetting)
                {
                    //m_blnSeperateDarkField2DefectSetting = false;
                    //m_blnSeperateDarkField3DefectSetting = false;

                    if ((m_intPkgFailMask & 0x4000) > 0)
                    {
                        if (objPkgViewROI_DarkField4 != null)
                        {
                            if (m_blnWantLinkDark4Defect)
                            {
                                if (!InspectionImage12DarkField2Defect_WithLinkFunction(objPkgViewROI_DarkField4, 4))
                                {
                                    //m_blnSeperateDarkField2DefectSetting = m_blnDarkField2;
                                    //m_blnSeperateDarkField3DefectSetting = m_blnDarkField3;
                                    return false;
                                }
                            }
                            else
                            {
                                if (!InspectionImage12DarkField2Defect(objPkgViewROI_DarkField4, 4))
                                {
                                    //m_blnSeperateDarkField2DefectSetting = m_blnDarkField2;
                                    //m_blnSeperateDarkField3DefectSetting = m_blnDarkField3;
                                    return false;
                                }
                            }
                        }
                    }

                    //m_blnSeperateDarkField2DefectSetting = m_blnDarkField2;
                    //m_blnSeperateDarkField3DefectSetting = m_blnDarkField3;
                }

            }
            return true;
        }
        public bool DoInspection_SideLightView(//RectGaugeM4L objUnitEdgeGauge,
                                               float fGaugeCenterX, float fGaugeCenterY, float fGaugeWidth, float fGaugeHeight,
                                               ROI objPkgViewROI,                 // Package Test on second image
                                               ROI objChipUnitROI,                // Chipped off test
                                               ImageDrawing m_objPkgViewImage,    // Second package image (option)
                                               ROI objMoldFlashROI,
                                               ROI objPkgViewROI_DarkField2,               // Dark Field 2 ROI)
                                               ROI objPkgViewROI_DarkField3,
                                               ROI objPkgViewROI_DarkField4,
                                               List<PointF> arrChippedROIPoints,
                                               ImageDrawing objWhiteImage,
                                               ImageDrawing objBlackImage,
                                               float fAngle,
                                               List<PointF> arrMoldROIPoints,
                                               ImageDrawing objBlackWhiteTopImage, ImageDrawing objBlackWhiteRightImage, ImageDrawing objBlackWhiteBottomImage, ImageDrawing objBlackWhiteLeftImage)
        {
            bool blnWantDebug = false;
            if (blnWantDebug)
            {
                if (objPkgViewROI != null)
                    objPkgViewROI.SaveImage("D:\\TS\\2-objPkgViewROI.bmp");
                if (objChipUnitROI != null)
                    objChipUnitROI.SaveImage("D:\\TS\\3-objChipUnitROI.bmp");
                if (objMoldFlashROI != null)
                    objMoldFlashROI.SaveImage("D:\\TS\\4-objMoldFlashROI.bmp");
                if (objPkgViewROI_DarkField2 != null)
                    objPkgViewROI_DarkField2.SaveImage("D:\\TS\\5-objPkgViewROI_DarkField2.bmp");
                if (m_objPkgViewImage != null)
                    m_objPkgViewImage.SaveImage("D:\\TS\\7-m_objPkgViewImage.bmp");
            }

            //if (m_blnUseDetailDefectCriteria)
            //{
            //    // Check chipped off 
            //    if ((m_intPkgFailMask & 0x02) > 0)
            //    {
            //        // In package view image
            //        objChipUnitROI.CopyToImage(ref m_objChippedOffImage);
            //        if (!InspectChipPackage_Area(fGaugeCenterX, fGaugeCenterY,
            //                                  fGaugeWidth, fGaugeHeight,
            //                                  m_objChippedOffImage, m_intChipView1Threshold, objChipUnitROI.ref_ROITotalX, objChipUnitROI.ref_ROITotalY, 0, 0))
            //            return false;
            //    }


            //    // Check package defect on first image (scratches/Contamination)
            //    if ((m_intPkgFailMask & 0x14) > 0)
            //    {
            //        // Check package defect on second image
            //        if (objPkgViewROI != null)
            //        {
            //            if (!InspectPackageView(objPkgViewROI))
            //                return false;
            //        }
            //    }

            //    // Check Mold Flash
            //    if ((m_intPkgFailMask & 0x08) > 0)
            //    {
            //        if (objMoldFlashROI != null)
            //        {
            //            if (m_blnWantLinkMoldFlashDefect)
            //            {
            //                if (!InspectMoldFlash_WithLinkFunction(objMoldFlashROI))
            //                {
            //                    objMoldFlashROI.Dispose();
            //                    return false;
            //                }
            //            }
            //            else
            //            {
            //                if (!InspectMoldFlash(objMoldFlashROI))
            //                {
            //                    objMoldFlashROI.Dispose();
            //                    return false;
            //                }
            //            }
            //            objMoldFlashROI.Dispose();
            //        }
            //    }
            //}
            //else
            {
                // Check Brigth Field
                if ((m_intPkgFailMask & 0x100) > 0)
                {
                    if (objPkgViewROI != null)
                    {
                        if (m_blnWantLinkBrightDefect)
                        {
                            if (!InspectionImage12BrightFieldDefect_WithLinkFunction(objPkgViewROI))
                                return false;
                        }
                        else
                        {
                            if (!InspectionImage12BrightFieldDefect(objPkgViewROI))
                                return false;
                        }
                    }
                }

                //Check chipped off
                if (m_blnSeperateChippedOffDefectSetting)
                {
                    // Check chipped off 
                    if ((m_intPkgFailMask & 0x02) > 0 && (m_arrWantDefectArea[(int)eWantDefect.ChipBright] || m_arrWantDefectLength[(int)eWantDefect.ChipBright]))
                    {
                        m_blnBrightChipDefect = true;
                        // In package view image
                        objChipUnitROI.CopyToImage(ref m_objChippedOffImage);
                        if (m_intChippedOffDefectInspectionMethod == 0)
                        {
                            if (!InspectChipPackage_Area(fGaugeCenterX, fGaugeCenterY,
                                                  fGaugeWidth, fGaugeHeight,
                                                  m_objChippedOffImage, m_intChipView1Threshold, objChipUnitROI.ref_ROITotalX, objChipUnitROI.ref_ROITotalY, 0, 0, arrChippedROIPoints, objWhiteImage, objBlackImage, fAngle))
                                return false;
                        }
                        else
                        {
                            if (!InspectChipPackage_Area_NoSeparateDirection(fGaugeCenterX, fGaugeCenterY,
                                                  fGaugeWidth, fGaugeHeight,
                                                  m_objChippedOffImage, m_intChipView1Threshold, objChipUnitROI.ref_ROITotalX, objChipUnitROI.ref_ROITotalY, 0, 0, arrChippedROIPoints, objWhiteImage, objBlackImage, fAngle,
                                                  objBlackWhiteTopImage, objBlackWhiteRightImage, objBlackWhiteBottomImage, objBlackWhiteLeftImage))
                                return false;
                        }
                    }
                }

                // Check Mold Flash
                if (m_blnSeperateMoldFlashDefectSetting)
                {
                    if ((m_intPkgFailMask & 0x08) > 0)
                    {
                        if (objMoldFlashROI != null)
                        {
                            if (m_blnWantLinkMoldFlashDefect)
                            {
                                if (!InspectMoldFlashArea_WithLinkFunction(objMoldFlashROI, arrMoldROIPoints))
                                {
                                    objMoldFlashROI.Dispose();
                                    return false;
                                }
                            }
                            else
                            {
                                if (!InspectMoldFlashArea(objMoldFlashROI, arrMoldROIPoints))
                                {
                                    objMoldFlashROI.Dispose();
                                    return false;
                                }
                            }
                            objMoldFlashROI.Dispose();
                        }
                    }
                }

                //bool m_blnDarkField2 = m_blnSeperateDarkField2DefectSetting;
                //bool m_blnDarkField3 = m_blnSeperateDarkField3DefectSetting;
                //bool m_blnDarkField4 = m_blnSeperateDarkField4DefectSetting;

                // Check Dark Field 2
                if (m_blnSeperateDarkField2DefectSetting)
                {
                    //m_blnSeperateDarkField3DefectSetting = false;
                    //m_blnSeperateDarkField4DefectSetting = false;

                    if ((m_intPkgFailMask & 0x400) > 0)
                    {
                        if (objPkgViewROI_DarkField2 != null)
                        {
                            if (m_blnWantLinkDark2Defect)
                            {
                                if (!InspectionImage12DarkField2Defect_WithLinkFunction(objPkgViewROI_DarkField2, 2))
                                {
                                    //m_blnSeperateDarkField3DefectSetting = m_blnDarkField3;
                                    //m_blnSeperateDarkField4DefectSetting = m_blnDarkField4;
                                    return false;
                                }
                            }
                            else
                            {
                                if (!InspectionImage12DarkField2Defect(objPkgViewROI_DarkField2, 2))
                                {
                                    //m_blnSeperateDarkField3DefectSetting = m_blnDarkField3;
                                    //m_blnSeperateDarkField4DefectSetting = m_blnDarkField4;
                                    return false;
                                }
                            }
                        }
                    }

                    //m_blnSeperateDarkField3DefectSetting = m_blnDarkField3;
                    //m_blnSeperateDarkField4DefectSetting = m_blnDarkField4;
                }

                if (m_blnSeperateDarkField3DefectSetting)
                {
                    //m_blnSeperateDarkField2DefectSetting = false;
                    //m_blnSeperateDarkField4DefectSetting = false;

                    if ((m_intPkgFailMask & 0x800) > 0)
                    {
                        if (objPkgViewROI_DarkField3 != null)
                        {
                            if (m_blnWantLinkDark3Defect)
                            {
                                if (!InspectionImage12DarkField2Defect_WithLinkFunction(objPkgViewROI_DarkField3, 3))
                                {
                                    //m_blnSeperateDarkField2DefectSetting = m_blnDarkField2;
                                    //m_blnSeperateDarkField4DefectSetting = m_blnDarkField4;
                                    return false;
                                }
                            }
                            else
                            {
                                if (!InspectionImage12DarkField2Defect(objPkgViewROI_DarkField3, 3))
                                {
                                    //m_blnSeperateDarkField2DefectSetting = m_blnDarkField2;
                                    //m_blnSeperateDarkField4DefectSetting = m_blnDarkField4;
                                    return false;
                                }
                            }
                        }
                    }
                    //m_blnSeperateDarkField2DefectSetting = m_blnDarkField2;
                    //m_blnSeperateDarkField4DefectSetting = m_blnDarkField4;
                }

                if (m_blnSeperateDarkField4DefectSetting)
                {
                    //m_blnSeperateDarkField2DefectSetting = false;
                    //m_blnSeperateDarkField3DefectSetting = false;

                    if ((m_intPkgFailMask & 0x4000) > 0)
                    {
                        if (objPkgViewROI_DarkField4 != null)
                        {
                            if (m_blnWantLinkDark4Defect)
                            {
                                if (!InspectionImage12DarkField2Defect_WithLinkFunction(objPkgViewROI_DarkField4, 4))
                                {
                                    //m_blnSeperateDarkField2DefectSetting = m_blnDarkField2;
                                    //m_blnSeperateDarkField3DefectSetting = m_blnDarkField3;
                                    return false;
                                }
                            }
                            else
                            {
                                if (!InspectionImage12DarkField2Defect(objPkgViewROI_DarkField4, 4))
                                {
                                    //m_blnSeperateDarkField2DefectSetting = m_blnDarkField2;
                                    //m_blnSeperateDarkField3DefectSetting = m_blnDarkField3;
                                    return false;
                                }
                            }
                        }
                    }
                    //m_blnSeperateDarkField2DefectSetting = m_blnDarkField2;
                    //m_blnSeperateDarkField3DefectSetting = m_blnDarkField3;
                }

            }
            return true;
        }
        public bool DoInspection_SideLightView_GrayValueThresholdMethod(//RectGaugeM4L objUnitEdgeGauge,
                                               float fGaugeCenterX, float fGaugeCenterY, float fGaugeWidth, float fGaugeHeight,
                                               ROI objPkgViewROI,                 // Package Test on second image
                                               ROI objChipUnitROI,                // Chipped off test
                                               ImageDrawing m_objPkgViewImage,    // Second package image (option)
                                               ImageDrawing m_objGrayValueImage,
                                               ROI objMoldFlashROI,
                                               int intInspectionAreaGrayValueSensitivity,
                                               int intMergeSensitivity,
                                               int intBrightSensitivity,
                                               ImageDrawing objWhiteImage,
                                               ImageDrawing objBlackImage)
        {
            // Check Brigth Field
            if ((m_intPkgFailMask & 0x100) > 0)
            {
                if (objPkgViewROI != null)
                {
                        if (!InspectionImage12BrightFieldDefect(m_objGrayValueImage, objPkgViewROI, intInspectionAreaGrayValueSensitivity, intMergeSensitivity, intBrightSensitivity))
                            return false;
                }
            }

            //Check chipped off
            if (m_blnSeperateChippedOffDefectSetting)
            {
                // Check chipped off 
                if ((m_intPkgFailMask & 0x02) > 0 && (m_arrWantDefectArea[(int)eWantDefect.ChipBright] || m_arrWantDefectLength[(int)eWantDefect.ChipBright]))
                {
                    m_blnBrightChipDefect = true;
                    // In package view image
                    objChipUnitROI.CopyToImage(ref m_objChippedOffImage);
                    if (m_intChippedOffDefectInspectionMethod == 0)
                    {
                        if (!InspectChipPackage_Area(fGaugeCenterX, fGaugeCenterY,
                                              fGaugeWidth, fGaugeHeight,
                                              m_objChippedOffImage, m_intChipView1Threshold, objChipUnitROI.ref_ROITotalX, objChipUnitROI.ref_ROITotalY, 0, 0))
                            return false;
                    }
                    else
                    {
                        if (!InspectChipPackage_Area_NoSeparateDirection(fGaugeCenterX, fGaugeCenterY,
                                              fGaugeWidth, fGaugeHeight,
                                              m_objChippedOffImage, m_intChipView1Threshold, objChipUnitROI.ref_ROITotalX, objChipUnitROI.ref_ROITotalY, 0, 0, objWhiteImage, objBlackImage))
                            return false;
                    }
                }
            }

            // Check Mold Flash
            if (m_blnSeperateMoldFlashDefectSetting)
            {
                if ((m_intPkgFailMask & 0x08) > 0)
                {
                    if (objMoldFlashROI != null)
                    {
                        if (m_blnWantLinkMoldFlashDefect)
                        {
                            if (!InspectMoldFlash_WithLinkFunction(objMoldFlashROI))
                            {
                                objMoldFlashROI.Dispose();
                                return false;
                            }
                        }
                        else
                        {
                            if (!InspectMoldFlash(objMoldFlashROI))
                            {
                                objMoldFlashROI.Dispose();
                                return false;
                            }
                        }
                        objMoldFlashROI.Dispose();
                    }
                }
            }

            return true;
        }
        public bool DoInspection_SideLightView_GrayValueThresholdMethod(//RectGaugeM4L objUnitEdgeGauge,
                                              float fGaugeCenterX, float fGaugeCenterY, float fGaugeWidth, float fGaugeHeight,
                                              ROI objPkgViewROI,                 // Package Test on second image
                                              ROI objChipUnitROI,                // Chipped off test
                                              ImageDrawing m_objPkgViewImage,    // Second package image (option)
                                              ImageDrawing m_objGrayValueImage,
                                              ROI objMoldFlashROI,
                                              int intInspectionAreaGrayValueSensitivity,
                                              int intMergeSensitivity,
                                              int intBrightSensitivity,
                                              List<PointF> arrChippedROIPoints,
                                              ImageDrawing objWhiteImage,
                                              ImageDrawing objBlackImage,
                                              float fAngle,
                                               List<PointF> arrMoldROIPoints,
                                               ImageDrawing objBlackWhiteTopImage, ImageDrawing objBlackWhiteRightImage, ImageDrawing objBlackWhiteBottomImage, ImageDrawing objBlackWhiteLeftImage)
        {
            // Check Brigth Field
            if ((m_intPkgFailMask & 0x100) > 0)
            {
                if (objPkgViewROI != null)
                {
                    if (!InspectionImage12BrightFieldDefect(m_objGrayValueImage, objPkgViewROI, intInspectionAreaGrayValueSensitivity, intMergeSensitivity, intBrightSensitivity))
                        return false;
                }
            }

            //Check chipped off
            if (m_blnSeperateChippedOffDefectSetting)
            {
                // Check chipped off 
                if ((m_intPkgFailMask & 0x02) > 0 && (m_arrWantDefectArea[(int)eWantDefect.ChipBright] || m_arrWantDefectLength[(int)eWantDefect.ChipBright]))
                {
                    m_blnBrightChipDefect = true;
                    // In package view image
                    objChipUnitROI.CopyToImage(ref m_objChippedOffImage);
                    if (m_intChippedOffDefectInspectionMethod == 0)
                    {
                        if (!InspectChipPackage_Area(fGaugeCenterX, fGaugeCenterY,
                                              fGaugeWidth, fGaugeHeight,
                                              m_objChippedOffImage, m_intChipView1Threshold, objChipUnitROI.ref_ROITotalX, objChipUnitROI.ref_ROITotalY, 0, 0, arrChippedROIPoints, objWhiteImage, objBlackImage, fAngle))
                            return false;
                    }
                    else
                    {
                        if (!InspectChipPackage_Area_NoSeparateDirection(fGaugeCenterX, fGaugeCenterY,
                                              fGaugeWidth, fGaugeHeight,
                                              m_objChippedOffImage, m_intChipView1Threshold, objChipUnitROI.ref_ROITotalX, objChipUnitROI.ref_ROITotalY, 0, 0, arrChippedROIPoints, objWhiteImage, objBlackImage, fAngle,
                                              objBlackWhiteTopImage, objBlackWhiteRightImage, objBlackWhiteBottomImage, objBlackWhiteLeftImage))
                            return false;
                    }
                }
            }

            // Check Mold Flash
            if (m_blnSeperateMoldFlashDefectSetting)
            {
                if ((m_intPkgFailMask & 0x08) > 0)
                {
                    if (objMoldFlashROI != null)
                    {
                        if (m_blnWantLinkMoldFlashDefect)
                        {
                            if (!InspectMoldFlashArea_WithLinkFunction(objMoldFlashROI, arrMoldROIPoints))
                            {
                                objMoldFlashROI.Dispose();
                                return false;
                            }
                        }
                        else
                        {
                            if (!InspectMoldFlashArea(objMoldFlashROI, arrMoldROIPoints))
                            {
                                objMoldFlashROI.Dispose();
                                return false;
                            }
                        }
                        objMoldFlashROI.Dispose();
                    }
                }
            }

            return true;
        }
        public bool DoInspection_TopLightView(//RectGauge objUnitEdgeGauge,         // use to measure unit edge
            float fGaugeCenterX, float fGaugeCenterY, float fGaugeWidth, float fGaugeHeight,
         ROI objCrackViewROI,               // Crack test
         ROI objChipUnitROI2,               // Chipped off test on third image
         ROI objVoidUnitROI, //Void Test using Image 3
         ImageDrawing m_objCrackViewImage,  // Image from Top light source
         ImageDrawing objWhiteImage, ImageDrawing objBlackImage)
        {
            //if (objCrackViewROI != null)
            //    objCrackViewROI.SaveImage("D:\\TS\\4-objCrackViewROI.bmp");
            //if (objChipUnitROI2 != null)
            //    objChipUnitROI2.SaveImage("D:\\TS\\5-objChipUnitROI2.bmp");
            //if (m_objCrackViewImage != null)
            //    m_objCrackViewImage.SaveImage("D:\\TS\\8-m_objCrackViewImage.bmp");
            //if (m_blnUseDetailDefectCriteria)
            //{

            //    //Check chipped off
            //    if ((m_intPkgFailMask & 0x02) > 0)
            //    {
            //        // In Crack View image
            //        if (objChipUnitROI2 != null)
            //        {
            //            objChipUnitROI2.CopyToImage(ref m_objChippedOffImage);
            //            // 2019 01 21 - CCENG:  Use objView1Gauge center point instead of objView2Gauge 
            //            //                      bcos objView1Gauge measurement result will use for image 3 (crack image).
            //            m_blnBrightChipDefect = false;
            //            if (!InspectChipPackage_Area(fGaugeCenterX, fGaugeCenterY,
            //                                  fGaugeWidth, fGaugeHeight,
            //                                  m_objChippedOffImage, m_intChipView2Threshold, objChipUnitROI2.ref_ROITotalX, objChipUnitROI2.ref_ROITotalY, 255, 1))
            //                return false;
            //        }
            //    }

            //    // Check crack  (Hide temporary for overkill test)
            //    if ((m_intPkgFailMask & 0x01) > 0)
            //        if (!InspectCrackView(objCrackViewROI))
            //            return false;

            //    // Check Void 
            //    if ((m_intPkgFailMask & 0x20) > 0)
            //    {
            //        if (objVoidUnitROI != null)
            //        {
            //            objVoidUnitROI.CopyToImage(ref m_objVoidViewImage);
            //            // m_objVoidViewImage.SaveImage("D:\\m_objVoidViewImage.bmp");
            //            // 2019 01 21 - CCENG:  Use objView1Gauge center point instead of objView2Gauge 
            //            //                      bcos objView1Gauge measurement result will use for image 3 (crack image).
            //            if (!InspectVoidPackage(fGaugeCenterX, fGaugeCenterY,
            //                                  fGaugeWidth, fGaugeHeight,
            //                                  m_objVoidViewImage, m_intVoidViewThreshold, objVoidUnitROI.ref_ROITotalX, objVoidUnitROI.ref_ROITotalY, 255))
            //                return false;
            //        }

            //    }
            //}
            //else
            {
                // Check Dark Field
                if ((m_intPkgFailMask & 0x200) > 0)
                {
                    if (m_blnWantLinkDarkDefect)
                    {
                        if (!InspectionImage3DarkFieldDefect_WithLinkFunction(objCrackViewROI))
                            return false;
                    }
                    else
                    {
                        if (!InspectionImage3DarkFieldDefect(objCrackViewROI))
                            return false;
                    }
                }

                //Check chipped off
                if (m_blnSeperateChippedOffDefectSetting)
                {
                    if ((m_intPkgFailMask & 0x02) > 0 && (m_arrWantDefectArea[(int)eWantDefect.ChipDark] || m_arrWantDefectLength[(int)eWantDefect.ChipDark]))
                    {
                        // In Crack View image
                        if (objChipUnitROI2 != null)
                        {
                            objChipUnitROI2.CopyToImage(ref m_objChippedOffImage);
                            // 2019 01 21 - CCENG:  Use objView1Gauge center point instead of objView2Gauge 
                            //                      bcos objView1Gauge measurement result will use for image 3 (crack image).
                            m_blnBrightChipDefect = false;
                            if (m_intChippedOffDefectInspectionMethod== 0)
                            {
                                if (!InspectChipPackage_Area(fGaugeCenterX, fGaugeCenterY,
                                                  fGaugeWidth, fGaugeHeight,
                                                  m_objChippedOffImage, m_intChipView2Threshold, objChipUnitROI2.ref_ROITotalX, objChipUnitROI2.ref_ROITotalY, 255, 1))
                                    return false;
                            }
                            else
                            {
                                if (!InspectChipPackage_Area_NoSeparateDirection(fGaugeCenterX, fGaugeCenterY,
                                                  fGaugeWidth, fGaugeHeight,
                                                  m_objChippedOffImage, m_intChipView2Threshold, objChipUnitROI2.ref_ROITotalX, objChipUnitROI2.ref_ROITotalY, 255, 1,
                                                  objWhiteImage, objBlackImage))
                                    return false;
                            }
                        }
                    }
                }

                // Check Crack Field
                if (m_blnSeperateCrackDefectSetting)
                {
                    if ((m_intPkgFailMask & 0x01) > 0)
                    {
                        if (m_blnWantLinkCrackDefect)
                        {
                            if (!InspectCrackView_WithLinkFunction(objCrackViewROI))
                                return false;
                        }
                        else
                        {
                            if (!InspectCrackView(objCrackViewROI))
                                return false;
                        }
                    }
                }
            }

            return true;
        }
        public bool DoInspection_TopLightView(//RectGauge objUnitEdgeGauge,         // use to measure unit edge
           float fGaugeCenterX, float fGaugeCenterY, float fGaugeWidth, float fGaugeHeight,
        ROI objCrackViewROI,               // Crack test
        ROI objChipUnitROI2,               // Chipped off test on third image
        //ROI objVoidUnitROI, //Void Test using Image 3
        ImageDrawing m_objCrackViewImage,  // Image from Top light source
        List<PointF> arrChippedROIPoints,
        ImageDrawing objWhiteImage,
        ImageDrawing objBlackImage,
        float fAngle,
        ImageDrawing objBlackWhiteTopImage, ImageDrawing objBlackWhiteRightImage, ImageDrawing objBlackWhiteBottomImage, ImageDrawing objBlackWhiteLeftImage)
        {
            bool blnDebug = false;

            if (blnDebug)
            {
                if (objCrackViewROI != null)
                    objCrackViewROI.SaveImage("D:\\TS\\4-objCrackViewROI.bmp");
                if (objChipUnitROI2 != null)
                    objChipUnitROI2.SaveImage("D:\\TS\\5-objChipUnitROI2.bmp");
                if (m_objCrackViewImage != null)
                    m_objCrackViewImage.SaveImage("D:\\TS\\8-m_objCrackViewImage.bmp");
            }

            //if (m_blnUseDetailDefectCriteria)
            //{

            //    //Check chipped off
            //    if ((m_intPkgFailMask & 0x02) > 0)
            //    {
            //        // In Crack View image
            //        if (objChipUnitROI2 != null)
            //        {
            //            objChipUnitROI2.CopyToImage(ref m_objChippedOffImage);
            //            // 2019 01 21 - CCENG:  Use objView1Gauge center point instead of objView2Gauge 
            //            //                      bcos objView1Gauge measurement result will use for image 3 (crack image).
            //            m_blnBrightChipDefect = false;
            //            if (!InspectChipPackage_Area(fGaugeCenterX, fGaugeCenterY,
            //                                  fGaugeWidth, fGaugeHeight,
            //                                  m_objChippedOffImage, m_intChipView2Threshold, objChipUnitROI2.ref_ROITotalX, objChipUnitROI2.ref_ROITotalY, 255, 1))
            //                return false;
            //        }
            //    }

            //    // Check crack  (Hide temporary for overkill test)
            //    if ((m_intPkgFailMask & 0x01) > 0)
            //        if (!InspectCrackView(objCrackViewROI))
            //            return false;

            //    //// Check Void 
            //    //if ((m_intPkgFailMask & 0x20) > 0)
            //    //{
            //    //    if (objVoidUnitROI != null)
            //    //    {
            //    //        objVoidUnitROI.CopyToImage(ref m_objVoidViewImage);
            //    //        // m_objVoidViewImage.SaveImage("D:\\m_objVoidViewImage.bmp");
            //    //        // 2019 01 21 - CCENG:  Use objView1Gauge center point instead of objView2Gauge 
            //    //        //                      bcos objView1Gauge measurement result will use for image 3 (crack image).
            //    //        if (!InspectVoidPackage(fGaugeCenterX, fGaugeCenterY,
            //    //                              fGaugeWidth, fGaugeHeight,
            //    //                              m_objVoidViewImage, m_intVoidViewThreshold, objVoidUnitROI.ref_ROITotalX, objVoidUnitROI.ref_ROITotalY, 255))
            //    //            return false;
            //    //    }

            //    //}
            //}
            //else
            {
                // Check Dark Field
                if ((m_intPkgFailMask & 0x200) > 0)
                {
                    if (m_blnWantLinkDarkDefect)
                    {
                        if (!InspectionImage3DarkFieldDefect_WithLinkFunction(objCrackViewROI))
                            return false;
                    }
                    else
                    {
                        if (!InspectionImage3DarkFieldDefect(objCrackViewROI))
                            return false;
                    }
                }

                //Check chipped off
                if (m_blnSeperateChippedOffDefectSetting)
                {
                    if ((m_intPkgFailMask & 0x02) > 0 && (m_arrWantDefectArea[(int)eWantDefect.ChipDark] || m_arrWantDefectLength[(int)eWantDefect.ChipDark]))
                    {
                        // In Crack View image
                        if (objChipUnitROI2 != null)
                        {
                            objChipUnitROI2.CopyToImage(ref m_objChippedOffImage);
                            // 2019 01 21 - CCENG:  Use objView1Gauge center point instead of objView2Gauge 
                            //                      bcos objView1Gauge measurement result will use for image 3 (crack image).
                            m_blnBrightChipDefect = false;
                            if (m_intChippedOffDefectInspectionMethod == 0)
                            {
                                if (!InspectChipPackage_Area(fGaugeCenterX, fGaugeCenterY,
                                                  fGaugeWidth, fGaugeHeight,
                                                  m_objChippedOffImage, m_intChipView2Threshold, objChipUnitROI2.ref_ROITotalX, objChipUnitROI2.ref_ROITotalY, 255, 1, arrChippedROIPoints, objWhiteImage, objBlackImage, fAngle))
                                    return false;
                            }
                            else
                            {
                                if (!InspectChipPackage_Area_NoSeparateDirection(fGaugeCenterX, fGaugeCenterY,
                                                  fGaugeWidth, fGaugeHeight,
                                                  m_objChippedOffImage, m_intChipView2Threshold, objChipUnitROI2.ref_ROITotalX, objChipUnitROI2.ref_ROITotalY, 255, 1, arrChippedROIPoints, objWhiteImage, objBlackImage, fAngle,
                                                  objBlackWhiteTopImage, objBlackWhiteRightImage, objBlackWhiteBottomImage, objBlackWhiteLeftImage))
                                    return false;
                            }
                        }
                    }
                }

                // Check Crack Field
                if (m_blnSeperateCrackDefectSetting)
                {
                   
                    if ((m_intPkgFailMask & 0x01) > 0)
                    {
                        if (m_blnWantLinkCrackDefect)
                        {
                            if (!InspectCrackView_WithLinkFunction(objCrackViewROI))
                                return false;
                        }
                        else
                        {
                            if (!InspectCrackView(objCrackViewROI))
                                return false;
                        }
                    }
                }
            }

            return true;
        }
        public bool DoInspection_TopLightView_GrayValueThresholdMethod(//RectGauge objUnitEdgeGauge,         // use to measure unit edge
            float fGaugeCenterX, float fGaugeCenterY, float fGaugeWidth, float fGaugeHeight,
         ROI objCrackViewROI,               // Crack test
         ROI objChipUnitROI2,               // Chipped off test on third image
         ROI objVoidUnitROI, //Void Test using Image 3
         ImageDrawing m_objCrackViewImage,  // Image from Top light source
         ImageDrawing objGrayValueImage,
                                               int intInspectionAreaGrayValueSensitivity,
                                               int intMergeSensitivity,
                                               int intDarkSensitivity,
        ImageDrawing objWhiteImage,
        ImageDrawing objBlackImage)
        {
            // Check Dark Field
            if ((m_intPkgFailMask & 0x200) > 0)
            {
                if (!InspectionImage3DarkFieldDefect(objGrayValueImage, objCrackViewROI, intInspectionAreaGrayValueSensitivity, intMergeSensitivity, intDarkSensitivity))
                    return false;
            }

            //Check chipped off
            if (m_blnSeperateChippedOffDefectSetting)
            {
                if ((m_intPkgFailMask & 0x02) > 0 && (m_arrWantDefectArea[(int)eWantDefect.ChipDark] || m_arrWantDefectLength[(int)eWantDefect.ChipDark]))
                {
                    // In Crack View image
                    if (objChipUnitROI2 != null)
                    {
                        objChipUnitROI2.CopyToImage(ref m_objChippedOffImage);
                        // 2019 01 21 - CCENG:  Use objView1Gauge center point instead of objView2Gauge 
                        //                      bcos objView1Gauge measurement result will use for image 3 (crack image).
                        m_blnBrightChipDefect = false;
                        if (m_intChippedOffDefectInspectionMethod == 0)
                        {
                            if (!InspectChipPackage_Area(fGaugeCenterX, fGaugeCenterY,
                                              fGaugeWidth, fGaugeHeight,
                                              m_objChippedOffImage, m_intChipView2Threshold, objChipUnitROI2.ref_ROITotalX, objChipUnitROI2.ref_ROITotalY, 255, 1))
                                return false;
                        }
                        else
                        {
                            if (!InspectChipPackage_Area_NoSeparateDirection(fGaugeCenterX, fGaugeCenterY,
                                              fGaugeWidth, fGaugeHeight,
                                              m_objChippedOffImage, m_intChipView2Threshold, objChipUnitROI2.ref_ROITotalX, objChipUnitROI2.ref_ROITotalY, 255, 1, objWhiteImage, objBlackImage))
                                return false;
                        }
                    }
                }
            }

            // Check Crack Field
            if (m_blnSeperateCrackDefectSetting)
            {
               
                if ((m_intPkgFailMask & 0x01) > 0)
                {
                    if (m_blnWantLinkCrackDefect)
                    {
                        if (!InspectCrackView_WithLinkFunction(objCrackViewROI))
                            return false;
                    }
                    else
                    {
                        if (!InspectCrackView(objCrackViewROI))
                            return false;
                    }
                }
            }
            return true;
        }
        public bool DoInspection_TopLightView_GrayValueThresholdMethod(//RectGauge objUnitEdgeGauge,         // use to measure unit edge
           float fGaugeCenterX, float fGaugeCenterY, float fGaugeWidth, float fGaugeHeight,
        ROI objCrackViewROI,               // Crack test
        ROI objChipUnitROI2,               // Chipped off test on third image
        //ROI objVoidUnitROI, //Void Test using Image 3
        ImageDrawing m_objCrackViewImage,  // Image from Top light source
        ImageDrawing objGrayValueImage,
        int intInspectionAreaGrayValueSensitivity,
        int intMergeSensitivity,
        int intDarkSensitivity,
        List<PointF> arrChippedROIPoints,
        ImageDrawing objWhiteImage,
        ImageDrawing objBlackImage,
        float fAngle,
        ImageDrawing objBlackWhiteTopImage, ImageDrawing objBlackWhiteRightImage, ImageDrawing objBlackWhiteBottomImage, ImageDrawing objBlackWhiteLeftImage)
        {
            // Check Dark Field
            if ((m_intPkgFailMask & 0x200) > 0)
            {
                if (!InspectionImage3DarkFieldDefect(objGrayValueImage, objCrackViewROI, intInspectionAreaGrayValueSensitivity, intMergeSensitivity, intDarkSensitivity))
                    return false;
            }

            //Check chipped off
            if (m_blnSeperateChippedOffDefectSetting)
            {
                if ((m_intPkgFailMask & 0x02) > 0 && (m_arrWantDefectArea[(int)eWantDefect.ChipDark] || m_arrWantDefectLength[(int)eWantDefect.ChipDark]))
                {
                    // In Crack View image
                    if (objChipUnitROI2 != null)
                    {
                        objChipUnitROI2.CopyToImage(ref m_objChippedOffImage);
                        // 2019 01 21 - CCENG:  Use objView1Gauge center point instead of objView2Gauge 
                        //                      bcos objView1Gauge measurement result will use for image 3 (crack image).
                        m_blnBrightChipDefect = false;
                        if (m_intChippedOffDefectInspectionMethod == 0)
                        {
                            if (!InspectChipPackage_Area(fGaugeCenterX, fGaugeCenterY,
                                              fGaugeWidth, fGaugeHeight,
                                              m_objChippedOffImage, m_intChipView2Threshold, objChipUnitROI2.ref_ROITotalX, objChipUnitROI2.ref_ROITotalY, 255, 1, arrChippedROIPoints, objWhiteImage, objBlackImage, fAngle))
                                return false;
                        }
                        else
                        {
                            if (!InspectChipPackage_Area_NoSeparateDirection(fGaugeCenterX, fGaugeCenterY,
                                              fGaugeWidth, fGaugeHeight,
                                              m_objChippedOffImage, m_intChipView2Threshold, objChipUnitROI2.ref_ROITotalX, objChipUnitROI2.ref_ROITotalY, 255, 1, arrChippedROIPoints, objWhiteImage, objBlackImage, fAngle,
                                              objBlackWhiteTopImage, objBlackWhiteRightImage, objBlackWhiteBottomImage, objBlackWhiteLeftImage))
                                return false;
                        }
                    }
                }
            }

            // Check Crack Field
            if (m_blnSeperateCrackDefectSetting)
            {
                if ((m_intPkgFailMask & 0x01) > 0)
                {
                    if (m_blnWantLinkCrackDefect)
                    {
                        if (!InspectCrackView_WithLinkFunction(objCrackViewROI))
                            return false;
                    }
                    else
                    {
                        if (!InspectCrackView(objCrackViewROI))
                            return false;
                    }
                }
            }
            return true;
        }
        private bool InspectVoidPackage(float fCenterX, float fCenterY, float fWidth, float fHeight, ImageDrawing objImage, int intThreshold,
                                        int intTotalROIStartX, int intTotalROIStartY, int intVoidLineLimitPixelValue)
        {
            if (objImage.ref_intImageHeight == 0 || objImage.ref_intImageWidth == 0)
                return true;

            if ((m_intPkgFailMask & 0x20) == 0)
                return true;

            int intSelectedImageIndex;

            if (intVoidLineLimitPixelValue == 0)    // White field defect
            {
                intSelectedImageIndex = m_arrGrabImageIndex[2];
            }
            else // Black field defect (Crack, void, chip)
            {
                intSelectedImageIndex = m_arrGrabImageIndex[3];
            }

            ROI objBlobsROI = new ROI();
            objBlobsROI.AttachImage(objImage);
            objBlobsROI.LoadROISetting(0, 0, objImage.ref_intImageWidth, objImage.ref_intImageHeight);

            bool bWhiteOnBlack;
            if (intVoidLineLimitPixelValue == 0)
                bWhiteOnBlack = true;    // detect white on black - white is the chip
            else
                bWhiteOnBlack = false;   // detect black on white - black is the chip

            int intSelectedObject = m_objPackageEBlobs.BuildObjects_Filter_GetElement(objBlobsROI, !bWhiteOnBlack, true, 0, intThreshold,
                m_intVoidViewMinArea, 1000, true, 0x1F);// 0x0D);

            if (intSelectedObject > 0)
            {
                int intObjectArea = 0;
                int intObjectTotalArea = 0;
                float fObjectHeight = 0, fObjectWidth = 0, fObjectCenterX = 0, fObjectCenterY = 0;
                bool blnOverAllFail = false;
                for (int i = 0; i < intSelectedObject; i++)
                {
                    intObjectArea = m_objPackageEBlobs.ref_arrArea[i];
                    fObjectHeight = m_objPackageEBlobs.ref_arrHeight[i];
                    fObjectWidth = m_objPackageEBlobs.ref_arrWidth[i];
                    fObjectCenterX = m_objPackageEBlobs.ref_arrLimitCenterX[i];
                    fObjectCenterY = m_objPackageEBlobs.ref_arrLimitCenterY[i];
                    intObjectTotalArea += intObjectArea;

                    int j;
                    for (j = 0; j < m_arrDontCareArea.Count; j++)
                    {
                        if ((intTotalROIStartX + fObjectCenterX > m_arrDontCareArea[j][0].X) && (intTotalROIStartY + fObjectCenterY > m_arrDontCareArea[j][0].Y) &&
                            (intTotalROIStartX + fObjectCenterX < m_arrDontCareArea[j][1].X) && (intTotalROIStartY + fObjectCenterY < m_arrDontCareArea[j][1].Y))
                        {
                            break;
                        }
                    }
                    if (j < m_arrDontCareArea.Count)
                    {
                        continue;
                    }

                    float Max = Math.Max(fObjectHeight, fObjectWidth);
                    float Min = Math.Min(fObjectHeight, fObjectWidth);

                    //if (Max / Min > 1.5)
                    //{
                    //    continue;
                    //}

                    //if (Max / Min <= 1.5)
                    //{
                    //    if ((intObjectArea / (fObjectHeight * fObjectWidth)) < 0.5)
                    //    {
                    //        continue;
                    //    }
                    //}

                    bool blnFail = false;
                    int intFailMask = 0;
                    string strDefectName = "Void";
                    if (m_arrWantDefectLength[(int)eWantDefect.Void])
                    {
                        if (fObjectWidth >= GetDefect("Void", 0))
                        {
                            //m_strErrorMessage += "*Fail Crack View Package - Cracked. Set = " + (m_arrDefectHorizontal[0] / m_fMMToPixelXValue).ToString("f5") + " mm,   Result = " + (Math.Max(fObjectWidth, fObjectHeight) / m_fMMToPixelXValue).ToString("f5") + " mm";
                            m_strErrorMessage += "* Void Width Package Fail. Set = " + (GetDefect("Void", 0) / m_fMMToPixelXValue).ToString("f5") + " mm,   Result = " + (fObjectWidth / m_fMMToPixelXValue).ToString("f5") + " mm";
                            blnFail = true;
                            intFailMask |= 0x01;
                            strDefectName = "Void";
                        }

                        if (fObjectHeight >= GetDefect("Void", 1))
                        {
                            //m_strErrorMessage += "*Fail Crack View Package - Cracked. Set = " + (m_arrDefectVertical[0] / m_fMMToPixelXValue).ToString("f5") + " mm,   Result = " + (Math.Max(fObjectWidth, fObjectHeight) / m_fMMToPixelXValue).ToString("f5") + " mm";
                            m_strErrorMessage += "* Void Height Package Fail. Set = " + (GetDefect("Void", 1) / m_fMMToPixelYValue).ToString("f5") + " mm,   Result = " + (fObjectHeight / m_fMMToPixelYValue).ToString("f5") + " mm";
                            blnFail = true;
                            intFailMask |= 0x02;
                            strDefectName = "Void";
                        }
                    }

                    if (m_arrWantDefectArea[(int)eWantDefect.Void])
                    {
                        if (intObjectArea >= GetAreaDefect("Void"))
                        {
                            //m_strErrorMessage += "*Fail Crack View Package - Cracked. Set = " + (m_arrDefectArea[0] / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                            m_strErrorMessage += "* Void Area Package Fail. Set = " + (GetAreaDefect("Void") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                            blnFail = true;
                            intFailMask |= 0x04;
                            strDefectName = "Void";
                        }
                    }

                    if (blnFail)
                    {
                        Defect objDefect = new Defect();
                        objDefect.ref_fDimX = fObjectWidth;
                        objDefect.ref_fDimY = fObjectHeight;
                        objDefect.ref_intLengthMode = 0;
                        objDefect.ref_fArea = intObjectArea;
                        objDefect.ref_fCenterX = intTotalROIStartX + fObjectCenterX;
                        objDefect.ref_fCenterY = intTotalROIStartY + fObjectCenterY;
                        objDefect.ref_intBlobNo = i;
                        objDefect.ref_intFailMask = intFailMask;
                        objDefect.ref_strName = strDefectName;
                        objDefect.ref_intFailedImage = intSelectedImageIndex + 1;
                        m_arrDefectList.Add(objDefect);

                        if (!blnOverAllFail)
                            blnOverAllFail = true;
                    }
                    else
                    {
                        Defect objDefect = new Defect();
                        objDefect.ref_fDimX = fObjectWidth;
                        objDefect.ref_fDimY = fObjectHeight;
                        objDefect.ref_intLengthMode = 0;
                        objDefect.ref_fArea = intObjectArea;
                        objDefect.ref_fCenterX = intTotalROIStartX + fObjectCenterX;
                        objDefect.ref_fCenterY = intTotalROIStartY + fObjectCenterY;
                        objDefect.ref_intBlobNo = i;
                        objDefect.ref_intFailMask = 0;
                        objDefect.ref_strName = strDefectName;
                        objDefect.ref_intFailedImage = intSelectedImageIndex + 1;
                        m_arrDefectList.Add(objDefect);
                    }
                }

                if (m_arrWantDefectArea[(int)eWantDefect.Void])
                {
                    if (intObjectTotalArea >= GetTotalAreaDefect("Void"))
                    {
                        m_strErrorMessage += "* Void Total Area Package Fail. Set = " + (GetTotalAreaDefect("Void") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectTotalArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        m_blnPkgViewFailTotalArea = true;

                        Defect objDefect = new Defect();
                        objDefect.ref_fDimX = m_objPackageEBlobs.ref_arrWidth[0];
                        objDefect.ref_fDimY = m_objPackageEBlobs.ref_arrHeight[0];
                        objDefect.ref_intLengthMode = 0;
                        objDefect.ref_fArea = m_objPackageEBlobs.ref_arrArea[0];
                        objDefect.ref_fCenterX = intTotalROIStartX + m_objPackageEBlobs.ref_arrLimitCenterX[0];
                        objDefect.ref_fCenterY = intTotalROIStartY + m_objPackageEBlobs.ref_arrLimitCenterY[0];
                        objDefect.ref_intFailMask |= 0x04;
                        objDefect.ref_strName = "Void";
                        objDefect.ref_intFailedImage = intSelectedImageIndex + 1;
                        m_arrDefectList.Add(objDefect);

                        if (!blnOverAllFail)
                            blnOverAllFail = true;
                    }
                }

                if (blnOverAllFail)
                    return false;
                else
                    return true;
            }
            return true;
        }

        /// <summary>
        /// Return defect parameter by refering to its name, all values are return in pixel 
        /// if no set advance setting for crack, void, mold flash, use 2 for all bright(scratch, contamination, mold flash), 4 for all dark(crack, void), 1 always for chip only
        /// </summary>
        /// <param name="intDefectNo">Defect No :  0=crack, 1=chip, 2=bright, 3=mold, 4=dark, 5=void</param>
        /// <param name="intType">0=Horizontal, 1=Vertical</param>
        public float GetDefectParam(int intDefectNo, int intType)
        {
            if (intType == 0)
                return m_arrDefectHorizontal[intDefectNo];
            else
                return m_arrDefectVertical[intDefectNo];
        }

        /// <summary>
        /// Return defect parameter by refering to its name, all values are return in pixel 
        /// if no set advance setting for crack, void, mold flash, use 2 for all bright(scratch, contamination, mold flash), 4 for all dark(crack, void), 1 always for chip only
        /// </summary>
        /// <param name="intDefectNo">Defect No :  0=crack, 1=chip(bright), 2=bright, 3=mold, 4=dark, 5=void, 6=chip(dark)</param>
        public float GetDefectAreaParam(int intDefectNo)
        {
            return m_arrDefectArea[intDefectNo];
        }

        /// <summary>
        /// Return defect parameter by refering to its name, all values are return in pixel 
        /// if no set advance setting for crack, void, mold flash, use 2 for all bright(scratch, contamination, mold flash), 4 for all dark(crack, void), 1 for chip(bright), 6 for chip(dark)
        /// </summary>
        /// <param name="intDefectNo">Defect No :  0=crack, 1=chip, 2=bright, 3=mold, 4=dark, 5=void</param>
        public float GetDefectTotalAreaParam(int intDefectNo)
        {
            return m_arrDefectTotalArea[intDefectNo];
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="intDefectNo">0=crack, 1=chip, 2=bright, 3=mold, 4=dark, 5=void</param>
        /// <returns></returns>
        public bool GetWantDefectParam(int intDefectNo)
        {
            return m_arrWantDefectLength[intDefectNo];
        }

        public bool GetWantInspectPackage()
        {
            return m_blnInspectPackage;
        }
        public void SetWantInspectPackage(bool bWantDefect)
        {
            m_blnInspectPackage = bWantDefect;
        }
        public bool GetWantDefectAreaParam(int intDefectNo)
        {
            return m_arrWantDefectArea[intDefectNo];
        }

        /// <summary>
        /// Get grab image index 
        /// </summary>
        /// <param name="intArrayIndex">Index which represent different defect inspection. 0: Unit Edge</param>
        /// <returns></returns>
        public int GetGrabImageIndex(int intArrayIndex)
        {
            if (intArrayIndex >= m_arrGrabImageIndex.Count)
                return 0;

            return m_arrGrabImageIndex[intArrayIndex];
        }

        public int GetGrabImageIndexCount()
        {
            return m_arrGrabImageIndex.Count;
        }

        private float GetDefect(string strDefectName, int intType)
        {
            // m_arrDefectHorizontal, m_arrDefectVertical array index : Defect No :  0=crack, 1=chip, 2=bright, 3=mold, 4=dark, 5=void
            float fDefectValue = 0;
            switch (strDefectName)
            {
                case "Dark":
                    if (intType == 0)
                        fDefectValue = m_arrDefectHorizontal[(int)eDefect.Dark];
                    else
                        fDefectValue = m_arrDefectVertical[(int)eDefect.Dark];
                    break;
                case "Dark 2":
                    if (intType == 0)
                        fDefectValue = m_arrDefectHorizontal[(int)eDefect.Dark2];
                    else
                        fDefectValue = m_arrDefectVertical[(int)eDefect.Dark2];
                    break;
                case "Dark 3":
                    if (intType == 0)
                        fDefectValue = m_arrDefectHorizontal[(int)eDefect.Dark3];
                    else
                        fDefectValue = m_arrDefectVertical[(int)eDefect.Dark3];
                    break;
                case "Dark 4":
                    if (intType == 0)
                        fDefectValue = m_arrDefectHorizontal[(int)eDefect.Dark4];
                    else
                        fDefectValue = m_arrDefectVertical[(int)eDefect.Dark4];
                    break;
                case "Bright":
                    if (intType == 0)
                        fDefectValue = m_arrDefectHorizontal[(int)eDefect.Bright];
                    else
                        fDefectValue = m_arrDefectVertical[(int)eDefect.Bright];
                    break;
                case "Scratch":
                case "Contamination":
                    if (intType == 0)
                        fDefectValue = m_arrDefectHorizontal[(int)eDefect.Bright];
                    else
                        fDefectValue = m_arrDefectVertical[(int)eDefect.Bright];
                    break;
                case "Crack":
                    if (m_blnSeperateCrackDefectSetting)
                    {
                        if (intType == 0)
                            fDefectValue = m_arrDefectHorizontal[(int)eDefect.Crack];
                        else
                            fDefectValue = m_arrDefectVertical[(int)eDefect.Crack];
                    }
                    else
                    {
                        if (intType == 0)
                            fDefectValue = m_arrDefectHorizontal[(int)eDefect.Dark];
                        else
                            fDefectValue = m_arrDefectVertical[(int)eDefect.Dark];
                    }
                    break;
                case "Void":
                    if (m_blnSeperateVoidDefectSetting)
                    {
                        if (intType == 0)
                            fDefectValue = m_arrDefectHorizontal[(int)eDefect.Void];
                        else
                            fDefectValue = m_arrDefectVertical[(int)eDefect.Void];
                    }
                    else
                    {
                        if (intType == 0)
                            fDefectValue = m_arrDefectHorizontal[(int)eDefect.Dark];
                        else
                            fDefectValue = m_arrDefectVertical[(int)eDefect.Dark];
                    }
                    break;
                case "MoldFlash":
                    if (m_blnSeperateMoldFlashDefectSetting)
                    {
                        if (intType == 0)
                            fDefectValue = m_arrDefectHorizontal[(int)eDefect.MoldFlash];
                        else
                            fDefectValue = m_arrDefectVertical[(int)eDefect.MoldFlash];
                    }
                    else
                    {
                        if (intType == 0)
                            fDefectValue = m_arrDefectHorizontal[(int)eDefect.Bright];
                        else
                            fDefectValue = m_arrDefectVertical[(int)eDefect.Bright];
                    }
                    break;
                case "Chip":
                    if (m_blnBrightChipDefect)
                    {
                        if (intType == 0)
                            fDefectValue = m_arrDefectHorizontal[(int)eDefect.ChipBright];
                        else
                            fDefectValue = m_arrDefectVertical[(int)eDefect.ChipBright];
                    }
                    else
                    {
                        if (intType == 0)
                            fDefectValue = m_arrDefectHorizontal[(int)eDefect.ChipDark];
                        else
                            fDefectValue = m_arrDefectVertical[(int)eDefect.ChipDark];
                    }
                    break;
            }
            return fDefectValue;
        }

        private float GetAreaDefect(string strDefectName)
        {
            float fDefectValue = 0;
            switch (strDefectName)
            {
                case "Dark":
                    fDefectValue = m_arrDefectArea[(int)eDefect.Dark];
                    break;
                case "Dark 2":
                    fDefectValue = m_arrDefectArea[(int)eDefect.Dark2];
                    break;
                case "Dark 3":
                    fDefectValue = m_arrDefectArea[(int)eDefect.Dark3];
                    break;
                case "Dark 4":
                    fDefectValue = m_arrDefectArea[(int)eDefect.Dark4];
                    break;
                case "Bright":
                    fDefectValue = m_arrDefectArea[(int)eDefect.Bright];
                    break;
                case "Scratch":
                case "Contamination":
                    fDefectValue = m_arrDefectArea[(int)eDefect.Bright];
                    break;
                case "Crack":
                    if (m_blnSeperateCrackDefectSetting)
                        fDefectValue = m_arrDefectArea[(int)eDefect.Crack];
                    else
                        fDefectValue = m_arrDefectArea[(int)eDefect.Dark];
                    break;
                case "Void":
                    if (m_blnSeperateVoidDefectSetting)
                        fDefectValue = m_arrDefectArea[(int)eDefect.Void];
                    else
                        fDefectValue = m_arrDefectArea[(int)eDefect.Dark];
                    break;
                case "MoldFlash":
                    if (m_blnSeperateMoldFlashDefectSetting)
                        fDefectValue = m_arrDefectArea[(int)eDefect.MoldFlash];
                    else
                        fDefectValue = m_arrDefectArea[(int)eDefect.Bright];
                    break;
                case "Chip":
                    if (m_blnBrightChipDefect)
                        fDefectValue = m_arrDefectArea[(int)eDefect.ChipBright];
                    else
                        fDefectValue = m_arrDefectArea[(int)eDefect.ChipDark];
                    break;
            }
            return fDefectValue;
        }

        private float GetTotalAreaDefect(string strDefectName)
        {
            float fDefectValue = 0;
            switch (strDefectName)
            {
                case "Dark":
                    fDefectValue = m_arrDefectTotalArea[(int)eDefect.Dark];
                    break;
                case "Dark 2":
                    fDefectValue = m_arrDefectTotalArea[(int)eDefect.Dark2];
                    break;
                case "Dark 3":
                    fDefectValue = m_arrDefectTotalArea[(int)eDefect.Dark3];
                    break;
                case "Dark 4":
                    fDefectValue = m_arrDefectTotalArea[(int)eDefect.Dark4];
                    break;
                case "Bright":
                    fDefectValue = m_arrDefectTotalArea[(int)eDefect.Bright];
                    break;
                case "Scratch":
                case "Contamination":
                    fDefectValue = m_arrDefectTotalArea[(int)eDefect.Bright];
                    break;
                case "Crack":
                    //if (m_blnSeperateCrackDefectSetting)
                    //    fDefectValue = m_arrDefectTotalArea[0];
                    //else
                    fDefectValue = m_arrDefectTotalArea[(int)eDefect.Dark];
                    break;
                case "Void":
                    //if (m_blnSeperateVoidDefectSetting)
                    //    fDefectValue = m_arrDefectTotalArea[5];
                    //else
                    fDefectValue = m_arrDefectTotalArea[(int)eDefect.Dark];
                    break;
                case "MoldFlash":
                    if (m_blnSeperateMoldFlashDefectSetting)
                        fDefectValue = m_arrDefectTotalArea[(int)eDefect.MoldFlash];
                    else
                        fDefectValue = m_arrDefectTotalArea[(int)eDefect.Bright];
                    break;
                    //case "Chip":
                    //    fDefectValue = m_arrDefectTotalArea[1];
                    //    break;
            }
            return fDefectValue;
        }


        public void BuildMarkViewObjects(ROI objROI)
        {
            m_objMarkViewEBlobs.BuildObjects_Filter_GetElement_DoubleThreshold(
                    objROI, false, true, false, m_intConnexity == 4, m_intMarkViewLowThreshold, m_intMarkViewHighThreshold,
                    m_intMarkViewMinArea, objROI.ref_ROIWidth * objROI.ref_ROIHeight + 1, false, 0x1F); // 2020 03 10 -> Plus 1 to max value to make sure blob with ROI size able to be detected.
            //m_intMarkViewMinArea, objROI.ref_ROIWidth * objROI.ref_ROIHeight, false, 0x1F);  // 2019 09 03 - change max area from 15000 to  objROI.ref_ROIWidth * objROI.ref_ROIHeight to make sure big defect able to be detected.
            //m_objMarkViewEBlobs.BuildObjects_Filter_GetElement(objROI, false, true, false, 0x1F);
        }

        public void BuildPackageViewObjects(ROI objROI)
        {
            m_objPackageEBlobs.BuildObjects_Filter_GetElement(objROI, false, true, false, 0x1F);

            //m_objPackageEBlobs.SetClassSelection(2);
            //m_objPackageEBlobs.BuildObjects(objROI, false);


        }

        public void ClearDontCareAreaArray()
        {
            m_arrDontCareArea.Clear();
        }

        public void ClearMarkMaskBlob()
        {
            m_arrMarkMaskROI.Clear();
        }

        public void CreateSideROI(float fCenterX, float fCenterY, float fWidth, float fHeight, ImageDrawing objImage)
        {
            m_arrSideROI.Clear();

            ROI objLeftROI = new ROI();
            ROI objRightROI = new ROI();
            ROI objTopROI = new ROI();
            ROI objBottomROI = new ROI();

            float fDimX = m_arrDefectHorizontal[(int)eDefect.ChipBright];    // chip defect minimum length
            if (fDimX == 0)
                fDimX = 1;

            //----------------------- TOP SIDE ROI ---------------------------
            float fLeftX = fCenterX - (fWidth / 2);
            float fTopY = fCenterY - (fHeight / 2) + 2;   // 2 pixel in
            objTopROI.LoadROISetting((int)Math.Floor(fLeftX), (int)Math.Floor(fTopY), (int)Math.Floor(fWidth), (int)Math.Floor(fDimX));
            objTopROI.AttachImage(objImage);
            m_arrSideROI.Add(objTopROI);

            //----------------------- Bottom SIDE ROI ---------------------------
            float fBottomY = fCenterY + (fHeight / 2) - fDimX - 2;
            objBottomROI.LoadROISetting((int)Math.Floor(fLeftX), (int)Math.Floor(fBottomY), (int)Math.Floor(fWidth), (int)Math.Floor(fDimX));
            objBottomROI.AttachImage(objImage);
            m_arrSideROI.Add(objBottomROI);


            //----------------------- LEFT SIDE ROI ---------------------------
            objLeftROI.LoadROISetting((int)Math.Floor(fLeftX), (int)Math.Floor(fTopY), (int)Math.Floor(fDimX), (int)Math.Floor(fHeight - 4));
            objLeftROI.AttachImage(objImage);
            m_arrSideROI.Add(objLeftROI);


            //----------------------- RIGHT SIDE ROI ---------------------------
            float fRightX = fCenterX + (fWidth / 2) - fDimX;
            objRightROI.LoadROISetting((int)Math.Floor(fRightX), (int)Math.Floor(fTopY), (int)Math.Floor(fDimX), (int)Math.Floor(fHeight - 4));
            objRightROI.AttachImage(objImage);
            m_arrSideROI.Add(objRightROI);
        }

        public void DrawLineEdge(Graphics g)
        {
            for (int i = 0; i < m_arrLinePoints.Count; i++)
            {
                for (int j = 0; j < m_arrLinePoints[i].Count; j++)
                {
                    int intCenterX = Convert.ToInt32(((EPoint)m_arrLinePoints[i][j]).Center.X);
                    int intCenterY = Convert.ToInt32(((EPoint)m_arrLinePoints[i][j]).Center.Y);

                    g.DrawLine(new Pen(m_BrushMatched, 1), new System.Drawing.Point(intCenterX - 2, intCenterY - 2),
                        new System.Drawing.Point(intCenterX + 2, intCenterY + 2));
                    g.DrawLine(new Pen(m_BrushMatched, 1), new System.Drawing.Point(intCenterX + 2, intCenterY - 2),
                         new System.Drawing.Point(intCenterX - 2, intCenterY + 2));
                }
            }
        }
        /// <summary>
        /// Draw all blob on mark view image. 
        /// </summary>
        /// <param name="g">Destination to draw image</param>
        /// <param name="blnViewAllObject">false = view object under defect only; true = view all selected blob objects</param>
        public void DrawMarkViewObjects(Graphics g, bool blnViewAllObject, List<ROI> arrROIs, float fDrawingScaleX, float fDrawingScaleY)
        {
            if (blnViewAllObject)
                m_objMarkViewEBlobs.DrawSelectedBlobs(g, fDrawingScaleX, fDrawingScaleY);
            else
            {
                for (int i = 0; i < m_arrDefectList.Count; i++)
                {
                    DrawMarkViewObjects(g, i, fDrawingScaleX, fDrawingScaleY);
                }
            }
        }

        public void DrawMarkViewObjects(Graphics g, int intSelectedImageView, List<ROI> arrROIs, float fDrawingScaleX, float fDrawingScaleY)
        {
            for (int i = 0; i < m_arrDefectList.Count; i++)
            {
                if (((Defect)m_arrDefectList[i]).ref_intFailedImage == (intSelectedImageView + 1))
                    DrawMarkViewObjects(g, i, fDrawingScaleX, fDrawingScaleY);
            }

            //if (m_blnPkgViewFailTotalArea)
            //    m_objPackageEBlobs.DrawSelectedBlob(g, fDrawingScaleX, fDrawingScaleY, Color.Red);
            //if(m_blnCrackChipViewFailTotalArea)
            //    m_objEBlobs.DrawSelectedBlob(g, fDrawingScaleX, fDrawingScaleY, Color.Red);
            //if(m_blnMarkViewFailTotalArea)
            //    m_objMarkViewEBlobs.DrawSelectedBlob(g, fDrawingScaleX, fDrawingScaleY, Color.Red);
        }



        public void DrawMarkViewObjects(Graphics g, int intObjectIndex, float fDrawingScaleX, float fDrawingScaleY)
        {
            if (intObjectIndex < m_arrDefectList.Count)
            {
                if (m_blnUseDetailDefectCriteria)
                {
                    Defect objDefect = (Defect)m_arrDefectList[intObjectIndex];
                    if (objDefect.ref_strName != "Crack")
                    {
                        if (objDefect.ref_intFailMask > 0)
                        {
                            g.DrawRectangle(new Pen(Color.Red), (objDefect.ref_fCenterX - (objDefect.ref_fDimX / 2)) * fDrawingScaleX,
                                                                (objDefect.ref_fCenterY - (objDefect.ref_fDimY / 2)) * fDrawingScaleY,
                                                                objDefect.ref_fDimX * fDrawingScaleX, objDefect.ref_fDimY * fDrawingScaleY);
                        }
                        else
                        {
                            g.DrawRectangle(new Pen(Color.Lime), (objDefect.ref_fCenterX - (objDefect.ref_fDimX / 2)) * fDrawingScaleX,
                                                                (objDefect.ref_fCenterY - (objDefect.ref_fDimY / 2)) * fDrawingScaleY,
                                                                objDefect.ref_fDimX * fDrawingScaleX, objDefect.ref_fDimY * fDrawingScaleY);
                        }
                    }
                    else
                    {
                        // Draw min rectangle Defect
                        //  Point 1 *-------------* Point 3
                        //          |             |
                        //          |             |
                        //          |             |
                        //  Point 2 *-------------* Point 4

                        if (objDefect.ref_intFailMask > 0)
                        {
                            float newX1 = 0, newY1 = 0;  // new point 1
                            float newX2 = 0, newY2 = 0; // new point 2
                            float newX3 = 0, newY3 = 0; // new point 3
                            float newX4 = 0, newY4 = 0; // new point 4

                            if (objDefect.ref_intLengthMode == 0)
                            {
                                Math2.RotateWithAngleAccordingToReferencePoint(objDefect.ref_fCenterX, objDefect.ref_fCenterY, (objDefect.ref_fCenterX - (objDefect.ref_fDimX / 2)), (objDefect.ref_fCenterY - (objDefect.ref_fDimY / 2)), objDefect.ref_fAngle, ref newX1, ref newY1);
                                Math2.RotateWithAngleAccordingToReferencePoint(objDefect.ref_fCenterX, objDefect.ref_fCenterY, (objDefect.ref_fCenterX - (objDefect.ref_fDimX / 2)), (objDefect.ref_fCenterY + (objDefect.ref_fDimY / 2)), objDefect.ref_fAngle, ref newX2, ref newY2);
                                Math2.RotateWithAngleAccordingToReferencePoint(objDefect.ref_fCenterX, objDefect.ref_fCenterY, (objDefect.ref_fCenterX + (objDefect.ref_fDimX / 2)), (objDefect.ref_fCenterY - (objDefect.ref_fDimY / 2)), objDefect.ref_fAngle, ref newX3, ref newY3);
                                Math2.RotateWithAngleAccordingToReferencePoint(objDefect.ref_fCenterX, objDefect.ref_fCenterY, (objDefect.ref_fCenterX + (objDefect.ref_fDimX / 2)), (objDefect.ref_fCenterY + (objDefect.ref_fDimY / 2)), objDefect.ref_fAngle, ref newX4, ref newY4);
                            }
                            else
                            {
                                Math2.RotateWithAngleAccordingToReferencePoint(objDefect.ref_fCenterX, objDefect.ref_fCenterY, (objDefect.ref_fCenterX - (objDefect.ref_fDimY / 2)), (objDefect.ref_fCenterY - (objDefect.ref_fDimX / 2)), objDefect.ref_fAngle, ref newX1, ref newY1);
                                Math2.RotateWithAngleAccordingToReferencePoint(objDefect.ref_fCenterX, objDefect.ref_fCenterY, (objDefect.ref_fCenterX - (objDefect.ref_fDimY / 2)), (objDefect.ref_fCenterY + (objDefect.ref_fDimX / 2)), objDefect.ref_fAngle, ref newX2, ref newY2);
                                Math2.RotateWithAngleAccordingToReferencePoint(objDefect.ref_fCenterX, objDefect.ref_fCenterY, (objDefect.ref_fCenterX + (objDefect.ref_fDimY / 2)), (objDefect.ref_fCenterY - (objDefect.ref_fDimX / 2)), objDefect.ref_fAngle, ref newX3, ref newY3);
                                Math2.RotateWithAngleAccordingToReferencePoint(objDefect.ref_fCenterX, objDefect.ref_fCenterY, (objDefect.ref_fCenterX + (objDefect.ref_fDimY / 2)), (objDefect.ref_fCenterY + (objDefect.ref_fDimX / 2)), objDefect.ref_fAngle, ref newX4, ref newY4);
                            }
                            g.DrawLine(new Pen(Color.Red), newX1 * fDrawingScaleX, newY1 * fDrawingScaleY, (newX3) * fDrawingScaleX, (newY3) * fDrawingScaleY);
                            g.DrawLine(new Pen(Color.Red), newX2 * fDrawingScaleX, newY2 * fDrawingScaleY, (newX1) * fDrawingScaleX, (newY1) * fDrawingScaleY);
                            g.DrawLine(new Pen(Color.Red), newX2 * fDrawingScaleX, newY2 * fDrawingScaleY, (newX4) * fDrawingScaleX, (newY4) * fDrawingScaleY);
                            g.DrawLine(new Pen(Color.Red), newX4 * fDrawingScaleX, newY4 * fDrawingScaleY, (newX3) * fDrawingScaleX, (newY3) * fDrawingScaleY);

                            //g.DrawRectangle(new Pen(Color.Red), (newX) * fDrawingScaleX,
                            //                                    (newY) * fDrawingScaleY,
                            //                                    objDefect.ref_fDimX * fDrawingScaleX, objDefect.ref_fDimY * fDrawingScaleY);
                        }
                        else
                        {
                            float newX1 = 0, newY1 = 0;
                            float newX2 = 0, newY2 = 0;
                            float newX3 = 0, newY3 = 0;
                            float newX4 = 0, newY4 = 0;
                            Math2.RotateWithAngleAccordingToReferencePoint(objDefect.ref_fCenterX, objDefect.ref_fCenterY, (objDefect.ref_fCenterX - (objDefect.ref_fDimX / 2)), (objDefect.ref_fCenterY - (objDefect.ref_fDimY / 2)), objDefect.ref_fAngle, ref newX1, ref newY1);
                            Math2.RotateWithAngleAccordingToReferencePoint(objDefect.ref_fCenterX, objDefect.ref_fCenterY, (objDefect.ref_fCenterX - (objDefect.ref_fDimX / 2)), (objDefect.ref_fCenterY + (objDefect.ref_fDimY / 2)), objDefect.ref_fAngle, ref newX2, ref newY2);
                            Math2.RotateWithAngleAccordingToReferencePoint(objDefect.ref_fCenterX, objDefect.ref_fCenterY, (objDefect.ref_fCenterX + (objDefect.ref_fDimX / 2)), (objDefect.ref_fCenterY - (objDefect.ref_fDimY / 2)), objDefect.ref_fAngle, ref newX3, ref newY3);
                            Math2.RotateWithAngleAccordingToReferencePoint(objDefect.ref_fCenterX, objDefect.ref_fCenterY, (objDefect.ref_fCenterX + (objDefect.ref_fDimX / 2)), (objDefect.ref_fCenterY + (objDefect.ref_fDimY / 2)), objDefect.ref_fAngle, ref newX4, ref newY4);

                            g.DrawLine(new Pen(Color.Lime), newX1 * fDrawingScaleX, newY1 * fDrawingScaleY, (newX3) * fDrawingScaleX, (newY3) * fDrawingScaleY);
                            g.DrawLine(new Pen(Color.Lime), newX2 * fDrawingScaleX, newY2 * fDrawingScaleY, (newX1) * fDrawingScaleX, (newY1) * fDrawingScaleY);
                            g.DrawLine(new Pen(Color.Lime), newX2 * fDrawingScaleX, newY2 * fDrawingScaleY, (newX4) * fDrawingScaleX, (newY4) * fDrawingScaleY);
                            g.DrawLine(new Pen(Color.Lime), newX4 * fDrawingScaleX, newY4 * fDrawingScaleY, (newX3) * fDrawingScaleX, (newY3) * fDrawingScaleY);
                        }
                    }
                }
                else
                {
                    // Draw min rectangle Defect
                    //  Point 1 *-------------* Point 3
                    //          |             |
                    //          |             |
                    //          |             |
                    //  Point 2 *-------------* Point 4
                    //insert function here to load defect list for unit 1
                    Defect objDefect = (Defect)m_arrDefectList[intObjectIndex];
                    int loop = 0, start = 0;
                    bool bln_failTotalArea = false;
                    string strFailTotalAreaDefectName = "";

                    if (objDefect.ref_intFailMask > 0 && objDefect.ref_fDimX == -1 && objDefect.ref_fDimY == -1) //fail total area
                    {
                        strFailTotalAreaDefectName = objDefect.ref_strName;

                        if (loop == 0)
                        {
                            loop = intObjectIndex;
                            start = 0;
                            bln_failTotalArea = true;
                        }
                        else
                        {
                            start = loop + 1;
                            loop = intObjectIndex;
                            bln_failTotalArea = true;
                        }
                    }

                    // 2020 12 28 - CXLim - make sure all defect draw red when total area fail
                    if (objDefect.ref_fDimX == -1 && objDefect.ref_fDimY == -1 && !bln_failTotalArea) // 2019-09-17 ZJYEOH : both -1 means fail total area, no need draw
                    //if (objDefect.ref_fDimX == -1 && objDefect.ref_fDimY == -1) // 2019-09-17 ZJYEOH : both -1 means fail total area, no need draw
                    {
                        return;
                    }
                        float newX1 = 0, newY1 = 0;  // new point 1
                        float newX2 = 0, newY2 = 0; // new point 2
                        float newX3 = 0, newY3 = 0; // new point 3
                        float newX4 = 0, newY4 = 0; // new point 4

                    if (bln_failTotalArea)
                    {
                        for (int i = start; i < loop; i++)
                        {
                            // 2022 01 21 - CCENG: m_arrDefectList will be clear during inspection while drawing is in progress, this will cause i out of index.
                            if (i >= m_arrDefectList.Count)
                                break;

                            objDefect = (Defect)m_arrDefectList[i];
                            if (objDefect.ref_intLengthMode == 0)
                            {
                                Math2.RotateWithAngleAccordingToReferencePoint(objDefect.ref_fCenterX, objDefect.ref_fCenterY, (objDefect.ref_fCenterX - (objDefect.ref_fDimX / 2)), (objDefect.ref_fCenterY - (objDefect.ref_fDimY / 2)), objDefect.ref_fAngle, ref newX1, ref newY1);
                                Math2.RotateWithAngleAccordingToReferencePoint(objDefect.ref_fCenterX, objDefect.ref_fCenterY, (objDefect.ref_fCenterX - (objDefect.ref_fDimX / 2)), (objDefect.ref_fCenterY + (objDefect.ref_fDimY / 2)), objDefect.ref_fAngle, ref newX2, ref newY2);
                                Math2.RotateWithAngleAccordingToReferencePoint(objDefect.ref_fCenterX, objDefect.ref_fCenterY, (objDefect.ref_fCenterX + (objDefect.ref_fDimX / 2)), (objDefect.ref_fCenterY - (objDefect.ref_fDimY / 2)), objDefect.ref_fAngle, ref newX3, ref newY3);
                                Math2.RotateWithAngleAccordingToReferencePoint(objDefect.ref_fCenterX, objDefect.ref_fCenterY, (objDefect.ref_fCenterX + (objDefect.ref_fDimX / 2)), (objDefect.ref_fCenterY + (objDefect.ref_fDimY / 2)), objDefect.ref_fAngle, ref newX4, ref newY4);
                            }
                            else
                            {
                                Math2.RotateWithAngleAccordingToReferencePoint(objDefect.ref_fCenterX, objDefect.ref_fCenterY, (objDefect.ref_fCenterX - (objDefect.ref_fDimY / 2)), (objDefect.ref_fCenterY - (objDefect.ref_fDimX / 2)), objDefect.ref_fAngle, ref newX1, ref newY1);
                                Math2.RotateWithAngleAccordingToReferencePoint(objDefect.ref_fCenterX, objDefect.ref_fCenterY, (objDefect.ref_fCenterX - (objDefect.ref_fDimY / 2)), (objDefect.ref_fCenterY + (objDefect.ref_fDimX / 2)), objDefect.ref_fAngle, ref newX2, ref newY2);
                                Math2.RotateWithAngleAccordingToReferencePoint(objDefect.ref_fCenterX, objDefect.ref_fCenterY, (objDefect.ref_fCenterX + (objDefect.ref_fDimY / 2)), (objDefect.ref_fCenterY - (objDefect.ref_fDimX / 2)), objDefect.ref_fAngle, ref newX3, ref newY3);
                                Math2.RotateWithAngleAccordingToReferencePoint(objDefect.ref_fCenterX, objDefect.ref_fCenterY, (objDefect.ref_fCenterX + (objDefect.ref_fDimY / 2)), (objDefect.ref_fCenterY + (objDefect.ref_fDimX / 2)), objDefect.ref_fAngle, ref newX4, ref newY4);
                            }

                            //2021-04-29 ZJYEOH : Need to draw red based on defect name, if not, all those defect not included in total area will also draw as red
                            if (strFailTotalAreaDefectName.Contains(objDefect.ref_strName))
                            {
                                g.DrawLine(new Pen(Color.Red), newX1 * fDrawingScaleX, newY1 * fDrawingScaleY, (newX3) * fDrawingScaleX, (newY3) * fDrawingScaleY);
                                g.DrawLine(new Pen(Color.Red), newX2 * fDrawingScaleX, newY2 * fDrawingScaleY, (newX1) * fDrawingScaleX, (newY1) * fDrawingScaleY);
                                g.DrawLine(new Pen(Color.Red), newX2 * fDrawingScaleX, newY2 * fDrawingScaleY, (newX4) * fDrawingScaleX, (newY4) * fDrawingScaleY);
                                g.DrawLine(new Pen(Color.Red), newX4 * fDrawingScaleX, newY4 * fDrawingScaleY, (newX3) * fDrawingScaleX, (newY3) * fDrawingScaleY);
                            }
                            else
                            {
                                g.DrawLine(new Pen(Color.Lime), newX1 * fDrawingScaleX, newY1 * fDrawingScaleY, (newX3) * fDrawingScaleX, (newY3) * fDrawingScaleY);
                                g.DrawLine(new Pen(Color.Lime), newX2 * fDrawingScaleX, newY2 * fDrawingScaleY, (newX1) * fDrawingScaleX, (newY1) * fDrawingScaleY);
                                g.DrawLine(new Pen(Color.Lime), newX2 * fDrawingScaleX, newY2 * fDrawingScaleY, (newX4) * fDrawingScaleX, (newY4) * fDrawingScaleY);
                                g.DrawLine(new Pen(Color.Lime), newX4 * fDrawingScaleX, newY4 * fDrawingScaleY, (newX3) * fDrawingScaleX, (newY3) * fDrawingScaleY);
                            }
                        }
                    }
                    else
                    {
                        if (objDefect.ref_intLengthMode == 0)
                        {
                            Math2.RotateWithAngleAccordingToReferencePoint(objDefect.ref_fCenterX, objDefect.ref_fCenterY, (objDefect.ref_fCenterX - (objDefect.ref_fDimX / 2)), (objDefect.ref_fCenterY - (objDefect.ref_fDimY / 2)), objDefect.ref_fAngle, ref newX1, ref newY1);
                            Math2.RotateWithAngleAccordingToReferencePoint(objDefect.ref_fCenterX, objDefect.ref_fCenterY, (objDefect.ref_fCenterX - (objDefect.ref_fDimX / 2)), (objDefect.ref_fCenterY + (objDefect.ref_fDimY / 2)), objDefect.ref_fAngle, ref newX2, ref newY2);
                            Math2.RotateWithAngleAccordingToReferencePoint(objDefect.ref_fCenterX, objDefect.ref_fCenterY, (objDefect.ref_fCenterX + (objDefect.ref_fDimX / 2)), (objDefect.ref_fCenterY - (objDefect.ref_fDimY / 2)), objDefect.ref_fAngle, ref newX3, ref newY3);
                            Math2.RotateWithAngleAccordingToReferencePoint(objDefect.ref_fCenterX, objDefect.ref_fCenterY, (objDefect.ref_fCenterX + (objDefect.ref_fDimX / 2)), (objDefect.ref_fCenterY + (objDefect.ref_fDimY / 2)), objDefect.ref_fAngle, ref newX4, ref newY4);
                        }
                        else
                        {
                            Math2.RotateWithAngleAccordingToReferencePoint(objDefect.ref_fCenterX, objDefect.ref_fCenterY, (objDefect.ref_fCenterX - (objDefect.ref_fDimY / 2)), (objDefect.ref_fCenterY - (objDefect.ref_fDimX / 2)), objDefect.ref_fAngle, ref newX1, ref newY1);
                            Math2.RotateWithAngleAccordingToReferencePoint(objDefect.ref_fCenterX, objDefect.ref_fCenterY, (objDefect.ref_fCenterX - (objDefect.ref_fDimY / 2)), (objDefect.ref_fCenterY + (objDefect.ref_fDimX / 2)), objDefect.ref_fAngle, ref newX2, ref newY2);
                            Math2.RotateWithAngleAccordingToReferencePoint(objDefect.ref_fCenterX, objDefect.ref_fCenterY, (objDefect.ref_fCenterX + (objDefect.ref_fDimY / 2)), (objDefect.ref_fCenterY - (objDefect.ref_fDimX / 2)), objDefect.ref_fAngle, ref newX3, ref newY3);
                            Math2.RotateWithAngleAccordingToReferencePoint(objDefect.ref_fCenterX, objDefect.ref_fCenterY, (objDefect.ref_fCenterX + (objDefect.ref_fDimY / 2)), (objDefect.ref_fCenterY + (objDefect.ref_fDimX / 2)), objDefect.ref_fAngle, ref newX4, ref newY4);
                        }

                        if (objDefect.ref_intFailMask > 0)
                        {
                            g.DrawLine(new Pen(Color.Red), newX1 * fDrawingScaleX, newY1 * fDrawingScaleY, (newX3) * fDrawingScaleX, (newY3) * fDrawingScaleY);
                            g.DrawLine(new Pen(Color.Red), newX2 * fDrawingScaleX, newY2 * fDrawingScaleY, (newX1) * fDrawingScaleX, (newY1) * fDrawingScaleY);
                            g.DrawLine(new Pen(Color.Red), newX2 * fDrawingScaleX, newY2 * fDrawingScaleY, (newX4) * fDrawingScaleX, (newY4) * fDrawingScaleY);
                            g.DrawLine(new Pen(Color.Red), newX4 * fDrawingScaleX, newY4 * fDrawingScaleY, (newX3) * fDrawingScaleX, (newY3) * fDrawingScaleY);
                        }
                        else
                        {
                            g.DrawLine(new Pen(Color.Lime), newX1 * fDrawingScaleX, newY1 * fDrawingScaleY, (newX3) * fDrawingScaleX, (newY3) * fDrawingScaleY);
                            g.DrawLine(new Pen(Color.Lime), newX2 * fDrawingScaleX, newY2 * fDrawingScaleY, (newX1) * fDrawingScaleX, (newY1) * fDrawingScaleY);
                            g.DrawLine(new Pen(Color.Lime), newX2 * fDrawingScaleX, newY2 * fDrawingScaleY, (newX4) * fDrawingScaleX, (newY4) * fDrawingScaleY);
                            g.DrawLine(new Pen(Color.Lime), newX4 * fDrawingScaleX, newY4 * fDrawingScaleY, (newX3) * fDrawingScaleX, (newY3) * fDrawingScaleY);
                        }
                    }
                }

            }
        }

        public void DrawPackageViewObjects(Graphics g)
        {
            m_objPackageEBlobs.DrawSelectedBlobs(g, 1f, 1f);
        }

        public void GetDefectInfo(int intNo, ref float fDimX, ref float fDimY, ref float fArea, float fCalibX)
        {
            Defect objDefect = ((Defect)m_arrDefectList[intNo]);
            fDimX = objDefect.ref_fDimX / fCalibX;
            fDimY = objDefect.ref_fDimY / fCalibX;
            fArea = objDefect.ref_fArea / (fCalibX * fCalibX);
        }

        public void GetDefectInfo(int intNo, ref float fDimX, ref float fDimY, ref float fArea, ref int intFailMask, ref string strDefectName, float fCalibX, float fCalibY, ref int intFailedImage, ref float fAngle)
        {
            Defect objDefect = ((Defect)m_arrDefectList[intNo]);
            if (objDefect.ref_intLengthMode == 0)
            {
                fDimX = objDefect.ref_fDimX / fCalibX;
                fDimY = objDefect.ref_fDimY / fCalibY;
            }
            else
            {
                fDimX = objDefect.ref_fDimX / fCalibY;
                fDimY = objDefect.ref_fDimY / fCalibX;
            }
            fArea = objDefect.ref_fArea / (fCalibX * fCalibY);
            fAngle = objDefect.ref_fAngle;
            intFailMask = objDefect.ref_intFailMask;
            if (objDefect.ref_strName == null)
                strDefectName = "";
            else
                strDefectName = objDefect.ref_strName;

            intFailedImage = objDefect.ref_intFailedImage;
        }

        public void GetDefectName(int intNo, ref string strDefectName, ref int intFailMask)
        {
            Defect objDefect = ((Defect)m_arrDefectList[intNo]);

            intFailMask = objDefect.ref_intFailMask;

            if (objDefect.ref_strName == null)
                strDefectName = "";
            else
                strDefectName = objDefect.ref_strName;

        }

        public bool InspectCrackView(ROI objROI)
        {
            int intSelectedImageIndex = m_arrGrabImageIndex[3];

            int intSelectedObjectNum = m_objEBlobs.BuildObjects_Filter_GetElement_DoubleThreshold(
                objROI, true, false, false, m_intConnexity == 8, m_intCrackViewLowThreshold, m_intCrackViewHighThreshold,
                m_intCrackViewMinArea, objROI.ref_ROIWidth * objROI.ref_ROIHeight, false, 0xED);

            if (intSelectedObjectNum == 0)
                return true;

            int intObjectTotalArea = 0;
            int intObjectArea = 0;
            int intLengthMode = 0;
            float fObjectHeight = 0, fObjectWidth = 0, fObjectCenterX = 0, fObjectCenterY = 0, fObjectAngle = 0;
            bool blnOverAllFail = false;
            for (int i = 0; i < intSelectedObjectNum; i++)
            {

                intObjectArea = m_objEBlobs.ref_arrArea[i];
                //fObjectHeight = m_objEBlobs.ref_arrHeight[i]; // Temporary changed to MinimumRect
                //fObjectWidth =  m_objEBlobs.ref_arrWidth[i]; // Temporary changed to MinimumRect
                //fObjectCenterX = m_objEBlobs.ref_arrLimitCenterX[i]; // Temporary changed to MinimumRect
                //fObjectCenterY =  m_objEBlobs.ref_arrLimitCenterY[i]; // Temporary changed to MinimumRect
                //if (m_objEBlobs.ref_arrRectWidth[i] < m_objEBlobs.ref_arrRectHeight[i])
                //{
                //    fObjectWidth = m_objEBlobs.ref_arrRectWidth[i];
                //    fObjectHeight = m_objEBlobs.ref_arrRectHeight[i];
                //    intLengthMode = 0;

                //    fObjectAngle = m_objEBlobs.ref_arrRectAngle[i];
                //    if (fObjectAngle < 0)
                //        fObjectAngle = -Math.Abs(fObjectAngle);
                //    else
                //        fObjectAngle = -fObjectAngle;

                //}
                //else
                //{
                //    fObjectHeight = m_objEBlobs.ref_arrRectWidth[i]; 
                //    fObjectWidth = m_objEBlobs.ref_arrRectHeight[i];
                //    intLengthMode = 0; // 1;

                //    fObjectAngle = m_objEBlobs.ref_arrRectAngle[i];
                //    if (fObjectAngle < 0)
                //        fObjectAngle = Math.Abs(fObjectAngle);
                //    else
                //        fObjectAngle = 90 - (fObjectAngle);
                //}

                if (m_objEBlobs.ref_arrRectHeight[i] < m_objEBlobs.ref_arrRectWidth[i])
                {
                    fObjectWidth = m_objEBlobs.ref_arrRectHeight[i];
                    fObjectHeight = m_objEBlobs.ref_arrRectWidth[i];
                    intLengthMode = 0;
                    fObjectAngle = m_objEBlobs.ref_arrRectAngle[i];

                    if (fObjectAngle >= 10)//&& fAngle <= 80)
                        fObjectAngle = m_objEBlobs.ref_arrRectAngle[i] - 90;
                    else
                        fObjectAngle = 90 + m_objEBlobs.ref_arrRectAngle[i];

                }
                else
                {
                    fObjectHeight = m_objEBlobs.ref_arrRectHeight[i];
                    fObjectWidth = m_objEBlobs.ref_arrRectWidth[i];
                    intLengthMode = 0;

                    fObjectAngle = m_objEBlobs.ref_arrRectAngle[i];

                }
                fObjectCenterX = m_objEBlobs.ref_arrRectLimitCenterX[i];
                fObjectCenterY = m_objEBlobs.ref_arrRectLimitCenterY[i];
                intObjectTotalArea += intObjectArea;

                float Max = Math.Max(fObjectHeight, fObjectWidth);
                float Min = Math.Min(fObjectHeight, fObjectWidth);

                //if (Max / Min <= 1.5)
                //{
                //    if ((intObjectArea / (fObjectHeight * fObjectWidth)) >= 0.5)
                //        continue;
                //}

                // 2019 04 29 - JBTAN: SMAT specification for crack, 1.5mil X 7.5mil
                //if (Min / m_fMMToPixelXValue * 1000 < 38f)
                //    continue;

                //Less than 5 pixel
                //if (Min < 5)
                //    continue;

                bool blnFail = false;
                int intFailMask = 0;
                string strDefectName = "Crack";
                if (m_arrWantDefectLength[(int)eWantDefect.Crack])
                {
                    if (m_intCrackDarkDefectDimensionFailCondition == 0)
                    {
                        if (fObjectWidth >= GetDefect("Crack", 0))
                        {
                            //m_strErrorMessage += "*Fail Crack View Package - Cracked. Set = " + (m_arrDefectHorizontal[0] / m_fMMToPixelXValue).ToString("f5") + " mm,   Result = " + (Math.Max(fObjectWidth, fObjectHeight) / m_fMMToPixelXValue).ToString("f5") + " mm";
                            m_strErrorMessage += "* Crack Width Package Fail. Set = " + (GetDefect("Crack", 0) / m_fMMToPixelXValue).ToString("f5") + " mm,   Result = " + (fObjectWidth / m_fMMToPixelXValue).ToString("f5") + " mm";
                            blnFail = true;
                            intFailMask |= 0x01;
                            strDefectName = "Crack";
                        }

                        if (fObjectHeight >= GetDefect("Crack", 1))
                        {
                            //m_strErrorMessage += "*Fail Crack View Package - Cracked. Set = " + (m_arrDefectHorizontal[0] / m_fMMToPixelXValue).ToString("f5") + " mm,   Result = " + (Math.Max(fObjectWidth, fObjectHeight) / m_fMMToPixelXValue).ToString("f5") + " mm";
                            m_strErrorMessage += "* Crack Height Package Fail. Set = " + (GetDefect("Crack", 1) / m_fMMToPixelYValue).ToString("f5") + " mm,   Result = " + (fObjectHeight / m_fMMToPixelYValue).ToString("f5") + " mm";
                            blnFail = true;
                            intFailMask |= 0x02;
                            strDefectName = "Crack";
                        }
                    }
                    else
                    {
                        if ((fObjectWidth >= GetDefect("Crack", 0)) && (fObjectHeight >= GetDefect("Crack", 1)))
                        {
                            //m_strErrorMessage += "*Fail Crack View Package - Cracked. Set = " + (m_arrDefectHorizontal[0] / m_fMMToPixelXValue).ToString("f5") + " mm,   Result = " + (Math.Max(fObjectWidth, fObjectHeight) / m_fMMToPixelXValue).ToString("f5") + " mm";
                            m_strErrorMessage += "* Crack Width Package Fail. Set = " + (GetDefect("Crack", 0) / m_fMMToPixelXValue).ToString("f5") + " mm,   Result = " + (fObjectWidth / m_fMMToPixelXValue).ToString("f5") + " mm";
                            intFailMask |= 0x01;
                            //m_strErrorMessage += "*Fail Crack View Package - Cracked. Set = " + (m_arrDefectHorizontal[0] / m_fMMToPixelXValue).ToString("f5") + " mm,   Result = " + (Math.Max(fObjectWidth, fObjectHeight) / m_fMMToPixelXValue).ToString("f5") + " mm";
                            m_strErrorMessage += "* Crack Height Package Fail. Set = " + (GetDefect("Crack", 1) / m_fMMToPixelYValue).ToString("f5") + " mm,   Result = " + (fObjectHeight / m_fMMToPixelYValue).ToString("f5") + " mm";
                            blnFail = true;
                            intFailMask |= 0x02;
                            strDefectName = "Crack";
                        }
                    }
                }

                if (m_arrWantDefectArea[(int)eWantDefect.Crack])
                {
                    if (intObjectArea >= GetAreaDefect("Crack"))
                    {
                        //m_strErrorMessage += "*Fail Crack View Package - Cracked. Set = " + (m_arrDefectArea[0] / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        m_strErrorMessage += "* Crack Area Package Fail. Set = " + (GetAreaDefect("Crack") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        blnFail = true;
                        intFailMask |= 0x04;
                        strDefectName = "Crack";
                    }
                }

                if (blnFail)
                {
                    Defect objDefect = new Defect();
                    objDefect.ref_fDimX = fObjectWidth;
                    objDefect.ref_fDimY = fObjectHeight;
                    objDefect.ref_intLengthMode = intLengthMode;
                    objDefect.ref_fArea = intObjectArea;
                    objDefect.ref_fCenterX = objROI.ref_ROITotalX + fObjectCenterX;
                    objDefect.ref_fCenterY = objROI.ref_ROITotalY + fObjectCenterY;
                    objDefect.ref_fAngle = fObjectAngle;
                    objDefect.ref_intBlobNo = i;
                    objDefect.ref_intFailMask = intFailMask;
                    objDefect.ref_strName = strDefectName;
                    objDefect.ref_intFailedImage = intSelectedImageIndex + 1;
                    m_arrDefectList.Add(objDefect);

                    if (!blnOverAllFail)
                        blnOverAllFail = true;
                }
                else
                {
                    Defect objDefect = new Defect();
                    objDefect.ref_fDimX = fObjectWidth;
                    objDefect.ref_fDimY = fObjectHeight;
                    objDefect.ref_intLengthMode = intLengthMode;
                    objDefect.ref_fArea = intObjectArea;
                    objDefect.ref_fCenterX = objROI.ref_ROITotalX + fObjectCenterX;
                    objDefect.ref_fCenterY = objROI.ref_ROITotalY + fObjectCenterY;
                    objDefect.ref_fAngle = fObjectAngle;
                    objDefect.ref_intBlobNo = i;
                    objDefect.ref_intFailMask = 0;
                    objDefect.ref_strName = strDefectName;
                    objDefect.ref_intFailedImage = intSelectedImageIndex + 1;
                    m_arrDefectList.Add(objDefect);
                }
            }

            if (m_arrWantDefectArea[(int)eWantDefect.Crack])
            {
                if (intObjectTotalArea >= GetTotalAreaDefect("Crack"))
                {
                    m_strErrorMessage += "* Crack Total Area Package Fail. Set = " + (GetTotalAreaDefect("Crack") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectTotalArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                    m_blnCrackChipViewFailTotalArea = true;

                    Defect objDefect = new Defect();
                    objDefect.ref_fDimX = -1;
                    objDefect.ref_fDimY = -1;
                    objDefect.ref_intLengthMode = intLengthMode;
                    objDefect.ref_fArea = intObjectTotalArea;
                    objDefect.ref_fCenterX = objROI.ref_ROITotalX + m_objEBlobs.ref_arrRectLimitCenterX[0];
                    objDefect.ref_fCenterY = objROI.ref_ROITotalY + m_objEBlobs.ref_arrRectLimitCenterY[0];
                    objDefect.ref_fAngle = fObjectAngle; //m_objEBlobs.ref_arrRectAngle[0];
                    objDefect.ref_intFailMask |= 0x04;
                    objDefect.ref_strName = "Total Crack";
                    objDefect.ref_intFailedImage = intSelectedImageIndex + 1;
                    m_arrDefectList.Add(objDefect);

                    if (!blnOverAllFail)
                        blnOverAllFail = true;
                }
            }

            if (blnOverAllFail)
            {
                m_intPkgFailResultMask |= 0x01;
                return false;
            }
            else
                return true;
        }
        public bool InspectCrackView_WithLinkFunction(ROI objROI)
        {
            int intSelectedImageIndex = m_arrGrabImageIndex[3];

            int intSelectedObjectNum = m_objEBlobs.BuildObjects_Filter_GetElement_DoubleThreshold(
                objROI, true, false, false, m_intConnexity == 8, m_intCrackViewLowThreshold, m_intCrackViewHighThreshold,
                m_intCrackViewMinArea, objROI.ref_ROIWidth * objROI.ref_ROIHeight, false, 0xED);

            if (intSelectedObjectNum == 0)
                return true;
            List<List<System.Windows.Point>> arr2DPoints = new List<List<System.Windows.Point>>();
            List<List<PointF>> arrRotatedPoints = new List<List<PointF>>();
            List<float> fObjectHeightList = new List<float>(), fObjectWidthList = new List<float>(), fObjectCenterXList = new List<float>(), fObjectCenterYList = new List<float>(), fObjectAngleList = new List<float>();
            List<float> fObjectLimitHeightList = new List<float>(), fObjectLimitWidthList = new List<float>(), fObjectLimitCenterXList = new List<float>(), fObjectLimitCenterYList = new List<float>();
            List<int> fObjectAreaList = new List<int>(), fObjectAreaList2 = new List<int>();
            int intObjectTotalArea = 0;
            int intObjectArea = 0;
            int intLengthMode = 0;
            float fObjectHeight = 0, fObjectWidth = 0, fObjectCenterX = 0, fObjectCenterY = 0, fObjectAngle = 0;
            float fObjectLimitHeight = 0, fObjectLimitWidth = 0, fObjectLimitCenterX = 0, fObjectLimitCenterY = 0;
            bool blnOverAllFail = false;
            for (int i = 0; i < intSelectedObjectNum; i++)
            {
                arrRotatedPoints.Add(new List<PointF>());
                arr2DPoints.Add(new List<System.Windows.Point>());
                intObjectArea = m_objEBlobs.ref_arrArea[i];
                
                if (m_objEBlobs.ref_arrRectHeight[i] < m_objEBlobs.ref_arrRectWidth[i])
                {
                    fObjectWidth = m_objEBlobs.ref_arrRectHeight[i];
                    fObjectHeight = m_objEBlobs.ref_arrRectWidth[i];
                    intLengthMode = 0;
                    fObjectAngle = m_objEBlobs.ref_arrRectAngle[i];

                    if (fObjectAngle >= 10)//&& fAngle <= 80)
                        fObjectAngle = m_objEBlobs.ref_arrRectAngle[i] - 90;
                    else
                        fObjectAngle = 90 + m_objEBlobs.ref_arrRectAngle[i];

                }
                else
                {
                    fObjectHeight = m_objEBlobs.ref_arrRectHeight[i];
                    fObjectWidth = m_objEBlobs.ref_arrRectWidth[i];
                    intLengthMode = 0;

                    fObjectAngle = m_objEBlobs.ref_arrRectAngle[i];

                }
                fObjectCenterX = m_objEBlobs.ref_arrRectLimitCenterX[i];
                fObjectCenterY = m_objEBlobs.ref_arrRectLimitCenterY[i];

                fObjectLimitCenterX = m_objEBlobs.ref_arrLimitCenterX[i];
                fObjectLimitCenterY = m_objEBlobs.ref_arrLimitCenterY[i];
                fObjectLimitWidth = m_objEBlobs.ref_arrWidth[i];
                fObjectLimitHeight = m_objEBlobs.ref_arrHeight[i];

                intObjectTotalArea += intObjectArea;
                
                float newX1 = 0, newY1 = 0;  // new point 1
                float newX2 = 0, newY2 = 0; // new point 2
                float newX3 = 0, newY3 = 0; // new point 3
                float newX4 = 0, newY4 = 0; // new point 4
                
                //2020-12-18 ZJYEOH : Change to this format
                //  Point 1 *-------------* Point 2
                //          |             |
                //          |             |
                //          |             |
                //  Point 4 *-------------* Point 3

                Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX - (fObjectWidth / 2)), (fObjectCenterY - (fObjectHeight / 2)), fObjectAngle, ref newX1, ref newY1);
                Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX + (fObjectWidth / 2)), (fObjectCenterY - (fObjectHeight / 2)), fObjectAngle, ref newX2, ref newY2);
                Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX + (fObjectWidth / 2)), (fObjectCenterY + (fObjectHeight / 2)), fObjectAngle, ref newX3, ref newY3);
                Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX - (fObjectWidth / 2)), (fObjectCenterY + (fObjectHeight / 2)), fObjectAngle, ref newX4, ref newY4);


                arrRotatedPoints[i].Add(new PointF(newX1, newY1));
                arrRotatedPoints[i].Add(new PointF(newX2, newY2));
                arrRotatedPoints[i].Add(new PointF(newX3, newY3));
                arrRotatedPoints[i].Add(new PointF(newX4, newY4));

                Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX - (fObjectWidth / 2)) - m_intCrackDefectLinkTolerance, (fObjectCenterY - (fObjectHeight / 2)) - m_intCrackDefectLinkTolerance, fObjectAngle, ref newX1, ref newY1);
                Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX + (fObjectWidth / 2)) + m_intCrackDefectLinkTolerance, (fObjectCenterY - (fObjectHeight / 2)) - m_intCrackDefectLinkTolerance, fObjectAngle, ref newX2, ref newY2);
                Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX + (fObjectWidth / 2)) + m_intCrackDefectLinkTolerance, (fObjectCenterY + (fObjectHeight / 2)) + m_intCrackDefectLinkTolerance, fObjectAngle, ref newX3, ref newY3);
                Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX - (fObjectWidth / 2)) - m_intCrackDefectLinkTolerance, (fObjectCenterY + (fObjectHeight / 2)) + m_intCrackDefectLinkTolerance, fObjectAngle, ref newX4, ref newY4);

                arr2DPoints[i].Add(new System.Windows.Point(newX1, newY1));
                arr2DPoints[i].Add(new System.Windows.Point(newX2, newY2));
                arr2DPoints[i].Add(new System.Windows.Point(newX3, newY3));
                arr2DPoints[i].Add(new System.Windows.Point(newX4, newY4));
                
                fObjectHeightList.Add(fObjectHeight);
                fObjectWidthList.Add(fObjectWidth);
                fObjectCenterXList.Add(fObjectCenterX);
                fObjectCenterYList.Add(fObjectCenterY);
                fObjectAngleList.Add(fObjectAngle);
                fObjectAreaList.Add(intObjectArea);
                fObjectAreaList2.Add(intObjectArea);
            }
            int intTolerance = m_intCrackDefectLinkTolerance;
            int intAngleTolerance = 10;
            bool blnDecrement = false;
            if (intTolerance >= 0)
            {
                for (int i = 0; i < fObjectHeightList.Count; i++)
                {
                    if (blnDecrement)
                    {
                        blnDecrement = false;
                        if (i > 0)
                            i--;
                    }
                    for (int j = 0; j < fObjectHeightList.Count; j++)
                    {
                        if (i != j && i < fObjectHeightList.Count && j < fObjectHeightList.Count)
                        {
                            if (Intersection.CheckRectRectIntersection(arr2DPoints[i].ToArray(), arr2DPoints[j].ToArray(), intTolerance))
                            {
                               
                                PointF[] arrPoints = new PointF[8];

                                arrPoints[0] = arrRotatedPoints[i][0];
                                arrPoints[1] = arrRotatedPoints[i][1];
                                arrPoints[2] = arrRotatedPoints[i][2];
                                arrPoints[3] = arrRotatedPoints[i][3];
                                arrPoints[4] = arrRotatedPoints[j][0];
                                arrPoints[5] = arrRotatedPoints[j][1];
                                arrPoints[6] = arrRotatedPoints[j][2];
                                arrPoints[7] = arrRotatedPoints[j][3];

                                float fMinAngle = 0;
                                List<PointF> arrMinRect = new List<PointF>();
                                arrMinRect = MinimumBoundingBox.CalculateMinimumBoundingBox(arrPoints, ref fMinAngle);

                                if (fMinAngle < 0)
                                    fObjectAngleList[i] = -(90 + fMinAngle);
                                else
                                    fObjectAngleList[i] = 90 - fMinAngle;

                                Line onjLine1 = new Line();
                                Line onjLine2 = new Line();
                                onjLine1.CalculateStraightLine(arrMinRect[0], arrMinRect[2]);
                                onjLine2.CalculateStraightLine(arrMinRect[1], arrMinRect[3]);
                                PointF pCenter = Line.GetCrossPoint(onjLine1, onjLine2);
                                float p1X = 0, p1Y = 0;
                                float p2X = 0, p2Y = 0;
                                float p3X = 0, p3Y = 0;
                                float p4X = 0, p4Y = 0;
                                Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[0].X, arrMinRect[0].Y, -fObjectAngleList[i], ref p1X, ref p1Y);
                                Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[1].X, arrMinRect[1].Y, -fObjectAngleList[i], ref p2X, ref p2Y);
                                Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[2].X, arrMinRect[2].Y, -fObjectAngleList[i], ref p3X, ref p3Y);
                                Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[3].X, arrMinRect[3].Y, -fObjectAngleList[i], ref p4X, ref p4Y);

                                float pR1X = 0, pR1Y = 0;
                                float pR2X = 0, pR2Y = 0;
                                float pR3X = 0, pR3Y = 0;
                                float pR4X = 0, pR4Y = 0;
                                Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)), Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)), fObjectAngleList[i], ref pR1X, ref pR1Y); // Top Left
                                Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)), Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)), fObjectAngleList[i], ref pR2X, ref pR2Y); // Top Right
                                Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)), Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)), fObjectAngleList[i], ref pR3X, ref pR3Y); // Bottom Right
                                Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)), Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)), fObjectAngleList[i], ref pR4X, ref pR4Y); // Bottom Left
                                arrMinRect[0] = new PointF(pR1X, pR1Y);
                                arrMinRect[1] = new PointF(pR2X, pR2Y);
                                arrMinRect[2] = new PointF(pR3X, pR3Y);
                                arrMinRect[3] = new PointF(pR4X, pR4Y);
                                
                                arrRotatedPoints[i][0] = arrMinRect[0];
                                arrRotatedPoints[i][1] = arrMinRect[1];
                                arrRotatedPoints[i][2] = arrMinRect[2];
                                arrRotatedPoints[i][3] = arrMinRect[3];

                                Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)) - m_intCrackDefectLinkTolerance, Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)) - m_intCrackDefectLinkTolerance, fObjectAngleList[i], ref pR1X, ref pR1Y); // Top Left
                                Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)) + m_intCrackDefectLinkTolerance, Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)) - m_intCrackDefectLinkTolerance, fObjectAngleList[i], ref pR2X, ref pR2Y); // Top Right
                                Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)) + m_intCrackDefectLinkTolerance, Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)) + m_intCrackDefectLinkTolerance, fObjectAngleList[i], ref pR3X, ref pR3Y); // Bottom Right
                                Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)) - m_intCrackDefectLinkTolerance, Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)) + m_intCrackDefectLinkTolerance, fObjectAngleList[i], ref pR4X, ref pR4Y); // Bottom Left

                                arr2DPoints[i][0] = new System.Windows.Point(pR1X, pR1Y);
                                arr2DPoints[i][1] = new System.Windows.Point(pR2X, pR2Y);
                                arr2DPoints[i][2] = new System.Windows.Point(pR3X, pR3Y);
                                arr2DPoints[i][3] = new System.Windows.Point(pR4X, pR4Y);

                                arrRotatedPoints.RemoveAt(j);
                                arr2DPoints.RemoveAt(j);

                                float fDiffX = Math.Max(Math.Abs(p1X - p4X), Math.Abs(p2X - p3X));
                                float fDiffY = Math.Max(Math.Abs(p3Y - p4Y), Math.Abs(p2Y - p1Y));
                               
                                fObjectWidthList[i] = fDiffX;
                                fObjectHeightList[i] = fDiffY;

                                fObjectCenterXList[i] = pCenter.X;
                                fObjectCenterYList[i] = pCenter.Y;

                                fObjectAreaList2.RemoveAt(j);
                                fObjectAreaList[i] = fObjectAreaList[i] + fObjectAreaList[j];
                               
                                fObjectHeightList.RemoveAt(j);
                                fObjectWidthList.RemoveAt(j);
                                fObjectCenterXList.RemoveAt(j);
                                fObjectCenterYList.RemoveAt(j);
                                fObjectAngleList.RemoveAt(j);
                                fObjectAreaList.RemoveAt(j);
                               
                                if (j > 0)
                                    j = -1;
                                if (i > 0)
                                {
                                    i = 0;
                                }
                                else
                                    blnDecrement = true;

                            }
                            
                        }
                    }
                }
            }
            for (int i = 0; i < fObjectHeightList.Count; i++)
            {
                if (fObjectHeightList[i] < fObjectWidthList[i])
                {
                    fObjectWidth = fObjectHeightList[i];
                    fObjectHeight = fObjectWidthList[i];

                    fObjectAngle = fObjectAngleList[i];

                    if (fObjectAngle >= 10)//&& fAngle <= 80)
                        fObjectAngle = fObjectAngleList[i] - 90;
                    else
                        fObjectAngle = 90 + fObjectAngleList[i];

                    fObjectWidthList[i] = fObjectWidth;
                    fObjectHeightList[i] = fObjectHeight;
                    fObjectAngleList[i] = fObjectAngle;
                }
                else
                {
                    fObjectHeight = fObjectHeightList[i];
                    fObjectWidth = fObjectWidthList[i];

                    fObjectAngle = fObjectAngleList[i];

                    fObjectWidthList[i] = fObjectWidth;
                    fObjectHeightList[i] = fObjectHeight;
                    fObjectAngleList[i] = fObjectAngle;
                }

                bool blnFail = false;
                int intFailMask = 0;
                string strDefectName = "Crack";

                if (m_arrWantDefectLength[(int)eWantDefect.Crack])
                {
                    if (m_intCrackDarkDefectDimensionFailCondition == 0)
                    {
                        if (fObjectWidthList[i] >= GetDefect("Crack", 0))
                        {
                            m_strErrorMessage += "* Crack Width Fail. Set = " + (GetDefect("Crack", 0) / m_fMMToPixelXValue).ToString("f5") + " mm,   Result = " + (fObjectWidthList[i] / m_fMMToPixelXValue).ToString("f5") + " mm";
                            blnFail = true;
                            intFailMask |= 0x01;
                            strDefectName = "Crack";
                        }

                        if (fObjectHeightList[i] >= GetDefect("Crack", 1))
                        {
                            m_strErrorMessage += "* Crack Length Fail. Set = " + (GetDefect("Crack", 1) / m_fMMToPixelYValue).ToString("f5") + " mm,   Result = " + (fObjectHeightList[i] / m_fMMToPixelYValue).ToString("f5") + " mm";
                            blnFail = true;
                            intFailMask |= 0x02;
                            strDefectName = "Crack";
                        }
                    }
                    else
                    {
                        if ((fObjectWidthList[i] >= GetDefect("Crack", 0)) && (fObjectHeightList[i] >= GetDefect("Crack", 1)))
                        {
                            m_strErrorMessage += "* Crack Width Fail. Set = " + (GetDefect("Crack", 0) / m_fMMToPixelXValue).ToString("f5") + " mm,   Result = " + (fObjectWidthList[i] / m_fMMToPixelXValue).ToString("f5") + " mm";
                            intFailMask |= 0x01;
                            m_strErrorMessage += "* Crack Length Fail. Set = " + (GetDefect("Crack", 1) / m_fMMToPixelYValue).ToString("f5") + " mm,   Result = " + (fObjectHeightList[i] / m_fMMToPixelYValue).ToString("f5") + " mm";
                            blnFail = true;
                            intFailMask |= 0x02;
                            strDefectName = "Crack";
                        }
                    }
                }

                if (m_arrWantDefectArea[(int)eWantDefect.Crack])
                {
                    if (fObjectAreaList[i] >= GetAreaDefect("Crack"))
                    {
                        m_strErrorMessage += "* Crack Area Fail. Set = " + (GetAreaDefect("Crack") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (fObjectAreaList[i] / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        blnFail = true;
                        intFailMask |= 0x04;
                        strDefectName = "Crack";
                    }
                }
                
                if (blnFail)
                {
                    Defect objDefect = new Defect();
                    objDefect.ref_fDimX = fObjectWidthList[i];
                    objDefect.ref_fDimY = fObjectHeightList[i];
                    objDefect.ref_intLengthMode = intLengthMode;
                    objDefect.ref_fArea = fObjectAreaList[i];
                    objDefect.ref_fCenterX = objROI.ref_ROITotalX + fObjectCenterXList[i];
                    objDefect.ref_fCenterY = objROI.ref_ROITotalY + fObjectCenterYList[i];
                    objDefect.ref_fAngle = fObjectAngleList[i];
                    objDefect.ref_intBlobNo = i;
                    objDefect.ref_intFailMask = intFailMask;
                    objDefect.ref_strName = strDefectName;
                    objDefect.ref_intFailedImage = intSelectedImageIndex + 1;
                    m_arrDefectList.Add(objDefect);

                    if (!blnOverAllFail)
                        blnOverAllFail = true;
                }
                else
                {
                    Defect objDefect = new Defect();
                    objDefect.ref_fDimX = fObjectWidthList[i];
                    objDefect.ref_fDimY = fObjectHeightList[i];
                    objDefect.ref_intLengthMode = intLengthMode;
                    objDefect.ref_fArea = fObjectAreaList[i];
                    objDefect.ref_fCenterX = objROI.ref_ROITotalX + fObjectCenterXList[i];
                    objDefect.ref_fCenterY = objROI.ref_ROITotalY + fObjectCenterYList[i];
                    objDefect.ref_fAngle = fObjectAngleList[i];
                    objDefect.ref_intBlobNo = i;
                    objDefect.ref_intFailMask = 0;
                    objDefect.ref_strName = strDefectName;
                    objDefect.ref_intFailedImage = intSelectedImageIndex + 1;
                    m_arrDefectList.Add(objDefect);
                }
            }

            if (m_arrWantDefectArea[(int)eWantDefect.Crack])
            {
                if (intObjectTotalArea >= GetTotalAreaDefect("Crack"))
                {
                    m_strErrorMessage += "* Crack Total Area Fail. Set = " + (GetTotalAreaDefect("Crack") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectTotalArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                    m_blnCrackChipViewFailTotalArea = true;

                    Defect objDefect = new Defect();
                    objDefect.ref_fDimX = -1;
                    objDefect.ref_fDimY = -1;
                    objDefect.ref_intLengthMode = intLengthMode;
                    objDefect.ref_fArea = intObjectTotalArea;
                    objDefect.ref_fCenterX = objROI.ref_ROITotalX + m_objEBlobs.ref_arrRectLimitCenterX[0];
                    objDefect.ref_fCenterY = objROI.ref_ROITotalY + m_objEBlobs.ref_arrRectLimitCenterY[0];
                    objDefect.ref_fAngle = fObjectAngle; //m_objEBlobs.ref_arrRectAngle[0];
                    objDefect.ref_intFailMask |= 0x04;
                    objDefect.ref_strName = "Total Crack";
                    objDefect.ref_intFailedImage = intSelectedImageIndex + 1;
                    m_arrDefectList.Add(objDefect);

                    if (!blnOverAllFail)
                        blnOverAllFail = true;
                }
            }

            if (blnOverAllFail)
            {
                m_intPkgFailResultMask |= 0x01;
                return false;
            }
            else
                return true;
        }
        public bool InspectionImage3DarkFieldDefect(ROI objROI)
        {
            int intSelectedImageIndex = m_arrGrabImageIndex[3];

            int intSelectedObjectNum = m_objEBlobs.BuildObjects_Filter_GetElement_DoubleThreshold(
                objROI, true, false, false, m_intConnexity == 8, m_intDarkFieldLowThreshold, m_intDarkFieldHighThreshold,
                m_intDarkFieldMinArea, objROI.ref_ROIWidth * objROI.ref_ROIHeight, false, 0xED);

            if (intSelectedObjectNum == 0)
                return true;

            int intObjectTotalArea = 0;
            int intObjectArea = 0;
            int intLengthMode = 0;
            float fObjectHeight = 0, fObjectWidth = 0, fObjectCenterX = 0, fObjectCenterY = 0, fObjectAngle = 0;
            bool blnOverAllFail = false;
            for (int i = 0; i < intSelectedObjectNum; i++)
            {

                intObjectArea = m_objEBlobs.ref_arrArea[i];
                //if (m_objEBlobs.ref_arrRectWidth[i] < m_objEBlobs.ref_arrRectHeight[i])
                //{
                //    fObjectWidth = m_objEBlobs.ref_arrRectWidth[i];
                //    fObjectHeight = m_objEBlobs.ref_arrRectHeight[i];
                //    intLengthMode = 0;

                //    fObjectAngle = m_objEBlobs.ref_arrRectAngle[i];
                //    if (fObjectAngle < 0)
                //        fObjectAngle = -Math.Abs(fObjectAngle);
                //    else
                //        fObjectAngle = -fObjectAngle;

                //}
                //else
                //{
                //    fObjectHeight = m_objEBlobs.ref_arrRectWidth[i];
                //    fObjectWidth = m_objEBlobs.ref_arrRectHeight[i];
                //    intLengthMode = 0;  //1;

                //    fObjectAngle = m_objEBlobs.ref_arrRectAngle[i];
                //    if (fObjectAngle < 0)
                //        fObjectAngle = Math.Abs(fObjectAngle);
                //    else
                //        fObjectAngle = 90 - (fObjectAngle);
                //}

                if (m_objEBlobs.ref_arrRectHeight[i] < m_objEBlobs.ref_arrRectWidth[i])
                {
                    fObjectWidth = m_objEBlobs.ref_arrRectHeight[i];
                    fObjectHeight = m_objEBlobs.ref_arrRectWidth[i];
                    intLengthMode = 0;
                    fObjectAngle = m_objEBlobs.ref_arrRectAngle[i];

                    if (fObjectAngle >= 10)//&& fAngle <= 80)
                        fObjectAngle = m_objEBlobs.ref_arrRectAngle[i] - 90;
                    else
                        fObjectAngle = 90 + m_objEBlobs.ref_arrRectAngle[i];

                }
                else
                {
                    fObjectHeight = m_objEBlobs.ref_arrRectHeight[i];
                    fObjectWidth = m_objEBlobs.ref_arrRectWidth[i];
                    intLengthMode = 0;

                    fObjectAngle = m_objEBlobs.ref_arrRectAngle[i];

                }
                fObjectCenterX = m_objEBlobs.ref_arrRectLimitCenterX[i];
                fObjectCenterY = m_objEBlobs.ref_arrRectLimitCenterY[i];
                intObjectTotalArea += intObjectArea;

                bool blnFail = false;
                int intFailMask = 0;
                string strDefectName = "Dark";
                if (m_arrWantDefectLength[(int)eWantDefect.Dark])
                {
                    if (m_intDarkDefectDimensionFailCondition == 0)
                    {
                        if (fObjectWidth >= GetDefect("Dark", 0))
                        {
                            m_strErrorMessage += "* Package Dark Field Width Fail. Set = " + (GetDefect("Dark", 0) / m_fMMToPixelXValue).ToString("f5") + " mm,   Result = " + (fObjectWidth / m_fMMToPixelXValue).ToString("f5") + " mm";
                            blnFail = true;
                            intFailMask |= 0x01;
                            strDefectName = "Dark";
                        }

                        if (fObjectHeight >= GetDefect("Dark", 1))
                        {
                            m_strErrorMessage += "* Package Dark Field Length Fail. Set = " + (GetDefect("Dark", 1) / m_fMMToPixelYValue).ToString("f5") + " mm,   Result = " + (fObjectHeight / m_fMMToPixelYValue).ToString("f5") + " mm";
                            blnFail = true;
                            intFailMask |= 0x02;
                            strDefectName = "Dark";
                        }
                    }
                    else
                    {
                        if ((fObjectWidth >= GetDefect("Dark", 0)) && (fObjectHeight >= GetDefect("Dark", 1)))
                        {
                            m_strErrorMessage += "* Package Dark Field Width Fail. Set = " + (GetDefect("Dark", 0) / m_fMMToPixelXValue).ToString("f5") + " mm,   Result = " + (fObjectWidth / m_fMMToPixelXValue).ToString("f5") + " mm";
                            intFailMask |= 0x01;
                            m_strErrorMessage += "* Package Dark Field Length Fail. Set = " + (GetDefect("Dark", 1) / m_fMMToPixelYValue).ToString("f5") + " mm,   Result = " + (fObjectHeight / m_fMMToPixelYValue).ToString("f5") + " mm";
                            blnFail = true;
                            intFailMask |= 0x02;
                            strDefectName = "Dark";
                        }
                    }
                }

                if (m_arrWantDefectArea[(int)eWantDefect.Dark])
                {
                    if (intObjectArea >= GetAreaDefect("Dark"))
                    {
                        m_strErrorMessage += "* Package Dark Field Area Fail. Set = " + (GetAreaDefect("Dark") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        blnFail = true;
                        intFailMask |= 0x04;
                        strDefectName = "Dark";
                    }
                }

                if (blnFail)
                {
                    Defect objDefect = new Defect();
                    objDefect.ref_fDimX = fObjectWidth;
                    objDefect.ref_fDimY = fObjectHeight;
                    objDefect.ref_intLengthMode = intLengthMode;
                    objDefect.ref_fArea = intObjectArea;
                    objDefect.ref_fCenterX = objROI.ref_ROITotalX + fObjectCenterX;
                    objDefect.ref_fCenterY = objROI.ref_ROITotalY + fObjectCenterY;
                    objDefect.ref_fAngle = fObjectAngle;
                    objDefect.ref_intBlobNo = i;
                    objDefect.ref_intFailMask = intFailMask;
                    objDefect.ref_strName = strDefectName;
                    objDefect.ref_intFailedImage = intSelectedImageIndex + 1;
                    m_arrDefectList.Add(objDefect);

                    if (!blnOverAllFail)
                        blnOverAllFail = true;
                }
                else
                {
                    Defect objDefect = new Defect();
                    objDefect.ref_fDimX = fObjectWidth;
                    objDefect.ref_fDimY = fObjectHeight;
                    objDefect.ref_intLengthMode = intLengthMode;
                    objDefect.ref_fArea = intObjectArea;
                    objDefect.ref_fCenterX = objROI.ref_ROITotalX + fObjectCenterX;
                    objDefect.ref_fCenterY = objROI.ref_ROITotalY + fObjectCenterY;
                    objDefect.ref_fAngle = fObjectAngle;
                    objDefect.ref_intBlobNo = i;
                    objDefect.ref_intFailMask = 0;
                    objDefect.ref_strName = strDefectName;
                    objDefect.ref_intFailedImage = intSelectedImageIndex + 1;
                    m_arrDefectList.Add(objDefect);
                }
            }

            if (m_arrWantDefectArea[(int)eWantDefect.Dark])
            {
                if (intObjectTotalArea >= GetTotalAreaDefect("Dark"))
                {
                    m_strErrorMessage += "* Package Dark Field Total Area Fail. Set = " + (GetTotalAreaDefect("Dark") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectTotalArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                    m_blnCrackChipViewFailTotalArea = true;

                    Defect objDefect = new Defect();
                    objDefect.ref_fDimX = -1;
                    objDefect.ref_fDimY = -1;
                    objDefect.ref_intLengthMode = intLengthMode;
                    objDefect.ref_fArea = intObjectTotalArea;
                    objDefect.ref_fCenterX = objROI.ref_ROITotalX + m_objEBlobs.ref_arrRectLimitCenterX[0];
                    objDefect.ref_fCenterY = objROI.ref_ROITotalY + m_objEBlobs.ref_arrRectLimitCenterY[0];
                    objDefect.ref_fAngle = fObjectAngle; //m_objEBlobs.ref_arrRectAngle[0];
                    objDefect.ref_intFailMask |= 0x04;
                    objDefect.ref_strName = "Total Dark";
                    objDefect.ref_intFailedImage = intSelectedImageIndex + 1;
                    m_arrDefectList.Add(objDefect);

                    if (!blnOverAllFail)
                        blnOverAllFail = true;
                }
            }

            if (blnOverAllFail)
            {
                m_intPkgFailResultMask |= 0x200;
                return false;
            }
            else
                return true;
        }
        public bool InspectionImage3DarkFieldDefect_WithLinkFunction(ROI objROI)
        {
            int intSelectedImageIndex = m_arrGrabImageIndex[3];

            int intSelectedObjectNum = m_objEBlobs.BuildObjects_Filter_GetElement_DoubleThreshold(
                objROI, true, false, false, m_intConnexity == 8, m_intDarkFieldLowThreshold, m_intDarkFieldHighThreshold,
                m_intDarkFieldMinArea, objROI.ref_ROIWidth * objROI.ref_ROIHeight, false, 0xED);

            if (intSelectedObjectNum == 0)
                return true;
            List<List<System.Windows.Point>> arr2DPoints = new List<List<System.Windows.Point>>();
            List<List<PointF>> arrRotatedPoints = new List<List<PointF>>();
            //List<float> fMaxX = new List<float>(), fMaxY = new List<float>(), fMinX = new List<float>(), fMinY = new List<float>();
            //List<float> fMaxLimitX = new List<float>(), fMaxLimitY = new List<float>(), fMinLimitX = new List<float>(), fMinLimitY = new List<float>();
            List<float> fObjectHeightList = new List<float>(), fObjectWidthList = new List<float>(), fObjectCenterXList = new List<float>(), fObjectCenterYList = new List<float>(), fObjectAngleList = new List<float>();
            List<float> fObjectLimitHeightList = new List<float>(), fObjectLimitWidthList = new List<float>(), fObjectLimitCenterXList = new List<float>(), fObjectLimitCenterYList = new List<float>();
            List<int> fObjectAreaList = new List<int>(), fObjectAreaList2 = new List<int>();
            int intObjectTotalArea = 0;
            int intObjectArea = 0;
            int intLengthMode = 0;
            float fObjectHeight = 0, fObjectWidth = 0, fObjectCenterX = 0, fObjectCenterY = 0, fObjectAngle = 0;
            float fObjectLimitHeight = 0, fObjectLimitWidth = 0, fObjectLimitCenterX = 0, fObjectLimitCenterY = 0;
            bool blnOverAllFail = false;
            for (int i = 0; i < intSelectedObjectNum; i++)
            {
                arrRotatedPoints.Add(new List<PointF>());
                arr2DPoints.Add(new List<System.Windows.Point>());
                intObjectArea = m_objEBlobs.ref_arrArea[i];
                //if (m_objEBlobs.ref_arrRectWidth[i] < m_objEBlobs.ref_arrRectHeight[i])
                //{
                //    fObjectWidth = m_objEBlobs.ref_arrRectWidth[i];
                //    fObjectHeight = m_objEBlobs.ref_arrRectHeight[i];
                //    intLengthMode = 0;

                //    fObjectAngle = m_objEBlobs.ref_arrRectAngle[i];
                //    if (fObjectAngle < 0)
                //        fObjectAngle = -Math.Abs(fObjectAngle);
                //    else
                //        fObjectAngle = -fObjectAngle;

                //}
                //else
                //{
                //    fObjectHeight = m_objEBlobs.ref_arrRectWidth[i];
                //    fObjectWidth = m_objEBlobs.ref_arrRectHeight[i];
                //    intLengthMode = 0;  //1;

                //    fObjectAngle = m_objEBlobs.ref_arrRectAngle[i];
                //    if (fObjectAngle < 0)
                //        fObjectAngle = Math.Abs(fObjectAngle);
                //    else
                //        fObjectAngle = 90 - (fObjectAngle);
                //}

                if (m_objEBlobs.ref_arrRectHeight[i] < m_objEBlobs.ref_arrRectWidth[i])
                {
                    fObjectWidth = m_objEBlobs.ref_arrRectHeight[i];
                    fObjectHeight = m_objEBlobs.ref_arrRectWidth[i];
                    intLengthMode = 0;
                    fObjectAngle = m_objEBlobs.ref_arrRectAngle[i];

                    if (fObjectAngle >= 10)//&& fAngle <= 80)
                        fObjectAngle = m_objEBlobs.ref_arrRectAngle[i] - 90;
                    else
                        fObjectAngle = 90 + m_objEBlobs.ref_arrRectAngle[i];

                }
                else
                {
                    fObjectHeight = m_objEBlobs.ref_arrRectHeight[i];
                    fObjectWidth = m_objEBlobs.ref_arrRectWidth[i];
                    intLengthMode = 0;

                    fObjectAngle = m_objEBlobs.ref_arrRectAngle[i];

                }
                fObjectCenterX = m_objEBlobs.ref_arrRectLimitCenterX[i];
                fObjectCenterY = m_objEBlobs.ref_arrRectLimitCenterY[i];

                fObjectLimitCenterX = m_objEBlobs.ref_arrLimitCenterX[i];
                fObjectLimitCenterY = m_objEBlobs.ref_arrLimitCenterY[i];
                fObjectLimitWidth = m_objEBlobs.ref_arrWidth[i];
                fObjectLimitHeight = m_objEBlobs.ref_arrHeight[i];

                intObjectTotalArea += intObjectArea;

                //float MaxX = 0, MaxY = 0, MinX = 0, MinY = 0;
                float newX1 = 0, newY1 = 0;  // new point 1
                float newX2 = 0, newY2 = 0; // new point 2
                float newX3 = 0, newY3 = 0; // new point 3
                float newX4 = 0, newY4 = 0; // new point 4

                //float MaxLimitX = 0, MaxLimitY = 0, MinLimitX = 0, MinLimitY = 0;
                //float newLimitX1 = 0, newLimitY1 = 0;  // new point 1
                //float newLimitX2 = 0, newLimitY2 = 0; // new point 2
                //float newLimitX3 = 0, newLimitY3 = 0; // new point 3
                //float newLimitX4 = 0, newLimitY4 = 0; // new point 4
                ////  Point 1 *-------------* Point 3
                ////          |             |
                ////          |             |
                ////          |             |
                ////  Point 2 *-------------* Point 4

                //Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX - (fObjectWidth / 2)), (fObjectCenterY - (fObjectHeight / 2)), fObjectAngle, ref newX1, ref newY1);
                //Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX - (fObjectWidth / 2)), (fObjectCenterY + (fObjectHeight / 2)), fObjectAngle, ref newX2, ref newY2);
                //Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX + (fObjectWidth / 2)), (fObjectCenterY - (fObjectHeight / 2)), fObjectAngle, ref newX3, ref newY3);
                //Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX + (fObjectWidth / 2)), (fObjectCenterY + (fObjectHeight / 2)), fObjectAngle, ref newX4, ref newY4);


                //2020-12-18 ZJYEOH : Change to this format
                //  Point 1 *-------------* Point 2
                //          |             |
                //          |             |
                //          |             |
                //  Point 4 *-------------* Point 3

                Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX - (fObjectWidth / 2)), (fObjectCenterY - (fObjectHeight / 2)), fObjectAngle, ref newX1, ref newY1);
                Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX + (fObjectWidth / 2)), (fObjectCenterY - (fObjectHeight / 2)), fObjectAngle, ref newX2, ref newY2);
                Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX + (fObjectWidth / 2)), (fObjectCenterY + (fObjectHeight / 2)), fObjectAngle, ref newX3, ref newY3);
                Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX - (fObjectWidth / 2)), (fObjectCenterY + (fObjectHeight / 2)), fObjectAngle, ref newX4, ref newY4);
      
              
                arrRotatedPoints[i].Add(new PointF(newX1, newY1));
                arrRotatedPoints[i].Add(new PointF(newX2, newY2));
                arrRotatedPoints[i].Add(new PointF(newX3, newY3));
                arrRotatedPoints[i].Add(new PointF(newX4, newY4));

                Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX - (fObjectWidth / 2)) - m_intDarkDefectLinkTolerance, (fObjectCenterY - (fObjectHeight / 2)) - m_intDarkDefectLinkTolerance, fObjectAngle, ref newX1, ref newY1);
                Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX + (fObjectWidth / 2)) + m_intDarkDefectLinkTolerance, (fObjectCenterY - (fObjectHeight / 2)) - m_intDarkDefectLinkTolerance, fObjectAngle, ref newX2, ref newY2);
                Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX + (fObjectWidth / 2)) + m_intDarkDefectLinkTolerance, (fObjectCenterY + (fObjectHeight / 2)) + m_intDarkDefectLinkTolerance, fObjectAngle, ref newX3, ref newY3);
                Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX - (fObjectWidth / 2)) - m_intDarkDefectLinkTolerance, (fObjectCenterY + (fObjectHeight / 2)) + m_intDarkDefectLinkTolerance, fObjectAngle, ref newX4, ref newY4);

                arr2DPoints[i].Add(new System.Windows.Point(newX1, newY1));
                arr2DPoints[i].Add(new System.Windows.Point(newX2, newY2));
                arr2DPoints[i].Add(new System.Windows.Point(newX3, newY3));
                arr2DPoints[i].Add(new System.Windows.Point(newX4, newY4));
                
                //if (Math.Max(newX1, newX2) > Math.Max(newX3, newX4))
                //{
                //    MaxX = Math.Max(newX1, newX2);
                //}
                //else
                //{
                //    MaxX = Math.Max(newX3, newX4);
                //}
                //if (Math.Max(newY1, newY2) > Math.Max(newY3, newY4))
                //{
                //    MaxY = Math.Max(newY1, newY2);
                //}
                //else
                //{
                //    MaxY = Math.Max(newY3, newY4);
                //}
                //if (Math.Min(newX1, newX2) < Math.Min(newX3, newX4))
                //{
                //    MinX = Math.Min(newX1, newX2);
                //}
                //else
                //{
                //    MinX = Math.Min(newX3, newX4);
                //}
                //if (Math.Min(newY1, newY2) < Math.Min(newY3, newY4))
                //{
                //    MinY = Math.Min(newY1, newY2);
                //}
                //else
                //{
                //    MinY = Math.Min(newY3, newY4);
                //}
                ////////////////////////////////////////////////////////////////////
                //if (Math.Max(newLimitX1, newLimitX2) > Math.Max(newLimitX3, newLimitX4))
                //{
                //    MaxLimitX = Math.Max(newLimitX1, newLimitX2);
                //}
                //else
                //{
                //    MaxLimitX = Math.Max(newLimitX3, newLimitX4);
                //}
                //if (Math.Max(newLimitY1, newLimitY2) > Math.Max(newLimitY3, newLimitY4))
                //{
                //    MaxLimitY = Math.Max(newLimitY1, newLimitY2);
                //}
                //else
                //{
                //    MaxLimitY = Math.Max(newLimitY3, newLimitY4);
                //}
                //if (Math.Min(newLimitX1, newLimitX2) < Math.Min(newLimitX3, newLimitX4))
                //{
                //    MinLimitX = Math.Min(newLimitX1, newLimitX2);
                //}
                //else
                //{
                //    MinLimitX = Math.Min(newLimitX3, newLimitX4);
                //}
                //if (Math.Min(newLimitY1, newLimitY2) < Math.Min(newLimitY3, newLimitY4))
                //{
                //    MinLimitY = Math.Min(newLimitY1, newLimitY2);
                //}
                //else
                //{
                //    MinLimitY = Math.Min(newLimitY3, newLimitY4);
                //}
                //fMaxX.Add(MaxX);
                //fMaxY.Add(MaxY);
                //fMinX.Add(MinX);
                //fMinY.Add(MinY);
                //fMaxLimitX.Add(MaxLimitX);
                //fMaxLimitY.Add(MaxLimitY);
                //fMinLimitX.Add(MinLimitX);
                //fMinLimitY.Add(MinLimitY);
                fObjectHeightList.Add(fObjectHeight);
                fObjectWidthList.Add(fObjectWidth);
                fObjectCenterXList.Add(fObjectCenterX);
                fObjectCenterYList.Add(fObjectCenterY);
                fObjectAngleList.Add(fObjectAngle);
                fObjectAreaList.Add(intObjectArea);
                fObjectAreaList2.Add(intObjectArea);
            }
            int intTolerance = m_intDarkDefectLinkTolerance;
            int intAngleTolerance = 10;
            bool blnDecrement = false;
            if (intTolerance >= 0)
            {
                for (int i = 0; i < fObjectHeightList.Count; i++)
                {
                    if (blnDecrement)
                    {
                        blnDecrement = false;
                        if (i > 0)
                            i--;
                    }
                    for (int j = 0; j < fObjectHeightList.Count; j++)
                    {
                        if (i != j && i < fObjectHeightList.Count && j < fObjectHeightList.Count)
                        {

                            //if (((fMinY[i] - intTolerance) <= fMaxY[j])// first blob is below second blob,  first blob is after second blob
                            //     && ((fMinY[i]) >= fMinY[j])
                            //    && ((fMinX[i] - intTolerance) <= fMaxX[j])
                            //    && ((fMinX[i]) >= fMinX[j]))
                            if(Intersection.CheckRectRectIntersection(arr2DPoints[i].ToArray(), arr2DPoints[j].ToArray(), intTolerance))
                            {
                                //if (fObjectAreaList2[i] >= fObjectAreaList2[j])
                                //{
                                //    if (fObjectAngleList[i] > 0 && fObjectAngleList[j] > 0)
                                //    {
                                //        if (Math.Abs(fObjectAngleList[i] - fObjectAngleList[j]) > intAngleTolerance)
                                //            continue;
                                //    }
                                //    else if (fObjectAngleList[i] < 0 && fObjectAngleList[j] < 0)
                                //    {
                                //        if (Math.Abs(fObjectAngleList[i] - fObjectAngleList[j]) > intAngleTolerance)
                                //            continue;
                                //    }
                                //    else
                                //        continue;

                                //    fObjectAngleList[i] = fObjectAngleList[i];
                                //    fObjectAreaList2[i] = fObjectAreaList2[i];


                                //}
                                //else
                                //{

                                //    if (fObjectAngleList[i] > 0 && fObjectAngleList[j] > 0)
                                //    {
                                //        if (Math.Abs(fObjectAngleList[i] - fObjectAngleList[j]) > intAngleTolerance)
                                //            continue;
                                //    }
                                //    else if (fObjectAngleList[i] < 0 && fObjectAngleList[j] < 0)
                                //    {
                                //        if (Math.Abs(fObjectAngleList[i] - fObjectAngleList[j]) > intAngleTolerance)
                                //            continue;
                                //    }
                                //    else
                                //        continue;

                                //    fObjectAngleList[i] = fObjectAngleList[j];
                                //    fObjectAreaList2[i] = fObjectAreaList2[j];
                                //}

                                ///////////////////////////
                                //if (Math.Abs(Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i])) - Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i])))
                                //    >= Math.Abs(Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i])) - Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i]))))
                                //{
                                //    fObjectHeightList[i] = Math.Abs(Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i])) - Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i])));
                                //    fObjectWidthList[i] = Math.Abs(Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i])) - Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i])));
                                //    //fObjectCenterXList[i] = (fMaxX[i] + fMinX[j]) / 2;
                                //    //fObjectCenterYList[i] = (fMaxY[i] + fMinY[j]) / 2;
                                //    fObjectAngleList[i] = 0;
                                //}
                                //else
                                //{
                                //    fObjectWidthList[i] = Math.Abs(Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i])) - Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i])));
                                //    fObjectHeightList[i] = Math.Abs(Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i])) - Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i])));
                                //    //fObjectCenterXList[i] = (fMaxY[i] + fMinY[j]) / 2;
                                //    //fObjectCenterYList[i] = (fMaxX[i] + fMinX[j]) / 2;
                                //    fObjectAngleList[i] = 90;
                                //}

                                //fObjectCenterXList[i] = (Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i])) + Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i]))) / 2;
                                //fObjectCenterYList[i] = (Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i])) + Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i]))) / 2;

                                PointF[] arrPoints = new PointF[8];

                                arrPoints[0] = arrRotatedPoints[i][0];
                                arrPoints[1] = arrRotatedPoints[i][1];
                                arrPoints[2] = arrRotatedPoints[i][2];
                                arrPoints[3] = arrRotatedPoints[i][3];
                                arrPoints[4] = arrRotatedPoints[j][0];
                                arrPoints[5] = arrRotatedPoints[j][1];
                                arrPoints[6] = arrRotatedPoints[j][2];
                                arrPoints[7] = arrRotatedPoints[j][3];

                                float fMinAngle = 0;
                                List<PointF> arrMinRect = new List<PointF>();
                                arrMinRect = MinimumBoundingBox.CalculateMinimumBoundingBox(arrPoints, ref fMinAngle);

                                if (fMinAngle < 0)
                                    fObjectAngleList[i] = -(90 + fMinAngle);
                                else
                                    fObjectAngleList[i] = 90 - fMinAngle;
                                
                                Line onjLine1 = new Line();
                                Line onjLine2 = new Line();
                                onjLine1.CalculateStraightLine(arrMinRect[0], arrMinRect[2]);
                                onjLine2.CalculateStraightLine(arrMinRect[1], arrMinRect[3]);
                                PointF pCenter = Line.GetCrossPoint(onjLine1, onjLine2);
                                float p1X = 0, p1Y = 0;
                                float p2X = 0, p2Y = 0;
                                float p3X = 0, p3Y = 0;
                                float p4X = 0, p4Y = 0;
                                Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[0].X, arrMinRect[0].Y, -fObjectAngleList[i], ref p1X, ref p1Y);
                                Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[1].X, arrMinRect[1].Y, -fObjectAngleList[i], ref p2X, ref p2Y);
                                Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[2].X, arrMinRect[2].Y, -fObjectAngleList[i], ref p3X, ref p3Y);
                                Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[3].X, arrMinRect[3].Y, -fObjectAngleList[i], ref p4X, ref p4Y);

                                float pR1X = 0, pR1Y = 0;
                                float pR2X = 0, pR2Y = 0;
                                float pR3X = 0, pR3Y = 0;
                                float pR4X = 0, pR4Y = 0;
                                Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)), Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)), fObjectAngleList[i], ref pR1X, ref pR1Y); // Top Left
                                Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)), Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)), fObjectAngleList[i], ref pR2X, ref pR2Y); // Top Right
                                Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)), Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)), fObjectAngleList[i], ref pR3X, ref pR3Y); // Bottom Right
                                Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)), Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)), fObjectAngleList[i], ref pR4X, ref pR4Y); // Bottom Left
                                arrMinRect[0] = new PointF(pR1X, pR1Y);
                                arrMinRect[1] = new PointF(pR2X, pR2Y);
                                arrMinRect[2] = new PointF(pR3X, pR3Y);
                                arrMinRect[3] = new PointF(pR4X, pR4Y);

                                //arrRotatedPoints[i][0] = arrMinRect[3];
                                //arrRotatedPoints[i][1] = arrMinRect[2];
                                //arrRotatedPoints[i][2] = arrMinRect[0];
                                //arrRotatedPoints[i][3] = arrMinRect[1];
                                arrRotatedPoints[i][0] = arrMinRect[0];
                                arrRotatedPoints[i][1] = arrMinRect[1];
                                arrRotatedPoints[i][2] = arrMinRect[2];
                                arrRotatedPoints[i][3] = arrMinRect[3];

                                Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)) - m_intDarkDefectLinkTolerance, Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)) - m_intDarkDefectLinkTolerance, fObjectAngleList[i], ref pR1X, ref pR1Y); // Top Left
                                Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)) + m_intDarkDefectLinkTolerance, Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)) - m_intDarkDefectLinkTolerance, fObjectAngleList[i], ref pR2X, ref pR2Y); // Top Right
                                Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)) + m_intDarkDefectLinkTolerance, Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)) + m_intDarkDefectLinkTolerance, fObjectAngleList[i], ref pR3X, ref pR3Y); // Bottom Right
                                Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)) - m_intDarkDefectLinkTolerance, Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)) + m_intDarkDefectLinkTolerance, fObjectAngleList[i], ref pR4X, ref pR4Y); // Bottom Left

                                arr2DPoints[i][0] = new System.Windows.Point(pR1X, pR1Y);
                                arr2DPoints[i][1] = new System.Windows.Point(pR2X, pR2Y);
                                arr2DPoints[i][2] = new System.Windows.Point(pR3X, pR3Y);
                                arr2DPoints[i][3] = new System.Windows.Point(pR4X, pR4Y);

                                arrRotatedPoints.RemoveAt(j);
                                arr2DPoints.RemoveAt(j);

                                float fDiffX = Math.Max(Math.Abs(p1X - p4X), Math.Abs(p2X - p3X));
                                float fDiffY = Math.Max(Math.Abs(p3Y - p4Y), Math.Abs(p2Y - p1Y));
                                //float fWidth = (int)Math.Round((fDiffX * Math.Cos((fMinAngle + 180) * Math.PI / 180)) + (fDiffY * Math.Sin((fMinAngle + 180) * Math.PI / 180)));
                                //float fHeight = (int)Math.Round((fDiffX * Math.Sin((fMinAngle + 180) * Math.PI / 180)) + (fDiffY * Math.Cos((fMinAngle + 180) * Math.PI / 180)));
                                fObjectWidthList[i] = fDiffX;
                                fObjectHeightList[i] = fDiffY;

                                fObjectCenterXList[i] = pCenter.X;
                                fObjectCenterYList[i] = pCenter.Y;

                                fObjectAreaList2.RemoveAt(j);
                                fObjectAreaList[i] = fObjectAreaList[i] + fObjectAreaList[j];
                                //fMinX[i] = Math.Min(Math.Min(arrMinRect[0].X, arrMinRect[1].X), Math.Min(arrMinRect[2].X, arrMinRect[3].X));
                                //fMinY[i] = Math.Min(Math.Min(arrMinRect[0].Y, arrMinRect[1].Y), Math.Min(arrMinRect[2].Y, arrMinRect[3].Y));
                                //fMaxX[i] = Math.Max(Math.Max(arrMinRect[0].X, arrMinRect[1].X), Math.Max(arrMinRect[2].X, arrMinRect[3].X));
                                //fMaxY[i] = Math.Max(Math.Max(arrMinRect[0].Y, arrMinRect[1].Y), Math.Max(arrMinRect[2].Y, arrMinRect[3].Y));
                                //fMinLimitX[i] = Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i]));
                                //fMinLimitY[i] = Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i]));
                                //fMaxLimitX[i] = Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i]));
                                //fMaxLimitY[i] = Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i]));
                                //fMinX[i] = Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i]));
                                //fMinY[i] = Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i]));
                                //fMaxX[i] = Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i]));
                                //fMaxY[i] = Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i]));
                                //fMinLimitX[i] = Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i]));
                                //fMinLimitY[i] = Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i]));
                                //fMaxLimitX[i] = Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i]));
                                //fMaxLimitY[i] = Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i]));
                                fObjectHeightList.RemoveAt(j);
                                fObjectWidthList.RemoveAt(j);
                                fObjectCenterXList.RemoveAt(j);
                                fObjectCenterYList.RemoveAt(j);
                                fObjectAngleList.RemoveAt(j);
                                fObjectAreaList.RemoveAt(j);
                                //fMaxLimitX.RemoveAt(j);
                                //fMaxLimitY.RemoveAt(j);
                                //fMinLimitX.RemoveAt(j);
                                //fMinLimitY.RemoveAt(j);
                                //fMaxX.RemoveAt(j);
                                //fMaxY.RemoveAt(j);
                                //fMinX.RemoveAt(j);
                                //fMinY.RemoveAt(j);
                                if (j > 0)
                                    j = -1;
                                if (i > 0)
                                {
                                    i = 0;
                                    //blnDecrement = true;
                                }
                                else
                                    blnDecrement = true;

                            }
                            //else if (((fMinY[i] - intTolerance) <= fMaxY[j])// first blob is below second blob, first blob is before second blob
                            //    && ((fMinY[i]) >= fMinY[j])
                            //   && ((fMaxX[i] + intTolerance) >= fMinX[j])
                            //    && ((fMaxX[i]) <= fMaxX[j]))
                            //{
                            //    //if (fObjectAreaList2[i] >= fObjectAreaList2[j])
                            //    //{
                            //    //    if (fObjectAngleList[i] > 0 && fObjectAngleList[j] > 0)
                            //    //    {
                            //    //        if (Math.Abs(fObjectAngleList[i] - fObjectAngleList[j]) > intAngleTolerance)
                            //    //            continue;
                            //    //    }
                            //    //    else if (fObjectAngleList[i] < 0 && fObjectAngleList[j] < 0)
                            //    //    {
                            //    //        if (Math.Abs(fObjectAngleList[i] - fObjectAngleList[j]) > intAngleTolerance)
                            //    //            continue;
                            //    //    }
                            //    //    else
                            //    //        continue;

                            //    //    fObjectAngleList[i] = fObjectAngleList[i];
                            //    //    fObjectAreaList2[i] = fObjectAreaList2[i];


                            //    //}
                            //    //else
                            //    //{

                            //    //    if (fObjectAngleList[i] > 0 && fObjectAngleList[j] > 0)
                            //    //    {
                            //    //        if (Math.Abs(fObjectAngleList[i] - fObjectAngleList[j]) > intAngleTolerance)
                            //    //            continue;
                            //    //    }
                            //    //    else if (fObjectAngleList[i] < 0 && fObjectAngleList[j] < 0)
                            //    //    {
                            //    //        if (Math.Abs(fObjectAngleList[i] - fObjectAngleList[j]) > intAngleTolerance)
                            //    //            continue;
                            //    //    }
                            //    //    else
                            //    //        continue;

                            //    //    fObjectAngleList[i] = fObjectAngleList[j];
                            //    //    fObjectAreaList2[i] = fObjectAreaList2[j];
                            //    //}
                            //    //if (Math.Abs(Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i])) - Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i])))
                            //    //    >= Math.Abs(Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i])) - Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i]))))
                            //    //{
                            //    //    fObjectHeightList[i] = Math.Abs(Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i])) - Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i])));
                            //    //    fObjectWidthList[i] = Math.Abs(Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i])) - Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i])));
                            //    //    //fObjectCenterXList[i] = (fMaxX[i] + fMinX[j]) / 2;
                            //    //    //fObjectCenterYList[i] = (fMaxY[i] + fMinY[j]) / 2;
                            //    //    fObjectAngleList[i] = 0;
                            //    //}
                            //    //else
                            //    //{
                            //    //    fObjectWidthList[i] = Math.Abs(Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i])) - Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i])));
                            //    //    fObjectHeightList[i] = Math.Abs(Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i])) - Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i])));
                            //    //    //fObjectCenterXList[i] = (fMaxY[i] + fMinY[j]) / 2;
                            //    //    //fObjectCenterYList[i] = (fMaxX[i] + fMinX[j]) / 2;
                            //    //    fObjectAngleList[i] = 90;
                            //    //}
                            //    //fObjectCenterXList[i] = (Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i])) + Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i]))) / 2;
                            //    //fObjectCenterYList[i] = (Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i])) + Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i]))) / 2;

                            //    PointF[] arrPoints = new PointF[8];

                            //    arrPoints[0] = arrRotatedPoints[i][0];
                            //    arrPoints[1] = arrRotatedPoints[i][1];
                            //    arrPoints[2] = arrRotatedPoints[i][2];
                            //    arrPoints[3] = arrRotatedPoints[i][3];
                            //    arrPoints[4] = arrRotatedPoints[j][0];
                            //    arrPoints[5] = arrRotatedPoints[j][1];
                            //    arrPoints[6] = arrRotatedPoints[j][2];
                            //    arrPoints[7] = arrRotatedPoints[j][3];

                            //    float fMinAngle = 0;
                            //    List<PointF> arrMinRect = new List<PointF>();
                            //    arrMinRect = MinimumBoundingBox.CalculateMinimumBoundingBox(arrPoints, ref fMinAngle);

                            //    arrRotatedPoints[i][0] = arrMinRect[3];
                            //    arrRotatedPoints[i][1] = arrMinRect[2];
                            //    arrRotatedPoints[i][2] = arrMinRect[0];
                            //    arrRotatedPoints[i][3] = arrMinRect[1];
                            //    arrRotatedPoints.RemoveAt(j);

                            //    if (fMinAngle < 0)
                            //        fObjectAngleList[i] = -(90 + fMinAngle);
                            //    else
                            //        fObjectAngleList[i] = 90 - fMinAngle;

                            //    Line onjLine1 = new Line();
                            //    Line onjLine2 = new Line();
                            //    onjLine1.CalculateStraightLine(arrMinRect[0], arrMinRect[2]);
                            //    onjLine2.CalculateStraightLine(arrMinRect[1], arrMinRect[3]);
                            //    PointF pCenter = Line.GetCrossPoint(onjLine1, onjLine2);
                            //    float p1X = 0, p1Y = 0;
                            //    float p2X = 0, p2Y = 0;
                            //    float p3X = 0, p3Y = 0;
                            //    float p4X = 0, p4Y = 0;
                            //    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[0].X, arrMinRect[0].Y, -fObjectAngleList[i], ref p1X, ref p1Y);
                            //    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[1].X, arrMinRect[1].Y, -fObjectAngleList[i], ref p2X, ref p2Y);
                            //    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[2].X, arrMinRect[2].Y, -fObjectAngleList[i], ref p3X, ref p3Y);
                            //    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[3].X, arrMinRect[3].Y, -fObjectAngleList[i], ref p4X, ref p4Y);

                            //    float fDiffX = Math.Max(Math.Abs(p1X - p4X), Math.Abs(p2X - p3X));
                            //    float fDiffY = Math.Max(Math.Abs(p3Y - p4Y), Math.Abs(p2Y - p1Y));
                            //    //float fWidth = (int)Math.Round((fDiffX * Math.Cos((fMinAngle + 180) * Math.PI / 180)) + (fDiffY * Math.Sin((fMinAngle + 180) * Math.PI / 180)));
                            //    //float fHeight = (int)Math.Round((fDiffX * Math.Sin((fMinAngle + 180) * Math.PI / 180)) + (fDiffY * Math.Cos((fMinAngle + 180) * Math.PI / 180)));
                            //    fObjectWidthList[i] = fDiffX;
                            //    fObjectHeightList[i] = fDiffY;

                            //    fObjectCenterXList[i] = pCenter.X;
                            //    fObjectCenterYList[i] = pCenter.Y;

                            //    fObjectAreaList2.RemoveAt(j);
                            //    fObjectAreaList[i] = fObjectAreaList[i] + fObjectAreaList[j];
                            //    fMinX[i] = Math.Min(Math.Min(arrMinRect[0].X, arrMinRect[1].X), Math.Min(arrMinRect[2].X, arrMinRect[3].X));
                            //    fMinY[i] = Math.Min(Math.Min(arrMinRect[0].Y, arrMinRect[1].Y), Math.Min(arrMinRect[2].Y, arrMinRect[3].Y));
                            //    fMaxX[i] = Math.Max(Math.Max(arrMinRect[0].X, arrMinRect[1].X), Math.Max(arrMinRect[2].X, arrMinRect[3].X));
                            //    fMaxY[i] = Math.Max(Math.Max(arrMinRect[0].Y, arrMinRect[1].Y), Math.Max(arrMinRect[2].Y, arrMinRect[3].Y));
                            //    //fMinLimitX[i] = Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i]));
                            //    //fMinLimitY[i] = Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i]));
                            //    //fMaxLimitX[i] = Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i]));
                            //    //fMaxLimitY[i] = Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i]));
                            //    //fMinX[i] = Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i]));
                            //    //fMinY[i] = Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i]));
                            //    //fMaxX[i] = Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i]));
                            //    //fMaxY[i] = Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i]));
                            //    //fMinLimitX[i] = Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i]));
                            //    //fMinLimitY[i] = Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i]));
                            //    //fMaxLimitX[i] = Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i]));
                            //    //fMaxLimitY[i] = Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i]));
                            //    fObjectHeightList.RemoveAt(j);
                            //    fObjectWidthList.RemoveAt(j);
                            //    fObjectCenterXList.RemoveAt(j);
                            //    fObjectCenterYList.RemoveAt(j);
                            //    fObjectAngleList.RemoveAt(j);
                            //    fObjectAreaList.RemoveAt(j);
                            //    //fMaxLimitX.RemoveAt(j);
                            //    //fMaxLimitY.RemoveAt(j);
                            //    //fMinLimitX.RemoveAt(j);
                            //    //fMinLimitY.RemoveAt(j);
                            //    fMaxX.RemoveAt(j);
                            //    fMaxY.RemoveAt(j);
                            //    fMinX.RemoveAt(j);
                            //    fMinY.RemoveAt(j);
                            //    if (j > 0)
                            //        j = -1;
                            //    if (i > 0)
                            //    {
                            //        i = 0;
                            //        //blnDecrement = true;
                            //    }
                            //    else
                            //        blnDecrement = true;
                            //}
                            //else if (((fMinY[j] - intTolerance) <= fMaxY[i])// first blob is above second blob, first blob is after second blob
                            //    && ((fMinY[j]) >= fMinY[i])
                            //  && ((fMinX[i] - intTolerance) <= fMaxX[j])
                            //    && ((fMinX[i]) >= fMinX[j]))
                            //{
                            //    //if (fObjectAreaList2[i] >= fObjectAreaList2[j])
                            //    //{
                            //    //    if (fObjectAngleList[i] > 0 && fObjectAngleList[j] > 0)
                            //    //    {
                            //    //        if (Math.Abs(fObjectAngleList[i] - fObjectAngleList[j]) > intAngleTolerance)
                            //    //            continue;
                            //    //    }
                            //    //    else if (fObjectAngleList[i] < 0 && fObjectAngleList[j] < 0)
                            //    //    {
                            //    //        if (Math.Abs(fObjectAngleList[i] - fObjectAngleList[j]) > intAngleTolerance)
                            //    //            continue;
                            //    //    }
                            //    //    else
                            //    //        continue;

                            //    //    fObjectAngleList[i] = fObjectAngleList[i];
                            //    //    fObjectAreaList2[i] = fObjectAreaList2[i];


                            //    //}
                            //    //else
                            //    //{

                            //    //    if (fObjectAngleList[i] > 0 && fObjectAngleList[j] > 0)
                            //    //    {
                            //    //        if (Math.Abs(fObjectAngleList[i] - fObjectAngleList[j]) > intAngleTolerance)
                            //    //            continue;
                            //    //    }
                            //    //    else if (fObjectAngleList[i] < 0 && fObjectAngleList[j] < 0)
                            //    //    {
                            //    //        if (Math.Abs(fObjectAngleList[i] - fObjectAngleList[j]) > intAngleTolerance)
                            //    //            continue;
                            //    //    }
                            //    //    else
                            //    //        continue;

                            //    //    fObjectAngleList[i] = fObjectAngleList[j];
                            //    //    fObjectAreaList2[i] = fObjectAreaList2[j];
                            //    //}
                            //    //if (Math.Abs(Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i])) - Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i])))
                            //    //    >= Math.Abs(Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i])) - Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i]))))
                            //    //{
                            //    //    fObjectHeightList[i] = Math.Abs(Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i])) - Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i])));
                            //    //    fObjectWidthList[i] = Math.Abs(Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i])) - Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i])));
                            //    //    //fObjectCenterXList[i] = (fMaxX[i] + fMinX[j]) / 2;
                            //    //    //fObjectCenterYList[i] = (fMaxY[i] + fMinY[j]) / 2;
                            //    //    fObjectAngleList[i] = 0;
                            //    //}
                            //    //else
                            //    //{
                            //    //    fObjectWidthList[i] = Math.Abs(Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i])) - Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i])));
                            //    //    fObjectHeightList[i] = Math.Abs(Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i])) - Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i])));
                            //    //    //fObjectCenterXList[i] = (fMaxY[i] + fMinY[j]) / 2;
                            //    //    //fObjectCenterYList[i] = (fMaxX[i] + fMinX[j]) / 2;
                            //    //    fObjectAngleList[i] = 90;
                            //    //}
                            //    //fObjectCenterXList[i] = (Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i])) + Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i]))) / 2;
                            //    //fObjectCenterYList[i] = (Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i])) + Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i]))) / 2;
                            //    PointF[] arrPoints = new PointF[8];

                            //    arrPoints[0] = arrRotatedPoints[i][0];
                            //    arrPoints[1] = arrRotatedPoints[i][1];
                            //    arrPoints[2] = arrRotatedPoints[i][2];
                            //    arrPoints[3] = arrRotatedPoints[i][3];
                            //    arrPoints[4] = arrRotatedPoints[j][0];
                            //    arrPoints[5] = arrRotatedPoints[j][1];
                            //    arrPoints[6] = arrRotatedPoints[j][2];
                            //    arrPoints[7] = arrRotatedPoints[j][3];

                            //    float fMinAngle = 0;
                            //    List<PointF> arrMinRect = new List<PointF>();
                            //    arrMinRect = MinimumBoundingBox.CalculateMinimumBoundingBox(arrPoints, ref fMinAngle);

                            //    arrRotatedPoints[i][0] = arrMinRect[3];
                            //    arrRotatedPoints[i][1] = arrMinRect[2];
                            //    arrRotatedPoints[i][2] = arrMinRect[0];
                            //    arrRotatedPoints[i][3] = arrMinRect[1];
                            //    arrRotatedPoints.RemoveAt(j);

                            //    if (fMinAngle < 0)
                            //        fObjectAngleList[i] = -(90 + fMinAngle);
                            //    else
                            //        fObjectAngleList[i] = 90 - fMinAngle;

                            //    Line onjLine1 = new Line();
                            //    Line onjLine2 = new Line();
                            //    onjLine1.CalculateStraightLine(arrMinRect[0], arrMinRect[2]);
                            //    onjLine2.CalculateStraightLine(arrMinRect[1], arrMinRect[3]);
                            //    PointF pCenter = Line.GetCrossPoint(onjLine1, onjLine2);
                            //    float p1X = 0, p1Y = 0;
                            //    float p2X = 0, p2Y = 0;
                            //    float p3X = 0, p3Y = 0;
                            //    float p4X = 0, p4Y = 0;
                            //    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[0].X, arrMinRect[0].Y, -fObjectAngleList[i], ref p1X, ref p1Y);
                            //    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[1].X, arrMinRect[1].Y, -fObjectAngleList[i], ref p2X, ref p2Y);
                            //    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[2].X, arrMinRect[2].Y, -fObjectAngleList[i], ref p3X, ref p3Y);
                            //    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[3].X, arrMinRect[3].Y, -fObjectAngleList[i], ref p4X, ref p4Y);

                            //    float fDiffX = Math.Max(Math.Abs(p1X - p4X), Math.Abs(p2X - p3X));
                            //    float fDiffY = Math.Max(Math.Abs(p3Y - p4Y), Math.Abs(p2Y - p1Y));
                            //    //float fWidth = (int)Math.Round((fDiffX * Math.Cos((fMinAngle + 180) * Math.PI / 180)) + (fDiffY * Math.Sin((fMinAngle + 180) * Math.PI / 180)));
                            //    //float fHeight = (int)Math.Round((fDiffX * Math.Sin((fMinAngle + 180) * Math.PI / 180)) + (fDiffY * Math.Cos((fMinAngle + 180) * Math.PI / 180)));
                            //    fObjectWidthList[i] = fDiffX;
                            //    fObjectHeightList[i] = fDiffY;

                            //    fObjectCenterXList[i] = pCenter.X;
                            //    fObjectCenterYList[i] = pCenter.Y;

                            //    fObjectAreaList2.RemoveAt(j);
                            //    fObjectAreaList[i] = fObjectAreaList[i] + fObjectAreaList[j];
                            //    fMinX[i] = Math.Min(Math.Min(arrMinRect[0].X, arrMinRect[1].X), Math.Min(arrMinRect[2].X, arrMinRect[3].X));
                            //    fMinY[i] = Math.Min(Math.Min(arrMinRect[0].Y, arrMinRect[1].Y), Math.Min(arrMinRect[2].Y, arrMinRect[3].Y));
                            //    fMaxX[i] = Math.Max(Math.Max(arrMinRect[0].X, arrMinRect[1].X), Math.Max(arrMinRect[2].X, arrMinRect[3].X));
                            //    fMaxY[i] = Math.Max(Math.Max(arrMinRect[0].Y, arrMinRect[1].Y), Math.Max(arrMinRect[2].Y, arrMinRect[3].Y));
                            //    //fMinLimitX[i] = Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i]));
                            //    //fMinLimitY[i] = Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i]));
                            //    //fMaxLimitX[i] = Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i]));
                            //    //fMaxLimitY[i] = Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i]));
                            //    //fMinX[i] = Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i]));
                            //    //fMinY[i] = Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i]));
                            //    //fMaxX[i] = Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i]));
                            //    //fMaxY[i] = Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i]));
                            //    //fMinLimitX[i] = Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i]));
                            //    //fMinLimitY[i] = Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i]));
                            //    //fMaxLimitX[i] = Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i]));
                            //    //fMaxLimitY[i] = Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i]));
                            //    fObjectHeightList.RemoveAt(j);
                            //    fObjectWidthList.RemoveAt(j);
                            //    fObjectCenterXList.RemoveAt(j);
                            //    fObjectCenterYList.RemoveAt(j);
                            //    fObjectAngleList.RemoveAt(j);
                            //    fObjectAreaList.RemoveAt(j);
                            //    //fMaxLimitX.RemoveAt(j);
                            //    //fMaxLimitY.RemoveAt(j);
                            //    //fMinLimitX.RemoveAt(j);
                            //    //fMinLimitY.RemoveAt(j);
                            //    fMaxX.RemoveAt(j);
                            //    fMaxY.RemoveAt(j);
                            //    fMinX.RemoveAt(j);
                            //    fMinY.RemoveAt(j);
                            //    if (j > 0)
                            //        j = -1;
                            //    if (i > 0)
                            //    {
                            //        i = 0;
                            //        //blnDecrement = true;
                            //    }
                            //    else
                            //        blnDecrement = true;
                            //}
                            //else if (((fMinY[j] - intTolerance) <= fMaxY[i])// first blob is above second blob, first blob is before second blob
                            //     && ((fMinY[j]) >= fMinY[i])
                            //     && ((fMaxX[i] + intTolerance) >= fMinX[j])
                            //    && ((fMaxX[i]) <= fMaxX[j]))
                            //{
                            //    //if (fObjectAreaList2[i] >= fObjectAreaList2[j])
                            //    //{
                            //    //    if (fObjectAngleList[i] > 0 && fObjectAngleList[j] > 0)
                            //    //    {
                            //    //        if (Math.Abs(fObjectAngleList[i] - fObjectAngleList[j]) > intAngleTolerance)
                            //    //            continue;
                            //    //    }
                            //    //    else if (fObjectAngleList[i] < 0 && fObjectAngleList[j] < 0)
                            //    //    {
                            //    //        if (Math.Abs(fObjectAngleList[i] - fObjectAngleList[j]) > intAngleTolerance)
                            //    //            continue;
                            //    //    }
                            //    //    else
                            //    //        continue;

                            //    //    fObjectAngleList[i] = fObjectAngleList[i];
                            //    //    fObjectAreaList2[i] = fObjectAreaList2[i];


                            //    //}
                            //    //else
                            //    //{

                            //    //    if (fObjectAngleList[i] > 0 && fObjectAngleList[j] > 0)
                            //    //    {
                            //    //        if (Math.Abs(fObjectAngleList[i] - fObjectAngleList[j]) > intAngleTolerance)
                            //    //            continue;
                            //    //    }
                            //    //    else if (fObjectAngleList[i] < 0 && fObjectAngleList[j] < 0)
                            //    //    {
                            //    //        if (Math.Abs(fObjectAngleList[i] - fObjectAngleList[j]) > intAngleTolerance)
                            //    //            continue;
                            //    //    }
                            //    //    else
                            //    //        continue;

                            //    //    fObjectAngleList[i] = fObjectAngleList[j];
                            //    //    fObjectAreaList2[i] = fObjectAreaList2[j];
                            //    //}
                            //    //if (Math.Abs(Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i])) - Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i])))
                            //    //    >= Math.Abs(Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i])) - Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i]))))
                            //    //{
                            //    //    fObjectHeightList[i] = Math.Abs(Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i])) - Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i])));
                            //    //    fObjectWidthList[i] = Math.Abs(Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i])) - Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i])));
                            //    //    //fObjectCenterXList[i] = (fMaxX[i] + fMinX[j]) / 2;
                            //    //    //fObjectCenterYList[i] = (fMaxY[i] + fMinY[j]) / 2;
                            //    //    fObjectAngleList[i] = 0;
                            //    //}
                            //    //else
                            //    //{
                            //    //    fObjectWidthList[i] = Math.Abs(Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i])) - Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i])));
                            //    //    fObjectHeightList[i] = Math.Abs(Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i])) - Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i])));
                            //    //    //fObjectCenterXList[i] = (fMaxY[i] + fMinY[j]) / 2;
                            //    //    //fObjectCenterYList[i] = (fMaxX[i] + fMinX[j]) / 2;
                            //    //    fObjectAngleList[i] = 90;
                            //    //}
                            //    //fObjectCenterXList[i] = (Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i])) + Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i]))) / 2;
                            //    //fObjectCenterYList[i] = (Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i])) + Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i]))) / 2;
                            //    PointF[] arrPoints = new PointF[8];

                            //    arrPoints[0] = arrRotatedPoints[i][0];
                            //    arrPoints[1] = arrRotatedPoints[i][1];
                            //    arrPoints[2] = arrRotatedPoints[i][2];
                            //    arrPoints[3] = arrRotatedPoints[i][3];
                            //    arrPoints[4] = arrRotatedPoints[j][0];
                            //    arrPoints[5] = arrRotatedPoints[j][1];
                            //    arrPoints[6] = arrRotatedPoints[j][2];
                            //    arrPoints[7] = arrRotatedPoints[j][3];

                            //    float fMinAngle = 0;
                            //    List<PointF> arrMinRect = new List<PointF>();
                            //    arrMinRect = MinimumBoundingBox.CalculateMinimumBoundingBox(arrPoints, ref fMinAngle);

                            //    arrRotatedPoints[i][0] = arrMinRect[3];
                            //    arrRotatedPoints[i][1] = arrMinRect[2];
                            //    arrRotatedPoints[i][2] = arrMinRect[0];
                            //    arrRotatedPoints[i][3] = arrMinRect[1];
                            //    arrRotatedPoints.RemoveAt(j);

                            //    if (fMinAngle < 0)
                            //        fObjectAngleList[i] = -(90 + fMinAngle);
                            //    else
                            //        fObjectAngleList[i] = 90 - fMinAngle;

                            //    Line onjLine1 = new Line();
                            //    Line onjLine2 = new Line();
                            //    onjLine1.CalculateStraightLine(arrMinRect[0], arrMinRect[2]);
                            //    onjLine2.CalculateStraightLine(arrMinRect[1], arrMinRect[3]);
                            //    PointF pCenter = Line.GetCrossPoint(onjLine1, onjLine2);
                            //    float p1X = 0, p1Y = 0;
                            //    float p2X = 0, p2Y = 0;
                            //    float p3X = 0, p3Y = 0;
                            //    float p4X = 0, p4Y = 0;
                            //    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[0].X, arrMinRect[0].Y, -fObjectAngleList[i], ref p1X, ref p1Y);
                            //    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[1].X, arrMinRect[1].Y, -fObjectAngleList[i], ref p2X, ref p2Y);
                            //    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[2].X, arrMinRect[2].Y, -fObjectAngleList[i], ref p3X, ref p3Y);
                            //    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[3].X, arrMinRect[3].Y, -fObjectAngleList[i], ref p4X, ref p4Y);

                            //    float fDiffX = Math.Max(Math.Abs(p1X - p4X), Math.Abs(p2X - p3X));
                            //    float fDiffY = Math.Max(Math.Abs(p3Y - p4Y), Math.Abs(p2Y - p1Y));
                            //    //float fWidth = (int)Math.Round((fDiffX * Math.Cos((fMinAngle + 180) * Math.PI / 180)) + (fDiffY * Math.Sin((fMinAngle + 180) * Math.PI / 180)));
                            //    //float fHeight = (int)Math.Round((fDiffX * Math.Sin((fMinAngle + 180) * Math.PI / 180)) + (fDiffY * Math.Cos((fMinAngle + 180) * Math.PI / 180)));
                            //    fObjectWidthList[i] = fDiffX;
                            //    fObjectHeightList[i] = fDiffY;

                            //    fObjectCenterXList[i] = pCenter.X;
                            //    fObjectCenterYList[i] = pCenter.Y;

                            //    fObjectAreaList2.RemoveAt(j);
                            //    fObjectAreaList[i] = fObjectAreaList[i] + fObjectAreaList[j];
                            //    fMinX[i] = Math.Min(Math.Min(arrMinRect[0].X, arrMinRect[1].X), Math.Min(arrMinRect[2].X, arrMinRect[3].X));
                            //    fMinY[i] = Math.Min(Math.Min(arrMinRect[0].Y, arrMinRect[1].Y), Math.Min(arrMinRect[2].Y, arrMinRect[3].Y));
                            //    fMaxX[i] = Math.Max(Math.Max(arrMinRect[0].X, arrMinRect[1].X), Math.Max(arrMinRect[2].X, arrMinRect[3].X));
                            //    fMaxY[i] = Math.Max(Math.Max(arrMinRect[0].Y, arrMinRect[1].Y), Math.Max(arrMinRect[2].Y, arrMinRect[3].Y));
                            //    //fMinLimitX[i] = Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i]));
                            //    //fMinLimitY[i] = Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i]));
                            //    //fMaxLimitX[i] = Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i]));
                            //    //fMaxLimitY[i] = Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i]));
                            //    //fMinX[i] = Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i]));
                            //    //fMinY[i] = Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i]));
                            //    //fMaxX[i] = Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i]));
                            //    //fMaxY[i] = Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i]));
                            //    //fMinLimitX[i] = Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i]));
                            //    //fMinLimitY[i] = Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i]));
                            //    //fMaxLimitX[i] = Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i]));
                            //    //fMaxLimitY[i] = Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i]));
                            //    fObjectHeightList.RemoveAt(j);
                            //    fObjectWidthList.RemoveAt(j);
                            //    fObjectCenterXList.RemoveAt(j);
                            //    fObjectCenterYList.RemoveAt(j);
                            //    fObjectAngleList.RemoveAt(j);
                            //    fObjectAreaList.RemoveAt(j);
                            //    //fMaxLimitX.RemoveAt(j);
                            //    //fMaxLimitY.RemoveAt(j);
                            //    //fMinLimitX.RemoveAt(j);
                            //    //fMinLimitY.RemoveAt(j);
                            //    fMaxX.RemoveAt(j);
                            //    fMaxY.RemoveAt(j);
                            //    fMinX.RemoveAt(j);
                            //    fMinY.RemoveAt(j);
                            //    if (j > 0)
                            //        j = -1;
                            //    if (i > 0)
                            //    {
                            //        i = 0;
                            //        //blnDecrement = true;
                            //    }
                            //    else
                            //        blnDecrement = true;
                            //}
                        }
                    }
                }
            }
            for (int i = 0; i < fObjectHeightList.Count; i++)
            {
                if (fObjectHeightList[i] < fObjectWidthList[i])
                {
                    fObjectWidth = fObjectHeightList[i];
                    fObjectHeight = fObjectWidthList[i];

                    fObjectAngle = fObjectAngleList[i];

                    if (fObjectAngle >= 10)//&& fAngle <= 80)
                        fObjectAngle = fObjectAngleList[i] - 90;
                    else
                        fObjectAngle = 90 + fObjectAngleList[i];

                    fObjectWidthList[i] = fObjectWidth;
                    fObjectHeightList[i] = fObjectHeight;
                    fObjectAngleList[i] = fObjectAngle;
                }
                else
                {
                    fObjectHeight = fObjectHeightList[i];
                    fObjectWidth = fObjectWidthList[i];

                    fObjectAngle = fObjectAngleList[i];

                    fObjectWidthList[i] = fObjectWidth;
                    fObjectHeightList[i] = fObjectHeight;
                    fObjectAngleList[i] = fObjectAngle;
                }

                bool blnFail = false;
                int intFailMask = 0;
                string strDefectName = "Dark";

                if ((m_intPkgFailMask & 0x200) > 0)
                {
                    if (m_arrWantDefectLength[(int)eWantDefect.Dark])
                    {
                        if (m_intDarkDefectDimensionFailCondition == 0)
                        {
                            if (fObjectWidthList[i] >= GetDefect("Dark", 0))
                            {
                                m_strErrorMessage += "* Package Dark Field Width Fail. Set = " + (GetDefect("Dark", 0) / m_fMMToPixelXValue).ToString("f5") + " mm,   Result = " + (fObjectWidthList[i] / m_fMMToPixelXValue).ToString("f5") + " mm";
                                blnFail = true;
                                intFailMask |= 0x01;
                                strDefectName = "Dark";
                            }

                            if (fObjectHeightList[i] >= GetDefect("Dark", 1))
                            {
                                m_strErrorMessage += "* Package Dark Field Length Fail. Set = " + (GetDefect("Dark", 1) / m_fMMToPixelYValue).ToString("f5") + " mm,   Result = " + (fObjectHeightList[i] / m_fMMToPixelYValue).ToString("f5") + " mm";
                                blnFail = true;
                                intFailMask |= 0x02;
                                strDefectName = "Dark";
                            }
                        }
                        else
                        {
                            if ((fObjectWidthList[i] >= GetDefect("Dark", 0)) && (fObjectHeightList[i] >= GetDefect("Dark", 1)))
                            {
                                m_strErrorMessage += "* Package Dark Field Width Fail. Set = " + (GetDefect("Dark", 0) / m_fMMToPixelXValue).ToString("f5") + " mm,   Result = " + (fObjectWidthList[i] / m_fMMToPixelXValue).ToString("f5") + " mm";
                                intFailMask |= 0x01;
                                m_strErrorMessage += "* Package Dark Field Length Fail. Set = " + (GetDefect("Dark", 1) / m_fMMToPixelYValue).ToString("f5") + " mm,   Result = " + (fObjectHeightList[i] / m_fMMToPixelYValue).ToString("f5") + " mm";
                                blnFail = true;
                                intFailMask |= 0x02;
                                strDefectName = "Dark";
                            }
                        }
                    }

                    if (m_arrWantDefectArea[(int)eWantDefect.Dark])
                    {
                        if (fObjectAreaList[i] >= GetAreaDefect("Dark"))
                        {
                            m_strErrorMessage += "* Package Dark Field Area Fail. Set = " + (GetAreaDefect("Dark") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (fObjectAreaList[i] / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                            blnFail = true;
                            intFailMask |= 0x04;
                            strDefectName = "Dark";
                        }
                    }
                }
                if (blnFail)
                {
                    Defect objDefect = new Defect();
                    objDefect.ref_fDimX = fObjectWidthList[i];
                    objDefect.ref_fDimY = fObjectHeightList[i];
                    objDefect.ref_intLengthMode = intLengthMode;
                    objDefect.ref_fArea = fObjectAreaList[i];
                    objDefect.ref_fCenterX = objROI.ref_ROITotalX + fObjectCenterXList[i];
                    objDefect.ref_fCenterY = objROI.ref_ROITotalY + fObjectCenterYList[i];
                    objDefect.ref_fAngle = fObjectAngleList[i];
                    objDefect.ref_intBlobNo = i;
                    objDefect.ref_intFailMask = intFailMask;
                    objDefect.ref_strName = strDefectName;
                    objDefect.ref_intFailedImage = intSelectedImageIndex + 1;
                    m_arrDefectList.Add(objDefect);

                    if (!blnOverAllFail)
                        blnOverAllFail = true;
                }
                else
                {
                    Defect objDefect = new Defect();
                    objDefect.ref_fDimX = fObjectWidthList[i];
                    objDefect.ref_fDimY = fObjectHeightList[i];
                    objDefect.ref_intLengthMode = intLengthMode;
                    objDefect.ref_fArea = fObjectAreaList[i];
                    objDefect.ref_fCenterX = objROI.ref_ROITotalX + fObjectCenterXList[i];
                    objDefect.ref_fCenterY = objROI.ref_ROITotalY + fObjectCenterYList[i];
                    objDefect.ref_fAngle = fObjectAngleList[i];
                    objDefect.ref_intBlobNo = i;
                    objDefect.ref_intFailMask = 0;
                    objDefect.ref_strName = strDefectName;
                    objDefect.ref_intFailedImage = intSelectedImageIndex + 1;
                    m_arrDefectList.Add(objDefect);
                }
            }

            if (m_arrWantDefectArea[(int)eWantDefect.Dark])
            {
                if (intObjectTotalArea >= GetTotalAreaDefect("Dark"))
                {
                    m_strErrorMessage += "* Package Dark Field Total Area Fail. Set = " + (GetTotalAreaDefect("Dark") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectTotalArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                    m_blnCrackChipViewFailTotalArea = true;

                    Defect objDefect = new Defect();
                    objDefect.ref_fDimX = -1;
                    objDefect.ref_fDimY = -1;
                    objDefect.ref_intLengthMode = intLengthMode;
                    objDefect.ref_fArea = intObjectTotalArea;
                    objDefect.ref_fCenterX = objROI.ref_ROITotalX + m_objEBlobs.ref_arrRectLimitCenterX[0];
                    objDefect.ref_fCenterY = objROI.ref_ROITotalY + m_objEBlobs.ref_arrRectLimitCenterY[0];
                    objDefect.ref_fAngle = fObjectAngle; //m_objEBlobs.ref_arrRectAngle[0];
                    objDefect.ref_intFailMask |= 0x04;
                    objDefect.ref_strName = "Total Dark";
                    objDefect.ref_intFailedImage = intSelectedImageIndex + 1;
                    m_arrDefectList.Add(objDefect);

                    if (!blnOverAllFail)
                        blnOverAllFail = true;
                }
            }

            if (blnOverAllFail)
            {
                m_intPkgFailResultMask |= 0x200;
                return false;
            }
            else
                return true;
        }
        public bool InspectionImage12DarkField2Defect(ROI objROI, int intDarkDefectIndex)
        {
            //2022-02-15 ZJYEOH : Direct use intDarkDefectIndex to decide which setting to use
            int intSelectedImageIndex = m_arrGrabImageIndex[4];

            if (intDarkDefectIndex == 3)
                intSelectedImageIndex = m_arrGrabImageIndex[6];
            else if (intDarkDefectIndex == 4)
                intSelectedImageIndex = m_arrGrabImageIndex[7];

            int intSelectedObjectNum = 0;

            if (intDarkDefectIndex == 2)
            {
                intSelectedObjectNum = m_objEBlobs.BuildObjects_Filter_GetElement_DoubleThreshold(
                    objROI, true, false, false, m_intConnexity == 8, m_intDarkField2LowThreshold, m_intDarkField2HighThreshold,
                    m_intDarkField2MinArea, objROI.ref_ROIWidth * objROI.ref_ROIHeight, false, 0xED);
            }
            else if(intDarkDefectIndex == 3)
            {
                intSelectedObjectNum = m_objEBlobs.BuildObjects_Filter_GetElement_DoubleThreshold(
                    objROI, true, false, false, m_intConnexity == 8, m_intDarkField3LowThreshold, m_intDarkField3HighThreshold,
                    m_intDarkField3MinArea, objROI.ref_ROIWidth * objROI.ref_ROIHeight, false, 0xED);
            }
            else if(intDarkDefectIndex == 4)
            {
                intSelectedObjectNum = m_objEBlobs.BuildObjects_Filter_GetElement_DoubleThreshold(
                    objROI, true, false, false, m_intConnexity == 8, m_intDarkField4LowThreshold, m_intDarkField4HighThreshold,
                    m_intDarkField4MinArea, objROI.ref_ROIWidth * objROI.ref_ROIHeight, false, 0xED);
            }

            if (intSelectedObjectNum == 0)
                return true;

            int intObjectTotalArea = 0;
            int intObjectArea = 0;
            int intLengthMode = 0;
            float fObjectHeight = 0, fObjectWidth = 0, fObjectCenterX = 0, fObjectCenterY = 0, fObjectAngle = 0;
            bool blnOverAllFail = false;
            for (int i = 0; i < intSelectedObjectNum; i++)
            {

                intObjectArea = m_objEBlobs.ref_arrArea[i];
                //if (m_objEBlobs.ref_arrRectWidth[i] < m_objEBlobs.ref_arrRectHeight[i])
                //{
                //    fObjectWidth = m_objEBlobs.ref_arrRectWidth[i];
                //    fObjectHeight = m_objEBlobs.ref_arrRectHeight[i];
                //    intLengthMode = 0;

                //    fObjectAngle = m_objEBlobs.ref_arrRectAngle[i];
                //    if (fObjectAngle < 0)
                //        fObjectAngle = -Math.Abs(fObjectAngle);
                //    else
                //        fObjectAngle = -fObjectAngle;

                //}
                //else
                //{
                //    fObjectHeight = m_objEBlobs.ref_arrRectWidth[i];
                //    fObjectWidth = m_objEBlobs.ref_arrRectHeight[i];
                //    intLengthMode = 0;  //1;

                //    fObjectAngle = m_objEBlobs.ref_arrRectAngle[i];
                //    if (fObjectAngle < 0)
                //        fObjectAngle = Math.Abs(fObjectAngle);
                //    else
                //        fObjectAngle = 90 - (fObjectAngle);
                //}

                if (m_objEBlobs.ref_arrRectHeight[i] < m_objEBlobs.ref_arrRectWidth[i])
                {
                    fObjectWidth = m_objEBlobs.ref_arrRectHeight[i];
                    fObjectHeight = m_objEBlobs.ref_arrRectWidth[i];
                    intLengthMode = 0;
                    fObjectAngle = m_objEBlobs.ref_arrRectAngle[i];

                    if (fObjectAngle >= 10)//&& fAngle <= 80)
                        fObjectAngle = m_objEBlobs.ref_arrRectAngle[i] - 90;
                    else
                        fObjectAngle = 90 + m_objEBlobs.ref_arrRectAngle[i];

                }
                else
                {
                    fObjectHeight = m_objEBlobs.ref_arrRectHeight[i];
                    fObjectWidth = m_objEBlobs.ref_arrRectWidth[i];
                    intLengthMode = 0;

                    fObjectAngle = m_objEBlobs.ref_arrRectAngle[i];

                }
                fObjectCenterX = m_objEBlobs.ref_arrRectLimitCenterX[i];
                fObjectCenterY = m_objEBlobs.ref_arrRectLimitCenterY[i];
                intObjectTotalArea += intObjectArea;

                bool blnFail = false;
                int intFailMask = 0;
                string strDefectName = "";

                if (intDarkDefectIndex == 2)
                    strDefectName = "Dark 2";
                else if (intDarkDefectIndex == 3)
                    strDefectName = "Dark 3";
                else if (intDarkDefectIndex == 4)
                    strDefectName = "Dark 4";

                if (m_arrWantDefectLength[(int)eWantDefect.Dark2] && intDarkDefectIndex == 2)
                {
                    if (m_intDark2DefectDimensionFailCondition == 0)
                    {
                        if (fObjectWidth >= GetDefect("Dark 2", 0))
                        {
                            m_strErrorMessage += "* Package Dark Field 2 Width Fail. Set = " + (GetDefect("Dark 2", 0) / m_fMMToPixelXValue).ToString("f5") + " mm,   Result = " + (fObjectWidth / m_fMMToPixelXValue).ToString("f5") + " mm";
                            blnFail = true;
                            intFailMask |= 0x01;
                            strDefectName = "Dark 2";
                        }

                        if (fObjectHeight >= GetDefect("Dark 2", 1))
                        {
                            m_strErrorMessage += "* Package Dark Field 2 Length Fail. Set = " + (GetDefect("Dark 2", 1) / m_fMMToPixelYValue).ToString("f5") + " mm,   Result = " + (fObjectHeight / m_fMMToPixelYValue).ToString("f5") + " mm";
                            blnFail = true;
                            intFailMask |= 0x02;
                            strDefectName = "Dark 2";
                        }
                    }
                    else
                    {
                        if ((fObjectWidth >= GetDefect("Dark 2", 0)) && (fObjectHeight >= GetDefect("Dark 2", 1)))
                        {
                            m_strErrorMessage += "* Package Dark Field 2 Width Fail. Set = " + (GetDefect("Dark 2", 0) / m_fMMToPixelXValue).ToString("f5") + " mm,   Result = " + (fObjectWidth / m_fMMToPixelXValue).ToString("f5") + " mm";
                            intFailMask |= 0x01;
                            m_strErrorMessage += "* Package Dark Field 2 Length Fail. Set = " + (GetDefect("Dark 2", 1) / m_fMMToPixelYValue).ToString("f5") + " mm,   Result = " + (fObjectHeight / m_fMMToPixelYValue).ToString("f5") + " mm";
                            blnFail = true;
                            intFailMask |= 0x02;
                            strDefectName = "Dark 2";
                        }
                    }
                }
               else if (m_arrWantDefectLength[(int)eWantDefect.Dark3] && intDarkDefectIndex == 3)
                {
                    if (m_intDark3DefectDimensionFailCondition == 0)
                    {
                        if (fObjectWidth >= GetDefect("Dark 3", 0))
                        {
                            m_strErrorMessage += "* Package Dark Field 3 Width Fail. Set = " + (GetDefect("Dark 3", 0) / m_fMMToPixelXValue).ToString("f5") + " mm,   Result = " + (fObjectWidth / m_fMMToPixelXValue).ToString("f5") + " mm";
                            blnFail = true;
                            intFailMask |= 0x01;
                            strDefectName = "Dark 3";
                        }

                        if (fObjectHeight >= GetDefect("Dark 3", 1))
                        {
                            m_strErrorMessage += "* Package Dark Field 3 Length Fail. Set = " + (GetDefect("Dark 3", 1) / m_fMMToPixelYValue).ToString("f5") + " mm,   Result = " + (fObjectHeight / m_fMMToPixelYValue).ToString("f5") + " mm";
                            blnFail = true;
                            intFailMask |= 0x02;
                            strDefectName = "Dark 3";
                        }
                    }
                    else
                    {
                        if ((fObjectWidth >= GetDefect("Dark 3", 0)) && (fObjectHeight >= GetDefect("Dark 3", 1)))
                        {
                            m_strErrorMessage += "* Package Dark Field 3 Width Fail. Set = " + (GetDefect("Dark 3", 0) / m_fMMToPixelXValue).ToString("f5") + " mm,   Result = " + (fObjectWidth / m_fMMToPixelXValue).ToString("f5") + " mm";
                            intFailMask |= 0x01;
                            m_strErrorMessage += "* Package Dark Field 3 Length Fail. Set = " + (GetDefect("Dark 3", 1) / m_fMMToPixelYValue).ToString("f5") + " mm,   Result = " + (fObjectHeight / m_fMMToPixelYValue).ToString("f5") + " mm";
                            blnFail = true;
                            intFailMask |= 0x02;
                            strDefectName = "Dark 3";
                        }
                    }
                }
                else if (m_arrWantDefectLength[(int)eWantDefect.Dark4] && intDarkDefectIndex == 4)
                {
                    if (m_intDark4DefectDimensionFailCondition == 0)
                    {
                        if (fObjectWidth >= GetDefect("Dark 4", 0))
                        {
                            m_strErrorMessage += "* Package Dark Field 4 Width Fail. Set = " + (GetDefect("Dark 4", 0) / m_fMMToPixelXValue).ToString("f5") + " mm,   Result = " + (fObjectWidth / m_fMMToPixelXValue).ToString("f5") + " mm";
                            blnFail = true;
                            intFailMask |= 0x01;
                            strDefectName = "Dark 4";
                        }

                        if (fObjectHeight >= GetDefect("Dark 4", 1))
                        {
                            m_strErrorMessage += "* Package Dark Field 4 Length Fail. Set = " + (GetDefect("Dark 4", 1) / m_fMMToPixelYValue).ToString("f5") + " mm,   Result = " + (fObjectHeight / m_fMMToPixelYValue).ToString("f5") + " mm";
                            blnFail = true;
                            intFailMask |= 0x02;
                            strDefectName = "Dark 4";
                        }
                    }
                    else
                    {
                        if ((fObjectWidth >= GetDefect("Dark 4", 0)) && (fObjectHeight >= GetDefect("Dark 4", 1)))
                        {
                            m_strErrorMessage += "* Package Dark Field 4 Width Fail. Set = " + (GetDefect("Dark 4", 0) / m_fMMToPixelXValue).ToString("f5") + " mm,   Result = " + (fObjectWidth / m_fMMToPixelXValue).ToString("f5") + " mm";
                            intFailMask |= 0x01;
                            m_strErrorMessage += "* Package Dark Field 4 Length Fail. Set = " + (GetDefect("Dark 4", 1) / m_fMMToPixelYValue).ToString("f5") + " mm,   Result = " + (fObjectHeight / m_fMMToPixelYValue).ToString("f5") + " mm";
                            blnFail = true;
                            intFailMask |= 0x02;
                            strDefectName = "Dark 4";
                        }
                    }
                }

                if (m_arrWantDefectArea[(int)eWantDefect.Dark2] && intDarkDefectIndex == 2)
                {
                    if (intObjectArea >= GetAreaDefect("Dark 2"))
                    {
                        m_strErrorMessage += "* Package Dark Field 2 Area Fail. Set = " + (GetAreaDefect("Dark 2") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        blnFail = true;
                        intFailMask |= 0x04;
                        strDefectName = "Dark 2";
                    }
                }
               else if (m_arrWantDefectArea[(int)eWantDefect.Dark3] && intDarkDefectIndex == 3)
                {
                    if (intObjectArea >= GetAreaDefect("Dark 3"))
                    {
                        m_strErrorMessage += "* Package Dark Field 3 Area Fail. Set = " + (GetAreaDefect("Dark 3") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        blnFail = true;
                        intFailMask |= 0x04;
                        strDefectName = "Dark 3";
                    }
                }
                else if (m_arrWantDefectArea[(int)eWantDefect.Dark4] && intDarkDefectIndex == 4)
                {
                    if (intObjectArea >= GetAreaDefect("Dark 4"))
                    {
                        m_strErrorMessage += "* Package Dark Field 4 Area Fail. Set = " + (GetAreaDefect("Dark 4") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        blnFail = true;
                        intFailMask |= 0x04;
                        strDefectName = "Dark 4";
                    }
                }

                if (blnFail)
                {
                    Defect objDefect = new Defect();
                    objDefect.ref_fDimX = fObjectWidth;
                    objDefect.ref_fDimY = fObjectHeight;
                    objDefect.ref_intLengthMode = intLengthMode;
                    objDefect.ref_fArea = intObjectArea;
                    objDefect.ref_fCenterX = objROI.ref_ROITotalX + fObjectCenterX;
                    objDefect.ref_fCenterY = objROI.ref_ROITotalY + fObjectCenterY;
                    objDefect.ref_fAngle = fObjectAngle;
                    objDefect.ref_intBlobNo = i;
                    objDefect.ref_intFailMask = intFailMask;
                    objDefect.ref_strName = strDefectName;
                    objDefect.ref_intFailedImage = intSelectedImageIndex + 1;
                    m_arrDefectList.Add(objDefect);

                    if (!blnOverAllFail)
                        blnOverAllFail = true;
                }
                else
                {
                    Defect objDefect = new Defect();
                    objDefect.ref_fDimX = fObjectWidth;
                    objDefect.ref_fDimY = fObjectHeight;
                    objDefect.ref_intLengthMode = intLengthMode;
                    objDefect.ref_fArea = intObjectArea;
                    objDefect.ref_fCenterX = objROI.ref_ROITotalX + fObjectCenterX;
                    objDefect.ref_fCenterY = objROI.ref_ROITotalY + fObjectCenterY;
                    objDefect.ref_fAngle = fObjectAngle;
                    objDefect.ref_intBlobNo = i;
                    objDefect.ref_intFailMask = 0;
                    objDefect.ref_strName = strDefectName;
                    objDefect.ref_intFailedImage = intSelectedImageIndex + 1;
                    m_arrDefectList.Add(objDefect);
                }
            }

            if (m_arrWantDefectArea[(int)eWantDefect.Dark2] && intDarkDefectIndex == 2)
            {
                if (intObjectTotalArea >= GetTotalAreaDefect("Dark 2"))
                {
                    m_strErrorMessage += "* Package Dark Field 2 Total Area Fail. Set = " + (GetTotalAreaDefect("Dark 2") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectTotalArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                    m_blnCrackChipViewFailTotalArea = true;

                    Defect objDefect = new Defect();
                    objDefect.ref_fDimX = -1;
                    objDefect.ref_fDimY = -1;
                    objDefect.ref_intLengthMode = intLengthMode;
                    objDefect.ref_fArea = intObjectTotalArea;
                    objDefect.ref_fCenterX = objROI.ref_ROITotalX + m_objEBlobs.ref_arrRectLimitCenterX[0];
                    objDefect.ref_fCenterY = objROI.ref_ROITotalY + m_objEBlobs.ref_arrRectLimitCenterY[0];
                    objDefect.ref_fAngle = fObjectAngle; //m_objEBlobs.ref_arrRectAngle[0];
                    objDefect.ref_intFailMask |= 0x04;
                    objDefect.ref_strName = "Total Dark 2";
                    objDefect.ref_intFailedImage = intSelectedImageIndex + 1;
                    m_arrDefectList.Add(objDefect);

                    if (!blnOverAllFail)
                        blnOverAllFail = true;
                }
            }
            else if (m_arrWantDefectArea[(int)eWantDefect.Dark3] && intDarkDefectIndex == 3)
            {
                if (intObjectTotalArea >= GetTotalAreaDefect("Dark 3"))
                {
                    m_strErrorMessage += "* Package Dark Field 3 Total Area Fail. Set = " + (GetTotalAreaDefect("Dark 3") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectTotalArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                    m_blnCrackChipViewFailTotalArea = true;

                    Defect objDefect = new Defect();
                    objDefect.ref_fDimX = -1;
                    objDefect.ref_fDimY = -1;
                    objDefect.ref_intLengthMode = intLengthMode;
                    objDefect.ref_fArea = intObjectTotalArea;
                    objDefect.ref_fCenterX = objROI.ref_ROITotalX + m_objEBlobs.ref_arrRectLimitCenterX[0];
                    objDefect.ref_fCenterY = objROI.ref_ROITotalY + m_objEBlobs.ref_arrRectLimitCenterY[0];
                    objDefect.ref_fAngle = fObjectAngle; //m_objEBlobs.ref_arrRectAngle[0];
                    objDefect.ref_intFailMask |= 0x04;
                    objDefect.ref_strName = "Total Dark 3";
                    objDefect.ref_intFailedImage = intSelectedImageIndex + 1;
                    m_arrDefectList.Add(objDefect);

                    if (!blnOverAllFail)
                        blnOverAllFail = true;
                }
            }
            else if (m_arrWantDefectArea[(int)eWantDefect.Dark4] && intDarkDefectIndex == 4)
            {
                if (intObjectTotalArea >= GetTotalAreaDefect("Dark 4"))
                {
                    m_strErrorMessage += "* Package Dark Field 4 Total Area Fail. Set = " + (GetTotalAreaDefect("Dark 4") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectTotalArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                    m_blnCrackChipViewFailTotalArea = true;

                    Defect objDefect = new Defect();
                    objDefect.ref_fDimX = -1;
                    objDefect.ref_fDimY = -1;
                    objDefect.ref_intLengthMode = intLengthMode;
                    objDefect.ref_fArea = intObjectTotalArea;
                    objDefect.ref_fCenterX = objROI.ref_ROITotalX + m_objEBlobs.ref_arrRectLimitCenterX[0];
                    objDefect.ref_fCenterY = objROI.ref_ROITotalY + m_objEBlobs.ref_arrRectLimitCenterY[0];
                    objDefect.ref_fAngle = fObjectAngle; //m_objEBlobs.ref_arrRectAngle[0];
                    objDefect.ref_intFailMask |= 0x04;
                    objDefect.ref_strName = "Total Dark 4";
                    objDefect.ref_intFailedImage = intSelectedImageIndex + 1;
                    m_arrDefectList.Add(objDefect);

                    if (!blnOverAllFail)
                        blnOverAllFail = true;
                }
            }

            if (blnOverAllFail)
            {
                m_intPkgFailResultMask |= 0x400;
                return false;
            }
            else
                return true;
        }
        public bool InspectionImage12DarkField2Defect_WithLinkFunction(ROI objROI, int intDarkDefectIndex)
        {
            //2022-02-15 ZJYEOH : Direct use intDarkDefectIndex to decide which setting to use
            int intSelectedImageIndex = m_arrGrabImageIndex[4];

            if (intDarkDefectIndex == 3)
                intSelectedImageIndex = m_arrGrabImageIndex[6];
            else if (intDarkDefectIndex == 4)
                intSelectedImageIndex = m_arrGrabImageIndex[7];

            int intSelectedObjectNum = 0;

            if (intDarkDefectIndex == 2)
            {
                intSelectedObjectNum = m_objEBlobs.BuildObjects_Filter_GetElement_DoubleThreshold(
                    objROI, true, false, false, m_intConnexity == 8, m_intDarkField2LowThreshold, m_intDarkField2HighThreshold,
                    m_intDarkField2MinArea, objROI.ref_ROIWidth * objROI.ref_ROIHeight, false, 0xED);
            }
            else if(intDarkDefectIndex == 3)
            {
                intSelectedObjectNum = m_objEBlobs.BuildObjects_Filter_GetElement_DoubleThreshold(
                    objROI, true, false, false, m_intConnexity == 8, m_intDarkField3LowThreshold, m_intDarkField3HighThreshold,
                    m_intDarkField3MinArea, objROI.ref_ROIWidth * objROI.ref_ROIHeight, false, 0xED);
            }
            else if(intDarkDefectIndex == 4)
            {
                intSelectedObjectNum = m_objEBlobs.BuildObjects_Filter_GetElement_DoubleThreshold(
                    objROI, true, false, false, m_intConnexity == 8, m_intDarkField4LowThreshold, m_intDarkField4HighThreshold,
                    m_intDarkField4MinArea, objROI.ref_ROIWidth * objROI.ref_ROIHeight, false, 0xED);
            }

            if (intSelectedObjectNum == 0)
                return true;
            List<List<System.Windows.Point>> arr2DPoints = new List<List<System.Windows.Point>>();
            List<List<PointF>> arrRotatedPoints = new List<List<PointF>>();
            List<float> fObjectHeightList = new List<float>(), fObjectWidthList = new List<float>(), fObjectCenterXList = new List<float>(), fObjectCenterYList = new List<float>(), fObjectAngleList = new List<float>();
            List<float> fObjectLimitHeightList = new List<float>(), fObjectLimitWidthList = new List<float>(), fObjectLimitCenterXList = new List<float>(), fObjectLimitCenterYList = new List<float>();
            List<int> fObjectAreaList = new List<int>(), fObjectAreaList2 = new List<int>();
            int intObjectTotalArea = 0;
            int intObjectArea = 0;
            int intLengthMode = 0;
            float fObjectHeight = 0, fObjectWidth = 0, fObjectCenterX = 0, fObjectCenterY = 0, fObjectAngle = 0;
            float fObjectLimitHeight = 0, fObjectLimitWidth = 0, fObjectLimitCenterX = 0, fObjectLimitCenterY = 0;
            bool blnOverAllFail = false;
            for (int i = 0; i < intSelectedObjectNum; i++)
            {
                arrRotatedPoints.Add(new List<PointF>());
                arr2DPoints.Add(new List<System.Windows.Point>());
                intObjectArea = m_objEBlobs.ref_arrArea[i];
             
                if (m_objEBlobs.ref_arrRectHeight[i] < m_objEBlobs.ref_arrRectWidth[i])
                {
                    fObjectWidth = m_objEBlobs.ref_arrRectHeight[i];
                    fObjectHeight = m_objEBlobs.ref_arrRectWidth[i];
                    intLengthMode = 0;
                    fObjectAngle = m_objEBlobs.ref_arrRectAngle[i];

                    if (fObjectAngle >= 10)//&& fAngle <= 80)
                        fObjectAngle = m_objEBlobs.ref_arrRectAngle[i] - 90;
                    else
                        fObjectAngle = 90 + m_objEBlobs.ref_arrRectAngle[i];

                }
                else
                {
                    fObjectHeight = m_objEBlobs.ref_arrRectHeight[i];
                    fObjectWidth = m_objEBlobs.ref_arrRectWidth[i];
                    intLengthMode = 0;

                    fObjectAngle = m_objEBlobs.ref_arrRectAngle[i];

                }
                fObjectCenterX = m_objEBlobs.ref_arrRectLimitCenterX[i];
                fObjectCenterY = m_objEBlobs.ref_arrRectLimitCenterY[i];

                fObjectLimitCenterX = m_objEBlobs.ref_arrLimitCenterX[i];
                fObjectLimitCenterY = m_objEBlobs.ref_arrLimitCenterY[i];
                fObjectLimitWidth = m_objEBlobs.ref_arrWidth[i];
                fObjectLimitHeight = m_objEBlobs.ref_arrHeight[i];

                intObjectTotalArea += intObjectArea;
                
                float newX1 = 0, newY1 = 0;  // new point 1
                float newX2 = 0, newY2 = 0; // new point 2
                float newX3 = 0, newY3 = 0; // new point 3
                float newX4 = 0, newY4 = 0; // new point 4
                
                //2020-12-18 ZJYEOH : Change to this format
                //  Point 1 *-------------* Point 2
                //          |             |
                //          |             |
                //          |             |
                //  Point 4 *-------------* Point 3

                Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX - (fObjectWidth / 2)), (fObjectCenterY - (fObjectHeight / 2)), fObjectAngle, ref newX1, ref newY1);
                Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX + (fObjectWidth / 2)), (fObjectCenterY - (fObjectHeight / 2)), fObjectAngle, ref newX2, ref newY2);
                Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX + (fObjectWidth / 2)), (fObjectCenterY + (fObjectHeight / 2)), fObjectAngle, ref newX3, ref newY3);
                Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX - (fObjectWidth / 2)), (fObjectCenterY + (fObjectHeight / 2)), fObjectAngle, ref newX4, ref newY4);


                arrRotatedPoints[i].Add(new PointF(newX1, newY1));
                arrRotatedPoints[i].Add(new PointF(newX2, newY2));
                arrRotatedPoints[i].Add(new PointF(newX3, newY3));
                arrRotatedPoints[i].Add(new PointF(newX4, newY4));

                if(intDarkDefectIndex == 2)
                {
                    Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX - (fObjectWidth / 2)) - m_intDark2DefectLinkTolerance, (fObjectCenterY - (fObjectHeight / 2)) - m_intDark2DefectLinkTolerance, fObjectAngle, ref newX1, ref newY1);
                    Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX + (fObjectWidth / 2)) + m_intDark2DefectLinkTolerance, (fObjectCenterY - (fObjectHeight / 2)) - m_intDark2DefectLinkTolerance, fObjectAngle, ref newX2, ref newY2);
                    Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX + (fObjectWidth / 2)) + m_intDark2DefectLinkTolerance, (fObjectCenterY + (fObjectHeight / 2)) + m_intDark2DefectLinkTolerance, fObjectAngle, ref newX3, ref newY3);
                    Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX - (fObjectWidth / 2)) - m_intDark2DefectLinkTolerance, (fObjectCenterY + (fObjectHeight / 2)) + m_intDark2DefectLinkTolerance, fObjectAngle, ref newX4, ref newY4);
                }
                else if(intDarkDefectIndex == 3)
                {
                    Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX - (fObjectWidth / 2)) - m_intDark3DefectLinkTolerance, (fObjectCenterY - (fObjectHeight / 2)) - m_intDark3DefectLinkTolerance, fObjectAngle, ref newX1, ref newY1);
                    Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX + (fObjectWidth / 2)) + m_intDark3DefectLinkTolerance, (fObjectCenterY - (fObjectHeight / 2)) - m_intDark3DefectLinkTolerance, fObjectAngle, ref newX2, ref newY2);
                    Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX + (fObjectWidth / 2)) + m_intDark3DefectLinkTolerance, (fObjectCenterY + (fObjectHeight / 2)) + m_intDark3DefectLinkTolerance, fObjectAngle, ref newX3, ref newY3);
                    Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX - (fObjectWidth / 2)) - m_intDark3DefectLinkTolerance, (fObjectCenterY + (fObjectHeight / 2)) + m_intDark3DefectLinkTolerance, fObjectAngle, ref newX4, ref newY4);
                }
                else if(intDarkDefectIndex == 4)
                {
                    Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX - (fObjectWidth / 2)) - m_intDark4DefectLinkTolerance, (fObjectCenterY - (fObjectHeight / 2)) - m_intDark4DefectLinkTolerance, fObjectAngle, ref newX1, ref newY1);
                    Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX + (fObjectWidth / 2)) + m_intDark4DefectLinkTolerance, (fObjectCenterY - (fObjectHeight / 2)) - m_intDark4DefectLinkTolerance, fObjectAngle, ref newX2, ref newY2);
                    Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX + (fObjectWidth / 2)) + m_intDark4DefectLinkTolerance, (fObjectCenterY + (fObjectHeight / 2)) + m_intDark4DefectLinkTolerance, fObjectAngle, ref newX3, ref newY3);
                    Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX - (fObjectWidth / 2)) - m_intDark4DefectLinkTolerance, (fObjectCenterY + (fObjectHeight / 2)) + m_intDark4DefectLinkTolerance, fObjectAngle, ref newX4, ref newY4);
                }

                arr2DPoints[i].Add(new System.Windows.Point(newX1, newY1));
                arr2DPoints[i].Add(new System.Windows.Point(newX2, newY2));
                arr2DPoints[i].Add(new System.Windows.Point(newX3, newY3));
                arr2DPoints[i].Add(new System.Windows.Point(newX4, newY4));
                
                fObjectHeightList.Add(fObjectHeight);
                fObjectWidthList.Add(fObjectWidth);
                fObjectCenterXList.Add(fObjectCenterX);
                fObjectCenterYList.Add(fObjectCenterY);
                fObjectAngleList.Add(fObjectAngle);
                fObjectAreaList.Add(intObjectArea);
                fObjectAreaList2.Add(intObjectArea);
            }
            int intTolerance = 10;

            if (intDarkDefectIndex == 2)
                intTolerance = m_intDark2DefectLinkTolerance;
            else if (intDarkDefectIndex == 3)
                intTolerance = m_intDark3DefectLinkTolerance;
            else if (intDarkDefectIndex == 4)
                intTolerance = m_intDark4DefectLinkTolerance;

            int intAngleTolerance = 10;
            bool blnDecrement = false;
            if (intTolerance >= 0)
            {
                for (int i = 0; i < fObjectHeightList.Count; i++)
                {
                    if (blnDecrement)
                    {
                        blnDecrement = false;
                        if (i > 0)
                            i--;
                    }
                    for (int j = 0; j < fObjectHeightList.Count; j++)
                    {
                        if (i != j && i < fObjectHeightList.Count && j < fObjectHeightList.Count)
                        {
                            if (Intersection.CheckRectRectIntersection(arr2DPoints[i].ToArray(), arr2DPoints[j].ToArray(), intTolerance))
                            {
                           
                                PointF[] arrPoints = new PointF[8];

                                arrPoints[0] = arrRotatedPoints[i][0];
                                arrPoints[1] = arrRotatedPoints[i][1];
                                arrPoints[2] = arrRotatedPoints[i][2];
                                arrPoints[3] = arrRotatedPoints[i][3];
                                arrPoints[4] = arrRotatedPoints[j][0];
                                arrPoints[5] = arrRotatedPoints[j][1];
                                arrPoints[6] = arrRotatedPoints[j][2];
                                arrPoints[7] = arrRotatedPoints[j][3];

                                float fMinAngle = 0;
                                List<PointF> arrMinRect = new List<PointF>();
                                arrMinRect = MinimumBoundingBox.CalculateMinimumBoundingBox(arrPoints, ref fMinAngle);

                                if (fMinAngle < 0)
                                    fObjectAngleList[i] = -(90 + fMinAngle);
                                else
                                    fObjectAngleList[i] = 90 - fMinAngle;

                                Line onjLine1 = new Line();
                                Line onjLine2 = new Line();
                                onjLine1.CalculateStraightLine(arrMinRect[0], arrMinRect[2]);
                                onjLine2.CalculateStraightLine(arrMinRect[1], arrMinRect[3]);
                                PointF pCenter = Line.GetCrossPoint(onjLine1, onjLine2);
                                float p1X = 0, p1Y = 0;
                                float p2X = 0, p2Y = 0;
                                float p3X = 0, p3Y = 0;
                                float p4X = 0, p4Y = 0;
                                Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[0].X, arrMinRect[0].Y, -fObjectAngleList[i], ref p1X, ref p1Y);
                                Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[1].X, arrMinRect[1].Y, -fObjectAngleList[i], ref p2X, ref p2Y);
                                Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[2].X, arrMinRect[2].Y, -fObjectAngleList[i], ref p3X, ref p3Y);
                                Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[3].X, arrMinRect[3].Y, -fObjectAngleList[i], ref p4X, ref p4Y);

                                float pR1X = 0, pR1Y = 0;
                                float pR2X = 0, pR2Y = 0;
                                float pR3X = 0, pR3Y = 0;
                                float pR4X = 0, pR4Y = 0;
                                Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)), Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)), fObjectAngleList[i], ref pR1X, ref pR1Y); // Top Left
                                Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)), Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)), fObjectAngleList[i], ref pR2X, ref pR2Y); // Top Right
                                Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)), Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)), fObjectAngleList[i], ref pR3X, ref pR3Y); // Bottom Right
                                Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)), Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)), fObjectAngleList[i], ref pR4X, ref pR4Y); // Bottom Left
                                arrMinRect[0] = new PointF(pR1X, pR1Y);
                                arrMinRect[1] = new PointF(pR2X, pR2Y);
                                arrMinRect[2] = new PointF(pR3X, pR3Y);
                                arrMinRect[3] = new PointF(pR4X, pR4Y);
                                
                                arrRotatedPoints[i][0] = arrMinRect[0];
                                arrRotatedPoints[i][1] = arrMinRect[1];
                                arrRotatedPoints[i][2] = arrMinRect[2];
                                arrRotatedPoints[i][3] = arrMinRect[3];

                                if(intDarkDefectIndex == 2)
                                {
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)) - m_intDark2DefectLinkTolerance, Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)) - m_intDark2DefectLinkTolerance, fObjectAngleList[i], ref pR1X, ref pR1Y); // Top Left
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)) + m_intDark2DefectLinkTolerance, Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)) - m_intDark2DefectLinkTolerance, fObjectAngleList[i], ref pR2X, ref pR2Y); // Top Right
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)) + m_intDark2DefectLinkTolerance, Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)) + m_intDark2DefectLinkTolerance, fObjectAngleList[i], ref pR3X, ref pR3Y); // Bottom Right
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)) - m_intDark2DefectLinkTolerance, Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)) + m_intDark2DefectLinkTolerance, fObjectAngleList[i], ref pR4X, ref pR4Y); // Bottom Left
                                }
                                else if(intDarkDefectIndex == 3)
                                {
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)) - m_intDark3DefectLinkTolerance, Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)) - m_intDark3DefectLinkTolerance, fObjectAngleList[i], ref pR1X, ref pR1Y); // Top Left
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)) + m_intDark3DefectLinkTolerance, Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)) - m_intDark3DefectLinkTolerance, fObjectAngleList[i], ref pR2X, ref pR2Y); // Top Right
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)) + m_intDark3DefectLinkTolerance, Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)) + m_intDark3DefectLinkTolerance, fObjectAngleList[i], ref pR3X, ref pR3Y); // Bottom Right
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)) - m_intDark3DefectLinkTolerance, Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)) + m_intDark3DefectLinkTolerance, fObjectAngleList[i], ref pR4X, ref pR4Y); // Bottom Left
                                }
                                else if(intDarkDefectIndex == 4)
                                {
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)) - m_intDark4DefectLinkTolerance, Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)) - m_intDark4DefectLinkTolerance, fObjectAngleList[i], ref pR1X, ref pR1Y); // Top Left
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)) + m_intDark4DefectLinkTolerance, Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)) - m_intDark4DefectLinkTolerance, fObjectAngleList[i], ref pR2X, ref pR2Y); // Top Right
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)) + m_intDark4DefectLinkTolerance, Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)) + m_intDark4DefectLinkTolerance, fObjectAngleList[i], ref pR3X, ref pR3Y); // Bottom Right
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)) - m_intDark4DefectLinkTolerance, Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)) + m_intDark4DefectLinkTolerance, fObjectAngleList[i], ref pR4X, ref pR4Y); // Bottom Left
                                }

                                arr2DPoints[i][0] = new System.Windows.Point(pR1X, pR1Y);
                                arr2DPoints[i][1] = new System.Windows.Point(pR2X, pR2Y);
                                arr2DPoints[i][2] = new System.Windows.Point(pR3X, pR3Y);
                                arr2DPoints[i][3] = new System.Windows.Point(pR4X, pR4Y);

                                arrRotatedPoints.RemoveAt(j);
                                arr2DPoints.RemoveAt(j);

                                float fDiffX = Math.Max(Math.Abs(p1X - p4X), Math.Abs(p2X - p3X));
                                float fDiffY = Math.Max(Math.Abs(p3Y - p4Y), Math.Abs(p2Y - p1Y));
                        
                                fObjectWidthList[i] = fDiffX;
                                fObjectHeightList[i] = fDiffY;

                                fObjectCenterXList[i] = pCenter.X;
                                fObjectCenterYList[i] = pCenter.Y;

                                fObjectAreaList2.RemoveAt(j);
                                fObjectAreaList[i] = fObjectAreaList[i] + fObjectAreaList[j];
                                fObjectHeightList.RemoveAt(j);
                                fObjectWidthList.RemoveAt(j);
                                fObjectCenterXList.RemoveAt(j);
                                fObjectCenterYList.RemoveAt(j);
                                fObjectAngleList.RemoveAt(j);
                                fObjectAreaList.RemoveAt(j);
                                if (j > 0)
                                    j = -1;
                                if (i > 0)
                                {
                                    i = 0;
                                }
                                else
                                    blnDecrement = true;

                            }
                           
                        }
                    }
                }
            }
            for (int i = 0; i < fObjectHeightList.Count; i++)
            {

                if (fObjectHeightList[i] < fObjectWidthList[i])
                {
                    fObjectWidth = fObjectHeightList[i];
                    fObjectHeight = fObjectWidthList[i];
                 
                    fObjectAngle = fObjectAngleList[i];

                    if (fObjectAngle >= 10)//&& fAngle <= 80)
                        fObjectAngle = fObjectAngleList[i] - 90;
                    else
                        fObjectAngle = 90 + fObjectAngleList[i];

                    fObjectWidthList[i] = fObjectWidth;
                    fObjectHeightList[i] = fObjectHeight;
                    fObjectAngleList[i] = fObjectAngle;
                }
                else
                {
                    fObjectHeight = fObjectHeightList[i];
                    fObjectWidth = fObjectWidthList[i];

                    fObjectAngle = fObjectAngleList[i];

                    fObjectWidthList[i] = fObjectWidth;
                    fObjectHeightList[i] = fObjectHeight;
                    fObjectAngleList[i] = fObjectAngle;
                }

                bool blnFail = false;
                int intFailMask = 0;
                string strDefectName = "";

                if (intDarkDefectIndex == 2)
                    strDefectName = "Dark 2";
                else if (intDarkDefectIndex == 3)
                    strDefectName = "Dark 3";
                else if (intDarkDefectIndex == 4)
                    strDefectName = "Dark 4";

                if (m_arrWantDefectLength[(int)eWantDefect.Dark2] && intDarkDefectIndex == 2)
                {
                    if (m_intDark2DefectDimensionFailCondition == 0)
                    {
                        if (fObjectWidthList[i] >= GetDefect("Dark 2", 0))
                        {
                            m_strErrorMessage += "* Package Dark Field 2 Width Fail. Set = " + (GetDefect("Dark 2", 0) / m_fMMToPixelXValue).ToString("f5") + " mm,   Result = " + (fObjectWidthList[i] / m_fMMToPixelXValue).ToString("f5") + " mm";
                            blnFail = true;
                            intFailMask |= 0x01;
                            strDefectName = "Dark 2";
                        }

                        if (fObjectHeightList[i] >= GetDefect("Dark 2", 1))
                        {
                            m_strErrorMessage += "* Package Dark Field 2 Length Fail. Set = " + (GetDefect("Dark 2", 1) / m_fMMToPixelYValue).ToString("f5") + " mm,   Result = " + (fObjectHeightList[i] / m_fMMToPixelYValue).ToString("f5") + " mm";
                            blnFail = true;
                            intFailMask |= 0x02;
                            strDefectName = "Dark 2";
                        }
                    }
                    else
                    {
                        if ((fObjectWidthList[i] >= GetDefect("Dark 2", 0)) && (fObjectHeightList[i] >= GetDefect("Dark 2", 1)))
                        {
                            m_strErrorMessage += "* Package Dark Field 2 Width Fail. Set = " + (GetDefect("Dark 2", 0) / m_fMMToPixelXValue).ToString("f5") + " mm,   Result = " + (fObjectWidthList[i] / m_fMMToPixelXValue).ToString("f5") + " mm";
                            intFailMask |= 0x01;
                            m_strErrorMessage += "* Package Dark Field 2 Length Fail. Set = " + (GetDefect("Dark 2", 1) / m_fMMToPixelYValue).ToString("f5") + " mm,   Result = " + (fObjectHeightList[i] / m_fMMToPixelYValue).ToString("f5") + " mm";
                            blnFail = true;
                            intFailMask |= 0x02;
                            strDefectName = "Dark 2";
                        }
                    }
                }
                else if (m_arrWantDefectLength[(int)eWantDefect.Dark3] && intDarkDefectIndex == 3)
                {
                    if (m_intDark3DefectDimensionFailCondition == 0)
                    {
                        if (fObjectWidthList[i] >= GetDefect("Dark 3", 0))
                        {
                            m_strErrorMessage += "* Package Dark Field 3 Width Fail. Set = " + (GetDefect("Dark 3", 0) / m_fMMToPixelXValue).ToString("f5") + " mm,   Result = " + (fObjectWidthList[i] / m_fMMToPixelXValue).ToString("f5") + " mm";
                            blnFail = true;
                            intFailMask |= 0x01;
                            strDefectName = "Dark 3";
                        }

                        if (fObjectHeightList[i] >= GetDefect("Dark 3", 1))
                        {
                            m_strErrorMessage += "* Package Dark Field 3 Length Fail. Set = " + (GetDefect("Dark 3", 1) / m_fMMToPixelYValue).ToString("f5") + " mm,   Result = " + (fObjectHeightList[i] / m_fMMToPixelYValue).ToString("f5") + " mm";
                            blnFail = true;
                            intFailMask |= 0x02;
                            strDefectName = "Dark 3";
                        }
                    }
                    else
                    {
                        if ((fObjectWidthList[i] >= GetDefect("Dark 3", 0)) && (fObjectHeightList[i] >= GetDefect("Dark 3", 1)))
                        {
                            m_strErrorMessage += "* Package Dark Field 3 Width Fail. Set = " + (GetDefect("Dark 3", 0) / m_fMMToPixelXValue).ToString("f5") + " mm,   Result = " + (fObjectWidthList[i] / m_fMMToPixelXValue).ToString("f5") + " mm";
                            intFailMask |= 0x01;
                            m_strErrorMessage += "* Package Dark Field 3 Length Fail. Set = " + (GetDefect("Dark 3", 1) / m_fMMToPixelYValue).ToString("f5") + " mm,   Result = " + (fObjectHeightList[i] / m_fMMToPixelYValue).ToString("f5") + " mm";
                            blnFail = true;
                            intFailMask |= 0x02;
                            strDefectName = "Dark 3";
                        }
                    }
                }
                else if (m_arrWantDefectLength[(int)eWantDefect.Dark4] && intDarkDefectIndex == 4)
                {
                    if (m_intDark4DefectDimensionFailCondition == 0)
                    {
                        if (fObjectWidthList[i] >= GetDefect("Dark 4", 0))
                        {
                            m_strErrorMessage += "* Package Dark Field 4 Width Fail. Set = " + (GetDefect("Dark 4", 0) / m_fMMToPixelXValue).ToString("f5") + " mm,   Result = " + (fObjectWidthList[i] / m_fMMToPixelXValue).ToString("f5") + " mm";
                            blnFail = true;
                            intFailMask |= 0x01;
                            strDefectName = "Dark 4";
                        }

                        if (fObjectHeightList[i] >= GetDefect("Dark 4", 1))
                        {
                            m_strErrorMessage += "* Package Dark Field 4 Length Fail. Set = " + (GetDefect("Dark 4", 1) / m_fMMToPixelYValue).ToString("f5") + " mm,   Result = " + (fObjectHeightList[i] / m_fMMToPixelYValue).ToString("f5") + " mm";
                            blnFail = true;
                            intFailMask |= 0x02;
                            strDefectName = "Dark 4";
                        }
                    }
                    else
                    {
                        if ((fObjectWidthList[i] >= GetDefect("Dark 4", 0)) && (fObjectHeightList[i] >= GetDefect("Dark 4", 1)))
                        {
                            m_strErrorMessage += "* Package Dark Field 4 Width Fail. Set = " + (GetDefect("Dark 4", 0) / m_fMMToPixelXValue).ToString("f5") + " mm,   Result = " + (fObjectWidthList[i] / m_fMMToPixelXValue).ToString("f5") + " mm";
                            intFailMask |= 0x01;
                            m_strErrorMessage += "* Package Dark Field 4 Length Fail. Set = " + (GetDefect("Dark 4", 1) / m_fMMToPixelYValue).ToString("f5") + " mm,   Result = " + (fObjectHeightList[i] / m_fMMToPixelYValue).ToString("f5") + " mm";
                            blnFail = true;
                            intFailMask |= 0x02;
                            strDefectName = "Dark 4";
                        }
                    }
                }



                if (m_arrWantDefectArea[(int)eWantDefect.Dark2] && intDarkDefectIndex == 2)
                {
                    if (fObjectAreaList[i] >= GetAreaDefect("Dark 2"))
                    {
                        m_strErrorMessage += "* Package Dark Field 2 Area Fail. Set = " + (GetAreaDefect("Dark 2") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (fObjectAreaList[i] / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        blnFail = true;
                        intFailMask |= 0x04;
                        strDefectName = "Dark 2";
                    }
                }
               else if (m_arrWantDefectArea[(int)eWantDefect.Dark3] && intDarkDefectIndex == 3)
                {
                    if (fObjectAreaList[i] >= GetAreaDefect("Dark 3"))
                    {
                        m_strErrorMessage += "* Package Dark Field 3 Area Fail. Set = " + (GetAreaDefect("Dark 3") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (fObjectAreaList[i] / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        blnFail = true;
                        intFailMask |= 0x04;
                        strDefectName = "Dark 3";
                    }
                }
                else if (m_arrWantDefectArea[(int)eWantDefect.Dark4] && intDarkDefectIndex == 4)
                {
                    if (fObjectAreaList[i] >= GetAreaDefect("Dark 4"))
                    {
                        m_strErrorMessage += "* Package Dark Field 4 Area Fail. Set = " + (GetAreaDefect("Dark 4") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (fObjectAreaList[i] / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        blnFail = true;
                        intFailMask |= 0x04;
                        strDefectName = "Dark 4";
                    }
                }


                if (blnFail)
                {
                    Defect objDefect = new Defect();
                    objDefect.ref_fDimX = fObjectWidthList[i];
                    objDefect.ref_fDimY = fObjectHeightList[i];
                    objDefect.ref_intLengthMode = intLengthMode;
                    objDefect.ref_fArea = fObjectAreaList[i];
                    objDefect.ref_fCenterX = objROI.ref_ROITotalX + fObjectCenterXList[i];
                    objDefect.ref_fCenterY = objROI.ref_ROITotalY + fObjectCenterYList[i];
                    objDefect.ref_fAngle = fObjectAngleList[i];
                    objDefect.ref_intBlobNo = i;
                    objDefect.ref_intFailMask = intFailMask;
                    objDefect.ref_strName = strDefectName;
                    objDefect.ref_intFailedImage = intSelectedImageIndex + 1;
                    m_arrDefectList.Add(objDefect);

                    if (!blnOverAllFail)
                        blnOverAllFail = true;
                }
                else
                {
                    Defect objDefect = new Defect();
                    objDefect.ref_fDimX = fObjectWidthList[i];
                    objDefect.ref_fDimY = fObjectHeightList[i];
                    objDefect.ref_intLengthMode = intLengthMode;
                    objDefect.ref_fArea = fObjectAreaList[i];
                    objDefect.ref_fCenterX = objROI.ref_ROITotalX + fObjectCenterXList[i];
                    objDefect.ref_fCenterY = objROI.ref_ROITotalY + fObjectCenterYList[i];
                    objDefect.ref_fAngle = fObjectAngleList[i];
                    objDefect.ref_intBlobNo = i;
                    objDefect.ref_intFailMask = 0;
                    objDefect.ref_strName = strDefectName;
                    objDefect.ref_intFailedImage = intSelectedImageIndex + 1;
                    m_arrDefectList.Add(objDefect);
                }
            }

            if (m_arrWantDefectArea[(int)eWantDefect.Dark2] && intDarkDefectIndex == 2)
            {
                if (intObjectTotalArea >= GetTotalAreaDefect("Dark 2"))
                {
                    m_strErrorMessage += "* Package Dark Field 2 Total Area Fail. Set = " + (GetTotalAreaDefect("Dark 2") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectTotalArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                    m_blnCrackChipViewFailTotalArea = true;

                    Defect objDefect = new Defect();
                    objDefect.ref_fDimX = -1;
                    objDefect.ref_fDimY = -1;
                    objDefect.ref_intLengthMode = intLengthMode;
                    objDefect.ref_fArea = intObjectTotalArea;
                    objDefect.ref_fCenterX = objROI.ref_ROITotalX + m_objEBlobs.ref_arrRectLimitCenterX[0];
                    objDefect.ref_fCenterY = objROI.ref_ROITotalY + m_objEBlobs.ref_arrRectLimitCenterY[0];
                    objDefect.ref_fAngle = fObjectAngle; //m_objEBlobs.ref_arrRectAngle[0];
                    objDefect.ref_intFailMask |= 0x04;
                    objDefect.ref_strName = "Total Dark 2";
                    objDefect.ref_intFailedImage = intSelectedImageIndex + 1;
                    m_arrDefectList.Add(objDefect);

                    if (!blnOverAllFail)
                        blnOverAllFail = true;
                }
            }
            else if (m_arrWantDefectArea[(int)eWantDefect.Dark3] && intDarkDefectIndex == 3)
            {
                if (intObjectTotalArea >= GetTotalAreaDefect("Dark 3"))
                {
                    m_strErrorMessage += "* Package Dark Field 3 Total Area Fail. Set = " + (GetTotalAreaDefect("Dark 3") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectTotalArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                    m_blnCrackChipViewFailTotalArea = true;

                    Defect objDefect = new Defect();
                    objDefect.ref_fDimX = -1;
                    objDefect.ref_fDimY = -1;
                    objDefect.ref_intLengthMode = intLengthMode;
                    objDefect.ref_fArea = intObjectTotalArea;
                    objDefect.ref_fCenterX = objROI.ref_ROITotalX + m_objEBlobs.ref_arrRectLimitCenterX[0];
                    objDefect.ref_fCenterY = objROI.ref_ROITotalY + m_objEBlobs.ref_arrRectLimitCenterY[0];
                    objDefect.ref_fAngle = fObjectAngle; //m_objEBlobs.ref_arrRectAngle[0];
                    objDefect.ref_intFailMask |= 0x04;
                    objDefect.ref_strName = "Total Dark 3";
                    objDefect.ref_intFailedImage = intSelectedImageIndex + 1;
                    m_arrDefectList.Add(objDefect);

                    if (!blnOverAllFail)
                        blnOverAllFail = true;
                }
            }
            else if (m_arrWantDefectArea[(int)eWantDefect.Dark4] && intDarkDefectIndex == 4)
            {
                if (intObjectTotalArea >= GetTotalAreaDefect("Dark 4"))
                {
                    m_strErrorMessage += "* Package Dark Field 4 Total Area Fail. Set = " + (GetTotalAreaDefect("Dark 4") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectTotalArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                    m_blnCrackChipViewFailTotalArea = true;

                    Defect objDefect = new Defect();
                    objDefect.ref_fDimX = -1;
                    objDefect.ref_fDimY = -1;
                    objDefect.ref_intLengthMode = intLengthMode;
                    objDefect.ref_fArea = intObjectTotalArea;
                    objDefect.ref_fCenterX = objROI.ref_ROITotalX + m_objEBlobs.ref_arrRectLimitCenterX[0];
                    objDefect.ref_fCenterY = objROI.ref_ROITotalY + m_objEBlobs.ref_arrRectLimitCenterY[0];
                    objDefect.ref_fAngle = fObjectAngle; //m_objEBlobs.ref_arrRectAngle[0];
                    objDefect.ref_intFailMask |= 0x04;
                    objDefect.ref_strName = "Total Dark 4";
                    objDefect.ref_intFailedImage = intSelectedImageIndex + 1;
                    m_arrDefectList.Add(objDefect);

                    if (!blnOverAllFail)
                        blnOverAllFail = true;
                }
            }



            if (blnOverAllFail)
            {
                m_intPkgFailResultMask |= 0x400;
                return false;
            }
            else
                return true;
        }
        public bool InspectionImage3DarkFieldDefect(ImageDrawing objGrayValueImage, ROI objROI, int intInspectionAreaGrayValueSensitivity, int intMergeSensitivity, int intDarkSensitivity)
        {
            int intSelectedImageIndex = m_arrGrabImageIndex[3];

            // 2020-05-15 ZJYEOH : New Inspection Method using gray value
            // Step 1 : Get average gray value of package surface area
            float fAverageGrayValue = 0;
            //EasyImage.PixelAverage(objROI.ref_ROI, out fAverageGrayValue);
            
            // Step 2 : declare another ROI and threshold it using (average gray value - sensitivity)
            ROI objThresholdROI = new ROI();
            //objThresholdROI.LoadROISetting(0, 0, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
            //ImageDrawing objImage = new ImageDrawing();
            ImageDrawing objTempImage = new ImageDrawing();
            objThresholdROI.LoadROISetting(objROI.ref_ROITotalX, objROI.ref_ROITotalY, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
            objGrayValueImage.CopyTo(ref objTempImage);
            objThresholdROI.AttachImage(objGrayValueImage);
            //objROI.CopyToImage(ref objImage);
            //objThresholdROI.AttachImage(objImage);
            EasyImage.PixelAverage(objThresholdROI.ref_ROI, out fAverageGrayValue);

            int intLowThreshold = (int)Math.Round(fAverageGrayValue) - intInspectionAreaGrayValueSensitivity;
            if (intLowThreshold < 0)
                intLowThreshold = 0;
#if (Debug_2_12 || Release_2_12)
            EasyImage.DoubleThreshold(objThresholdROI.ref_ROI, objThresholdROI.ref_ROI, (uint)intLowThreshold, 255, 0, 255, 0);
            //objThresholdROI.ref_ROI.Save("D:\\objThresholdROI1.bmp");
            //for Dark Defect, no need invert
            //// Step 3 : invert the thrshold ROI 
            //EasyImage.Oper(EArithmeticLogicOperation.Invert, objThresholdROI.ref_ROI, objThresholdROI.ref_ROI);
            //objROI.ref_ROI.Save("D:\\objROI1.bmp");
            // Step 4 : Add Original ROI with inverted threshold ROI will result defect below the threshold value only
            EasyImage.Oper(EArithmeticLogicOperation.Add, objROI.ref_ROI, objThresholdROI.ref_ROI, objROI.ref_ROI);
            //objROI.ref_ROI.Save("D:\\objROI2.bmp");
            // Step 5 : using Open morphology to link the small defect together using sensitivity set by user
            EasyImage.OpenDisk(objROI.ref_ROI, objROI.ref_ROI, (uint)intMergeSensitivity);
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
            EasyImage.DoubleThreshold(objThresholdROI.ref_ROI, objThresholdROI.ref_ROI, intLowThreshold, 255, 0, 255, 0);
            //objThresholdROI.ref_ROI.Save("D:\\objThresholdROI1.bmp");
            //for Dark Defect, no need invert
            //// Step 3 : invert the thrshold ROI 
            //EasyImage.Oper(EArithmeticLogicOperation.Invert, objThresholdROI.ref_ROI, objThresholdROI.ref_ROI);
            //objROI.ref_ROI.Save("D:\\objROI1.bmp");
            // Step 4 : Add Original ROI with inverted threshold ROI will result defect below the threshold value only
            EasyImage.Oper(EArithmeticLogicOperation.Add, objROI.ref_ROI, objThresholdROI.ref_ROI, objROI.ref_ROI);
            //objROI.ref_ROI.Save("D:\\objROI2.bmp");
            // Step 5 : using Open morphology to link the small defect together using sensitivity set by user
            EasyImage.OpenDisk(objROI.ref_ROI, objROI.ref_ROI, intMergeSensitivity);
#endif

            //objROI.ref_ROI.Save("D:\\objROI3.bmp");
            // Step 6 : Get average gray value of the final ROI
            //fAverageGrayValue = 0;
            //EasyImage.PixelAverage(objROI.ref_ROI, out fAverageGrayValue);

            ROI objTempROI = new ROI();
            objTempROI.LoadROISetting(objROI.ref_ROITotalX, objROI.ref_ROITotalY, objROI.ref_ROIWidth, objROI.ref_ROIHeight);

            objTempROI.AttachImage(objTempImage);
            fAverageGrayValue = 0;
            EasyImage.PixelAverage(objTempROI.ref_ROI, objThresholdROI.ref_ROI, out fAverageGrayValue);
            //objTempROI.ref_ROI.Save("D:\\objTempROI1.bmp");

            objTempROI.Dispose();
            objThresholdROI.Dispose();
            objTempImage.Dispose();
            //objImage.Dispose();

            // Step 7 : Build blob using the threshold value (average gray value - dark sensitivity)
            intLowThreshold = (int)Math.Round(fAverageGrayValue) - intDarkSensitivity;
            if (intLowThreshold < 0)
                intLowThreshold = 0;
            int intSelectedObjectNum = m_objEBlobs.BuildObjects_Filter_GetElement_DoubleThreshold(
                objROI, true, false, false, m_intConnexity == 8, intLowThreshold, 255, //m_intDarkFieldHighThreshold, //Always use 255 because user cannot set threshold anymore
                m_intDarkFieldMinArea, objROI.ref_ROIWidth * objROI.ref_ROIHeight, false, 0xED);

            if (intSelectedObjectNum == 0)
                return true;

            int intObjectTotalArea = 0;
            int intObjectArea = 0;
            int intLengthMode = 0;
            float fObjectHeight = 0, fObjectWidth = 0, fObjectCenterX = 0, fObjectCenterY = 0, fObjectAngle = 0;
            bool blnOverAllFail = false;
            for (int i = 0; i < intSelectedObjectNum; i++)
            {

                intObjectArea = m_objEBlobs.ref_arrArea[i];
                //if (m_objEBlobs.ref_arrRectWidth[i] < m_objEBlobs.ref_arrRectHeight[i])
                //{
                //    fObjectWidth = m_objEBlobs.ref_arrRectWidth[i];
                //    fObjectHeight = m_objEBlobs.ref_arrRectHeight[i];
                //    intLengthMode = 0;

                //    fObjectAngle = m_objEBlobs.ref_arrRectAngle[i];
                //    if (fObjectAngle < 0)
                //        fObjectAngle = -Math.Abs(fObjectAngle);
                //    else
                //        fObjectAngle = -fObjectAngle;

                //}
                //else
                //{
                //    fObjectHeight = m_objEBlobs.ref_arrRectWidth[i];
                //    fObjectWidth = m_objEBlobs.ref_arrRectHeight[i];
                //    intLengthMode = 0;  //1;

                //    fObjectAngle = m_objEBlobs.ref_arrRectAngle[i];
                //    if (fObjectAngle < 0)
                //        fObjectAngle = Math.Abs(fObjectAngle);
                //    else
                //        fObjectAngle = 90 - (fObjectAngle);
                //}

                if (m_objEBlobs.ref_arrRectHeight[i] < m_objEBlobs.ref_arrRectWidth[i])
                {
                    fObjectWidth = m_objEBlobs.ref_arrRectHeight[i];
                    fObjectHeight = m_objEBlobs.ref_arrRectWidth[i];
                    intLengthMode = 0;
                    fObjectAngle = m_objEBlobs.ref_arrRectAngle[i];

                    if (fObjectAngle >= 10)//&& fAngle <= 80)
                        fObjectAngle = m_objEBlobs.ref_arrRectAngle[i] - 90;
                    else
                        fObjectAngle = 90 + m_objEBlobs.ref_arrRectAngle[i];

                }
                else
                {
                    fObjectHeight = m_objEBlobs.ref_arrRectHeight[i];
                    fObjectWidth = m_objEBlobs.ref_arrRectWidth[i];
                    intLengthMode = 0;

                    fObjectAngle = m_objEBlobs.ref_arrRectAngle[i];

                }
                fObjectCenterX = m_objEBlobs.ref_arrRectLimitCenterX[i];
                fObjectCenterY = m_objEBlobs.ref_arrRectLimitCenterY[i];
                intObjectTotalArea += intObjectArea;

                bool blnFail = false;
                int intFailMask = 0;
                string strDefectName = "Dark";
                if (m_arrWantDefectLength[(int)eWantDefect.Dark])
                {
                    if (m_intDark2DefectDimensionFailCondition == 0)
                    {
                        if (fObjectWidth >= GetDefect("Dark", 0))
                        {
                            m_strErrorMessage += "* Package Dark Field Width Fail. Set = " + (GetDefect("Dark", 0) / m_fMMToPixelXValue).ToString("f5") + " mm,   Result = " + (fObjectWidth / m_fMMToPixelXValue).ToString("f5") + " mm";
                            blnFail = true;
                            intFailMask |= 0x01;
                            strDefectName = "Dark";
                        }

                        if (fObjectHeight >= GetDefect("Dark", 1))
                        {
                            m_strErrorMessage += "* Package Dark Field Length Fail. Set = " + (GetDefect("Dark", 1) / m_fMMToPixelYValue).ToString("f5") + " mm,   Result = " + (fObjectHeight / m_fMMToPixelYValue).ToString("f5") + " mm";
                            blnFail = true;
                            intFailMask |= 0x02;
                            strDefectName = "Dark";
                        }
                    }
                    else
                    {
                        if ((fObjectWidth >= GetDefect("Dark", 0)) && (fObjectHeight >= GetDefect("Dark", 1)))
                        {
                            m_strErrorMessage += "* Package Dark Field Width Fail. Set = " + (GetDefect("Dark", 0) / m_fMMToPixelXValue).ToString("f5") + " mm,   Result = " + (fObjectWidth / m_fMMToPixelXValue).ToString("f5") + " mm";
                            intFailMask |= 0x01;
                            m_strErrorMessage += "* Package Dark Field Length Fail. Set = " + (GetDefect("Dark", 1) / m_fMMToPixelYValue).ToString("f5") + " mm,   Result = " + (fObjectHeight / m_fMMToPixelYValue).ToString("f5") + " mm";
                            blnFail = true;
                            intFailMask |= 0x02;
                            strDefectName = "Dark";
                        }
                    }
                }

                if (m_arrWantDefectArea[(int)eWantDefect.Dark])
                {
                    if (intObjectArea >= GetAreaDefect("Dark"))
                    {
                        m_strErrorMessage += "* Package Dark Field Area Fail. Set = " + (GetAreaDefect("Dark") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        blnFail = true;
                        intFailMask |= 0x04;
                        strDefectName = "Dark";
                    }
                }

                if (blnFail)
                {
                    Defect objDefect = new Defect();
                    objDefect.ref_fDimX = fObjectWidth;
                    objDefect.ref_fDimY = fObjectHeight;
                    objDefect.ref_intLengthMode = intLengthMode;
                    objDefect.ref_fArea = intObjectArea;
                    objDefect.ref_fCenterX = objROI.ref_ROITotalX + fObjectCenterX;
                    objDefect.ref_fCenterY = objROI.ref_ROITotalY + fObjectCenterY;
                    objDefect.ref_fAngle = fObjectAngle;
                    objDefect.ref_intBlobNo = i;
                    objDefect.ref_intFailMask = intFailMask;
                    objDefect.ref_strName = strDefectName;
                    objDefect.ref_intFailedImage = intSelectedImageIndex + 1;
                    m_arrDefectList.Add(objDefect);

                    if (!blnOverAllFail)
                        blnOverAllFail = true;
                }
                else
                {
                    Defect objDefect = new Defect();
                    objDefect.ref_fDimX = fObjectWidth;
                    objDefect.ref_fDimY = fObjectHeight;
                    objDefect.ref_intLengthMode = intLengthMode;
                    objDefect.ref_fArea = intObjectArea;
                    objDefect.ref_fCenterX = objROI.ref_ROITotalX + fObjectCenterX;
                    objDefect.ref_fCenterY = objROI.ref_ROITotalY + fObjectCenterY;
                    objDefect.ref_fAngle = fObjectAngle;
                    objDefect.ref_intBlobNo = i;
                    objDefect.ref_intFailMask = 0;
                    objDefect.ref_strName = strDefectName;
                    objDefect.ref_intFailedImage = intSelectedImageIndex + 1;
                    m_arrDefectList.Add(objDefect);
                }
            }

            if (m_arrWantDefectArea[(int)eWantDefect.Dark])
            {
                if (intObjectTotalArea >= GetTotalAreaDefect("Dark"))
                {
                    m_strErrorMessage += "* Package Dark Field Total Area Fail. Set = " + (GetTotalAreaDefect("Dark") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectTotalArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                    m_blnCrackChipViewFailTotalArea = true;

                    Defect objDefect = new Defect();
                    objDefect.ref_fDimX = -1;
                    objDefect.ref_fDimY = -1;
                    objDefect.ref_intLengthMode = intLengthMode;
                    objDefect.ref_fArea = intObjectTotalArea;
                    objDefect.ref_fCenterX = objROI.ref_ROITotalX + m_objEBlobs.ref_arrRectLimitCenterX[0];
                    objDefect.ref_fCenterY = objROI.ref_ROITotalY + m_objEBlobs.ref_arrRectLimitCenterY[0];
                    objDefect.ref_fAngle = fObjectAngle; //m_objEBlobs.ref_arrRectAngle[0];
                    objDefect.ref_intFailMask |= 0x04;
                    objDefect.ref_strName = "Total Dark";
                    objDefect.ref_intFailedImage = intSelectedImageIndex + 1;
                    m_arrDefectList.Add(objDefect);

                    if (!blnOverAllFail)
                        blnOverAllFail = true;
                }
            }

            if (blnOverAllFail)
            {
                m_intPkgFailResultMask |= 0x200;
                return false;
            }
            else
                return true;
        }
        /// <summary>
        /// Check Mark View Image
        /// </summary>
        /// <param name="objROI"></param>
        public bool InspectMarkView(ROI objROI)
        {
            int intSelectedObjectNum = 0;
            if (m_intMarkViewHighThreshold == 255)
            {
                // Build using single threshold
                intSelectedObjectNum = m_objMarkViewEBlobs.BuildObjects_Filter_GetElement(
                objROI, false, m_intConnexity == 4, 0, m_intMarkViewLowThreshold,
                m_intMarkViewMinArea, objROI.ref_ROIWidth * objROI.ref_ROIHeight, false, 0x0D);
            }
            else
            {
                // Build using double threshold
                intSelectedObjectNum = m_objMarkViewEBlobs.BuildObjects_Filter_GetElement_DoubleThreshold(
                objROI, false, true, false, m_intConnexity == 4, m_intMarkViewLowThreshold, m_intMarkViewHighThreshold,
                m_intMarkViewMinArea, objROI.ref_ROIWidth * objROI.ref_ROIHeight, false, 0x0D);
            }

            if (intSelectedObjectNum == 0)
                return true;

            int intObjectTotalArea = 0;
            int intObjectArea = 0, j;
            float fObjectHeight = 0, fObjectWidth = 0, fObjectCenterX = 0, fObjectCenterY = 0;
            bool blnOverAllFail = false;
            for (int i = 0; i < intSelectedObjectNum; i++)
            {
                intObjectArea = m_objMarkViewEBlobs.ref_arrArea[i];
                fObjectHeight = m_objMarkViewEBlobs.ref_arrHeight[i];
                fObjectWidth = m_objMarkViewEBlobs.ref_arrWidth[i];
                fObjectCenterX = m_objMarkViewEBlobs.ref_arrLimitCenterX[i];
                fObjectCenterY = m_objMarkViewEBlobs.ref_arrLimitCenterY[i];
                intObjectTotalArea += intObjectArea;

                for (j = 0; j < m_arrDontCareArea.Count; j++)
                {
                    if ((objROI.ref_ROITotalX + fObjectCenterX > m_arrDontCareArea[j][0].X) && (objROI.ref_ROITotalY + fObjectCenterY > m_arrDontCareArea[j][0].Y) &&
                        (objROI.ref_ROITotalX + fObjectCenterX < m_arrDontCareArea[j][1].X) && (objROI.ref_ROITotalY + fObjectCenterY < m_arrDontCareArea[j][1].Y))
                    {
                        break;
                    }
                }
                if (j < m_arrDontCareArea.Count)
                {
                    continue;
                }

                bool blnFail = false;
                int intFailMask = 0;
                string strDefectName = "Scratches";
                if ((m_intPkgFailMask & 0x04) > 0)
                {
                    if (m_arrWantDefectLength[(int)eWantDefect.Scratches])
                    {
                        if (fObjectWidth >= GetDefect("Scratch", 0))
                        {
                            //m_strErrorMessage += "* Fail Mark View Package - Object " + (m_arrDefectList.Count + 1) + " is scratched. Set = " + (m_arrDefectHorizontal[2] / m_fMMToPixelXValue).ToString("f5") + " mm,   Result = " + (Math.Max(fObjectWidth, fObjectHeight) / m_fMMToPixelXValue).ToString("f5") + " mm";
                            m_strErrorMessage += "* Mark View Scratches Width Package Fail. Set = " + (GetDefect("Scratch", 0) / m_fMMToPixelXValue).ToString("f5") + " mm,   Result = " + (fObjectWidth / m_fMMToPixelXValue).ToString("f5") + " mm";
                            blnFail = true;
                            intFailMask |= 0x01;
                            strDefectName = "Scratches";
                        }

                        if (fObjectHeight >= GetDefect("Scratch", 1))
                        {
                            //m_strErrorMessage += "* Mark View Scratches Length Package Fail. Set = " + (m_arrDefectHorizontal[2] / m_fMMToPixelXValue).ToString("f5") + " mm,   Result = " + (Math.Max(fObjectWidth, fObjectHeight) / m_fMMToPixelXValue).ToString("f5") + " mm";
                            m_strErrorMessage += "* Mark View Scratches Height Package Fail. Set = " + (GetDefect("Scratch", 1) / m_fMMToPixelYValue).ToString("f5") + " mm,   Result = " + (fObjectHeight / m_fMMToPixelYValue).ToString("f5") + " mm";
                            blnFail = true;
                            intFailMask |= 0x02;
                            strDefectName = "Scratches";
                        }
                    }

                    if (m_arrWantDefectArea[(int)eWantDefect.Scratches])
                    {
                        if (intObjectArea >= GetAreaDefect("Scratch"))
                        {
                            //m_strErrorMessage += "* Fail Mark View Package - Object " + (m_arrDefectList.Count + 1) + " is scratched. Set = " + (m_arrDefectArea[2] / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                            m_strErrorMessage += "* Mark View Scratches Area Package Fail. Set = " + (GetAreaDefect("Scratch") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                            blnFail = true;
                            intFailMask |= 0x04;
                            strDefectName = "Scratches";
                        }
                    }
                }

                if (!blnFail)
                {
                    if ((m_intPkgFailMask & 0x10) > 0)
                    {
                        strDefectName = "Contamination";
                        if (m_arrWantDefectLength[(int)eWantDefect.Contamination])
                        {
                            if (fObjectWidth >= GetDefect("Contamination", 0))
                            {
                                //m_strErrorMessage += "* Fail Mark View Package - Object " + (m_arrDefectList.Count + 1) + " is contaminated. Set = " + (m_arrDefectHorizontal[4] / m_fMMToPixelXValue).ToString("f5") + " mm,   Result = " + (Math.Max(fObjectWidth, fObjectHeight) / m_fMMToPixelXValue).ToString("f5") + " mm";
                                m_strErrorMessage += "* Mark View Contamination Width Package Fail. Set = " + (GetDefect("Contamination", 0) / m_fMMToPixelXValue).ToString("f5") + " mm,   Result = " + (fObjectWidth / m_fMMToPixelXValue).ToString("f5") + " mm";
                                blnFail = true;
                                intFailMask |= 0x01;
                                strDefectName = "Contamination";
                            }

                            if (fObjectHeight >= GetDefect("Contamination", 1))
                            {
                                //m_strErrorMessage += "* Fail Mark View Package - Object " + (m_arrDefectList.Count + 1) + " is contaminated. Set = " + (m_arrDefectHorizontal[4] / m_fMMToPixelXValue).ToString("f5") + " mm,   Result = " + (Math.Max(fObjectWidth, fObjectHeight) / m_fMMToPixelXValue).ToString("f5") + " mm";
                                m_strErrorMessage += "* Mark View Contamination Height Package Fail. Set = " + (GetDefect("Contamination", 1) / m_fMMToPixelYValue).ToString("f5") + " mm,   Result = " + (fObjectHeight / m_fMMToPixelYValue).ToString("f5") + " mm";
                                blnFail = true;
                                intFailMask |= 0x02;
                                strDefectName = "Contamination";
                            }
                        }

                        if (m_arrWantDefectArea[(int)eWantDefect.Contamination])
                        {
                            if (intObjectArea >= GetAreaDefect("Contamination"))
                            {
                                //m_strErrorMessage += "* Fail Mark View Package - Object " + (m_arrDefectList.Count + 1) + " is contaminated. Set = " + (m_arrDefectArea[4] / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                                m_strErrorMessage += "* Mark View Contamination Area Package Fail. Set = " + (GetAreaDefect("Contamination") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                                blnFail = true;
                                intFailMask |= 0x04;
                                strDefectName = "Contamination";
                            }
                        }
                    }
                }

                //if (((fObjectWidth >= fScratchMinLenght) || (fObjectHeight >= fScratchMinLenght)) &&
                //    ((fObjectWidth >= fContaMinLength) || (fObjectHeight >= fContaMinLength)))
                //{
                //    if (((float)intObjectArea / (fObjectWidth * fObjectHeight)) > 0.5)
                //    {
                //        if ((m_intPkgFailMask & 0x10) > 0)
                //        {
                //            m_strErrorMessage += "* Fail Mark View Package - Object " + (m_arrDefectList.Count + 1) + " is contaminated";
                //            blnFail = true;
                //        }
                //    }
                //    else
                //    {
                //        if ((m_intPkgFailMask & 0x04) > 0)
                //        {
                //            m_strErrorMessage += "* Fail Mark View Package - Object " + (m_arrDefectList.Count + 1) + " is scratched";
                //            blnFail = true;
                //        }
                //    }
                //}
                //else if ((fObjectWidth >= fScratchMinLenght) || (fObjectHeight >= fScratchMinLenght))
                //{
                //    if ((m_intPkgFailMask & 0x04) > 0)
                //    {
                //        m_strErrorMessage += "* Fail Mark View Package - Object " + (m_arrDefectList.Count + 1) + " is scratched";
                //        blnFail = true;
                //    }
                //}
                //else if ((fObjectWidth >= fContaMinLength) || (fObjectHeight >= fContaMinLength))
                //{
                //    if ((m_intPkgFailMask & 0x10) > 0)
                //    {
                //        m_strErrorMessage += "* Fail Mark View Package - Object " + (m_arrDefectList.Count + 1) + " is contaminated";
                //        blnFail = true;
                //    }
                //}

                if (blnFail)
                {
                    Defect objDefect = new Defect();
                    objDefect.ref_fDimX = fObjectWidth;
                    objDefect.ref_fDimY = fObjectHeight;
                    objDefect.ref_intLengthMode = 0;
                    objDefect.ref_fArea = intObjectArea;
                    objDefect.ref_fCenterX = objROI.ref_ROITotalX + fObjectCenterX;
                    objDefect.ref_fCenterY = objROI.ref_ROITotalY + fObjectCenterY;
                    objDefect.ref_intBlobNo = i;
                    objDefect.ref_intFailMask = intFailMask;
                    objDefect.ref_strName = strDefectName;
                    objDefect.ref_intFailedImage = 1;
                    m_arrDefectList.Add(objDefect);
                    if(strDefectName == "Scratches")
                        m_intPkgFailResultMask |= 0x04;
                    else
                        m_intPkgFailResultMask |= 0x10;
                    if (!blnOverAllFail)
                        blnOverAllFail = true;
                }
                else
                {
                    Defect objDefect = new Defect();
                    objDefect.ref_fDimX = fObjectWidth;
                    objDefect.ref_fDimY = fObjectHeight;
                    objDefect.ref_intLengthMode = 0;
                    objDefect.ref_fArea = intObjectArea;
                    objDefect.ref_fCenterX = objROI.ref_ROITotalX + fObjectCenterX;
                    objDefect.ref_fCenterY = objROI.ref_ROITotalY + fObjectCenterY;
                    objDefect.ref_intBlobNo = i;
                    objDefect.ref_intFailMask = 0;
                    objDefect.ref_strName = strDefectName;
                    objDefect.ref_intFailedImage = 1;
                    m_arrDefectList.Add(objDefect);
                }
            }

            if (m_arrWantDefectArea[(int)eWantDefect.Scratches])
            {
                if (intObjectTotalArea >= GetTotalAreaDefect("Scratch"))
                {
                    m_strErrorMessage += "* Scratch Total Area Package Fail. Set = " + (GetTotalAreaDefect("Scratch") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectTotalArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                    m_blnMarkViewFailTotalArea = true;

                    Defect objDefect = new Defect();
                    objDefect.ref_fDimX = m_objMarkViewEBlobs.ref_arrWidth[0];
                    objDefect.ref_fDimY = m_objMarkViewEBlobs.ref_arrHeight[0];
                    objDefect.ref_intLengthMode = 0;
                    objDefect.ref_fArea = m_objMarkViewEBlobs.ref_arrArea[0];
                    objDefect.ref_fCenterX = objROI.ref_ROITotalX + m_objMarkViewEBlobs.ref_arrLimitCenterX[0];
                    objDefect.ref_fCenterY = objROI.ref_ROITotalY + m_objMarkViewEBlobs.ref_arrLimitCenterY[0];
                    objDefect.ref_intFailMask |= 0x04;
                    objDefect.ref_strName = "Scratches";
                    objDefect.ref_intFailedImage = 1;
                    m_arrDefectList.Add(objDefect);
                    m_intPkgFailResultMask |= 0x04;
                    if (!blnOverAllFail)
                        blnOverAllFail = true;
                }
            }


            if (m_arrWantDefectArea[(int)eWantDefect.Contamination])
            {
                if (intObjectTotalArea >= GetTotalAreaDefect("Contamination"))
                {
                    m_strErrorMessage += "* Contamination Total Area Package Fail. Set = " + (GetTotalAreaDefect("Contamination") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectTotalArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                    m_blnMarkViewFailTotalArea = true;

                    Defect objDefect = new Defect();
                    objDefect.ref_fDimX = m_objMarkViewEBlobs.ref_arrWidth[0];
                    objDefect.ref_fDimY = m_objMarkViewEBlobs.ref_arrHeight[0];
                    objDefect.ref_intLengthMode = 0;
                    objDefect.ref_fArea = m_objMarkViewEBlobs.ref_arrArea[0];
                    objDefect.ref_fCenterX = objROI.ref_ROITotalX + m_objMarkViewEBlobs.ref_arrLimitCenterX[0];
                    objDefect.ref_fCenterY = objROI.ref_ROITotalY + m_objMarkViewEBlobs.ref_arrLimitCenterY[0];
                    objDefect.ref_intFailMask |= 0x04;
                    objDefect.ref_strName = "Contamination";
                    objDefect.ref_intFailedImage = 1;
                    m_arrDefectList.Add(objDefect);
                    m_intPkgFailResultMask |= 0x10;
                    if (!blnOverAllFail)
                        blnOverAllFail = true;
                }
            }

            if (blnOverAllFail)
                return false;
            else
                return true;
        }
        
        public void SetBlobSettings(int intPkgThreshold, int intPkgMinArea, int intMarkHighThreshold,
                                             int intMarkLowThreshold, int intMarkMinArea)
        {
            m_objPackageEBlobs.ref_intAbsoluteThreshold = m_intPkgViewThreshold = intPkgThreshold;
            m_objPackageEBlobs.ref_intClassSelection = 0x01;
            m_objPackageEBlobs.ref_intConnexity = m_intConnexity;
            m_objPackageEBlobs.ref_intMinAreaLimit = intPkgMinArea;
            m_objPackageEBlobs.ref_intMaxAreaLimit = 15000;
            m_objPackageEBlobs.ref_intCriteria = m_intFeature;  // area and object center

            m_objMarkViewEBlobs.ref_intAbsoluteLowThreshold = m_intMarkViewLowThreshold = intMarkLowThreshold;
            m_objMarkViewEBlobs.ref_intAbsoluteHighThreshold = m_intMarkViewHighThreshold = intMarkHighThreshold;
            m_objMarkViewEBlobs.ref_intClassSelection = 0x06;
            m_objMarkViewEBlobs.ref_intConnexity = m_intConnexity;
            m_objMarkViewEBlobs.ref_intMinAreaLimit = intPkgMinArea;
            m_objMarkViewEBlobs.ref_intMaxAreaLimit = 15000;
            m_objMarkViewEBlobs.ref_intCriteria = m_intFeature;  // area and object center

            m_intMarkViewMinArea = intMarkMinArea;
            m_intPkgViewMinArea = intPkgMinArea;

        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="intValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        /// <returns></returns>
        public float GetUnitWidthMin(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_fUnitWidthMin * m_fMMToPixelXValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fUnitWidthMin * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="fValue"></param>
        /// <param name="intFromValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        public void SetUnitWidthMin(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                case 0: // Pixel
                    m_fUnitWidthMin = fValue / m_fMMToPixelXValue;
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fUnitWidthMin = fValue / m_fMMToUnitValue;
                    break;
            }
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="intValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        /// <returns></returns>
        public float GetUnitWidthMax(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_fUnitWidthMax * m_fMMToPixelXValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fUnitWidthMax * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="fValue"></param>
        /// <param name="intFromValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        public void SetUnitWidthMax(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                case 0: // Pixel
                    m_fUnitWidthMax = fValue / m_fMMToPixelXValue;
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fUnitWidthMax = fValue / m_fMMToUnitValue;
                    break;
            }
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="intValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        /// <returns></returns>
        public float GetUnitHeightMin(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_fUnitHeightMin * m_fMMToPixelYValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fUnitHeightMin * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="fValue"></param>
        /// <param name="intFromValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        public void SetUnitHeightMin(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                case 0: // Pixel
                    m_fUnitHeightMin = fValue / m_fMMToPixelYValue;
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fUnitHeightMin = fValue / m_fMMToUnitValue;
                    break;
            }
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="intValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        /// <returns></returns>
        public float GetUnitHeightMax(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_fUnitHeightMax * m_fMMToPixelYValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fUnitHeightMax * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="fValue"></param>
        /// <param name="intFromValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        public void SetUnitHeightMax(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                case 0: // Pixel
                    m_fUnitHeightMax = fValue / m_fMMToPixelYValue;
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fUnitHeightMax = fValue / m_fMMToUnitValue;
                    break;
            }
        }

        /// <summary>
        /// Set the minimum length of pointed defect type
        /// </summary>
        /// <param name="intDefectNo">defect no :  0=crack, 1 = chip, 2=scratch, 3 = mold, 4=contamination</param>
        /// <param name="fDiameter">minimum of defect length</param>
        /// <param name="intType">0=Horizontal, 1=Vertical</param>
        public bool SetDefectParam(int intDefectNo, float fDiameter, int intType)
        {
            if (intDefectNo == (int)Package.eDefect.ChipBright || intDefectNo == (int)Package.eDefect.ChipDark)
            {
                // For chipped off setting, only length will be limited. Length == deep defect from border to center.
                if (intType == 1)
                {
                    // for chip defect cannot set defect size larger than or equal to half of the template unit min width or height
                    if (fDiameter >= (m_fUnitWidthMin * m_fMMToPixelXValue / 3) || fDiameter >= (m_fUnitHeightMin * m_fMMToPixelYValue / 3))
                        return false;
                }
            }
            else
            {
                // prevent set defect size larger than template unit min size
                if (intType == 0 && fDiameter > m_fUnitWidthMin * m_fMMToPixelXValue || intType == 1 && fDiameter > m_fUnitHeightMin * m_fMMToPixelYValue)
                    return false;
            }

            if (intType == 0)
                m_arrDefectHorizontal[intDefectNo] = fDiameter;
            else
                m_arrDefectVertical[intDefectNo] = fDiameter;
            return true;
        }

        /// <summary>
        /// Set the minimum area of pointed defect type
        /// </summary>
        /// <param name="intDefectNo">defect no :  0=crack, 1 = chip, 2=scratch, 3 = mold, 4=contamination</param>
        /// <param name="fArea">minimum of defect area</param>
        public bool SetDefectAreaParam(int intDefectNo, float fArea)
        {
            // prevent set defect area larger than unit min area
            if (fArea > m_fUnitWidthMin * m_fUnitHeightMin * m_fMMtoPixelAreaValue)
                return false;

            m_arrDefectArea[intDefectNo] = fArea;
            return true;
        }

        /// <summary>
        /// Set the minimum area of pointed defect type
        /// </summary>
        /// <param name="intDefectNo">defect no :  0=crack, 1 = chip, 2=scratch, 3 = mold, 4=contamination</param>
        /// <param name="fArea">minimum of defect area</param>
        public bool SetDefectTotalAreaParam(int intDefectNo, float fArea)
        {
            // prevent set defect area larger than unit min area
            if (fArea > m_fUnitWidthMin * m_fUnitHeightMin * m_fMMtoPixelAreaValue)
                return false;

            m_arrDefectTotalArea[intDefectNo] = fArea;
            return true;
        }

        public void SetWantDefectParam(int intDefectNo, bool bWantDefect)
        {
            m_arrWantDefectLength[intDefectNo] = bWantDefect;
        }

        public void SetWantDefectAreaParam(int intDefectNo, bool bWantDefect)
        {
            m_arrWantDefectArea[intDefectNo] = bWantDefect;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="intValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        /// <returns></returns>
        public float GetResultWidth(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_fUnitResultWidth * m_fMMToPixelXValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fUnitResultWidth * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="intValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        /// <returns></returns>
        public float GetResultHeight(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_fUnitResultHeight * m_fMMToPixelYValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fUnitResultHeight * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }

        public void SetDontCareArea(float fStartX, float fStartY, float fEndX, float fEndY)
        {
            m_arrDontCareArea.Add(new List<PointF>());
            int intIndex = m_arrDontCareArea.Count - 1;
            m_arrDontCareArea[intIndex].Add(new PointF(fStartX, fStartY));
            m_arrDontCareArea[intIndex].Add(new PointF(fEndX, fEndY));
        }

        /// <summary>
        /// Set grab image index
        /// </summary>
        /// <param name="intArrayIndex">Index which represent different defect inspection. 0: Package Size, 1: Pkg Defect Under Mark View, 2: Pkg Defect Under Side Light Image View, 3: Pkg Defect Under Direct Light Image View </param>
        /// <param name="intGrabImageIndex">Select which image view no use to inspection</param>
        public void SetGrabImageIndex(int intArrayIndex, int intGrabImageIndex)
        {
            if (intArrayIndex >= m_arrGrabImageIndex.Count)
            {
                for (int i = m_arrGrabImageIndex.Count - 1; i <= intArrayIndex; i++)
                {
                    m_arrGrabImageIndex.Add(0);
                }
            }

            m_arrGrabImageIndex[intArrayIndex] = intGrabImageIndex;
        }

        public void SetMarkMaskBlob(int intGroup, int intTemplateNo, float fCenterX, float fCenterY, float fWidth, float fHeight,
                                               int intXDistance, int intYDistance)
        {
            // ------------------- checking loop timeout ---------------------------------------------------
            HiPerfTimer timeout = new HiPerfTimer();
            timeout.Start();

            while (m_arrMarkMaskROI.Count < (intGroup + 1))
            {
                // ------------------- checking loop timeout ---------------------------------------------------
                if (timeout.Timing > 10000)
                {
                    STTrackLog.WriteLine(">>>>>>>>>>>>> time out 601");
                    break;
                }

                m_arrMarkMaskROI.Add(new List<List<ROI>>());
            }
            timeout.Stop(); // ------------------- checking loop timeout ---------------------------------------------------

            // ------------------- checking loop timeout ---------------------------------------------------
            timeout.Start();

            while (m_arrMarkMaskROI[intGroup].Count < (intTemplateNo + 1))
            {
                // ------------------- checking loop timeout ---------------------------------------------------
                if (timeout.Timing > 10000)
                {
                    STTrackLog.WriteLine(">>>>>>>>>>>>> time out 600");
                    break;
                }

                m_arrMarkMaskROI[intGroup].Add(new List<ROI>());
            }

            timeout.Stop(); // ------------------- checking loop timeout ---------------------------------------------------

            int intPositionX = Convert.ToInt32(Math.Floor(fCenterX - (fWidth / 2))) + intXDistance;
            int intPositionY = Convert.ToInt32(Math.Floor(fCenterY - (fHeight / 2))) + intYDistance;
            ROI objROI = new ROI();
            objROI.LoadROISetting(intPositionX, intPositionY, Convert.ToInt32(Math.Ceiling(fWidth)), Convert.ToInt32(Math.Ceiling(fHeight)));
            m_arrMarkMaskROI[intGroup][intTemplateNo].Add(objROI);
        }


        private bool InspectChipPackage_Area(float fCenterX, float fCenterY, float fWidth, float fHeight, ImageDrawing objImage, int intThreshold,
                          int intTotalROIStartX, int intTotalROIStartY, int intChipLineLimitPixelValue, int intChipViewMinAreaSetting)
        {
            if (objImage.ref_intImageHeight == 0 || objImage.ref_intImageWidth == 0)
                return true;

            if ((m_intPkgFailMask & 0x02) == 0)
                return true;

            bool blnDebug = false;
            int intSelectedImageIndex;

            int intChipType = (int)eWantDefect.ChipBright;
            if (intChipLineLimitPixelValue == 255)
            {
                intChipType = (int)eWantDefect.ChipDark;
            }

            int intCeilChipLengthTop = 0; // (int)Math.Ceiling(m_arrDefectHorizontal[1]);
            int intCeilChipLengthRight = 0;  //(int)Math.Ceiling(m_arrDefectHorizontal[1]);
            int intCeilChipLengthBottom = 0; //(int)Math.Ceiling(m_arrDefectHorizontal[1]);
            int intCeilChipLengthLeft = 0;  //(int)Math.Ceiling(m_arrDefectHorizontal[1]);

            if (intChipLineLimitPixelValue == 0)    // White field defect (Scratches, contamination, chip)
            {
                intCeilChipLengthTop = m_intStartPixelFromEdge_Chip - m_intStartPixelExtendFromEdge_Chip;
                intCeilChipLengthRight = m_intStartPixelFromRight_Chip - m_intStartPixelExtendFromRight_Chip;
                intCeilChipLengthBottom = m_intStartPixelFromBottom_Chip - m_intStartPixelExtendFromBottom_Chip;
                intCeilChipLengthLeft = m_intStartPixelFromLeft_Chip - m_intStartPixelExtendFromLeft_Chip;

                intSelectedImageIndex = m_arrGrabImageIndex[2];
            }
            else // Black field defect (Crack, void, chip)
            {
                intCeilChipLengthTop = m_intStartPixelFromEdge_Chip_Dark - m_intStartPixelExtendFromEdge_Chip_Dark;
                intCeilChipLengthRight = m_intStartPixelFromRight_Chip_Dark - m_intStartPixelExtendFromRight_Chip_Dark;
                intCeilChipLengthBottom = m_intStartPixelFromBottom_Chip_Dark - m_intStartPixelExtendFromBottom_Chip_Dark;
                intCeilChipLengthLeft = m_intStartPixelFromLeft_Chip_Dark - m_intStartPixelExtendFromLeft_Chip_Dark;

                intSelectedImageIndex = m_arrGrabImageIndex[3];
            }

            if (blnDebug)
                objImage.SaveImage("D:\\TS\\1.ChippedOffImage.bmp");
            // if (intCeilChipLength != 0)
            FillChipLineLimitToCorner_Area(objImage, intCeilChipLengthTop, intCeilChipLengthRight, intCeilChipLengthBottom, intCeilChipLengthLeft, intChipLineLimitPixelValue);
            if (blnDebug)
                objImage.SaveImage("D:\\TS\\2.ChippedOffImageFillChipLineLimitToCorner.bmp");

            ROI objBlobsROI = new ROI();
            objBlobsROI.AttachImage(objImage);
            objBlobsROI.LoadROISetting(0, 0, objImage.ref_intImageWidth, objImage.ref_intImageHeight);
            if (blnDebug)
                objBlobsROI.SaveImage("D:\\TS\\3.objBlobsROI.bmp");
            int intMinValue;
            if (intChipViewMinAreaSetting == 0)
                intMinValue = m_intChipView1MinArea;
            else
                intMinValue = m_intChipView2MinArea;

            bool bWhiteOnBlack;
            if (intChipLineLimitPixelValue == 0)
                bWhiteOnBlack = true;    // detect white on black - white is the chip
            else
                bWhiteOnBlack = false;   // detect black on white - black is the chip

            int intSelectedObject = m_objEBlobs.BuildObjects_Filter_GetElement(objBlobsROI, !bWhiteOnBlack, true, 0, intThreshold,
                intMinValue, objBlobsROI.ref_ROIWidth * objBlobsROI.ref_ROIHeight, false, 0x0D);

            bool blnOverAllFail = false;
            if (intSelectedObject > 0)
            {
                int intObjectArea = 0;
                float fObjectHeight = 0, fObjectWidth = 0, fObjectCenterX = 0, fObjectCenterY = 0;
                float fStartX, fStartY, fEndX, fEndY;
                float fOuterStartX = 1;
                float fOuterStartY = 1;
                float fOuterEndX = objBlobsROI.ref_ROIWidth;
                float fOuterEndY = objBlobsROI.ref_ROIHeight;
                float fInterStartX = intCeilChipLengthLeft;// m_intStartPixelFromLeft_Chip; // m_arrDefectHorizontal[1];
                float fInterStartY = intCeilChipLengthTop;//m_intStartPixelFromEdge_Chip; // m_arrDefectHorizontal[1];
                float fInterEndX = (float)objBlobsROI.ref_ROIWidth - intCeilChipLengthRight; //- m_arrDefectHorizontal[1] - 1;
                float fInterEndY = (float)objBlobsROI.ref_ROIHeight - intCeilChipLengthBottom;  //- m_arrDefectHorizontal[1] - 1;
                int intChipLengthTop = intCeilChipLengthTop;// m_intStartPixelFromEdge_Chip;
                int intChipLengthRight = intCeilChipLengthRight;// m_intStartPixelFromRight_Chip;
                int intChipLengthBottom = intCeilChipLengthBottom;// m_intStartPixelFromBottom_Chip;
                int intChipLengthLeft = intCeilChipLengthLeft;// m_intStartPixelFromLeft_Chip;
                if (intChipLineLimitPixelValue == 0)    // White field defect (Scratches, contamination, chip)
                {
                    intChipLengthTop -= m_intStartPixelExtendFromEdge_Chip;
                    intChipLengthRight -= m_intStartPixelExtendFromRight_Chip;
                    intChipLengthBottom -= m_intStartPixelExtendFromBottom_Chip;
                    intChipLengthLeft -= m_intStartPixelExtendFromLeft_Chip;

                    intCeilChipLengthTop -= m_intStartPixelExtendFromEdge_Chip;
                    intCeilChipLengthRight -= m_intStartPixelExtendFromRight_Chip;
                    intCeilChipLengthBottom -= m_intStartPixelExtendFromBottom_Chip;
                    intCeilChipLengthLeft -= m_intStartPixelExtendFromLeft_Chip;
                }
                else // Black field defect (Crack, void, chip)
                {
                    intChipLengthTop -= m_intStartPixelExtendFromEdge_Chip_Dark;
                    intChipLengthRight -= m_intStartPixelExtendFromRight_Chip_Dark;
                    intChipLengthBottom -= m_intStartPixelExtendFromBottom_Chip_Dark;
                    intChipLengthLeft -= m_intStartPixelExtendFromLeft_Chip_Dark;

                    intCeilChipLengthTop -= m_intStartPixelExtendFromEdge_Chip_Dark;
                    intCeilChipLengthRight -= m_intStartPixelExtendFromRight_Chip_Dark;
                    intCeilChipLengthBottom -= m_intStartPixelExtendFromBottom_Chip_Dark;
                    intCeilChipLengthLeft -= m_intStartPixelExtendFromLeft_Chip_Dark;
                }
                int intFailMask = 0;

                for (int i = 0; i < intSelectedObject; i++)
                {
                    intObjectArea = m_objEBlobs.ref_arrArea[i];
                    fObjectHeight = m_objEBlobs.ref_arrHeight[i];
                    fObjectWidth = m_objEBlobs.ref_arrWidth[i];
                    fObjectCenterX = m_objEBlobs.ref_arrLimitCenterX[i];
                    fObjectCenterY = m_objEBlobs.ref_arrLimitCenterY[i];
                    intFailMask = 0;

                    if (true)
                    {
                        fStartX = fObjectCenterX - (fObjectWidth / 2);
                        fStartY = fObjectCenterY - (fObjectHeight / 2);
                        fEndX = fObjectCenterX + (fObjectWidth / 2);
                        fEndY = fObjectCenterY + (fObjectHeight / 2);

                        float fToleranceLeft = intChipLengthLeft / 2;
                        float fToleranceTop = intChipLengthTop / 2;
                        float fToleranceRight = intChipLengthRight / 2;
                        float fToleranceBottom = intChipLengthBottom / 2;
                        bool blnDefect = false;
                        bool blnTopChipped = false;
                        bool blnBottomChipped = false;
                        bool blnLeftChipped = false;
                        bool blnRightChipped = false;

                        float fAddX = 0;
                        float fAddY = 0;

                        /*
                         * If Chipped off Length Checked but Chipped Off area unchecked, then chipped off happen as long as defect touch the setting tolerance line.
                         * If Chipped off length and area both Checked, then chipped off will only happen when defect touch the setting tolerance line and with min defect area.
                         */

                        //if (m_arrWantDefectArea[(int)eWantDefect.Chip])   // Want check defect Chipped Off Area 
                        {
                            if (fStartX < fInterStartX) // Possible Left Chipped
                            {
                                if (fStartY < fInterStartY) // Possible Top Chipped
                                {
                                    if (fStartX < fStartY)  // Confirm Left Chipped
                                    {
                                        blnDefect = true;
                                        blnLeftChipped = true;
                                        //CheckIsAreaMoreThanChipToleranceSetting(intObjectArea, ref intFailMask, ref blnDefect, ref blnLeftChipped, intSelectedImageIndex);
                                    }
                                    else // Confirm Top Chipped
                                    {
                                        blnDefect = true;
                                        blnTopChipped = true;
                                        //CheckIsAreaMoreThanChipToleranceSetting(intObjectArea, ref intFailMask, ref blnDefect, ref blnTopChipped, intSelectedImageIndex);
                                    }
                                }
                                else if (fEndY > fInterEndY)    // Possible Bottom Chipped
                                {
                                    if (fStartX < (objBlobsROI.ref_ROIHeight - fEndY)) // Confirm Left Chipped
                                    {
                                        blnDefect = true;
                                        blnLeftChipped = true;
                                        //CheckIsAreaMoreThanChipToleranceSetting(intObjectArea, ref intFailMask, ref blnDefect, ref blnLeftChipped, intSelectedImageIndex);
                                    }
                                    else // Confirm BOttom Chipped
                                    {
                                        blnDefect = true;
                                        blnBottomChipped = true;
                                        //CheckIsAreaMoreThanChipToleranceSetting(intObjectArea, ref intFailMask, ref blnDefect, ref blnBottomChipped, intSelectedImageIndex);
                                    }
                                }
                                else // Confirm Left Chipped 
                                {
                                    blnDefect = true;
                                    blnLeftChipped = true;
                                    //CheckIsAreaMoreThanChipToleranceSetting(intObjectArea, ref intFailMask, ref blnDefect, ref blnLeftChipped, intSelectedImageIndex);
                                }
                            }

                            if (!blnDefect && fEndX > fInterEndX) // Possible Right Chipped
                            {
                                if (fStartY < fInterStartY) // Possible Top Chipped
                                {
                                    if (fStartY < (objBlobsROI.ref_ROIWidth - fEndX))  // Confirm Top Chipped
                                    {
                                        blnDefect = true;
                                        blnTopChipped = true;
                                        //CheckIsAreaMoreThanChipToleranceSetting(intObjectArea, ref intFailMask, ref blnDefect, ref blnTopChipped, intSelectedImageIndex);
                                    }
                                    else // Confirm Right Chipped
                                    {
                                        blnDefect = true;
                                        blnRightChipped = true;
                                        //CheckIsAreaMoreThanChipToleranceSetting(intObjectArea, ref intFailMask, ref blnDefect, ref blnRightChipped, intSelectedImageIndex);
                                    }
                                }
                                else if (fEndY > fInterEndY)    // Possible Bottom Chipped
                                {
                                    if ((objBlobsROI.ref_ROIWidth - fEndX) < (objBlobsROI.ref_ROIHeight - fEndY)) // Confirm Right Chipped
                                    {
                                        blnDefect = true;
                                        blnRightChipped = true;
                                        //CheckIsAreaMoreThanChipToleranceSetting(intObjectArea, ref intFailMask, ref blnDefect, ref blnRightChipped, intSelectedImageIndex);
                                    }
                                    else // Confirm BOttom Chipped
                                    {
                                        blnDefect = true;
                                        blnBottomChipped = true;
                                        //CheckIsAreaMoreThanChipToleranceSetting(intObjectArea, ref intFailMask, ref blnDefect, ref blnBottomChipped, intSelectedImageIndex);
                                    }
                                }
                                else // Confirm Right Chipped
                                {
                                    blnDefect = true;
                                    blnRightChipped = true;
                                    //CheckIsAreaMoreThanChipToleranceSetting(intObjectArea, ref intFailMask, ref blnDefect, ref blnRightChipped, intSelectedImageIndex);
                                }
                            }

                            if (!blnDefect && fStartY < fInterStartY) // Possible Top chipped
                            {
                                if (fStartX < fInterStartX) // Possible Left Chipped
                                {
                                    if (fStartX < fStartY)  // Confirm Left Chipped
                                    {
                                        blnDefect = true;
                                        blnLeftChipped = true;
                                        //CheckIsAreaMoreThanChipToleranceSetting(intObjectArea, ref intFailMask, ref blnDefect, ref blnLeftChipped, intSelectedImageIndex);
                                    }
                                    else // Confirm Top Chipped
                                    {
                                        blnDefect = true;
                                        blnTopChipped = true;
                                        //CheckIsAreaMoreThanChipToleranceSetting(intObjectArea, ref intFailMask, ref blnDefect, ref blnTopChipped, intSelectedImageIndex);
                                    }
                                }
                                else if (fEndX > fInterEndX)    // Possible Right Chipped
                                {
                                    if (fStartY < (objBlobsROI.ref_ROIWidth - fEndX)) // Confirm Top Chipped
                                    {
                                        blnDefect = true;
                                        blnTopChipped = true;
                                        //CheckIsAreaMoreThanChipToleranceSetting(intObjectArea, ref intFailMask, ref blnDefect, ref blnTopChipped, intSelectedImageIndex);
                                    }
                                    else // Confirm Right Chipped
                                    {
                                        blnDefect = true;
                                        blnRightChipped = true;
                                        //CheckIsAreaMoreThanChipToleranceSetting(intObjectArea, ref intFailMask, ref blnDefect, ref blnRightChipped, intSelectedImageIndex);
                                    }
                                }
                                else // Confirm Top Chipped
                                {
                                    blnDefect = true;
                                    blnTopChipped = true;
                                    //CheckIsAreaMoreThanChipToleranceSetting(intObjectArea, ref intFailMask, ref blnDefect, ref blnTopChipped, intSelectedImageIndex);
                                }
                            }

                            if (!blnDefect && fEndY > fInterEndY) // Possible Bottom Chipped
                            {
                                if (fStartX < fInterStartX) // Possible Left Chipped
                                {
                                    if (fStartX < (objBlobsROI.ref_ROIHeight - fEndY))  // Confirm Left Chipped
                                    {
                                        blnDefect = true;
                                        blnLeftChipped = true;
                                        //CheckIsAreaMoreThanChipToleranceSetting(intObjectArea, ref intFailMask, ref blnDefect, ref blnLeftChipped, intSelectedImageIndex);
                                    }
                                    else // Confirm Bottom Chipped
                                    {
                                        blnDefect = true;
                                        blnBottomChipped = true;
                                        //CheckIsAreaMoreThanChipToleranceSetting(intObjectArea, ref intFailMask, ref blnDefect, ref blnBottomChipped, intSelectedImageIndex);
                                    }
                                }
                                else if (fEndX > fInterEndX)    // Possible Right Chipped
                                {
                                    if ((objBlobsROI.ref_ROIWidth - fEndX) < (objBlobsROI.ref_ROIHeight - fEndY)) // Confirm Right Chipped
                                    {
                                        blnDefect = true;
                                        blnRightChipped = true;
                                        //CheckIsAreaMoreThanChipToleranceSetting(intObjectArea, ref intFailMask, ref blnDefect, ref blnRightChipped, intSelectedImageIndex);
                                    }
                                    else // Confirm BOttom Chipped
                                    {
                                        blnDefect = true;
                                        blnBottomChipped = true;
                                        //CheckIsAreaMoreThanChipToleranceSetting(intObjectArea, ref intFailMask, ref blnDefect, ref blnBottomChipped, intSelectedImageIndex);
                                    }
                                }
                                else // Confirm Bottom Chipped
                                {
                                    blnDefect = true;
                                    blnBottomChipped = true;
                                    //CheckIsAreaMoreThanChipToleranceSetting(intObjectArea, ref intFailMask, ref blnDefect, ref blnBottomChipped, intSelectedImageIndex);
                                }
                            }
                        }

                        //if (m_arrWantDefectArea[(int)eWantDefect.Chip])   // Want check defect Chipped Off Area 
                        //{
                        //    if (fStartX < fInterStartX) // Possible Left Chipped
                        //    {
                        //        if (fStartY < fInterStartY) // Possible Top Chipped
                        //        {
                        //            if (fStartX < fStartY)  // Confirm Left Chipped
                        //            {
                        //                if (fObjectWidth >= intChipLengthLeft)  // Is Chipped over setting min value
                        //                {
                        //                    if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                    {
                        //                        if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                        {
                        //                            intFailMask |= 0x04;
                        //                            blnDefect = true;
                        //                            blnLeftChipped = true;

                        //                            m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                        }
                        //                        else
                        //                        {
                        //                            intFailMask |= 0;
                        //                            blnDefect = true;
                        //                            blnLeftChipped = true;
                        //                        }
                        //                    }
                        //                }
                        //                else if ((fObjectCenterX - fObjectWidth / 2) > 0)
                        //                {
                        //                    //if (fObjectWidth == intCeilChipLengthLeft - fToleranceLeft)    // Is Chipped same length with chip setting + tolerance
                        //                    if (fObjectWidth >= intCeilChipLengthLeft - fToleranceLeft)    // Is Chipped over chip setting - tolerance
                        //                    {
                        //                        //if ((fToleranceLeft - (fObjectCenterX + fObjectWidth / 2)) <= fToleranceLeft) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        if ((fToleranceLeft - (fObjectCenterX + fObjectWidth / 2)) <= 1) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        {
                        //                            if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                            {
                        //                                if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                                {
                        //                                    intFailMask |= 0x04;
                        //                                    blnDefect = true;
                        //                                    blnLeftChipped = true;
                        //                                    fAddX = fObjectCenterX - fObjectWidth / 2;

                        //                                    m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                                }
                        //                                else
                        //                                {
                        //                                    intFailMask |= 0;
                        //                                    blnDefect = true;
                        //                                    blnLeftChipped = true;
                        //                                    fAddX = fObjectCenterX - fObjectWidth / 2;
                        //                                }

                        //                            }
                        //                        }
                        //                    }
                        //                }
                        //            }
                        //            else // Confirm Top Chipped
                        //            {
                        //                if (fObjectHeight >= intChipLengthTop) // Is Chipped over setting min value
                        //                {
                        //                    if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                    {
                        //                        if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                        {
                        //                            intFailMask |= 0x04;
                        //                            blnDefect = true;
                        //                            blnTopChipped = true;

                        //                            m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                        }
                        //                        else
                        //                        {
                        //                            intFailMask |= 0;
                        //                            blnDefect = true;
                        //                            blnTopChipped = true;
                        //                        }
                        //                    }
                        //                }
                        //                else if ((fObjectCenterY - fObjectHeight / 2) > 0)
                        //                {
                        //                    //if (fObjectHeight == intCeilChipLengthTop - fToleranceTop) // Is Chipped same length with chip setting + tolerance
                        //                    if (fObjectHeight >= intCeilChipLengthTop - fToleranceTop) // Is Chipped over chip setting - tolerance
                        //                    {
                        //                        //if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= fToleranceTop)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= 1)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        {
                        //                            if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                            {
                        //                                if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                                {
                        //                                    intFailMask |= 0x04;
                        //                                    blnDefect = true;
                        //                                    blnTopChipped = true;
                        //                                    fAddY = fObjectCenterY - fObjectHeight / 2;

                        //                                    m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                                }
                        //                                else
                        //                                {
                        //                                    intFailMask |= 0;
                        //                                    blnDefect = true;
                        //                                    blnTopChipped = true;
                        //                                    fAddY = fObjectCenterY - fObjectHeight / 2;
                        //                                }
                        //                            }
                        //                        }
                        //                    }
                        //                }

                        //            }
                        //        }
                        //        else if (fEndY > fInterEndY)    // Possible Bottom Chipped
                        //        {
                        //            if (fStartX < (objBlobsROI.ref_ROIHeight - fEndY)) // Confirm Left Chipped
                        //            {
                        //                if (fObjectWidth >= intChipLengthLeft)  // Is Chipped over setting min value
                        //                {
                        //                    if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                    {
                        //                        if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                        {
                        //                            intFailMask |= 0x04;
                        //                            blnDefect = true;
                        //                            blnLeftChipped = true;

                        //                            m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                        }
                        //                        else
                        //                        {
                        //                            intFailMask |= 0;
                        //                            blnDefect = true;
                        //                            blnLeftChipped = true;
                        //                        }
                        //                    }
                        //                }
                        //                else if ((fObjectCenterX - fObjectWidth / 2) > 0)
                        //                {
                        //                    //if (fObjectWidth == intCeilChipLengthLeft - fToleranceLeft)    // Is Chipped same length with chip setting + tolerance
                        //                    if (fObjectWidth >= intCeilChipLengthLeft - fToleranceLeft)    // Is Chipped over chip setting - tolerance
                        //                    {
                        //                        //if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= fToleranceLeft) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= 1) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        {
                        //                            if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                            {
                        //                                if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                                {
                        //                                    intFailMask |= 0x04;
                        //                                    blnDefect = true;
                        //                                    blnLeftChipped = true;
                        //                                    fAddX = fObjectCenterX - fObjectWidth / 2;

                        //                                    m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                                }
                        //                                else
                        //                                {
                        //                                    intFailMask |= 0;
                        //                                    blnDefect = true;
                        //                                    blnLeftChipped = true;
                        //                                    fAddX = fObjectCenterX - fObjectWidth / 2;
                        //                                }
                        //                            }

                        //                        }
                        //                    }
                        //                }
                        //            }
                        //            else // Confirm BOttom Chipped
                        //            {
                        //                if (fObjectHeight >= intChipLengthBottom) // Is Chipped over setting min value
                        //                {
                        //                    if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                    {
                        //                        if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                        {
                        //                            intFailMask |= 0x04;
                        //                            blnDefect = true;
                        //                            blnBottomChipped = true;

                        //                            m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                        }
                        //                        else
                        //                        {
                        //                            intFailMask |= 0;
                        //                            blnDefect = true;
                        //                            blnBottomChipped = true;
                        //                        }
                        //                    }
                        //                }
                        //                else if ((objBlobsROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2)) > 0)
                        //                {
                        //                    //if (fObjectHeight == intCeilChipLengthBottom - fToleranceBottom) // Is Chipped same length with chip setting + tolerance
                        //                    if (fObjectHeight >= intCeilChipLengthBottom - fToleranceBottom) // Is Chipped over chip setting - tolerance
                        //                    {
                        //                        //if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= fToleranceBottom)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= 1)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        {
                        //                            if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                            {
                        //                                if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                                {
                        //                                    intFailMask |= 0x04;
                        //                                    blnDefect = true;
                        //                                    blnBottomChipped = true;
                        //                                    fAddY = objBlobsROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2);

                        //                                    m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                                }
                        //                                else
                        //                                {
                        //                                    intFailMask |= 0;
                        //                                    blnDefect = true;
                        //                                    blnBottomChipped = true;
                        //                                    fAddY = objBlobsROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2);
                        //                                }
                        //                            }

                        //                        }
                        //                    }
                        //                }
                        //            }
                        //        }
                        //        else // Confirm Left Chipped 
                        //        {
                        //            if (fObjectWidth >= intChipLengthLeft)  // Is Chipped over setting min value
                        //            {
                        //                if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                {
                        //                    if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                    {
                        //                        intFailMask |= 0x04;
                        //                        blnDefect = true;
                        //                        blnLeftChipped = true;

                        //                        m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                    }
                        //                    else
                        //                    {
                        //                        intFailMask |= 0;
                        //                        blnDefect = true;
                        //                        blnLeftChipped = true;
                        //                    }
                        //                }
                        //            }
                        //            else if ((fObjectCenterX - fObjectWidth / 2) > 0)
                        //            {
                        //                //if (fObjectWidth == intCeilChipLengthLeft - fToleranceLeft)    // Is Chipped same length with chip setting + tolerance
                        //                if (fObjectWidth >= intCeilChipLengthLeft - fToleranceLeft) // Is Chipped over chip setting - tolerance
                        //                {
                        //                    //if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= fToleranceLeft) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                    if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= 1) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                    {
                        //                        if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                        {
                        //                            if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                            {
                        //                                intFailMask |= 0x04;
                        //                                blnDefect = true;
                        //                                blnLeftChipped = true;
                        //                                fAddX = fObjectCenterX - fObjectWidth / 2;

                        //                                m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                            }
                        //                            else
                        //                            {
                        //                                intFailMask |= 0;
                        //                                blnDefect = true;
                        //                                blnLeftChipped = true;
                        //                                fAddX = fObjectCenterX - fObjectWidth / 2;
                        //                            }
                        //                        }

                        //                    }
                        //                }
                        //            }
                        //        }
                        //    }

                        //    if (!blnDefect && fEndX > fInterEndX) // Possible Right Chipped
                        //    {
                        //        if (fStartY < fInterStartY) // Possible Top Chipped
                        //        {
                        //            if (fStartY < (objBlobsROI.ref_ROIWidth - fEndX))  // Confirm Top Chipped
                        //            {
                        //                if (fObjectHeight >= intChipLengthTop)  // Is Chipped over setting min value
                        //                {
                        //                    if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                    {
                        //                        if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                        {
                        //                            intFailMask |= 0x04;
                        //                            blnDefect = true;
                        //                            blnTopChipped = true;

                        //                            m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                        }
                        //                        else
                        //                        {
                        //                            intFailMask |= 0;
                        //                            blnDefect = true;
                        //                            blnTopChipped = true;
                        //                        }
                        //                    }
                        //                }
                        //                else if ((fObjectCenterY - fObjectHeight / 2) > 0)
                        //                {
                        //                    //if (fObjectHeight == intCeilChipLengthTop - fToleranceTop) // Is Chipped same length with chip setting + tolerance
                        //                    if (fObjectHeight >= intCeilChipLengthTop - fToleranceTop) // Is Chipped over chip setting - tolerance
                        //                    {
                        //                        //if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= fToleranceTop)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= 1)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        {
                        //                            if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                            {
                        //                                if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                                {
                        //                                    intFailMask |= 0x04;
                        //                                    blnDefect = true;
                        //                                    blnTopChipped = true;
                        //                                    fAddY = fObjectCenterY - fObjectHeight / 2;

                        //                                    m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                                }
                        //                                else
                        //                                {
                        //                                    intFailMask |= 0;
                        //                                    blnDefect = true;
                        //                                    blnTopChipped = true;
                        //                                    fAddY = fObjectCenterY - fObjectHeight / 2;
                        //                                }
                        //                            }
                        //                        }
                        //                    }
                        //                }
                        //            }
                        //            else // Confirm Right Chipped
                        //            {
                        //                if (fObjectWidth >= intChipLengthRight) // Is Chipped over setting min value
                        //                {
                        //                    if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                    {
                        //                        if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                        {
                        //                            intFailMask |= 0x04;
                        //                            blnDefect = true;
                        //                            blnRightChipped = true;

                        //                            m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                        }
                        //                        else
                        //                        {
                        //                            intFailMask |= 0;
                        //                            blnDefect = true;
                        //                            blnRightChipped = true;
                        //                        }
                        //                    }
                        //                }
                        //                else if ((objBlobsROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2)) > 0)
                        //                {
                        //                    //if (fObjectWidth == intCeilChipLengthRight - fToleranceRight)    // Is Chipped same length with chip setting + tolerance
                        //                    if (fObjectWidth >= intCeilChipLengthRight - fToleranceRight) // Is Chipped over chip setting - tolerance
                        //                    {
                        //                        //if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= fToleranceRight) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= 1) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        {
                        //                            if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                            {
                        //                                if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                                {
                        //                                    intFailMask |= 0x04;
                        //                                    blnDefect = true;
                        //                                    blnRightChipped = true;
                        //                                    fAddX = objBlobsROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2);

                        //                                    m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                                }
                        //                                else
                        //                                {
                        //                                    intFailMask |= 0;
                        //                                    blnDefect = true;
                        //                                    blnRightChipped = true;
                        //                                    fAddX = objBlobsROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2);
                        //                                }
                        //                            }
                        //                        }
                        //                    }
                        //                }
                        //            }
                        //        }
                        //        else if (fEndY > fInterEndY)    // Possible Bottom Chipped
                        //        {
                        //            if ((objBlobsROI.ref_ROIWidth - fEndX) < (objBlobsROI.ref_ROIHeight - fEndY)) // Confirm Right Chipped
                        //            {
                        //                if (fObjectWidth >= intChipLengthRight)  // Is Chipped over setting min value
                        //                {
                        //                    if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                    {
                        //                        if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                        {
                        //                            intFailMask |= 0x04;
                        //                            blnDefect = true;
                        //                            blnRightChipped = true;

                        //                            m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                        }
                        //                        else
                        //                        {
                        //                            intFailMask |= 0;
                        //                            blnDefect = true;
                        //                            blnRightChipped = true;
                        //                        }
                        //                    }
                        //                }
                        //                else if ((objBlobsROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2)) > 0)
                        //                {
                        //                    //if (fObjectWidth == intCeilChipLengthRight - fToleranceRight)    // Is Chipped same length with chip setting + tolerance
                        //                    if (fObjectWidth >= intCeilChipLengthRight - fToleranceRight) // Is Chipped over chip setting - tolerance
                        //                    {
                        //                        //if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= fToleranceRight) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= 1) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        {
                        //                            if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                            {
                        //                                if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                                {
                        //                                    intFailMask |= 0x04;
                        //                                    blnDefect = true;
                        //                                    blnRightChipped = true;
                        //                                    fAddX = objBlobsROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2);

                        //                                    m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                                }
                        //                                else
                        //                                {
                        //                                    intFailMask |= 0;
                        //                                    blnDefect = true;
                        //                                    blnRightChipped = true;
                        //                                    fAddX = objBlobsROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2);
                        //                                }
                        //                            }
                        //                        }
                        //                    }
                        //                }
                        //            }
                        //            else // Confirm BOttom Chipped
                        //            {
                        //                if (fObjectHeight >= intChipLengthBottom) // Is Chipped over setting min value
                        //                {
                        //                    if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                    {
                        //                        if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                        {
                        //                            intFailMask |= 0x04;
                        //                            blnDefect = true;
                        //                            blnBottomChipped = true;

                        //                            m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                        }
                        //                        else
                        //                        {
                        //                            intFailMask |= 0;
                        //                            blnDefect = true;
                        //                            blnBottomChipped = true;
                        //                        }
                        //                    }
                        //                }
                        //                else if ((objBlobsROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2)) > 0)
                        //                {
                        //                    //if (fObjectHeight == intCeilChipLengthBottom - fToleranceBottom) // Is Chipped same length with chip setting + tolerance
                        //                    if (fObjectHeight >= intCeilChipLengthBottom - fToleranceBottom) // Is Chipped over chip setting - tolerance
                        //                    {
                        //                        //if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= fToleranceBottom)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= 1)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        {
                        //                            if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                            {
                        //                                if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                                {
                        //                                    intFailMask |= 0x04;
                        //                                    blnDefect = true;
                        //                                    blnBottomChipped = true;
                        //                                    fAddY = objBlobsROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2);

                        //                                    m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                                }
                        //                                else
                        //                                {
                        //                                    intFailMask |= 0;
                        //                                    blnDefect = true;
                        //                                    blnBottomChipped = true;
                        //                                    fAddY = objBlobsROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2);
                        //                                }
                        //                            }
                        //                        }
                        //                    }
                        //                }
                        //            }
                        //        }
                        //        else // Confirm Right Chipped
                        //        {
                        //            if (fObjectWidth >= intChipLengthRight)  // Is Chipped over setting min value
                        //            {
                        //                if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                {
                        //                    if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                    {
                        //                        intFailMask |= 0x04;
                        //                        blnDefect = true;
                        //                        blnRightChipped = true;

                        //                        m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                    }
                        //                    else
                        //                    {
                        //                        intFailMask |= 0;
                        //                        blnDefect = true;
                        //                        blnRightChipped = true;
                        //                    }

                        //                }
                        //            }
                        //            else if ((objBlobsROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2)) > 0)
                        //            {
                        //                //if (fObjectWidth == intCeilChipLengthRight - fToleranceRight)    // Is Chipped same length with chip setting + tolerance
                        //                if (fObjectWidth >= intCeilChipLengthRight - fToleranceRight) // Is Chipped over chip setting - tolerance
                        //                {
                        //                    //if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= fToleranceRight) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                    if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= 1) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                    {
                        //                        if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                        {
                        //                            if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                            {
                        //                                intFailMask |= 0x04;
                        //                                blnDefect = true;
                        //                                blnRightChipped = true;
                        //                                fAddX = objBlobsROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2);

                        //                                m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                            }
                        //                            else
                        //                            {
                        //                                intFailMask |= 0;
                        //                                blnDefect = true;
                        //                                blnRightChipped = true;
                        //                                fAddX = objBlobsROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2);
                        //                            }
                        //                        }
                        //                    }
                        //                }
                        //            }
                        //        }
                        //    }

                        //    if (!blnDefect && fStartY < fInterStartY) // Possible Top chipped
                        //    {
                        //        if (fStartX < fInterStartX) // Possible Left Chipped
                        //        {
                        //            if (fStartX < fStartY)  // Confirm Left Chipped
                        //            {
                        //                if (fObjectWidth >= intChipLengthLeft)  // Is Chipped over setting min value
                        //                {
                        //                    if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                    {
                        //                        if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                        {
                        //                            intFailMask |= 0x04;
                        //                            blnDefect = true;
                        //                            blnLeftChipped = true;

                        //                            m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                        }
                        //                        else
                        //                        {
                        //                            intFailMask |= 0;
                        //                            blnDefect = true;
                        //                            blnLeftChipped = true;
                        //                        }

                        //                    }
                        //                }
                        //                else if ((fObjectCenterX - fObjectWidth / 2) > 0)
                        //                {
                        //                    //if (fObjectWidth == intCeilChipLengthLeft - fToleranceLeft)    // Is Chipped same length with chip setting + tolerance
                        //                    if (fObjectWidth >= intCeilChipLengthLeft - fToleranceLeft) // Is Chipped over chip setting - tolerance
                        //                    {
                        //                        //if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= fToleranceLeft) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= 1) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        {
                        //                            if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                            {
                        //                                if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                                {
                        //                                    intFailMask |= 0x04;
                        //                                    blnDefect = true;
                        //                                    blnLeftChipped = true;
                        //                                    fAddX = fObjectCenterX - fObjectWidth / 2;

                        //                                    m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                                }
                        //                                else
                        //                                {
                        //                                    intFailMask |= 0;
                        //                                    blnDefect = true;
                        //                                    blnLeftChipped = true;
                        //                                    fAddX = fObjectCenterX - fObjectWidth / 2;
                        //                                }
                        //                            }

                        //                        }
                        //                    }
                        //                }

                        //            }
                        //            else // Confirm Top Chipped
                        //            {
                        //                if (fObjectHeight >= intChipLengthTop) // Is Chipped over setting min value
                        //                {
                        //                    if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                    {
                        //                        if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                        {
                        //                            intFailMask |= 0x04;
                        //                            blnDefect = true;
                        //                            blnTopChipped = true;

                        //                            m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                        }
                        //                        else
                        //                        {
                        //                            intFailMask |= 0;
                        //                            blnDefect = true;
                        //                            blnTopChipped = true;
                        //                        }

                        //                    }
                        //                }
                        //                else if ((fObjectCenterY - fObjectHeight / 2) > 0)
                        //                {
                        //                    //if (fObjectHeight == intCeilChipLengthTop - fToleranceTop) // Is Chipped same length with chip setting + tolerance
                        //                    if (fObjectHeight >= intCeilChipLengthTop - fToleranceTop) // Is Chipped over chip setting - tolerance
                        //                    {
                        //                        //if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= fToleranceTop)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= 1)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        {
                        //                            if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                            {
                        //                                if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                                {
                        //                                    intFailMask |= 0x04;
                        //                                    blnDefect = true;
                        //                                    blnTopChipped = true;
                        //                                    fAddY = fObjectCenterY - fObjectHeight / 2;

                        //                                    m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                                }
                        //                                else
                        //                                {
                        //                                    intFailMask |= 0;
                        //                                    blnDefect = true;
                        //                                    blnTopChipped = true;
                        //                                    fAddY = fObjectCenterY - fObjectHeight / 2;
                        //                                }

                        //                            }
                        //                        }
                        //                    }
                        //                }
                        //            }
                        //        }
                        //        else if (fEndX > fInterEndX)    // Possible Right Chipped
                        //        {
                        //            if (fStartY < (objBlobsROI.ref_ROIWidth - fEndX)) // Confirm Top Chipped
                        //            {
                        //                if (fObjectHeight >= intChipLengthTop)  // Is Chipped over setting min value
                        //                {
                        //                    if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                    {
                        //                        if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                        {
                        //                            intFailMask |= 0x04;
                        //                            blnDefect = true;
                        //                            blnTopChipped = true;

                        //                            m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                        }
                        //                        else
                        //                        {
                        //                            intFailMask |= 0;
                        //                            blnDefect = true;
                        //                            blnTopChipped = true;
                        //                        }

                        //                    }
                        //                }
                        //                else if ((fObjectCenterY - fObjectHeight / 2) > 0)
                        //                {
                        //                    //if (fObjectHeight == intCeilChipLengthTop - fToleranceTop) // Is Chipped same length with chip setting + tolerance
                        //                    if (fObjectHeight >= intCeilChipLengthTop - fToleranceTop) // Is Chipped over chip setting - tolerance
                        //                    {
                        //                        //if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= fToleranceTop)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= 1)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        {
                        //                            if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                            {
                        //                                if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                                {
                        //                                    intFailMask |= 0x04;
                        //                                    blnDefect = true;
                        //                                    blnTopChipped = true;
                        //                                    fAddY = fObjectCenterY - fObjectHeight / 2;

                        //                                    m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                                }
                        //                                else
                        //                                {
                        //                                    intFailMask |= 0;
                        //                                    blnDefect = true;
                        //                                    blnTopChipped = true;
                        //                                    fAddY = fObjectCenterY - fObjectHeight / 2;
                        //                                }
                        //                            }
                        //                        }
                        //                    }
                        //                }
                        //            }
                        //            else // Confirm Right Chipped
                        //            {
                        //                if (fObjectWidth >= intChipLengthRight) // Is Chipped over setting min value
                        //                {
                        //                    if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                    {
                        //                        if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                        {
                        //                            intFailMask |= 0x04;
                        //                            blnDefect = true;
                        //                            blnRightChipped = true;

                        //                            m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                        }
                        //                        else
                        //                        {
                        //                            intFailMask |= 0;
                        //                            blnDefect = true;
                        //                            blnRightChipped = true;
                        //                        }

                        //                    }
                        //                }
                        //                else if ((objBlobsROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2)) > 0)
                        //                {
                        //                    //if (fObjectWidth == intCeilChipLengthRight - fToleranceRight)    // Is Chipped same length with chip setting + tolerance
                        //                    if (fObjectWidth >= intCeilChipLengthRight - fToleranceRight) // Is Chipped over chip setting - tolerance
                        //                    {
                        //                        //if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= fToleranceRight) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= 1) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        {
                        //                            if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                            {
                        //                                if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                                {
                        //                                    intFailMask |= 0x04;
                        //                                    blnDefect = true;
                        //                                    blnRightChipped = true;
                        //                                    fAddX = objBlobsROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2);

                        //                                    m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                                }
                        //                                else
                        //                                {
                        //                                    intFailMask |= 0;
                        //                                    blnDefect = true;
                        //                                    blnRightChipped = true;
                        //                                    fAddX = objBlobsROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2);
                        //                                }
                        //                            }
                        //                        }
                        //                    }
                        //                }
                        //            }
                        //        }
                        //        else // Confirm Top Chipped
                        //        {
                        //            if (fObjectHeight >= intChipLengthTop)  // Is Chipped over setting min value
                        //            {
                        //                if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                {
                        //                    if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                    {
                        //                        intFailMask |= 0x04;
                        //                        blnDefect = true;
                        //                        blnTopChipped = true;

                        //                        m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                    }
                        //                    else
                        //                    {
                        //                        intFailMask |= 0;
                        //                        blnDefect = true;
                        //                        blnTopChipped = true;
                        //                    }
                        //                }
                        //            }
                        //            else if ((fObjectCenterY - fObjectHeight / 2) > 0)
                        //            {
                        //                //if (fObjectHeight == intCeilChipLengthTop - fToleranceTop) // Is Chipped same length with chip setting + tolerance
                        //                if (fObjectHeight >= intCeilChipLengthTop - fToleranceTop) // Is Chipped over chip setting - tolerance
                        //                {
                        //                    //if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= fToleranceTop)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                    if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= 1)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                    {
                        //                        if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                        {
                        //                            if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                            {
                        //                                intFailMask |= 0x04;
                        //                                blnDefect = true;
                        //                                blnTopChipped = true;
                        //                                fAddY = fObjectCenterY - fObjectHeight / 2;

                        //                                m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                            }
                        //                            else
                        //                            {
                        //                                intFailMask |= 0;
                        //                                blnDefect = true;
                        //                                blnTopChipped = true;
                        //                                fAddY = fObjectCenterY - fObjectHeight / 2;
                        //                            }
                        //                        }
                        //                    }
                        //                }
                        //            }
                        //        }
                        //    }

                        //    if (!blnDefect && fEndY > fInterEndY) // Possible Bottom Chipped
                        //    {
                        //        if (fStartX < fInterStartX) // Possible Left Chipped
                        //        {
                        //            if (fStartX < (objBlobsROI.ref_ROIHeight - fEndY))  // Confirm Left Chipped
                        //            {
                        //                if (fObjectWidth >= intChipLengthLeft)  // Is Chipped over setting min value
                        //                {
                        //                    if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                    {
                        //                        if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                        {
                        //                            intFailMask |= 0x04;
                        //                            blnDefect = true;
                        //                            blnLeftChipped = true;

                        //                            m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                        }
                        //                        else
                        //                        {
                        //                            intFailMask |= 0;
                        //                            blnDefect = true;
                        //                            blnLeftChipped = true;
                        //                        }
                        //                    }
                        //                }
                        //                else if ((fObjectCenterX - fObjectWidth / 2) > 0)
                        //                {
                        //                    //if (fObjectWidth == intCeilChipLengthLeft - fToleranceLeft)    // Is Chipped same length with chip setting + tolerance
                        //                    if (fObjectWidth >= intCeilChipLengthLeft - fToleranceLeft) // Is Chipped over chip setting - tolerance
                        //                    {
                        //                        //if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= fToleranceLeft) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= 1) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        {
                        //                            if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                            {
                        //                                if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                                {
                        //                                    intFailMask |= 0x04;
                        //                                    blnDefect = true;
                        //                                    blnLeftChipped = true;
                        //                                    fAddX = fObjectCenterX - fObjectWidth / 2;

                        //                                    m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                                }
                        //                                else
                        //                                {
                        //                                    intFailMask |= 0;
                        //                                    blnDefect = true;
                        //                                    blnLeftChipped = true;
                        //                                    fAddX = fObjectCenterX - fObjectWidth / 2;
                        //                                }
                        //                            }
                        //                        }
                        //                    }
                        //                }

                        //            }
                        //            else // Confirm Bottom Chipped
                        //            {
                        //                if (fObjectHeight >= intChipLengthBottom) // Is Chipped over setting min value
                        //                {
                        //                    if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                    {
                        //                        if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                        {
                        //                            intFailMask |= 0x04;
                        //                            blnDefect = true;
                        //                            blnBottomChipped = true;

                        //                            m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                        }
                        //                        else
                        //                        {
                        //                            intFailMask |= 0;
                        //                            blnDefect = true;
                        //                            blnBottomChipped = true;
                        //                        }
                        //                    }
                        //                }
                        //                else if ((objBlobsROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2)) > 0)
                        //                {
                        //                    //if (fObjectHeight == intCeilChipLengthBottom - fToleranceBottom) // Is Chipped same length with chip setting + tolerance
                        //                    if (fObjectHeight >= intCeilChipLengthBottom - fToleranceBottom) // Is Chipped over chip setting - tolerance
                        //                    {
                        //                        //if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= fToleranceBottom)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= 1)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        {
                        //                            if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                            {
                        //                                if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                                {
                        //                                    intFailMask |= 0x04;
                        //                                    blnDefect = true;
                        //                                    blnBottomChipped = true;
                        //                                    fAddY = objBlobsROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2);

                        //                                    m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                                }
                        //                                else
                        //                                {
                        //                                    intFailMask |= 0;
                        //                                    blnDefect = true;
                        //                                    blnBottomChipped = true;
                        //                                    fAddY = objBlobsROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2);
                        //                                }
                        //                            }
                        //                        }
                        //                    }
                        //                }
                        //            }
                        //        }
                        //        else if (fEndX > fInterEndX)    // Possible Right Chipped
                        //        {
                        //            if ((objBlobsROI.ref_ROIWidth - fEndX) < (objBlobsROI.ref_ROIHeight - fEndY)) // Confirm Right Chipped
                        //            {
                        //                if (fObjectWidth >= intChipLengthRight)  // Is Chipped over setting min value
                        //                {
                        //                    if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                    {
                        //                        if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                        {
                        //                            intFailMask |= 0x04;
                        //                            blnDefect = true;
                        //                            blnRightChipped = true;

                        //                            m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                        }
                        //                        else
                        //                        {
                        //                            intFailMask |= 0;
                        //                            blnDefect = true;
                        //                            blnRightChipped = true;
                        //                        }
                        //                    }
                        //                }
                        //                else if ((objBlobsROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2)) > 0)
                        //                {
                        //                    //if (fObjectWidth == intCeilChipLengthRight - fToleranceRight)    // Is Chipped same length with chip setting + tolerance
                        //                    if (fObjectWidth >= intCeilChipLengthRight - fToleranceRight) // Is Chipped over chip setting - tolerance
                        //                    {
                        //                        //if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= fToleranceRight) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= 1) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        {
                        //                            if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                            {
                        //                                if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                                {
                        //                                    intFailMask |= 0x04;
                        //                                    blnDefect = true;
                        //                                    blnRightChipped = true;
                        //                                    fAddX = objBlobsROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2);

                        //                                    m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                                }
                        //                                else
                        //                                {
                        //                                    intFailMask |= 0;
                        //                                    blnDefect = true;
                        //                                    blnRightChipped = true;
                        //                                    fAddX = objBlobsROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2);
                        //                                }
                        //                            }
                        //                        }
                        //                    }
                        //                }
                        //            }
                        //            else // Confirm BOttom Chipped
                        //            {
                        //                if (fObjectHeight >= intChipLengthBottom) // Is Chipped over setting min value
                        //                {
                        //                    if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                    {
                        //                        if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                        {
                        //                            intFailMask |= 0x04;
                        //                            blnDefect = true;
                        //                            blnBottomChipped = true;


                        //                            m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                        }
                        //                        else
                        //                        {
                        //                            intFailMask |= 0;
                        //                            blnDefect = true;
                        //                            blnBottomChipped = true;
                        //                        }
                        //                    }
                        //                }
                        //                else if ((objBlobsROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2)) > 0)
                        //                {
                        //                    //if (fObjectHeight == intCeilChipLengthBottom - fToleranceBottom) // Is Chipped same length with chip setting + tolerance
                        //                    if (fObjectHeight >= intCeilChipLengthBottom - fToleranceBottom) // Is Chipped over chip setting - tolerance
                        //                    {
                        //                        //if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= fToleranceBottom)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= 1)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        {
                        //                            if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                            {
                        //                                if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                                {
                        //                                    intFailMask |= 0x04;
                        //                                    blnDefect = true;
                        //                                    blnBottomChipped = true;
                        //                                    fAddY = objBlobsROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2);

                        //                                    m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                                }
                        //                                else
                        //                                {
                        //                                    intFailMask |= 0;
                        //                                    blnDefect = true;
                        //                                    blnBottomChipped = true;
                        //                                    fAddY = objBlobsROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2);
                        //                                }
                        //                            }
                        //                        }
                        //                    }
                        //                }
                        //            }
                        //        }
                        //        else // Confirm Bottom Chipped
                        //        {
                        //            if (fObjectHeight >= intChipLengthBottom)  // Is Chipped over setting min value
                        //            {
                        //                if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                {
                        //                    if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                    {
                        //                        intFailMask |= 0x04;
                        //                        blnDefect = true;
                        //                        blnBottomChipped = true;

                        //                        m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                    }
                        //                    else
                        //                    {
                        //                        intFailMask |= 0;
                        //                        blnDefect = true;
                        //                        blnBottomChipped = true;
                        //                    }
                        //                }
                        //            }
                        //            else if ((objBlobsROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2)) > 0)
                        //            {
                        //                //if (fObjectHeight == intCeilChipLengthBottom - fToleranceBottom) // Is Chipped same length with chip setting + tolerance
                        //                if (fObjectHeight >= intCeilChipLengthBottom - fToleranceBottom) // Is Chipped over chip setting - tolerance
                        //                {
                        //                    //if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= fToleranceBottom)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                    if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= 1)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                    {
                        //                        if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                        {
                        //                            if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                            {
                        //                                intFailMask |= 0x04;
                        //                                blnDefect = true;
                        //                                blnBottomChipped = true;
                        //                                fAddY = objBlobsROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2);

                        //                                m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                            }
                        //                            else
                        //                            {
                        //                                intFailMask |= 0;
                        //                                blnDefect = true;
                        //                                blnBottomChipped = true;
                        //                                fAddY = objBlobsROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2);
                        //                            }
                        //                        }
                        //                    }
                        //                }
                        //            }
                        //        }
                        //    }
                        //}



                        if (blnDefect)
                        {
                            if (m_arrWantDefectArea[intChipType] || m_arrWantDefectLength[intChipType])   // Want check defect Chipped Off Area 
                            {
                                Defect objDefect = new Defect();

                                //To determine the object width or height is over the chipped tolerance
                                if (blnTopChipped || blnBottomChipped)
                                {
                                    objDefect.ref_fDimX = fObjectWidth;
                                    objDefect.ref_fDimY = fObjectHeight + fAddY;
                                    objDefect.ref_intLengthMode = 0;
                                }
                                else if (blnLeftChipped || blnRightChipped)
                                {
                                    objDefect.ref_fDimY = fObjectWidth + fAddX;
                                    objDefect.ref_fDimX = fObjectHeight;
                                    objDefect.ref_intLengthMode = 1;
                                }

                                if (m_arrWantDefectArea[intChipType])
                                {
                                    if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                                    {
                                        intFailMask |= 0x04;
                                        m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                                    }
                                }

                                if (m_arrWantDefectLength[intChipType])
                                {
                                    float fWidthLimit = GetDefect("Chip", 0);
                                    float fLengthLimit = GetDefect("Chip", 1);

                                    int intFailCondition = m_intChippedDarkDefectDimensionFailCondition;
                                    if (m_blnBrightChipDefect)
                                        intFailCondition = m_intChippedBrightDefectDimensionFailCondition;

                                    if (blnTopChipped || blnBottomChipped)
                                    {
                                        if (intFailCondition == 0)
                                        {
                                            // Top Left Border + LengthMode 0
                                            // ------------------------------------ 
                                            // X : fDimX, fWidthLimit, FailMask=0x01, Fail Message label width
                                            // Y : fDimY, fLengthLimit, FailMask=0x02, Fail Message label length

                                            if (objDefect.ref_fDimX >= fWidthLimit)  // Is Chipped over setting min value
                                            {
                                                intFailMask |= 0x01;
                                                m_strErrorMessage += "*Chipped Off Width Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (fWidthLimit / m_fMMToPixelXValue).ToString("f4") + " mm,   Result = " + (objDefect.ref_fDimX / m_fMMToPixelXValue).ToString("f4") + " mm";
                                            }
                                            if (objDefect.ref_fDimY >= fLengthLimit)  // Is Chipped over setting min value
                                            {
                                                intFailMask |= 0x02;
                                                m_strErrorMessage += "*Chipped Off Length Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (fLengthLimit / m_fMMToPixelYValue).ToString("f4") + " mm,   Result = " + (objDefect.ref_fDimY / m_fMMToPixelYValue).ToString("f4") + " mm";
                                            }
                                        }
                                        else
                                        {
                                            if ((objDefect.ref_fDimX >= fWidthLimit) && (objDefect.ref_fDimY >= fLengthLimit))  // Is Chipped over setting min value
                                            {
                                                intFailMask |= 0x01;
                                                intFailMask |= 0x02;
                                                m_strErrorMessage += "*Chipped Off Width Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (fWidthLimit / m_fMMToPixelXValue).ToString("f4") + " mm,   Result = " + (objDefect.ref_fDimX / m_fMMToPixelXValue).ToString("f4") + " mm";
                                                m_strErrorMessage += "*Chipped Off Length Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (fLengthLimit / m_fMMToPixelYValue).ToString("f4") + " mm,   Result = " + (objDefect.ref_fDimY / m_fMMToPixelYValue).ToString("f4") + " mm";
                                            }
                                        }
                                    }
                                    else if (blnLeftChipped || blnRightChipped)
                                    {
                                        if (objDefect.ref_intLengthMode == 0)
                                        {
                                            // Left Right Border + LengthMode 0
                                            // ------------------------------------ 
                                            // X : fDimX, fLengthLimit, FailMask=0x01
                                            // Y : fDimY, fWidthLimit, FailMask=0x02

                                            if (intFailCondition == 0)
                                            {
                                                if (objDefect.ref_fDimY >= fWidthLimit)  // Is Chipped over setting min value
                                                {
                                                    intFailMask |= 0x02;
                                                    m_strErrorMessage += "*Chipped Off Length Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (fWidthLimit / m_fMMToPixelXValue).ToString("f4") + " mm,   Result = " + (objDefect.ref_fDimY / m_fMMToPixelXValue).ToString("f4") + " mm";
                                                }
                                                if (objDefect.ref_fDimX >= fLengthLimit)  // Is Chipped over setting min value
                                                {
                                                    intFailMask |= 0x01;
                                                    m_strErrorMessage += "*Chipped Off Width Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (fLengthLimit / m_fMMToPixelYValue).ToString("f4") + " mm,   Result = " + (objDefect.ref_fDimX / m_fMMToPixelYValue).ToString("f4") + " mm";
                                                }
                                            }
                                            else
                                            {
                                                if ((objDefect.ref_fDimY >= fWidthLimit) && (objDefect.ref_fDimX >= fLengthLimit))  // Is Chipped over setting min value
                                                {
                                                    intFailMask |= 0x01;
                                                    intFailMask |= 0x02;
                                                    m_strErrorMessage += "*Chipped Off Length Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (fWidthLimit / m_fMMToPixelXValue).ToString("f4") + " mm,   Result = " + (objDefect.ref_fDimY / m_fMMToPixelXValue).ToString("f4") + " mm";
                                                    m_strErrorMessage += "*Chipped Off Width Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (fLengthLimit / m_fMMToPixelYValue).ToString("f4") + " mm,   Result = " + (objDefect.ref_fDimX / m_fMMToPixelYValue).ToString("f4") + " mm";
                                                }
                                            }
                                        }
                                        else
                                        {
                                            // Left Right Border + LengthMode 1
                                            // ------------------------------------ 
                                            // X : fDimX, fWidthLimit, FailMask=0x01, Fail Message label Width
                                            // Y : fDimY, fLengthLimit, FailMask=0x02, Fail Message label length

                                            if (intFailCondition == 0)
                                            {
                                                if (objDefect.ref_fDimX >= fWidthLimit)  // Is Chipped over setting min value
                                                {
                                                    intFailMask |= 0x01;
                                                    m_strErrorMessage += "*Chipped Off Width Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (fWidthLimit / m_fMMToPixelXValue).ToString("f4") + " mm,   Result = " + (objDefect.ref_fDimX / m_fMMToPixelXValue).ToString("f4") + " mm";
                                                }
                                                if (objDefect.ref_fDimY >= fLengthLimit)  // Is Chipped over setting min value
                                                {
                                                    intFailMask |= 0x02;
                                                    m_strErrorMessage += "*Chipped Off Length Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (fLengthLimit / m_fMMToPixelYValue).ToString("f4") + " mm,   Result = " + (objDefect.ref_fDimY / m_fMMToPixelYValue).ToString("f4") + " mm";
                                                }
                                            }
                                            else
                                            {
                                                if ((objDefect.ref_fDimX >= fWidthLimit) && (objDefect.ref_fDimY >= fLengthLimit))  // Is Chipped over setting min value
                                                {
                                                    intFailMask |= 0x01;
                                                    intFailMask |= 0x02;
                                                    m_strErrorMessage += "*Chipped Off Width Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (fWidthLimit / m_fMMToPixelXValue).ToString("f4") + " mm,   Result = " + (objDefect.ref_fDimX / m_fMMToPixelXValue).ToString("f4") + " mm";
                                                    m_strErrorMessage += "*Chipped Off Length Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (fLengthLimit / m_fMMToPixelYValue).ToString("f4") + " mm,   Result = " + (objDefect.ref_fDimY / m_fMMToPixelYValue).ToString("f4") + " mm";
                                                }
                                            }
                                        }
                                    }

                                }


                                //objDefect.ref_fDimX = fObjectWidth;
                                //objDefect.ref_fDimY = fObjectHeight;
                                objDefect.ref_fArea = intObjectArea;
                                objDefect.ref_fCenterX = intTotalROIStartX + fObjectCenterX;
                                objDefect.ref_fCenterY = intTotalROIStartY + fObjectCenterY;
                                objDefect.ref_intBlobNo = i;
                                objDefect.ref_intFailMask = intFailMask;
                                m_intPkgFailResultMask |= 0x02;
                                objDefect.ref_strName = "Img " + (intSelectedImageIndex + 1).ToString() + " Chipped";
                                objDefect.ref_intFailedImage = intSelectedImageIndex + 1;

                                m_arrDefectList.Add(objDefect);

                                if (intFailMask > 0)
                                {
                                    if (!blnOverAllFail)
                                        blnOverAllFail = true;
                                }
                            }
                        }
                    }

                }
            }

            if (blnOverAllFail)
                return false;
            else
                return true;
        }

        private bool InspectChipPackage_Area(float fCenterX, float fCenterY, float fWidth, float fHeight, ImageDrawing objImage, int intThreshold,
                                  int intTotalROIStartX, int intTotalROIStartY, int intChipLineLimitPixelValue, int intChipViewMinAreaSetting, List<PointF> arrChippedROIPoints,
                                  ImageDrawing objWhiteImage, ImageDrawing objBlackImage, float fAngle)
        {
            if (objImage.ref_intImageHeight == 0 || objImage.ref_intImageWidth == 0)
                return true;

            if ((m_intPkgFailMask & 0x02) == 0)
                return true;

            bool blnDebug = false;
            int intSelectedImageIndex;

            int intChipType = (int)eWantDefect.ChipBright;
            if (intChipLineLimitPixelValue == 255)
            {
                intChipType = (int)eWantDefect.ChipDark;
            }

            int intCeilChipLengthTop = 0; // (int)Math.Ceiling(m_arrDefectHorizontal[1]);
            int intCeilChipLengthRight = 0;  //(int)Math.Ceiling(m_arrDefectHorizontal[1]);
            int intCeilChipLengthBottom = 0; //(int)Math.Ceiling(m_arrDefectHorizontal[1]);
            int intCeilChipLengthLeft = 0;  //(int)Math.Ceiling(m_arrDefectHorizontal[1]);

            if (intChipLineLimitPixelValue == 0)    // White field defect (Scratches, contamination, chip)
            {
                intCeilChipLengthTop = m_intStartPixelFromEdge_Chip - m_intStartPixelExtendFromEdge_Chip;
                intCeilChipLengthRight = m_intStartPixelFromRight_Chip - m_intStartPixelExtendFromRight_Chip;
                intCeilChipLengthBottom = m_intStartPixelFromBottom_Chip - m_intStartPixelExtendFromBottom_Chip;
                intCeilChipLengthLeft = m_intStartPixelFromLeft_Chip - m_intStartPixelExtendFromLeft_Chip;

                intSelectedImageIndex = m_arrGrabImageIndex[2];
            }
            else // Black field defect (Crack, void, chip)
            {
                intCeilChipLengthTop = m_intStartPixelFromEdge_Chip_Dark - m_intStartPixelExtendFromEdge_Chip_Dark;
                intCeilChipLengthRight = m_intStartPixelFromRight_Chip_Dark - m_intStartPixelExtendFromRight_Chip_Dark;
                intCeilChipLengthBottom = m_intStartPixelFromBottom_Chip_Dark - m_intStartPixelExtendFromBottom_Chip_Dark;
                intCeilChipLengthLeft = m_intStartPixelFromLeft_Chip_Dark - m_intStartPixelExtendFromLeft_Chip_Dark;

                intSelectedImageIndex = m_arrGrabImageIndex[3];
            }
            for (int i =0; i < arrChippedROIPoints.Count; i++)
            {
                arrChippedROIPoints[i] = new PointF(arrChippedROIPoints[i].X - intTotalROIStartX, arrChippedROIPoints[i].Y - intTotalROIStartY);
            }
            if (blnDebug)
                objImage.SaveImage("D:\\TS\\1.ChippedOffImage.bmp");
            // if (intCeilChipLength != 0)
            //HiPerfTimer t = new HiPerfTimer();
            //t.Start();
            FillChipLineLimitToCorner_Area(objImage, intCeilChipLengthTop, intCeilChipLengthRight, intCeilChipLengthBottom, intCeilChipLengthLeft, intChipLineLimitPixelValue, arrChippedROIPoints, objWhiteImage, objBlackImage, fAngle);
            //t.Stop();
            //STTrackLog.WriteLine("FillChipLineLimitToCorner_Area " + intChipLineLimitPixelValue.ToString() + " time = " + t.Duration.ToString());
            if (blnDebug)
                objImage.SaveImage("D:\\TS\\2.ChippedOffImageFillChipLineLimitToCorner.bmp");

            ROI objBlobsROI = new ROI();
            objBlobsROI.AttachImage(objImage);
            objBlobsROI.LoadROISetting(0, 0, objImage.ref_intImageWidth, objImage.ref_intImageHeight);
            if (blnDebug)
                objBlobsROI.SaveImage("D:\\TS\\3.objBlobsROI.bmp");
            int intMinValue;
            if (intChipViewMinAreaSetting == 0)
                intMinValue = m_intChipView1MinArea;
            else
                intMinValue = m_intChipView2MinArea;

            bool bWhiteOnBlack;
            if (intChipLineLimitPixelValue == 0)
                bWhiteOnBlack = true;    // detect white on black - white is the chip
            else
                bWhiteOnBlack = false;   // detect black on white - black is the chip

            int intSelectedObject = m_objEBlobs.BuildObjects_Filter_GetElement(objBlobsROI, !bWhiteOnBlack, true, 0, intThreshold,
                intMinValue, objBlobsROI.ref_ROIWidth * objBlobsROI.ref_ROIHeight, false, 0x0D);

            bool blnOverAllFail = false;
            if (intSelectedObject > 0)
            {
                int intObjectArea = 0;
                float fObjectHeight = 0, fObjectWidth = 0, fObjectCenterX = 0, fObjectCenterY = 0;
                float fStartX, fStartY, fEndX, fEndY;
                //float fOuterStartX = 1;
                //float fOuterStartY = 1;
                //float fOuterEndX = objBlobsROI.ref_ROIWidth;
                //float fOuterEndY = objBlobsROI.ref_ROIHeight;
                //float fInterStartX = intCeilChipLengthLeft;// m_intStartPixelFromLeft_Chip; // m_arrDefectHorizontal[1];
                //float fInterStartY = intCeilChipLengthTop;//m_intStartPixelFromEdge_Chip; // m_arrDefectHorizontal[1];
                //float fInterEndX = (float)objBlobsROI.ref_ROIWidth - intCeilChipLengthRight; //- m_arrDefectHorizontal[1] - 1;
                //float fInterEndY = (float)objBlobsROI.ref_ROIHeight - intCeilChipLengthBottom;  //- m_arrDefectHorizontal[1] - 1;
                //int intChipLengthTop = intCeilChipLengthTop;// m_intStartPixelFromEdge_Chip;
                //int intChipLengthRight = intCeilChipLengthRight;// m_intStartPixelFromRight_Chip;
                //int intChipLengthBottom = intCeilChipLengthBottom;// m_intStartPixelFromBottom_Chip;
                //int intChipLengthLeft = intCeilChipLengthLeft;// m_intStartPixelFromLeft_Chip;
                int intFailMask = 0;
                
                float fInterStartX = fCenterX - (fWidth / 2) - intTotalROIStartX + intCeilChipLengthLeft;// m_intStartPixelFromLeft_Chip; // m_arrDefectHorizontal[1];
                float fInterStartY = fCenterY - (fHeight / 2) - intTotalROIStartY + intCeilChipLengthTop;//m_intStartPixelFromEdge_Chip; // m_arrDefectHorizontal[1];
                float fInterEndX = fCenterX + (fWidth / 2) - intTotalROIStartX - intCeilChipLengthRight; //- m_arrDefectHorizontal[1] - 1;
                float fInterEndY = fCenterY + (fHeight / 2) - intTotalROIStartY - intCeilChipLengthBottom;  //- m_arrDefectHorizontal[1] - 1;

                for (int i = 0; i < intSelectedObject; i++)
                {
                    intObjectArea = m_objEBlobs.ref_arrArea[i];
                    fObjectHeight = m_objEBlobs.ref_arrHeight[i];
                    fObjectWidth = m_objEBlobs.ref_arrWidth[i];
                    fObjectCenterX = m_objEBlobs.ref_arrLimitCenterX[i];
                    fObjectCenterY = m_objEBlobs.ref_arrLimitCenterY[i];
                    intFailMask = 0;

                    if (true)
                    {
                        float fCenterX_New = (float)((objBlobsROI.ref_ROIWidth / 2) + ((fObjectCenterX - (objBlobsROI.ref_ROIWidth / 2)) * Math.Cos(-fAngle * Math.PI / 180)) - ((fObjectCenterY - (objBlobsROI.ref_ROIHeight / 2)) * Math.Sin(-fAngle * Math.PI / 180)));

                        float fCenterY_New = (float)(((objBlobsROI.ref_ROIHeight / 2)) + ((fObjectCenterX - (objBlobsROI.ref_ROIWidth / 2)) * Math.Sin(-fAngle * Math.PI / 180)) + ((fObjectCenterY - (objBlobsROI.ref_ROIHeight / 2)) * Math.Cos(-fAngle * Math.PI / 180)));

                        fStartX = fCenterX_New - (fObjectWidth / 2);
                        fStartY = fCenterY_New - (fObjectHeight / 2);
                        fEndX = fCenterX_New + (fObjectWidth / 2);
                        fEndY = fCenterY_New + (fObjectHeight / 2);

                        //fStartX = fObjectCenterX - (fObjectWidth / 2);
                        //fStartY = fObjectCenterY - (fObjectHeight / 2);
                        //fEndX = fObjectCenterX + (fObjectWidth / 2);
                        //fEndY = fObjectCenterY + (fObjectHeight / 2);

                        //float fToleranceLeft = intChipLengthLeft / 2;
                        //float fToleranceTop = intChipLengthTop / 2;
                        //float fToleranceRight = intChipLengthRight / 2;
                        //float fToleranceBottom = intChipLengthBottom / 2;
                        bool blnDefect = false;
                        bool blnTopChipped = false;
                        bool blnBottomChipped = false;
                        bool blnLeftChipped = false;
                        bool blnRightChipped = false;

                        float fAddX = 0;
                        float fAddY = 0;

                        /*
                         * If Chipped off Length Checked but Chipped Off area unchecked, then chipped off happen as long as defect touch the setting tolerance line.
                         * If Chipped off length and area both Checked, then chipped off will only happen when defect touch the setting tolerance line and with min defect area.
                         */

                        //if (m_arrWantDefectArea[(int)eWantDefect.Chip])   // Want check defect Chipped Off Area 
                        {
                            if (fStartX < fInterStartX) // Possible Left Chipped
                            {
                                if (fStartY < fInterStartY) // Possible Top Chipped
                                {
                                    if (fStartX < fStartY)  // Confirm Left Chipped
                                    {
                                        blnDefect = true;
                                        blnLeftChipped = true;
                                        //CheckIsAreaMoreThanChipToleranceSetting(intObjectArea, ref intFailMask, ref blnDefect, ref blnLeftChipped, intSelectedImageIndex);
                                    }
                                    else // Confirm Top Chipped
                                    {
                                        blnDefect = true;
                                        blnTopChipped = true;
                                        //CheckIsAreaMoreThanChipToleranceSetting(intObjectArea, ref intFailMask, ref blnDefect, ref blnTopChipped, intSelectedImageIndex);
                                    }
                                }
                                else if (fEndY > fInterEndY)    // Possible Bottom Chipped
                                {
                                    if (fStartX < (objBlobsROI.ref_ROIHeight - fEndY)) // Confirm Left Chipped
                                    {
                                        blnDefect = true;
                                        blnLeftChipped = true;
                                        //CheckIsAreaMoreThanChipToleranceSetting(intObjectArea, ref intFailMask, ref blnDefect, ref blnLeftChipped, intSelectedImageIndex);
                                    }
                                    else // Confirm BOttom Chipped
                                    {
                                        blnDefect = true;
                                        blnBottomChipped = true;
                                        //CheckIsAreaMoreThanChipToleranceSetting(intObjectArea, ref intFailMask, ref blnDefect, ref blnBottomChipped, intSelectedImageIndex);
                                    }
                                }
                                else // Confirm Left Chipped 
                                {
                                    blnDefect = true;
                                    blnLeftChipped = true;
                                    //CheckIsAreaMoreThanChipToleranceSetting(intObjectArea, ref intFailMask, ref blnDefect, ref blnLeftChipped, intSelectedImageIndex);
                                }
                            }

                            if (!blnDefect && fEndX > fInterEndX) // Possible Right Chipped
                            {
                                if (fStartY < fInterStartY) // Possible Top Chipped
                                {
                                    if (fStartY < (objBlobsROI.ref_ROIWidth - fEndX))  // Confirm Top Chipped
                                    {
                                        blnDefect = true;
                                        blnTopChipped = true;
                                        //CheckIsAreaMoreThanChipToleranceSetting(intObjectArea, ref intFailMask, ref blnDefect, ref blnTopChipped, intSelectedImageIndex);
                                    }
                                    else // Confirm Right Chipped
                                    {
                                        blnDefect = true;
                                        blnRightChipped = true;
                                        //CheckIsAreaMoreThanChipToleranceSetting(intObjectArea, ref intFailMask, ref blnDefect, ref blnRightChipped, intSelectedImageIndex);
                                    }
                                }
                                else if (fEndY > fInterEndY)    // Possible Bottom Chipped
                                {
                                    if ((objBlobsROI.ref_ROIWidth - fEndX) < (objBlobsROI.ref_ROIHeight - fEndY)) // Confirm Right Chipped
                                    {
                                        blnDefect = true;
                                        blnRightChipped = true;
                                        //CheckIsAreaMoreThanChipToleranceSetting(intObjectArea, ref intFailMask, ref blnDefect, ref blnRightChipped, intSelectedImageIndex);
                                    }
                                    else // Confirm BOttom Chipped
                                    {
                                        blnDefect = true;
                                        blnBottomChipped = true;
                                        //CheckIsAreaMoreThanChipToleranceSetting(intObjectArea, ref intFailMask, ref blnDefect, ref blnBottomChipped, intSelectedImageIndex);
                                    }
                                }
                                else // Confirm Right Chipped
                                {
                                    blnDefect = true;
                                    blnRightChipped = true;
                                    //CheckIsAreaMoreThanChipToleranceSetting(intObjectArea, ref intFailMask, ref blnDefect, ref blnRightChipped, intSelectedImageIndex);
                                }
                            }

                            if (!blnDefect && fStartY < fInterStartY) // Possible Top chipped
                            {
                                if (fStartX < fInterStartX) // Possible Left Chipped
                                {
                                    if (fStartX < fStartY)  // Confirm Left Chipped
                                    {
                                        blnDefect = true;
                                        blnLeftChipped = true;
                                        //CheckIsAreaMoreThanChipToleranceSetting(intObjectArea, ref intFailMask, ref blnDefect, ref blnLeftChipped, intSelectedImageIndex);
                                    }
                                    else // Confirm Top Chipped
                                    {
                                        blnDefect = true;
                                        blnTopChipped = true;
                                        //CheckIsAreaMoreThanChipToleranceSetting(intObjectArea, ref intFailMask, ref blnDefect, ref blnTopChipped, intSelectedImageIndex);
                                    }
                                }
                                else if (fEndX > fInterEndX)    // Possible Right Chipped
                                {
                                    if (fStartY < (objBlobsROI.ref_ROIWidth - fEndX)) // Confirm Top Chipped
                                    {
                                        blnDefect = true;
                                        blnTopChipped = true;
                                        //CheckIsAreaMoreThanChipToleranceSetting(intObjectArea, ref intFailMask, ref blnDefect, ref blnTopChipped, intSelectedImageIndex);
                                    }
                                    else // Confirm Right Chipped
                                    {
                                        blnDefect = true;
                                        blnRightChipped = true;
                                        //CheckIsAreaMoreThanChipToleranceSetting(intObjectArea, ref intFailMask, ref blnDefect, ref blnRightChipped, intSelectedImageIndex);
                                    }
                                }
                                else // Confirm Top Chipped
                                {
                                    blnDefect = true;
                                    blnTopChipped = true;
                                    //CheckIsAreaMoreThanChipToleranceSetting(intObjectArea, ref intFailMask, ref blnDefect, ref blnTopChipped, intSelectedImageIndex);
                                }
                            }

                            if (!blnDefect && fEndY > fInterEndY) // Possible Bottom Chipped
                            {
                                if (fStartX < fInterStartX) // Possible Left Chipped
                                {
                                    if (fStartX < (objBlobsROI.ref_ROIHeight - fEndY))  // Confirm Left Chipped
                                    {
                                        blnDefect = true;
                                        blnLeftChipped = true;
                                        //CheckIsAreaMoreThanChipToleranceSetting(intObjectArea, ref intFailMask, ref blnDefect, ref blnLeftChipped, intSelectedImageIndex);
                                    }
                                    else // Confirm Bottom Chipped
                                    {
                                        blnDefect = true;
                                        blnBottomChipped = true;
                                        //CheckIsAreaMoreThanChipToleranceSetting(intObjectArea, ref intFailMask, ref blnDefect, ref blnBottomChipped, intSelectedImageIndex);
                                    }
                                }
                                else if (fEndX > fInterEndX)    // Possible Right Chipped
                                {
                                    if ((objBlobsROI.ref_ROIWidth - fEndX) < (objBlobsROI.ref_ROIHeight - fEndY)) // Confirm Right Chipped
                                    {
                                        blnDefect = true;
                                        blnRightChipped = true;
                                        //CheckIsAreaMoreThanChipToleranceSetting(intObjectArea, ref intFailMask, ref blnDefect, ref blnRightChipped, intSelectedImageIndex);
                                    }
                                    else // Confirm BOttom Chipped
                                    {
                                        blnDefect = true;
                                        blnBottomChipped = true;
                                        //CheckIsAreaMoreThanChipToleranceSetting(intObjectArea, ref intFailMask, ref blnDefect, ref blnBottomChipped, intSelectedImageIndex);
                                    }
                                }
                                else // Confirm Bottom Chipped
                                {
                                    blnDefect = true;
                                    blnBottomChipped = true;
                                    //CheckIsAreaMoreThanChipToleranceSetting(intObjectArea, ref intFailMask, ref blnDefect, ref blnBottomChipped, intSelectedImageIndex);
                                }
                            }
                        }

                        //if (m_arrWantDefectArea[(int)eWantDefect.Chip])   // Want check defect Chipped Off Area 
                        //{
                        //    if (fStartX < fInterStartX) // Possible Left Chipped
                        //    {
                        //        if (fStartY < fInterStartY) // Possible Top Chipped
                        //        {
                        //            if (fStartX < fStartY)  // Confirm Left Chipped
                        //            {
                        //                if (fObjectWidth >= intChipLengthLeft)  // Is Chipped over setting min value
                        //                {
                        //                    if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                    {
                        //                        if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                        {
                        //                            intFailMask |= 0x04;
                        //                            blnDefect = true;
                        //                            blnLeftChipped = true;

                        //                            m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                        }
                        //                        else
                        //                        {
                        //                            intFailMask |= 0;
                        //                            blnDefect = true;
                        //                            blnLeftChipped = true;
                        //                        }
                        //                    }
                        //                }
                        //                else if ((fObjectCenterX - fObjectWidth / 2) > 0)
                        //                {
                        //                    //if (fObjectWidth == intCeilChipLengthLeft - fToleranceLeft)    // Is Chipped same length with chip setting + tolerance
                        //                    if (fObjectWidth >= intCeilChipLengthLeft - fToleranceLeft)    // Is Chipped over chip setting - tolerance
                        //                    {
                        //                        //if ((fToleranceLeft - (fObjectCenterX + fObjectWidth / 2)) <= fToleranceLeft) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        if ((fToleranceLeft - (fObjectCenterX + fObjectWidth / 2)) <= 1) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        {
                        //                            if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                            {
                        //                                if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                                {
                        //                                    intFailMask |= 0x04;
                        //                                    blnDefect = true;
                        //                                    blnLeftChipped = true;
                        //                                    fAddX = fObjectCenterX - fObjectWidth / 2;

                        //                                    m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                                }
                        //                                else
                        //                                {
                        //                                    intFailMask |= 0;
                        //                                    blnDefect = true;
                        //                                    blnLeftChipped = true;
                        //                                    fAddX = fObjectCenterX - fObjectWidth / 2;
                        //                                }

                        //                            }
                        //                        }
                        //                    }
                        //                }
                        //            }
                        //            else // Confirm Top Chipped
                        //            {
                        //                if (fObjectHeight >= intChipLengthTop) // Is Chipped over setting min value
                        //                {
                        //                    if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                    {
                        //                        if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                        {
                        //                            intFailMask |= 0x04;
                        //                            blnDefect = true;
                        //                            blnTopChipped = true;

                        //                            m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                        }
                        //                        else
                        //                        {
                        //                            intFailMask |= 0;
                        //                            blnDefect = true;
                        //                            blnTopChipped = true;
                        //                        }
                        //                    }
                        //                }
                        //                else if ((fObjectCenterY - fObjectHeight / 2) > 0)
                        //                {
                        //                    //if (fObjectHeight == intCeilChipLengthTop - fToleranceTop) // Is Chipped same length with chip setting + tolerance
                        //                    if (fObjectHeight >= intCeilChipLengthTop - fToleranceTop) // Is Chipped over chip setting - tolerance
                        //                    {
                        //                        //if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= fToleranceTop)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= 1)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        {
                        //                            if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                            {
                        //                                if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                                {
                        //                                    intFailMask |= 0x04;
                        //                                    blnDefect = true;
                        //                                    blnTopChipped = true;
                        //                                    fAddY = fObjectCenterY - fObjectHeight / 2;

                        //                                    m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                                }
                        //                                else
                        //                                {
                        //                                    intFailMask |= 0;
                        //                                    blnDefect = true;
                        //                                    blnTopChipped = true;
                        //                                    fAddY = fObjectCenterY - fObjectHeight / 2;
                        //                                }
                        //                            }
                        //                        }
                        //                    }
                        //                }

                        //            }
                        //        }
                        //        else if (fEndY > fInterEndY)    // Possible Bottom Chipped
                        //        {
                        //            if (fStartX < (objBlobsROI.ref_ROIHeight - fEndY)) // Confirm Left Chipped
                        //            {
                        //                if (fObjectWidth >= intChipLengthLeft)  // Is Chipped over setting min value
                        //                {
                        //                    if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                    {
                        //                        if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                        {
                        //                            intFailMask |= 0x04;
                        //                            blnDefect = true;
                        //                            blnLeftChipped = true;

                        //                            m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                        }
                        //                        else
                        //                        {
                        //                            intFailMask |= 0;
                        //                            blnDefect = true;
                        //                            blnLeftChipped = true;
                        //                        }
                        //                    }
                        //                }
                        //                else if ((fObjectCenterX - fObjectWidth / 2) > 0)
                        //                {
                        //                    //if (fObjectWidth == intCeilChipLengthLeft - fToleranceLeft)    // Is Chipped same length with chip setting + tolerance
                        //                    if (fObjectWidth >= intCeilChipLengthLeft - fToleranceLeft)    // Is Chipped over chip setting - tolerance
                        //                    {
                        //                        //if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= fToleranceLeft) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= 1) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        {
                        //                            if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                            {
                        //                                if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                                {
                        //                                    intFailMask |= 0x04;
                        //                                    blnDefect = true;
                        //                                    blnLeftChipped = true;
                        //                                    fAddX = fObjectCenterX - fObjectWidth / 2;

                        //                                    m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                                }
                        //                                else
                        //                                {
                        //                                    intFailMask |= 0;
                        //                                    blnDefect = true;
                        //                                    blnLeftChipped = true;
                        //                                    fAddX = fObjectCenterX - fObjectWidth / 2;
                        //                                }
                        //                            }

                        //                        }
                        //                    }
                        //                }
                        //            }
                        //            else // Confirm BOttom Chipped
                        //            {
                        //                if (fObjectHeight >= intChipLengthBottom) // Is Chipped over setting min value
                        //                {
                        //                    if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                    {
                        //                        if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                        {
                        //                            intFailMask |= 0x04;
                        //                            blnDefect = true;
                        //                            blnBottomChipped = true;

                        //                            m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                        }
                        //                        else
                        //                        {
                        //                            intFailMask |= 0;
                        //                            blnDefect = true;
                        //                            blnBottomChipped = true;
                        //                        }
                        //                    }
                        //                }
                        //                else if ((objBlobsROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2)) > 0)
                        //                {
                        //                    //if (fObjectHeight == intCeilChipLengthBottom - fToleranceBottom) // Is Chipped same length with chip setting + tolerance
                        //                    if (fObjectHeight >= intCeilChipLengthBottom - fToleranceBottom) // Is Chipped over chip setting - tolerance
                        //                    {
                        //                        //if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= fToleranceBottom)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= 1)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        {
                        //                            if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                            {
                        //                                if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                                {
                        //                                    intFailMask |= 0x04;
                        //                                    blnDefect = true;
                        //                                    blnBottomChipped = true;
                        //                                    fAddY = objBlobsROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2);

                        //                                    m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                                }
                        //                                else
                        //                                {
                        //                                    intFailMask |= 0;
                        //                                    blnDefect = true;
                        //                                    blnBottomChipped = true;
                        //                                    fAddY = objBlobsROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2);
                        //                                }
                        //                            }

                        //                        }
                        //                    }
                        //                }
                        //            }
                        //        }
                        //        else // Confirm Left Chipped 
                        //        {
                        //            if (fObjectWidth >= intChipLengthLeft)  // Is Chipped over setting min value
                        //            {
                        //                if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                {
                        //                    if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                    {
                        //                        intFailMask |= 0x04;
                        //                        blnDefect = true;
                        //                        blnLeftChipped = true;

                        //                        m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                    }
                        //                    else
                        //                    {
                        //                        intFailMask |= 0;
                        //                        blnDefect = true;
                        //                        blnLeftChipped = true;
                        //                    }
                        //                }
                        //            }
                        //            else if ((fObjectCenterX - fObjectWidth / 2) > 0)
                        //            {
                        //                //if (fObjectWidth == intCeilChipLengthLeft - fToleranceLeft)    // Is Chipped same length with chip setting + tolerance
                        //                if (fObjectWidth >= intCeilChipLengthLeft - fToleranceLeft) // Is Chipped over chip setting - tolerance
                        //                {
                        //                    //if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= fToleranceLeft) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                    if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= 1) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                    {
                        //                        if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                        {
                        //                            if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                            {
                        //                                intFailMask |= 0x04;
                        //                                blnDefect = true;
                        //                                blnLeftChipped = true;
                        //                                fAddX = fObjectCenterX - fObjectWidth / 2;

                        //                                m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                            }
                        //                            else
                        //                            {
                        //                                intFailMask |= 0;
                        //                                blnDefect = true;
                        //                                blnLeftChipped = true;
                        //                                fAddX = fObjectCenterX - fObjectWidth / 2;
                        //                            }
                        //                        }

                        //                    }
                        //                }
                        //            }
                        //        }
                        //    }

                        //    if (!blnDefect && fEndX > fInterEndX) // Possible Right Chipped
                        //    {
                        //        if (fStartY < fInterStartY) // Possible Top Chipped
                        //        {
                        //            if (fStartY < (objBlobsROI.ref_ROIWidth - fEndX))  // Confirm Top Chipped
                        //            {
                        //                if (fObjectHeight >= intChipLengthTop)  // Is Chipped over setting min value
                        //                {
                        //                    if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                    {
                        //                        if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                        {
                        //                            intFailMask |= 0x04;
                        //                            blnDefect = true;
                        //                            blnTopChipped = true;

                        //                            m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                        }
                        //                        else
                        //                        {
                        //                            intFailMask |= 0;
                        //                            blnDefect = true;
                        //                            blnTopChipped = true;
                        //                        }
                        //                    }
                        //                }
                        //                else if ((fObjectCenterY - fObjectHeight / 2) > 0)
                        //                {
                        //                    //if (fObjectHeight == intCeilChipLengthTop - fToleranceTop) // Is Chipped same length with chip setting + tolerance
                        //                    if (fObjectHeight >= intCeilChipLengthTop - fToleranceTop) // Is Chipped over chip setting - tolerance
                        //                    {
                        //                        //if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= fToleranceTop)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= 1)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        {
                        //                            if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                            {
                        //                                if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                                {
                        //                                    intFailMask |= 0x04;
                        //                                    blnDefect = true;
                        //                                    blnTopChipped = true;
                        //                                    fAddY = fObjectCenterY - fObjectHeight / 2;

                        //                                    m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                                }
                        //                                else
                        //                                {
                        //                                    intFailMask |= 0;
                        //                                    blnDefect = true;
                        //                                    blnTopChipped = true;
                        //                                    fAddY = fObjectCenterY - fObjectHeight / 2;
                        //                                }
                        //                            }
                        //                        }
                        //                    }
                        //                }
                        //            }
                        //            else // Confirm Right Chipped
                        //            {
                        //                if (fObjectWidth >= intChipLengthRight) // Is Chipped over setting min value
                        //                {
                        //                    if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                    {
                        //                        if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                        {
                        //                            intFailMask |= 0x04;
                        //                            blnDefect = true;
                        //                            blnRightChipped = true;

                        //                            m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                        }
                        //                        else
                        //                        {
                        //                            intFailMask |= 0;
                        //                            blnDefect = true;
                        //                            blnRightChipped = true;
                        //                        }
                        //                    }
                        //                }
                        //                else if ((objBlobsROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2)) > 0)
                        //                {
                        //                    //if (fObjectWidth == intCeilChipLengthRight - fToleranceRight)    // Is Chipped same length with chip setting + tolerance
                        //                    if (fObjectWidth >= intCeilChipLengthRight - fToleranceRight) // Is Chipped over chip setting - tolerance
                        //                    {
                        //                        //if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= fToleranceRight) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= 1) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        {
                        //                            if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                            {
                        //                                if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                                {
                        //                                    intFailMask |= 0x04;
                        //                                    blnDefect = true;
                        //                                    blnRightChipped = true;
                        //                                    fAddX = objBlobsROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2);

                        //                                    m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                                }
                        //                                else
                        //                                {
                        //                                    intFailMask |= 0;
                        //                                    blnDefect = true;
                        //                                    blnRightChipped = true;
                        //                                    fAddX = objBlobsROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2);
                        //                                }
                        //                            }
                        //                        }
                        //                    }
                        //                }
                        //            }
                        //        }
                        //        else if (fEndY > fInterEndY)    // Possible Bottom Chipped
                        //        {
                        //            if ((objBlobsROI.ref_ROIWidth - fEndX) < (objBlobsROI.ref_ROIHeight - fEndY)) // Confirm Right Chipped
                        //            {
                        //                if (fObjectWidth >= intChipLengthRight)  // Is Chipped over setting min value
                        //                {
                        //                    if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                    {
                        //                        if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                        {
                        //                            intFailMask |= 0x04;
                        //                            blnDefect = true;
                        //                            blnRightChipped = true;

                        //                            m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                        }
                        //                        else
                        //                        {
                        //                            intFailMask |= 0;
                        //                            blnDefect = true;
                        //                            blnRightChipped = true;
                        //                        }
                        //                    }
                        //                }
                        //                else if ((objBlobsROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2)) > 0)
                        //                {
                        //                    //if (fObjectWidth == intCeilChipLengthRight - fToleranceRight)    // Is Chipped same length with chip setting + tolerance
                        //                    if (fObjectWidth >= intCeilChipLengthRight - fToleranceRight) // Is Chipped over chip setting - tolerance
                        //                    {
                        //                        //if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= fToleranceRight) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= 1) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        {
                        //                            if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                            {
                        //                                if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                                {
                        //                                    intFailMask |= 0x04;
                        //                                    blnDefect = true;
                        //                                    blnRightChipped = true;
                        //                                    fAddX = objBlobsROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2);

                        //                                    m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                                }
                        //                                else
                        //                                {
                        //                                    intFailMask |= 0;
                        //                                    blnDefect = true;
                        //                                    blnRightChipped = true;
                        //                                    fAddX = objBlobsROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2);
                        //                                }
                        //                            }
                        //                        }
                        //                    }
                        //                }
                        //            }
                        //            else // Confirm BOttom Chipped
                        //            {
                        //                if (fObjectHeight >= intChipLengthBottom) // Is Chipped over setting min value
                        //                {
                        //                    if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                    {
                        //                        if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                        {
                        //                            intFailMask |= 0x04;
                        //                            blnDefect = true;
                        //                            blnBottomChipped = true;

                        //                            m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                        }
                        //                        else
                        //                        {
                        //                            intFailMask |= 0;
                        //                            blnDefect = true;
                        //                            blnBottomChipped = true;
                        //                        }
                        //                    }
                        //                }
                        //                else if ((objBlobsROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2)) > 0)
                        //                {
                        //                    //if (fObjectHeight == intCeilChipLengthBottom - fToleranceBottom) // Is Chipped same length with chip setting + tolerance
                        //                    if (fObjectHeight >= intCeilChipLengthBottom - fToleranceBottom) // Is Chipped over chip setting - tolerance
                        //                    {
                        //                        //if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= fToleranceBottom)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= 1)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        {
                        //                            if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                            {
                        //                                if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                                {
                        //                                    intFailMask |= 0x04;
                        //                                    blnDefect = true;
                        //                                    blnBottomChipped = true;
                        //                                    fAddY = objBlobsROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2);

                        //                                    m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                                }
                        //                                else
                        //                                {
                        //                                    intFailMask |= 0;
                        //                                    blnDefect = true;
                        //                                    blnBottomChipped = true;
                        //                                    fAddY = objBlobsROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2);
                        //                                }
                        //                            }
                        //                        }
                        //                    }
                        //                }
                        //            }
                        //        }
                        //        else // Confirm Right Chipped
                        //        {
                        //            if (fObjectWidth >= intChipLengthRight)  // Is Chipped over setting min value
                        //            {
                        //                if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                {
                        //                    if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                    {
                        //                        intFailMask |= 0x04;
                        //                        blnDefect = true;
                        //                        blnRightChipped = true;

                        //                        m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                    }
                        //                    else
                        //                    {
                        //                        intFailMask |= 0;
                        //                        blnDefect = true;
                        //                        blnRightChipped = true;
                        //                    }

                        //                }
                        //            }
                        //            else if ((objBlobsROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2)) > 0)
                        //            {
                        //                //if (fObjectWidth == intCeilChipLengthRight - fToleranceRight)    // Is Chipped same length with chip setting + tolerance
                        //                if (fObjectWidth >= intCeilChipLengthRight - fToleranceRight) // Is Chipped over chip setting - tolerance
                        //                {
                        //                    //if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= fToleranceRight) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                    if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= 1) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                    {
                        //                        if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                        {
                        //                            if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                            {
                        //                                intFailMask |= 0x04;
                        //                                blnDefect = true;
                        //                                blnRightChipped = true;
                        //                                fAddX = objBlobsROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2);

                        //                                m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                            }
                        //                            else
                        //                            {
                        //                                intFailMask |= 0;
                        //                                blnDefect = true;
                        //                                blnRightChipped = true;
                        //                                fAddX = objBlobsROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2);
                        //                            }
                        //                        }
                        //                    }
                        //                }
                        //            }
                        //        }
                        //    }

                        //    if (!blnDefect && fStartY < fInterStartY) // Possible Top chipped
                        //    {
                        //        if (fStartX < fInterStartX) // Possible Left Chipped
                        //        {
                        //            if (fStartX < fStartY)  // Confirm Left Chipped
                        //            {
                        //                if (fObjectWidth >= intChipLengthLeft)  // Is Chipped over setting min value
                        //                {
                        //                    if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                    {
                        //                        if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                        {
                        //                            intFailMask |= 0x04;
                        //                            blnDefect = true;
                        //                            blnLeftChipped = true;

                        //                            m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                        }
                        //                        else
                        //                        {
                        //                            intFailMask |= 0;
                        //                            blnDefect = true;
                        //                            blnLeftChipped = true;
                        //                        }

                        //                    }
                        //                }
                        //                else if ((fObjectCenterX - fObjectWidth / 2) > 0)
                        //                {
                        //                    //if (fObjectWidth == intCeilChipLengthLeft - fToleranceLeft)    // Is Chipped same length with chip setting + tolerance
                        //                    if (fObjectWidth >= intCeilChipLengthLeft - fToleranceLeft) // Is Chipped over chip setting - tolerance
                        //                    {
                        //                        //if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= fToleranceLeft) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= 1) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        {
                        //                            if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                            {
                        //                                if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                                {
                        //                                    intFailMask |= 0x04;
                        //                                    blnDefect = true;
                        //                                    blnLeftChipped = true;
                        //                                    fAddX = fObjectCenterX - fObjectWidth / 2;

                        //                                    m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                                }
                        //                                else
                        //                                {
                        //                                    intFailMask |= 0;
                        //                                    blnDefect = true;
                        //                                    blnLeftChipped = true;
                        //                                    fAddX = fObjectCenterX - fObjectWidth / 2;
                        //                                }
                        //                            }

                        //                        }
                        //                    }
                        //                }

                        //            }
                        //            else // Confirm Top Chipped
                        //            {
                        //                if (fObjectHeight >= intChipLengthTop) // Is Chipped over setting min value
                        //                {
                        //                    if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                    {
                        //                        if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                        {
                        //                            intFailMask |= 0x04;
                        //                            blnDefect = true;
                        //                            blnTopChipped = true;

                        //                            m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                        }
                        //                        else
                        //                        {
                        //                            intFailMask |= 0;
                        //                            blnDefect = true;
                        //                            blnTopChipped = true;
                        //                        }

                        //                    }
                        //                }
                        //                else if ((fObjectCenterY - fObjectHeight / 2) > 0)
                        //                {
                        //                    //if (fObjectHeight == intCeilChipLengthTop - fToleranceTop) // Is Chipped same length with chip setting + tolerance
                        //                    if (fObjectHeight >= intCeilChipLengthTop - fToleranceTop) // Is Chipped over chip setting - tolerance
                        //                    {
                        //                        //if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= fToleranceTop)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= 1)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        {
                        //                            if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                            {
                        //                                if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                                {
                        //                                    intFailMask |= 0x04;
                        //                                    blnDefect = true;
                        //                                    blnTopChipped = true;
                        //                                    fAddY = fObjectCenterY - fObjectHeight / 2;

                        //                                    m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                                }
                        //                                else
                        //                                {
                        //                                    intFailMask |= 0;
                        //                                    blnDefect = true;
                        //                                    blnTopChipped = true;
                        //                                    fAddY = fObjectCenterY - fObjectHeight / 2;
                        //                                }

                        //                            }
                        //                        }
                        //                    }
                        //                }
                        //            }
                        //        }
                        //        else if (fEndX > fInterEndX)    // Possible Right Chipped
                        //        {
                        //            if (fStartY < (objBlobsROI.ref_ROIWidth - fEndX)) // Confirm Top Chipped
                        //            {
                        //                if (fObjectHeight >= intChipLengthTop)  // Is Chipped over setting min value
                        //                {
                        //                    if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                    {
                        //                        if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                        {
                        //                            intFailMask |= 0x04;
                        //                            blnDefect = true;
                        //                            blnTopChipped = true;

                        //                            m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                        }
                        //                        else
                        //                        {
                        //                            intFailMask |= 0;
                        //                            blnDefect = true;
                        //                            blnTopChipped = true;
                        //                        }

                        //                    }
                        //                }
                        //                else if ((fObjectCenterY - fObjectHeight / 2) > 0)
                        //                {
                        //                    //if (fObjectHeight == intCeilChipLengthTop - fToleranceTop) // Is Chipped same length with chip setting + tolerance
                        //                    if (fObjectHeight >= intCeilChipLengthTop - fToleranceTop) // Is Chipped over chip setting - tolerance
                        //                    {
                        //                        //if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= fToleranceTop)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= 1)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        {
                        //                            if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                            {
                        //                                if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                                {
                        //                                    intFailMask |= 0x04;
                        //                                    blnDefect = true;
                        //                                    blnTopChipped = true;
                        //                                    fAddY = fObjectCenterY - fObjectHeight / 2;

                        //                                    m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                                }
                        //                                else
                        //                                {
                        //                                    intFailMask |= 0;
                        //                                    blnDefect = true;
                        //                                    blnTopChipped = true;
                        //                                    fAddY = fObjectCenterY - fObjectHeight / 2;
                        //                                }
                        //                            }
                        //                        }
                        //                    }
                        //                }
                        //            }
                        //            else // Confirm Right Chipped
                        //            {
                        //                if (fObjectWidth >= intChipLengthRight) // Is Chipped over setting min value
                        //                {
                        //                    if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                    {
                        //                        if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                        {
                        //                            intFailMask |= 0x04;
                        //                            blnDefect = true;
                        //                            blnRightChipped = true;

                        //                            m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                        }
                        //                        else
                        //                        {
                        //                            intFailMask |= 0;
                        //                            blnDefect = true;
                        //                            blnRightChipped = true;
                        //                        }

                        //                    }
                        //                }
                        //                else if ((objBlobsROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2)) > 0)
                        //                {
                        //                    //if (fObjectWidth == intCeilChipLengthRight - fToleranceRight)    // Is Chipped same length with chip setting + tolerance
                        //                    if (fObjectWidth >= intCeilChipLengthRight - fToleranceRight) // Is Chipped over chip setting - tolerance
                        //                    {
                        //                        //if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= fToleranceRight) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= 1) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        {
                        //                            if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                            {
                        //                                if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                                {
                        //                                    intFailMask |= 0x04;
                        //                                    blnDefect = true;
                        //                                    blnRightChipped = true;
                        //                                    fAddX = objBlobsROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2);

                        //                                    m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                                }
                        //                                else
                        //                                {
                        //                                    intFailMask |= 0;
                        //                                    blnDefect = true;
                        //                                    blnRightChipped = true;
                        //                                    fAddX = objBlobsROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2);
                        //                                }
                        //                            }
                        //                        }
                        //                    }
                        //                }
                        //            }
                        //        }
                        //        else // Confirm Top Chipped
                        //        {
                        //            if (fObjectHeight >= intChipLengthTop)  // Is Chipped over setting min value
                        //            {
                        //                if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                {
                        //                    if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                    {
                        //                        intFailMask |= 0x04;
                        //                        blnDefect = true;
                        //                        blnTopChipped = true;

                        //                        m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                    }
                        //                    else
                        //                    {
                        //                        intFailMask |= 0;
                        //                        blnDefect = true;
                        //                        blnTopChipped = true;
                        //                    }
                        //                }
                        //            }
                        //            else if ((fObjectCenterY - fObjectHeight / 2) > 0)
                        //            {
                        //                //if (fObjectHeight == intCeilChipLengthTop - fToleranceTop) // Is Chipped same length with chip setting + tolerance
                        //                if (fObjectHeight >= intCeilChipLengthTop - fToleranceTop) // Is Chipped over chip setting - tolerance
                        //                {
                        //                    //if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= fToleranceTop)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                    if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= 1)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                    {
                        //                        if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                        {
                        //                            if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                            {
                        //                                intFailMask |= 0x04;
                        //                                blnDefect = true;
                        //                                blnTopChipped = true;
                        //                                fAddY = fObjectCenterY - fObjectHeight / 2;

                        //                                m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                            }
                        //                            else
                        //                            {
                        //                                intFailMask |= 0;
                        //                                blnDefect = true;
                        //                                blnTopChipped = true;
                        //                                fAddY = fObjectCenterY - fObjectHeight / 2;
                        //                            }
                        //                        }
                        //                    }
                        //                }
                        //            }
                        //        }
                        //    }

                        //    if (!blnDefect && fEndY > fInterEndY) // Possible Bottom Chipped
                        //    {
                        //        if (fStartX < fInterStartX) // Possible Left Chipped
                        //        {
                        //            if (fStartX < (objBlobsROI.ref_ROIHeight - fEndY))  // Confirm Left Chipped
                        //            {
                        //                if (fObjectWidth >= intChipLengthLeft)  // Is Chipped over setting min value
                        //                {
                        //                    if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                    {
                        //                        if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                        {
                        //                            intFailMask |= 0x04;
                        //                            blnDefect = true;
                        //                            blnLeftChipped = true;

                        //                            m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                        }
                        //                        else
                        //                        {
                        //                            intFailMask |= 0;
                        //                            blnDefect = true;
                        //                            blnLeftChipped = true;
                        //                        }
                        //                    }
                        //                }
                        //                else if ((fObjectCenterX - fObjectWidth / 2) > 0)
                        //                {
                        //                    //if (fObjectWidth == intCeilChipLengthLeft - fToleranceLeft)    // Is Chipped same length with chip setting + tolerance
                        //                    if (fObjectWidth >= intCeilChipLengthLeft - fToleranceLeft) // Is Chipped over chip setting - tolerance
                        //                    {
                        //                        //if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= fToleranceLeft) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= 1) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        {
                        //                            if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                            {
                        //                                if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                                {
                        //                                    intFailMask |= 0x04;
                        //                                    blnDefect = true;
                        //                                    blnLeftChipped = true;
                        //                                    fAddX = fObjectCenterX - fObjectWidth / 2;

                        //                                    m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                                }
                        //                                else
                        //                                {
                        //                                    intFailMask |= 0;
                        //                                    blnDefect = true;
                        //                                    blnLeftChipped = true;
                        //                                    fAddX = fObjectCenterX - fObjectWidth / 2;
                        //                                }
                        //                            }
                        //                        }
                        //                    }
                        //                }

                        //            }
                        //            else // Confirm Bottom Chipped
                        //            {
                        //                if (fObjectHeight >= intChipLengthBottom) // Is Chipped over setting min value
                        //                {
                        //                    if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                    {
                        //                        if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                        {
                        //                            intFailMask |= 0x04;
                        //                            blnDefect = true;
                        //                            blnBottomChipped = true;

                        //                            m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                        }
                        //                        else
                        //                        {
                        //                            intFailMask |= 0;
                        //                            blnDefect = true;
                        //                            blnBottomChipped = true;
                        //                        }
                        //                    }
                        //                }
                        //                else if ((objBlobsROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2)) > 0)
                        //                {
                        //                    //if (fObjectHeight == intCeilChipLengthBottom - fToleranceBottom) // Is Chipped same length with chip setting + tolerance
                        //                    if (fObjectHeight >= intCeilChipLengthBottom - fToleranceBottom) // Is Chipped over chip setting - tolerance
                        //                    {
                        //                        //if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= fToleranceBottom)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= 1)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        {
                        //                            if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                            {
                        //                                if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                                {
                        //                                    intFailMask |= 0x04;
                        //                                    blnDefect = true;
                        //                                    blnBottomChipped = true;
                        //                                    fAddY = objBlobsROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2);

                        //                                    m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                                }
                        //                                else
                        //                                {
                        //                                    intFailMask |= 0;
                        //                                    blnDefect = true;
                        //                                    blnBottomChipped = true;
                        //                                    fAddY = objBlobsROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2);
                        //                                }
                        //                            }
                        //                        }
                        //                    }
                        //                }
                        //            }
                        //        }
                        //        else if (fEndX > fInterEndX)    // Possible Right Chipped
                        //        {
                        //            if ((objBlobsROI.ref_ROIWidth - fEndX) < (objBlobsROI.ref_ROIHeight - fEndY)) // Confirm Right Chipped
                        //            {
                        //                if (fObjectWidth >= intChipLengthRight)  // Is Chipped over setting min value
                        //                {
                        //                    if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                    {
                        //                        if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                        {
                        //                            intFailMask |= 0x04;
                        //                            blnDefect = true;
                        //                            blnRightChipped = true;

                        //                            m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                        }
                        //                        else
                        //                        {
                        //                            intFailMask |= 0;
                        //                            blnDefect = true;
                        //                            blnRightChipped = true;
                        //                        }
                        //                    }
                        //                }
                        //                else if ((objBlobsROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2)) > 0)
                        //                {
                        //                    //if (fObjectWidth == intCeilChipLengthRight - fToleranceRight)    // Is Chipped same length with chip setting + tolerance
                        //                    if (fObjectWidth >= intCeilChipLengthRight - fToleranceRight) // Is Chipped over chip setting - tolerance
                        //                    {
                        //                        //if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= fToleranceRight) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= 1) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        {
                        //                            if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                            {
                        //                                if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                                {
                        //                                    intFailMask |= 0x04;
                        //                                    blnDefect = true;
                        //                                    blnRightChipped = true;
                        //                                    fAddX = objBlobsROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2);

                        //                                    m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                                }
                        //                                else
                        //                                {
                        //                                    intFailMask |= 0;
                        //                                    blnDefect = true;
                        //                                    blnRightChipped = true;
                        //                                    fAddX = objBlobsROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2);
                        //                                }
                        //                            }
                        //                        }
                        //                    }
                        //                }
                        //            }
                        //            else // Confirm BOttom Chipped
                        //            {
                        //                if (fObjectHeight >= intChipLengthBottom) // Is Chipped over setting min value
                        //                {
                        //                    if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                    {
                        //                        if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                        {
                        //                            intFailMask |= 0x04;
                        //                            blnDefect = true;
                        //                            blnBottomChipped = true;


                        //                            m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                        }
                        //                        else
                        //                        {
                        //                            intFailMask |= 0;
                        //                            blnDefect = true;
                        //                            blnBottomChipped = true;
                        //                        }
                        //                    }
                        //                }
                        //                else if ((objBlobsROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2)) > 0)
                        //                {
                        //                    //if (fObjectHeight == intCeilChipLengthBottom - fToleranceBottom) // Is Chipped same length with chip setting + tolerance
                        //                    if (fObjectHeight >= intCeilChipLengthBottom - fToleranceBottom) // Is Chipped over chip setting - tolerance
                        //                    {
                        //                        //if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= fToleranceBottom)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= 1)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                        {
                        //                            if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                            {
                        //                                if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                                {
                        //                                    intFailMask |= 0x04;
                        //                                    blnDefect = true;
                        //                                    blnBottomChipped = true;
                        //                                    fAddY = objBlobsROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2);

                        //                                    m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                                }
                        //                                else
                        //                                {
                        //                                    intFailMask |= 0;
                        //                                    blnDefect = true;
                        //                                    blnBottomChipped = true;
                        //                                    fAddY = objBlobsROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2);
                        //                                }
                        //                            }
                        //                        }
                        //                    }
                        //                }
                        //            }
                        //        }
                        //        else // Confirm Bottom Chipped
                        //        {
                        //            if (fObjectHeight >= intChipLengthBottom)  // Is Chipped over setting min value
                        //            {
                        //                if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                {
                        //                    if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                    {
                        //                        intFailMask |= 0x04;
                        //                        blnDefect = true;
                        //                        blnBottomChipped = true;

                        //                        m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                    }
                        //                    else
                        //                    {
                        //                        intFailMask |= 0;
                        //                        blnDefect = true;
                        //                        blnBottomChipped = true;
                        //                    }
                        //                }
                        //            }
                        //            else if ((objBlobsROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2)) > 0)
                        //            {
                        //                //if (fObjectHeight == intCeilChipLengthBottom - fToleranceBottom) // Is Chipped same length with chip setting + tolerance
                        //                if (fObjectHeight >= intCeilChipLengthBottom - fToleranceBottom) // Is Chipped over chip setting - tolerance
                        //                {
                        //                    //if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= fToleranceBottom)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                    if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= 1)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                        //                    {
                        //                        if (m_arrWantDefectArea[(int)eWantDefect.Chip])
                        //                        {
                        //                            if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                        //                            {
                        //                                intFailMask |= 0x04;
                        //                                blnDefect = true;
                        //                                blnBottomChipped = true;
                        //                                fAddY = objBlobsROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2);

                        //                                m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                        //                            }
                        //                            else
                        //                            {
                        //                                intFailMask |= 0;
                        //                                blnDefect = true;
                        //                                blnBottomChipped = true;
                        //                                fAddY = objBlobsROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2);
                        //                            }
                        //                        }
                        //                    }
                        //                }
                        //            }
                        //        }
                        //    }
                        //}



                        if (blnDefect)
                        {
                            if (m_arrWantDefectArea[intChipType] || m_arrWantDefectLength[intChipType])   // Want check defect Chipped Off Area 
                            {
                                Defect objDefect = new Defect();

                                //To determine the object width or height is over the chipped tolerance
                                if (blnTopChipped || blnBottomChipped)
                                {
                                    objDefect.ref_fDimX = fObjectWidth;
                                    objDefect.ref_fDimY = fObjectHeight + fAddY;
                                    objDefect.ref_intLengthMode = 0;
                                }
                                else if (blnLeftChipped || blnRightChipped)
                                {
                                    objDefect.ref_fDimY = fObjectWidth + fAddX;
                                    objDefect.ref_fDimX = fObjectHeight;
                                    objDefect.ref_intLengthMode = 1;
                                }

                                if (m_arrWantDefectArea[intChipType])
                                {
                                    if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                                    {
                                        intFailMask |= 0x04;
                                        m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                                    }
                                }

                                if (m_arrWantDefectLength[intChipType])
                                {
                                    float fWidthLimit = GetDefect("Chip", 0);
                                    float fLengthLimit = GetDefect("Chip", 1);

                                    int intFailCondition = m_intChippedDarkDefectDimensionFailCondition;
                                    if (m_blnBrightChipDefect)
                                        intFailCondition = m_intChippedBrightDefectDimensionFailCondition;

                                    if (blnTopChipped || blnBottomChipped)
                                    {
                                        if (intFailCondition == 0)
                                        {
                                            // Top Left Border + LengthMode 0
                                            // ------------------------------------ 
                                            // X : fDimX, fWidthLimit, FailMask=0x01, Fail Message label width
                                            // Y : fDimY, fLengthLimit, FailMask=0x02, Fail Message label length

                                            if (objDefect.ref_fDimX >= fWidthLimit)  // Is Chipped over setting min value
                                            {
                                                intFailMask |= 0x01;
                                                m_strErrorMessage += "*Chipped Off Width Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (fWidthLimit / m_fMMToPixelXValue).ToString("f4") + " mm,   Result = " + (objDefect.ref_fDimX / m_fMMToPixelXValue).ToString("f4") + " mm";
                                            }
                                            if (objDefect.ref_fDimY >= fLengthLimit)  // Is Chipped over setting min value
                                            {
                                                intFailMask |= 0x02;
                                                m_strErrorMessage += "*Chipped Off Length Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (fLengthLimit / m_fMMToPixelYValue).ToString("f4") + " mm,   Result = " + (objDefect.ref_fDimY / m_fMMToPixelYValue).ToString("f4") + " mm";
                                            }
                                        }
                                        else
                                        {
                                            if ((objDefect.ref_fDimX >= fWidthLimit) && (objDefect.ref_fDimY >= fLengthLimit))  // Is Chipped over setting min value
                                            {
                                                intFailMask |= 0x01;
                                                intFailMask |= 0x02;
                                                m_strErrorMessage += "*Chipped Off Width Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (fWidthLimit / m_fMMToPixelXValue).ToString("f4") + " mm,   Result = " + (objDefect.ref_fDimX / m_fMMToPixelXValue).ToString("f4") + " mm";
                                                m_strErrorMessage += "*Chipped Off Length Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (fLengthLimit / m_fMMToPixelYValue).ToString("f4") + " mm,   Result = " + (objDefect.ref_fDimY / m_fMMToPixelYValue).ToString("f4") + " mm";
                                            }
                                        }
                                    }
                                    else if (blnLeftChipped || blnRightChipped)
                                    {
                                        if (objDefect.ref_intLengthMode == 0)
                                        {
                                            // Left Right Border + LengthMode 0
                                            // ------------------------------------ 
                                            // X : fDimX, fLengthLimit, FailMask=0x01
                                            // Y : fDimY, fWidthLimit, FailMask=0x02

                                            if (intFailCondition == 0)
                                            {
                                                if (objDefect.ref_fDimY >= fWidthLimit)  // Is Chipped over setting min value
                                                {
                                                    intFailMask |= 0x02;
                                                    m_strErrorMessage += "*Chipped Off Length Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (fWidthLimit / m_fMMToPixelXValue).ToString("f4") + " mm,   Result = " + (objDefect.ref_fDimY / m_fMMToPixelXValue).ToString("f4") + " mm";
                                                }
                                                if (objDefect.ref_fDimX >= fLengthLimit)  // Is Chipped over setting min value
                                                {
                                                    intFailMask |= 0x01;
                                                    m_strErrorMessage += "*Chipped Off Width Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (fLengthLimit / m_fMMToPixelYValue).ToString("f4") + " mm,   Result = " + (objDefect.ref_fDimX / m_fMMToPixelYValue).ToString("f4") + " mm";
                                                }
                                            }
                                            else
                                            {
                                                if ((objDefect.ref_fDimY >= fWidthLimit) && (objDefect.ref_fDimX >= fLengthLimit))  // Is Chipped over setting min value
                                                {
                                                    intFailMask |= 0x01;
                                                    intFailMask |= 0x02;
                                                    m_strErrorMessage += "*Chipped Off Length Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (fWidthLimit / m_fMMToPixelXValue).ToString("f4") + " mm,   Result = " + (objDefect.ref_fDimY / m_fMMToPixelXValue).ToString("f4") + " mm";
                                                    m_strErrorMessage += "*Chipped Off Width Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (fLengthLimit / m_fMMToPixelYValue).ToString("f4") + " mm,   Result = " + (objDefect.ref_fDimX / m_fMMToPixelYValue).ToString("f4") + " mm";
                                                }
                                            }
                                        }
                                        else
                                        {
                                            // Left Right Border + LengthMode 1
                                            // ------------------------------------ 
                                            // X : fDimX, fWidthLimit, FailMask=0x01, Fail Message label Width
                                            // Y : fDimY, fLengthLimit, FailMask=0x02, Fail Message label length

                                            if (intFailCondition == 0)
                                            {
                                                if (objDefect.ref_fDimX >= fWidthLimit)  // Is Chipped over setting min value
                                                {
                                                    intFailMask |= 0x01;
                                                    m_strErrorMessage += "*Chipped Off Width Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (fWidthLimit / m_fMMToPixelXValue).ToString("f4") + " mm,   Result = " + (objDefect.ref_fDimX / m_fMMToPixelXValue).ToString("f4") + " mm";
                                                }
                                                if (objDefect.ref_fDimY >= fLengthLimit)  // Is Chipped over setting min value
                                                {
                                                    intFailMask |= 0x02;
                                                    m_strErrorMessage += "*Chipped Off Length Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (fLengthLimit / m_fMMToPixelYValue).ToString("f4") + " mm,   Result = " + (objDefect.ref_fDimY / m_fMMToPixelYValue).ToString("f4") + " mm";
                                                }
                                            }
                                            else
                                            {
                                                if ((objDefect.ref_fDimX >= fWidthLimit) && (objDefect.ref_fDimY >= fLengthLimit))  // Is Chipped over setting min value
                                                {
                                                    intFailMask |= 0x01;
                                                    intFailMask |= 0x02;
                                                    m_strErrorMessage += "*Chipped Off Width Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (fWidthLimit / m_fMMToPixelXValue).ToString("f4") + " mm,   Result = " + (objDefect.ref_fDimX / m_fMMToPixelXValue).ToString("f4") + " mm";
                                                    m_strErrorMessage += "*Chipped Off Length Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (fLengthLimit / m_fMMToPixelYValue).ToString("f4") + " mm,   Result = " + (objDefect.ref_fDimY / m_fMMToPixelYValue).ToString("f4") + " mm";
                                                }
                                            }
                                        }
                                    }
                                }

                                //objDefect.ref_fDimX = fObjectWidth;
                                //objDefect.ref_fDimY = fObjectHeight;
                                objDefect.ref_fArea = intObjectArea;
                                objDefect.ref_fCenterX = intTotalROIStartX + fObjectCenterX;
                                objDefect.ref_fCenterY = intTotalROIStartY + fObjectCenterY;
                                objDefect.ref_intBlobNo = i;
                                objDefect.ref_intFailMask = intFailMask;
                                m_intPkgFailResultMask |= 0x02;
                                objDefect.ref_strName = "Img " + (intSelectedImageIndex + 1).ToString() + " Chipped";
                                objDefect.ref_intFailedImage = intSelectedImageIndex + 1;

				objDefect.ref_fAngle = fAngle;

                                m_arrDefectList.Add(objDefect);

                                if (intFailMask > 0)
                                {
                                    if (!blnOverAllFail)
                                        blnOverAllFail = true;
                                }
                            }
                        }
                    }

                }
            }

            if (blnOverAllFail)
                return false;
            else
                return true;
        }
        private bool InspectChipPackage_Area_NoSeparateDirection(float fCenterX, float fCenterY, float fWidth, float fHeight, ImageDrawing objImage, int intThreshold,
                          int intTotalROIStartX, int intTotalROIStartY, int intChipLineLimitPixelValue, int intChipViewMinAreaSetting, ImageDrawing objWhiteImage, ImageDrawing objBlackImage)
        {
            if (objImage.ref_intImageHeight == 0 || objImage.ref_intImageWidth == 0)
                return true;

            if ((m_intPkgFailMask & 0x02) == 0)
                return true;

            bool blnDebug = false;
            int intSelectedImageIndex;

            int intChipType = (int)eWantDefect.ChipBright;
            if (intChipLineLimitPixelValue == 255)
            {
                intChipType = (int)eWantDefect.ChipDark;
            }

            int intCeilChipLengthTop = 0; // (int)Math.Ceiling(m_arrDefectHorizontal[1]);
            int intCeilChipLengthRight = 0;  //(int)Math.Ceiling(m_arrDefectHorizontal[1]);
            int intCeilChipLengthBottom = 0; //(int)Math.Ceiling(m_arrDefectHorizontal[1]);
            int intCeilChipLengthLeft = 0;  //(int)Math.Ceiling(m_arrDefectHorizontal[1]);

            if (intChipLineLimitPixelValue == 0)    // White field defect (Scratches, contamination, chip)
            {
                intCeilChipLengthTop = m_intStartPixelFromEdge_Chip - m_intStartPixelExtendFromEdge_Chip;
                intCeilChipLengthRight = m_intStartPixelFromRight_Chip - m_intStartPixelExtendFromRight_Chip;
                intCeilChipLengthBottom = m_intStartPixelFromBottom_Chip - m_intStartPixelExtendFromBottom_Chip;
                intCeilChipLengthLeft = m_intStartPixelFromLeft_Chip - m_intStartPixelExtendFromLeft_Chip;

                intSelectedImageIndex = m_arrGrabImageIndex[2];
            }
            else // Black field defect (Crack, void, chip)
            {
                intCeilChipLengthTop = m_intStartPixelFromEdge_Chip_Dark - m_intStartPixelExtendFromEdge_Chip_Dark;
                intCeilChipLengthRight = m_intStartPixelFromRight_Chip_Dark - m_intStartPixelExtendFromRight_Chip_Dark;
                intCeilChipLengthBottom = m_intStartPixelFromBottom_Chip_Dark - m_intStartPixelExtendFromBottom_Chip_Dark;
                intCeilChipLengthLeft = m_intStartPixelFromLeft_Chip_Dark - m_intStartPixelExtendFromLeft_Chip_Dark;

                intSelectedImageIndex = m_arrGrabImageIndex[3];
            }

            if (blnDebug)
                objImage.SaveImage("D:\\TS\\1.ChippedOffImage.bmp");

            ROI objROIInner = new ROI();
            ROI objWhiteROI = new ROI();
            objWhiteROI.AttachImage(objWhiteImage);
            objROIInner.AttachImage(objImage);
            objROIInner.LoadROISetting(intCeilChipLengthLeft, intCeilChipLengthTop, objImage.ref_intImageWidth - intCeilChipLengthLeft - intCeilChipLengthRight, objImage.ref_intImageHeight - intCeilChipLengthTop - intCeilChipLengthBottom);
            objWhiteROI.LoadROISetting(intCeilChipLengthLeft, intCeilChipLengthTop, objImage.ref_intImageWidth - intCeilChipLengthLeft - intCeilChipLengthRight, objImage.ref_intImageHeight - intCeilChipLengthTop - intCeilChipLengthBottom);

            if (intChipLineLimitPixelValue == 0)
            {
                ROI.SubtractROI(objROIInner, objWhiteROI);
            }
            else
            {
                ROI.LogicOperationAddROI(objROIInner, objWhiteROI);
            }
            objROIInner.Dispose();
            objWhiteROI.Dispose();
            if (blnDebug)
                objImage.SaveImage("D:\\TS\\2.ChippedOffImageFillChipLineLimitToCorner.bmp");

            ROI objBlobsROI = new ROI();
            objBlobsROI.AttachImage(objImage);
            objBlobsROI.LoadROISetting(0, 0, objImage.ref_intImageWidth, objImage.ref_intImageHeight);
            if (blnDebug)
                objBlobsROI.SaveImage("D:\\TS\\3.objBlobsROI.bmp");
            int intMinValue;
            if (intChipViewMinAreaSetting == 0)
                intMinValue = m_intChipView1MinArea;
            else
                intMinValue = m_intChipView2MinArea;

            bool bWhiteOnBlack;
            if (intChipLineLimitPixelValue == 0)
                bWhiteOnBlack = true;    // detect white on black - white is the chip
            else
                bWhiteOnBlack = false;   // detect black on white - black is the chip

            int intSelectedObject = m_objEBlobs.BuildObjects_Filter_GetElement(objBlobsROI, !bWhiteOnBlack, true, 0, intThreshold,
                intMinValue, objBlobsROI.ref_ROIWidth * objBlobsROI.ref_ROIHeight + 1, false, 0x0D);

            bool blnOverAllFail = false;
            if (intSelectedObject > 0)
            {
                int intObjectArea = 0;
                float fObjectHeight = 0, fObjectWidth = 0, fObjectCenterX = 0, fObjectCenterY = 0;
               
                float fOuterEndX = objBlobsROI.ref_ROIWidth;
                float fOuterEndY = objBlobsROI.ref_ROIHeight;
                float fInterStartX = intCeilChipLengthLeft;// m_intStartPixelFromLeft_Chip; // m_arrDefectHorizontal[1];
                float fInterStartY = intCeilChipLengthTop;//m_intStartPixelFromEdge_Chip; // m_arrDefectHorizontal[1];
                float fInterEndX = (float)objBlobsROI.ref_ROIWidth - intCeilChipLengthRight; //- m_arrDefectHorizontal[1] - 1;
                float fInterEndY = (float)objBlobsROI.ref_ROIHeight - intCeilChipLengthBottom;  //- m_arrDefectHorizontal[1] - 1;
                int intChipLengthTop = intCeilChipLengthTop;// m_intStartPixelFromEdge_Chip;
                int intChipLengthRight = intCeilChipLengthRight;// m_intStartPixelFromRight_Chip;
                int intChipLengthBottom = intCeilChipLengthBottom;// m_intStartPixelFromBottom_Chip;
                int intChipLengthLeft = intCeilChipLengthLeft;// m_intStartPixelFromLeft_Chip;
                if (intChipLineLimitPixelValue == 0)    // White field defect (Scratches, contamination, chip)
                {
                    intChipLengthTop -= m_intStartPixelExtendFromEdge_Chip;
                    intChipLengthRight -= m_intStartPixelExtendFromRight_Chip;
                    intChipLengthBottom -= m_intStartPixelExtendFromBottom_Chip;
                    intChipLengthLeft -= m_intStartPixelExtendFromLeft_Chip;

                    intCeilChipLengthTop -= m_intStartPixelExtendFromEdge_Chip;
                    intCeilChipLengthRight -= m_intStartPixelExtendFromRight_Chip;
                    intCeilChipLengthBottom -= m_intStartPixelExtendFromBottom_Chip;
                    intCeilChipLengthLeft -= m_intStartPixelExtendFromLeft_Chip;
                }
                else // Black field defect (Crack, void, chip)
                {
                    intChipLengthTop -= m_intStartPixelExtendFromEdge_Chip_Dark;
                    intChipLengthRight -= m_intStartPixelExtendFromRight_Chip_Dark;
                    intChipLengthBottom -= m_intStartPixelExtendFromBottom_Chip_Dark;
                    intChipLengthLeft -= m_intStartPixelExtendFromLeft_Chip_Dark;

                    intCeilChipLengthTop -= m_intStartPixelExtendFromEdge_Chip_Dark;
                    intCeilChipLengthRight -= m_intStartPixelExtendFromRight_Chip_Dark;
                    intCeilChipLengthBottom -= m_intStartPixelExtendFromBottom_Chip_Dark;
                    intCeilChipLengthLeft -= m_intStartPixelExtendFromLeft_Chip_Dark;
                }
                int intFailMask = 0;

                for (int i = 0; i < intSelectedObject; i++)
                {
                    intObjectArea = m_objEBlobs.ref_arrArea[i];
                    fObjectHeight = m_objEBlobs.ref_arrHeight[i];
                    fObjectWidth = m_objEBlobs.ref_arrWidth[i];
                    fObjectCenterX = m_objEBlobs.ref_arrLimitCenterX[i];
                    fObjectCenterY = m_objEBlobs.ref_arrLimitCenterY[i];
                    intFailMask = 0;

                    if (true)
                    {
                        //fStartX = fObjectCenterX - (fObjectWidth / 2);
                        //fStartY = fObjectCenterY - (fObjectHeight / 2);
                        //fEndX = fObjectCenterX + (fObjectWidth / 2);
                        //fEndY = fObjectCenterY + (fObjectHeight / 2);
                        
                            if (m_arrWantDefectArea[intChipType] || m_arrWantDefectLength[intChipType])   // Want check defect Chipped Off Area 
                            {
                                Defect objDefect = new Defect();

                                objDefect.ref_fDimX = fObjectWidth;
                                objDefect.ref_fDimY = fObjectHeight;
                                objDefect.ref_intLengthMode = 0;

                                if (m_arrWantDefectArea[intChipType])
                                {
                                    if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                                    {
                                        intFailMask |= 0x04;
                                        m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                                    }
                                }

                                if (m_arrWantDefectLength[intChipType])
                                {
                                    float fWidthLimit = GetDefect("Chip", 0);
                                    float fLengthLimit = GetDefect("Chip", 1);

                                    int intFailCondition = m_intChippedDarkDefectDimensionFailCondition;
                                    if (m_blnBrightChipDefect)
                                        intFailCondition = m_intChippedBrightDefectDimensionFailCondition;

                                    if (intFailCondition == 0)
                                    {
                                        // Top Left Border + LengthMode 0
                                        // ------------------------------------ 
                                        // X : fDimX, fWidthLimit, FailMask=0x01, Fail Message label width
                                        // Y : fDimY, fLengthLimit, FailMask=0x02, Fail Message label length

                                        if (objDefect.ref_fDimX >= fWidthLimit)  // Is Chipped over setting min value
                                        {
                                            intFailMask |= 0x01;
                                            m_strErrorMessage += "*Chipped Off Width Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (fWidthLimit / m_fMMToPixelXValue).ToString("f4") + " mm,   Result = " + (objDefect.ref_fDimX / m_fMMToPixelXValue).ToString("f4") + " mm";
                                        }
                                        if (objDefect.ref_fDimY >= fLengthLimit)  // Is Chipped over setting min value
                                        {
                                            intFailMask |= 0x02;
                                            m_strErrorMessage += "*Chipped Off Length Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (fLengthLimit / m_fMMToPixelYValue).ToString("f4") + " mm,   Result = " + (objDefect.ref_fDimY / m_fMMToPixelYValue).ToString("f4") + " mm";
                                        }
                                    }
                                    else
                                    {
                                        if ((objDefect.ref_fDimX >= fWidthLimit) && (objDefect.ref_fDimY >= fLengthLimit))  // Is Chipped over setting min value
                                        {
                                            intFailMask |= 0x01;
                                            intFailMask |= 0x02;
                                            m_strErrorMessage += "*Chipped Off Width Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (fWidthLimit / m_fMMToPixelXValue).ToString("f4") + " mm,   Result = " + (objDefect.ref_fDimX / m_fMMToPixelXValue).ToString("f4") + " mm";
                                            m_strErrorMessage += "*Chipped Off Length Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (fLengthLimit / m_fMMToPixelYValue).ToString("f4") + " mm,   Result = " + (objDefect.ref_fDimY / m_fMMToPixelYValue).ToString("f4") + " mm";
                                        }
                                    }

                                }


                                //objDefect.ref_fDimX = fObjectWidth;
                                //objDefect.ref_fDimY = fObjectHeight;
                                objDefect.ref_fArea = intObjectArea;
                                objDefect.ref_fCenterX = intTotalROIStartX + fObjectCenterX;
                                objDefect.ref_fCenterY = intTotalROIStartY + fObjectCenterY;
                                objDefect.ref_intBlobNo = i;
                                objDefect.ref_intFailMask = intFailMask;
                                m_intPkgFailResultMask |= 0x02;
                                objDefect.ref_strName = "Img " + (intSelectedImageIndex + 1).ToString() + " Chipped";
                                objDefect.ref_intFailedImage = intSelectedImageIndex + 1;

                                m_arrDefectList.Add(objDefect);

                                if (intFailMask > 0)
                                {
                                    if (!blnOverAllFail)
                                        blnOverAllFail = true;
                                }
                            }
                        
                    }

                }
            }

            if (blnOverAllFail)
                return false;
            else
                return true;
        }
        private bool InspectChipPackage_Area_NoSeparateDirection(float fCenterX, float fCenterY, float fWidth, float fHeight, ImageDrawing objImage, int intThreshold,
                                  int intTotalROIStartX, int intTotalROIStartY, int intChipLineLimitPixelValue, int intChipViewMinAreaSetting, List<PointF> arrChippedROIPoints,
                                  ImageDrawing objWhiteImage, ImageDrawing objBlackImage, float fAngle,
                                  ImageDrawing objBlackWhiteTopImage, ImageDrawing objBlackWhiteRightImage, ImageDrawing objBlackWhiteBottomImage, ImageDrawing objBlackWhiteLeftImage)
        {
            if (objImage.ref_intImageHeight == 0 || objImage.ref_intImageWidth == 0)
                return true;

            if ((m_intPkgFailMask & 0x02) == 0)
                return true;

            bool blnDebug = false;
            int intSelectedImageIndex;

            int intChipType = (int)eWantDefect.ChipBright;
            if (intChipLineLimitPixelValue == 255)
            {
                intChipType = (int)eWantDefect.ChipDark;
            }

            int intCeilChipLengthTop = 0; // (int)Math.Ceiling(m_arrDefectHorizontal[1]);
            int intCeilChipLengthRight = 0;  //(int)Math.Ceiling(m_arrDefectHorizontal[1]);
            int intCeilChipLengthBottom = 0; //(int)Math.Ceiling(m_arrDefectHorizontal[1]);
            int intCeilChipLengthLeft = 0;  //(int)Math.Ceiling(m_arrDefectHorizontal[1]);

            if (intChipLineLimitPixelValue == 0)    // White field defect (Scratches, contamination, chip)
            {
                intCeilChipLengthTop = m_intStartPixelFromEdge_Chip - m_intStartPixelExtendFromEdge_Chip;
                intCeilChipLengthRight = m_intStartPixelFromRight_Chip - m_intStartPixelExtendFromRight_Chip;
                intCeilChipLengthBottom = m_intStartPixelFromBottom_Chip - m_intStartPixelExtendFromBottom_Chip;
                intCeilChipLengthLeft = m_intStartPixelFromLeft_Chip - m_intStartPixelExtendFromLeft_Chip;

                intSelectedImageIndex = m_arrGrabImageIndex[2];
            }
            else // Black field defect (Crack, void, chip)
            {
                intCeilChipLengthTop = m_intStartPixelFromEdge_Chip_Dark - m_intStartPixelExtendFromEdge_Chip_Dark;
                intCeilChipLengthRight = m_intStartPixelFromRight_Chip_Dark - m_intStartPixelExtendFromRight_Chip_Dark;
                intCeilChipLengthBottom = m_intStartPixelFromBottom_Chip_Dark - m_intStartPixelExtendFromBottom_Chip_Dark;
                intCeilChipLengthLeft = m_intStartPixelFromLeft_Chip_Dark - m_intStartPixelExtendFromLeft_Chip_Dark;

                intSelectedImageIndex = m_arrGrabImageIndex[3];
            }
            for (int i = 0; i < arrChippedROIPoints.Count; i++)
            {
                arrChippedROIPoints[i] = new PointF(arrChippedROIPoints[i].X - intTotalROIStartX, arrChippedROIPoints[i].Y - intTotalROIStartY);
            }
            if (blnDebug)
                objImage.SaveImage("D:\\TS\\1.ChippedOffImage.bmp");

            ROI objChipUnitROI2 = new ROI();
            ROI objChipUnitROI3 = new ROI();
            objChipUnitROI3.AttachImage(objWhiteImage);
            objChipUnitROI3.LoadROISetting(0, 0, objImage.ref_intImageWidth, objImage.ref_intImageHeight);
            ImageDrawing objImage_Temp = new ImageDrawing(true, objImage.ref_intImageWidth, objImage.ref_intImageHeight);
            objChipUnitROI3.CopyToImage(ref objImage_Temp);
            objChipUnitROI2.AttachImage(objImage_Temp);
            objChipUnitROI2.LoadROISetting(1 + (int)Math.Round((fCenterX - fWidth / 2) + m_intStartPixelFromLeft_Chip - intTotalROIStartX, 0, MidpointRounding.AwayFromZero),
                                       1 + (int)Math.Round((fCenterY - fHeight / 2) + m_intStartPixelFromEdge_Chip - intTotalROIStartY, 0, MidpointRounding.AwayFromZero),
                                       (int)Math.Round(fWidth - m_intStartPixelFromLeft_Chip - m_intStartPixelFromRight_Chip - 1, 0, MidpointRounding.AwayFromZero),
                                       (int)Math.Round(fHeight - m_intStartPixelFromEdge_Chip - m_intStartPixelFromBottom_Chip - 1, 0, MidpointRounding.AwayFromZero));

            PointF pStart = new PointF(objChipUnitROI2.ref_ROIPositionX, objChipUnitROI2.ref_ROIPositionY);
            PointF pEnd = new PointF(objChipUnitROI2.ref_ROIPositionX + objChipUnitROI2.ref_ROIWidth, objChipUnitROI2.ref_ROIPositionY + objChipUnitROI2.ref_ROIHeight);
            List<PointF> arrPoints = new List<PointF>(); // 0:Top Left, 1: Top Right, 2:Bottom Left, 3:Bottom Right
            arrPoints.Add(new PointF(pStart.X, pStart.Y));
            arrPoints.Add(new PointF(pEnd.X, pStart.Y));
            arrPoints.Add(new PointF(pStart.X, pEnd.Y));
            arrPoints.Add(new PointF(pEnd.X, pEnd.Y));

            //m_objMarkTrainROI.SaveImage("D:\\m_objMarkTrainROI1.bmp");

            PointF pTemp = new PointF();
            Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2,
                                             (pEnd.Y + pStart.Y) / 2,
                                             arrPoints[0],
                                             (fAngle),
                                             ref pTemp);
            arrPoints[0] = pTemp;

            Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2,
                                             (pEnd.Y + pStart.Y) / 2,
                                             arrPoints[1],
                                             (fAngle),
                                             ref pTemp);
            arrPoints[1] = pTemp;

            Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2,
                                             (pEnd.Y + pStart.Y) / 2,
                                             arrPoints[2],
                                             (fAngle),
                                             ref pTemp);
            arrPoints[2] = pTemp;

            Math2.GetNewXYAfterRotate_360deg((pEnd.X + pStart.X) / 2,
                                             (pEnd.Y + pStart.Y) / 2,
                                             arrPoints[3],
                                             (fAngle),
                                             ref pTemp);
            arrPoints[3] = pTemp;
           
            DontCareWithoutRotateImage.ProduceImage(arrPoints, objChipUnitROI2, objImage_Temp
                , objBlackWhiteTopImage, objBlackWhiteRightImage, objBlackWhiteBottomImage, objBlackWhiteLeftImage, false);
            objChipUnitROI3.AttachImage(objImage);
            objChipUnitROI3.LoadROISetting(objChipUnitROI2.ref_ROIPositionX, objChipUnitROI2.ref_ROIPositionY, objChipUnitROI2.ref_ROIWidth, objChipUnitROI2.ref_ROIHeight);
            if (blnDebug)
            {
                objChipUnitROI2.SaveImage("D:\\TS\\objChipUnitROI2.bmp");
                objChipUnitROI3.SaveImage("D:\\TS\\objChipUnitROI3.bmp");
                objImage_Temp.SaveImage("D:\\TS\\2_1.objImage_Temp.bmp");
            }
            if (intChipLineLimitPixelValue == 0)
            {
                ROI.SubtractROI(objChipUnitROI3, objChipUnitROI2);
            }
            else
            {
                ROI.LogicOperationAddROI(objChipUnitROI3, objChipUnitROI2);
            }

            objChipUnitROI2.Dispose();
            objChipUnitROI3.Dispose();
            objImage_Temp.Dispose();
            if (blnDebug)
                objImage.SaveImage("D:\\TS\\2_2.ChippedOffImageFillChipLineLimitToCorner.bmp");

            ROI objBlobsROI = new ROI();
            objBlobsROI.AttachImage(objImage);
            objBlobsROI.LoadROISetting(0, 0, objImage.ref_intImageWidth, objImage.ref_intImageHeight);
            
            if (blnDebug)
                objBlobsROI.SaveImage("D:\\TS\\3.objBlobsROI.bmp");
            int intMinValue;
            if (intChipViewMinAreaSetting == 0)
                intMinValue = m_intChipView1MinArea;
            else
                intMinValue = m_intChipView2MinArea;

            bool bWhiteOnBlack;
            if (intChipLineLimitPixelValue == 0)
                bWhiteOnBlack = true;    // detect white on black - white is the chip
            else
                bWhiteOnBlack = false;   // detect black on white - black is the chip

            int intSelectedObject = m_objEBlobs.BuildObjects_Filter_GetElement(objBlobsROI, !bWhiteOnBlack, true, 0, intThreshold,
                intMinValue, objBlobsROI.ref_ROIWidth * objBlobsROI.ref_ROIHeight, false, 0x0D);

            bool blnOverAllFail = false;
            if (intSelectedObject > 0)
            {
                int intObjectArea = 0;
                float fObjectHeight = 0, fObjectWidth = 0, fObjectCenterX = 0, fObjectCenterY = 0;
                float fStartX, fStartY, fEndX, fEndY;
                //float fOuterStartX = 1;
                //float fOuterStartY = 1;
                //float fOuterEndX = objBlobsROI.ref_ROIWidth;
                //float fOuterEndY = objBlobsROI.ref_ROIHeight;
                //float fInterStartX = intCeilChipLengthLeft;// m_intStartPixelFromLeft_Chip; // m_arrDefectHorizontal[1];
                //float fInterStartY = intCeilChipLengthTop;//m_intStartPixelFromEdge_Chip; // m_arrDefectHorizontal[1];
                //float fInterEndX = (float)objBlobsROI.ref_ROIWidth - intCeilChipLengthRight; //- m_arrDefectHorizontal[1] - 1;
                //float fInterEndY = (float)objBlobsROI.ref_ROIHeight - intCeilChipLengthBottom;  //- m_arrDefectHorizontal[1] - 1;
                //int intChipLengthTop = intCeilChipLengthTop;// m_intStartPixelFromEdge_Chip;
                //int intChipLengthRight = intCeilChipLengthRight;// m_intStartPixelFromRight_Chip;
                //int intChipLengthBottom = intCeilChipLengthBottom;// m_intStartPixelFromBottom_Chip;
                //int intChipLengthLeft = intCeilChipLengthLeft;// m_intStartPixelFromLeft_Chip;
                int intFailMask = 0;

                float fInterStartX = fCenterX - (fWidth / 2) - intTotalROIStartX + intCeilChipLengthLeft;// m_intStartPixelFromLeft_Chip; // m_arrDefectHorizontal[1];
                float fInterStartY = fCenterY - (fHeight / 2) - intTotalROIStartY + intCeilChipLengthTop;//m_intStartPixelFromEdge_Chip; // m_arrDefectHorizontal[1];
                float fInterEndX = fCenterX + (fWidth / 2) - intTotalROIStartX - intCeilChipLengthRight; //- m_arrDefectHorizontal[1] - 1;
                float fInterEndY = fCenterY + (fHeight / 2) - intTotalROIStartY - intCeilChipLengthBottom;  //- m_arrDefectHorizontal[1] - 1;

                for (int i = 0; i < intSelectedObject; i++)
                {
                    intObjectArea = m_objEBlobs.ref_arrArea[i];
                    fObjectHeight = m_objEBlobs.ref_arrHeight[i];
                    fObjectWidth = m_objEBlobs.ref_arrWidth[i];
                    fObjectCenterX = m_objEBlobs.ref_arrLimitCenterX[i];
                    fObjectCenterY = m_objEBlobs.ref_arrLimitCenterY[i];
                    intFailMask = 0;

                    if (true)
                    {
                        //float fCenterX_New = (float)((objBlobsROI.ref_ROIWidth / 2) + ((fObjectCenterX - (objBlobsROI.ref_ROIWidth / 2)) * Math.Cos(-fAngle * Math.PI / 180)) - ((fObjectCenterY - (objBlobsROI.ref_ROIHeight / 2)) * Math.Sin(-fAngle * Math.PI / 180)));

                        //float fCenterY_New = (float)(((objBlobsROI.ref_ROIHeight / 2)) + ((fObjectCenterX - (objBlobsROI.ref_ROIWidth / 2)) * Math.Sin(-fAngle * Math.PI / 180)) + ((fObjectCenterY - (objBlobsROI.ref_ROIHeight / 2)) * Math.Cos(-fAngle * Math.PI / 180)));

                        //fStartX = fCenterX_New - (fObjectWidth / 2);
                        //fStartY = fCenterY_New - (fObjectHeight / 2);
                        //fEndX = fCenterX_New + (fObjectWidth / 2);
                        //fEndY = fCenterY_New + (fObjectHeight / 2);
                        
                            if (m_arrWantDefectArea[intChipType] || m_arrWantDefectLength[intChipType])   // Want check defect Chipped Off Area 
                            {
                                Defect objDefect = new Defect();
                            
                                    objDefect.ref_fDimX = fObjectWidth;
                                    objDefect.ref_fDimY = fObjectHeight;
                                    objDefect.ref_intLengthMode = 0;
                                
                                if (m_arrWantDefectArea[intChipType])
                                {
                                    if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                                    {
                                        intFailMask |= 0x04;
                                        m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                                    }
                                }

                                if (m_arrWantDefectLength[intChipType])
                                {
                                    float fWidthLimit = GetDefect("Chip", 0);
                                    float fLengthLimit = GetDefect("Chip", 1);

                                    int intFailCondition = m_intChippedDarkDefectDimensionFailCondition;
                                    if (m_blnBrightChipDefect)
                                        intFailCondition = m_intChippedBrightDefectDimensionFailCondition;

                                    if (intFailCondition == 0)
                                    {
                                        // Top Left Border + LengthMode 0
                                        // ------------------------------------ 
                                        // X : fDimX, fWidthLimit, FailMask=0x01, Fail Message label width
                                        // Y : fDimY, fLengthLimit, FailMask=0x02, Fail Message label length

                                        if (objDefect.ref_fDimX >= fWidthLimit)  // Is Chipped over setting min value
                                        {
                                            intFailMask |= 0x01;
                                            m_strErrorMessage += "*Chipped Off Width Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (fWidthLimit / m_fMMToPixelXValue).ToString("f4") + " mm,   Result = " + (objDefect.ref_fDimX / m_fMMToPixelXValue).ToString("f4") + " mm";
                                        }
                                        if (objDefect.ref_fDimY >= fLengthLimit)  // Is Chipped over setting min value
                                        {
                                            intFailMask |= 0x02;
                                            m_strErrorMessage += "*Chipped Off Length Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (fLengthLimit / m_fMMToPixelYValue).ToString("f4") + " mm,   Result = " + (objDefect.ref_fDimY / m_fMMToPixelYValue).ToString("f4") + " mm";
                                        }
                                    }
                                    else
                                    {
                                        if ((objDefect.ref_fDimX >= fWidthLimit) && (objDefect.ref_fDimY >= fLengthLimit))  // Is Chipped over setting min value
                                        {
                                            intFailMask |= 0x01;
                                            intFailMask |= 0x02;
                                            m_strErrorMessage += "*Chipped Off Width Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (fWidthLimit / m_fMMToPixelXValue).ToString("f4") + " mm,   Result = " + (objDefect.ref_fDimX / m_fMMToPixelXValue).ToString("f4") + " mm";
                                            m_strErrorMessage += "*Chipped Off Length Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (fLengthLimit / m_fMMToPixelYValue).ToString("f4") + " mm,   Result = " + (objDefect.ref_fDimY / m_fMMToPixelYValue).ToString("f4") + " mm";
                                        }
                                    }
                                }

                                //objDefect.ref_fDimX = fObjectWidth;
                                //objDefect.ref_fDimY = fObjectHeight;
                                objDefect.ref_fArea = intObjectArea;
                                objDefect.ref_fCenterX = intTotalROIStartX + fObjectCenterX;
                                objDefect.ref_fCenterY = intTotalROIStartY + fObjectCenterY;
                                objDefect.ref_intBlobNo = i;
                                objDefect.ref_intFailMask = intFailMask;
                                m_intPkgFailResultMask |= 0x02;
                                objDefect.ref_strName = "Img " + (intSelectedImageIndex + 1).ToString() + " Chipped";
                                objDefect.ref_intFailedImage = intSelectedImageIndex + 1;

                                objDefect.ref_fAngle = fAngle;

                                m_arrDefectList.Add(objDefect);

                                if (intFailMask > 0)
                                {
                                    if (!blnOverAllFail)
                                        blnOverAllFail = true;
                                }
                            }
                        
                    }

                }
            }

            if (blnOverAllFail)
                return false;
            else
                return true;
        }
        /// <summary>
        /// Check Package View Image
        /// </summary>
        /// <param name="objROI"></param>
        private bool InspectPackageView(ROI objROI)
        {
            int intSelectedImageIndex = m_arrGrabImageIndex[2];

            bool blnWantDebug = false;
            if (blnWantDebug)
            {
                objROI.SaveImage("D:\\TS\\InspectPackageView_ROI.bmp");
            }
            int intSelectedObjectNum = m_objPackageEBlobs.BuildObjects_Filter_GetElement(objROI, false, m_intConnexity == 4,
                0, m_intPkgViewThreshold, m_intPkgViewMinArea, objROI.ref_ROIWidth * objROI.ref_ROIHeight, false, 0x1D);

            if (intSelectedObjectNum == 0)
                return true;

            int intObjectTotalArea = 0;
            int intObjectArea = 0, j, intContourX = 0, intContourY = 0;
            float fObjectHeight = 0, fObjectWidth = 0, fObjectCenterX = 0, fObjectCenterY = 0;
            bool blnOverAllFail = false;
            for (int i = 0; i < intSelectedObjectNum; i++)
            {
                intObjectArea = m_objPackageEBlobs.ref_arrArea[i];
                fObjectHeight = m_objPackageEBlobs.ref_arrHeight[i];
                fObjectWidth = m_objPackageEBlobs.ref_arrWidth[i];
                fObjectCenterX = m_objPackageEBlobs.ref_arrLimitCenterX[i];
                fObjectCenterY = m_objPackageEBlobs.ref_arrLimitCenterY[i];
                intObjectTotalArea += intObjectArea;

                // Recalculate object size using sub pixel if object size near 2 pixels to tolerance setting.
                //if ((Math.Abs(fObjectWidth - GetDefect("Scratch", 0)) <= 2) || (Math.Abs(fObjectHeight - GetDefect("Scratch", 1)) <= 2) ||
                //    (Math.Abs(fObjectWidth - GetDefect("Contamination", 0)) <= 2) || (Math.Abs(fObjectHeight - GetDefect("Contamination", 1)) <= 2))
                //{
                //    // get contour point from object.
                //    intContourX = m_objPackageEBlobs.ref_arrContourX[i];
                //    intContourY = m_objPackageEBlobs.ref_arrContourY[i];

                //    Contour objContour = new Contour();
                //    objContour.ClearContour();
                //    if (objContour.BuildBasicContour(objROI, intContourX, intContourY, m_intPkgViewThreshold, 4))
                //    {
                //        Point pTop = new Point();
                //        Point pBottom = new Point();
                //        Point pLeft = new Point();
                //        Point pRight = new Point();
                //        // Get 4 Direction Point
                //        if (objContour.Get4DirectionPoints(objROI, ref pTop, ref pBottom, ref pLeft, ref pRight))
                //        {
                //            Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, pTop, pBottom, pLeft, pRight, fObjectCenterX, fObjectCenterY,
                //                ref fObjectWidth, ref fObjectHeight, ref fObjectCenterX, ref fObjectCenterY, m_intPkgViewThreshold);
                //        }
                //    }
                //    objContour.Dispose();

                //}

                //if (i < 2)
                //{
                //    m_strTrack += ", Area" + i.ToString() + "=" + intObjectArea.ToString();
                //    m_strTrack += ", ObjH" + i.ToString() + "=" + fObjectHeight.ToString();
                //    m_strTrack += ", ObjW" + i.ToString() + "=" + fObjectWidth.ToString();
                //    m_strTrack += ", ObjX" + i.ToString() + "=" + fObjectCenterX.ToString();
                //    m_strTrack += ", ObjH" + i.ToString() + "=" + fObjectCenterY.ToString();
                //}

                for (j = 0; j < m_arrDontCareArea.Count; j++)
                {
                    if ((objROI.ref_ROITotalX + fObjectCenterX > m_arrDontCareArea[j][0].X) && (objROI.ref_ROITotalY + fObjectCenterY > m_arrDontCareArea[j][0].Y) &&
                        (objROI.ref_ROITotalX + fObjectCenterX < m_arrDontCareArea[j][1].X) && (objROI.ref_ROITotalY + fObjectCenterY < m_arrDontCareArea[j][1].Y))
                    {
                        break;
                    }
                }
                if (j < m_arrDontCareArea.Count)
                {
                    continue;
                }



                bool blnFail = false;
                int intFailMask = 0;
                string strDefectName = "Scratches";

                if ((m_intPkgFailMask & 0x04) > 0)
                {
                    if (m_arrWantDefectLength[(int)eWantDefect.Scratches])
                    {
                        if (fObjectWidth >= GetDefect("Scratch", 0))
                        {
                            //m_strErrorMessage += "* Fail Package View Package - Object " + (m_arrDefectList.Count + 1) + " is scratched. Set = " + (m_arrDefectHorizontal[2] / m_fMMToPixelXValue).ToString("f5") + " mm,   Result = " + (Math.Max(fObjectWidth, fObjectHeight) / m_fMMToPixelXValue).ToString("f5") + " mm";
                            m_strErrorMessage += "* Package View Scratches Width Package Fail. Set = " + (GetDefect("Scratch", 0) / m_fMMToPixelXValue).ToString("f4") + " mm,   Result = " + (fObjectWidth / m_fMMToPixelXValue).ToString("f4") + " mm";
                            blnFail = true;
                            intFailMask |= 0x01;
                            strDefectName = "Scratches";
                        }

                        if (fObjectHeight >= GetDefect("Scratch", 1))
                        {
                            //m_strErrorMessage += "* Fail Package View Package - Object " + (m_arrDefectList.Count + 1) + " is scratched. Set = " + (m_arrDefectHorizontal[2] / m_fMMToPixelXValue).ToString("f5") + " mm,   Result = " + (Math.Max(fObjectWidth, fObjectHeight) / m_fMMToPixelXValue).ToString("f5") + " mm";
                            m_strErrorMessage += "* Package View Scratches Height Package Fail. Set = " + (GetDefect("Scratch", 1) / m_fMMToPixelYValue).ToString("f4") + " mm,   Result = " + (fObjectHeight / m_fMMToPixelYValue).ToString("f4") + " mm";
                            blnFail = true;
                            intFailMask |= 0x02;
                            strDefectName = "Scratches";
                        }
                    }

                    if (m_arrWantDefectArea[(int)eWantDefect.Scratches])
                    {
                        if (intObjectArea >= GetAreaDefect("Scratch"))
                        {
                            //m_strErrorMessage += "* Fail Package View Package - Object " + (m_arrDefectList.Count + 1) + " is scratched. Set = " + (m_arrDefectArea[2] / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                            m_strErrorMessage += "* Package View Scratches Area Package Fail. Set = " + (GetAreaDefect("Scratch") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                            blnFail = true;
                            intFailMask |= 0x04;
                            strDefectName = "Scratches";
                        }
                    }

                }

                if (!blnFail)
                {
                    if ((m_intPkgFailMask & 0x10) > 0)
                    {
                        strDefectName = "Contamination";
                        if (m_arrWantDefectLength[(int)eWantDefect.Contamination])
                        {
                            if (fObjectWidth >= GetDefect("Contamination", 0))
                            {
                                //m_strErrorMessage += "* Fail Package View Package - Object " + (m_arrDefectList.Count + 1) + " is contaminated. Set = " + (m_arrDefectHorizontal[4] / m_fMMToPixelXValue).ToString("f5") + " mm,   Result = " + (Math.Max(fObjectWidth, fObjectHeight) / m_fMMToPixelXValue).ToString("f5") + " mm";
                                m_strErrorMessage += "* Package View Contamination Width Package Fail. Set = " + (GetDefect("Contamination", 0) / m_fMMToPixelXValue).ToString("f5") + " mm,   Result = " + (fObjectWidth / m_fMMToPixelXValue).ToString("f5") + " mm";
                                blnFail = true;
                                intFailMask |= 0x01;
                                strDefectName = "Contamination";
                            }

                            if (fObjectHeight >= GetDefect("Contamination", 1))
                            {
                                //m_strErrorMessage += "* Fail Package View Package - Object " + (m_arrDefectList.Count + 1) + " is contaminated. Set = " + (m_arrDefectHorizontal[4] / m_fMMToPixelXValue).ToString("f5") + " mm,   Result = " + (Math.Max(fObjectWidth, fObjectHeight) / m_fMMToPixelXValue).ToString("f5") + " mm";
                                m_strErrorMessage += "* Package View Contamination Height Package Fail. Set = " + (GetDefect("Contamination", 1) / m_fMMToPixelYValue).ToString("f5") + " mm,   Result = " + (fObjectHeight / m_fMMToPixelYValue).ToString("f5") + " mm";
                                blnFail = true;
                                intFailMask |= 0x02;
                                strDefectName = "Contamination";
                            }
                        }

                        if (m_arrWantDefectArea[(int)eWantDefect.Contamination])
                        {
                            if (intObjectArea >= GetAreaDefect("Contamination"))
                            {
                                //m_strErrorMessage += "* Fail Package View Package - Object " + (m_arrDefectList.Count + 1) + " is contaminated. Set = " + (m_arrDefectArea[4] / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                                m_strErrorMessage += "* Package View Contamination Area Package Fail. Set = " + (GetAreaDefect("Contamination") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                                blnFail = true;
                                intFailMask |= 0x04;
                                strDefectName = "Contamination";
                            }
                        }
                    }
                }

                //if (((fObjectWidth >= fScratchMinLenght) || (fObjectHeight >= fScratchMinLenght)) &&
                //    ((fObjectWidth >= fContaMinLength) || (fObjectHeight >= fContaMinLength)))
                //{
                //    if (((float)intObjectArea / (fObjectWidth * fObjectHeight)) > 0.5)
                //    {
                //        if ((m_intPkgFailMask & 0x10) > 0)
                //        {
                //            m_strErrorMessage += "* Fail Package View Package - Object " + (m_arrDefectList.Count + 1) + " is contaminated";
                //            blnFail = true;
                //        }
                //    }
                //    else
                //    {
                //        if ((m_intPkgFailMask & 0x04) > 0)
                //        {
                //            m_strErrorMessage += "* Fail Package View Package - Object " + (m_arrDefectList.Count + 1) + " is scratched";
                //            blnFail = true;
                //        }
                //    }
                //}
                //else if ((fObjectWidth >= fScratchMinLenght) || (fObjectHeight >= fScratchMinLenght))
                //{
                //    if ((m_intPkgFailMask & 0x04) > 0)
                //    {
                //        m_strErrorMessage += "* Fail Package View Package - Object " + (m_arrDefectList.Count + 1) + " is scratched";
                //        blnFail = true;
                //    }
                //}
                //else if ((fObjectWidth >= fContaMinLength) || (fObjectHeight >= fContaMinLength))
                //{
                //    if ((m_intPkgFailMask & 0x10) > 0)
                //    {
                //        m_strErrorMessage += "* Fail Package View Package - Object " + (m_arrDefectList.Count + 1) + " is contaminated";
                //        blnFail = true;
                //    }
                //}

                if (blnFail)
                {
                    Defect objDefect = new Defect();
                    objDefect.ref_fDimX = fObjectWidth;
                    objDefect.ref_fDimY = fObjectHeight;
                    objDefect.ref_intLengthMode = 0;
                    objDefect.ref_fArea = intObjectArea;
                    objDefect.ref_fCenterX = objROI.ref_ROITotalX + fObjectCenterX;
                    objDefect.ref_fCenterY = objROI.ref_ROITotalY + fObjectCenterY;
                    objDefect.ref_intBlobNo = i;
                    objDefect.ref_intFailMask = intFailMask;
                    objDefect.ref_strName = strDefectName;
                    objDefect.ref_intFailedImage = intSelectedImageIndex + 1;
                    m_arrDefectList.Add(objDefect);

                    if(strDefectName == "Scratches")
                        m_intPkgFailResultMask |= 0x04;
                    else
                        m_intPkgFailResultMask |= 0x10;
                    if (!blnOverAllFail)
                        blnOverAllFail = true;
                }
                else
                {
                    Defect objDefect = new Defect();
                    objDefect.ref_fDimX = fObjectWidth;
                    objDefect.ref_fDimY = fObjectHeight;
                    objDefect.ref_intLengthMode = 0;
                    objDefect.ref_fArea = intObjectArea;
                    objDefect.ref_fCenterX = objROI.ref_ROITotalX + fObjectCenterX;
                    objDefect.ref_fCenterY = objROI.ref_ROITotalY + fObjectCenterY;
                    objDefect.ref_intBlobNo = i;
                    objDefect.ref_intFailMask = 0;
                    objDefect.ref_strName = strDefectName;
                    objDefect.ref_intFailedImage = intSelectedImageIndex + 1;
                    m_arrDefectList.Add(objDefect);
                }
            }

            if (m_arrWantDefectArea[(int)eWantDefect.Scratches])
            {
                if (intObjectTotalArea >= GetTotalAreaDefect("Scratch"))
                {
                    m_strErrorMessage += "* Scratch Total Area Package Fail. Set = " + (GetTotalAreaDefect("Scratch") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectTotalArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                    m_blnPkgViewFailTotalArea = true;

                    Defect objDefect = new Defect();
                    objDefect.ref_fDimX = m_objPackageEBlobs.ref_arrWidth[0];
                    objDefect.ref_fDimY = m_objPackageEBlobs.ref_arrHeight[0];
                    objDefect.ref_intLengthMode = 0;
                    objDefect.ref_fArea = m_objPackageEBlobs.ref_arrArea[0];
                    objDefect.ref_fCenterX = objROI.ref_ROITotalX + m_objPackageEBlobs.ref_arrLimitCenterX[0];
                    objDefect.ref_fCenterY = objROI.ref_ROITotalY + m_objPackageEBlobs.ref_arrLimitCenterY[0];
                    objDefect.ref_intFailMask |= 0x04;
                    objDefect.ref_strName = "Scratches";
                    objDefect.ref_intFailedImage = intSelectedImageIndex + 1;
                    m_arrDefectList.Add(objDefect);
                    m_intPkgFailResultMask |= 0x04;
                    if (!blnOverAllFail)
                        blnOverAllFail = true;
                }
            }


            if (m_arrWantDefectArea[(int)eWantDefect.Contamination])
            {
                if (intObjectTotalArea >= GetTotalAreaDefect("Contamination"))
                {
                    m_strErrorMessage += "* Contamination Total Area Package Fail. Set = " + (GetTotalAreaDefect("Contamination") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectTotalArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                    m_blnPkgViewFailTotalArea = true;

                    Defect objDefect = new Defect();
                    objDefect.ref_fDimX = m_objPackageEBlobs.ref_arrWidth[0];
                    objDefect.ref_fDimY = m_objPackageEBlobs.ref_arrHeight[0];
                    objDefect.ref_intLengthMode = 0;
                    objDefect.ref_fArea = m_objPackageEBlobs.ref_arrArea[0];
                    objDefect.ref_fCenterX = objROI.ref_ROITotalX + m_objPackageEBlobs.ref_arrLimitCenterX[0];
                    objDefect.ref_fCenterY = objROI.ref_ROITotalY + m_objPackageEBlobs.ref_arrLimitCenterY[0];
                    objDefect.ref_intFailMask |= 0x04;
                    objDefect.ref_strName = "Contamination";
                    objDefect.ref_intFailedImage = intSelectedImageIndex + 1;
                    m_arrDefectList.Add(objDefect);
                    m_intPkgFailResultMask |= 0x10;
                    if (!blnOverAllFail)
                        blnOverAllFail = true;
                }
            }

            if (blnOverAllFail)
                return false;
            else
                return true;
        }
        private bool InspectionImage12BrightFieldDefect(ROI objROI)
        {
            int intSelectedImageIndex = m_arrGrabImageIndex[2];

            bool blnWantDebug = false;
            if (blnWantDebug)
            {
                objROI.SaveImage("D:\\TS\\InspectPackageView_ROI.bmp");
            }

            int intSelectedObjectNum = m_objPackageEBlobs.BuildObjects_Filter_GetElement(objROI, false, m_intConnexity == 4,
                                        0, m_intBrightFieldLowThreshold, m_intBrightFieldMinArea, objROI.ref_ROIWidth * objROI.ref_ROIHeight + 1, false, 0xED); // 2020 03 10 -> Plus 1 to max value to make sure blob with ROI size able to be detected.
            //    0, m_intBrightFieldLowThreshold, m_intBrightFieldMinArea, objROI.ref_ROIWidth * objROI.ref_ROIHeight + 1, false, 0xED); // 2019 09 03 - change max area from 15000 to  objROI.ref_ROIWidth * objROI.ref_ROIHeight to make sure big defect able to be detected.

            if (intSelectedObjectNum == 0)
                return true;

            int intObjectTotalArea = 0;
            int intObjectArea = 0;
            int intLengthMode = 0;
            float fObjectHeight = 0, fObjectWidth = 0, fObjectCenterX = 0, fObjectCenterY = 0, fObjectAngle = 0;
            bool blnOverAllFail = false;
            m_arrDefectList.Clear();

            for (int i = 0; i < intSelectedObjectNum; i++)
            {
                intObjectArea = m_objPackageEBlobs.ref_arrArea[i];

                //if (m_objPackageEBlobs.ref_arrRectWidth[i] < m_objPackageEBlobs.ref_arrRectHeight[i])
                //{
                //    fObjectWidth = m_objPackageEBlobs.ref_arrRectWidth[i];
                //    fObjectHeight = m_objPackageEBlobs.ref_arrRectHeight[i];
                //    intLengthMode = 0;
                //    fObjectAngle = m_objPackageEBlobs.ref_arrRectAngle[i];

                //    if (fObjectAngle < 0)
                //        fObjectAngle = -Math.Abs(fObjectAngle);
                //    else
                //        fObjectAngle = -fObjectAngle;

                //}
                //else
                //{
                //    fObjectHeight = m_objPackageEBlobs.ref_arrRectWidth[i];
                //    fObjectWidth = m_objPackageEBlobs.ref_arrRectHeight[i];
                //    intLengthMode = 0;

                //    fObjectAngle = m_objPackageEBlobs.ref_arrRectAngle[i];
                //    if (fObjectAngle < 0)
                //        fObjectAngle = Math.Abs(fObjectAngle);
                //    else
                //        fObjectAngle = 90 - (fObjectAngle);

                //}

                if (m_objPackageEBlobs.ref_arrRectHeight[i] < m_objPackageEBlobs.ref_arrRectWidth[i])
                {
                    fObjectWidth = m_objPackageEBlobs.ref_arrRectHeight[i];
                    fObjectHeight = m_objPackageEBlobs.ref_arrRectWidth[i];
                    intLengthMode = 0;
                    fObjectAngle = m_objPackageEBlobs.ref_arrRectAngle[i];

                    if (fObjectAngle >= 10)//&& fAngle <= 80)
                        fObjectAngle = m_objPackageEBlobs.ref_arrRectAngle[i] - 90;
                    else
                        fObjectAngle = 90 + m_objPackageEBlobs.ref_arrRectAngle[i];

                }
                else
                {
                    fObjectHeight = m_objPackageEBlobs.ref_arrRectHeight[i];
                    fObjectWidth = m_objPackageEBlobs.ref_arrRectWidth[i];
                    intLengthMode = 0;

                    fObjectAngle = m_objPackageEBlobs.ref_arrRectAngle[i];

                }
                fObjectCenterX = m_objPackageEBlobs.ref_arrRectLimitCenterX[i];
                fObjectCenterY = m_objPackageEBlobs.ref_arrRectLimitCenterY[i];

                intObjectTotalArea += intObjectArea;

                bool blnFail = false;
                int intFailMask = 0;
                string strDefectName = "Bright";

                if ((m_intPkgFailMask & 0x100) > 0)
                {
                    if (m_arrWantDefectLength[(int)eWantDefect.Bright])
                    {
                        if (m_intBrightDefectDimensionFailCondition == 0)
                        {
                            if (fObjectWidth >= GetDefect("Bright", 0))
                            {
                                m_strErrorMessage += "* Package Bright Field Width Fail. Set = " + (GetDefect("Bright", 0) / m_fMMToPixelXValue).ToString("f4") + " mm,   Result = " + (fObjectWidth / m_fMMToPixelXValue).ToString("f4") + " mm";
                                blnFail = true;
                                intFailMask |= 0x01;
                                strDefectName = "Bright";
                            }

                            if (fObjectHeight >= GetDefect("Bright", 1))
                            {
                                m_strErrorMessage += "* Package Bright Field Length Fail. Set = " + (GetDefect("Bright", 1) / m_fMMToPixelYValue).ToString("f4") + " mm,   Result = " + (fObjectHeight / m_fMMToPixelYValue).ToString("f4") + " mm";
                                blnFail = true;
                                intFailMask |= 0x02;
                                strDefectName = "Bright";
                            }
                        }
                        else
                        {
                            if ((fObjectWidth >= GetDefect("Bright", 0)) && (fObjectHeight >= GetDefect("Bright", 1)))
                            {
                                m_strErrorMessage += "* Package Bright Field Width Fail. Set = " + (GetDefect("Bright", 0) / m_fMMToPixelXValue).ToString("f4") + " mm,   Result = " + (fObjectWidth / m_fMMToPixelXValue).ToString("f4") + " mm";
                                intFailMask |= 0x01;
                                m_strErrorMessage += "* Package Bright Field Length Fail. Set = " + (GetDefect("Bright", 1) / m_fMMToPixelYValue).ToString("f4") + " mm,   Result = " + (fObjectHeight / m_fMMToPixelYValue).ToString("f4") + " mm";
                                blnFail = true;
                                intFailMask |= 0x02;
                                strDefectName = "Bright";
                            }
                        }
                    }

                    if (m_arrWantDefectArea[(int)eWantDefect.Bright])
                    {
                        if (intObjectArea >= GetAreaDefect("Bright"))
                        {
                            m_strErrorMessage += "* Package Bright Field Area Fail. Set = " + (GetAreaDefect("Scratch") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                            blnFail = true;
                            intFailMask |= 0x04;
                            strDefectName = "Bright";
                        }
                    }

                }

                if (blnFail)
                {
                    Defect objDefect = new Defect();
                    objDefect.ref_fDimX = fObjectWidth;
                    objDefect.ref_fDimY = fObjectHeight;
                    objDefect.ref_intLengthMode = intLengthMode;
                    objDefect.ref_fArea = intObjectArea;
                    objDefect.ref_fCenterX = objROI.ref_ROITotalX + fObjectCenterX;
                    objDefect.ref_fCenterY = objROI.ref_ROITotalY + fObjectCenterY;
                    objDefect.ref_intBlobNo = i;
                    objDefect.ref_fAngle = fObjectAngle;
                    objDefect.ref_intFailMask = intFailMask;
                    objDefect.ref_strName = strDefectName;
                    objDefect.ref_intFailedImage = intSelectedImageIndex + 1;
                    m_arrDefectList.Add(objDefect);

                    if (!blnOverAllFail)
                        blnOverAllFail = true;
                }
                else
                {
                    Defect objDefect = new Defect();
                    objDefect.ref_fDimX = fObjectWidth;
                    objDefect.ref_fDimY = fObjectHeight;
                    objDefect.ref_intLengthMode = intLengthMode;
                    objDefect.ref_fArea = intObjectArea;
                    objDefect.ref_fCenterX = objROI.ref_ROITotalX + fObjectCenterX;
                    objDefect.ref_fCenterY = objROI.ref_ROITotalY + fObjectCenterY;
                    objDefect.ref_intBlobNo = i;
                    objDefect.ref_fAngle = fObjectAngle;
                    objDefect.ref_intFailMask = 0;
                    objDefect.ref_strName = strDefectName;
                    objDefect.ref_intFailedImage = intSelectedImageIndex + 1;
                    m_arrDefectList.Add(objDefect);
                }
            }

            if (m_arrWantDefectArea[(int)eWantDefect.Bright])
            {
                if (intObjectTotalArea >= GetTotalAreaDefect("Bright"))
                {
                    m_strErrorMessage += "* Package Bright Field Total Area Fail. Set = " + (GetTotalAreaDefect("Bright") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectTotalArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                    m_blnPkgViewFailTotalArea = true;

                    Defect objDefect = new Defect();
                    objDefect.ref_fDimX = -1;
                    objDefect.ref_fDimY = -1;
                    objDefect.ref_intLengthMode = 0;
                    objDefect.ref_fArea = intObjectTotalArea;
                    objDefect.ref_fCenterX = objROI.ref_ROITotalX + m_objPackageEBlobs.ref_arrLimitCenterX[0];
                    objDefect.ref_fCenterY = objROI.ref_ROITotalY + m_objPackageEBlobs.ref_arrLimitCenterY[0];
                    objDefect.ref_intFailMask |= 0x04;
                    objDefect.ref_fAngle = fObjectAngle;
                    objDefect.ref_strName = "Total Bright";
                    objDefect.ref_intFailedImage = intSelectedImageIndex + 1;
                    m_arrDefectList.Add(objDefect);

                    if (!blnOverAllFail)
                        blnOverAllFail = true;
                }
            }

            if (blnOverAllFail)
            {
                m_intPkgFailResultMask |= 0x100;
                return false;
            }
            else
                return true;
        }
        private bool InspectionImage12BrightFieldDefect(ImageDrawing objGrayValueImage, ROI objROI, int intInspectionAreaGrayValueSensitivity, int intMergeSensitivity, int intBrightSensitivity)
        {
            int intSelectedImageIndex = m_arrGrabImageIndex[2];

            bool blnWantDebug = false;
            if (blnWantDebug)
            {
                objROI.SaveImage("D:\\TS\\InspectPackageView_ROI.bmp");
            }
             
            // 2020-05-15 ZJYEOH : New Inspection Method using gray value
            // Step 1 : Get average gray value of package surface area
            float fAverageGrayValue = 0;
            //EasyImage.PixelAverage(objROI.ref_ROI, out fAverageGrayValue);
            //objROI.ref_ROI.Save("D:\\objROI.bmp");
            // Step 2 : declare another ROI and threshold it using (average gray value + sensitivity)
            ROI objThresholdROI = new ROI();
            objThresholdROI.LoadROISetting(objROI.ref_ROITotalX, objROI.ref_ROITotalY, objROI.ref_ROIWidth, objROI.ref_ROIHeight);//0,0,objROI.ref_ROIWidth, objROI.ref_ROIHeight
            ImageDrawing objTempImage = new ImageDrawing();
             
            objGrayValueImage.CopyTo(ref objTempImage);
            objThresholdROI.AttachImage(objGrayValueImage);

            EasyImage.PixelAverage(objThresholdROI.ref_ROI, out fAverageGrayValue);

            //objROI.CopyToImage(ref objImage);
            //objROI.CopyToImage(ref objTempImage);
            //objThresholdROI.AttachImage(objImage);

            int intThreshold = (int)Math.Round(fAverageGrayValue) + intInspectionAreaGrayValueSensitivity;
            if (intThreshold > 255)
                intThreshold = 255;

            int intLowThreshold = (int)Math.Round(fAverageGrayValue) - intInspectionAreaGrayValueSensitivity;
            if (intLowThreshold < 0)
                intLowThreshold = 0;
#if (Debug_2_12 || Release_2_12)
            //objThresholdROI.ref_ROI.Save("D:\\objThresholdROI1.bmp");
            //objROI.ref_ROI.Save("D:\\objROI1.bmp");
            EasyImage.Threshold(objThresholdROI.ref_ROI, objThresholdROI.ref_ROI, (uint)intThreshold);
            //objThresholdROI.ref_ROI.Save("D:\\objThresholdROI2.bmp");
            // Step 3 : invert the thrshold ROI 
            //EasyImage.Oper(EArithmeticLogicOperation.Invert, objThresholdROI.ref_ROI, objThresholdROI.ref_ROI);
            ROI.InvertOperationROI(objThresholdROI);
            //objThresholdROI.ref_ROI.Save("D:\\objThresholdROI3.bmp");


            //EasyImage.DoubleThreshold(objThresholdROI.ref_ROI, objThresholdROI.ref_ROI, intLowThreshold, intThreshold, 255, 0, 255);
            //objThresholdROI.ref_ROI.Save("D:\\objThresholdROI2.bmp");
            //EasyImage.Oper(EArithmeticLogicOperation.Invert, objThresholdROI.ref_ROI, objThresholdROI.ref_ROI);
            //objThresholdROI.ref_ROI.Save("D:\\objThresholdROI3.bmp");
            //// Step 4 : Subtract Original ROI with inverted threshold ROI will result defect above the threshold value only
            //EasyImage.Oper(EArithmeticLogicOperation.BitwiseAnd, objThresholdROI.ref_ROI, objROI.ref_ROI, objROI.ref_ROI);
            //objROI.ref_ROI.Save("D:\\objROI2.bmp");

            // Step 4 : Subtract Original ROI with inverted threshold ROI will result defect above the threshold value only
            EasyImage.Oper(EArithmeticLogicOperation.Subtract, objROI.ref_ROI, objThresholdROI.ref_ROI, objROI.ref_ROI);
            //objROI.ref_ROI.Save("D:\\objROI2.bmp");
            // Step 5 : using Close morphology to link the small defect together using sensitivity set by user
            EasyImage.CloseDisk(objROI.ref_ROI, objROI.ref_ROI, (uint)intMergeSensitivity);
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
            //objThresholdROI.ref_ROI.Save("D:\\objThresholdROI1.bmp");
            //objROI.ref_ROI.Save("D:\\objROI1.bmp");
            EasyImage.Threshold(objThresholdROI.ref_ROI, objThresholdROI.ref_ROI, intThreshold);
            //objThresholdROI.ref_ROI.Save("D:\\objThresholdROI2.bmp");
            // Step 3 : invert the thrshold ROI 
            //EasyImage.Oper(EArithmeticLogicOperation.Invert, objThresholdROI.ref_ROI, objThresholdROI.ref_ROI);
            ROI.InvertOperationROI(objThresholdROI);
            //objThresholdROI.ref_ROI.Save("D:\\objThresholdROI3.bmp");


            //EasyImage.DoubleThreshold(objThresholdROI.ref_ROI, objThresholdROI.ref_ROI, intLowThreshold, intThreshold, 255, 0, 255);
            //objThresholdROI.ref_ROI.Save("D:\\objThresholdROI2.bmp");
            //EasyImage.Oper(EArithmeticLogicOperation.Invert, objThresholdROI.ref_ROI, objThresholdROI.ref_ROI);
            //objThresholdROI.ref_ROI.Save("D:\\objThresholdROI3.bmp");
            //// Step 4 : Subtract Original ROI with inverted threshold ROI will result defect above the threshold value only
            //EasyImage.Oper(EArithmeticLogicOperation.BitwiseAnd, objThresholdROI.ref_ROI, objROI.ref_ROI, objROI.ref_ROI);
            //objROI.ref_ROI.Save("D:\\objROI2.bmp");

            // Step 4 : Subtract Original ROI with inverted threshold ROI will result defect above the threshold value only
            EasyImage.Oper(EArithmeticLogicOperation.Subtract, objROI.ref_ROI, objThresholdROI.ref_ROI, objROI.ref_ROI);
            //objROI.ref_ROI.Save("D:\\objROI2.bmp");
            // Step 5 : using Close morphology to link the small defect together using sensitivity set by user
            EasyImage.CloseDisk(objROI.ref_ROI, objROI.ref_ROI, intMergeSensitivity);
#endif

            //objROI.ref_ROI.Save("D:\\objROI3.bmp");
            // Step 6 : Get background average gray value of the original ROI masked with inverted threshold ROI
            ROI objTempROI = new ROI();
            objTempROI.LoadROISetting(objROI.ref_ROITotalX, objROI.ref_ROITotalY, objROI.ref_ROIWidth, objROI.ref_ROIHeight);

            //objTempROI.AttachImage(objImage);

            objTempROI.AttachImage(objTempImage); 
            fAverageGrayValue = 0;
            EasyImage.PixelAverage(objTempROI.ref_ROI, objThresholdROI.ref_ROI, out fAverageGrayValue);
            //objTempROI.ref_ROI.Save("D:\\objTempROI1.bmp");

            objThresholdROI.Dispose();
            objTempROI.Dispose();
            objTempImage.Dispose();

            // Step 7 : Build blob using the threshold value (average gray value + bright sensitivity)
            intThreshold = (int)Math.Round(fAverageGrayValue) + intBrightSensitivity;
            if (intThreshold > 255)
                intThreshold = 255;
            int intSelectedObjectNum = m_objPackageEBlobs.BuildObjects_Filter_GetElement(objROI, false, m_intConnexity == 4,
                                        0, intThreshold, m_intBrightFieldMinArea, objROI.ref_ROIWidth * objROI.ref_ROIHeight + 1, false, 0xED); // 2020 03 10 -> Plus 1 to max value to make sure blob with ROI size able to be detected.
            
            if (intSelectedObjectNum == 0)
                return true;

            int intObjectTotalArea = 0;
            int intObjectArea = 0;
            int intLengthMode = 0;
            float fObjectHeight = 0, fObjectWidth = 0, fObjectCenterX = 0, fObjectCenterY = 0, fObjectAngle = 0;
            bool blnOverAllFail = false;
            for (int i = 0; i < intSelectedObjectNum; i++)
            {
                intObjectArea = m_objPackageEBlobs.ref_arrArea[i];

                //if (m_objPackageEBlobs.ref_arrRectWidth[i] < m_objPackageEBlobs.ref_arrRectHeight[i])
                //{
                //    fObjectWidth = m_objPackageEBlobs.ref_arrRectWidth[i];
                //    fObjectHeight = m_objPackageEBlobs.ref_arrRectHeight[i];
                //    intLengthMode = 0;
                //    fObjectAngle = m_objPackageEBlobs.ref_arrRectAngle[i];

                //    if (fObjectAngle < 0)
                //        fObjectAngle = -Math.Abs(fObjectAngle);
                //    else
                //        fObjectAngle = -fObjectAngle;

                //}
                //else
                //{
                //    fObjectHeight = m_objPackageEBlobs.ref_arrRectWidth[i];
                //    fObjectWidth = m_objPackageEBlobs.ref_arrRectHeight[i];
                //    intLengthMode = 0;

                //    fObjectAngle = m_objPackageEBlobs.ref_arrRectAngle[i];
                //    if (fObjectAngle < 0)
                //        fObjectAngle = Math.Abs(fObjectAngle);
                //    else
                //        fObjectAngle = 90 - (fObjectAngle);

                //}

                if (m_objPackageEBlobs.ref_arrRectHeight[i] < m_objPackageEBlobs.ref_arrRectWidth[i])
                {
                    fObjectWidth = m_objPackageEBlobs.ref_arrRectHeight[i];
                    fObjectHeight = m_objPackageEBlobs.ref_arrRectWidth[i];
                    intLengthMode = 0;
                    fObjectAngle = m_objPackageEBlobs.ref_arrRectAngle[i];

                    if (fObjectAngle >= 10)//&& fAngle <= 80)
                        fObjectAngle = m_objPackageEBlobs.ref_arrRectAngle[i] - 90;
                    else
                        fObjectAngle = 90 + m_objPackageEBlobs.ref_arrRectAngle[i];

                }
                else
                {
                    fObjectHeight = m_objPackageEBlobs.ref_arrRectHeight[i];
                    fObjectWidth = m_objPackageEBlobs.ref_arrRectWidth[i];
                    intLengthMode = 0;

                    fObjectAngle = m_objPackageEBlobs.ref_arrRectAngle[i];

                }
                fObjectCenterX = m_objPackageEBlobs.ref_arrRectLimitCenterX[i];
                fObjectCenterY = m_objPackageEBlobs.ref_arrRectLimitCenterY[i];

                intObjectTotalArea += intObjectArea;

                bool blnFail = false;
                int intFailMask = 0;
                string strDefectName = "Bright";

                if ((m_intPkgFailMask & 0x100) > 0)
                {
                    if (m_arrWantDefectLength[(int)eWantDefect.Bright])
                    {
                        if (m_intBrightDefectDimensionFailCondition == 0)
                        {
                            if (fObjectWidth >= GetDefect("Bright", 0))
                            {
                                m_strErrorMessage += "* Package Bright Field Width Fail. Set = " + (GetDefect("Bright", 0) / m_fMMToPixelXValue).ToString("f4") + " mm,   Result = " + (fObjectWidth / m_fMMToPixelXValue).ToString("f4") + " mm";
                                blnFail = true;
                                intFailMask |= 0x01;
                                strDefectName = "Bright";
                            }

                            if (fObjectHeight >= GetDefect("Bright", 1))
                            {
                                m_strErrorMessage += "* Package Bright Field Length Fail. Set = " + (GetDefect("Bright", 1) / m_fMMToPixelYValue).ToString("f4") + " mm,   Result = " + (fObjectHeight / m_fMMToPixelYValue).ToString("f4") + " mm";
                                blnFail = true;
                                intFailMask |= 0x02;
                                strDefectName = "Bright";
                            }
                        }
                        else
                        {
                            if ((fObjectWidth >= GetDefect("Bright", 0)) && (fObjectHeight >= GetDefect("Bright", 1)))
                            {
                                m_strErrorMessage += "* Package Bright Field Width Fail. Set = " + (GetDefect("Bright", 0) / m_fMMToPixelXValue).ToString("f4") + " mm,   Result = " + (fObjectWidth / m_fMMToPixelXValue).ToString("f4") + " mm";
                                intFailMask |= 0x01;
                                m_strErrorMessage += "* Package Bright Field Length Fail. Set = " + (GetDefect("Bright", 1) / m_fMMToPixelYValue).ToString("f4") + " mm,   Result = " + (fObjectHeight / m_fMMToPixelYValue).ToString("f4") + " mm";
                                blnFail = true;
                                intFailMask |= 0x02;
                                strDefectName = "Bright";
                            }
                        }
                    }

                    if (m_arrWantDefectArea[(int)eWantDefect.Bright])
                    {
                        if (intObjectArea >= GetAreaDefect("Bright"))
                        {
                            m_strErrorMessage += "* Package Bright Field Area Fail. Set = " + (GetAreaDefect("Scratch") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                            blnFail = true;
                            intFailMask |= 0x04;
                            strDefectName = "Bright";
                        }
                    }

                }

                if (blnFail)
                {
                    Defect objDefect = new Defect();
                    objDefect.ref_fDimX = fObjectWidth;
                    objDefect.ref_fDimY = fObjectHeight;
                    objDefect.ref_intLengthMode = intLengthMode;
                    objDefect.ref_fArea = intObjectArea;
                    objDefect.ref_fCenterX = objROI.ref_ROITotalX + fObjectCenterX;
                    objDefect.ref_fCenterY = objROI.ref_ROITotalY + fObjectCenterY;
                    objDefect.ref_intBlobNo = i;
                    objDefect.ref_fAngle = fObjectAngle;
                    objDefect.ref_intFailMask = intFailMask;
                    objDefect.ref_strName = strDefectName;
                    objDefect.ref_intFailedImage = intSelectedImageIndex + 1;

                    if (m_arrDefectList.Count != 0)
                        m_arrDefectList2.Add(m_arrDefectList.Clone());

                    m_arrDefectList.Add(objDefect);

                    if (!blnOverAllFail)
                        blnOverAllFail = true;
                }
                else
                {
                    Defect objDefect = new Defect();
                    objDefect.ref_fDimX = fObjectWidth;
                    objDefect.ref_fDimY = fObjectHeight;
                    objDefect.ref_intLengthMode = intLengthMode;
                    objDefect.ref_fArea = intObjectArea;
                    objDefect.ref_fCenterX = objROI.ref_ROITotalX + fObjectCenterX;
                    objDefect.ref_fCenterY = objROI.ref_ROITotalY + fObjectCenterY;
                    objDefect.ref_intBlobNo = i;
                    objDefect.ref_fAngle = fObjectAngle;
                    objDefect.ref_intFailMask = 0;
                    objDefect.ref_strName = strDefectName;
                    objDefect.ref_intFailedImage = intSelectedImageIndex + 1;

                    if (m_arrDefectList.Count != 0)
                        m_arrDefectList2.Add(m_arrDefectList.Clone());

                    m_arrDefectList.Add(objDefect);
                }
            }

            if (m_arrWantDefectArea[(int)eWantDefect.Bright])
            {
                if (intObjectTotalArea >= GetTotalAreaDefect("Bright"))
                {
                    m_strErrorMessage += "* Package Bright Field Total Area Fail. Set = " + (GetTotalAreaDefect("Bright") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectTotalArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                    m_blnPkgViewFailTotalArea = true;

                    Defect objDefect = new Defect();
                    objDefect.ref_fDimX = -1;
                    objDefect.ref_fDimY = -1;
                    objDefect.ref_intLengthMode = 0;
                    objDefect.ref_fArea = intObjectTotalArea;
                    objDefect.ref_fCenterX = objROI.ref_ROITotalX + m_objPackageEBlobs.ref_arrLimitCenterX[0];
                    objDefect.ref_fCenterY = objROI.ref_ROITotalY + m_objPackageEBlobs.ref_arrLimitCenterY[0];
                    objDefect.ref_intFailMask |= 0x04;
                    objDefect.ref_fAngle = fObjectAngle;
                    objDefect.ref_strName = "Total Bright";
                    objDefect.ref_intFailedImage = intSelectedImageIndex + 1;

                    if (m_arrDefectList.Count != 0)
                        m_arrDefectList2.Add(m_arrDefectList.Clone());

                    m_arrDefectList.Add(objDefect);

                    if (!blnOverAllFail)
                        blnOverAllFail = true;
                }
            }

            if (blnOverAllFail)
            {
                m_intPkgFailResultMask |= 0x100;
                return false;
            }
            else
                return true;
        }
        private bool InspectionImage12BrightFieldDefect_WithLinkFunction(ROI objROI)
        {
            int intSelectedImageIndex = m_arrGrabImageIndex[2];
            //EasyImage.CloseDisk(objROI.ref_ROI, objROI.ref_ROI, 3);
            //objROI.SaveImage("D:\\objROI.bmp");
            bool blnWantDebug = false;
            if (blnWantDebug)
            {
                objROI.SaveImage("D:\\TS\\InspectPackageView_ROI.bmp");
            }

            int intSelectedObjectNum = m_objPackageEBlobs.BuildObjects_Filter_GetElement(objROI, false, m_intConnexity == 4,
                            0, m_intBrightFieldLowThreshold, m_intBrightFieldMinArea, objROI.ref_ROIWidth * objROI.ref_ROIHeight + 1, false, 0xED);// 2020 03 10 -> Plus 1 to max value to make sure blob with ROI size able to be detected.
            //0, m_intBrightFieldLowThreshold, m_intBrightFieldMinArea, objROI.ref_ROIWidth * objROI.ref_ROIHeight, false, 0xED); // 2019 09 03 - change max area from 15000 to  objROI.ref_ROIWidth * objROI.ref_ROIHeight to make sure big defect able to be detected.

            if (intSelectedObjectNum == 0)
                return true;
            List<List<System.Windows.Point>> arr2DPoints = new List<List<System.Windows.Point>>();
            List<List<PointF>> arrRotatedPoints = new List<List<PointF>>();
            //List<float> fMaxX = new List<float>(), fMaxY = new List<float>(), fMinX = new List<float>(), fMinY = new List<float>();
            //List<float> fMaxLimitX = new List<float>(), fMaxLimitY = new List<float>(), fMinLimitX = new List<float>(), fMinLimitY = new List<float>();
            List<float> fObjectHeightList = new List<float>(), fObjectWidthList = new List<float>(), fObjectCenterXList = new List<float>(), fObjectCenterYList = new List<float>(), fObjectAngleList = new List<float>();
            List<float> fObjectLimitHeightList = new List<float>(), fObjectLimitWidthList = new List<float>(), fObjectLimitCenterXList = new List<float>(), fObjectLimitCenterYList = new List<float>();
            List<int> fObjectAreaList = new List<int>(), fObjectAreaList2 = new List<int>();
            int intObjectTotalArea = 0;
            int intObjectArea = 0;
            int intLengthMode = 0;
            float fObjectHeight = 0, fObjectWidth = 0, fObjectCenterX = 0, fObjectCenterY = 0, fObjectAngle = 0;
            float fObjectLimitHeight = 0, fObjectLimitWidth = 0, fObjectLimitCenterX = 0, fObjectLimitCenterY = 0;
            bool blnOverAllFail = false;
            for (int i = 0; i < intSelectedObjectNum; i++)
            {
                arrRotatedPoints.Add(new List<PointF>());
                arr2DPoints.Add(new List<System.Windows.Point>());
                intObjectArea = m_objPackageEBlobs.ref_arrArea[i];
               
                //if (m_objPackageEBlobs.ref_arrRectWidth[i] < m_objPackageEBlobs.ref_arrRectHeight[i])
                //{
                //    fObjectWidth = m_objPackageEBlobs.ref_arrRectWidth[i];
                //    fObjectHeight = m_objPackageEBlobs.ref_arrRectHeight[i];
                //    intLengthMode = 0;
                //    fObjectAngle = m_objPackageEBlobs.ref_arrRectAngle[i];

                //    if (fObjectAngle < 0)
                //        fObjectAngle = -Math.Abs(fObjectAngle);
                //    else
                //        fObjectAngle = -fObjectAngle;

                //}
                //else
                //{
                //    fObjectHeight = m_objPackageEBlobs.ref_arrRectWidth[i];
                //    fObjectWidth = m_objPackageEBlobs.ref_arrRectHeight[i];
                //    intLengthMode = 0;

                //    fObjectAngle = m_objPackageEBlobs.ref_arrRectAngle[i];
                //    if (fObjectAngle < 0)
                //        fObjectAngle = Math.Abs(fObjectAngle);
                //    else
                //        fObjectAngle = 90 - (fObjectAngle);

                //}

                if (m_objPackageEBlobs.ref_arrRectHeight[i] < m_objPackageEBlobs.ref_arrRectWidth[i])
                {
                    fObjectWidth = m_objPackageEBlobs.ref_arrRectHeight[i];
                    fObjectHeight = m_objPackageEBlobs.ref_arrRectWidth[i];
                    intLengthMode = 0;
                    fObjectAngle = m_objPackageEBlobs.ref_arrRectAngle[i];
                    
                    if (fObjectAngle >= 10)//&& fAngle <= 80)
                        fObjectAngle = m_objPackageEBlobs.ref_arrRectAngle[i] - 90;
                    else
                        fObjectAngle = 90 + m_objPackageEBlobs.ref_arrRectAngle[i];

                }
                else
                {
                    fObjectHeight = m_objPackageEBlobs.ref_arrRectHeight[i];
                    fObjectWidth = m_objPackageEBlobs.ref_arrRectWidth[i];
                    intLengthMode = 0;

                    fObjectAngle = m_objPackageEBlobs.ref_arrRectAngle[i];
                  
                }
                fObjectCenterX = m_objPackageEBlobs.ref_arrRectLimitCenterX[i];
                fObjectCenterY = m_objPackageEBlobs.ref_arrRectLimitCenterY[i];

                fObjectLimitCenterX = m_objPackageEBlobs.ref_arrLimitCenterX[i];
                fObjectLimitCenterY = m_objPackageEBlobs.ref_arrLimitCenterY[i];
                fObjectLimitWidth = m_objPackageEBlobs.ref_arrWidth[i];
                fObjectLimitHeight = m_objPackageEBlobs.ref_arrHeight[i];

                intObjectTotalArea += intObjectArea;
                //float MaxX = 0, MaxY = 0, MinX = 0, MinY = 0;
                float newX1 = 0, newY1 = 0;  // new point 1
                float newX2 = 0, newY2 = 0; // new point 2
                float newX3 = 0, newY3 = 0; // new point 3
                float newX4 = 0, newY4 = 0; // new point 4

                //float MaxLimitX = 0, MaxLimitY = 0, MinLimitX = 0, MinLimitY = 0;
                //float newLimitX1 = 0, newLimitY1 = 0;  // new point 1
                //float newLimitX2 = 0, newLimitY2 = 0; // new point 2
                //float newLimitX3 = 0, newLimitY3 = 0; // new point 3
                //float newLimitX4 = 0, newLimitY4 = 0; // new point 4
                ////  Point 1 *-------------* Point 3
                ////          |             |
                ////          |             |
                ////          |             |
                ////  Point 2 *-------------* Point 4

                //Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX - (fObjectWidth / 2)), (fObjectCenterY - (fObjectHeight / 2)), fObjectAngle, ref newX1, ref newY1);
                //Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX - (fObjectWidth / 2)), (fObjectCenterY + (fObjectHeight / 2)), fObjectAngle, ref newX2, ref newY2);
                //Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX + (fObjectWidth / 2)), (fObjectCenterY - (fObjectHeight / 2)), fObjectAngle, ref newX3, ref newY3);
                //Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX + (fObjectWidth / 2)), (fObjectCenterY + (fObjectHeight / 2)), fObjectAngle, ref newX4, ref newY4);


                //2020-12-18 ZJYEOH : Change to this format
                //  Point 1 *-------------* Point 2
                //          |             |
                //          |             |
                //          |             |
                //  Point 4 *-------------* Point 3

                Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX - (fObjectWidth / 2)), (fObjectCenterY - (fObjectHeight / 2)), fObjectAngle, ref newX1, ref newY1);
                Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX + (fObjectWidth / 2)), (fObjectCenterY - (fObjectHeight / 2)), fObjectAngle, ref newX2, ref newY2);
                Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX + (fObjectWidth / 2)), (fObjectCenterY + (fObjectHeight / 2)), fObjectAngle, ref newX3, ref newY3);
                Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX - (fObjectWidth / 2)), (fObjectCenterY + (fObjectHeight / 2)), fObjectAngle, ref newX4, ref newY4);


                arrRotatedPoints[i].Add(new PointF(newX1, newY1));
                arrRotatedPoints[i].Add(new PointF(newX2, newY2));
                arrRotatedPoints[i].Add(new PointF(newX3, newY3));
                arrRotatedPoints[i].Add(new PointF(newX4, newY4));

                Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX - (fObjectWidth / 2)) - m_intBrightDefectLinkTolerance, (fObjectCenterY - (fObjectHeight / 2)) - m_intBrightDefectLinkTolerance, fObjectAngle, ref newX1, ref newY1);
                Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX + (fObjectWidth / 2)) + m_intBrightDefectLinkTolerance, (fObjectCenterY - (fObjectHeight / 2)) - m_intBrightDefectLinkTolerance, fObjectAngle, ref newX2, ref newY2);
                Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX + (fObjectWidth / 2)) + m_intBrightDefectLinkTolerance, (fObjectCenterY + (fObjectHeight / 2)) + m_intBrightDefectLinkTolerance, fObjectAngle, ref newX3, ref newY3);
                Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX - (fObjectWidth / 2)) - m_intBrightDefectLinkTolerance, (fObjectCenterY + (fObjectHeight / 2)) + m_intBrightDefectLinkTolerance, fObjectAngle, ref newX4, ref newY4);

                arr2DPoints[i].Add(new System.Windows.Point(newX1, newY1));
                arr2DPoints[i].Add(new System.Windows.Point(newX2, newY2));
                arr2DPoints[i].Add(new System.Windows.Point(newX3, newY3));
                arr2DPoints[i].Add(new System.Windows.Point(newX4, newY4));
                
                //newLimitX1 = (fObjectLimitCenterX - (fObjectLimitWidth / 2));
                //newLimitY1 = (fObjectLimitCenterY - (fObjectLimitHeight / 2));

                //newLimitX2 = (fObjectLimitCenterX - (fObjectLimitWidth / 2));
                //newLimitY2 = (fObjectLimitCenterY + (fObjectLimitHeight / 2));

                //newLimitX3 = (fObjectLimitCenterX + (fObjectLimitWidth / 2));
                //newLimitY3 = (fObjectLimitCenterY - (fObjectLimitHeight / 2));

                //newLimitX4 = (fObjectLimitCenterX + (fObjectLimitWidth / 2));
                //newLimitY4 = (fObjectLimitCenterY + (fObjectLimitHeight / 2));

                //if (Math.Max(newX1, newX2) > Math.Max(newX3, newX4))
                //{
                //    MaxX = Math.Max(newX1, newX2);
                //}
                //else
                //{
                //    MaxX = Math.Max(newX3, newX4);
                //}
                //if (Math.Max(newY1, newY2) > Math.Max(newY3, newY4))
                //{
                //    MaxY = Math.Max(newY1, newY2);
                //}
                //else
                //{
                //    MaxY = Math.Max(newY3, newY4);
                //}
                //if (Math.Min(newX1, newX2) < Math.Min(newX3, newX4))
                //{
                //    MinX = Math.Min(newX1, newX2);
                //}
                //else
                //{
                //    MinX = Math.Min(newX3, newX4);
                //}
                //if (Math.Min(newY1, newY2) < Math.Min(newY3, newY4))
                //{
                //    MinY = Math.Min(newY1, newY2);
                //}
                //else
                //{
                //    MinY = Math.Min(newY3, newY4);
                //}
                ////////////////////////////////////////////////////////////////////
                //if (Math.Max(newLimitX1, newLimitX2) > Math.Max(newLimitX3, newLimitX4))
                //{
                //    MaxLimitX = Math.Max(newLimitX1, newLimitX2);
                //}
                //else
                //{
                //    MaxLimitX = Math.Max(newLimitX3, newLimitX4);
                //}
                //if (Math.Max(newLimitY1, newLimitY2) > Math.Max(newLimitY3, newLimitY4))
                //{
                //    MaxLimitY = Math.Max(newLimitY1, newLimitY2);
                //}
                //else
                //{
                //    MaxLimitY = Math.Max(newLimitY3, newLimitY4);
                //}
                //if (Math.Min(newLimitX1, newLimitX2) < Math.Min(newLimitX3, newLimitX4))
                //{
                //    MinLimitX = Math.Min(newLimitX1, newLimitX2);
                //}
                //else
                //{
                //    MinLimitX = Math.Min(newLimitX3, newLimitX4);
                //}
                //if (Math.Min(newLimitY1, newLimitY2) < Math.Min(newLimitY3, newLimitY4))
                //{
                //    MinLimitY = Math.Min(newLimitY1, newLimitY2);
                //}
                //else
                //{
                //    MinLimitY = Math.Min(newLimitY3, newLimitY4);
                //}
                //fMaxX.Add(MaxX);
                //fMaxY.Add(MaxY);
                //fMinX.Add(MinX);
                //fMinY.Add(MinY);
                //fMaxLimitX.Add(MaxLimitX);
                //fMaxLimitY.Add(MaxLimitY);
                //fMinLimitX.Add(MinLimitX);
                //fMinLimitY.Add(MinLimitY);
                fObjectHeightList.Add(fObjectHeight);
                fObjectWidthList.Add(fObjectWidth);
                fObjectCenterXList.Add(fObjectCenterX);
                fObjectCenterYList.Add(fObjectCenterY);
                fObjectAngleList.Add(fObjectAngle);
                fObjectAreaList.Add(intObjectArea);
                fObjectAreaList2.Add(intObjectArea);
            }
            int intTolerance = m_intBrightDefectLinkTolerance;
            int intAngleTolerance = 10;
            bool blnDecrement = false;
            if (intTolerance >= 0)
            {
                for (int i = 0; i < fObjectHeightList.Count; i++)
                {
                    if (blnDecrement)
                    {
                        blnDecrement = false;
                        if(i>0)
                        i--;
                    }
                    for (int j = 0; j < fObjectHeightList.Count; j++)
                    {
                        if (i != j && i < fObjectHeightList.Count && j < fObjectHeightList.Count)
                        {

                            //if (((fMinY[i] - intTolerance) <= fMaxY[j])// first blob is below second blob,  first blob is after second blob
                            //     && ((fMinY[i]) >= fMinY[j])
                            //    && ((fMinX[i] - intTolerance) <= fMaxX[j])
                            //    && ((fMinX[i]) >= fMinX[j]))
                            if (Intersection.CheckRectRectIntersection(arr2DPoints[i].ToArray(), arr2DPoints[j].ToArray(), intTolerance))
                            {
                                //if (fObjectAreaList2[i] >= fObjectAreaList2[j])
                                //{
                                //    if (fObjectAngleList[i] > 0 && fObjectAngleList[j] > 0)
                                //    {
                                //        if (Math.Abs(fObjectAngleList[i] - fObjectAngleList[j]) > intAngleTolerance)
                                //            continue;
                                //    }
                                //    else if (fObjectAngleList[i] < 0 && fObjectAngleList[j] < 0)
                                //    {
                                //        if (Math.Abs(fObjectAngleList[i] - fObjectAngleList[j]) > intAngleTolerance)
                                //            continue;
                                //    }
                                //    else
                                //        continue;

                                //    fObjectAngleList[i] = fObjectAngleList[i];
                                //    fObjectAreaList2[i] = fObjectAreaList2[i];


                                //}
                                //else
                                //{

                                //    if (fObjectAngleList[i] > 0 && fObjectAngleList[j] > 0)
                                //    {
                                //        if (Math.Abs(fObjectAngleList[i] - fObjectAngleList[j]) > intAngleTolerance)
                                //            continue;
                                //    }
                                //    else if (fObjectAngleList[i] < 0 && fObjectAngleList[j] < 0)
                                //    {
                                //        if (Math.Abs(fObjectAngleList[i] - fObjectAngleList[j]) > intAngleTolerance)
                                //            continue;
                                //    }
                                //    else
                                //        continue;

                                //    fObjectAngleList[i] = fObjectAngleList[j];
                                //    fObjectAreaList2[i] = fObjectAreaList2[j];
                                //}
                                //if (Math.Abs(Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i])) - Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i])))
                                //    >= Math.Abs(Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i])) - Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i]))))
                                //{
                                //    fObjectHeightList[i] = Math.Abs(Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i])) - Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i])));
                                //    fObjectWidthList[i] = Math.Abs(Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i])) - Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i])));
                                //    //fObjectCenterXList[i] = (fMaxX[i] + fMinX[j]) / 2;
                                //    //fObjectCenterYList[i] = (fMaxY[i] + fMinY[j]) / 2;
                                //    fObjectAngleList[i] = 0;
                                //}
                                //else
                                //{
                                //    fObjectWidthList[i] = Math.Abs(Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i])) - Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i])));
                                //    fObjectHeightList[i] = Math.Abs(Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i])) - Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i])));
                                //    //fObjectCenterXList[i] = (fMaxY[i] + fMinY[j]) / 2;
                                //    //fObjectCenterYList[i] = (fMaxX[i] + fMinX[j]) / 2;
                                //    fObjectAngleList[i] = 90;
                                //}
                                //fObjectCenterXList[i] = (Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i])) + Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i]))) / 2;
                                //fObjectCenterYList[i] = (Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i])) + Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i]))) / 2;

                                PointF[] arrPoints = new PointF[8];

                                arrPoints[0] = arrRotatedPoints[i][0];
                                arrPoints[1] = arrRotatedPoints[i][1];
                                arrPoints[2] = arrRotatedPoints[i][2];
                                arrPoints[3] = arrRotatedPoints[i][3];
                                arrPoints[4] = arrRotatedPoints[j][0];
                                arrPoints[5] = arrRotatedPoints[j][1];
                                arrPoints[6] = arrRotatedPoints[j][2];
                                arrPoints[7] = arrRotatedPoints[j][3];

                                float fMinAngle = 0;
                                List<PointF> arrMinRect = new List<PointF>();
                                arrMinRect = MinimumBoundingBox.CalculateMinimumBoundingBox(arrPoints, ref fMinAngle);

                                if (fMinAngle < 0)
                                    fObjectAngleList[i] = -(90 + fMinAngle);
                                else
                                    fObjectAngleList[i] = 90 - fMinAngle;

                                Line onjLine1 = new Line();
                                Line onjLine2 = new Line();
                                onjLine1.CalculateStraightLine(arrMinRect[0], arrMinRect[2]);
                                onjLine2.CalculateStraightLine(arrMinRect[1], arrMinRect[3]);
                                PointF pCenter = Line.GetCrossPoint(onjLine1, onjLine2);
                                float p1X = 0, p1Y = 0;
                                float p2X = 0, p2Y = 0;
                                float p3X = 0, p3Y = 0;
                                float p4X = 0, p4Y = 0;
                                Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[0].X, arrMinRect[0].Y, -fObjectAngleList[i], ref p1X, ref p1Y);
                                Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[1].X, arrMinRect[1].Y, -fObjectAngleList[i], ref p2X, ref p2Y);
                                Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[2].X, arrMinRect[2].Y, -fObjectAngleList[i], ref p3X, ref p3Y);
                                Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[3].X, arrMinRect[3].Y, -fObjectAngleList[i], ref p4X, ref p4Y);

                                float pR1X = 0, pR1Y = 0;
                                float pR2X = 0, pR2Y = 0;
                                float pR3X = 0, pR3Y = 0;
                                float pR4X = 0, pR4Y = 0;
                                Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X),Math.Min(p3X, p4X)), Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)), fObjectAngleList[i], ref pR1X, ref pR1Y); // Top Left
                                Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)), Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)), fObjectAngleList[i], ref pR2X, ref pR2Y); // Top Right
                                Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)), Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)), fObjectAngleList[i], ref pR3X, ref pR3Y); // Bottom Right
                                Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)), Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)), fObjectAngleList[i], ref pR4X, ref pR4Y); // Bottom Left
                                arrMinRect[0] = new PointF(pR1X, pR1Y);
                                arrMinRect[1] = new PointF(pR2X, pR2Y);
                                arrMinRect[2] = new PointF(pR3X, pR3Y);
                                arrMinRect[3] = new PointF(pR4X, pR4Y);

                                //arrRotatedPoints[i][0] = arrMinRect[3];
                                //arrRotatedPoints[i][1] = arrMinRect[2];
                                //arrRotatedPoints[i][2] = arrMinRect[0];
                                //arrRotatedPoints[i][3] = arrMinRect[1];
                                arrRotatedPoints[i][0] = arrMinRect[0];
                                arrRotatedPoints[i][1] = arrMinRect[1];
                                arrRotatedPoints[i][2] = arrMinRect[2];
                                arrRotatedPoints[i][3] = arrMinRect[3];

                                Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)) - m_intBrightDefectLinkTolerance, Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)) - m_intBrightDefectLinkTolerance, fObjectAngleList[i], ref pR1X, ref pR1Y); // Top Left
                                Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)) + m_intBrightDefectLinkTolerance, Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)) - m_intBrightDefectLinkTolerance, fObjectAngleList[i], ref pR2X, ref pR2Y); // Top Right
                                Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)) + m_intBrightDefectLinkTolerance, Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)) + m_intBrightDefectLinkTolerance, fObjectAngleList[i], ref pR3X, ref pR3Y); // Bottom Right
                                Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)) - m_intBrightDefectLinkTolerance, Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)) + m_intBrightDefectLinkTolerance, fObjectAngleList[i], ref pR4X, ref pR4Y); // Bottom Left

                                arr2DPoints[i][0] = new System.Windows.Point(pR1X, pR1Y);
                                arr2DPoints[i][1] = new System.Windows.Point(pR2X, pR2Y);
                                arr2DPoints[i][2] = new System.Windows.Point(pR3X, pR3Y);
                                arr2DPoints[i][3] = new System.Windows.Point(pR4X, pR4Y);

                                arrRotatedPoints.RemoveAt(j);
                                arr2DPoints.RemoveAt(j);

                                float fDiffX = Math.Max(Math.Abs(p1X - p4X), Math.Abs(p2X - p3X));
                                float fDiffY = Math.Max(Math.Abs(p3Y - p4Y), Math.Abs(p2Y - p1Y));
                                //float fWidth = (int)Math.Round((fDiffX * Math.Cos((fMinAngle + 180) * Math.PI / 180)) + (fDiffY * Math.Sin((fMinAngle + 180) * Math.PI / 180)));
                                //float fHeight = (int)Math.Round((fDiffX * Math.Sin((fMinAngle + 180) * Math.PI / 180)) + (fDiffY * Math.Cos((fMinAngle + 180) * Math.PI / 180)));
                                fObjectWidthList[i] = fDiffX;
                                fObjectHeightList[i] = fDiffY;

                                fObjectCenterXList[i] = pCenter.X;
                                fObjectCenterYList[i] = pCenter.Y;

                                fObjectAreaList2.RemoveAt(j);
                                fObjectAreaList[i] = fObjectAreaList[i] + fObjectAreaList[j];
                                //fMinX[i] = Math.Min(Math.Min(arrMinRect[0].X, arrMinRect[1].X), Math.Min(arrMinRect[2].X, arrMinRect[3].X));
                                //fMinY[i] = Math.Min(Math.Min(arrMinRect[0].Y, arrMinRect[1].Y), Math.Min(arrMinRect[2].Y, arrMinRect[3].Y));
                                //fMaxX[i] = Math.Max(Math.Max(arrMinRect[0].X, arrMinRect[1].X), Math.Max(arrMinRect[2].X, arrMinRect[3].X));
                                //fMaxY[i] = Math.Max(Math.Max(arrMinRect[0].Y, arrMinRect[1].Y), Math.Max(arrMinRect[2].Y, arrMinRect[3].Y));
                                //fMinLimitX[i] = Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i]));
                                //fMinLimitY[i] = Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i]));
                                //fMaxLimitX[i] = Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i]));
                                //fMaxLimitY[i] = Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i]));
                                //fMinX[i] = Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i]));
                                //fMinY[i] = Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i]));
                                //fMaxX[i] = Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i]));
                                //fMaxY[i] = Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i]));
                                //fMinLimitX[i] = Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i]));
                                //fMinLimitY[i] = Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i]));
                                //fMaxLimitX[i] = Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i]));
                                //fMaxLimitY[i] = Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i]));
                                fObjectHeightList.RemoveAt(j);
                                fObjectWidthList.RemoveAt(j);
                                fObjectCenterXList.RemoveAt(j);
                                fObjectCenterYList.RemoveAt(j);
                                fObjectAngleList.RemoveAt(j);
                                fObjectAreaList.RemoveAt(j);
                                //fMaxLimitX.RemoveAt(j);
                                //fMaxLimitY.RemoveAt(j);
                                //fMinLimitX.RemoveAt(j);
                                //fMinLimitY.RemoveAt(j);
                                //fMaxX.RemoveAt(j);
                                //fMaxY.RemoveAt(j);
                                //fMinX.RemoveAt(j);
                                //fMinY.RemoveAt(j);
                                if (j > 0)
                                    j = -1;
                                if (i > 0)
                                {
                                    i = 0;
                                    //blnDecrement = true;
                                }
                                else
                                    blnDecrement = true;

                            }
                            //else if (((fMinY[i] - intTolerance) <= fMaxY[j])// first blob is below second blob, first blob is before second blob
                            //    && ((fMinY[i]) >= fMinY[j])
                            //   && ((fMaxX[i] + intTolerance) >= fMinX[j])
                            //    && ((fMaxX[i]) <= fMaxX[j]))
                            //{
                            //    //if (fObjectAreaList2[i] >= fObjectAreaList2[j])
                            //    //{
                            //    //    if (fObjectAngleList[i] > 0 && fObjectAngleList[j] > 0)
                            //    //    {
                            //    //        if (Math.Abs(fObjectAngleList[i] - fObjectAngleList[j]) > intAngleTolerance)
                            //    //            continue;
                            //    //    }
                            //    //    else if (fObjectAngleList[i] < 0 && fObjectAngleList[j] < 0)
                            //    //    {
                            //    //        if (Math.Abs(fObjectAngleList[i] - fObjectAngleList[j]) > intAngleTolerance)
                            //    //            continue;
                            //    //    }
                            //    //    else
                            //    //        continue;

                            //    //    fObjectAngleList[i] = fObjectAngleList[i];
                            //    //    fObjectAreaList2[i] = fObjectAreaList2[i];


                            //    //}
                            //    //else
                            //    //{

                            //    //    if (fObjectAngleList[i] > 0 && fObjectAngleList[j] > 0)
                            //    //    {
                            //    //        if (Math.Abs(fObjectAngleList[i] - fObjectAngleList[j]) > intAngleTolerance)
                            //    //            continue;
                            //    //    }
                            //    //    else if (fObjectAngleList[i] < 0 && fObjectAngleList[j] < 0)
                            //    //    {
                            //    //        if (Math.Abs(fObjectAngleList[i] - fObjectAngleList[j]) > intAngleTolerance)
                            //    //            continue;
                            //    //    }
                            //    //    else
                            //    //        continue;

                            //    //    fObjectAngleList[i] = fObjectAngleList[j];
                            //    //    fObjectAreaList2[i] = fObjectAreaList2[j];
                            //    //}
                            //    //if (Math.Abs(Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i])) - Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i])))
                            //    //    >= Math.Abs(Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i])) - Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i]))))
                            //    //{
                            //    //    fObjectHeightList[i] = Math.Abs(Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i])) - Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i])));
                            //    //    fObjectWidthList[i] = Math.Abs(Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i])) - Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i])));
                            //    //    //fObjectCenterXList[i] = (fMaxX[i] + fMinX[j]) / 2;
                            //    //    //fObjectCenterYList[i] = (fMaxY[i] + fMinY[j]) / 2;
                            //    //    fObjectAngleList[i] = 0;
                            //    //}
                            //    //else
                            //    //{
                            //    //    fObjectWidthList[i] = Math.Abs(Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i])) - Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i])));
                            //    //    fObjectHeightList[i] = Math.Abs(Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i])) - Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i])));
                            //    //    //fObjectCenterXList[i] = (fMaxY[i] + fMinY[j]) / 2;
                            //    //    //fObjectCenterYList[i] = (fMaxX[i] + fMinX[j]) / 2;
                            //    //    fObjectAngleList[i] = 90;
                            //    //}
                            //    //fObjectCenterXList[i] = (Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i])) + Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i]))) / 2;
                            //    //fObjectCenterYList[i] = (Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i])) + Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i]))) / 2;

                            //    PointF[] arrPoints = new PointF[8];

                            //    arrPoints[0] = arrRotatedPoints[i][0];
                            //    arrPoints[1] = arrRotatedPoints[i][1];
                            //    arrPoints[2] = arrRotatedPoints[i][2];
                            //    arrPoints[3] = arrRotatedPoints[i][3];
                            //    arrPoints[4] = arrRotatedPoints[j][0];
                            //    arrPoints[5] = arrRotatedPoints[j][1];
                            //    arrPoints[6] = arrRotatedPoints[j][2];
                            //    arrPoints[7] = arrRotatedPoints[j][3];

                            //    float fMinAngle = 0;
                            //    List<PointF> arrMinRect = new List<PointF>();
                            //    arrMinRect = MinimumBoundingBox.CalculateMinimumBoundingBox(arrPoints, ref fMinAngle);

                            //    arrRotatedPoints[i][0] = arrMinRect[3];
                            //    arrRotatedPoints[i][1] = arrMinRect[2];
                            //    arrRotatedPoints[i][2] = arrMinRect[0];
                            //    arrRotatedPoints[i][3] = arrMinRect[1];
                            //    arrRotatedPoints.RemoveAt(j);

                            //    if (fMinAngle < 0)
                            //        fObjectAngleList[i] = -(90 + fMinAngle);
                            //    else
                            //        fObjectAngleList[i] = 90 - fMinAngle;

                            //    Line onjLine1 = new Line();
                            //    Line onjLine2 = new Line();
                            //    onjLine1.CalculateStraightLine(arrMinRect[0], arrMinRect[2]);
                            //    onjLine2.CalculateStraightLine(arrMinRect[1], arrMinRect[3]);
                            //    PointF pCenter = Line.GetCrossPoint(onjLine1, onjLine2);
                            //    float p1X = 0, p1Y = 0;
                            //    float p2X = 0, p2Y = 0;
                            //    float p3X = 0, p3Y = 0;
                            //    float p4X = 0, p4Y = 0;
                            //    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[0].X, arrMinRect[0].Y, -fObjectAngleList[i], ref p1X, ref p1Y);
                            //    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[1].X, arrMinRect[1].Y, -fObjectAngleList[i], ref p2X, ref p2Y);
                            //    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[2].X, arrMinRect[2].Y, -fObjectAngleList[i], ref p3X, ref p3Y);
                            //    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[3].X, arrMinRect[3].Y, -fObjectAngleList[i], ref p4X, ref p4Y);

                            //    float fDiffX = Math.Max(Math.Abs(p1X - p4X), Math.Abs(p2X - p3X));
                            //    float fDiffY = Math.Max(Math.Abs(p3Y - p4Y), Math.Abs(p2Y - p1Y));
                            //    //float fWidth = (int)Math.Round((fDiffX * Math.Cos((fMinAngle + 180) * Math.PI / 180)) + (fDiffY * Math.Sin((fMinAngle + 180) * Math.PI / 180)));
                            //    //float fHeight = (int)Math.Round((fDiffX * Math.Sin((fMinAngle + 180) * Math.PI / 180)) + (fDiffY * Math.Cos((fMinAngle + 180) * Math.PI / 180)));
                            //    fObjectWidthList[i] = fDiffX;
                            //    fObjectHeightList[i] = fDiffY;

                            //    fObjectCenterXList[i] = pCenter.X;
                            //    fObjectCenterYList[i] = pCenter.Y;

                            //    fObjectAreaList2.RemoveAt(j);
                            //    fObjectAreaList[i] = fObjectAreaList[i] + fObjectAreaList[j];
                            //    fMinX[i] = Math.Min(Math.Min(arrMinRect[0].X, arrMinRect[1].X), Math.Min(arrMinRect[2].X, arrMinRect[3].X));
                            //    fMinY[i] = Math.Min(Math.Min(arrMinRect[0].Y, arrMinRect[1].Y), Math.Min(arrMinRect[2].Y, arrMinRect[3].Y));
                            //    fMaxX[i] = Math.Max(Math.Max(arrMinRect[0].X, arrMinRect[1].X), Math.Max(arrMinRect[2].X, arrMinRect[3].X));
                            //    fMaxY[i] = Math.Max(Math.Max(arrMinRect[0].Y, arrMinRect[1].Y), Math.Max(arrMinRect[2].Y, arrMinRect[3].Y));
                            //    fMinLimitX[i] = Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i]));
                            //    fMinLimitY[i] = Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i]));
                            //    fMaxLimitX[i] = Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i]));
                            //    fMaxLimitY[i] = Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i]));
                            //    //fMinX[i] = Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i]));
                            //    //fMinY[i] = Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i]));
                            //    //fMaxX[i] = Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i]));
                            //    //fMaxY[i] = Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i]));
                            //    //fMinLimitX[i] = Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i]));
                            //    //fMinLimitY[i] = Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i]));
                            //    //fMaxLimitX[i] = Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i]));
                            //    //fMaxLimitY[i] = Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i]));
                            //    fObjectHeightList.RemoveAt(j);
                            //    fObjectWidthList.RemoveAt(j);
                            //    fObjectCenterXList.RemoveAt(j);
                            //    fObjectCenterYList.RemoveAt(j);
                            //    fObjectAngleList.RemoveAt(j);
                            //    fObjectAreaList.RemoveAt(j);
                            //    fMaxLimitX.RemoveAt(j);
                            //    fMaxLimitY.RemoveAt(j);
                            //    fMinLimitX.RemoveAt(j);
                            //    fMinLimitY.RemoveAt(j);
                            //    fMaxX.RemoveAt(j);
                            //    fMaxY.RemoveAt(j);
                            //    fMinX.RemoveAt(j);
                            //    fMinY.RemoveAt(j);
                            //    if (j > 0)
                            //        j = -1;
                            //    if (i > 0)
                            //    {
                            //        i = 0;
                            //        //blnDecrement = true;
                            //    }
                            //    else
                            //        blnDecrement = true;
                            //}
                            //else if (((fMinY[j] - intTolerance) <= fMaxY[i])// first blob is above second blob, first blob is after second blob
                            //    && ((fMinY[j]) >= fMinY[i])
                            //  && ((fMinX[i] - intTolerance) <= fMaxX[j])
                            //    && ((fMinX[i]) >= fMinX[j]))
                            //{
                            //    //if (fObjectAreaList2[i] >= fObjectAreaList2[j])
                            //    //{
                            //    //    if (fObjectAngleList[i] > 0 && fObjectAngleList[j] > 0)
                            //    //    {
                            //    //        if (Math.Abs(fObjectAngleList[i] - fObjectAngleList[j]) > intAngleTolerance)
                            //    //            continue;
                            //    //    }
                            //    //    else if (fObjectAngleList[i] < 0 && fObjectAngleList[j] < 0)
                            //    //    {
                            //    //        if (Math.Abs(fObjectAngleList[i] - fObjectAngleList[j]) > intAngleTolerance)
                            //    //            continue;
                            //    //    }
                            //    //    else
                            //    //        continue;

                            //    //    fObjectAngleList[i] = fObjectAngleList[i];
                            //    //    fObjectAreaList2[i] = fObjectAreaList2[i];


                            //    //}
                            //    //else
                            //    //{

                            //    //    if (fObjectAngleList[i] > 0 && fObjectAngleList[j] > 0)
                            //    //    {
                            //    //        if (Math.Abs(fObjectAngleList[i] - fObjectAngleList[j]) > intAngleTolerance)
                            //    //            continue;
                            //    //    }
                            //    //    else if (fObjectAngleList[i] < 0 && fObjectAngleList[j] < 0)
                            //    //    {
                            //    //        if (Math.Abs(fObjectAngleList[i] - fObjectAngleList[j]) > intAngleTolerance)
                            //    //            continue;
                            //    //    }
                            //    //    else
                            //    //        continue;

                            //    //    fObjectAngleList[i] = fObjectAngleList[j];
                            //    //    fObjectAreaList2[i] = fObjectAreaList2[j];
                            //    //}
                            //    //if (Math.Abs(Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i])) - Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i])))
                            //    //    >= Math.Abs(Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i])) - Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i]))))
                            //    //{
                            //    //    fObjectHeightList[i] = Math.Abs(Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i])) - Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i])));
                            //    //    fObjectWidthList[i] = Math.Abs(Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i])) - Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i])));
                            //    //    //fObjectCenterXList[i] = (fMaxX[i] + fMinX[j]) / 2;
                            //    //    //fObjectCenterYList[i] = (fMaxY[i] + fMinY[j]) / 2;
                            //    //    fObjectAngleList[i] = 0;
                            //    //}
                            //    //else
                            //    //{
                            //    //    fObjectWidthList[i] = Math.Abs(Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i])) - Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i])));
                            //    //    fObjectHeightList[i] = Math.Abs(Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i])) - Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i])));
                            //    //    //fObjectCenterXList[i] = (fMaxY[i] + fMinY[j]) / 2;
                            //    //    //fObjectCenterYList[i] = (fMaxX[i] + fMinX[j]) / 2;
                            //    //    fObjectAngleList[i] = 90;
                            //    //}
                            //    //fObjectCenterXList[i] = (Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i])) + Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i]))) / 2;
                            //    //fObjectCenterYList[i] = (Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i])) + Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i]))) / 2;

                            //    PointF[] arrPoints = new PointF[8];

                            //    arrPoints[0] = arrRotatedPoints[i][0];
                            //    arrPoints[1] = arrRotatedPoints[i][1];
                            //    arrPoints[2] = arrRotatedPoints[i][2];
                            //    arrPoints[3] = arrRotatedPoints[i][3];
                            //    arrPoints[4] = arrRotatedPoints[j][0];
                            //    arrPoints[5] = arrRotatedPoints[j][1];
                            //    arrPoints[6] = arrRotatedPoints[j][2];
                            //    arrPoints[7] = arrRotatedPoints[j][3];

                            //    float fMinAngle = 0;
                            //    List<PointF> arrMinRect = new List<PointF>();
                            //    arrMinRect = MinimumBoundingBox.CalculateMinimumBoundingBox(arrPoints, ref fMinAngle);

                            //    arrRotatedPoints[i][0] = arrMinRect[3];
                            //    arrRotatedPoints[i][1] = arrMinRect[2];
                            //    arrRotatedPoints[i][2] = arrMinRect[0];
                            //    arrRotatedPoints[i][3] = arrMinRect[1];
                            //    arrRotatedPoints.RemoveAt(j);

                            //    if (fMinAngle < 0)
                            //        fObjectAngleList[i] = -(90 + fMinAngle);
                            //    else
                            //        fObjectAngleList[i] = 90 - fMinAngle;

                            //    Line onjLine1 = new Line();
                            //    Line onjLine2 = new Line();
                            //    onjLine1.CalculateStraightLine(arrMinRect[0], arrMinRect[2]);
                            //    onjLine2.CalculateStraightLine(arrMinRect[1], arrMinRect[3]);
                            //    PointF pCenter = Line.GetCrossPoint(onjLine1, onjLine2);
                            //    float p1X = 0, p1Y = 0;
                            //    float p2X = 0, p2Y = 0;
                            //    float p3X = 0, p3Y = 0;
                            //    float p4X = 0, p4Y = 0;
                            //    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[0].X, arrMinRect[0].Y, -fObjectAngleList[i], ref p1X, ref p1Y);
                            //    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[1].X, arrMinRect[1].Y, -fObjectAngleList[i], ref p2X, ref p2Y);
                            //    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[2].X, arrMinRect[2].Y, -fObjectAngleList[i], ref p3X, ref p3Y);
                            //    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[3].X, arrMinRect[3].Y, -fObjectAngleList[i], ref p4X, ref p4Y);

                            //    float fDiffX = Math.Max(Math.Abs(p1X - p4X), Math.Abs(p2X - p3X));
                            //    float fDiffY = Math.Max(Math.Abs(p3Y - p4Y), Math.Abs(p2Y - p1Y));
                            //    //float fWidth = (int)Math.Round((fDiffX * Math.Cos((fMinAngle + 180) * Math.PI / 180)) + (fDiffY * Math.Sin((fMinAngle + 180) * Math.PI / 180)));
                            //    //float fHeight = (int)Math.Round((fDiffX * Math.Sin((fMinAngle + 180) * Math.PI / 180)) + (fDiffY * Math.Cos((fMinAngle + 180) * Math.PI / 180)));
                            //    fObjectWidthList[i] = fDiffX;
                            //    fObjectHeightList[i] = fDiffY;

                            //    fObjectCenterXList[i] = pCenter.X;
                            //    fObjectCenterYList[i] = pCenter.Y;

                            //    fObjectAreaList2.RemoveAt(j);
                            //    fObjectAreaList[i] = fObjectAreaList[i] + fObjectAreaList[j];
                            //    fMinX[i] = Math.Min(Math.Min(arrMinRect[0].X, arrMinRect[1].X), Math.Min(arrMinRect[2].X, arrMinRect[3].X));
                            //    fMinY[i] = Math.Min(Math.Min(arrMinRect[0].Y, arrMinRect[1].Y), Math.Min(arrMinRect[2].Y, arrMinRect[3].Y));
                            //    fMaxX[i] = Math.Max(Math.Max(arrMinRect[0].X, arrMinRect[1].X), Math.Max(arrMinRect[2].X, arrMinRect[3].X));
                            //    fMaxY[i] = Math.Max(Math.Max(arrMinRect[0].Y, arrMinRect[1].Y), Math.Max(arrMinRect[2].Y, arrMinRect[3].Y));
                            //    fMinLimitX[i] = Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i]));
                            //    fMinLimitY[i] = Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i]));
                            //    fMaxLimitX[i] = Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i]));
                            //    fMaxLimitY[i] = Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i]));
                            //    //fMinX[i] = Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i]));
                            //    //fMinY[i] = Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i]));
                            //    //fMaxX[i] = Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i]));
                            //    //fMaxY[i] = Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i]));
                            //    //fMinLimitX[i] = Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i]));
                            //    //fMinLimitY[i] = Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i]));
                            //    //fMaxLimitX[i] = Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i]));
                            //    //fMaxLimitY[i] = Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i]));
                            //    fObjectHeightList.RemoveAt(j);
                            //    fObjectWidthList.RemoveAt(j);
                            //    fObjectCenterXList.RemoveAt(j);
                            //    fObjectCenterYList.RemoveAt(j);
                            //    fObjectAngleList.RemoveAt(j);
                            //    fObjectAreaList.RemoveAt(j);
                            //    fMaxLimitX.RemoveAt(j);
                            //    fMaxLimitY.RemoveAt(j);
                            //    fMinLimitX.RemoveAt(j);
                            //    fMinLimitY.RemoveAt(j);
                            //    fMaxX.RemoveAt(j);
                            //    fMaxY.RemoveAt(j);
                            //    fMinX.RemoveAt(j);
                            //    fMinY.RemoveAt(j);
                            //    if (j > 0)
                            //        j = -1;
                            //    if (i > 0)
                            //    {
                            //        i = 0;
                            //        //blnDecrement = true;
                            //    }
                            //    else
                            //        blnDecrement = true;
                            //}
                            //else if (((fMinY[j] - intTolerance) <= fMaxY[i])// first blob is above second blob, first blob is before second blob
                            //     && ((fMinY[j]) >= fMinY[i])
                            //     && ((fMaxX[i] + intTolerance) >= fMinX[j])
                            //    && ((fMaxX[i]) <= fMaxX[j]))
                            //{
                            //    //if (fObjectAreaList2[i] >= fObjectAreaList2[j])
                            //    //{
                            //    //    if (fObjectAngleList[i] > 0 && fObjectAngleList[j] > 0)
                            //    //    {
                            //    //        if (Math.Abs(fObjectAngleList[i] - fObjectAngleList[j]) > intAngleTolerance)
                            //    //            continue;
                            //    //    }
                            //    //    else if (fObjectAngleList[i] < 0 && fObjectAngleList[j] < 0)
                            //    //    {
                            //    //        if (Math.Abs(fObjectAngleList[i] - fObjectAngleList[j]) > intAngleTolerance)
                            //    //            continue;
                            //    //    }
                            //    //    else
                            //    //        continue;

                            //    //    fObjectAngleList[i] = fObjectAngleList[i];
                            //    //    fObjectAreaList2[i] = fObjectAreaList2[i];


                            //    //}
                            //    //else
                            //    //{

                            //    //    if (fObjectAngleList[i] > 0 && fObjectAngleList[j] > 0)
                            //    //    {
                            //    //        if (Math.Abs(fObjectAngleList[i] - fObjectAngleList[j]) > intAngleTolerance)
                            //    //            continue;
                            //    //    }
                            //    //    else if (fObjectAngleList[i] < 0 && fObjectAngleList[j] < 0)
                            //    //    {
                            //    //        if (Math.Abs(fObjectAngleList[i] - fObjectAngleList[j]) > intAngleTolerance)
                            //    //            continue;
                            //    //    }
                            //    //    else
                            //    //        continue;

                            //    //    fObjectAngleList[i] = fObjectAngleList[j];
                            //    //    fObjectAreaList2[i] = fObjectAreaList2[j];
                            //    //}
                            //    //if (Math.Abs(Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i])) - Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i])))
                            //    //    >= Math.Abs(Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i])) - Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i]))))
                            //    //{
                            //    //    fObjectHeightList[i] = Math.Abs(Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i])) - Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i])));
                            //    //    fObjectWidthList[i] = Math.Abs(Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i])) - Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i])));
                            //    //    //fObjectCenterXList[i] = (fMaxX[i] + fMinX[j]) / 2;
                            //    //    //fObjectCenterYList[i] = (fMaxY[i] + fMinY[j]) / 2;
                            //    //    fObjectAngleList[i] = 0;
                            //    //}
                            //    //else
                            //    //{
                            //    //    fObjectWidthList[i] = Math.Abs(Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i])) - Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i])));
                            //    //    fObjectHeightList[i] = Math.Abs(Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i])) - Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i])));
                            //    //    //fObjectCenterXList[i] = (fMaxY[i] + fMinY[j]) / 2;
                            //    //    //fObjectCenterYList[i] = (fMaxX[i] + fMinX[j]) / 2;
                            //    //    fObjectAngleList[i] = 90;
                            //    //}
                            //    //fObjectCenterXList[i] = (Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i])) + Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i]))) / 2;
                            //    //fObjectCenterYList[i] = (Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i])) + Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i]))) / 2;

                            //    PointF[] arrPoints = new PointF[8];

                            //    arrPoints[0] = arrRotatedPoints[i][0];
                            //    arrPoints[1] = arrRotatedPoints[i][1];
                            //    arrPoints[2] = arrRotatedPoints[i][2];
                            //    arrPoints[3] = arrRotatedPoints[i][3];
                            //    arrPoints[4] = arrRotatedPoints[j][0];
                            //    arrPoints[5] = arrRotatedPoints[j][1];
                            //    arrPoints[6] = arrRotatedPoints[j][2];
                            //    arrPoints[7] = arrRotatedPoints[j][3];

                            //    float fMinAngle = 0;
                            //    List<PointF> arrMinRect = new List<PointF>();
                            //    arrMinRect = MinimumBoundingBox.CalculateMinimumBoundingBox(arrPoints, ref fMinAngle);

                            //    arrRotatedPoints[i][0] = arrMinRect[3];
                            //    arrRotatedPoints[i][1] = arrMinRect[2];
                            //    arrRotatedPoints[i][2] = arrMinRect[0];
                            //    arrRotatedPoints[i][3] = arrMinRect[1];
                            //    arrRotatedPoints.RemoveAt(j);

                            //    if (fMinAngle < 0)
                            //        fObjectAngleList[i] = -(90 + fMinAngle);
                            //    else
                            //        fObjectAngleList[i] = 90 - fMinAngle;

                            //    Line onjLine1 = new Line();
                            //    Line onjLine2 = new Line();
                            //    onjLine1.CalculateStraightLine(arrMinRect[0], arrMinRect[2]);
                            //    onjLine2.CalculateStraightLine(arrMinRect[1], arrMinRect[3]);
                            //    PointF pCenter = Line.GetCrossPoint(onjLine1, onjLine2);
                            //    float p1X = 0, p1Y = 0;
                            //    float p2X = 0, p2Y = 0;
                            //    float p3X = 0, p3Y = 0;
                            //    float p4X = 0, p4Y = 0;
                            //    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[0].X, arrMinRect[0].Y, -fObjectAngleList[i], ref p1X, ref p1Y);
                            //    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[1].X, arrMinRect[1].Y, -fObjectAngleList[i], ref p2X, ref p2Y);
                            //    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[2].X, arrMinRect[2].Y, -fObjectAngleList[i], ref p3X, ref p3Y);
                            //    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[3].X, arrMinRect[3].Y, -fObjectAngleList[i], ref p4X, ref p4Y);

                            //    float fDiffX = Math.Max(Math.Abs(p1X - p4X), Math.Abs(p2X - p3X));
                            //    float fDiffY = Math.Max(Math.Abs(p3Y - p4Y), Math.Abs(p2Y - p1Y));
                            //    //float fWidth = (int)Math.Round((fDiffX * Math.Cos((fMinAngle + 180) * Math.PI / 180)) + (fDiffY * Math.Sin((fMinAngle + 180) * Math.PI / 180)));
                            //    //float fHeight = (int)Math.Round((fDiffX * Math.Sin((fMinAngle + 180) * Math.PI / 180)) + (fDiffY * Math.Cos((fMinAngle + 180) * Math.PI / 180)));
                            //    fObjectWidthList[i] = fDiffX;
                            //    fObjectHeightList[i] = fDiffY;

                            //    fObjectCenterXList[i] = pCenter.X;
                            //    fObjectCenterYList[i] = pCenter.Y;

                            //    fObjectAreaList2.RemoveAt(j);
                            //    fObjectAreaList[i] = fObjectAreaList[i] + fObjectAreaList[j];
                            //    fMinX[i] = Math.Min(Math.Min(arrMinRect[0].X, arrMinRect[1].X), Math.Min(arrMinRect[2].X, arrMinRect[3].X));
                            //    fMinY[i] = Math.Min(Math.Min(arrMinRect[0].Y, arrMinRect[1].Y), Math.Min(arrMinRect[2].Y, arrMinRect[3].Y));
                            //    fMaxX[i] = Math.Max(Math.Max(arrMinRect[0].X, arrMinRect[1].X), Math.Max(arrMinRect[2].X, arrMinRect[3].X));
                            //    fMaxY[i] = Math.Max(Math.Max(arrMinRect[0].Y, arrMinRect[1].Y), Math.Max(arrMinRect[2].Y, arrMinRect[3].Y));
                            //    fMinLimitX[i] = Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i]));
                            //    fMinLimitY[i] = Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i]));
                            //    fMaxLimitX[i] = Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i]));
                            //    fMaxLimitY[i] = Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i]));
                            //    //fMinX[i] = Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i]));
                            //    //fMinY[i] = Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i]));
                            //    //fMaxX[i] = Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i]));
                            //    //fMaxY[i] = Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i]));
                            //    //fMinLimitX[i] = Math.Min(Math.Max(fMinX[j], fMinLimitX[j]), Math.Max(fMinX[i], fMinLimitX[i]));
                            //    //fMinLimitY[i] = Math.Min(Math.Max(fMinY[j], fMinLimitY[j]), Math.Max(fMinY[i], fMinLimitY[i]));
                            //    //fMaxLimitX[i] = Math.Max(Math.Min(fMaxX[j], fMaxLimitX[j]), Math.Min(fMaxX[i], fMaxLimitX[i]));
                            //    //fMaxLimitY[i] = Math.Max(Math.Min(fMaxY[j], fMaxLimitY[j]), Math.Min(fMaxY[i], fMaxLimitY[i]));
                            //    fObjectHeightList.RemoveAt(j);
                            //    fObjectWidthList.RemoveAt(j);
                            //    fObjectCenterXList.RemoveAt(j);
                            //    fObjectCenterYList.RemoveAt(j);
                            //    fObjectAngleList.RemoveAt(j);
                            //    fObjectAreaList.RemoveAt(j);
                            //    fMaxLimitX.RemoveAt(j);
                            //    fMaxLimitY.RemoveAt(j);
                            //    fMinLimitX.RemoveAt(j);
                            //    fMinLimitY.RemoveAt(j);
                            //    fMaxX.RemoveAt(j);
                            //    fMaxY.RemoveAt(j);
                            //    fMinX.RemoveAt(j);
                            //    fMinY.RemoveAt(j);
                            //    if (j > 0)
                            //        j = -1;
                            //    if (i > 0)
                            //    {
                            //        i = 0;
                            //        //blnDecrement = true;
                            //    }
                            //    else
                            //        blnDecrement = true;
                            //}
                        }
                    }
                }
            }
            for (int i = 0; i < fObjectHeightList.Count; i++)
            {
                if (fObjectHeightList[i] < fObjectWidthList[i])
                {
                    fObjectWidth = fObjectHeightList[i];
                    fObjectHeight = fObjectWidthList[i];

                    fObjectAngle = fObjectAngleList[i];

                    if (fObjectAngle >= 10)//&& fAngle <= 80)
                        fObjectAngle = fObjectAngleList[i] - 90;
                    else
                        fObjectAngle = 90 + fObjectAngleList[i];

                    fObjectWidthList[i] = fObjectWidth;
                    fObjectHeightList[i] = fObjectHeight;
                    fObjectAngleList[i] = fObjectAngle;
                }
                else
                {
                    fObjectHeight = fObjectHeightList[i];
                    fObjectWidth = fObjectWidthList[i];

                    fObjectAngle = fObjectAngleList[i];

                    fObjectWidthList[i] = fObjectWidth;
                    fObjectHeightList[i] = fObjectHeight;
                    fObjectAngleList[i] = fObjectAngle;
                }

                bool blnFail = false;
                int intFailMask = 0;
                string strDefectName = "Bright";

                if ((m_intPkgFailMask & 0x100) > 0)
                {
                    if (m_arrWantDefectLength[(int)eWantDefect.Bright])
                    {
                        if (m_intBrightDefectDimensionFailCondition == 0)
                        {
                            if (fObjectWidthList[i] >= GetDefect("Bright", 0))
                            {
                                m_strErrorMessage += "* Package Bright Field Width Fail. Set = " + (GetDefect("Bright", 0) / m_fMMToPixelXValue).ToString("f4") + " mm,   Result = " + (fObjectWidthList[i] / m_fMMToPixelXValue).ToString("f4") + " mm";
                                blnFail = true;
                                intFailMask |= 0x01;
                                strDefectName = "Bright";
                            }

                            if (fObjectHeightList[i] >= GetDefect("Bright", 1))
                            {
                                m_strErrorMessage += "* Package Bright Field Length Fail. Set = " + (GetDefect("Bright", 1) / m_fMMToPixelYValue).ToString("f4") + " mm,   Result = " + (fObjectHeightList[i] / m_fMMToPixelYValue).ToString("f4") + " mm";
                                blnFail = true;
                                intFailMask |= 0x02;
                                strDefectName = "Bright";
                            }
                        }
                        else
                        {
                            if ((fObjectWidthList[i] >= GetDefect("Bright", 0)) && (fObjectHeightList[i] >= GetDefect("Bright", 1)))
                            {
                                m_strErrorMessage += "* Package Bright Field Width Fail. Set = " + (GetDefect("Bright", 0) / m_fMMToPixelXValue).ToString("f4") + " mm,   Result = " + (fObjectWidthList[i] / m_fMMToPixelXValue).ToString("f4") + " mm";
                                intFailMask |= 0x01;
                                m_strErrorMessage += "* Package Bright Field Length Fail. Set = " + (GetDefect("Bright", 1) / m_fMMToPixelYValue).ToString("f4") + " mm,   Result = " + (fObjectHeightList[i] / m_fMMToPixelYValue).ToString("f4") + " mm";
                                blnFail = true;
                                intFailMask |= 0x02;
                                strDefectName = "Bright";
                            }
                        }
                    }

                    if (m_arrWantDefectArea[(int)eWantDefect.Bright])
                    {
                        if (fObjectAreaList[i] >= GetAreaDefect("Bright"))
                        {
                            m_strErrorMessage += "* Package Bright Field Area Fail. Set = " + (GetAreaDefect("Scratch") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (fObjectAreaList[i] / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                            blnFail = true;
                            intFailMask |= 0x04;
                            strDefectName = "Bright";
                        }
                    }

                }

                if (blnFail)
                {
                    Defect objDefect = new Defect();
                    objDefect.ref_fDimX = fObjectWidthList[i];
                    objDefect.ref_fDimY = fObjectHeightList[i];
                    objDefect.ref_intLengthMode = intLengthMode;
                    objDefect.ref_fArea = fObjectAreaList[i];
                    objDefect.ref_fCenterX = objROI.ref_ROITotalX + fObjectCenterXList[i];
                    objDefect.ref_fCenterY = objROI.ref_ROITotalY + fObjectCenterYList[i];
                    objDefect.ref_intBlobNo = i;
                    objDefect.ref_fAngle = fObjectAngleList[i];
                    objDefect.ref_intFailMask = intFailMask;
                    objDefect.ref_strName = strDefectName;
                    objDefect.ref_intFailedImage = intSelectedImageIndex + 1;
                    m_arrDefectList.Add(objDefect);

                    if (!blnOverAllFail)
                        blnOverAllFail = true;
                }
                else
                {
                    Defect objDefect = new Defect();
                    objDefect.ref_fDimX = fObjectWidthList[i];
                    objDefect.ref_fDimY = fObjectHeightList[i];
                    objDefect.ref_intLengthMode = intLengthMode;
                    objDefect.ref_fArea = fObjectAreaList[i];
                    objDefect.ref_fCenterX = objROI.ref_ROITotalX + fObjectCenterXList[i];
                    objDefect.ref_fCenterY = objROI.ref_ROITotalY + fObjectCenterYList[i];
                    objDefect.ref_intBlobNo = i;
                    objDefect.ref_fAngle = fObjectAngleList[i];
                    objDefect.ref_intFailMask = 0;
                    objDefect.ref_strName = strDefectName;
                    objDefect.ref_intFailedImage = intSelectedImageIndex + 1;
                    m_arrDefectList.Add(objDefect);
                }
            }
            if (m_arrWantDefectArea[(int)eWantDefect.Bright])
            {
                if (intObjectTotalArea >= GetTotalAreaDefect("Bright"))
                {
                    m_strErrorMessage += "* Package Bright Field Total Area Fail. Set = " + (GetTotalAreaDefect("Bright") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectTotalArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                    m_blnPkgViewFailTotalArea = true;

                    Defect objDefect = new Defect();
                    objDefect.ref_fDimX = -1;
                    objDefect.ref_fDimY = -1;
                    objDefect.ref_intLengthMode = 0;
                    objDefect.ref_fArea = intObjectTotalArea;
                    objDefect.ref_fCenterX = objROI.ref_ROITotalX + m_objPackageEBlobs.ref_arrLimitCenterX[0];
                    objDefect.ref_fCenterY = objROI.ref_ROITotalY + m_objPackageEBlobs.ref_arrLimitCenterY[0];
                    objDefect.ref_intFailMask |= 0x04;
                    objDefect.ref_fAngle = fObjectAngle;
                    objDefect.ref_strName = "Total Bright";
                    objDefect.ref_intFailedImage = intSelectedImageIndex + 1;
                    m_arrDefectList.Add(objDefect);

                    if (!blnOverAllFail)
                        blnOverAllFail = true;
                }
            }

            if (blnOverAllFail)
            {
                m_intPkgFailResultMask |= 0x100;
                return false;
            }
            else
                return true;
        }

        private void PolishRectImage(ImageDrawing objImage, ROI objMaskROI, List<ROI> arrROIs)
        {
            int intPixel = (m_intMarkViewLowThreshold + m_intMarkViewHighThreshold) / 2;
            Shape.FillRectangle(objImage, objMaskROI, intPixel);

            arrROIs[0].AttachImage(objImage);
            arrROIs[1].AttachImage(arrROIs[0]);
            for (int i = 2; i < arrROIs.Count; i++)
            {
                Shape.FillRectangle(arrROIs[1], arrROIs[i], intPixel);
            }
        }

        public bool CheckUnitSitProper(float ObjectWidth, float ObjectHeight)
        {
            // Should Validate gauge score? (but where is the score setting???)

            float fUnitWidth = ObjectWidth * m_fMMPerPixelX * m_fMMToUnitValue;
            float fUnitHeight = ObjectHeight * m_fMMPerPixelY * m_fMMToUnitValue;
            m_strErrorMessage = "";
            bool blnResult = true;
            if (fUnitWidth < m_fSittingWidthMin)
            {
                blnResult = false;
                m_strErrorMessage += "*Sitting Width Fail. Set min=" + m_fSittingWidthMin.ToString() +
                                      " Result= " + fUnitWidth.ToString("F4");
            }

            if (fUnitWidth > m_fSittingWidthMax)
            {
                blnResult = false;
                m_strErrorMessage += "*Sitting Width Fail. Set max= " + m_fSittingWidthMax.ToString() +
                                      " Result= " + fUnitWidth.ToString("F4");
            }

            if (fUnitHeight < m_fSittingHeightMin)
            {
                blnResult = false;
                m_strErrorMessage += "*Sitting Height Fail. Set min=" + m_fSittingHeightMin.ToString() +
                                      " Result= " + fUnitHeight.ToString("F4");
            }

            if (fUnitHeight > m_fSittingHeightMax)
            {
                blnResult = false;
                m_strErrorMessage += "*Sitting Height Fail. Set max= " + m_fSittingHeightMax.ToString() +
                                      " Result= " + fUnitHeight.ToString("F4");
            }
            return blnResult;
        }
        private void FillChipLineLimitToCorner_Area(ImageDrawing objImage, int intChippedOffToleranceTop, int intChippedOffToleranceRight, int intChippedOffToleranceBottom, int intChippedOffToleranceLeft, int intChipLineLimitPixelValue)
        {
            if (objImage.ref_intImageHeight == 0 || objImage.ref_intImageWidth == 0)
                return;

            int intStartX1 = 0;
            int intStartY1 = 0;
            int intEndX1 = objImage.ref_intImageWidth - 1;
            int intEndY1 = objImage.ref_intImageHeight - 1;

            //int intStartX2 = intChippedOffToleranceLeft;
            //int intStartY2 = intChippedOffToleranceTop;
            //int intEndX2 = objImage.ref_intImageWidth - intChippedOffToleranceRight - 1;
            //int intEndY2 = objImage.ref_intImageHeight - intChippedOffToleranceBottom - 1;

            int intStartX2 = 0;
            int intStartY2 = 0;
            int intEndX2 = 0;
            int intEndY2 = 0;

            if (intChipLineLimitPixelValue == 0)
            {
                //intStartX2 = intChippedOffToleranceLeft - m_intStartPixelExtendFromLeft_Chip;
                //intStartY2 = intChippedOffToleranceTop - m_intStartPixelExtendFromEdge_Chip;
                //intEndX2 = objImage.ref_intImageWidth - intChippedOffToleranceRight + m_intStartPixelExtendFromRight_Chip - 1;
                //intEndY2 = objImage.ref_intImageHeight - intChippedOffToleranceBottom + m_intStartPixelExtendFromBottom_Chip - 1;

                intStartX2 = intChippedOffToleranceLeft;
                intStartY2 = intChippedOffToleranceTop;
                intEndX2 = objImage.ref_intImageWidth - intChippedOffToleranceRight - 1;
                intEndY2 = objImage.ref_intImageHeight - intChippedOffToleranceBottom - 1;
            }
            else
            {
                //intStartX2 = intChippedOffToleranceLeft - m_intStartPixelExtendFromLeft_Chip_Dark;
                //intStartY2 = intChippedOffToleranceTop - m_intStartPixelExtendFromEdge_Chip_Dark;
                //intEndX2 = objImage.ref_intImageWidth - intChippedOffToleranceRight + m_intStartPixelExtendFromRight_Chip_Dark - 1;
                //intEndY2 = objImage.ref_intImageHeight - intChippedOffToleranceBottom + m_intStartPixelExtendFromBottom_Chip_Dark - 1;

                intStartX2 = intChippedOffToleranceLeft;
                intStartY2 = intChippedOffToleranceTop;
                intEndX2 = objImage.ref_intImageWidth - intChippedOffToleranceRight - 1;
                intEndY2 = objImage.ref_intImageHeight - intChippedOffToleranceBottom - 1;
            }

            Line objLine1 = new Line();
            Line objLine2 = new Line();
            Line objLine3 = new Line();
            Line objLine4 = new Line();
            objLine1.CalculateStraightLine(new PointF(intStartX1, intStartY1), new PointF(intStartX2, intStartY2));
            objLine2.CalculateStraightLine(new PointF(intEndX1, intStartY1), new PointF(intEndX2, intStartY2));
            objLine3.CalculateStraightLine(new PointF(intStartX1, intEndY1), new PointF(intStartX2, intEndY2));
            objLine4.CalculateStraightLine(new PointF(intEndX1, intEndY1), new PointF(intEndX2, intEndY2));
            int x, y;
            EBW8 darkPixel = new EBW8((byte)intChipLineLimitPixelValue);
            // -------- separate corner with dark line -------------------------------------------
            for (x = intStartX1; x <= intStartX2; x++)
            {
                y = (int)Math.Round(objLine1.GetPointY(x), 0, MidpointRounding.AwayFromZero);

                if (!(y >= 0 && y < objImage.ref_objMainImage.Height &&
                    x >= 0 && x < objImage.ref_objMainImage.Width))
                {
                    continue;
                }

                if (y < objImage.ref_objMainImage.Height)
                    objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
            }
            for (x = intEndX2; x <= intEndX1; x++)
            {
                y = (int)Math.Round(objLine2.GetPointY(x), 0, MidpointRounding.AwayFromZero);

                if (!(y >= 0 && y < objImage.ref_objMainImage.Height &&
                    x >= 0 && x < objImage.ref_objMainImage.Width))
                {
                    continue;
                }

                if (y < objImage.ref_objMainImage.Height)
                    objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
            }
            for (x = intStartX1; x <= intStartX2; x++)
            {
                y = (int)Math.Round(objLine3.GetPointY(x), 0, MidpointRounding.AwayFromZero);

                if (!(y >= 0 && y < objImage.ref_objMainImage.Height &&
                    x >= 0 && x < objImage.ref_objMainImage.Width))
                {
                    continue;
                }

                if (y < objImage.ref_objMainImage.Height)
                    objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
            }
            for (x = intEndX2; x <= intEndX1; x++)
            {
                y = (int)Math.Round(objLine4.GetPointY(x), 0, MidpointRounding.AwayFromZero);

                if (!(y >= 0 && y < objImage.ref_objMainImage.Height &&
                    x >= 0 && x < objImage.ref_objMainImage.Width))
                {
                    continue;
                }

                if (y < objImage.ref_objMainImage.Height)
                    objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
            }

            // ------------------- Set limit with dark pixel --------------------------------------------------
            for (x = intStartX2; x < intEndX2; x++)
            {
                objImage.ref_objMainImage.SetPixel(darkPixel, x, intStartY2);
            }
            int intEnd = intEndY2;
            for (x = intStartX2; x < intEndX2; x++)
            {
                objImage.ref_objMainImage.SetPixel(darkPixel, x, intEnd);
            }
            for (y = intStartY2; y < intEndY2; y++)
            {
                objImage.ref_objMainImage.SetPixel(darkPixel, intStartX2, y);
            }
            intEnd = intEndX2;
            for (y = intStartY2; y < intEndY2; y++)
            {
                objImage.ref_objMainImage.SetPixel(darkPixel, intEnd, y);
            }

            //// 
            //for (x = 0; x < 3; x++)
            //{
            //    for (y = 0; y < 3; y++)
            //        objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
            //}
            //for (x = 0; x < 3; x++)
            //{
            //    for (y = intEndY1 - 2; y <= intEndY1; y++)
            //        objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
            //}
            //for (x = intEndX1 - 2; x <= intEndX1; x++)
            //{
            //    for (y = 0; y < 3; y++)
            //        objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
            //}
            //for (x = intEndX1 - 2; x <= intEndX1; x++)
            //{
            //    for (y = intEndY1 - 2; y <= intEndY1; y++)
            //        objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
            //}

        }
        private void FillChipLineLimitToCorner_Area(ImageDrawing objImage, int intChippedOffToleranceTop, int intChippedOffToleranceRight, int intChippedOffToleranceBottom, int intChippedOffToleranceLeft, int intChipLineLimitPixelValue,
            List<PointF> arrChippedROIPoints, ImageDrawing objWhiteImage, ImageDrawing objBlackImage, float fAngle)
        {
            if (objImage.ref_intImageHeight == 0 || objImage.ref_intImageWidth == 0)
                return;

            int intExtendTop = 0;
            int intExtendRight = 0;
            int intExtendBottom = 0;
            int intExtendLeft = 0;

            if (intChipLineLimitPixelValue == 0)
            {
                intExtendTop = m_intStartPixelExtendFromEdge_Chip;
                intExtendRight = m_intStartPixelExtendFromRight_Chip;
                intExtendBottom = m_intStartPixelExtendFromBottom_Chip;
                intExtendLeft = m_intStartPixelExtendFromLeft_Chip;
            }
            else
            {
                intExtendTop = m_intStartPixelExtendFromEdge_Chip_Dark;
                intExtendRight = m_intStartPixelExtendFromRight_Chip_Dark;
                intExtendBottom = m_intStartPixelExtendFromBottom_Chip_Dark;
                intExtendLeft = m_intStartPixelExtendFromLeft_Chip_Dark;
            }

            //Line objLine1 = new Line();
            //Line objLine2 = new Line();
            //Line objLine3 = new Line();
            //Line objLine4 = new Line();
            ////objLine1.CalculateStraightLine(new PointF(intStartX1, intStartY1), new PointF(intStartX2, intStartY2));
            ////objLine2.CalculateStraightLine(new PointF(intEndX1, intStartY1), new PointF(intEndX2, intStartY2));
            ////objLine3.CalculateStraightLine(new PointF(intStartX1, intEndY1), new PointF(intStartX2, intEndY2));
            ////objLine4.CalculateStraightLine(new PointF(intEndX1, intEndY1), new PointF(intEndX2, intEndY2));
            //objLine1.CalculateStraightLine(new PointF(arrChippedROIPoints[0].X, arrChippedROIPoints[0].Y), 
            //    new PointF(arrChippedROIPoints[0].X + intChippedOffToleranceLeft + intExtendLeft, arrChippedROIPoints[0].Y + intChippedOffToleranceTop + intExtendTop));

            //objLine2.CalculateStraightLine(new PointF(arrChippedROIPoints[1].X, arrChippedROIPoints[1].Y),
            //    new PointF(arrChippedROIPoints[1].X - intChippedOffToleranceRight - intExtendRight, arrChippedROIPoints[1].Y + intChippedOffToleranceTop + intExtendTop));

            //objLine3.CalculateStraightLine(new PointF(arrChippedROIPoints[2].X, arrChippedROIPoints[2].Y),
            //    new PointF(arrChippedROIPoints[2].X + intChippedOffToleranceLeft + intExtendLeft, arrChippedROIPoints[2].Y - intChippedOffToleranceBottom - intExtendBottom));

            //objLine4.CalculateStraightLine(new PointF(arrChippedROIPoints[3].X, arrChippedROIPoints[3].Y),
            //    new PointF(arrChippedROIPoints[3].X - intChippedOffToleranceRight - intExtendRight, arrChippedROIPoints[3].Y - intChippedOffToleranceBottom - intExtendBottom));
            //int x, y;
            //EBW8 darkPixel = new EBW8((byte)intChipLineLimitPixelValue);
            //// -------- separate corner with dark line -------------------------------------------
            //for (x = (int)Math.Round(arrChippedROIPoints[0].X); x <= (int)Math.Round(arrChippedROIPoints[0].X + intChippedOffToleranceLeft + intExtendLeft); x++)
            //{
            //    y = (int)Math.Round(objLine1.GetPointY(x), 0, MidpointRounding.AwayFromZero);

            //    if (!(y >= 0 && y < objImage.ref_objMainImage.Height &&
            //        x >= 0 && x < objImage.ref_objMainImage.Width))
            //    {
            //        continue;
            //    }

            //    if (y < objImage.ref_objMainImage.Height)
            //        objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
            //}
            //for (x = (int)Math.Round(arrChippedROIPoints[1].X - intChippedOffToleranceRight - intExtendRight); x <= (int)Math.Round(arrChippedROIPoints[1].X); x++)
            //{
            //    y = (int)Math.Round(objLine2.GetPointY(x), 0, MidpointRounding.AwayFromZero);

            //    if (!(y >= 0 && y < objImage.ref_objMainImage.Height &&
            //        x >= 0 && x < objImage.ref_objMainImage.Width))
            //    {
            //        continue;
            //    }

            //    if (y < objImage.ref_objMainImage.Height)
            //        objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
            //}
            //for (x = (int)Math.Round(arrChippedROIPoints[2].X); x <= (int)Math.Round(arrChippedROIPoints[2].X + intChippedOffToleranceLeft + intExtendLeft); x++)
            //{
            //    y = (int)Math.Round(objLine3.GetPointY(x), 0, MidpointRounding.AwayFromZero);

            //    if (!(y >= 0 && y < objImage.ref_objMainImage.Height &&
            //        x >= 0 && x < objImage.ref_objMainImage.Width))
            //    {
            //        continue;
            //    }

            //    if (y < objImage.ref_objMainImage.Height)
            //        objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
            //}
            //for (x = (int)Math.Round(arrChippedROIPoints[3].X - intChippedOffToleranceRight - intExtendRight); x <= (int)Math.Round(arrChippedROIPoints[3].X); x++)
            //{
            //    y = (int)Math.Round(objLine4.GetPointY(x), 0, MidpointRounding.AwayFromZero);

            //    if (!(y >= 0 && y < objImage.ref_objMainImage.Height &&
            //        x >= 0 && x < objImage.ref_objMainImage.Width))
            //    {
            //        continue;
            //    }

            //    if (y < objImage.ref_objMainImage.Height)
            //        objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
            //}

            //2020-11-18 ZJYEOH : Time consuming for large image
            //// ------------------- Set limit with dark pixel --------------------------------------------------
            //objLine1.CalculateStraightLine(new PointF(arrChippedROIPoints[0].X + intChippedOffToleranceLeft + intExtendLeft, arrChippedROIPoints[0].Y + intChippedOffToleranceTop + intExtendTop),
            //    new PointF(arrChippedROIPoints[1].X - intChippedOffToleranceRight - intExtendRight, arrChippedROIPoints[1].Y + intChippedOffToleranceTop + intExtendTop));

            //objLine2.CalculateStraightLine(new PointF(arrChippedROIPoints[1].X - intChippedOffToleranceRight - intExtendRight, arrChippedROIPoints[1].Y + intChippedOffToleranceTop + intExtendTop),
            //    new PointF(arrChippedROIPoints[3].X - intChippedOffToleranceRight - intExtendRight, arrChippedROIPoints[3].Y - intChippedOffToleranceBottom - intExtendBottom));

            //objLine3.CalculateStraightLine(new PointF(arrChippedROIPoints[0].X + intChippedOffToleranceLeft + intExtendLeft, arrChippedROIPoints[0].Y + intChippedOffToleranceTop + intExtendTop),
            //    new PointF(arrChippedROIPoints[2].X + intChippedOffToleranceLeft + intExtendLeft, arrChippedROIPoints[2].Y - intChippedOffToleranceBottom - intExtendBottom));

            //objLine4.CalculateStraightLine(new PointF(arrChippedROIPoints[2].X + intChippedOffToleranceLeft + intExtendLeft, arrChippedROIPoints[2].Y - intChippedOffToleranceBottom - intExtendBottom),
            //    new PointF(arrChippedROIPoints[3].X - intChippedOffToleranceRight - intExtendRight, arrChippedROIPoints[3].Y - intChippedOffToleranceBottom - intExtendBottom));

            //// -------- separate corner with dark line -------------------------------------------
            //for (x = (int)Math.Round(arrChippedROIPoints[0].X + intChippedOffToleranceLeft + intExtendLeft); x <= (int)Math.Round(arrChippedROIPoints[1].X - intChippedOffToleranceRight - intExtendRight); x++)
            //{
            //    y = (int)Math.Round(objLine1.GetPointY(x), 0, MidpointRounding.AwayFromZero);

            //    if (!(y >= 0 && y < objImage.ref_objMainImage.Height &&
            //        x >= 0 && x < objImage.ref_objMainImage.Width))
            //    {
            //        continue;
            //    }

            //    if (y < objImage.ref_objMainImage.Height)
            //        objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
            //}
            //for (y = (int)Math.Round(arrChippedROIPoints[1].Y + intChippedOffToleranceTop + intExtendTop); y <= (int)Math.Round(arrChippedROIPoints[3].Y - intChippedOffToleranceBottom - intExtendBottom); y++)
            //{
            //    x = (int)Math.Round(objLine2.GetPointX(y), 0, MidpointRounding.AwayFromZero);

            //    if (!(x >= 0 && x < objImage.ref_objMainImage.Width &&
            //        y >= 0 && y < objImage.ref_objMainImage.Height))
            //    {
            //        continue;
            //    }

            //    if (x < objImage.ref_objMainImage.Width)
            //        objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
            //}
            //for (y = (int)Math.Round(arrChippedROIPoints[0].Y + intChippedOffToleranceTop + intExtendTop); y <= (int)Math.Round(arrChippedROIPoints[2].Y - intChippedOffToleranceBottom - intExtendBottom); y++)
            //{
            //    x = (int)Math.Round(objLine3.GetPointX(y), 0, MidpointRounding.AwayFromZero);

            //    if (!(x >= 0 && x < objImage.ref_objMainImage.Width &&
            //        y >= 0 && y < objImage.ref_objMainImage.Height))
            //    {
            //        continue;
            //    }

            //    if (x < objImage.ref_objMainImage.Width)
            //        objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
            //}
            //for (x = (int)Math.Round(arrChippedROIPoints[2].X + intChippedOffToleranceLeft + intExtendLeft); x <= (int)Math.Round(arrChippedROIPoints[3].X - intChippedOffToleranceRight - intExtendRight); x++)
            //{
            //    y = (int)Math.Round(objLine4.GetPointY(x), 0, MidpointRounding.AwayFromZero);

            //    if (!(y >= 0 && y < objImage.ref_objMainImage.Height &&
            //        x >= 0 && x < objImage.ref_objMainImage.Width))
            //    {
            //        continue;
            //    }

            //    if (y < objImage.ref_objMainImage.Height)
            //        objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
            //}

            //HiPerfTimer t = new HiPerfTimer();
            //t.Start();
            List<PointF> arrPoints = new List<PointF>();
            PointF pCenter = new PointF(objImage.ref_intImageWidth / 2, objImage.ref_intImageHeight / 2);// Line.GetCrossPoint(objLine1, objLine2);

            PointF pTemp = new PointF();
            Math2.GetNewXYAfterRotate_360deg((pCenter.X),
                                             (pCenter.Y),
                                             arrChippedROIPoints[0],
                                             -(fAngle),
                                             ref pTemp);
            arrPoints.Add(pTemp);

            Math2.GetNewXYAfterRotate_360deg((pCenter.X),
                                             (pCenter.Y),
                                             arrChippedROIPoints[1],
                                             -(fAngle),
                                             ref pTemp);
            arrPoints.Add(pTemp);

            Math2.GetNewXYAfterRotate_360deg((pCenter.X),
                                             (pCenter.Y),
                                             arrChippedROIPoints[2],
                                             -(fAngle),
                                             ref pTemp);
            arrPoints.Add(pTemp);

            Math2.GetNewXYAfterRotate_360deg((pCenter.X),
                                             (pCenter.Y),
                                             arrChippedROIPoints[3],
                                             -(fAngle),
                                             ref pTemp);
            arrPoints.Add(pTemp);


            ImageDrawing objImage1 = new ImageDrawing(true, objBlackImage.ref_intImageWidth, objBlackImage.ref_intImageHeight);
            ImageDrawing objImage2 = new ImageDrawing(true, objBlackImage.ref_intImageWidth, objBlackImage.ref_intImageHeight);
            objBlackImage.CopyTo(ref objImage1);
            objBlackImage.CopyTo(ref objImage2);
            ROI objROI1 = new ROI();
            ROI objROI2 = new ROI();
            objROI1.LoadROISetting((int)Math.Round(arrPoints[0].X) + intChippedOffToleranceLeft, (int)Math.Round(arrPoints[0].Y) + intChippedOffToleranceTop,
                (int)Math.Round(arrPoints[1].X - arrPoints[0].X - intChippedOffToleranceLeft - intChippedOffToleranceRight),
                (int)Math.Round(arrPoints[3].Y - arrPoints[0].Y - intChippedOffToleranceTop - intChippedOffToleranceBottom));
            objROI1.AttachImage(objWhiteImage);
            objROI1.CopyTo_ROIToROISamePosition(ref objImage1);
            //objImage1.SaveImage("D:\\objImage1.bmp");
            objROI1.LoadROISetting((int)Math.Round(arrPoints[0].X) + intChippedOffToleranceLeft + 1, (int)Math.Round(arrPoints[0].Y) + intChippedOffToleranceTop + 1,
                            (int)Math.Round(arrPoints[1].X - arrPoints[0].X - intChippedOffToleranceLeft - intChippedOffToleranceRight) - 2,
                            (int)Math.Round(arrPoints[3].Y - arrPoints[0].Y - intChippedOffToleranceTop - intChippedOffToleranceBottom) - 2);
            objROI1.AttachImage(objBlackImage);
            objROI1.CopyTo_ROIToROISamePosition(ref objImage1);
            //objImage1.SaveImage("D:\\objImage1.bmp");
            objROI1.LoadROISetting((int)Math.Round(0f), (int)Math.Round(0f),(int)Math.Round(objImage.ref_intImageWidth + 0f), (int)Math.Round(objImage.ref_intImageHeight + 0f));
            objROI1.AttachImage(objImage1);

            //int intStartX1 = 0;
            //int intStartY1 = 0;
            //int intEndX1 = objImage.ref_intImageWidth - 1;
            //int intEndY1 = objImage.ref_intImageHeight - 1;

            int intStartX1 = (int)Math.Round(arrPoints[0].X);
            int intStartY1 = (int)Math.Round(arrPoints[0].Y);
            int intEndX1 = (int)Math.Round(arrPoints[3].X);
            int intEndY1 = (int)Math.Round(arrPoints[3].Y);

            //int intStartX2 = intChippedOffToleranceLeft;
            //int intStartY2 = intChippedOffToleranceTop;
            //int intEndX2 = objImage.ref_intImageWidth - intChippedOffToleranceRight - 1;
            //int intEndY2 = objImage.ref_intImageHeight - intChippedOffToleranceBottom - 1;

            //int intStartX2 = 0;
            //int intStartY2 = 0;
            //int intEndX2 = 0;
            //int intEndY2 = 0;

            int intStartX2 = (int)Math.Round(arrPoints[0].X) + intChippedOffToleranceLeft;
            int intStartY2 = (int)Math.Round(arrPoints[0].Y) + intChippedOffToleranceTop;
            int intEndX2 = intStartX2 + (int)Math.Round(arrPoints[1].X - arrPoints[0].X - intChippedOffToleranceLeft - intChippedOffToleranceRight);
            int intEndY2 = intStartY2 + (int)Math.Round(arrPoints[3].Y - arrPoints[0].Y - intChippedOffToleranceTop - intChippedOffToleranceBottom);

            //if (intChipLineLimitPixelValue == 0)
            //{
            //    //intStartX2 = intChippedOffToleranceLeft - m_intStartPixelExtendFromLeft_Chip;
            //    //intStartY2 = intChippedOffToleranceTop - m_intStartPixelExtendFromEdge_Chip;
            //    //intEndX2 = objImage.ref_intImageWidth - intChippedOffToleranceRight + m_intStartPixelExtendFromRight_Chip - 1;
            //    //intEndY2 = objImage.ref_intImageHeight - intChippedOffToleranceBottom + m_intStartPixelExtendFromBottom_Chip - 1;

            //    intStartX2 = intChippedOffToleranceLeft;
            //    intStartY2 = intChippedOffToleranceTop;
            //    intEndX2 = objImage.ref_intImageWidth - intChippedOffToleranceRight - 1;
            //    intEndY2 = objImage.ref_intImageHeight - intChippedOffToleranceBottom - 1;
            //}
            //else
            //{
            //    //intStartX2 = intChippedOffToleranceLeft - m_intStartPixelExtendFromLeft_Chip_Dark;
            //    //intStartY2 = intChippedOffToleranceTop - m_intStartPixelExtendFromEdge_Chip_Dark;
            //    //intEndX2 = objImage.ref_intImageWidth - intChippedOffToleranceRight + m_intStartPixelExtendFromRight_Chip_Dark - 1;
            //    //intEndY2 = objImage.ref_intImageHeight - intChippedOffToleranceBottom + m_intStartPixelExtendFromBottom_Chip_Dark - 1;

            //    intStartX2 = intChippedOffToleranceLeft;
            //    intStartY2 = intChippedOffToleranceTop;
            //    intEndX2 = objImage.ref_intImageWidth - intChippedOffToleranceRight - 1;
            //    intEndY2 = objImage.ref_intImageHeight - intChippedOffToleranceBottom - 1;
            //}

            Line objLine1 = new Line();
            Line objLine2 = new Line();
            Line objLine3 = new Line();
            Line objLine4 = new Line();
            objLine1.CalculateStraightLine(new PointF(intStartX1, intStartY1), new PointF(intStartX2, intStartY2));
            objLine2.CalculateStraightLine(new PointF(intEndX1, intStartY1), new PointF(intEndX2, intStartY2));
            objLine3.CalculateStraightLine(new PointF(intStartX1, intEndY1), new PointF(intStartX2, intEndY2));
            objLine4.CalculateStraightLine(new PointF(intEndX1, intEndY1), new PointF(intEndX2, intEndY2));
            int x, y;
            EBW8 darkPixel = new EBW8((byte)255);
            // -------- separate corner with dark line -------------------------------------------
            //for (x = (int)Math.Round(arrPoints[0].X); x <= (int)Math.Round(arrPoints[0].X) + intStartX2; x++)
            //{
            //    y = (int)Math.Round(objLine1.GetPointY(x), 0, MidpointRounding.AwayFromZero);

            //    if (!(y >= 0 && y < objImage.ref_objMainImage.Height &&
            //        x >= 0 && x < objImage.ref_objMainImage.Width))
            //    {
            //        continue;
            //    }

            //    if (y < objImage.ref_objMainImage.Height)
            //        objImage1.ref_objMainImage.SetPixel(darkPixel, x, y);
            //}
            //for (x = (int)Math.Round(arrPoints[1].X) - (objImage.ref_intImageWidth - intEndX2); x <= (int)Math.Round(arrPoints[1].X); x++)
            //{
            //    y = (int)Math.Round(objLine2.GetPointY(x), 0, MidpointRounding.AwayFromZero);

            //    if (!(y >= 0 && y < objImage.ref_objMainImage.Height &&
            //        x >= 0 && x < objImage.ref_objMainImage.Width))
            //    {
            //        continue;
            //    }

            //    if (y < objImage.ref_objMainImage.Height)
            //        objImage1.ref_objMainImage.SetPixel(darkPixel, x, y);
            //}
            //for (x = (int)Math.Round(arrPoints[2].X); x <= (int)Math.Round(arrPoints[2].X) + intStartX2; x++)
            //{
            //    y = (int)Math.Round(objLine3.GetPointY(x), 0, MidpointRounding.AwayFromZero);

            //    if (!(y >= 0 && y < objImage.ref_objMainImage.Height &&
            //        x >= 0 && x < objImage.ref_objMainImage.Width))
            //    {
            //        continue;
            //    }

            //    if (y < objImage.ref_objMainImage.Height)
            //        objImage1.ref_objMainImage.SetPixel(darkPixel, x, y);
            //}
            //for (x = (int)Math.Round(arrPoints[3].X) - (objImage.ref_intImageWidth - intEndX2); x <= (int)Math.Round(arrPoints[3].X); x++)
            //{
            //    y = (int)Math.Round(objLine4.GetPointY(x), 0, MidpointRounding.AwayFromZero);

            //    if (!(y >= 0 && y < objImage.ref_objMainImage.Height &&
            //        x >= 0 && x < objImage.ref_objMainImage.Width))
            //    {
            //        continue;
            //    }

            //    if (y < objImage.ref_objMainImage.Height)
            //        objImage1.ref_objMainImage.SetPixel(darkPixel, x, y);
            //}
            for (x = intStartX1; x <= intStartX2; x++)
            {
                y = (int)Math.Round(objLine1.GetPointY(x), 0, MidpointRounding.AwayFromZero);

                if (!(y >= 0 && y < objImage.ref_objMainImage.Height &&
                    x >= 0 && x < objImage.ref_objMainImage.Width))
                {
                    continue;
                }

                if (y < objImage.ref_objMainImage.Height)
                    objImage1.ref_objMainImage.SetPixel(darkPixel, x, y);
            }
            for (x = intEndX2; x <= intEndX1; x++)
            {
                y = (int)Math.Round(objLine2.GetPointY(x), 0, MidpointRounding.AwayFromZero);

                if (!(y >= 0 && y < objImage.ref_objMainImage.Height &&
                    x >= 0 && x < objImage.ref_objMainImage.Width))
                {
                    continue;
                }

                if (y < objImage.ref_objMainImage.Height)
                    objImage1.ref_objMainImage.SetPixel(darkPixel, x, y);
            }
            for (x = intStartX1; x <= intStartX2; x++)
            {
                y = (int)Math.Round(objLine3.GetPointY(x), 0, MidpointRounding.AwayFromZero);

                if (!(y >= 0 && y < objImage.ref_objMainImage.Height &&
                    x >= 0 && x < objImage.ref_objMainImage.Width))
                {
                    continue;
                }

                if (y < objImage.ref_objMainImage.Height)
                    objImage1.ref_objMainImage.SetPixel(darkPixel, x, y);
            }
            for (x = intEndX2; x <= intEndX1; x++)
            {
                y = (int)Math.Round(objLine4.GetPointY(x), 0, MidpointRounding.AwayFromZero);

                if (!(y >= 0 && y < objImage.ref_objMainImage.Height &&
                    x >= 0 && x < objImage.ref_objMainImage.Width))
                {
                    continue;
                }

                if (y < objImage.ref_objMainImage.Height)
                    objImage1.ref_objMainImage.SetPixel(darkPixel, x, y);
            }
            objROI2.LoadROISetting((int)Math.Round(0f), (int)Math.Round(0f), (int)Math.Round(objImage.ref_intImageWidth + 0f), (int)Math.Round(objImage.ref_intImageHeight + 0f));
            objROI2.AttachImage(objImage2);
            //HiPerfTimer t1 = new HiPerfTimer();
            //t1.Start();
            EasyImage.DilateBox(objROI1.ref_ROI, objROI1.ref_ROI, 1); // 2020-11-18 ZJYEOH : To prevent the pixel connection break after rotate
            //t1.Stop();
            //STTrackLog.WriteLine("t1 = " + t1.Duration.ToString());
            //objROI1.SaveImage("D:\\objROI1.bmp");
            ROI.Rotate0Degree_ForDontCare(objROI1, -fAngle, 0, objROI2);
            //objROI2.SaveImage("D:\\objROI2.bmp");
            //objImage2.SaveImage("D:\\objImage2.bmp");
            objROI1.AttachImage(objImage);
            if (intChipLineLimitPixelValue == 0)
                ROI.SubtractROI(objROI1, objROI2);
            else
                ROI.LogicOperationAddROI(objROI1, objROI2);
            //objImage.SaveImage("D:\\objImage.bmp");
            objROI1.Dispose();
            objROI2.Dispose();
            objImage1.Dispose();
            objImage2.Dispose();
            //t.Stop();
            //STTrackLog.WriteLine("t = " + t.Duration.ToString());
        }
        private void FillChipLineLimitToCorner(ImageDrawing objImage, int intChippedOffTolerance, int intChipLineLimitPixelValue)
        {
            if (objImage.ref_intImageHeight == 0 || objImage.ref_intImageWidth == 0)
                return;

            int intStartX1 = 0;
            int intStartY1 = 0;
            int intEndX1 = objImage.ref_intImageWidth - 1;
            int intEndY1 = objImage.ref_intImageHeight - 1;

            int intStartX2 = intChippedOffTolerance;
            int intStartY2 = intChippedOffTolerance;
            int intEndX2 = objImage.ref_intImageWidth - intChippedOffTolerance - 1;
            int intEndY2 = objImage.ref_intImageHeight - intChippedOffTolerance - 1;

            Line objLine1 = new Line();
            Line objLine2 = new Line();
            Line objLine3 = new Line();
            Line objLine4 = new Line();
            objLine1.CalculateStraightLine(new PointF(intStartX1, intStartY1), new PointF(intStartX2, intStartY2));
            objLine2.CalculateStraightLine(new PointF(intEndX1, intStartY1), new PointF(intEndX2, intStartY2));
            objLine3.CalculateStraightLine(new PointF(intStartX1, intEndY1), new PointF(intStartX2, intEndY2));
            objLine4.CalculateStraightLine(new PointF(intEndX1, intEndY1), new PointF(intEndX2, intEndY2));
            int x, y;
            EBW8 darkPixel = new EBW8((byte)intChipLineLimitPixelValue);
            // -------- separate corner with dark line -------------------------------------------
            for (x = intStartX1; x <= intStartX2; x++)
            {
                y = (int)Math.Round(objLine1.GetPointY(x), 0, MidpointRounding.AwayFromZero);

                if (!(y >= 0 && y < objImage.ref_objMainImage.Height &&
                    x >= 0 && x < objImage.ref_objMainImage.Width))
                {
                    continue;
                }

                if (y < objImage.ref_objMainImage.Height)
                    objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
            }
            for (x = intEndX2; x <= intEndX1; x++)
            {
                y = (int)Math.Round(objLine2.GetPointY(x), 0, MidpointRounding.AwayFromZero);

                if (!(y >= 0 && y < objImage.ref_objMainImage.Height &&
                    x >= 0 && x < objImage.ref_objMainImage.Width))
                {
                    continue;
                }

                if (y < objImage.ref_objMainImage.Height)
                    objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
            }
            for (x = intStartX1; x <= intStartX2; x++)
            {
                y = (int)Math.Round(objLine3.GetPointY(x), 0, MidpointRounding.AwayFromZero);

                if (!(y >= 0 && y < objImage.ref_objMainImage.Height &&
                    x >= 0 && x < objImage.ref_objMainImage.Width))
                {
                    continue;
                }

                if (y < objImage.ref_objMainImage.Height)
                    objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
            }
            for (x = intEndX2; x <= intEndX1; x++)
            {
                y = (int)Math.Round(objLine4.GetPointY(x), 0, MidpointRounding.AwayFromZero);

                if (!(y >= 0 && y < objImage.ref_objMainImage.Height &&
                    x >= 0 && x < objImage.ref_objMainImage.Width))
                {
                    continue;
                }

                if (y < objImage.ref_objMainImage.Height)
                    objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
            }

            // ------------------- Set limit with dark pixel --------------------------------------------------
            for (x = intStartX2; x < intEndX2; x++)
            {
                objImage.ref_objMainImage.SetPixel(darkPixel, x, intStartY2);
            }
            int intEnd = intEndY2;
            for (x = intStartX2; x < intEndX2; x++)
            {
                objImage.ref_objMainImage.SetPixel(darkPixel, x, intEnd);
            }
            for (y = intStartY2; y < intEndY2; y++)
            {
                objImage.ref_objMainImage.SetPixel(darkPixel, intStartX2, y);
            }
            intEnd = intEndX2;
            for (y = intStartY2; y < intEndY2; y++)
            {
                objImage.ref_objMainImage.SetPixel(darkPixel, intEnd, y);
            }

            //// 
            //for (x = 0; x < 3; x++)
            //{
            //    for (y = 0; y < 3; y++)
            //        objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
            //}
            //for (x = 0; x < 3; x++)
            //{
            //    for (y = intEndY1 - 2; y <= intEndY1; y++)
            //        objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
            //}
            //for (x = intEndX1 - 2; x <= intEndX1; x++)
            //{
            //    for (y = 0; y < 3; y++)
            //        objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
            //}
            //for (x = intEndX1 - 2; x <= intEndX1; x++)
            //{
            //    for (y = intEndY1 - 2; y <= intEndY1; y++)
            //        objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
            //}

        }
        private void ClearColorDefect()
        {
            m_arrDefectColorThresName.Clear();
            m_arrDefectColorSystem.Clear();
            m_arrDefectCloseIteration.Clear();
            m_arrDefectInvertBlackWhite.Clear();
            m_arrDefectColor.Clear();
            m_arrDefectColorTolerance.Clear();
            m_arrDefectColorMinArea.Clear();
            m_arrDefectType.Clear();
            m_arrDefectImageNo.Clear();
            m_arrDefectDontCareMode.Clear();
            m_arrDefectColorInspection_Top.Clear();
            m_arrDefectColorInspection_Right.Clear();
            m_arrDefectColorInspection_Bottom.Clear();
            m_arrDefectColorInspection_Left.Clear();

        }
        public void LoadPackage(string strPath, string strSectionName, float fCalibPixelPerMMX, float fCalibPixelPerMMY)
        {
            XmlParser objFile = new XmlParser(strPath);

            objFile.GetFirstSection(strSectionName);

            // Min area
            m_intMarkViewMinArea = objFile.GetValueAsInt("MarkViewMinArea", 20);
            m_intPkgViewMinArea = objFile.GetValueAsInt("PkgViewMinArea", 20);
            m_intCrackViewMinArea = objFile.GetValueAsInt("CrackViewMinArea", 20);
            m_intChipView1MinArea = objFile.GetValueAsInt("ChipView1MinArea", 20);
            m_intChipView2MinArea = objFile.GetValueAsInt("ChipView2MinArea", 20);
            m_intVoidViewMinArea = objFile.GetValueAsInt("VoidViewMinArea", 20);
            m_intMoldFlashMinArea = objFile.GetValueAsInt("MoldFlashMinArea", 20);
            m_intBrightFieldMinArea = objFile.GetValueAsInt("BrightFieldMinArea", 20);
            m_intDarkFieldMinArea = objFile.GetValueAsInt("DarkFieldMinArea", 20);
            m_intDarkField2MinArea = objFile.GetValueAsInt("DarkField2MinArea", 20);
            m_intDarkField3MinArea = objFile.GetValueAsInt("DarkField3MinArea", 20);
            m_intDarkField4MinArea = objFile.GetValueAsInt("DarkField4MinArea", 20);
            // Threshold
            m_intMarkViewHighThreshold = objFile.GetValueAsInt("MarkViewHighThreshold", 200);
            m_intMarkViewLowThreshold = objFile.GetValueAsInt("MarkViewLowThreshold", 50);
            m_intPkgViewThreshold = objFile.GetValueAsInt("PackageViewThreshold", -4);
            m_intCrackViewThreshold = objFile.GetValueAsInt("CrackViewThreshold", -4);
            m_intChipView1Threshold = objFile.GetValueAsInt("ChipView1Threshold", -4);
            m_intChipView2Threshold = objFile.GetValueAsInt("ChipView2Threshold", -4);
            m_intVoidViewThreshold = objFile.GetValueAsInt("VoidViewThreshold", -4);
            m_intMoldFlashThreshold = objFile.GetValueAsInt("MoldFlashThreshold", -4);
            m_intCrackViewLowThreshold = objFile.GetValueAsInt("CrackViewLowThreshold", 50);
            m_intCrackViewHighThreshold = objFile.GetValueAsInt("CrackViewHighThreshold", 200);
            m_intBrightFieldLowThreshold = objFile.GetValueAsInt("BrightFieldLowThreshold", 50);
            m_intBrightFieldHighThreshold = objFile.GetValueAsInt("BrightFieldHighThreshold", 255);
            m_intDarkFieldLowThreshold = objFile.GetValueAsInt("DarkFieldLowThreshold", 50);
            m_intDarkFieldHighThreshold = objFile.GetValueAsInt("DarkFieldHighThreshold", 255);
            m_intDarkField2LowThreshold = objFile.GetValueAsInt("DarkField2LowThreshold", 50);
            m_intDarkField2HighThreshold = objFile.GetValueAsInt("DarkField2HighThreshold", 255);
            m_intDarkField3LowThreshold = objFile.GetValueAsInt("DarkField3LowThreshold", 50);
            m_intDarkField3HighThreshold = objFile.GetValueAsInt("DarkFiel32HighThreshold", 255);
            m_intDarkField4LowThreshold = objFile.GetValueAsInt("DarkField4LowThreshold", 50);
            m_intDarkField4HighThreshold = objFile.GetValueAsInt("DarkField4HighThreshold", 255);

            // Template Unit Size tolerance
            m_fUnitWidthMin = objFile.GetValueAsFloat("UnitWidthMin", 0);
            m_fUnitWidthMax = objFile.GetValueAsFloat("UnitWidthMax", 0);
            m_fUnitHeightMin = objFile.GetValueAsFloat("UnitHeightMin", 0);
            m_fUnitHeightMax = objFile.GetValueAsFloat("UnitHeightMax", 0);
            m_fUnitAngleMax = objFile.GetValueAsFloat("UnitAngleMax", 15);

            // Unit Sitting Tolerance
            m_fSittingWidthMin = objFile.GetValueAsFloat("SittingWidthMin", 0);
            m_fSittingWidthMax = objFile.GetValueAsFloat("SittingWidthMax", 0);
            m_fSittingHeightMin = objFile.GetValueAsFloat("SittingHeightMin", 0);
            m_fSittingHeightMax = objFile.GetValueAsFloat("SittingHeightMax", 0);
            
            // Setting
            m_intStartPixelFromEdge = (int)Math.Round(objFile.GetValueAsFloat("PixelFromEdge", 0), 0, MidpointRounding.AwayFromZero);  //04-03-2019 ZJYeoh : remove conversion(* fCalibPixelPerMM) to avoid rounding problem 
            m_intStartPixelFromRight = (int)Math.Round(objFile.GetValueAsFloat("PixelFromRight", 0), 0, MidpointRounding.AwayFromZero);
            m_intStartPixelFromBottom = (int)Math.Round(objFile.GetValueAsFloat("PixelFromBottom", 0), 0, MidpointRounding.AwayFromZero);
            m_intStartPixelFromLeft = (int)Math.Round(objFile.GetValueAsFloat("PixelFromLeft", 0), 0, MidpointRounding.AwayFromZero);
            m_intStartPixelFromEdge_DarkField2 = (int)Math.Round(objFile.GetValueAsFloat("PixelFromEdge_DarkField2", 0), 0, MidpointRounding.AwayFromZero); 
            m_intStartPixelFromRight_DarkField2 = (int)Math.Round(objFile.GetValueAsFloat("PixelFromRight_DarkField2", 0), 0, MidpointRounding.AwayFromZero);
            m_intStartPixelFromBottom_DarkField2 = (int)Math.Round(objFile.GetValueAsFloat("PixelFromBottom_DarkField2", 0), 0, MidpointRounding.AwayFromZero);
            m_intStartPixelFromLeft_DarkField2 = (int)Math.Round(objFile.GetValueAsFloat("PixelFromLeft_DarkField2", 0), 0, MidpointRounding.AwayFromZero);
            m_intStartPixelFromEdge_DarkField3 = (int)Math.Round(objFile.GetValueAsFloat("PixelFromEdge_DarkField3", 0), 0, MidpointRounding.AwayFromZero);
            m_intStartPixelFromRight_DarkField3 = (int)Math.Round(objFile.GetValueAsFloat("PixelFromRight_DarkField3", 0), 0, MidpointRounding.AwayFromZero);
            m_intStartPixelFromBottom_DarkField3 = (int)Math.Round(objFile.GetValueAsFloat("PixelFromBottom_DarkField3", 0), 0, MidpointRounding.AwayFromZero);
            m_intStartPixelFromLeft_DarkField3 = (int)Math.Round(objFile.GetValueAsFloat("PixelFromLeft_DarkField3", 0), 0, MidpointRounding.AwayFromZero);
            m_intStartPixelFromEdge_DarkField4 = (int)Math.Round(objFile.GetValueAsFloat("PixelFromEdge_DarkField4", 0), 0, MidpointRounding.AwayFromZero);
            m_intStartPixelFromRight_DarkField4 = (int)Math.Round(objFile.GetValueAsFloat("PixelFromRight_DarkField4", 0), 0, MidpointRounding.AwayFromZero);
            m_intStartPixelFromBottom_DarkField4 = (int)Math.Round(objFile.GetValueAsFloat("PixelFromBottom_DarkField4", 0), 0, MidpointRounding.AwayFromZero);
            m_intStartPixelFromLeft_DarkField4 = (int)Math.Round(objFile.GetValueAsFloat("PixelFromLeft_DarkField4", 0), 0, MidpointRounding.AwayFromZero);
            m_intStartPixelFromEdge_Mold = (int)Math.Round(objFile.GetValueAsFloat("PixelFromEdge_Mold", 0), 0, MidpointRounding.AwayFromZero);
            m_intStartPixelFromRight_Mold = (int)Math.Round(objFile.GetValueAsFloat("PixelFromRight_Mold", 0), 0, MidpointRounding.AwayFromZero);
            m_intStartPixelFromBottom_Mold = (int)Math.Round(objFile.GetValueAsFloat("PixelFromBottom_Mold", 0), 0, MidpointRounding.AwayFromZero);
            m_intStartPixelFromLeft_Mold = (int)Math.Round(objFile.GetValueAsFloat("PixelFromLeft_Mold", 0), 0, MidpointRounding.AwayFromZero);
            m_intStartPixelFromEdgeInner_Mold = (int)Math.Round(objFile.GetValueAsFloat("PixelFromEdgeInner_Mold", 0), 0, MidpointRounding.AwayFromZero);
            m_intStartPixelFromRightInner_Mold = (int)Math.Round(objFile.GetValueAsFloat("PixelFromRightInner_Mold", 0), 0, MidpointRounding.AwayFromZero);
            m_intStartPixelFromBottomInner_Mold = (int)Math.Round(objFile.GetValueAsFloat("PixelFromBottomInner_Mold", 0), 0, MidpointRounding.AwayFromZero);
            m_intStartPixelFromLeftInner_Mold = (int)Math.Round(objFile.GetValueAsFloat("PixelFromLeftInner_Mold", 0), 0, MidpointRounding.AwayFromZero);
            m_intStartPixelFromEdge_Chip = (int)Math.Round(objFile.GetValueAsFloat("PixelFromEdge_Chip", 0), 0, MidpointRounding.AwayFromZero);
            m_intStartPixelFromRight_Chip = (int)Math.Round(objFile.GetValueAsFloat("PixelFromRight_Chip", 0), 0, MidpointRounding.AwayFromZero);
            m_intStartPixelFromBottom_Chip = (int)Math.Round(objFile.GetValueAsFloat("PixelFromBottom_Chip", 0), 0, MidpointRounding.AwayFromZero);
            m_intStartPixelFromLeft_Chip = (int)Math.Round(objFile.GetValueAsFloat("PixelFromLeft_Chip", 0), 0, MidpointRounding.AwayFromZero);
            m_intStartPixelExtendFromEdge_Chip = (int)Math.Round(objFile.GetValueAsFloat("PixelExtendFromEdge_Chip", 0), 0, MidpointRounding.AwayFromZero);
            m_intStartPixelExtendFromRight_Chip = (int)Math.Round(objFile.GetValueAsFloat("PixelExtendFromRight_Chip", 0), 0, MidpointRounding.AwayFromZero);
            m_intStartPixelExtendFromBottom_Chip = (int)Math.Round(objFile.GetValueAsFloat("PixelExtendFromBottom_Chip", 0), 0, MidpointRounding.AwayFromZero);
            m_intStartPixelExtendFromLeft_Chip = (int)Math.Round(objFile.GetValueAsFloat("PixelExtendFromLeft_Chip", 0), 0, MidpointRounding.AwayFromZero);
            m_intStartPixelFromEdge_Dark = (int)Math.Round(objFile.GetValueAsFloat("PixelFromEdge_Dark", 0), 0, MidpointRounding.AwayFromZero);  //04-03-2019 ZJYeoh : remove conversion(* fCalibPixelPerMM) to avoid rounding problem 
            m_intStartPixelFromRight_Dark = (int)Math.Round(objFile.GetValueAsFloat("PixelFromRight_Dark", 0), 0, MidpointRounding.AwayFromZero);
            m_intStartPixelFromBottom_Dark = (int)Math.Round(objFile.GetValueAsFloat("PixelFromBottom_Dark", 0), 0, MidpointRounding.AwayFromZero);
            m_intStartPixelFromLeft_Dark = (int)Math.Round(objFile.GetValueAsFloat("PixelFromLeft_Dark", 0), 0, MidpointRounding.AwayFromZero);
            m_intStartPixelFromEdge_Chip_Dark = (int)Math.Round(objFile.GetValueAsFloat("PixelFromEdge_Chip_Dark", 0), 0, MidpointRounding.AwayFromZero);
            m_intStartPixelFromRight_Chip_Dark = (int)Math.Round(objFile.GetValueAsFloat("PixelFromRight_Chip_Dark", 0), 0, MidpointRounding.AwayFromZero);
            m_intStartPixelFromBottom_Chip_Dark = (int)Math.Round(objFile.GetValueAsFloat("PixelFromBottom_Chip_Dark", 0), 0, MidpointRounding.AwayFromZero);
            m_intStartPixelFromLeft_Chip_Dark = (int)Math.Round(objFile.GetValueAsFloat("PixelFromLeft_Chip_Dark", 0), 0, MidpointRounding.AwayFromZero);
            m_intStartPixelExtendFromEdge_Chip_Dark = (int)Math.Round(objFile.GetValueAsFloat("PixelExtendFromEdge_Chip_Dark", 0), 0, MidpointRounding.AwayFromZero);
            m_intStartPixelExtendFromRight_Chip_Dark = (int)Math.Round(objFile.GetValueAsFloat("PixelExtendFromRight_Chip_Dark", 0), 0, MidpointRounding.AwayFromZero);
            m_intStartPixelExtendFromBottom_Chip_Dark = (int)Math.Round(objFile.GetValueAsFloat("PixelExtendFromBottom_Chip_Dark", 0), 0, MidpointRounding.AwayFromZero);
            m_intStartPixelExtendFromLeft_Chip_Dark = (int)Math.Round(objFile.GetValueAsFloat("PixelExtendFromLeft_Chip_Dark", 0), 0, MidpointRounding.AwayFromZero);


            m_fUnitSizeTolerance = objFile.GetValueAsFloat("UnitSizeTolerance", 0);
            m_intPkgFailMask = objFile.GetValueAsInt("FailMask", 31);
            m_intUseOtherGaugeMeasurePackage = objFile.GetValueAsInt("UseOtherGaugeMeasurePackage", 0);

            m_intBrightDefectLinkTolerance = objFile.GetValueAsInt("BrightDefectLinkTolerance", 10);
            m_intDarkDefectLinkTolerance = objFile.GetValueAsInt("DarkDefectLinkTolerance", 10);
            m_intDark2DefectLinkTolerance = objFile.GetValueAsInt("Dark2DefectLinkTolerance", 10);
            m_intDark3DefectLinkTolerance = objFile.GetValueAsInt("Dark3DefectLinkTolerance", 10);
            m_intDark4DefectLinkTolerance = objFile.GetValueAsInt("Dark4DefectLinkTolerance", 10);
            m_intCrackDefectLinkTolerance = objFile.GetValueAsInt("CrackDefectLinkTolerance", 10);
            m_intMoldFlashDefectLinkTolerance = objFile.GetValueAsInt("MoldFlashDefectLinkTolerance", 10);
            m_blnWantLinkBrightDefect = objFile.GetValueAsBoolean("WantLinkBrightDefect", false);
            m_blnWantLinkDarkDefect = objFile.GetValueAsBoolean("WantLinkDarkDefect", false);
            m_blnWantLinkDark2Defect = objFile.GetValueAsBoolean("WantLinkDark2Defect", false);
            m_blnWantLinkDark3Defect = objFile.GetValueAsBoolean("WantLinkDark3Defect", false);
            m_blnWantLinkDark4Defect = objFile.GetValueAsBoolean("WantLinkDark4Defect", false);
            m_blnWantLinkCrackDefect = objFile.GetValueAsBoolean("WantLinkCrackDefect", false);
            m_blnWantLinkMoldFlashDefect = objFile.GetValueAsBoolean("WantLinkMoldFlashDefect", false);
            m_blnSeperateBrightDarkROITolerance = objFile.GetValueAsBoolean("SeperateBrightDarkROITolerance", false);
            m_blnSeperateDarkField2DefectSetting = objFile.GetValueAsBoolean("SeperateDarkField2DefectSetting", false);
            m_blnSeperateDarkField3DefectSetting = objFile.GetValueAsBoolean("SeperateDarkField3DefectSetting", false);
            m_blnSeperateDarkField4DefectSetting = objFile.GetValueAsBoolean("SeperateDarkField4DefectSetting", false);
            m_blnSeperateCrackDefectSetting = objFile.GetValueAsBoolean("SeperateCrackDefectSetting", false);
            m_blnSeperateChippedOffDefectSetting = objFile.GetValueAsBoolean("SeperateChippedOffDefectSetting", false);
            m_intChippedOffDefectInspectionMethod = objFile.GetValueAsInt("ChippedOffDefectInspectionMethod", 0);
            m_blnSeperateVoidDefectSetting = objFile.GetValueAsBoolean("SeperateVoidDefectSetting", false);
            m_blnSeperateMoldFlashDefectSetting = objFile.GetValueAsBoolean("SeperateMoldFlashDefectSetting", false);

            m_intBrightDefectDimensionFailCondition = objFile.GetValueAsInt("BrightDefectDimensionFailCondition", 0);
            m_intDarkDefectDimensionFailCondition = objFile.GetValueAsInt("DarkDefectDimensionFailCondition", 0);
            m_intDark2DefectDimensionFailCondition = objFile.GetValueAsInt("Dark2DefectDimensionFailCondition", 0);
            m_intDark3DefectDimensionFailCondition = objFile.GetValueAsInt("Dark3DefectDimensionFailCondition", 0);
            m_intDark4DefectDimensionFailCondition = objFile.GetValueAsInt("Dark4DefectDimensionFailCondition", 0);
            m_intCrackDarkDefectDimensionFailCondition = objFile.GetValueAsInt("CrackDarkDefectDimensionFailCondition", 0);
            m_intChippedBrightDefectDimensionFailCondition = objFile.GetValueAsInt("ChippedBrightDefectDimensionFailCondition", 0);
            m_intChippedDarkDefectDimensionFailCondition = objFile.GetValueAsInt("ChippedDarkDefectDimensionFailCondition", 0);

            //PackageSize Offset
            m_fWidthOffsetMM = objFile.GetValueAsFloat("WidthOffsetMM", 0);
            m_fHeightOffsetMM = objFile.GetValueAsFloat("HeightOffsetMM", 0);

            // Unit Surface Offset
            m_fUnitSurfaceOffsetX = objFile.GetValueAsFloat("UnitSurfaceOffsetX", 0);
            m_fUnitSurfaceOffsetY = objFile.GetValueAsFloat("UnitSurfaceOffsetY", 0);

            // Defect Horizontal Tolerance
            m_arrDefectHorizontal = new float[10];
            for (int i = 0; i < m_arrDefectHorizontal.Length; i++)
                m_arrDefectHorizontal[i] = objFile.GetValueAsFloat("DefectHorizontalValue" + i.ToString(), 0) * fCalibPixelPerMMX;

            // Defect Vertical Tolerance
            m_arrDefectVertical = new float[10];
            for (int i = 0; i < m_arrDefectVertical.Length; i++)
                m_arrDefectVertical[i] = objFile.GetValueAsFloat("DefectVerticalValue" + i.ToString(), 0) * fCalibPixelPerMMY;

            // Defect Area Tolerance
            m_arrDefectArea = new float[10];
            for (int i = 0; i < m_arrDefectArea.Length; i++)
                m_arrDefectArea[i] = objFile.GetValueAsFloat("DefectAreaValue" + i.ToString(), 0) * fCalibPixelPerMMX * fCalibPixelPerMMY;

            // Defect Total Area Tolerance
            m_arrDefectTotalArea = new float[10];
            for (int i = 0; i < m_arrDefectTotalArea.Length; i++)
                m_arrDefectTotalArea[i] = objFile.GetValueAsFloat("DefectTotalAreaValue" + i.ToString(), 0) * fCalibPixelPerMMX * fCalibPixelPerMMY;

            // Want Defect Length 
            m_arrWantDefectLength = new bool[15];
            for (int i = 0; i < m_arrWantDefectLength.Length; i++)
                m_arrWantDefectLength[i] = objFile.GetValueAsBoolean("WantDefectLength" + i.ToString(), false);

            // Want Defect Area
            m_arrWantDefectArea = new bool[15];
            for (int i = 0; i < m_arrWantDefectArea.Length; i++)
                m_arrWantDefectArea[i] = objFile.GetValueAsBoolean("WantDefectArea" + i.ToString(), false);

            // Want Inspect Package   
            m_blnInspectPackage = objFile.GetValueAsBoolean("WantInspectPackage", false);

            // Grab image index
            int intGrabImageIndexCount = objFile.GetValueAsInt("GrabImageIndexCount", 0);
            m_arrGrabImageIndex.Clear();
            for (int j = 0; j < intGrabImageIndexCount; j++)
                m_arrGrabImageIndex.Add(objFile.GetValueAsInt("GrabImageIndex" + j.ToString(), 0));

            //2021-10-27 ZJYEOH : Default need load at least 6 count
            if (m_arrGrabImageIndex.Count < 6)
            {
                for (int i = m_arrGrabImageIndex.Count; i < 6; i++)
                {
                    m_arrGrabImageIndex.Add(0);
                }
            }

            objFile.GetSecondSection("ColorPackageSetting");
            m_intColorDefectLinkMethod = objFile.GetValueAsInt("ColorDefectLinkMethod", 0, 2);
            m_intColorDefectLinkTolerance = objFile.GetValueAsInt("ColorDefectLinkTolerance", 10, 2);
            m_intFailColorOptionMask = objFile.GetValueAsInt("FailColorMask", 0, 2);
            int intColorDefectCount = objFile.GetValueAsInt("ColorDefectCount", 0, 2);
            ClearColorDefect();
            for (int v = 0; v < intColorDefectCount; v++)
            {
                objFile.GetSecondSection("ColorDefect" + v);
                m_arrDefectColorThresName.Add(objFile.GetValueAsString("DefectColorThresName", "", 2));
                m_arrDefectColorSystem.Add(objFile.GetValueAsInt("DefectColorSystem", 0, 2));
                m_arrDefectCloseIteration.Add(objFile.GetValueAsInt("DefectCloseIteration", 0, 2));
                m_arrDefectInvertBlackWhite.Add(objFile.GetValueAsBoolean("DefectInvertBlackWhite", false, 2));
                m_arrDefectColor.Add(new int[3]);
                m_arrDefectColor[v][0] = objFile.GetValueAsInt("DefectColor0", 0, 2);
                m_arrDefectColor[v][1] = objFile.GetValueAsInt("DefectColor1", 0, 2);
                m_arrDefectColor[v][2] = objFile.GetValueAsInt("DefectColor2", 0, 2);
                m_arrDefectColorTolerance.Add(new int[3]);
                m_arrDefectColorTolerance[v][0] = objFile.GetValueAsInt("DefectColorTolerance0", 0, 2);
                m_arrDefectColorTolerance[v][1] = objFile.GetValueAsInt("DefectColorTolerance1", 0, 2);
                m_arrDefectColorTolerance[v][2] = objFile.GetValueAsInt("DefectColorTolerance2", 0, 2);
                m_arrDefectColorMinArea.Add(objFile.GetValueAsInt("DefectColorMinArea", 0, 2));
                m_arrDefectType.Add(objFile.GetValueAsInt("DefectType", 0, 2));
                m_arrDefectImageNo.Add(objFile.GetValueAsInt("DefectImageNo", 0, 2));
                m_arrDefectDontCareMode.Add(objFile.GetValueAsInt("DefectDontCareMode", 0, 2));
                m_arrDefectColorInspection_Top.Add(objFile.GetValueAsInt("DefectColorInspection_Top", 0, 2));
                m_arrDefectColorInspection_Right.Add(objFile.GetValueAsInt("DefectColorInspection_Right", 0, 2));
                m_arrDefectColorInspection_Bottom.Add(objFile.GetValueAsInt("DefectColorInspection_Bottom", 0, 2));
                m_arrDefectColorInspection_Left.Add(objFile.GetValueAsInt("DefectColorInspection_Left", 0, 2));
                m_arrDefectColorInspectionFailCondition.Add(objFile.GetValueAsInt("DefectColorInspectionFailCondition", 0, 2));
                m_arrDefectColorInspectionWidth.Add(objFile.GetValueAsFloat("DefectColorInspectionWidth", 0, 2));
                m_arrDefectColorInspectionLength.Add(objFile.GetValueAsFloat("DefectColorInspectionLength", 0, 2));
                m_arrDefectColorInspectionMinArea.Add(objFile.GetValueAsFloat("DefectColorInspectionMinArea", 0, 2));
                m_arrDefectColorInspectionMaxArea.Add(objFile.GetValueAsFloat("DefectColorInspectionMaxArea", 0, 2));
                m_arrDefectColorInspectionTotalArea.Add(objFile.GetValueAsFloat("DefectColorInspectionTotalArea", 0, 2));

            }

        }

        public void LoadPackageToleranceOnly(string strPath, string strSectionName, float fCalibPixelPerMMX, float fCalibPixelPerMMY)
        {
            XmlParser objFile = new XmlParser(strPath);

            objFile.GetFirstSection(strSectionName);

            // Template Unit Size tolerance
            m_fUnitWidthMin = objFile.GetValueAsFloat("UnitWidthMin", 0);
            m_fUnitWidthMax = objFile.GetValueAsFloat("UnitWidthMax", 0);
            m_fUnitHeightMin = objFile.GetValueAsFloat("UnitHeightMin", 0);
            m_fUnitHeightMax = objFile.GetValueAsFloat("UnitHeightMax", 0);
            m_fUnitAngleMax = objFile.GetValueAsFloat("UnitAngleMax", 15);

            // Unit Sitting Tolerance
            m_fSittingWidthMin = objFile.GetValueAsFloat("SittingWidthMin", 0);
            m_fSittingWidthMax = objFile.GetValueAsFloat("SittingWidthMax", 0);
            m_fSittingHeightMin = objFile.GetValueAsFloat("SittingHeightMin", 0);
            m_fSittingHeightMax = objFile.GetValueAsFloat("SittingHeightMax", 0);

            m_intBrightDefectLinkTolerance = objFile.GetValueAsInt("BrightDefectLinkTolerance", 10);
            m_intDarkDefectLinkTolerance = objFile.GetValueAsInt("DarkDefectLinkTolerance", 10);
            m_intDark2DefectLinkTolerance = objFile.GetValueAsInt("Dark2DefectLinkTolerance", 10);
            m_intDark3DefectLinkTolerance = objFile.GetValueAsInt("Dark3DefectLinkTolerance", 10);
            m_intDark4DefectLinkTolerance = objFile.GetValueAsInt("Dark4DefectLinkTolerance", 10);
            m_intCrackDefectLinkTolerance = objFile.GetValueAsInt("CrackDefectLinkTolerance", 10);
            m_intMoldFlashDefectLinkTolerance = objFile.GetValueAsInt("MoldFlashDefectLinkTolerance", 10);

            //PackageSize Offset
            m_fWidthOffsetMM = objFile.GetValueAsFloat("WidthOffsetMM", 0);
            m_fHeightOffsetMM = objFile.GetValueAsFloat("HeightOffsetMM", 0);

            // Unit Surface Offset
            m_fUnitSurfaceOffsetX = objFile.GetValueAsFloat("UnitSurfaceOffsetX", 0);
            m_fUnitSurfaceOffsetY = objFile.GetValueAsFloat("UnitSurfaceOffsetY", 0);

            // Defect Horizontal Tolerance
            m_arrDefectHorizontal = new float[10];
            for (int i = 0; i < m_arrDefectHorizontal.Length; i++)
                m_arrDefectHorizontal[i] = objFile.GetValueAsFloat("DefectHorizontalValue" + i.ToString(), 0) * fCalibPixelPerMMX;

            // Defect Vertical Tolerance
            m_arrDefectVertical = new float[10];
            for (int i = 0; i < m_arrDefectVertical.Length; i++)
                m_arrDefectVertical[i] = objFile.GetValueAsFloat("DefectVerticalValue" + i.ToString(), 0) * fCalibPixelPerMMY;

            // Defect Area Tolerance
            m_arrDefectArea = new float[10];
            for (int i = 0; i < m_arrDefectArea.Length; i++)
                m_arrDefectArea[i] = objFile.GetValueAsFloat("DefectAreaValue" + i.ToString(), 0) * fCalibPixelPerMMX * fCalibPixelPerMMY;

            // Defect Total Area Tolerance
            m_arrDefectTotalArea = new float[10];
            for (int i = 0; i < m_arrDefectTotalArea.Length; i++)
                m_arrDefectTotalArea[i] = objFile.GetValueAsFloat("DefectTotalAreaValue" + i.ToString(), 0) * fCalibPixelPerMMX * fCalibPixelPerMMY;

            objFile.GetSecondSection("ColorPackageSetting");
            m_intColorDefectLinkMethod = objFile.GetValueAsInt("ColorDefectLinkMethod", 0, 2);
            m_intColorDefectLinkTolerance = objFile.GetValueAsInt("ColorDefectLinkTolerance", 10, 2);
            m_intFailColorOptionMask = objFile.GetValueAsInt("FailColorMask", 0, 2);
            int intColorDefectCount = objFile.GetValueAsInt("ColorDefectCount", 0, 2);
            ClearColorDefect();
            for (int v = 0; v < intColorDefectCount; v++)
            {
                objFile.GetSecondSection("ColorDefect" + v);
                m_arrDefectColorThresName.Add(objFile.GetValueAsString("DefectColorThresName", "", 2));
                m_arrDefectColorSystem.Add(objFile.GetValueAsInt("DefectColorSystem", 0, 2));
                m_arrDefectCloseIteration.Add(objFile.GetValueAsInt("DefectCloseIteration", 0, 2));
                m_arrDefectInvertBlackWhite.Add(objFile.GetValueAsBoolean("DefectInvertBlackWhite", false, 2));
                m_arrDefectColor.Add(new int[3]);
                m_arrDefectColor[v][0] = objFile.GetValueAsInt("DefectColor0", 0, 2);
                m_arrDefectColor[v][1] = objFile.GetValueAsInt("DefectColor1", 0, 2);
                m_arrDefectColor[v][2] = objFile.GetValueAsInt("DefectColor2", 0, 2);
                m_arrDefectColorTolerance.Add(new int[3]);
                m_arrDefectColorTolerance[v][0] = objFile.GetValueAsInt("DefectColorTolerance0", 0, 2);
                m_arrDefectColorTolerance[v][1] = objFile.GetValueAsInt("DefectColorTolerance1", 0, 2);
                m_arrDefectColorTolerance[v][2] = objFile.GetValueAsInt("DefectColorTolerance2", 0, 2);
                m_arrDefectColorMinArea.Add(objFile.GetValueAsInt("DefectColorMinArea", 0, 2));
                m_arrDefectType.Add(objFile.GetValueAsInt("DefectType", 0, 2));
                m_arrDefectImageNo.Add(objFile.GetValueAsInt("DefectImageNo", 0, 2));
                m_arrDefectDontCareMode.Add(objFile.GetValueAsInt("DefectDontCareMode", 0, 2));
                m_arrDefectColorInspection_Top.Add(objFile.GetValueAsInt("DefectColorInspection_Top", 0, 2));
                m_arrDefectColorInspection_Right.Add(objFile.GetValueAsInt("DefectColorInspection_Right", 0, 2));
                m_arrDefectColorInspection_Bottom.Add(objFile.GetValueAsInt("DefectColorInspection_Bottom", 0, 2));
                m_arrDefectColorInspection_Left.Add(objFile.GetValueAsInt("DefectColorInspection_Left", 0, 2));
                m_arrDefectColorInspectionFailCondition.Add(objFile.GetValueAsInt("DefectColorInspectionFailCondition", 0, 2));
                m_arrDefectColorInspectionWidth.Add(objFile.GetValueAsFloat("DefectColorInspectionWidth", 0, 2));
                m_arrDefectColorInspectionLength.Add(objFile.GetValueAsFloat("DefectColorInspectionLength", 0, 2));
                m_arrDefectColorInspectionMinArea.Add(objFile.GetValueAsFloat("DefectColorInspectionMinArea", 0, 2));
                m_arrDefectColorInspectionMaxArea.Add(objFile.GetValueAsFloat("DefectColorInspectionMaxArea", 0, 2));
                m_arrDefectColorInspectionTotalArea.Add(objFile.GetValueAsFloat("DefectColorInspectionTotalArea", 0, 2));

            }

        }
        public void LoadColorPackageOnly(string strPath, string strSectionName)
        {
            XmlParser objFile = new XmlParser(strPath);

            objFile.GetFirstSection(strSectionName);

            objFile.GetSecondSection("ColorPackageSetting");
            m_intColorDefectLinkMethod = objFile.GetValueAsInt("ColorDefectLinkMethod", 0, 2);
            m_intColorDefectLinkTolerance = objFile.GetValueAsInt("ColorDefectLinkTolerance", 10, 2);
            m_intFailColorOptionMask = objFile.GetValueAsInt("FailColorMask", 0, 2);
            int intColorDefectCount = objFile.GetValueAsInt("ColorDefectCount", 0, 2);
            ClearColorDefect();
            for (int v = 0; v < intColorDefectCount; v++)
            {
                objFile.GetSecondSection("ColorDefect" + v);
                m_arrDefectColorThresName.Add(objFile.GetValueAsString("DefectColorThresName", "", 2));
                m_arrDefectColorSystem.Add(objFile.GetValueAsInt("DefectColorSystem", 0, 2));
                m_arrDefectCloseIteration.Add(objFile.GetValueAsInt("DefectCloseIteration", 0, 2));
                m_arrDefectInvertBlackWhite.Add(objFile.GetValueAsBoolean("DefectInvertBlackWhite", false, 2));
                m_arrDefectColor.Add(new int[3]);
                m_arrDefectColor[v][0] = objFile.GetValueAsInt("DefectColor0", 0, 2);
                m_arrDefectColor[v][1] = objFile.GetValueAsInt("DefectColor1", 0, 2);
                m_arrDefectColor[v][2] = objFile.GetValueAsInt("DefectColor2", 0, 2);
                m_arrDefectColorTolerance.Add(new int[3]);
                m_arrDefectColorTolerance[v][0] = objFile.GetValueAsInt("DefectColorTolerance0", 0, 2);
                m_arrDefectColorTolerance[v][1] = objFile.GetValueAsInt("DefectColorTolerance1", 0, 2);
                m_arrDefectColorTolerance[v][2] = objFile.GetValueAsInt("DefectColorTolerance2", 0, 2);
                m_arrDefectColorMinArea.Add(objFile.GetValueAsInt("DefectColorMinArea", 0, 2));
                m_arrDefectType.Add(objFile.GetValueAsInt("DefectType", 0, 2));
                m_arrDefectImageNo.Add(objFile.GetValueAsInt("DefectImageNo", 0, 2));
                m_arrDefectDontCareMode.Add(objFile.GetValueAsInt("DefectDontCareMode", 0, 2));
                m_arrDefectColorInspection_Top.Add(objFile.GetValueAsInt("DefectColorInspection_Top", 0, 2));
                m_arrDefectColorInspection_Right.Add(objFile.GetValueAsInt("DefectColorInspection_Right", 0, 2));
                m_arrDefectColorInspection_Bottom.Add(objFile.GetValueAsInt("DefectColorInspection_Bottom", 0, 2));
                m_arrDefectColorInspection_Left.Add(objFile.GetValueAsInt("DefectColorInspection_Left", 0, 2));
                m_arrDefectColorInspectionFailCondition.Add(objFile.GetValueAsInt("DefectColorInspectionFailCondition", 0, 2));
                m_arrDefectColorInspectionWidth.Add(objFile.GetValueAsFloat("DefectColorInspectionWidth", 0, 2));
                m_arrDefectColorInspectionLength.Add(objFile.GetValueAsFloat("DefectColorInspectionLength", 0, 2));
                m_arrDefectColorInspectionMinArea.Add(objFile.GetValueAsFloat("DefectColorInspectionMinArea", 0, 2));
                m_arrDefectColorInspectionMaxArea.Add(objFile.GetValueAsFloat("DefectColorInspectionMaxArea", 0, 2));
                m_arrDefectColorInspectionTotalArea.Add(objFile.GetValueAsFloat("DefectColorInspectionTotalArea", 0, 2));
            }

        }
        public void SaveColorPackage(string strPath, bool blnNewFile, string strSectionName, bool blnNewSection)
        {
            XmlParser objFile = new XmlParser(strPath, blnNewFile);

            objFile.WriteSectionElement(strSectionName, blnNewSection);

            // Save PackageSetting
            objFile.WriteElement1Value("ColorPackageSetting", "");
            objFile.WriteElement2Value("ColorDefectLinkMethod", m_intColorDefectLinkMethod);
            objFile.WriteElement2Value("ColorDefectLinkTolerance", m_intColorDefectLinkTolerance);
            objFile.WriteElement2Value("FailColorMask", m_intFailColorOptionMask);
            objFile.WriteElement2Value("ColorDefectCount", m_arrDefectColorThresName.Count);
            for (int v = 0; v < m_arrDefectColorThresName.Count; v++)
            {
                objFile.WriteElement1Value("ColorDefect" + v, "");
                objFile.WriteElement2Value("DefectColorThresName", m_arrDefectColorThresName[v]);
                objFile.WriteElement2Value("DefectColorSystem", m_arrDefectColorSystem[v]);
                objFile.WriteElement2Value("DefectCloseIteration", m_arrDefectCloseIteration[v]);
                objFile.WriteElement2Value("DefectInvertBlackWhite", m_arrDefectInvertBlackWhite[v]);
                objFile.WriteElement2Value("DefectColor0", m_arrDefectColor[v][0]);
                objFile.WriteElement2Value("DefectColor1", m_arrDefectColor[v][1]);
                objFile.WriteElement2Value("DefectColor2", m_arrDefectColor[v][2]);
                objFile.WriteElement2Value("DefectColorTolerance0", m_arrDefectColorTolerance[v][0]);
                objFile.WriteElement2Value("DefectColorTolerance1", m_arrDefectColorTolerance[v][1]);
                objFile.WriteElement2Value("DefectColorTolerance2", m_arrDefectColorTolerance[v][2]);
                objFile.WriteElement2Value("DefectColorMinArea", m_arrDefectColorMinArea[v]);
                objFile.WriteElement2Value("DefectType", m_arrDefectType[v]);
                objFile.WriteElement2Value("DefectImageNo", m_arrDefectImageNo[v]);
                objFile.WriteElement2Value("DefectDontCareMode", m_arrDefectDontCareMode[v]);
                objFile.WriteElement2Value("DefectColorInspection_Top", m_arrDefectColorInspection_Top[v]);
                objFile.WriteElement2Value("DefectColorInspection_Right", m_arrDefectColorInspection_Right[v]);
                objFile.WriteElement2Value("DefectColorInspection_Bottom", m_arrDefectColorInspection_Bottom[v]);
                objFile.WriteElement2Value("DefectColorInspection_Left", m_arrDefectColorInspection_Left[v]);
                objFile.WriteElement2Value("DefectColorInspectionFailCondition", m_arrDefectColorInspectionFailCondition[v]);
                objFile.WriteElement2Value("DefectColorInspectionWidth", m_arrDefectColorInspectionWidth[v]);
                objFile.WriteElement2Value("DefectColorInspectionLength", m_arrDefectColorInspectionLength[v]);
                objFile.WriteElement2Value("DefectColorInspectionMinArea", m_arrDefectColorInspectionMinArea[v]);
                objFile.WriteElement2Value("DefectColorInspectionMaxArea", m_arrDefectColorInspectionMaxArea[v]);
                objFile.WriteElement2Value("DefectColorInspectionTotalArea", m_arrDefectColorInspectionTotalArea[v]);
            }


            objFile.WriteEndElement();

        }
        public void SavePackage(string strPath, bool blnNewFile, string strSectionName, bool blnNewSection, float fCalibPixelPerMMX, float fCalibPixelPerMMY)
        {
            XmlParser objFile = new XmlParser(strPath, blnNewFile);

            objFile.WriteSectionElement(strSectionName, blnNewSection);

            // Min area
            objFile.WriteElement1Value("MarkViewMinArea", m_intMarkViewMinArea);
            objFile.WriteElement1Value("PkgViewMinArea", m_intPkgViewMinArea);
            objFile.WriteElement1Value("CrackViewMinArea", m_intCrackViewMinArea);
            objFile.WriteElement1Value("ChipView1MinArea", m_intChipView1MinArea);
            objFile.WriteElement1Value("ChipView2MinArea", m_intChipView2MinArea);
            objFile.WriteElement1Value("VoidViewMinArea", m_intVoidViewMinArea);
            objFile.WriteElement1Value("MoldFlashMinArea", m_intMoldFlashMinArea);
            objFile.WriteElement1Value("BrightFieldMinArea", m_intBrightFieldMinArea);
            objFile.WriteElement1Value("DarkFieldMinArea", m_intDarkFieldMinArea);
            objFile.WriteElement1Value("DarkField2MinArea", m_intDarkField2MinArea);
            objFile.WriteElement1Value("DarkField3MinArea", m_intDarkField3MinArea);
            objFile.WriteElement1Value("DarkField4MinArea", m_intDarkField4MinArea);
            // Threshold
            objFile.WriteElement1Value("PackageViewThreshold", m_intPkgViewThreshold);
            objFile.WriteElement1Value("MarkViewHighThreshold", m_intMarkViewHighThreshold);
            objFile.WriteElement1Value("MarkViewLowThreshold", m_intMarkViewLowThreshold);
            objFile.WriteElement1Value("CrackViewThreshold", m_intCrackViewThreshold);
            objFile.WriteElement1Value("ChipView1Threshold", m_intChipView1Threshold);
            objFile.WriteElement1Value("ChipView2Threshold", m_intChipView2Threshold);
            objFile.WriteElement1Value("VoidViewThreshold", m_intVoidViewThreshold);
            objFile.WriteElement1Value("MoldFlashThreshold", m_intMoldFlashThreshold);
            objFile.WriteElement1Value("CrackViewLowThreshold", m_intCrackViewLowThreshold);
            objFile.WriteElement1Value("CrackViewHighThreshold", m_intCrackViewHighThreshold);
            objFile.WriteElement1Value("BrightFieldLowThreshold", m_intBrightFieldLowThreshold);
            objFile.WriteElement1Value("BrightFieldHighThreshold", m_intBrightFieldHighThreshold);
            objFile.WriteElement1Value("DarkFieldLowThreshold", m_intDarkFieldLowThreshold);
            objFile.WriteElement1Value("DarkFieldHighThreshold", m_intDarkFieldHighThreshold);
            objFile.WriteElement1Value("DarkField2LowThreshold", m_intDarkField2LowThreshold);
            objFile.WriteElement1Value("DarkField2HighThreshold", m_intDarkField2HighThreshold);
            objFile.WriteElement1Value("DarkField3LowThreshold", m_intDarkField3LowThreshold);
            objFile.WriteElement1Value("DarkField3HighThreshold", m_intDarkField3HighThreshold);
            objFile.WriteElement1Value("DarkField4LowThreshold", m_intDarkField4LowThreshold);
            objFile.WriteElement1Value("DarkField4HighThreshold", m_intDarkField4HighThreshold);

            // Template Unit size tolerance
            objFile.WriteElement1Value("UnitWidthMin", m_fUnitWidthMin);
            objFile.WriteElement1Value("UnitWidthMax", m_fUnitWidthMax);
            objFile.WriteElement1Value("UnitHeightMin", m_fUnitHeightMin);
            objFile.WriteElement1Value("UnitHeightMax", m_fUnitHeightMax);
            objFile.WriteElement1Value("UnitAngleMax", m_fUnitAngleMax);

            //Unit Sitting Tolerance
            objFile.WriteElement1Value("SittingWidthMin", m_fSittingWidthMin);
            objFile.WriteElement1Value("SittingWidthMax", m_fSittingWidthMax);
            objFile.WriteElement1Value("SittingHeightMin", m_fSittingHeightMin);
            objFile.WriteElement1Value("SittingHeightMax", m_fSittingHeightMax);
            
            // Setting
            objFile.WriteElement1Value("PixelFromEdge", (float)m_intStartPixelFromEdge, "Package ROI Setting", true); //04-03-2019 ZJYeoh : remove conversion(/ fCalibPixelPerMM) to avoid rounding problem 
            objFile.WriteElement1Value("PixelFromRight", (float)m_intStartPixelFromRight, "Package ROI Setting", true);
            objFile.WriteElement1Value("PixelFromBottom", (float)m_intStartPixelFromBottom, "Package ROI Setting", true);
            objFile.WriteElement1Value("PixelFromLeft", (float)m_intStartPixelFromLeft, "Package ROI Setting", true);
            objFile.WriteElement1Value("PixelFromEdge_DarkField2", (float)m_intStartPixelFromEdge_DarkField2, "Dark Field 2 ROI Setting", true); 
            objFile.WriteElement1Value("PixelFromRight_DarkField2", (float)m_intStartPixelFromRight_DarkField2, "Dark Field 2 ROI Setting", true);
            objFile.WriteElement1Value("PixelFromBottom_DarkField2", (float)m_intStartPixelFromBottom_DarkField2, "Dark Field 2 ROI Setting", true);
            objFile.WriteElement1Value("PixelFromLeft_DarkField2", (float)m_intStartPixelFromLeft_DarkField2, "Dark Field 2 ROI Setting", true);
            objFile.WriteElement1Value("PixelFromEdge_DarkField3", (float)m_intStartPixelFromEdge_DarkField3, "Dark Field 3 ROI Setting", true);
            objFile.WriteElement1Value("PixelFromRight_DarkField3", (float)m_intStartPixelFromRight_DarkField3, "Dark Field 3 ROI Setting", true);
            objFile.WriteElement1Value("PixelFromBottom_DarkField3", (float)m_intStartPixelFromBottom_DarkField3, "Dark Field 3 ROI Setting", true);
            objFile.WriteElement1Value("PixelFromLeft_DarkField3", (float)m_intStartPixelFromLeft_DarkField3, "Dark Field 3 ROI Setting", true);
            objFile.WriteElement1Value("PixelFromEdge_DarkField4", (float)m_intStartPixelFromEdge_DarkField4, "Dark Field 4 ROI Setting", true);
            objFile.WriteElement1Value("PixelFromRight_DarkField4", (float)m_intStartPixelFromRight_DarkField4, "Dark Field 4 ROI Setting", true);
            objFile.WriteElement1Value("PixelFromBottom_DarkField4", (float)m_intStartPixelFromBottom_DarkField4, "Dark Field 4 ROI Setting", true);
            objFile.WriteElement1Value("PixelFromLeft_DarkField4", (float)m_intStartPixelFromLeft_DarkField4, "Dark Field 4 ROI Setting", true);
            objFile.WriteElement1Value("PixelFromEdge_Mold", (float)m_intStartPixelFromEdge_Mold, "Mold Flash Outer ROI Setting", true);
            objFile.WriteElement1Value("PixelFromRight_Mold", (float)m_intStartPixelFromRight_Mold, "Mold Flash Outer ROI Setting", true);
            objFile.WriteElement1Value("PixelFromBottom_Mold", (float)m_intStartPixelFromBottom_Mold, "Mold Flash Outer ROI Setting", true);
            objFile.WriteElement1Value("PixelFromLeft_Mold", (float)m_intStartPixelFromLeft_Mold, "Mold Flash Outer ROI Setting", true);
            objFile.WriteElement1Value("PixelFromEdgeInner_Mold", (float)m_intStartPixelFromEdgeInner_Mold, "Mold Flash Inner ROI Setting", true);
            objFile.WriteElement1Value("PixelFromRightInner_Mold", (float)m_intStartPixelFromRightInner_Mold, "Mold Flash Inner ROI Setting", true);
            objFile.WriteElement1Value("PixelFromBottomInner_Mold", (float)m_intStartPixelFromBottomInner_Mold, "Mold Flash Inner ROI Setting", true);
            objFile.WriteElement1Value("PixelFromLeftInner_Mold", (float)m_intStartPixelFromLeftInner_Mold, "Mold Flash Inner ROI Setting", true);
            objFile.WriteElement1Value("PixelFromEdge_Chip", (float)m_intStartPixelFromEdge_Chip, "Bright Chipped Inward ROI Setting", true);
            objFile.WriteElement1Value("PixelFromRight_Chip", (float)m_intStartPixelFromRight_Chip, "Bright Chipped Inward ROI Setting", true);
            objFile.WriteElement1Value("PixelFromBottom_Chip", (float)m_intStartPixelFromBottom_Chip, "Bright Chipped Inward ROI Setting", true);
            objFile.WriteElement1Value("PixelFromLeft_Chip", (float)m_intStartPixelFromLeft_Chip, "Bright Chipped Inward ROI Setting", true);
            objFile.WriteElement1Value("PixelExtendFromEdge_Chip", (float)m_intStartPixelExtendFromEdge_Chip, "Bright Chipped Outward ROI Setting", true);
            objFile.WriteElement1Value("PixelExtendFromRight_Chip", (float)m_intStartPixelExtendFromRight_Chip, "Bright Chipped Outward ROI Setting", true);
            objFile.WriteElement1Value("PixelExtendFromBottom_Chip", (float)m_intStartPixelExtendFromBottom_Chip, "Bright Chipped Outward ROI Setting", true);
            objFile.WriteElement1Value("PixelExtendFromLeft_Chip", (float)m_intStartPixelExtendFromLeft_Chip, "Bright Chipped Outward ROI Setting", true);
            objFile.WriteElement1Value("PixelFromEdge_Dark", (float)m_intStartPixelFromEdge_Dark, "Dark Field ROI Setting", true); //04-03-2019 ZJYeoh : remove conversion(/ fCalibPixelPerMM) to avoid rounding problem 
            objFile.WriteElement1Value("PixelFromRight_Dark", (float)m_intStartPixelFromRight_Dark, "Dark Field ROI Setting", true);
            objFile.WriteElement1Value("PixelFromBottom_Dark", (float)m_intStartPixelFromBottom_Dark, "Dark Field ROI Setting", true);
            objFile.WriteElement1Value("PixelFromLeft_Dark", (float)m_intStartPixelFromLeft_Dark, "Dark Field ROI Setting", true);
            objFile.WriteElement1Value("PixelFromEdge_Chip_Dark", (float)m_intStartPixelFromEdge_Chip_Dark, "Dark Chipped Inward ROI Setting", true);
            objFile.WriteElement1Value("PixelFromRight_Chip_Dark", (float)m_intStartPixelFromRight_Chip_Dark, "Dark Chipped Inward ROI Setting", true);
            objFile.WriteElement1Value("PixelFromBottom_Chip_Dark", (float)m_intStartPixelFromBottom_Chip_Dark, "Dark Chipped Inward ROI Setting", true);
            objFile.WriteElement1Value("PixelFromLeft_Chip_Dark", (float)m_intStartPixelFromLeft_Chip_Dark, "Dark Chipped Inward ROI Setting", true);
            objFile.WriteElement1Value("PixelExtendFromEdge_Chip_Dark", (float)m_intStartPixelExtendFromEdge_Chip_Dark, "Dark Chipped Outward ROI Setting", true);
            objFile.WriteElement1Value("PixelExtendFromRight_Chip_Dark", (float)m_intStartPixelExtendFromRight_Chip_Dark, "Dark Chipped Outward ROI Setting", true);
            objFile.WriteElement1Value("PixelExtendFromBottom_Chip_Dark", (float)m_intStartPixelExtendFromBottom_Chip_Dark, "Dark Chipped Outward ROI Setting", true);
            objFile.WriteElement1Value("PixelExtendFromLeft_Chip_Dark", (float)m_intStartPixelExtendFromLeft_Chip_Dark, "Dark Chipped Outward ROI Setting", true);
            objFile.WriteElement1Value("UnitSizeTolerance", m_fUnitSizeTolerance);
            objFile.WriteElement1Value("FailMask", m_intPkgFailMask);
            objFile.WriteElement1Value("UseOtherGaugeMeasurePackage", m_intUseOtherGaugeMeasurePackage);
            objFile.WriteElement1Value("SeperateBrightDarkROITolerance", m_blnSeperateBrightDarkROITolerance);
            objFile.WriteElement1Value("SeperateDarkField2DefectSetting", m_blnSeperateDarkField2DefectSetting);
            objFile.WriteElement1Value("SeperateDarkField3DefectSetting", m_blnSeperateDarkField3DefectSetting);
            objFile.WriteElement1Value("SeperateDarkField4DefectSetting", m_blnSeperateDarkField4DefectSetting);
            objFile.WriteElement1Value("SeperateCrackDefectSetting", m_blnSeperateCrackDefectSetting);
            objFile.WriteElement1Value("WantLinkBrightDefect", m_blnWantLinkBrightDefect);
            objFile.WriteElement1Value("WantLinkDarkDefect", m_blnWantLinkDarkDefect);
            objFile.WriteElement1Value("WantLinkDark2Defect", m_blnWantLinkDark2Defect);
            objFile.WriteElement1Value("WantLinkDark3Defect", m_blnWantLinkDark3Defect);
            objFile.WriteElement1Value("WantLinkDark4Defect", m_blnWantLinkDark4Defect);
            objFile.WriteElement1Value("WantLinkCrackDefect", m_blnWantLinkCrackDefect);
            objFile.WriteElement1Value("WantLinkMoldFlashDefect", m_blnWantLinkMoldFlashDefect); 
            objFile.WriteElement1Value("BrightDefectLinkTolerance", m_intBrightDefectLinkTolerance);
            objFile.WriteElement1Value("DarkDefectLinkTolerance", m_intDarkDefectLinkTolerance);
            objFile.WriteElement1Value("Dark2DefectLinkTolerance", m_intDark2DefectLinkTolerance);
            objFile.WriteElement1Value("Dark3DefectLinkTolerance", m_intDark3DefectLinkTolerance);
            objFile.WriteElement1Value("Dark4DefectLinkTolerance", m_intDark4DefectLinkTolerance);
            objFile.WriteElement1Value("CrackDefectLinkTolerance", m_intCrackDefectLinkTolerance);
            objFile.WriteElement1Value("MoldFlashDefectLinkTolerance", m_intMoldFlashDefectLinkTolerance); 
            objFile.WriteElement1Value("SeperateChippedOffDefectSetting", m_blnSeperateChippedOffDefectSetting);
            objFile.WriteElement1Value("ChippedOffDefectInspectionMethod", m_intChippedOffDefectInspectionMethod);
            objFile.WriteElement1Value("SeperateVoidDefectSetting", m_blnSeperateVoidDefectSetting);
            objFile.WriteElement1Value("SeperateMoldFlashDefectSetting", m_blnSeperateMoldFlashDefectSetting);

            objFile.WriteElement1Value("BrightDefectDimensionFailCondition", m_intBrightDefectDimensionFailCondition);
            objFile.WriteElement1Value("DarkDefectDimensionFailCondition", m_intDarkDefectDimensionFailCondition);
            objFile.WriteElement1Value("Dark2DefectDimensionFailCondition", m_intDark2DefectDimensionFailCondition);
            objFile.WriteElement1Value("Dark3DefectDimensionFailCondition", m_intDark3DefectDimensionFailCondition);
            objFile.WriteElement1Value("Dark4DefectDimensionFailCondition", m_intDark4DefectDimensionFailCondition);
            objFile.WriteElement1Value("CrackDarkDefectDimensionFailCondition", m_intCrackDarkDefectDimensionFailCondition);
            objFile.WriteElement1Value("ChippedBrightDefectDimensionFailCondition", m_intChippedBrightDefectDimensionFailCondition);
            objFile.WriteElement1Value("ChippedDarkDefectDimensionFailCondition", m_intChippedDarkDefectDimensionFailCondition);

            //PackageSize Offset
            objFile.WriteElement1Value("WidthOffsetMM", m_fWidthOffsetMM);
            objFile.WriteElement1Value("HeightOffsetMM", m_fHeightOffsetMM);

            // Unit Surface Offset
            objFile.WriteElement1Value("UnitSurfaceOffsetX", m_fUnitSurfaceOffsetX);
            objFile.WriteElement1Value("UnitSurfaceOffsetY", m_fUnitSurfaceOffsetY);

            // Defect Horizontal Tolerance
            for (int i = 0; i < m_arrDefectHorizontal.Length; i++)
                objFile.WriteElement1Value("DefectHorizontalValue" + i.ToString(), m_arrDefectHorizontal[i] / fCalibPixelPerMMX);

            // Defect Vertical Tolerance
            for (int i = 0; i < m_arrDefectVertical.Length; i++)
                objFile.WriteElement1Value("DefectVerticalValue" + i.ToString(), m_arrDefectVertical[i] / fCalibPixelPerMMY);

            // Defect Area Toelerance
            for (int i = 0; i < m_arrDefectArea.Length; i++)
                objFile.WriteElement1Value("DefectAreaValue" + i.ToString(), m_arrDefectArea[i] / (fCalibPixelPerMMX * fCalibPixelPerMMY));

            // Defect Total Area Toelerance
            for (int i = 0; i < m_arrDefectTotalArea.Length; i++)
                objFile.WriteElement1Value("DefectTotalAreaValue" + i.ToString(), m_arrDefectTotalArea[i] / (fCalibPixelPerMMX * fCalibPixelPerMMY));

            // Want Defect Length
            for (int i = 0; i < m_arrWantDefectLength.Length; i++)
                objFile.WriteElement1Value("WantDefectLength" + i.ToString(), m_arrWantDefectLength[i]);

            // Want Defect Length
            for (int i = 0; i < m_arrWantDefectArea.Length; i++)
                objFile.WriteElement1Value("WantDefectArea" + i.ToString(), m_arrWantDefectArea[i]);

            // Want Inspect Package
            objFile.WriteElement1Value("WantInspectPackage", m_blnInspectPackage);

            // Grab image index
            objFile.WriteElement1Value("GrabImageIndexCount", m_arrGrabImageIndex.Count);
            for (int j = 0; j < m_arrGrabImageIndex.Count; j++)
                objFile.WriteElement1Value("GrabImageIndex" + j.ToString(), m_arrGrabImageIndex[j]);


            objFile.WriteElement1Value("ColorPackageSetting", "");
            objFile.WriteElement2Value("ColorDefectLinkMethod", m_intColorDefectLinkMethod);
            objFile.WriteElement2Value("ColorDefectLinkTolerance", m_intColorDefectLinkTolerance);
            objFile.WriteElement2Value("FailColorMask", m_intFailColorOptionMask);
            objFile.WriteElement2Value("ColorDefectCount", m_arrDefectColorThresName.Count);
            for (int v = 0; v < m_arrDefectColorThresName.Count; v++)
            {
                objFile.WriteElement1Value("ColorDefect" + v, "");
                objFile.WriteElement2Value("DefectColorThresName", m_arrDefectColorThresName[v]);
                objFile.WriteElement2Value("DefectColorSystem", m_arrDefectColorSystem[v]);
                objFile.WriteElement2Value("DefectCloseIteration", m_arrDefectCloseIteration[v]);
                objFile.WriteElement2Value("DefectInvertBlackWhite", m_arrDefectInvertBlackWhite[v]);
                objFile.WriteElement2Value("DefectColor0", m_arrDefectColor[v][0]);
                objFile.WriteElement2Value("DefectColor1", m_arrDefectColor[v][1]);
                objFile.WriteElement2Value("DefectColor2", m_arrDefectColor[v][2]);
                objFile.WriteElement2Value("DefectColorTolerance0", m_arrDefectColorTolerance[v][0]);
                objFile.WriteElement2Value("DefectColorTolerance1", m_arrDefectColorTolerance[v][1]);
                objFile.WriteElement2Value("DefectColorTolerance2", m_arrDefectColorTolerance[v][2]);
                objFile.WriteElement2Value("DefectColorMinArea", m_arrDefectColorMinArea[v]);
                objFile.WriteElement2Value("DefectType", m_arrDefectType[v]);
                objFile.WriteElement2Value("DefectImageNo", m_arrDefectImageNo[v]);
                objFile.WriteElement2Value("DefectDontCareMode", m_arrDefectDontCareMode[v]);
                objFile.WriteElement2Value("DefectColorInspection_Top", m_arrDefectColorInspection_Top[v]);
                objFile.WriteElement2Value("DefectColorInspection_Right", m_arrDefectColorInspection_Right[v]);
                objFile.WriteElement2Value("DefectColorInspection_Bottom", m_arrDefectColorInspection_Bottom[v]);
                objFile.WriteElement2Value("DefectColorInspection_Left", m_arrDefectColorInspection_Left[v]);
                objFile.WriteElement2Value("DefectColorInspectionFailCondition", m_arrDefectColorInspectionFailCondition[v]);
                objFile.WriteElement2Value("DefectColorInspectionWidth", m_arrDefectColorInspectionWidth[v]);
                objFile.WriteElement2Value("DefectColorInspectionLength", m_arrDefectColorInspectionLength[v]);
                objFile.WriteElement2Value("DefectColorInspectionMinArea", m_arrDefectColorInspectionMinArea[v]);
                objFile.WriteElement2Value("DefectColorInspectionMaxArea", m_arrDefectColorInspectionMaxArea[v]);
                objFile.WriteElement2Value("DefectColorInspectionTotalArea", m_arrDefectColorInspectionTotalArea[v]);
            }


            objFile.WriteEndElement();
        }

        public void SavePackage_SECSGEM(string strPath, string strSectionName, string strVisionName, float fCalibPixelPerMMX, float fCalibPixelPerMMY)
        {
            XmlParser objFile = new XmlParser(strPath, "SECSGEMData");
            objFile.WriteRootElement("SECSGEMData");

            // Min area
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_MarkViewMinArea", m_intMarkViewMinArea);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_PkgViewMinArea", m_intPkgViewMinArea);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_CrackViewMinArea", m_intCrackViewMinArea);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_ChipView1MinArea", m_intChipView1MinArea);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_ChipView2MinArea", m_intChipView2MinArea);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_VoidViewMinArea", m_intVoidViewMinArea);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_MoldFlashMinArea", m_intMoldFlashMinArea);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_BrightFieldMinArea", m_intBrightFieldMinArea);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_DarkFieldMinArea", m_intDarkFieldMinArea);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_DarkField2MinArea", m_intDarkField2MinArea);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_DarkField3MinArea", m_intDarkField3MinArea);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_DarkField4MinArea", m_intDarkField4MinArea);
            // Threshold
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_PackageViewThreshold", m_intPkgViewThreshold);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_MarkViewHighThreshold", m_intMarkViewHighThreshold);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_MarkViewLowThreshold", m_intMarkViewLowThreshold);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_CrackViewThreshold", m_intCrackViewThreshold);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_ChipView1Threshold", m_intChipView1Threshold);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_ChipView2Threshold", m_intChipView2Threshold);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_VoidViewThreshold", m_intVoidViewThreshold);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_MoldFlashThreshold", m_intMoldFlashThreshold);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_CrackViewLowThreshold", m_intCrackViewLowThreshold);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_CrackViewHighThreshold", m_intCrackViewHighThreshold);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_BrightFieldLowThreshold", m_intBrightFieldLowThreshold);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_BrightFieldHighThreshold", m_intBrightFieldHighThreshold);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_DarkFieldLowThreshold", m_intDarkFieldLowThreshold);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_DarkFieldHighThreshold", m_intDarkFieldHighThreshold);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_DarkField2LowThreshold", m_intDarkField2LowThreshold);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_DarkField2HighThreshold", m_intDarkField2HighThreshold);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_DarkField3LowThreshold", m_intDarkField3LowThreshold);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_DarkField3HighThreshold", m_intDarkField3HighThreshold);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_DarkField4LowThreshold", m_intDarkField4LowThreshold);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_DarkField4HighThreshold", m_intDarkField4HighThreshold);

            // Template Unit size tolerance
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_UnitWidthMin", m_fUnitWidthMin);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_UnitWidthMax", m_fUnitWidthMax);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_UnitHeightMin", m_fUnitHeightMin);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_UnitHeightMax", m_fUnitHeightMax);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_UnitAngleMax", m_fUnitAngleMax);

            //Unit Sitting Tolerance
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_SittingWidthMin", m_fSittingWidthMin);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_SittingWidthMax", m_fSittingWidthMax);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_SittingHeightMin", m_fSittingHeightMin);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_SittingHeightMax", m_fSittingHeightMax);
            
            // Setting
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_PixelFromEdge", (float)m_intStartPixelFromEdge); //04-03-2019 ZJYeoh : remove conversion(/ fCalibPixelPerMM) to avoid rounding problem 
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_PixelFromRight", (float)m_intStartPixelFromRight);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_PixelFromBottom", (float)m_intStartPixelFromBottom);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_PixelFromLeft", (float)m_intStartPixelFromLeft);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_PixelFromEdge_DarkField2", (float)m_intStartPixelFromEdge_DarkField2); 
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_PixelFromRight_DarkField2", (float)m_intStartPixelFromRight_DarkField2);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_PixelFromBottom_DarkField2", (float)m_intStartPixelFromBottom_DarkField2);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_PixelFromLeft_DarkField2", (float)m_intStartPixelFromLeft_DarkField2);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_PixelFromEdge_DarkField3", (float)m_intStartPixelFromEdge_DarkField3);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_PixelFromRight_DarkField3", (float)m_intStartPixelFromRight_DarkField3);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_PixelFromBottom_DarkField3", (float)m_intStartPixelFromBottom_DarkField3);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_PixelFromLeft_DarkField3", (float)m_intStartPixelFromLeft_DarkField3);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_PixelFromEdge_DarkField4", (float)m_intStartPixelFromEdge_DarkField4);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_PixelFromRight_DarkField4", (float)m_intStartPixelFromRight_DarkField4);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_PixelFromBottom_DarkField4", (float)m_intStartPixelFromBottom_DarkField4);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_PixelFromLeft_DarkField4", (float)m_intStartPixelFromLeft_DarkField4);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_PixelFromEdge_Mold", (float)m_intStartPixelFromEdge_Mold);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_PixelFromRight_Mold", (float)m_intStartPixelFromRight_Mold);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_PixelFromBottom_Mold", (float)m_intStartPixelFromBottom_Mold);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_PixelFromLeft_Mold", (float)m_intStartPixelFromLeft_Mold);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_PixelFromEdgeInner_Mold", (float)m_intStartPixelFromEdgeInner_Mold);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_PixelFromRightInner_Mold", (float)m_intStartPixelFromRightInner_Mold);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_PixelFromBottomInner_Mold", (float)m_intStartPixelFromBottomInner_Mold);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_PixelFromLeftInner_Mold", (float)m_intStartPixelFromLeftInner_Mold);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_PixelFromEdge_Chip", (float)m_intStartPixelFromEdge_Chip);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_PixelFromRight_Chip", (float)m_intStartPixelFromRight_Chip);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_PixelFromBottom_Chip", (float)m_intStartPixelFromBottom_Chip);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_PixelFromLeft_Chip", (float)m_intStartPixelFromLeft_Chip);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_PixelExtendFromEdge_Chip", (float)m_intStartPixelExtendFromEdge_Chip);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_PixelExtendFromRight_Chip", (float)m_intStartPixelExtendFromRight_Chip);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_PixelExtendFromBottom_Chip", (float)m_intStartPixelExtendFromBottom_Chip);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_PixelExtendFromLeft_Chip", (float)m_intStartPixelExtendFromLeft_Chip);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_PixelFromEdge_Dark", (float)m_intStartPixelFromEdge_Dark); //04-03-2019 ZJYeoh : remove conversion(/ fCalibPixelPerMM) to avoid rounding problem 
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_PixelFromRight_Dark", (float)m_intStartPixelFromRight_Dark);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_PixelFromBottom_Dark", (float)m_intStartPixelFromBottom_Dark);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_PixelFromLeft_Dark", (float)m_intStartPixelFromLeft_Dark);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_PixelFromEdge_Chip_Dark", (float)m_intStartPixelFromEdge_Chip_Dark);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_PixelFromRight_Chip_Dark", (float)m_intStartPixelFromRight_Chip_Dark);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_PixelFromBottom_Chip_Dark", (float)m_intStartPixelFromBottom_Chip_Dark);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_PixelFromLeft_Chip_Dark", (float)m_intStartPixelFromLeft_Chip_Dark);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_PixelExtendFromEdge_Chip_Dark", (float)m_intStartPixelExtendFromEdge_Chip_Dark);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_PixelExtendFromRight_Chip_Dark", (float)m_intStartPixelExtendFromRight_Chip_Dark);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_PixelExtendFromBottom_Chip_Dark", (float)m_intStartPixelExtendFromBottom_Chip_Dark);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_PixelExtendFromLeft_Chip_Dark", (float)m_intStartPixelExtendFromLeft_Chip_Dark);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_UnitSizeTolerance", m_fUnitSizeTolerance);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_FailMask", m_intPkgFailMask);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_UseOtherGaugeMeasurePackage", m_intUseOtherGaugeMeasurePackage);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_SeperateBrightDarkROITolerance", m_blnSeperateBrightDarkROITolerance);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_SeperateDarkField2DefectSetting", m_blnSeperateDarkField2DefectSetting);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_SeperateDarkField3DefectSetting", m_blnSeperateDarkField3DefectSetting);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_SeperateDarkField4DefectSetting", m_blnSeperateDarkField4DefectSetting);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_SeperateCrackDefectSetting", m_blnSeperateCrackDefectSetting);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_WantLinkBrightDefect", m_blnWantLinkBrightDefect);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_WantLinkDarkDefect", m_blnWantLinkDarkDefect);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_WantLinkDark2Defect", m_blnWantLinkDark2Defect);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_WantLinkDark2Defect", m_blnWantLinkDark3Defect);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_WantLinkDark2Defect", m_blnWantLinkDark4Defect);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_WantLinkCrackDefect", m_blnWantLinkCrackDefect);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_WantLinkMoldFlashDefect", m_blnWantLinkMoldFlashDefect); 
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_BrightDefectLinkTolerance", m_intBrightDefectLinkTolerance);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_DarkDefectLinkTolerance", m_intDarkDefectLinkTolerance);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_Dark2DefectLinkTolerance", m_intDark2DefectLinkTolerance);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_Dark3DefectLinkTolerance", m_intDark3DefectLinkTolerance);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_Dark4DefectLinkTolerance", m_intDark4DefectLinkTolerance);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_CrackDefectLinkTolerance", m_intCrackDefectLinkTolerance);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_MoldFlashDefectLinkTolerance", m_intMoldFlashDefectLinkTolerance); 
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_SeperateChippedOffDefectSetting", m_blnSeperateChippedOffDefectSetting);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_ChippedOffDefectInspectionMethod", m_intChippedOffDefectInspectionMethod);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_SeperateVoidDefectSetting", m_blnSeperateVoidDefectSetting);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_SeperateMoldFlashDefectSetting", m_blnSeperateMoldFlashDefectSetting);

            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_BrightDefectDimensionFailCondition", m_intBrightDefectDimensionFailCondition);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_DarkDefectDimensionFailCondition", m_intDarkDefectDimensionFailCondition);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_Dark2DefectDimensionFailCondition", m_intDark2DefectDimensionFailCondition);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_Dark3DefectDimensionFailCondition", m_intDark3DefectDimensionFailCondition);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_Dark4DefectDimensionFailCondition", m_intDark4DefectDimensionFailCondition);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_CrackDarkDefectDimensionFailCondition", m_intCrackDarkDefectDimensionFailCondition);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_ChippedBrightDefectDimensionFailCondition", m_intChippedBrightDefectDimensionFailCondition);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_ChippedDarkDefectDimensionFailCondition", m_intChippedDarkDefectDimensionFailCondition);

            // Unit Surface Offset
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_UnitSurfaceOffsetX", m_fUnitSurfaceOffsetX);
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_UnitSurfaceOffsetY", m_fUnitSurfaceOffsetY);

            // Defect Horizontal Tolerance
            for (int i = 0; i < m_arrDefectHorizontal.Length; i++)
                objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_DefectHorizontalValue" + i.ToString(), m_arrDefectHorizontal[i] / fCalibPixelPerMMX);

            // Defect Vertical Tolerance
            for (int i = 0; i < m_arrDefectVertical.Length; i++)
                objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_DefectVerticalValue" + i.ToString(), m_arrDefectVertical[i] / fCalibPixelPerMMY);

            // Defect Area Toelerance
            for (int i = 0; i < m_arrDefectArea.Length; i++)
                objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_DefectAreaValue" + i.ToString(), m_arrDefectArea[i] / (fCalibPixelPerMMX * fCalibPixelPerMMY));

            // Defect Total Area Toelerance
            for (int i = 0; i < m_arrDefectTotalArea.Length; i++)
                objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_DefectTotalAreaValue" + i.ToString(), m_arrDefectTotalArea[i] / (fCalibPixelPerMMX * fCalibPixelPerMMY));

            // Want Defect Length
            for (int i = 0; i < m_arrWantDefectLength.Length; i++)
                objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_WantDefectLength" + i.ToString(), m_arrWantDefectLength[i]);

            // Want Defect Length
            for (int i = 0; i < m_arrWantDefectArea.Length; i++)
                objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_WantDefectArea" + i.ToString(), m_arrWantDefectArea[i]);

            // Want Inspect Package
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_WantInspectPackage", m_blnInspectPackage);

            // Grab image index
            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_GrabImageIndexCount", m_arrGrabImageIndex.Count);

            for (int j = 0; j < 6; j++)
            {
                if (m_arrGrabImageIndex.Count > j)
                    objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_GrabImageIndex" + j.ToString(), m_arrGrabImageIndex[j]);
                else
                    objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_GrabImageIndex" + j.ToString(), "NA");
            }

            objFile.WriteEndElement();
        }

        public void ResetPackageInspectionData()
        {
            m_blnDrawPkgGaugeResult = false;
            m_blnPkgSizeInspectionDone = false;
            m_blnPkgDefectInspectionDone = false;
            m_strErrorMessage = "";
            m_arrDefectList.Clear();
            m_arrMarkDefectList.Clear();
            m_arrPackageDefectList.Clear();
            m_arrColorDefectList.Clear();
            m_blnViewUnitPosition = false;
            m_blnPkgViewFailTotalArea = false;
            m_blnCrackChipViewFailTotalArea = false;
            m_blnMarkViewFailTotalArea = false;
            m_fPackageResultCenterX = 0;
            m_fPackageResultCenterY = 0;
            m_fPackageResultWidth_px = 0;
            m_fPackageResultHeight_px = 0;
            m_intPkgFailResultMask = 0;
            m_intFailColorResultMask = 0;
        }

        public void Dispose()
        {
            if (m_BrushMatched != null)
                m_BrushMatched.Dispose();

            if (m_objPackageEBlobs != null)
                m_objPackageEBlobs.Dispose();

            if (m_objMarkViewEBlobs != null)
                m_objMarkViewEBlobs.Dispose();

            if (m_objEBlobs != null)
                m_objEBlobs.Dispose();

            if (m_objImage1MoldFlashBlobs != null)
                m_objImage1MoldFlashBlobs.Dispose();

            if (m_objChippedOffImage != null)
                m_objChippedOffImage.Dispose();

            if (m_objVoidViewImage != null)
                m_objVoidViewImage.Dispose();

            for (int i = 0; i < m_arrSideROI.Count; i++)
            {
                if (m_arrSideROI[i] != null)
                    m_arrSideROI[i].Dispose();
            }

            for (int i = 0; i < m_arrMarkMaskROI.Count; i++)
            {
                for (int j = 0; j < m_arrMarkMaskROI[i].Count; j++)
                {
                    for (int k = 0; k < m_arrMarkMaskROI[i][j].Count; k++)
                    {
                        if (m_arrMarkMaskROI[i][j][k] != null)
                            m_arrMarkMaskROI[i][j][k].Dispose();
                    }
                }
            }
        }

        private bool InspectMoldFlash(ROI objMoldFlashROI)
        {
            if ((m_intPkgFailMask & 0x08) == 0)
                return true;

            int intSelectedImageIndex = m_arrGrabImageIndex[5];
            bool blnDebugImage = false;
            bool blnOverAllFail = false;
            int intTotalStartX = 0, intTotalStartY = 0;
            ROI objMoldFlashBorderROI = new ROI();
            objMoldFlashBorderROI.AttachImage(objMoldFlashROI);

            for (int i = 0; i < 4; i++)   // Create 4 direction ROI
            {


                //switch (i)
                //{
                //    case 0:  // Top Border
                //        objMoldFlashBorderROI.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth, m_intStartPixelFromEdge_Mold);
                //        intTotalStartX = objMoldFlashROI.ref_ROITotalX;
                //        intTotalStartY = objMoldFlashROI.ref_ROITotalY;

                //        break;
                //    case 1: // Right Border
                //        objMoldFlashBorderROI.LoadROISetting(objMoldFlashROI.ref_ROIWidth - m_intStartPixelFromRight_Mold, 0, m_intStartPixelFromRight_Mold, objMoldFlashROI.ref_ROIHeight);
                //        intTotalStartX = objMoldFlashROI.ref_ROITotalX + objMoldFlashROI.ref_ROIWidth - m_intStartPixelFromRight_Mold;
                //        intTotalStartY = objMoldFlashROI.ref_ROITotalY;

                //        break;
                //    case 2: // Bottom Border
                //        objMoldFlashBorderROI.LoadROISetting(0, objMoldFlashROI.ref_ROIHeight - m_intStartPixelFromBottom_Mold, objMoldFlashROI.ref_ROIWidth, m_intStartPixelFromBottom_Mold);
                //        intTotalStartX = objMoldFlashROI.ref_ROITotalX;
                //        intTotalStartY = objMoldFlashROI.ref_ROITotalY + objMoldFlashROI.ref_ROIHeight - m_intStartPixelFromBottom_Mold;


                //        break;
                //    case 3: // Left Border
                //        objMoldFlashBorderROI.LoadROISetting(0, 0, m_intStartPixelFromLeft_Mold, objMoldFlashROI.ref_ROIHeight);
                //        intTotalStartX = objMoldFlashROI.ref_ROITotalX;
                //        intTotalStartY = objMoldFlashROI.ref_ROITotalY;

                //        break;
                //}
                switch (i)
                {
                    case 0:  // Top Border
                        objMoldFlashBorderROI.LoadROISetting(m_intStartPixelFromLeft_Mold, 0, objMoldFlashROI.ref_ROIWidth - m_intStartPixelFromLeft_Mold - m_intStartPixelFromRight_Mold, m_intStartPixelFromEdge_Mold - m_intStartPixelFromEdgeInner_Mold);//m_intStartPixelFromEdge_Mold
                        intTotalStartX = objMoldFlashROI.ref_ROITotalX + m_intStartPixelFromLeft_Mold;
                        intTotalStartY = objMoldFlashROI.ref_ROITotalY;

                        break;
                    case 1: // Right Border
                        objMoldFlashBorderROI.LoadROISetting(objMoldFlashROI.ref_ROIWidth - (m_intStartPixelFromRight_Mold - m_intStartPixelFromRightInner_Mold), m_intStartPixelFromEdge_Mold, m_intStartPixelFromRight_Mold - m_intStartPixelFromRightInner_Mold, objMoldFlashROI.ref_ROIHeight - m_intStartPixelFromEdge_Mold - m_intStartPixelFromBottom_Mold);
                        intTotalStartX = objMoldFlashROI.ref_ROITotalX + objMoldFlashROI.ref_ROIWidth - (m_intStartPixelFromRight_Mold - m_intStartPixelFromRightInner_Mold);
                        intTotalStartY = objMoldFlashROI.ref_ROITotalY + m_intStartPixelFromEdge_Mold;

                        break;
                    case 2: // Bottom Border
                        objMoldFlashBorderROI.LoadROISetting(m_intStartPixelFromLeft_Mold, objMoldFlashROI.ref_ROIHeight - (m_intStartPixelFromBottom_Mold - m_intStartPixelFromBottomInner_Mold), objMoldFlashROI.ref_ROIWidth - m_intStartPixelFromLeft_Mold - m_intStartPixelFromRight_Mold, m_intStartPixelFromBottom_Mold - m_intStartPixelFromBottomInner_Mold);
                        intTotalStartX = objMoldFlashROI.ref_ROITotalX + m_intStartPixelFromLeft_Mold;
                        intTotalStartY = objMoldFlashROI.ref_ROITotalY + objMoldFlashROI.ref_ROIHeight - (m_intStartPixelFromBottom_Mold - m_intStartPixelFromBottomInner_Mold);


                        break;
                    case 3: // Left Border
                        objMoldFlashBorderROI.LoadROISetting(0, m_intStartPixelFromEdge_Mold, m_intStartPixelFromLeft_Mold - m_intStartPixelFromLeftInner_Mold, objMoldFlashROI.ref_ROIHeight - m_intStartPixelFromEdge_Mold - m_intStartPixelFromBottom_Mold);
                        intTotalStartX = objMoldFlashROI.ref_ROITotalX;
                        intTotalStartY = objMoldFlashROI.ref_ROITotalY + m_intStartPixelFromEdge_Mold;

                        break;
                }
                if (blnDebugImage)
                    objMoldFlashBorderROI.SaveImage("D:\\TS\\objMoldFlashBorderROI" + i.ToString() + ".bmp");
                // Build blobs object for subtract image
                int intSelectedObject = m_objImage1MoldFlashBlobs.BuildObjects_Filter_GetElement(objMoldFlashBorderROI, false, true, 0, m_intMoldFlashThreshold, m_intMoldFlashMinArea, objMoldFlashBorderROI.ref_ROIWidth * objMoldFlashBorderROI.ref_ROIHeight, true, 0x1F);
                if (intSelectedObject > 0)
                {
                    int intObjectTotalArea = 0;
                    int intObjectArea = 0;
                    float fObjectHeight = 0, fObjectWidth = 0, fObjectCenterX = 0, fObjectCenterY = 0;

                    for (int x = 0; x < intSelectedObject; x++)
                    {
                        intObjectArea = m_objImage1MoldFlashBlobs.ref_arrArea[x];
                        fObjectHeight = m_objImage1MoldFlashBlobs.ref_arrHeight[x];
                        fObjectWidth = m_objImage1MoldFlashBlobs.ref_arrWidth[x];
                        fObjectCenterX = m_objImage1MoldFlashBlobs.ref_arrLimitCenterX[x];
                        fObjectCenterY = m_objImage1MoldFlashBlobs.ref_arrLimitCenterY[x];
                        intObjectTotalArea += intObjectArea;

                        bool blnFail = false;
                        int intFailMask = 0;
                        string strDefectName = "Mold Flash";

                        if (m_arrWantDefectArea[(int)eWantDefect.MoldFlash])
                        {
                            if (intObjectArea >= GetAreaDefect("MoldFlash"))
                            {
                                //m_strErrorMessage += "*Fail Crack View Package - Cracked. Set = " + (m_arrDefectArea[0] / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                                m_strErrorMessage += "* Mold Flash Area Package Fail. Set = " + (GetAreaDefect("MoldFlash") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                                blnFail = true;
                                intFailMask |= 0x04;
                                strDefectName = "Mold Flash";
                            }
                        }
                        if (blnFail)
                        {
                            Defect objDefect = new Defect();
                            objDefect.ref_fDimX = fObjectWidth;
                            objDefect.ref_fDimY = fObjectHeight;
                            objDefect.ref_intLengthMode = 0;
                            objDefect.ref_fArea = intObjectArea;
                            objDefect.ref_fCenterX = intTotalStartX + fObjectCenterX;
                            objDefect.ref_fCenterY = intTotalStartY + fObjectCenterY;
                            objDefect.ref_intBlobNo = i;
                            objDefect.ref_intFailMask = intFailMask;
                            objDefect.ref_strName = strDefectName;
                            objDefect.ref_intFailedImage = intSelectedImageIndex + 1;
                            m_arrDefectList.Add(objDefect);

                            if (!blnOverAllFail)
                                blnOverAllFail = true;
                        }
                        else
                        {
                            Defect objDefect = new Defect();
                            objDefect.ref_fDimX = fObjectWidth;
                            objDefect.ref_fDimY = fObjectHeight;
                            objDefect.ref_intLengthMode = 0;
                            objDefect.ref_fArea = intObjectArea;
                            objDefect.ref_fCenterX = intTotalStartX + fObjectCenterX;
                            objDefect.ref_fCenterY = intTotalStartY + fObjectCenterY;
                            objDefect.ref_intBlobNo = i;
                            objDefect.ref_intFailMask = 0;
                            objDefect.ref_strName = strDefectName;
                            objDefect.ref_intFailedImage = intSelectedImageIndex + 1; ;
                            m_arrDefectList.Add(objDefect);
                        }

                    }

                    if (m_arrWantDefectArea[(int)eWantDefect.MoldFlash])
                    {
                        if (intObjectTotalArea >= GetTotalAreaDefect("MoldFlash"))
                        {
                            m_strErrorMessage += "* Mold Flash Total Area Fail. Set = " + (GetTotalAreaDefect("MoldFlash") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectTotalArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                            m_blnPkgViewFailTotalArea = true;

                            Defect objDefect = new Defect();
                            objDefect.ref_fDimX = -1;
                            objDefect.ref_fDimY = -1;
                            objDefect.ref_intLengthMode = 0;
                            objDefect.ref_fArea = intObjectTotalArea;
                            objDefect.ref_fCenterX = intTotalStartX + fObjectCenterX;
                            objDefect.ref_fCenterY = intTotalStartY + fObjectCenterY;
                            objDefect.ref_intFailMask |= 0x04;
                            objDefect.ref_strName = "Total Mold Flash";
                            objDefect.ref_intFailedImage = intSelectedImageIndex + 1;
                            m_arrDefectList.Add(objDefect);

                            if (!blnOverAllFail)
                                blnOverAllFail = true;
                        }
                    }
                }

            }
            if (blnOverAllFail)
            {
                m_intPkgFailResultMask |= 0x08;
                return false;
            }
            else
                return true;

        }
        private bool InspectMoldFlash_WithLinkFunction(ROI objMoldFlashROI)
        {
            if ((m_intPkgFailMask & 0x08) == 0)
                return true;

            int intSelectedImageIndex = m_arrGrabImageIndex[5];
            bool blnDebugImage = false;
            bool blnOverAllFail = false;
            int intTotalStartX = 0, intTotalStartY = 0;
            ROI objMoldFlashBorderROI = new ROI();
            objMoldFlashBorderROI.AttachImage(objMoldFlashROI);
            List<List<List<System.Windows.Point>>> arr2DPoints = new List<List<List<System.Windows.Point>>>();
            List<List<List<PointF>>> arrRotatedPoints = new List<List<List<PointF>>>();
            List<List<float>> fObjectHeightList = new List<List<float>>(), fObjectWidthList = new List<List<float>>(), fObjectCenterXList = new List<List<float>>(), fObjectCenterYList = new List<List<float>>(), fObjectAngleList = new List<List<float>>();
            List<List<int>> fObjectAreaList = new List<List<int>>(), fObjectAreaList2 = new List<List<int>>();
            for (int i = 0; i < 4; i++)   // Create 4 direction ROI
            {
                arrRotatedPoints.Add(new List<List<PointF>>());
                arr2DPoints.Add(new List<List<System.Windows.Point>>());
                fObjectHeightList.Add(new List<float>());
                fObjectWidthList.Add(new List<float>());
                fObjectCenterXList.Add(new List<float>());
                fObjectCenterYList.Add(new List<float>());
                fObjectAngleList.Add(new List<float>());
                fObjectAreaList.Add(new List<int>());
                fObjectAreaList2.Add(new List<int>());

                //switch (i)
                //{
                //    case 0:  // Top Border
                //        objMoldFlashBorderROI.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth, m_intStartPixelFromEdge_Mold);
                //        intTotalStartX = objMoldFlashROI.ref_ROITotalX;
                //        intTotalStartY = objMoldFlashROI.ref_ROITotalY;

                //        break;
                //    case 1: // Right Border
                //        objMoldFlashBorderROI.LoadROISetting(objMoldFlashROI.ref_ROIWidth - m_intStartPixelFromRight_Mold, 0, m_intStartPixelFromRight_Mold, objMoldFlashROI.ref_ROIHeight);
                //        intTotalStartX = objMoldFlashROI.ref_ROITotalX + objMoldFlashROI.ref_ROIWidth - m_intStartPixelFromRight_Mold;
                //        intTotalStartY = objMoldFlashROI.ref_ROITotalY;

                //        break;
                //    case 2: // Bottom Border
                //        objMoldFlashBorderROI.LoadROISetting(0, objMoldFlashROI.ref_ROIHeight - m_intStartPixelFromBottom_Mold, objMoldFlashROI.ref_ROIWidth, m_intStartPixelFromBottom_Mold);
                //        intTotalStartX = objMoldFlashROI.ref_ROITotalX;
                //        intTotalStartY = objMoldFlashROI.ref_ROITotalY + objMoldFlashROI.ref_ROIHeight - m_intStartPixelFromBottom_Mold;


                //        break;
                //    case 3: // Left Border
                //        objMoldFlashBorderROI.LoadROISetting(0, 0, m_intStartPixelFromLeft_Mold, objMoldFlashROI.ref_ROIHeight);
                //        intTotalStartX = objMoldFlashROI.ref_ROITotalX;
                //        intTotalStartY = objMoldFlashROI.ref_ROITotalY;

                //        break;
                //}
                switch (i)
                {
                    case 0:  // Top Border
                        objMoldFlashBorderROI.LoadROISetting(m_intStartPixelFromLeft_Mold, 0, objMoldFlashROI.ref_ROIWidth - m_intStartPixelFromLeft_Mold - m_intStartPixelFromRight_Mold, m_intStartPixelFromEdge_Mold - m_intStartPixelFromEdgeInner_Mold);//m_intStartPixelFromEdge_Mold
                        intTotalStartX = objMoldFlashROI.ref_ROITotalX + m_intStartPixelFromLeft_Mold;
                        intTotalStartY = objMoldFlashROI.ref_ROITotalY;

                        break;
                    case 1: // Right Border
                        objMoldFlashBorderROI.LoadROISetting(objMoldFlashROI.ref_ROIWidth - (m_intStartPixelFromRight_Mold - m_intStartPixelFromRightInner_Mold), m_intStartPixelFromEdge_Mold, m_intStartPixelFromRight_Mold - m_intStartPixelFromRightInner_Mold, objMoldFlashROI.ref_ROIHeight - m_intStartPixelFromEdge_Mold - m_intStartPixelFromBottom_Mold);
                        intTotalStartX = objMoldFlashROI.ref_ROITotalX + objMoldFlashROI.ref_ROIWidth - (m_intStartPixelFromRight_Mold - m_intStartPixelFromRightInner_Mold);
                        intTotalStartY = objMoldFlashROI.ref_ROITotalY + m_intStartPixelFromEdge_Mold;

                        break;
                    case 2: // Bottom Border
                        objMoldFlashBorderROI.LoadROISetting(m_intStartPixelFromLeft_Mold, objMoldFlashROI.ref_ROIHeight - (m_intStartPixelFromBottom_Mold - m_intStartPixelFromBottomInner_Mold), objMoldFlashROI.ref_ROIWidth - m_intStartPixelFromLeft_Mold - m_intStartPixelFromRight_Mold, m_intStartPixelFromBottom_Mold - m_intStartPixelFromBottomInner_Mold);
                        intTotalStartX = objMoldFlashROI.ref_ROITotalX + m_intStartPixelFromLeft_Mold;
                        intTotalStartY = objMoldFlashROI.ref_ROITotalY + objMoldFlashROI.ref_ROIHeight - (m_intStartPixelFromBottom_Mold - m_intStartPixelFromBottomInner_Mold);


                        break;
                    case 3: // Left Border
                        objMoldFlashBorderROI.LoadROISetting(0, m_intStartPixelFromEdge_Mold, m_intStartPixelFromLeft_Mold - m_intStartPixelFromLeftInner_Mold, objMoldFlashROI.ref_ROIHeight - m_intStartPixelFromEdge_Mold - m_intStartPixelFromBottom_Mold);
                        intTotalStartX = objMoldFlashROI.ref_ROITotalX;
                        intTotalStartY = objMoldFlashROI.ref_ROITotalY + m_intStartPixelFromEdge_Mold;

                        break;
                }
                if (blnDebugImage)
                    objMoldFlashBorderROI.SaveImage("D:\\TS\\objMoldFlashBorderROI" + i.ToString() + ".bmp");
                // Build blobs object for subtract image
                int intSelectedObject = m_objImage1MoldFlashBlobs.BuildObjects_Filter_GetElement(objMoldFlashBorderROI, false, true, 0, m_intMoldFlashThreshold, m_intMoldFlashMinArea, objMoldFlashBorderROI.ref_ROIWidth * objMoldFlashBorderROI.ref_ROIHeight + 1, true, 0xED);//0x1F
                if (intSelectedObject > 0)
                {
                
                    int intObjectTotalArea = 0;
                    int intObjectArea = 0;
                    float fObjectHeight = 0, fObjectWidth = 0, fObjectCenterX = 0, fObjectCenterY = 0, fObjectAngle = 0;

                    for (int x = 0; x < intSelectedObject; x++)
                    {
                        arrRotatedPoints[i].Add(new List<PointF>());
                        arr2DPoints[i].Add(new List<System.Windows.Point>());
                        intObjectArea = m_objImage1MoldFlashBlobs.ref_arrArea[x];
                        //fObjectHeight = m_objImage1MoldFlashBlobs.ref_arrHeight[x];
                        //fObjectWidth = m_objImage1MoldFlashBlobs.ref_arrWidth[x];
                        //fObjectCenterX = m_objImage1MoldFlashBlobs.ref_arrLimitCenterX[x];
                        //fObjectCenterY = m_objImage1MoldFlashBlobs.ref_arrLimitCenterY[x];
                        intObjectTotalArea += intObjectArea;

                        if (m_objImage1MoldFlashBlobs.ref_arrRectHeight[x] < m_objImage1MoldFlashBlobs.ref_arrRectWidth[x])
                        {
                            fObjectWidth = m_objImage1MoldFlashBlobs.ref_arrRectHeight[x];
                            fObjectHeight = m_objImage1MoldFlashBlobs.ref_arrRectWidth[x];

                            fObjectAngle = m_objImage1MoldFlashBlobs.ref_arrRectAngle[x];

                            if (fObjectAngle >= 10)//&& fAngle <= 80)
                                fObjectAngle = m_objImage1MoldFlashBlobs.ref_arrRectAngle[x] - 90;
                            else
                                fObjectAngle = 90 + m_objImage1MoldFlashBlobs.ref_arrRectAngle[x];

                        }
                        else
                        {
                            fObjectHeight = m_objImage1MoldFlashBlobs.ref_arrRectHeight[x];
                            fObjectWidth = m_objImage1MoldFlashBlobs.ref_arrRectWidth[x];

                            fObjectAngle = m_objImage1MoldFlashBlobs.ref_arrRectAngle[x];

                        }
                        fObjectCenterX = m_objImage1MoldFlashBlobs.ref_arrRectLimitCenterX[x];
                        fObjectCenterY = m_objImage1MoldFlashBlobs.ref_arrRectLimitCenterY[x];

                        float newX1 = 0, newY1 = 0;  // new point 1
                        float newX2 = 0, newY2 = 0; // new point 2
                        float newX3 = 0, newY3 = 0; // new point 3
                        float newX4 = 0, newY4 = 0; // new point 4

                        //2020-12-18 ZJYEOH : Change to this format
                        //  Point 1 *-------------* Point 2
                        //          |             |
                        //          |             |
                        //          |             |
                        //  Point 4 *-------------* Point 3

                        Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX - (fObjectWidth / 2)), (fObjectCenterY - (fObjectHeight / 2)), fObjectAngle, ref newX1, ref newY1);
                        Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX + (fObjectWidth / 2)), (fObjectCenterY - (fObjectHeight / 2)), fObjectAngle, ref newX2, ref newY2);
                        Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX + (fObjectWidth / 2)), (fObjectCenterY + (fObjectHeight / 2)), fObjectAngle, ref newX3, ref newY3);
                        Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX - (fObjectWidth / 2)), (fObjectCenterY + (fObjectHeight / 2)), fObjectAngle, ref newX4, ref newY4);


                        arrRotatedPoints[i][x].Add(new PointF(newX1, newY1));
                        arrRotatedPoints[i][x].Add(new PointF(newX2, newY2));
                        arrRotatedPoints[i][x].Add(new PointF(newX3, newY3));
                        arrRotatedPoints[i][x].Add(new PointF(newX4, newY4));

                        Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX - (fObjectWidth / 2)) - m_intMoldFlashDefectLinkTolerance, (fObjectCenterY - (fObjectHeight / 2)) - m_intMoldFlashDefectLinkTolerance, fObjectAngle, ref newX1, ref newY1);
                        Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX + (fObjectWidth / 2)) + m_intMoldFlashDefectLinkTolerance, (fObjectCenterY - (fObjectHeight / 2)) - m_intMoldFlashDefectLinkTolerance, fObjectAngle, ref newX2, ref newY2);
                        Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX + (fObjectWidth / 2)) + m_intMoldFlashDefectLinkTolerance, (fObjectCenterY + (fObjectHeight / 2)) + m_intMoldFlashDefectLinkTolerance, fObjectAngle, ref newX3, ref newY3);
                        Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX - (fObjectWidth / 2)) - m_intMoldFlashDefectLinkTolerance, (fObjectCenterY + (fObjectHeight / 2)) + m_intMoldFlashDefectLinkTolerance, fObjectAngle, ref newX4, ref newY4);

                        arr2DPoints[i][x].Add(new System.Windows.Point(newX1, newY1));
                        arr2DPoints[i][x].Add(new System.Windows.Point(newX2, newY2));
                        arr2DPoints[i][x].Add(new System.Windows.Point(newX3, newY3));
                        arr2DPoints[i][x].Add(new System.Windows.Point(newX4, newY4));

                        fObjectHeightList[i].Add(fObjectHeight);
                        fObjectWidthList[i].Add(fObjectWidth);
                        fObjectCenterXList[i].Add(fObjectCenterX);
                        fObjectCenterYList[i].Add(fObjectCenterY);
                        fObjectAngleList[i].Add(fObjectAngle);
                        fObjectAreaList[i].Add(intObjectArea);
                        fObjectAreaList2[i].Add(intObjectArea);
                    }
                    int intTolerance = m_intMoldFlashDefectLinkTolerance;
                    int intAngleTolerance = 10;
                    bool blnDecrement = false;
                    if (intTolerance >= 0)
                    {
                        for (int x = 0; x < fObjectHeightList[i].Count; x++)
                        {
                            if (blnDecrement)
                            {
                                blnDecrement = false;
                                if (x > 0)
                                    x--;
                            }
                            for (int j = 0; j < fObjectHeightList[i].Count; j++)
                            {
                                if (x != j && x < fObjectHeightList[i].Count && j < fObjectHeightList[i].Count)
                                {
                                    if (Intersection.CheckRectRectIntersection(arr2DPoints[i][x].ToArray(), arr2DPoints[i][j].ToArray(), intTolerance))
                                    {

                                        PointF[] arrPoints = new PointF[8];

                                        arrPoints[0] = arrRotatedPoints[i][x][0];
                                        arrPoints[1] = arrRotatedPoints[i][x][1];
                                        arrPoints[2] = arrRotatedPoints[i][x][2];
                                        arrPoints[3] = arrRotatedPoints[i][x][3];
                                        arrPoints[4] = arrRotatedPoints[i][j][0];
                                        arrPoints[5] = arrRotatedPoints[i][j][1];
                                        arrPoints[6] = arrRotatedPoints[i][j][2];
                                        arrPoints[7] = arrRotatedPoints[i][j][3];

                                        float fMinAngle = 0;
                                        List<PointF> arrMinRect = new List<PointF>();
                                        arrMinRect = MinimumBoundingBox.CalculateMinimumBoundingBox(arrPoints, ref fMinAngle);

                                        if (fMinAngle < 0)
                                            fObjectAngleList[i][x] = -(90 + fMinAngle);
                                        else
                                            fObjectAngleList[i][x] = 90 - fMinAngle;

                                        Line onjLine1 = new Line();
                                        Line onjLine2 = new Line();
                                        onjLine1.CalculateStraightLine(arrMinRect[0], arrMinRect[2]);
                                        onjLine2.CalculateStraightLine(arrMinRect[1], arrMinRect[3]);
                                        PointF pCenter = Line.GetCrossPoint(onjLine1, onjLine2);
                                        float p1X = 0, p1Y = 0;
                                        float p2X = 0, p2Y = 0;
                                        float p3X = 0, p3Y = 0;
                                        float p4X = 0, p4Y = 0;
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[0].X, arrMinRect[0].Y, -fObjectAngleList[i][x], ref p1X, ref p1Y);
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[1].X, arrMinRect[1].Y, -fObjectAngleList[i][x], ref p2X, ref p2Y);
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[2].X, arrMinRect[2].Y, -fObjectAngleList[i][x], ref p3X, ref p3Y);
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[3].X, arrMinRect[3].Y, -fObjectAngleList[i][x], ref p4X, ref p4Y);

                                        float pR1X = 0, pR1Y = 0;
                                        float pR2X = 0, pR2Y = 0;
                                        float pR3X = 0, pR3Y = 0;
                                        float pR4X = 0, pR4Y = 0;
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)), Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)), fObjectAngleList[i][x], ref pR1X, ref pR1Y); // Top Left
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)), Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)), fObjectAngleList[i][x], ref pR2X, ref pR2Y); // Top Right
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)), Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)), fObjectAngleList[i][x], ref pR3X, ref pR3Y); // Bottom Right
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)), Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)), fObjectAngleList[i][x], ref pR4X, ref pR4Y); // Bottom Left
                                        arrMinRect[0] = new PointF(pR1X, pR1Y);
                                        arrMinRect[1] = new PointF(pR2X, pR2Y);
                                        arrMinRect[2] = new PointF(pR3X, pR3Y);
                                        arrMinRect[3] = new PointF(pR4X, pR4Y);

                                        arrRotatedPoints[i][x][0] = arrMinRect[0];
                                        arrRotatedPoints[i][x][1] = arrMinRect[1];
                                        arrRotatedPoints[i][x][2] = arrMinRect[2];
                                        arrRotatedPoints[i][x][3] = arrMinRect[3];

                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)) - m_intMoldFlashDefectLinkTolerance, Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)) - m_intMoldFlashDefectLinkTolerance, fObjectAngleList[i][x], ref pR1X, ref pR1Y); // Top Left
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)) + m_intMoldFlashDefectLinkTolerance, Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)) - m_intMoldFlashDefectLinkTolerance, fObjectAngleList[i][x], ref pR2X, ref pR2Y); // Top Right
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)) + m_intMoldFlashDefectLinkTolerance, Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)) + m_intMoldFlashDefectLinkTolerance, fObjectAngleList[i][x], ref pR3X, ref pR3Y); // Bottom Right
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)) - m_intMoldFlashDefectLinkTolerance, Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)) + m_intMoldFlashDefectLinkTolerance, fObjectAngleList[i][x], ref pR4X, ref pR4Y); // Bottom Left

                                        arr2DPoints[i][x][0] = new System.Windows.Point(pR1X, pR1Y);
                                        arr2DPoints[i][x][1] = new System.Windows.Point(pR2X, pR2Y);
                                        arr2DPoints[i][x][2] = new System.Windows.Point(pR3X, pR3Y);
                                        arr2DPoints[i][x][3] = new System.Windows.Point(pR4X, pR4Y);

                                        arrRotatedPoints[i].RemoveAt(j);
                                        arr2DPoints[i].RemoveAt(j);

                                        float fDiffX = Math.Max(Math.Abs(p1X - p4X), Math.Abs(p2X - p3X));
                                        float fDiffY = Math.Max(Math.Abs(p3Y - p4Y), Math.Abs(p2Y - p1Y));

                                        fObjectWidthList[i][x] = fDiffX;
                                        fObjectHeightList[i][x] = fDiffY;

                                        fObjectCenterXList[i][x] = pCenter.X;
                                        fObjectCenterYList[i][x] = pCenter.Y;

                                        fObjectAreaList2[i].RemoveAt(j);
                                        fObjectAreaList[i][x] = fObjectAreaList[i][x] + fObjectAreaList[i][j];

                                        fObjectHeightList[i].RemoveAt(j);
                                        fObjectWidthList[i].RemoveAt(j);
                                        fObjectCenterXList[i].RemoveAt(j);
                                        fObjectCenterYList[i].RemoveAt(j);
                                        fObjectAngleList[i].RemoveAt(j);
                                        fObjectAreaList[i].RemoveAt(j);

                                        if (j > 0)
                                            j = -1;
                                        if (x > 0)
                                        {
                                            x = 0;
                                        }
                                        else
                                            blnDecrement = true;

                                    }

                                }
                            }
                        }
                    }
                    for (int x = 0; x < fObjectAreaList[i].Count; x++)
                    {
                        bool blnFail = false;
                        int intFailMask = 0;
                        string strDefectName = "Mold Flash";

                        if (m_arrWantDefectArea[(int)eWantDefect.MoldFlash])
                        {
                            if (fObjectAreaList[i][x] >= GetAreaDefect("MoldFlash"))
                            {
                                //m_strErrorMessage += "*Fail Crack View Package - Cracked. Set = " + (m_arrDefectArea[0] / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                                m_strErrorMessage += "* Mold Flash Area Package Fail. Set = " + (GetAreaDefect("MoldFlash") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (fObjectAreaList[i][x] / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                                blnFail = true;
                                intFailMask |= 0x04;
                                strDefectName = "Mold Flash";
                            }
                        }
                        if (blnFail)
                        {
                            Defect objDefect = new Defect();
                            objDefect.ref_fDimX = fObjectWidthList[i][x];
                            objDefect.ref_fDimY = fObjectHeightList[i][x];
                            objDefect.ref_intLengthMode = 0;
                            objDefect.ref_fArea = fObjectAreaList[i][x];
                            objDefect.ref_fCenterX = intTotalStartX + fObjectCenterXList[i][x];
                            objDefect.ref_fCenterY = intTotalStartY + fObjectCenterYList[i][x];
                            objDefect.ref_fAngle = fObjectAngleList[i][x];
                            objDefect.ref_intBlobNo = i;
                            objDefect.ref_intFailMask = intFailMask;
                            objDefect.ref_strName = strDefectName;
                            objDefect.ref_intFailedImage = intSelectedImageIndex + 1;
                            m_arrDefectList.Add(objDefect);

                            if (!blnOverAllFail)
                                blnOverAllFail = true;
                        }
                        else
                        {
                            Defect objDefect = new Defect();
                            objDefect.ref_fDimX = fObjectWidthList[i][x];
                            objDefect.ref_fDimY = fObjectHeightList[i][x];
                            objDefect.ref_intLengthMode = 0;
                            objDefect.ref_fArea = fObjectAreaList[i][x];
                            objDefect.ref_fCenterX = intTotalStartX + fObjectCenterXList[i][x];
                            objDefect.ref_fCenterY = intTotalStartY + fObjectCenterYList[i][x];
                            objDefect.ref_fAngle = fObjectAngleList[i][x];
                            objDefect.ref_intBlobNo = i;
                            objDefect.ref_intFailMask = 0;
                            objDefect.ref_strName = strDefectName;
                            objDefect.ref_intFailedImage = intSelectedImageIndex + 1; ;
                            m_arrDefectList.Add(objDefect);
                        }

                    }

                    if (m_arrWantDefectArea[(int)eWantDefect.MoldFlash])
                    {
                        if (intObjectTotalArea >= GetTotalAreaDefect("MoldFlash"))
                        {
                            m_strErrorMessage += "* Mold Flash Total Area Fail. Set = " + (GetTotalAreaDefect("MoldFlash") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectTotalArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                            m_blnPkgViewFailTotalArea = true;

                            Defect objDefect = new Defect();
                            objDefect.ref_fDimX = -1;
                            objDefect.ref_fDimY = -1;
                            objDefect.ref_intLengthMode = 0;
                            objDefect.ref_fArea = intObjectTotalArea;
                            objDefect.ref_fCenterX = intTotalStartX + fObjectCenterX;
                            objDefect.ref_fCenterY = intTotalStartY + fObjectCenterY;
                            objDefect.ref_fAngle = fObjectAngle;
                            objDefect.ref_intFailMask |= 0x04;
                            objDefect.ref_strName = "Total Mold Flash";
                            objDefect.ref_intFailedImage = intSelectedImageIndex + 1;
                            m_arrDefectList.Add(objDefect);

                            if (!blnOverAllFail)
                                blnOverAllFail = true;
                        }
                    }
                }

            }
            if (blnOverAllFail)
            {
                m_intPkgFailResultMask |= 0x08;
                return false;
            }
            else
                return true;

        }
        private bool InspectMoldFlashArea(ROI objMoldFlashROI, List<PointF> arrMoldROIPoints)
        {
            //arrMoldROIPoints Index: 0=TopLeft, 1=TopRight, 2=BottomLeft, 3=BottomRight

            if ((m_intPkgFailMask & 0x08) == 0)
                return true;

            int intSelectedImageIndex = m_arrGrabImageIndex[5];
            bool blnDebugImage = false;
            bool blnOverAllFail = false;
            int intTotalStartX = 0, intTotalStartY = 0;
            ROI objMoldFlashBorderROI = new ROI();
            objMoldFlashBorderROI.AttachImage(objMoldFlashROI);

            for (int i = 0; i < 4; i++)   // Create 4 direction ROI
            {
                switch (i)
                {
                    case 0:  // Top Border
                        objMoldFlashBorderROI.LoadROISetting((int)Math.Round(arrMoldROIPoints[0].X) - objMoldFlashROI.ref_ROITotalX, 0, (int)Math.Round(arrMoldROIPoints[1].X - arrMoldROIPoints[0].X), (int)Math.Round(arrMoldROIPoints[0].Y) - objMoldFlashROI.ref_ROITotalY);//m_intStartPixelFromEdge_Mold
                        //intTotalStartX = (int)Math.Round(arrMoldROIPoints[0].X);
                        //intTotalStartY = objMoldFlashROI.ref_ROITotalY;
                        intTotalStartX = objMoldFlashBorderROI.ref_ROITotalX;
                        intTotalStartY = objMoldFlashBorderROI.ref_ROITotalY;
                        break;
                    case 1: // Right Border
                        objMoldFlashBorderROI.LoadROISetting((int)Math.Round(arrMoldROIPoints[1].X) - objMoldFlashROI.ref_ROITotalX + m_intStartPixelFromRightInner_Mold, (int)Math.Round(arrMoldROIPoints[1].Y) - objMoldFlashROI.ref_ROITotalY, objMoldFlashROI.ref_ROITotalX + objMoldFlashROI.ref_ROIWidth - (int)Math.Round(arrMoldROIPoints[1].X), (int)Math.Round(arrMoldROIPoints[3].Y - arrMoldROIPoints[1].Y));
                        //intTotalStartX = (int)Math.Round(arrMoldROIPoints[1].X);
                        //intTotalStartY = (int)Math.Round(arrMoldROIPoints[1].Y);
                        intTotalStartX = objMoldFlashBorderROI.ref_ROITotalX;
                        intTotalStartY = objMoldFlashBorderROI.ref_ROITotalY;
                        break;
                    case 2: // Bottom Border
                        objMoldFlashBorderROI.LoadROISetting((int)Math.Round(arrMoldROIPoints[2].X) - objMoldFlashROI.ref_ROITotalX, (int)Math.Round(arrMoldROIPoints[2].Y) - objMoldFlashROI.ref_ROITotalY, (int)Math.Round(arrMoldROIPoints[3].X - arrMoldROIPoints[2].X), objMoldFlashROI.ref_ROITotalY + objMoldFlashROI.ref_ROIHeight - (int)Math.Round(arrMoldROIPoints[3].Y));
                        //intTotalStartX = (int)Math.Round(arrMoldROIPoints[2].X);
                        //intTotalStartY = (int)Math.Round(arrMoldROIPoints[2].Y);
                        intTotalStartX = objMoldFlashBorderROI.ref_ROITotalX;
                        intTotalStartY = objMoldFlashBorderROI.ref_ROITotalY;
                        break;
                    case 3: // Left Border
                        objMoldFlashBorderROI.LoadROISetting(0, (int)Math.Round(arrMoldROIPoints[0].Y) - objMoldFlashROI.ref_ROITotalY, (int)Math.Round(arrMoldROIPoints[0].X) - objMoldFlashROI.ref_ROITotalX, (int)Math.Round(arrMoldROIPoints[2].Y - arrMoldROIPoints[0].Y));
                        //intTotalStartX = objMoldFlashROI.ref_ROITotalX;
                        //intTotalStartY = (int)Math.Round(arrMoldROIPoints[0].Y);
                        intTotalStartX = objMoldFlashBorderROI.ref_ROITotalX;
                        intTotalStartY = objMoldFlashBorderROI.ref_ROITotalY;
                        break;
                }
                if (blnDebugImage)
                    objMoldFlashBorderROI.SaveImage("D:\\TS\\objMoldFlashBorderROI" + i.ToString() + ".bmp");
                // Build blobs object for subtract image
                int intSelectedObject = m_objImage1MoldFlashBlobs.BuildObjects_Filter_GetElement(objMoldFlashBorderROI, false, true, 0, m_intMoldFlashThreshold, m_intMoldFlashMinArea, objMoldFlashBorderROI.ref_ROIWidth * objMoldFlashBorderROI.ref_ROIHeight, true, 0x1F);
                if (intSelectedObject > 0)
                {
                    int intObjectTotalArea = 0;
                    int intObjectArea = 0;
                    float fObjectHeight = 0, fObjectWidth = 0, fObjectCenterX = 0, fObjectCenterY = 0;

                    for (int x = 0; x < intSelectedObject; x++)
                    {
                        intObjectArea = m_objImage1MoldFlashBlobs.ref_arrArea[x];
                        fObjectHeight = m_objImage1MoldFlashBlobs.ref_arrHeight[x];
                        fObjectWidth = m_objImage1MoldFlashBlobs.ref_arrWidth[x];
                        fObjectCenterX = m_objImage1MoldFlashBlobs.ref_arrLimitCenterX[x];
                        fObjectCenterY = m_objImage1MoldFlashBlobs.ref_arrLimitCenterY[x];
                        intObjectTotalArea += intObjectArea;

                        bool blnFail = false;
                        int intFailMask = 0;
                        string strDefectName = "Mold Flash";

                        if (m_arrWantDefectArea[(int)eWantDefect.MoldFlash])
                        {
                            if (intObjectArea >= GetAreaDefect("MoldFlash"))
                            {
                                //m_strErrorMessage += "*Fail Crack View Package - Cracked. Set = " + (m_arrDefectArea[0] / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                                m_strErrorMessage += "* Mold Flash Area Package Fail. Set = " + (GetAreaDefect("MoldFlash") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                                blnFail = true;
                                intFailMask |= 0x04;
                                strDefectName = "Mold Flash";
                            }
                        }
                        if (blnFail)
                        {
                            Defect objDefect = new Defect();
                            objDefect.ref_fDimX = fObjectWidth;
                            objDefect.ref_fDimY = fObjectHeight;
                            objDefect.ref_intLengthMode = 0;
                            objDefect.ref_fArea = intObjectArea;
                            objDefect.ref_fCenterX = intTotalStartX + fObjectCenterX;
                            objDefect.ref_fCenterY = intTotalStartY + fObjectCenterY;
                            objDefect.ref_intBlobNo = i;
                            objDefect.ref_intFailMask = intFailMask;
                            objDefect.ref_strName = strDefectName;
                            objDefect.ref_intFailedImage = intSelectedImageIndex + 1;
                            m_arrDefectList.Add(objDefect);

                            if (!blnOverAllFail)
                                blnOverAllFail = true;
                        }
                        else
                        {
                            Defect objDefect = new Defect();
                            objDefect.ref_fDimX = fObjectWidth;
                            objDefect.ref_fDimY = fObjectHeight;
                            objDefect.ref_intLengthMode = 0;
                            objDefect.ref_fArea = intObjectArea;
                            objDefect.ref_fCenterX = intTotalStartX + fObjectCenterX;
                            objDefect.ref_fCenterY = intTotalStartY + fObjectCenterY;
                            objDefect.ref_intBlobNo = i;
                            objDefect.ref_intFailMask = 0;
                            objDefect.ref_strName = strDefectName;
                            objDefect.ref_intFailedImage = intSelectedImageIndex + 1; ;
                            m_arrDefectList.Add(objDefect);
                        }

                    }

                    if (m_arrWantDefectArea[(int)eWantDefect.MoldFlash])
                    {
                        if (intObjectTotalArea >= GetTotalAreaDefect("MoldFlash"))
                        {
                            m_strErrorMessage += "* Mold Flash Total Area Fail. Set = " + (GetTotalAreaDefect("MoldFlash") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectTotalArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                            m_blnPkgViewFailTotalArea = true;

                            Defect objDefect = new Defect();
                            objDefect.ref_fDimX = -1;
                            objDefect.ref_fDimY = -1;
                            objDefect.ref_intLengthMode = 0;
                            objDefect.ref_fArea = intObjectTotalArea;
                            objDefect.ref_fCenterX = intTotalStartX + fObjectCenterX;
                            objDefect.ref_fCenterY = intTotalStartY + fObjectCenterY;
                            objDefect.ref_intFailMask |= 0x04;
                            objDefect.ref_strName = "Total Mold Flash";
                            objDefect.ref_intFailedImage = intSelectedImageIndex + 1;
                            m_arrDefectList.Add(objDefect);

                            if (!blnOverAllFail)
                                blnOverAllFail = true;
                        }
                    }
                }

            }
            if (blnOverAllFail)
            {
                m_intPkgFailResultMask |= 0x08;
                return false;
            }
            else
                return true;

        }
        private bool InspectMoldFlashArea_WithLinkFunction(ROI objMoldFlashROI, List<PointF> arrMoldROIPoints)
        {
            //arrMoldROIPoints Index: 0=TopLeft, 1=TopRight, 2=BottomLeft, 3=BottomRight

            if ((m_intPkgFailMask & 0x08) == 0)
                return true;

            int intSelectedImageIndex = m_arrGrabImageIndex[5];
            bool blnDebugImage = false;
            bool blnOverAllFail = false;
            int intTotalStartX = 0, intTotalStartY = 0;
            ROI objMoldFlashBorderROI = new ROI();
            objMoldFlashBorderROI.AttachImage(objMoldFlashROI);
            List<List<List<System.Windows.Point>>> arr2DPoints = new List<List<List<System.Windows.Point>>>();
            List<List<List<PointF>>> arrRotatedPoints = new List<List<List<PointF>>>();
            List<List<float>> fObjectHeightList = new List<List<float>>(), fObjectWidthList = new List<List<float>>(), fObjectCenterXList = new List<List<float>>(), fObjectCenterYList = new List<List<float>>(), fObjectAngleList = new List<List<float>>();
            List<List<int>> fObjectAreaList = new List<List<int>>(), fObjectAreaList2 = new List<List<int>>();
            for (int i = 0; i < 4; i++)   // Create 4 direction ROI
            {
                arrRotatedPoints.Add(new List<List<PointF>>());
                arr2DPoints.Add(new List<List<System.Windows.Point>>());
                fObjectHeightList.Add(new List<float>());
                fObjectWidthList.Add(new List<float>());
                fObjectCenterXList.Add(new List<float>());
                fObjectCenterYList.Add(new List<float>());
                fObjectAngleList.Add(new List<float>());
                fObjectAreaList.Add(new List<int>());
                fObjectAreaList2.Add(new List<int>());
                switch (i)
                {
                    case 0:  // Top Border
                        objMoldFlashBorderROI.LoadROISetting((int)Math.Round(arrMoldROIPoints[0].X) - objMoldFlashROI.ref_ROITotalX, 0, (int)Math.Round(arrMoldROIPoints[1].X - arrMoldROIPoints[0].X), (int)Math.Round(arrMoldROIPoints[0].Y) - objMoldFlashROI.ref_ROITotalY);//m_intStartPixelFromEdge_Mold
                        //intTotalStartX = (int)Math.Round(arrMoldROIPoints[0].X);
                        //intTotalStartY = objMoldFlashROI.ref_ROITotalY;
                        intTotalStartX = objMoldFlashBorderROI.ref_ROITotalX;
                        intTotalStartY = objMoldFlashBorderROI.ref_ROITotalY;
                        break;
                    case 1: // Right Border
                        objMoldFlashBorderROI.LoadROISetting((int)Math.Round(arrMoldROIPoints[1].X) - objMoldFlashROI.ref_ROITotalX + m_intStartPixelFromRightInner_Mold, (int)Math.Round(arrMoldROIPoints[1].Y) - objMoldFlashROI.ref_ROITotalY, objMoldFlashROI.ref_ROITotalX + objMoldFlashROI.ref_ROIWidth - (int)Math.Round(arrMoldROIPoints[1].X), (int)Math.Round(arrMoldROIPoints[3].Y - arrMoldROIPoints[1].Y));
                        //intTotalStartX = (int)Math.Round(arrMoldROIPoints[1].X);
                        //intTotalStartY = (int)Math.Round(arrMoldROIPoints[1].Y);
                        intTotalStartX = objMoldFlashBorderROI.ref_ROITotalX;
                        intTotalStartY = objMoldFlashBorderROI.ref_ROITotalY;
                        break;
                    case 2: // Bottom Border
                        objMoldFlashBorderROI.LoadROISetting((int)Math.Round(arrMoldROIPoints[2].X) - objMoldFlashROI.ref_ROITotalX, (int)Math.Round(arrMoldROIPoints[2].Y) - objMoldFlashROI.ref_ROITotalY, (int)Math.Round(arrMoldROIPoints[3].X - arrMoldROIPoints[2].X), objMoldFlashROI.ref_ROITotalY + objMoldFlashROI.ref_ROIHeight - (int)Math.Round(arrMoldROIPoints[3].Y));
                        //intTotalStartX = (int)Math.Round(arrMoldROIPoints[2].X);
                        //intTotalStartY = (int)Math.Round(arrMoldROIPoints[2].Y);
                        intTotalStartX = objMoldFlashBorderROI.ref_ROITotalX;
                        intTotalStartY = objMoldFlashBorderROI.ref_ROITotalY;
                        break;
                    case 3: // Left Border
                        objMoldFlashBorderROI.LoadROISetting(0, (int)Math.Round(arrMoldROIPoints[0].Y) - objMoldFlashROI.ref_ROITotalY, (int)Math.Round(arrMoldROIPoints[0].X) - objMoldFlashROI.ref_ROITotalX, (int)Math.Round(arrMoldROIPoints[2].Y - arrMoldROIPoints[0].Y));
                        //intTotalStartX = objMoldFlashROI.ref_ROITotalX;
                        //intTotalStartY = (int)Math.Round(arrMoldROIPoints[0].Y);
                        intTotalStartX = objMoldFlashBorderROI.ref_ROITotalX;
                        intTotalStartY = objMoldFlashBorderROI.ref_ROITotalY;
                        break;
                }
                if (blnDebugImage)
                    objMoldFlashBorderROI.SaveImage("D:\\TS\\objMoldFlashBorderROI" + i.ToString() + ".bmp");
                // Build blobs object for subtract image
                int intSelectedObject = m_objImage1MoldFlashBlobs.BuildObjects_Filter_GetElement(objMoldFlashBorderROI, false, true, 0, m_intMoldFlashThreshold, m_intMoldFlashMinArea, objMoldFlashBorderROI.ref_ROIWidth * objMoldFlashBorderROI.ref_ROIHeight + 1, true, 0xED);//0x1F
                if (intSelectedObject > 0)
                {
                    int intObjectTotalArea = 0;
                    int intObjectArea = 0;
                    float fObjectHeight = 0, fObjectWidth = 0, fObjectCenterX = 0, fObjectCenterY = 0, fObjectAngle = 0;

                    for (int x = 0; x < intSelectedObject; x++)
                    {
                        arrRotatedPoints[i].Add(new List<PointF>());
                        arr2DPoints[i].Add(new List<System.Windows.Point>());
                        intObjectArea = m_objImage1MoldFlashBlobs.ref_arrArea[x];
                        //fObjectHeight = m_objImage1MoldFlashBlobs.ref_arrHeight[x];
                        //fObjectWidth = m_objImage1MoldFlashBlobs.ref_arrWidth[x];
                        //fObjectCenterX = m_objImage1MoldFlashBlobs.ref_arrLimitCenterX[x];
                        //fObjectCenterY = m_objImage1MoldFlashBlobs.ref_arrLimitCenterY[x];
                        intObjectTotalArea += intObjectArea;

                        if (m_objImage1MoldFlashBlobs.ref_arrRectHeight[x] < m_objImage1MoldFlashBlobs.ref_arrRectWidth[x])
                        {
                            fObjectWidth = m_objImage1MoldFlashBlobs.ref_arrRectHeight[x];
                            fObjectHeight = m_objImage1MoldFlashBlobs.ref_arrRectWidth[x];

                            fObjectAngle = m_objImage1MoldFlashBlobs.ref_arrRectAngle[x];

                            if (fObjectAngle >= 10)//&& fAngle <= 80)
                                fObjectAngle = m_objImage1MoldFlashBlobs.ref_arrRectAngle[x] - 90;
                            else
                                fObjectAngle = 90 + m_objImage1MoldFlashBlobs.ref_arrRectAngle[x];

                        }
                        else
                        {
                            fObjectHeight = m_objImage1MoldFlashBlobs.ref_arrRectHeight[x];
                            fObjectWidth = m_objImage1MoldFlashBlobs.ref_arrRectWidth[x];

                            fObjectAngle = m_objImage1MoldFlashBlobs.ref_arrRectAngle[x];

                        }
                        fObjectCenterX = m_objImage1MoldFlashBlobs.ref_arrRectLimitCenterX[x];
                        fObjectCenterY = m_objImage1MoldFlashBlobs.ref_arrRectLimitCenterY[x];

                        float newX1 = 0, newY1 = 0;  // new point 1
                        float newX2 = 0, newY2 = 0; // new point 2
                        float newX3 = 0, newY3 = 0; // new point 3
                        float newX4 = 0, newY4 = 0; // new point 4

                        //2020-12-18 ZJYEOH : Change to this format
                        //  Point 1 *-------------* Point 2
                        //          |             |
                        //          |             |
                        //          |             |
                        //  Point 4 *-------------* Point 3

                        Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX - (fObjectWidth / 2)), (fObjectCenterY - (fObjectHeight / 2)), fObjectAngle, ref newX1, ref newY1);
                        Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX + (fObjectWidth / 2)), (fObjectCenterY - (fObjectHeight / 2)), fObjectAngle, ref newX2, ref newY2);
                        Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX + (fObjectWidth / 2)), (fObjectCenterY + (fObjectHeight / 2)), fObjectAngle, ref newX3, ref newY3);
                        Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX - (fObjectWidth / 2)), (fObjectCenterY + (fObjectHeight / 2)), fObjectAngle, ref newX4, ref newY4);


                        arrRotatedPoints[i][x].Add(new PointF(newX1, newY1));
                        arrRotatedPoints[i][x].Add(new PointF(newX2, newY2));
                        arrRotatedPoints[i][x].Add(new PointF(newX3, newY3));
                        arrRotatedPoints[i][x].Add(new PointF(newX4, newY4));

                        Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX - (fObjectWidth / 2)) - m_intMoldFlashDefectLinkTolerance, (fObjectCenterY - (fObjectHeight / 2)) - m_intMoldFlashDefectLinkTolerance, fObjectAngle, ref newX1, ref newY1);
                        Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX + (fObjectWidth / 2)) + m_intMoldFlashDefectLinkTolerance, (fObjectCenterY - (fObjectHeight / 2)) - m_intMoldFlashDefectLinkTolerance, fObjectAngle, ref newX2, ref newY2);
                        Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX + (fObjectWidth / 2)) + m_intMoldFlashDefectLinkTolerance, (fObjectCenterY + (fObjectHeight / 2)) + m_intMoldFlashDefectLinkTolerance, fObjectAngle, ref newX3, ref newY3);
                        Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX - (fObjectWidth / 2)) - m_intMoldFlashDefectLinkTolerance, (fObjectCenterY + (fObjectHeight / 2)) + m_intMoldFlashDefectLinkTolerance, fObjectAngle, ref newX4, ref newY4);

                        arr2DPoints[i][x].Add(new System.Windows.Point(newX1, newY1));
                        arr2DPoints[i][x].Add(new System.Windows.Point(newX2, newY2));
                        arr2DPoints[i][x].Add(new System.Windows.Point(newX3, newY3));
                        arr2DPoints[i][x].Add(new System.Windows.Point(newX4, newY4));

                        fObjectHeightList[i].Add(fObjectHeight);
                        fObjectWidthList[i].Add(fObjectWidth);
                        fObjectCenterXList[i].Add(fObjectCenterX);
                        fObjectCenterYList[i].Add(fObjectCenterY);
                        fObjectAngleList[i].Add(fObjectAngle);
                        fObjectAreaList[i].Add(intObjectArea);
                        fObjectAreaList2[i].Add(intObjectArea);
                    }
                    int intTolerance = m_intMoldFlashDefectLinkTolerance;
                    int intAngleTolerance = 10;
                    bool blnDecrement = false;
                    if (intTolerance >= 0)
                    {
                        for (int x = 0; x < fObjectHeightList[i].Count; x++)
                        {
                            if (blnDecrement)
                            {
                                blnDecrement = false;
                                if (x > 0)
                                    x--;
                            }
                            for (int j = 0; j < fObjectHeightList[i].Count; j++)
                            {
                                if (x != j && x < fObjectHeightList[i].Count && j < fObjectHeightList[i].Count)
                                {
                                    if (Intersection.CheckRectRectIntersection(arr2DPoints[i][x].ToArray(), arr2DPoints[i][j].ToArray(), intTolerance))
                                    {

                                        PointF[] arrPoints = new PointF[8];

                                        arrPoints[0] = arrRotatedPoints[i][x][0];
                                        arrPoints[1] = arrRotatedPoints[i][x][1];
                                        arrPoints[2] = arrRotatedPoints[i][x][2];
                                        arrPoints[3] = arrRotatedPoints[i][x][3];
                                        arrPoints[4] = arrRotatedPoints[i][j][0];
                                        arrPoints[5] = arrRotatedPoints[i][j][1];
                                        arrPoints[6] = arrRotatedPoints[i][j][2];
                                        arrPoints[7] = arrRotatedPoints[i][j][3];

                                        float fMinAngle = 0;
                                        List<PointF> arrMinRect = new List<PointF>();
                                        arrMinRect = MinimumBoundingBox.CalculateMinimumBoundingBox(arrPoints, ref fMinAngle);

                                        if (fMinAngle < 0)
                                            fObjectAngleList[i][x] = -(90 + fMinAngle);
                                        else
                                            fObjectAngleList[i][x] = 90 - fMinAngle;

                                        Line onjLine1 = new Line();
                                        Line onjLine2 = new Line();
                                        onjLine1.CalculateStraightLine(arrMinRect[0], arrMinRect[2]);
                                        onjLine2.CalculateStraightLine(arrMinRect[1], arrMinRect[3]);
                                        PointF pCenter = Line.GetCrossPoint(onjLine1, onjLine2);
                                        float p1X = 0, p1Y = 0;
                                        float p2X = 0, p2Y = 0;
                                        float p3X = 0, p3Y = 0;
                                        float p4X = 0, p4Y = 0;
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[0].X, arrMinRect[0].Y, -fObjectAngleList[i][x], ref p1X, ref p1Y);
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[1].X, arrMinRect[1].Y, -fObjectAngleList[i][x], ref p2X, ref p2Y);
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[2].X, arrMinRect[2].Y, -fObjectAngleList[i][x], ref p3X, ref p3Y);
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[3].X, arrMinRect[3].Y, -fObjectAngleList[i][x], ref p4X, ref p4Y);

                                        float pR1X = 0, pR1Y = 0;
                                        float pR2X = 0, pR2Y = 0;
                                        float pR3X = 0, pR3Y = 0;
                                        float pR4X = 0, pR4Y = 0;
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)), Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)), fObjectAngleList[i][x], ref pR1X, ref pR1Y); // Top Left
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)), Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)), fObjectAngleList[i][x], ref pR2X, ref pR2Y); // Top Right
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)), Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)), fObjectAngleList[i][x], ref pR3X, ref pR3Y); // Bottom Right
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)), Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)), fObjectAngleList[i][x], ref pR4X, ref pR4Y); // Bottom Left
                                        arrMinRect[0] = new PointF(pR1X, pR1Y);
                                        arrMinRect[1] = new PointF(pR2X, pR2Y);
                                        arrMinRect[2] = new PointF(pR3X, pR3Y);
                                        arrMinRect[3] = new PointF(pR4X, pR4Y);

                                        arrRotatedPoints[i][x][0] = arrMinRect[0];
                                        arrRotatedPoints[i][x][1] = arrMinRect[1];
                                        arrRotatedPoints[i][x][2] = arrMinRect[2];
                                        arrRotatedPoints[i][x][3] = arrMinRect[3];

                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)) - m_intMoldFlashDefectLinkTolerance, Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)) - m_intMoldFlashDefectLinkTolerance, fObjectAngleList[i][x], ref pR1X, ref pR1Y); // Top Left
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)) + m_intMoldFlashDefectLinkTolerance, Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)) - m_intMoldFlashDefectLinkTolerance, fObjectAngleList[i][x], ref pR2X, ref pR2Y); // Top Right
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)) + m_intMoldFlashDefectLinkTolerance, Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)) + m_intMoldFlashDefectLinkTolerance, fObjectAngleList[i][x], ref pR3X, ref pR3Y); // Bottom Right
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)) - m_intMoldFlashDefectLinkTolerance, Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)) + m_intMoldFlashDefectLinkTolerance, fObjectAngleList[i][x], ref pR4X, ref pR4Y); // Bottom Left

                                        arr2DPoints[i][x][0] = new System.Windows.Point(pR1X, pR1Y);
                                        arr2DPoints[i][x][1] = new System.Windows.Point(pR2X, pR2Y);
                                        arr2DPoints[i][x][2] = new System.Windows.Point(pR3X, pR3Y);
                                        arr2DPoints[i][x][3] = new System.Windows.Point(pR4X, pR4Y);

                                        arrRotatedPoints[i].RemoveAt(j);
                                        arr2DPoints[i].RemoveAt(j);

                                        float fDiffX = Math.Max(Math.Abs(p1X - p4X), Math.Abs(p2X - p3X));
                                        float fDiffY = Math.Max(Math.Abs(p3Y - p4Y), Math.Abs(p2Y - p1Y));

                                        fObjectWidthList[i][x] = fDiffX;
                                        fObjectHeightList[i][x] = fDiffY;

                                        fObjectCenterXList[i][x] = pCenter.X;
                                        fObjectCenterYList[i][x] = pCenter.Y;

                                        fObjectAreaList2[i].RemoveAt(j);
                                        fObjectAreaList[i][x] = fObjectAreaList[i][x] + fObjectAreaList[i][j];

                                        fObjectHeightList[i].RemoveAt(j);
                                        fObjectWidthList[i].RemoveAt(j);
                                        fObjectCenterXList[i].RemoveAt(j);
                                        fObjectCenterYList[i].RemoveAt(j);
                                        fObjectAngleList[i].RemoveAt(j);
                                        fObjectAreaList[i].RemoveAt(j);

                                        if (j > 0)
                                            j = -1;
                                        if (x > 0)
                                        {
                                            x = 0;
                                        }
                                        else
                                            blnDecrement = true;

                                    }

                                }
                            }
                        }
                    }
                    for (int x = 0; x < fObjectAreaList[i].Count; x++)
                    {
                        bool blnFail = false;
                        int intFailMask = 0;
                        string strDefectName = "Mold Flash";

                        if (m_arrWantDefectArea[(int)eWantDefect.MoldFlash])
                        {
                            if (fObjectAreaList[i][x] >= GetAreaDefect("MoldFlash"))
                            {
                                //m_strErrorMessage += "*Fail Crack View Package - Cracked. Set = " + (m_arrDefectArea[0] / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                                m_strErrorMessage += "* Mold Flash Area Package Fail. Set = " + (GetAreaDefect("MoldFlash") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (fObjectAreaList[i][x] / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                                blnFail = true;
                                intFailMask |= 0x04;
                                strDefectName = "Mold Flash";
                            }
                        }
                        if (blnFail)
                        {
                            Defect objDefect = new Defect();
                            objDefect.ref_fDimX = fObjectWidthList[i][x];
                            objDefect.ref_fDimY = fObjectHeightList[i][x];
                            objDefect.ref_intLengthMode = 0;
                            objDefect.ref_fArea = fObjectAreaList[i][x];
                            objDefect.ref_fCenterX = intTotalStartX + fObjectCenterXList[i][x];
                            objDefect.ref_fCenterY = intTotalStartY + fObjectCenterYList[i][x];
                            objDefect.ref_fAngle = fObjectAngleList[i][x];
                            objDefect.ref_intBlobNo = i;
                            objDefect.ref_intFailMask = intFailMask;
                            objDefect.ref_strName = strDefectName;
                            objDefect.ref_intFailedImage = intSelectedImageIndex + 1;
                            m_arrDefectList.Add(objDefect);

                            if (!blnOverAllFail)
                                blnOverAllFail = true;
                        }
                        else
                        {
                            Defect objDefect = new Defect();
                            objDefect.ref_fDimX = fObjectWidthList[i][x];
                            objDefect.ref_fDimY = fObjectHeightList[i][x];
                            objDefect.ref_intLengthMode = 0;
                            objDefect.ref_fArea = fObjectAreaList[i][x];
                            objDefect.ref_fCenterX = intTotalStartX + fObjectCenterXList[i][x];
                            objDefect.ref_fCenterY = intTotalStartY + fObjectCenterYList[i][x];
                            objDefect.ref_fAngle = fObjectAngleList[i][x];
                            objDefect.ref_intBlobNo = i;
                            objDefect.ref_intFailMask = 0;
                            objDefect.ref_strName = strDefectName;
                            objDefect.ref_intFailedImage = intSelectedImageIndex + 1; ;
                            m_arrDefectList.Add(objDefect);
                        }

                    }

                    if (m_arrWantDefectArea[(int)eWantDefect.MoldFlash])
                    {
                        if (intObjectTotalArea >= GetTotalAreaDefect("MoldFlash"))
                        {
                            m_strErrorMessage += "* Mold Flash Total Area Fail. Set = " + (GetTotalAreaDefect("MoldFlash") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectTotalArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                            m_blnPkgViewFailTotalArea = true;

                            Defect objDefect = new Defect();
                            objDefect.ref_fDimX = -1;
                            objDefect.ref_fDimY = -1;
                            objDefect.ref_intLengthMode = 0;
                            objDefect.ref_fArea = intObjectTotalArea;
                            objDefect.ref_fCenterX = intTotalStartX + fObjectCenterX;
                            objDefect.ref_fCenterY = intTotalStartY + fObjectCenterY;
                            objDefect.ref_fAngle = fObjectAngle;
                            objDefect.ref_intFailMask |= 0x04;
                            objDefect.ref_strName = "Total Mold Flash";
                            objDefect.ref_intFailedImage = intSelectedImageIndex + 1;
                            m_arrDefectList.Add(objDefect);

                            if (!blnOverAllFail)
                                blnOverAllFail = true;
                        }
                    }
                }

            }
            if (blnOverAllFail)
            {
                m_intPkgFailResultMask |= 0x08;
                return false;
            }
            else
                return true;

        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="intValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        /// <returns></returns>
        public float GetSittingWidthMin(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_fSittingWidthMin * m_fMMToPixelXValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fSittingWidthMin * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="fValue"></param>
        /// <param name="intFromValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        public void SetSittingWidthMin(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                case 0: // Pixel
                    m_fSittingWidthMin = fValue / m_fMMToPixelXValue;
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fSittingWidthMin = fValue / m_fMMToUnitValue;
                    break;
            }
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="intValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        /// <returns></returns>
        public float GetSittingWidthMax(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_fSittingWidthMax * m_fMMToPixelXValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fSittingWidthMax * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="fValue"></param>
        /// <param name="intFromValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        public void SetSittingWidthMax(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                case 0: // Pixel
                    m_fSittingWidthMax = fValue / m_fMMToPixelXValue;
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fSittingWidthMax = fValue / m_fMMToUnitValue;
                    break;
            }
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="intValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        /// <returns></returns>
        public float GetSittingHeightMin(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_fSittingHeightMin * m_fMMToPixelYValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fSittingHeightMin * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="fValue"></param>
        /// <param name="intFromValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        public void SetSittingHeightMin(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                case 0: // Pixel
                    m_fSittingHeightMin = fValue / m_fMMToPixelYValue;
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fSittingHeightMin = fValue / m_fMMToUnitValue;
                    break;
            }
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="intValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        /// <returns></returns>
        public float GetSittingHeightMax(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_fSittingHeightMax * m_fMMToPixelYValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fSittingHeightMax * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="fValue"></param>
        /// <param name="intFromValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        public void SetSittingHeightMax(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                case 0: // Pixel
                    m_fSittingHeightMax = fValue / m_fMMToPixelYValue;
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fSittingHeightMax = fValue / m_fMMToUnitValue;
                    break;
            }
        }

        public bool LearnUnitPRPattern(ROI objROI)
        {
            try
            {
                if (m_objUnitPRMatcher == null)
                    m_objUnitPRMatcher = new EMatcher();
#if (Debug_2_12 || Release_2_12)
                m_objUnitPRMatcher.AdvancedLearning = false; // 2020-09-23 ZJYEOH : If set to true when MIN MAX angle both are same sign(++/--) then will have error
#endif
                m_objUnitPRMatcher.LearnPattern(objROI.ref_ROI);
            }
#if (Debug_2_12 || Release_2_12)
            catch (Euresys.Open_eVision_2_12.EException ex)
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
            catch (Euresys.Open_eVision_1_2.EException ex)
#endif
            {
                m_strErrorMessage = "Package Learn Unit PR Pattern Error: " + ex.ToString();
                return false;
            }
            return true;
        }

        public void SetUnitPRFinalReduction(int intFinalReductionValue)
        {
            if (intFinalReductionValue > 3)
                return;
#if (Debug_2_12 || Release_2_12)
            m_objUnitPRMatcher.FinalReduction = (uint)intFinalReductionValue;
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
            m_objUnitPRMatcher.FinalReduction = intFinalReductionValue;
#endif

        }

        public void SetUnitPRAngleSetting(int intMinAngle, int intMaxAngle)
        {
            m_objUnitPRMatcher.MinAngle = intMinAngle;
            m_objUnitPRMatcher.MaxAngle = intMaxAngle;
        }

        public void SaveUnitPRPattern(string strFilePath)
        {
            string strDirectory = Path.GetDirectoryName(strFilePath);
            if (!Directory.Exists(strDirectory))
                Directory.CreateDirectory(strDirectory);
            m_objUnitPRMatcher.Save(strFilePath);
        }

        public void LoadUnitPRPattern(string strFilePath)
        {
            try
            {
                if (m_objUnitPRMatcher == null)
                    m_objUnitPRMatcher = new EMatcher();

                if (File.Exists(strFilePath))
                    m_objUnitPRMatcher.Load(strFilePath);
            }
            catch
            {
                m_strErrorMessage = "Package - Unit PR Pattern file is not found";
            }
        }

        public bool MatchWithTemplateUnitPR(ROI objSearchROI)
        {
            if (!m_objUnitPRMatcher.PatternLearnt)
                return false;

            m_objUnitPRMatcher.Match(objSearchROI.ref_ROI);

            if (m_objUnitPRMatcher.NumPositions > 0 && m_objUnitPRMatcher.GetPosition(0).Score > 0.5)     // if macthing result hit the min score, its position will be 1 or more
            {
                return true;
            }

            return false;
        }

        public float GetUnitPRResultCenterX()
        {
            if (m_objUnitPRMatcher.NumPositions > 0)     // if macthing result hit the min score, its position will be 1 or more
            {
                return m_objUnitPRMatcher.GetPosition(0).CenterX;
            }
            else
                return 0;
        }

        public float GetUnitPRResultCenterY()
        {
            if (m_objUnitPRMatcher.NumPositions > 0)     // if macthing result hit the min score, its position will be 1 or more
            {
                return m_objUnitPRMatcher.GetPosition(0).CenterY;
            }
            else
                return 0;
        }

        public int GetUnitPRWidth()
        {
            if (!m_objUnitPRMatcher.PatternLearnt)
                return 0;

            return m_objUnitPRMatcher.PatternWidth;
        }

        public int GetUnitPRHeight()
        {
            if (!m_objUnitPRMatcher.PatternLearnt)
                return 0;

            return m_objUnitPRMatcher.PatternHeight;
        }

        public float GetUnitAngleMax()
        {
            return m_fUnitAngleMax;
        }

        public void SetUnitAngleMax(float fValue)
        {
            m_fUnitAngleMax = fValue;
        }

        public float GetResultAngle()
        {
            return m_fPackageResultAngle;
        }

        public void DrawGrayValueSensitivity(int intSelectedImage, ref ROI objROI, int intInspectionAreaGrayValueSensitivity, int intMergeSensitivity, bool blnViewThreshold, int intBrightSensitivity, int intDarkSensitivity, ref float fFinalAverageGrayValue)
        {
            if (objROI == null)
                return;
            if (intSelectedImage == 0)
            {
                // 2020-05-15 ZJYEOH : New Inspection Method using gray value
                // Step 1 : Get average gray value of package surface area
                float fAverageGrayValue = 0;
                EasyImage.PixelAverage(objROI.ref_ROI, out fAverageGrayValue);

                // Step 2 : declare another ROI and threshold it using (average gray value + sensitivity)
                ROI objThresholdROI = new ROI();
                objThresholdROI.LoadROISetting(0, 0, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
                ImageDrawing objImage = new ImageDrawing();
                ImageDrawing objTempImage = new ImageDrawing();
                objROI.CopyToImage(ref objImage);
                objROI.CopyToImage(ref objTempImage);
                objThresholdROI.AttachImage(objImage);
                int intThreshold = (int)Math.Round(fAverageGrayValue) + intInspectionAreaGrayValueSensitivity;
                if (intThreshold > 255)
                    intThreshold = 255;
#if (Debug_2_12 || Release_2_12)
                //objROI.ref_ROI.Save("D:\\objROI1.bmp");
                //objThresholdROI.ref_ROI.Save("D:\\objThresholdROI1.bmp");
                EasyImage.Threshold(objThresholdROI.ref_ROI, objThresholdROI.ref_ROI, (uint)intThreshold);
                //objROI.ref_ROI.Save("D:\\objROI2.bmp");
                //objThresholdROI.ref_ROI.Save("D:\\objThresholdROI2.bmp");
                // Step 3 : invert the thrshold ROI 
                //EasyImage.Oper(EArithmeticLogicOperation.Invert, objThresholdROI.ref_ROI, objThresholdROI.ref_ROI);
                ROI.InvertOperationROI(objThresholdROI);
                //objROI.ref_ROI.Save("D:\\objROI3.bmp");
                //objThresholdROI.ref_ROI.Save("D:\\objThresholdROI3.bmp");
                // Step 4 : Subtract Original ROI with inverted threshold ROI will result defect above the threshold value only
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objROI.ref_ROI, objThresholdROI.ref_ROI, objROI.ref_ROI);
                //objROI.ref_ROI.Save("D:\\objROI4.bmp");
                //objThresholdROI.ref_ROI.Save("D:\\objThresholdROI4.bmp");
                // Step 5 : using Close morphology to link the small defect together using sensitivity set by user
                EasyImage.CloseDisk(objROI.ref_ROI, objROI.ref_ROI, (uint)intMergeSensitivity);
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                //objROI.ref_ROI.Save("D:\\objROI1.bmp");
                //objThresholdROI.ref_ROI.Save("D:\\objThresholdROI1.bmp");
                EasyImage.Threshold(objThresholdROI.ref_ROI, objThresholdROI.ref_ROI, intThreshold);
                //objROI.ref_ROI.Save("D:\\objROI2.bmp");
                //objThresholdROI.ref_ROI.Save("D:\\objThresholdROI2.bmp");
                // Step 3 : invert the thrshold ROI 
                //EasyImage.Oper(EArithmeticLogicOperation.Invert, objThresholdROI.ref_ROI, objThresholdROI.ref_ROI);
                ROI.InvertOperationROI(objThresholdROI);
                //objROI.ref_ROI.Save("D:\\objROI3.bmp");
                //objThresholdROI.ref_ROI.Save("D:\\objThresholdROI3.bmp");
                // Step 4 : Subtract Original ROI with inverted threshold ROI will result defect above the threshold value only
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objROI.ref_ROI, objThresholdROI.ref_ROI, objROI.ref_ROI);
                //objROI.ref_ROI.Save("D:\\objROI4.bmp");
                //objThresholdROI.ref_ROI.Save("D:\\objThresholdROI4.bmp");
                // Step 5 : using Close morphology to link the small defect together using sensitivity set by user
                EasyImage.CloseDisk(objROI.ref_ROI, objROI.ref_ROI, intMergeSensitivity);
#endif

                //objROI.ref_ROI.Save("D:\\objROI5.bmp");
                //objThresholdROI.ref_ROI.Save("D:\\objThresholdROI5.bmp");
                // Step 6 : Get average gray value of the final ROI
                ROI objTempROI = new ROI();
                objTempROI.LoadROISetting(0, 0, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
                objTempROI.AttachImage(objTempImage);
                fAverageGrayValue = 0;
                EasyImage.PixelAverage(objTempROI.ref_ROI, objThresholdROI.ref_ROI, out fAverageGrayValue);
                //objTempROI.ref_ROI.Save("D:\\objTempROI1.bmp");

                objThresholdROI.Dispose();
                objTempROI.Dispose();
                objImage.Dispose();
                objTempImage.Dispose();

                fFinalAverageGrayValue = (float)Math.Round(fAverageGrayValue);
                if (blnViewThreshold)
                {
                    intThreshold = (int)Math.Round(fAverageGrayValue) + intBrightSensitivity;
                    if (intThreshold > 255)
                        intThreshold = 255;
#if (Debug_2_12 || Release_2_12)
                    EasyImage.Threshold(objROI.ref_ROI, objROI.ref_ROI, (uint)intThreshold);
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                    EasyImage.Threshold(objROI.ref_ROI, objROI.ref_ROI, intThreshold);
#endif

                }
            }
            else
            {
                // 2020-05-15 ZJYEOH : New Inspection Method using gray value
                // Step 1 : Get average gray value of package surface area
                float fAverageGrayValue = 0;
                EasyImage.PixelAverage(objROI.ref_ROI, out fAverageGrayValue);

                // Step 2 : declare another ROI and threshold it using (average gray value - sensitivity)
                ROI objThresholdROI = new ROI();
                objThresholdROI.LoadROISetting(0, 0, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
                ImageDrawing objImage = new ImageDrawing();
                ImageDrawing objTempImage = new ImageDrawing();
                objROI.CopyToImage(ref objTempImage);
                objROI.CopyToImage(ref objImage);
                objThresholdROI.AttachImage(objImage);
                int intLowThreshold = (int)Math.Round(fAverageGrayValue) - intInspectionAreaGrayValueSensitivity;
                if (intLowThreshold < 0)
                    intLowThreshold = 0;
#if (Debug_2_12 || Release_2_12)
                //objROI.ref_ROI.Save("D:\\objROI1.bmp");
                //objThresholdROI.ref_ROI.Save("D:\\objThresholdROI1.bmp");
                EasyImage.DoubleThreshold(objThresholdROI.ref_ROI, objThresholdROI.ref_ROI, (uint)intLowThreshold, 255, 0, 255, 0);
                //objROI.ref_ROI.Save("D:\\objROI2.bmp");
                //objThresholdROI.ref_ROI.Save("D:\\objThresholdROI2.bmp");
                //for Dark Defect, no need invert
                //// Step 3 : invert the thrshold ROI 
                //EasyImage.Oper(EArithmeticLogicOperation.Invert, objThresholdROI.ref_ROI, objThresholdROI.ref_ROI);

                // Step 4 : Add Original ROI with inverted threshold ROI will result defect below the threshold value only
                EasyImage.Oper(EArithmeticLogicOperation.Add, objROI.ref_ROI, objThresholdROI.ref_ROI, objROI.ref_ROI);
                //objROI.ref_ROI.Save("D:\\objROI3.bmp");
                //objThresholdROI.ref_ROI.Save("D:\\objThresholdROI3.bmp");
                // Step 5 : using Open morphology to link the small defect together using sensitivity set by user
                EasyImage.OpenDisk(objROI.ref_ROI, objROI.ref_ROI, (uint)intMergeSensitivity);
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                //objROI.ref_ROI.Save("D:\\objROI1.bmp");
                //objThresholdROI.ref_ROI.Save("D:\\objThresholdROI1.bmp");
                EasyImage.DoubleThreshold(objThresholdROI.ref_ROI, objThresholdROI.ref_ROI, intLowThreshold, 255, 0, 255, 0);
                //objROI.ref_ROI.Save("D:\\objROI2.bmp");
                //objThresholdROI.ref_ROI.Save("D:\\objThresholdROI2.bmp");
                //for Dark Defect, no need invert
                //// Step 3 : invert the thrshold ROI 
                //EasyImage.Oper(EArithmeticLogicOperation.Invert, objThresholdROI.ref_ROI, objThresholdROI.ref_ROI);

                // Step 4 : Add Original ROI with inverted threshold ROI will result defect below the threshold value only
                EasyImage.Oper(EArithmeticLogicOperation.Add, objROI.ref_ROI, objThresholdROI.ref_ROI, objROI.ref_ROI);
                //objROI.ref_ROI.Save("D:\\objROI3.bmp");
                //objThresholdROI.ref_ROI.Save("D:\\objThresholdROI3.bmp");
                // Step 5 : using Open morphology to link the small defect together using sensitivity set by user
                EasyImage.OpenDisk(objROI.ref_ROI, objROI.ref_ROI, intMergeSensitivity);
#endif

                //objROI.ref_ROI.Save("D:\\objROI4.bmp");
                //objThresholdROI.ref_ROI.Save("D:\\objThresholdROI4.bmp");
                // Step 6 : Get average gray value of the final ROI
                //fAverageGrayValue = 0;
                //EasyImage.PixelAverage(objROI.ref_ROI, out fAverageGrayValue);
                ROI objTempROI = new ROI();
                objTempROI.LoadROISetting(0, 0, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
                objTempROI.AttachImage(objTempImage);
                fAverageGrayValue = 0;
                EasyImage.PixelAverage(objTempROI.ref_ROI, objThresholdROI.ref_ROI, out fAverageGrayValue);
                //objTempROI.ref_ROI.Save("D:\\objTempROI1.bmp");

                objThresholdROI.Dispose();
                objImage.Dispose();
                fFinalAverageGrayValue = (float)Math.Round(fAverageGrayValue);
                if (blnViewThreshold)
                {
                    intLowThreshold = (int)Math.Round(fAverageGrayValue) - intDarkSensitivity;
                    if (intLowThreshold < 0)
                        intLowThreshold = 0;
#if (Debug_2_12 || Release_2_12)
                    EasyImage.DoubleThreshold(objROI.ref_ROI, objROI.ref_ROI, (uint)intLowThreshold, 255, 0, 255, 0);
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                    EasyImage.DoubleThreshold(objROI.ref_ROI, objROI.ref_ROI, intLowThreshold, 255, 0, 255, 0);
#endif

                }
            }

        }
        private void CheckIsAreaMoreThanChipToleranceSetting(int intObjectArea, ref int intFailMask, ref bool blnDefect, ref bool blnChipped, int intSelectedImageIndex)
        {
            if (m_arrWantDefectArea[(int)eWantDefect.Chip])
            {
                if (intObjectArea >= GetAreaDefect("Chip"))  // Is Chipped over setting min value
                {
                    intFailMask |= 0x04;
                    blnDefect = true;
                    blnChipped = true;

                    m_strErrorMessage += "*Chipped Off Area Fail (Img " + (intSelectedImageIndex + 1).ToString() + "). Set = " + (GetAreaDefect("Chip") / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2,   Result = " + (intObjectArea / m_fMMtoPixelAreaValue).ToString("f5") + " mm^2";
                }
                else
                {
                    intFailMask |= 0;
                    blnDefect = true;
                    blnChipped = true;
                }
            }
        }
        public int SelectColorDefectObject(int intOrgX, int intOrgY)
        {
            int intMatchNo = -1;

            if (m_arrColorDefectList != null)
            {
                for (int i = 0; i < m_arrColorDefectList.Count; i++)
                {
                    if ((intOrgX >= m_arrColorDefectList[i].ref_fStartX && intOrgX <= m_arrColorDefectList[i].ref_fEndX &&
                        (intOrgY >= m_arrColorDefectList[i].ref_fStartY && intOrgY <= (m_arrColorDefectList[i].ref_fEndY))))
                        intMatchNo = i;
                }
            }

            return intMatchNo;
        }
        public List<List<string>> GetColorDefectList()
        {
            List<List<string>> arrDefectList = new List<List<string>>();

            int intCount = 0;

            for (int i = 0; i < m_arrColorDefectList.Count; i++)
            {
                arrDefectList.Add(new List<string>());
                arrDefectList[intCount].Add(m_arrColorDefectList[i].ref_intFailCriteria.ToString());
                arrDefectList[intCount].Add(m_arrColorDefectList[i].ref_strName);
                arrDefectList[intCount].Add(m_arrColorDefectList[i].ref_fWidthInMM.ToString("F4"));
                arrDefectList[intCount].Add(m_arrColorDefectList[i].ref_fHeightInMM.ToString("F4"));
                arrDefectList[intCount].Add(m_arrColorDefectList[i].ref_fAreaInMM2.ToString("F6"));
                arrDefectList[intCount].Add(m_arrColorDefectList[i].ref_intImageNo.ToString());
                intCount++;
            }

            return arrDefectList;
        }
        public int GetColorDefectListCount()
        {
            return m_arrColorDefectList.Count;
        }
        public void ResetColorThresholdData()
        {
            m_arrDefectColorThresName.Clear();
            m_arrDefectColorSystem.Clear();
            m_arrDefectCloseIteration.Clear();
            m_arrDefectInvertBlackWhite.Clear();
            m_arrDefectColor.Clear();
            m_arrDefectColorTolerance.Clear();
            m_arrDefectColorMinArea.Clear();
            m_arrDefectType.Clear();
            m_arrDefectImageNo.Clear();
            m_arrDefectDontCareMode.Clear();
            m_arrDefectColorInspection_Top.Clear();
            m_arrDefectColorInspection_Right.Clear();
            m_arrDefectColorInspection_Bottom.Clear();
            m_arrDefectColorInspection_Left.Clear();
            m_arrDefectColorInspectionFailCondition.Clear();
            m_arrDefectColorInspectionWidth.Clear();
            m_arrDefectColorInspectionLength.Clear();
            m_arrDefectColorInspectionMinArea.Clear();
            m_arrDefectColorInspectionMaxArea.Clear();
            m_arrDefectColorInspectionTotalArea.Clear();
        }
        public bool AddColorThresholdData(string strDefectThresName, int intDefectSystemColor, int intDefectCloseIteration, bool blnDefectInvertBlackWhite,
                                                       int intColorThreshold1, int intColorThreshold2, int intColorThreshold3,
                                                       int intColorThresholdTolerance1, int intColorThresholdTolerance2, int intColorThresholdTolerance3,
                                                       int intDefectMinArea, int intDefectType, int intDefectImageNo, int intDontCareMode,
                                                       int intDefectColorInspection_Top, int intDefectColorInspection_Right, int intDefectColorInspection_Bottom, int intDefectColorInspection_Left)
        {
            try
            {
                m_arrDefectColorThresName.Add(strDefectThresName);
                m_arrDefectColorSystem.Add(intDefectSystemColor);
                m_arrDefectCloseIteration.Add(intDefectCloseIteration);
                m_arrDefectInvertBlackWhite.Add(blnDefectInvertBlackWhite);

                int intIndex = m_arrDefectColor.Count;
                m_arrDefectColor.Add(new int[3]);
                m_arrDefectColor[intIndex][0] = intColorThreshold1;
                m_arrDefectColor[intIndex][1] = intColorThreshold2;
                m_arrDefectColor[intIndex][2] = intColorThreshold3;

                m_arrDefectColorTolerance.Add(new int[3]);
                m_arrDefectColorTolerance[intIndex][0] = intColorThresholdTolerance1;
                m_arrDefectColorTolerance[intIndex][1] = intColorThresholdTolerance2;
                m_arrDefectColorTolerance[intIndex][2] = intColorThresholdTolerance3;

                m_arrDefectColorMinArea.Add(intDefectMinArea);

                m_arrDefectType.Add(intDefectType);
                m_arrDefectImageNo.Add(intDefectImageNo);
                m_arrDefectDontCareMode.Add(intDontCareMode);
                m_arrDefectColorInspection_Top.Add(intDefectColorInspection_Top);
                m_arrDefectColorInspection_Right.Add(intDefectColorInspection_Right);
                m_arrDefectColorInspection_Bottom.Add(intDefectColorInspection_Bottom);
                m_arrDefectColorInspection_Left.Add(intDefectColorInspection_Left);

                m_arrDefectColorInspectionFailCondition.Add(0);
                m_arrDefectColorInspectionWidth.Add(0);
                m_arrDefectColorInspectionLength.Add(0);
                m_arrDefectColorInspectionMinArea.Add(0);
                m_arrDefectColorInspectionMaxArea.Add(0);
                m_arrDefectColorInspectionTotalArea.Add(0);
                return true;
            }
            catch
            {
                return false;
            }
        }
        public bool AddColorThresholdData(string strDefectThresName, int intDefectSystemColor, int intDefectCloseIteration, bool blnDefectInvertBlackWhite,
                                               int intColorThreshold1, int intColorThreshold2, int intColorThreshold3,
                                               int intColorThresholdTolerance1, int intColorThresholdTolerance2, int intColorThresholdTolerance3,
                                               int intDefectMinArea, int intDefectType, int intDefectImageNo, int intDontCareMode, int intInspectionFailCondition,
                                               float m_intInspectWidth, float m_intInspectLength, float m_intInspectMinArea, float m_intInspectMaxArea, float m_intInspectTotalArea,
                                               int intDefectColorInspection_Top, int intDefectColorInspection_Right, int intDefectColorInspection_Bottom, int intDefectColorInspection_Left)
        {
            try
            {
                m_arrDefectColorThresName.Add(strDefectThresName);
                m_arrDefectColorSystem.Add(intDefectSystemColor);
                m_arrDefectCloseIteration.Add(intDefectCloseIteration);
                m_arrDefectInvertBlackWhite.Add(blnDefectInvertBlackWhite);

                int intIndex = m_arrDefectColor.Count;
                m_arrDefectColor.Add(new int[3]);
                m_arrDefectColor[intIndex][0] = intColorThreshold1;
                m_arrDefectColor[intIndex][1] = intColorThreshold2;
                m_arrDefectColor[intIndex][2] = intColorThreshold3;

                m_arrDefectColorTolerance.Add(new int[3]);
                m_arrDefectColorTolerance[intIndex][0] = intColorThresholdTolerance1;
                m_arrDefectColorTolerance[intIndex][1] = intColorThresholdTolerance2;
                m_arrDefectColorTolerance[intIndex][2] = intColorThresholdTolerance3;

                m_arrDefectColorMinArea.Add(intDefectMinArea);

                m_arrDefectType.Add(intDefectType);
                m_arrDefectImageNo.Add(intDefectImageNo);
                m_arrDefectDontCareMode.Add(intDontCareMode);
                m_arrDefectColorInspection_Top.Add(intDefectColorInspection_Top);
                m_arrDefectColorInspection_Right.Add(intDefectColorInspection_Right);
                m_arrDefectColorInspection_Bottom.Add(intDefectColorInspection_Bottom);
                m_arrDefectColorInspection_Left.Add(intDefectColorInspection_Left);

                m_arrDefectColorInspectionFailCondition.Add(intInspectionFailCondition);
                m_arrDefectColorInspectionWidth.Add(m_intInspectWidth);
                m_arrDefectColorInspectionLength.Add(m_intInspectLength);
                m_arrDefectColorInspectionMinArea.Add(m_intInspectMinArea);
                m_arrDefectColorInspectionMaxArea.Add(m_intInspectMaxArea);
                m_arrDefectColorInspectionTotalArea.Add(m_intInspectTotalArea);
                return true;
            }
            catch
            {
                return false;
            }
        }
        public void DeleteColorThresholdData(int intIndex)
        {
            try
            {
                m_arrDefectColorThresName.RemoveAt(intIndex);
                m_arrDefectColorSystem.RemoveAt(intIndex);
                m_arrDefectCloseIteration.RemoveAt(intIndex);
                m_arrDefectInvertBlackWhite.RemoveAt(intIndex);

                m_arrDefectColor.RemoveAt(intIndex);

                m_arrDefectColorTolerance.RemoveAt(intIndex);

                m_arrDefectColorMinArea.RemoveAt(intIndex);

                m_arrDefectType.RemoveAt(intIndex);
                m_arrDefectImageNo.RemoveAt(intIndex);
                m_arrDefectDontCareMode.RemoveAt(intIndex);
                m_arrDefectColorInspection_Top.RemoveAt(intIndex);
                m_arrDefectColorInspection_Right.RemoveAt(intIndex);
                m_arrDefectColorInspection_Bottom.RemoveAt(intIndex);
                m_arrDefectColorInspection_Left.RemoveAt(intIndex);

                m_arrDefectColorInspectionFailCondition.RemoveAt(intIndex);
                m_arrDefectColorInspectionWidth.RemoveAt(intIndex);
                m_arrDefectColorInspectionLength.RemoveAt(intIndex);
                m_arrDefectColorInspectionMinArea.RemoveAt(intIndex);
                m_arrDefectColorInspectionMaxArea.RemoveAt(intIndex);
                m_arrDefectColorInspectionTotalArea.RemoveAt(intIndex);

            }
            catch
            {

            }
        }
        public float GetColorDefectInspectionLengthLimit(int intValueType, int intIndex)
        {
            if (m_arrDefectColorInspectionLength.Count > intIndex)
            {
                switch (intValueType)
                {
                    case -1: // Pixel X
                        return m_arrDefectColorInspectionLength[intIndex] * m_fMMToPixelXValue;
                    case -2: // Pixel Y
                        return m_arrDefectColorInspectionLength[intIndex] * m_fMMToPixelYValue;
                    case 1: // mm
                    case 2: // mil
                    case 3: // micron
                        return m_arrDefectColorInspectionLength[intIndex] * m_fMMToUnitValue;
                    default:
                        return 0;
                }
            }
            else
                return 0;
        }

        public int GetColorDefectInspection_Top(int intIndex)
        {
            if (m_arrDefectColorInspection_Top.Count > intIndex && intIndex != -1)
            {
                return m_arrDefectColorInspection_Top[intIndex];
            }
            else
                return 0;
        }
        public int GetColorDefectInspection_Right(int intIndex)
        {
            if (m_arrDefectColorInspection_Right.Count > intIndex && intIndex != -1)
            {
                return m_arrDefectColorInspection_Right[intIndex];
            }
            else
                return 0;
        }
        public int GetColorDefectInspection_Bottom(int intIndex)
        {
            if (m_arrDefectColorInspection_Bottom.Count > intIndex && intIndex != -1)
            {
                return m_arrDefectColorInspection_Bottom[intIndex];
            }
            else
                return 0;
        }
        public int GetColorDefectInspection_Left(int intIndex)
        {
            if (m_arrDefectColorInspection_Left.Count > intIndex && intIndex != -1)
            {
                return m_arrDefectColorInspection_Left[intIndex];
            }
            else
                return 0;
        }
        public int GetColorDefectInspectionFailCondition(int intIndex)
        {
            if (m_arrDefectColorInspectionFailCondition.Count > intIndex && intIndex != -1)
            {
                return m_arrDefectColorInspectionFailCondition[intIndex];
            }
            else
                return 0;
        }
        
        public float GetColorDefectInspectionWidthLimit(int intValueType, int intIndex)
        {
            if (m_arrDefectColorInspectionWidth.Count > intIndex)
            {
                switch (intValueType)
                {
                    case -1: // Pixel X
                        return m_arrDefectColorInspectionWidth[intIndex] * m_fMMToPixelXValue;
                    case -2: // Pixel Y
                        return m_arrDefectColorInspectionWidth[intIndex] * m_fMMToPixelYValue;
                    case 1: // mm
                    case 2: // mil
                    case 3: // micron
                        return m_arrDefectColorInspectionWidth[intIndex] * m_fMMToUnitValue;
                    default:
                        return 0;
                }
            }
            else
                return 0;
        }
        public float GetColorDefectInspectionMinAreaLimit(int intValueType, int intIndex)
        {
            if (m_arrDefectType.Count > intIndex)
            {
                if (m_arrDefectType[intIndex] == 0)
                {
                    return 0;
                }
            }

            if (m_arrDefectColorInspectionMinArea.Count > intIndex)
            {
                switch (intValueType)
                {
                    case 0: // Pixel
                        return m_arrDefectColorInspectionMinArea[intIndex] * m_fMMtoPixelAreaValue;
                    case 1: // mm
                    case 2: // mil
                    case 3: // micron
                        return m_arrDefectColorInspectionMinArea[intIndex] * m_fMMToUnitValueArea;
                    default:
                        return 0;
                }
            }
            else
                return 0;
        }
        public float GetColorDefectInspectionMaxAreaLimit(int intValueType, int intIndex)
        {
            if (m_arrDefectColorInspectionMaxArea.Count > intIndex)
            {
                switch (intValueType)
                {
                    case 0: // Pixel
                        return m_arrDefectColorInspectionMaxArea[intIndex] * m_fMMtoPixelAreaValue;
                    case 1: // mm
                    case 2: // mil
                    case 3: // micron
                        return m_arrDefectColorInspectionMaxArea[intIndex] * m_fMMToUnitValueArea;
                    default:
                        return 0;
                }
            }
            else
                return 0;
        }

        public float GetColorDefectInspectionTotalAreaLimit(int intValueType, int intIndex)
        {
            if (m_arrDefectColorInspectionTotalArea.Count > intIndex)
            {
                switch (intValueType)
                {
                    case 0: // Pixel
                        return m_arrDefectColorInspectionTotalArea[intIndex] * m_fMMtoPixelAreaValue;
                    case 1: // mm
                    case 2: // mil
                    case 3: // micron
                        return m_arrDefectColorInspectionTotalArea[intIndex] * m_fMMToUnitValueArea;
                    default:
                        return 0;
                }
            }
            else
                return 0;
        }
        public void SetColorDefectInspectionLengthLimit(float fValue, int intFromValueType, int intIndex)
        {
            if (m_arrDefectColorInspectionLength.Count > intIndex)
            {
                switch (intFromValueType)
                {
                    //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                    //case 0: // Pixel X
                    //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                    //    break;
                    //case 1: // Pixel Y
                    //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                    //    break;
                    case 1: // mm
                    case 2: // mil
                    case 3: // micron
                    default:
                        m_arrDefectColorInspectionLength[intIndex] = fValue / m_fMMToUnitValue;
                        break;
                }
            }
        }
        public void SetColorDefectInspectionFailCondition(int intValue, int intIndex)
        {
            if (m_arrDefectColorInspectionFailCondition.Count > intIndex)
            {
                m_arrDefectColorInspectionLength[intIndex] = intValue;
            }
        }
        
        public void SetColorDefectInspectionWidthLimit(float fValue, int intFromValueType, int intIndex)
        {
            if (m_arrDefectColorInspectionWidth.Count > intIndex)
            {
                switch (intFromValueType)
                {
                    //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                    //case 0: // Pixel X
                    //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                    //    break;
                    //case 1: // Pixel Y
                    //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                    //    break;
                    case 1: // mm
                    case 2: // mil
                    case 3: // micron
                    default:
                        m_arrDefectColorInspectionWidth[intIndex] = fValue / m_fMMToUnitValue;
                        break;
                }
            }
        }
        public void SetColorDefectInspectionMinAreaLimit(float fValue, int intFromValueType, int intIndex)
        {
            if (m_arrDefectColorInspectionMinArea.Count > intIndex)
            {
                switch (intFromValueType)
                {
                    //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                    //case 0: // Pixel X
                    //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                    //    break;
                    //case 1: // Pixel Y
                    //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                    //    break;
                    case 1: // mm
                    case 2: // mil
                    case 3: // micron
                    default:
                        m_arrDefectColorInspectionMinArea[intIndex] = fValue / m_fMMToUnitValueArea;
                        break;
                }
            }
        }
        public void SetColorDefectInspectionMaxAreaLimit(float fValue, int intFromValueType, int intIndex)
        {
            if (m_arrDefectColorInspectionMaxArea.Count > intIndex)
            {
                switch (intFromValueType)
                {
                    //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                    //case 0: // Pixel X
                    //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                    //    break;
                    //case 1: // Pixel Y
                    //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                    //    break;
                    case 1: // mm
                    case 2: // mil
                    case 3: // micron
                    default:
                        m_arrDefectColorInspectionMaxArea[intIndex] = fValue / m_fMMToUnitValueArea;
                        break;
                }
            }
        }

        public void SetColorDefectInspectionTotalAreaLimit(float fValue, int intFromValueType, int intIndex)
        {
            if (m_arrDefectColorInspectionTotalArea.Count > intIndex)
            {
                switch (intFromValueType)
                {
                    //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                    //case 0: // Pixel X
                    //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                    //    break;
                    //case 1: // Pixel Y
                    //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                    //    break;
                    case 1: // mm
                    case 2: // mil
                    case 3: // micron
                    default:
                        m_arrDefectColorInspectionTotalArea[intIndex] = fValue / m_fMMToUnitValueArea;
                        break;
                }
            }
        }
        public void SetColorDefectInspectionLengthLimit(float fValue, int intFromValueType, string strName)
        {
            for (int i = 0; i < m_arrDefectColorInspectionLength.Count; i++)
            {
                if (m_arrDefectColorThresName.Count > i && m_arrDefectColorThresName[i] == strName)
                {
                    switch (intFromValueType)
                    {
                        //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                        //case 0: // Pixel X
                        //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                        //    break;
                        //case 1: // Pixel Y
                        //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                        //    break;
                        case 1: // mm
                        case 2: // mil
                        case 3: // micron
                        default:
                            m_arrDefectColorInspectionLength[i] = fValue / m_fMMToUnitValue;
                            break;
                    }
                }
            }
        }

        public void SetColorDefectInspectionFailCondition(int intValue, string strName)
        {
            for (int i = 0; i < m_arrDefectColorInspectionFailCondition.Count; i++)
            {
                if (m_arrDefectColorThresName.Count > i && m_arrDefectColorThresName[i] == strName)
                {
                    m_arrDefectColorInspectionFailCondition[i] = intValue;
                }
            }
        }
        public void SetColorDefectInspectionWidthLimit(float fValue, int intFromValueType, string strName)
        {
            for (int i = 0; i < m_arrDefectColorInspectionWidth.Count; i++)
            {
                if (m_arrDefectColorThresName.Count > i && m_arrDefectColorThresName[i] == strName)
                {
                    switch (intFromValueType)
                    {
                        //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                        //case 0: // Pixel X
                        //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                        //    break;
                        //case 1: // Pixel Y
                        //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                        //    break;
                        case 1: // mm
                        case 2: // mil
                        case 3: // micron
                        default:
                            m_arrDefectColorInspectionWidth[i] = fValue / m_fMMToUnitValue;
                            break;
                    }
                }
            }
        }
        public void SetColorDefectInspectionMinAreaLimit(float fValue, int intFromValueType, string strName)
        {
            for (int i = 0; i < m_arrDefectColorInspectionMinArea.Count; i++)
            {
                if (m_arrDefectColorThresName.Count > i && m_arrDefectColorThresName[i] == strName)
                {
                    switch (intFromValueType)
                    {
                        //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                        //case 0: // Pixel X
                        //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                        //    break;
                        //case 1: // Pixel Y
                        //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                        //    break;
                        case 1: // mm
                        case 2: // mil
                        case 3: // micron
                        default:
                            m_arrDefectColorInspectionMinArea[i] = fValue / m_fMMToUnitValueArea;
                            break;
                    }
                }
            }
        }
        public void SetColorDefectInspectionMaxAreaLimit(float fValue, int intFromValueType, string strName)
        {
            for (int i = 0; i < m_arrDefectColorInspectionMaxArea.Count; i++)
            {
                if (m_arrDefectColorThresName.Count > i && m_arrDefectColorThresName[i] == strName)
                {
                    switch (intFromValueType)
                    {
                        //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                        //case 0: // Pixel X
                        //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                        //    break;
                        //case 1: // Pixel Y
                        //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                        //    break;
                        case 1: // mm
                        case 2: // mil
                        case 3: // micron
                        default:
                            m_arrDefectColorInspectionMaxArea[i] = fValue / m_fMMToUnitValueArea;
                            break;
                    }
                }
            }
        }
        public void DrawColorDefect(Graphics g, float fDrawingScaleX, float fDrawingScaleY, int intDefectSelectingNumber, float fGaugeCenterX, float fGaugeCenterY, float fGaugeAngle)
        {
            if (intDefectSelectingNumber >= m_arrColorDefectList.Count)
            {
                return;
            }

            Pen pen = new Pen(Color.Red, 1);
            Pen penLime = new Pen(Color.Lime, 1);

            if (intDefectSelectingNumber >= 0 && intDefectSelectingNumber < m_arrColorDefectList.Count)
            {
                ColorDefect objDefect = (ColorDefect)m_arrColorDefectList[intDefectSelectingNumber];
                int loop = 0, start = 0;
                bool bln_failTotalArea = false;
                string strFailTotalAreaDefectName = "";

                if (objDefect.ref_intFailCriteria > 0 && objDefect.ref_fWidth == -1 && objDefect.ref_fHeight == -1) //fail total area
                {
                    strFailTotalAreaDefectName = objDefect.ref_strName;
                    if (loop == 0)
                    {
                        loop = intDefectSelectingNumber;
                        start = 0;
                        bln_failTotalArea = true;
                    }
                    else
                    {
                        start = loop + 1;
                        loop = intDefectSelectingNumber;
                        bln_failTotalArea = true;
                    }
                }

                if (objDefect.ref_fWidth == -1 && objDefect.ref_fHeight == -1 && !bln_failTotalArea)
                {
                    return;
                }

                if (bln_failTotalArea)
                {
                    for (int i = start; i < loop; i++)
                    {
                        if (intDefectSelectingNumber >= m_arrColorDefectList.Count)
                            continue;

                        objDefect = (ColorDefect)m_arrColorDefectList[i];
                        float newX1 = 0, newY1 = 0;  // new point 1
                        float newX2 = 0, newY2 = 0; // new point 2
                        float newX3 = 0, newY3 = 0; // new point 3
                        float newX4 = 0, newY4 = 0; // new point 4

                        if (m_intColorDefectLinkMethod == 1)
                        {
                            Math2.NewXYAfterRotate1(m_arrColorDefectList[i].ref_fCenterX, m_arrColorDefectList[i].ref_fCenterY, (m_arrColorDefectList[i].ref_fCenterX - (m_arrColorDefectList[i].ref_fWidth / 2)), (m_arrColorDefectList[i].ref_fCenterY - (m_arrColorDefectList[i].ref_fHeight / 2)), m_arrColorDefectList[i].ref_fAngle, ref newX1, ref newY1);
                            Math2.NewXYAfterRotate2(m_arrColorDefectList[i].ref_fCenterX, m_arrColorDefectList[i].ref_fCenterY, (m_arrColorDefectList[i].ref_fCenterX - (m_arrColorDefectList[i].ref_fWidth / 2)), (m_arrColorDefectList[i].ref_fCenterY + (m_arrColorDefectList[i].ref_fHeight / 2)), m_arrColorDefectList[i].ref_fAngle, ref newX2, ref newY2);
                            Math2.NewXYAfterRotate3(m_arrColorDefectList[i].ref_fCenterX, m_arrColorDefectList[i].ref_fCenterY, (m_arrColorDefectList[i].ref_fCenterX + (m_arrColorDefectList[i].ref_fWidth / 2)), (m_arrColorDefectList[i].ref_fCenterY - (m_arrColorDefectList[i].ref_fHeight / 2)), m_arrColorDefectList[i].ref_fAngle, ref newX3, ref newY3);
                            Math2.NewXYAfterRotate4(m_arrColorDefectList[i].ref_fCenterX, m_arrColorDefectList[i].ref_fCenterY, (m_arrColorDefectList[i].ref_fCenterX + (m_arrColorDefectList[i].ref_fWidth / 2)), (m_arrColorDefectList[i].ref_fCenterY + (m_arrColorDefectList[i].ref_fHeight / 2)), m_arrColorDefectList[i].ref_fAngle, ref newX4, ref newY4);
                        }
                        else
                        {
                            Math2.NewXYAfterRotate1(m_arrColorDefectList[i].ref_fCenterX, m_arrColorDefectList[i].ref_fCenterY, (m_arrColorDefectList[i].ref_fCenterX - (m_arrColorDefectList[i].ref_fWidth / 2)), (m_arrColorDefectList[i].ref_fCenterY - (m_arrColorDefectList[i].ref_fHeight / 2)), -m_arrColorDefectList[i].ref_fAngle, ref newX1, ref newY1);
                            Math2.NewXYAfterRotate2(m_arrColorDefectList[i].ref_fCenterX, m_arrColorDefectList[i].ref_fCenterY, (m_arrColorDefectList[i].ref_fCenterX - (m_arrColorDefectList[i].ref_fWidth / 2)), (m_arrColorDefectList[i].ref_fCenterY + (m_arrColorDefectList[i].ref_fHeight / 2)), -m_arrColorDefectList[i].ref_fAngle, ref newX2, ref newY2);
                            Math2.NewXYAfterRotate3(m_arrColorDefectList[i].ref_fCenterX, m_arrColorDefectList[i].ref_fCenterY, (m_arrColorDefectList[i].ref_fCenterX + (m_arrColorDefectList[i].ref_fWidth / 2)), (m_arrColorDefectList[i].ref_fCenterY - (m_arrColorDefectList[i].ref_fHeight / 2)), -m_arrColorDefectList[i].ref_fAngle, ref newX3, ref newY3);
                            Math2.NewXYAfterRotate4(m_arrColorDefectList[i].ref_fCenterX, m_arrColorDefectList[i].ref_fCenterY, (m_arrColorDefectList[i].ref_fCenterX + (m_arrColorDefectList[i].ref_fWidth / 2)), (m_arrColorDefectList[i].ref_fCenterY + (m_arrColorDefectList[i].ref_fHeight / 2)), -m_arrColorDefectList[i].ref_fAngle, ref newX4, ref newY4);
                        }

                        float NewX1 = (float)((fGaugeCenterX) + ((newX1 - (fGaugeCenterX)) * Math.Cos(fGaugeAngle * Math.PI / 180)) - ((newY1 - (fGaugeCenterY)) * Math.Sin(fGaugeAngle * Math.PI / 180)));
                        float NewY1 = (float)((fGaugeCenterY) + ((newX1 - (fGaugeCenterX)) * Math.Sin(fGaugeAngle * Math.PI / 180)) + ((newY1 - (fGaugeCenterY)) * Math.Cos(fGaugeAngle * Math.PI / 180)));

                        float NewX2 = (float)((fGaugeCenterX) + ((newX2 - (fGaugeCenterX)) * Math.Cos(fGaugeAngle * Math.PI / 180)) - ((newY2 - (fGaugeCenterY)) * Math.Sin(fGaugeAngle * Math.PI / 180)));
                        float NewY2 = (float)((fGaugeCenterY) + ((newX2 - (fGaugeCenterX)) * Math.Sin(fGaugeAngle * Math.PI / 180)) + ((newY2 - (fGaugeCenterY)) * Math.Cos(fGaugeAngle * Math.PI / 180)));

                        float NewX3 = (float)((fGaugeCenterX) + ((newX3 - (fGaugeCenterX)) * Math.Cos(fGaugeAngle * Math.PI / 180)) - ((newY3 - (fGaugeCenterY)) * Math.Sin(fGaugeAngle * Math.PI / 180)));
                        float NewY3 = (float)((fGaugeCenterY) + ((newX3 - (fGaugeCenterX)) * Math.Sin(fGaugeAngle * Math.PI / 180)) + ((newY3 - (fGaugeCenterY)) * Math.Cos(fGaugeAngle * Math.PI / 180)));

                        float NewX4 = (float)((fGaugeCenterX) + ((newX4 - (fGaugeCenterX)) * Math.Cos(fGaugeAngle * Math.PI / 180)) - ((newY4 - (fGaugeCenterY)) * Math.Sin(fGaugeAngle * Math.PI / 180)));
                        float NewY4 = (float)((fGaugeCenterY) + ((newX4 - (fGaugeCenterX)) * Math.Sin(fGaugeAngle * Math.PI / 180)) + ((newY4 - (fGaugeCenterY)) * Math.Cos(fGaugeAngle * Math.PI / 180)));

                        if (strFailTotalAreaDefectName.Contains(objDefect.ref_strName))
                        {
                            g.DrawLine(pen, NewX1 * fDrawingScaleX, NewY1 * fDrawingScaleY, (NewX3) * fDrawingScaleX, (NewY3) * fDrawingScaleY);
                            g.DrawLine(pen, NewX2 * fDrawingScaleX, NewY2 * fDrawingScaleY, (NewX1) * fDrawingScaleX, (NewY1) * fDrawingScaleY);
                            g.DrawLine(pen, NewX2 * fDrawingScaleX, NewY2 * fDrawingScaleY, (NewX4) * fDrawingScaleX, (NewY4) * fDrawingScaleY);
                            g.DrawLine(pen, NewX4 * fDrawingScaleX, NewY4 * fDrawingScaleY, (NewX3) * fDrawingScaleX, (NewY3) * fDrawingScaleY);
                        }
                        else
                        {
                            g.DrawLine(penLime, NewX1 * fDrawingScaleX, NewY1 * fDrawingScaleY, (NewX3) * fDrawingScaleX, (NewY3) * fDrawingScaleY);
                            g.DrawLine(penLime, NewX2 * fDrawingScaleX, NewY2 * fDrawingScaleY, (NewX1) * fDrawingScaleX, (NewY1) * fDrawingScaleY);
                            g.DrawLine(penLime, NewX2 * fDrawingScaleX, NewY2 * fDrawingScaleY, (NewX4) * fDrawingScaleX, (NewY4) * fDrawingScaleY);
                            g.DrawLine(penLime, NewX4 * fDrawingScaleX, NewY4 * fDrawingScaleY, (NewX3) * fDrawingScaleX, (NewY3) * fDrawingScaleY);
                        }
                    }
                }
                else
                {
                    float newX1 = 0, newY1 = 0;  // new point 1
                    float newX2 = 0, newY2 = 0; // new point 2
                    float newX3 = 0, newY3 = 0; // new point 3
                    float newX4 = 0, newY4 = 0; // new point 4

                    if (m_intColorDefectLinkMethod == 1)
                    {
                        Math2.NewXYAfterRotate1(objDefect.ref_fCenterX, objDefect.ref_fCenterY, (objDefect.ref_fCenterX - (objDefect.ref_fWidth / 2)), (objDefect.ref_fCenterY - (objDefect.ref_fHeight / 2)), objDefect.ref_fAngle, ref newX1, ref newY1);
                        Math2.NewXYAfterRotate2(objDefect.ref_fCenterX, objDefect.ref_fCenterY, (objDefect.ref_fCenterX - (objDefect.ref_fWidth / 2)), (objDefect.ref_fCenterY + (objDefect.ref_fHeight / 2)), objDefect.ref_fAngle, ref newX2, ref newY2);
                        Math2.NewXYAfterRotate3(objDefect.ref_fCenterX, objDefect.ref_fCenterY, (objDefect.ref_fCenterX + (objDefect.ref_fWidth / 2)), (objDefect.ref_fCenterY - (objDefect.ref_fHeight / 2)), objDefect.ref_fAngle, ref newX3, ref newY3);
                        Math2.NewXYAfterRotate4(objDefect.ref_fCenterX, objDefect.ref_fCenterY, (objDefect.ref_fCenterX + (objDefect.ref_fWidth / 2)), (objDefect.ref_fCenterY + (objDefect.ref_fHeight / 2)), objDefect.ref_fAngle, ref newX4, ref newY4);
                    }
                    else
                    {
                        Math2.NewXYAfterRotate1(objDefect.ref_fCenterX, objDefect.ref_fCenterY, (objDefect.ref_fCenterX - (objDefect.ref_fWidth / 2)), (objDefect.ref_fCenterY - (objDefect.ref_fHeight / 2)), -objDefect.ref_fAngle, ref newX1, ref newY1);
                        Math2.NewXYAfterRotate2(objDefect.ref_fCenterX, objDefect.ref_fCenterY, (objDefect.ref_fCenterX - (objDefect.ref_fWidth / 2)), (objDefect.ref_fCenterY + (objDefect.ref_fHeight / 2)), -objDefect.ref_fAngle, ref newX2, ref newY2);
                        Math2.NewXYAfterRotate3(objDefect.ref_fCenterX, objDefect.ref_fCenterY, (objDefect.ref_fCenterX + (objDefect.ref_fWidth / 2)), (objDefect.ref_fCenterY - (objDefect.ref_fHeight / 2)), -objDefect.ref_fAngle, ref newX3, ref newY3);
                        Math2.NewXYAfterRotate4(objDefect.ref_fCenterX, objDefect.ref_fCenterY, (objDefect.ref_fCenterX + (objDefect.ref_fWidth / 2)), (objDefect.ref_fCenterY + (objDefect.ref_fHeight / 2)), -objDefect.ref_fAngle, ref newX4, ref newY4);
                    }

                    float NewX1 = (float)((fGaugeCenterX) + ((newX1 - (fGaugeCenterX)) * Math.Cos(fGaugeAngle * Math.PI / 180)) - ((newY1 - (fGaugeCenterY)) * Math.Sin(fGaugeAngle * Math.PI / 180)));
                    float NewY1 = (float)((fGaugeCenterY) + ((newX1 - (fGaugeCenterX)) * Math.Sin(fGaugeAngle * Math.PI / 180)) + ((newY1 - (fGaugeCenterY)) * Math.Cos(fGaugeAngle * Math.PI / 180)));

                    float NewX2 = (float)((fGaugeCenterX) + ((newX2 - (fGaugeCenterX)) * Math.Cos(fGaugeAngle * Math.PI / 180)) - ((newY2 - (fGaugeCenterY)) * Math.Sin(fGaugeAngle * Math.PI / 180)));
                    float NewY2 = (float)((fGaugeCenterY) + ((newX2 - (fGaugeCenterX)) * Math.Sin(fGaugeAngle * Math.PI / 180)) + ((newY2 - (fGaugeCenterY)) * Math.Cos(fGaugeAngle * Math.PI / 180)));

                    float NewX3 = (float)((fGaugeCenterX) + ((newX3 - (fGaugeCenterX)) * Math.Cos(fGaugeAngle * Math.PI / 180)) - ((newY3 - (fGaugeCenterY)) * Math.Sin(fGaugeAngle * Math.PI / 180)));
                    float NewY3 = (float)((fGaugeCenterY) + ((newX3 - (fGaugeCenterX)) * Math.Sin(fGaugeAngle * Math.PI / 180)) + ((newY3 - (fGaugeCenterY)) * Math.Cos(fGaugeAngle * Math.PI / 180)));

                    float NewX4 = (float)((fGaugeCenterX) + ((newX4 - (fGaugeCenterX)) * Math.Cos(fGaugeAngle * Math.PI / 180)) - ((newY4 - (fGaugeCenterY)) * Math.Sin(fGaugeAngle * Math.PI / 180)));
                    float NewY4 = (float)((fGaugeCenterY) + ((newX4 - (fGaugeCenterX)) * Math.Sin(fGaugeAngle * Math.PI / 180)) + ((newY4 - (fGaugeCenterY)) * Math.Cos(fGaugeAngle * Math.PI / 180)));

                    if (objDefect.ref_intFailCriteria > 0)
                    {
                        g.DrawLine(pen, NewX1 * fDrawingScaleX, NewY1 * fDrawingScaleY, (NewX3) * fDrawingScaleX, (NewY3) * fDrawingScaleY);
                        g.DrawLine(pen, NewX2 * fDrawingScaleX, NewY2 * fDrawingScaleY, (NewX1) * fDrawingScaleX, (NewY1) * fDrawingScaleY);
                        g.DrawLine(pen, NewX2 * fDrawingScaleX, NewY2 * fDrawingScaleY, (NewX4) * fDrawingScaleX, (NewY4) * fDrawingScaleY);
                        g.DrawLine(pen, NewX4 * fDrawingScaleX, NewY4 * fDrawingScaleY, (NewX3) * fDrawingScaleX, (NewY3) * fDrawingScaleY);
                    }
                    else
                    {
                        g.DrawLine(penLime, NewX1 * fDrawingScaleX, NewY1 * fDrawingScaleY, (NewX3) * fDrawingScaleX, (NewY3) * fDrawingScaleY);
                        g.DrawLine(penLime, NewX2 * fDrawingScaleX, NewY2 * fDrawingScaleY, (NewX1) * fDrawingScaleX, (NewY1) * fDrawingScaleY);
                        g.DrawLine(penLime, NewX2 * fDrawingScaleX, NewY2 * fDrawingScaleY, (NewX4) * fDrawingScaleX, (NewY4) * fDrawingScaleY);
                        g.DrawLine(penLime, NewX4 * fDrawingScaleX, NewY4 * fDrawingScaleY, (NewX3) * fDrawingScaleX, (NewY3) * fDrawingScaleY);
                    }
                }
            }
        }

        public void DrawColorDefect(Graphics g, float fDrawingScaleX, float fDrawingScaleY, float fGaugeCenterX, float fGaugeCenterY, float fGaugeAngle)
        {
            Pen pen = new Pen(Color.Red, 1);
            Pen penLime = new Pen(Color.Lime, 1);

            for (int i = 0; i < m_arrColorDefectList.Count; i++)
            {

                if (m_arrColorDefectList[i].ref_intFailCriteria > 0 || m_arrColorDefectList[i].ref_blnFailTotalArea)
                {
                    pen = new Pen(Color.Red, 1);
                }
                else
                {
                    pen = new Pen(Color.Lime, 1);
                }

                float newX1 = 0, newY1 = 0;  // new point 1
                float newX2 = 0, newY2 = 0; // new point 2
                float newX3 = 0, newY3 = 0; // new point 3
                float newX4 = 0, newY4 = 0; // new point 4

                if (m_intColorDefectLinkMethod == 1)
                {
                    Math2.NewXYAfterRotate1(m_arrColorDefectList[i].ref_fCenterX, m_arrColorDefectList[i].ref_fCenterY, (m_arrColorDefectList[i].ref_fCenterX - (m_arrColorDefectList[i].ref_fWidth / 2)), (m_arrColorDefectList[i].ref_fCenterY - (m_arrColorDefectList[i].ref_fHeight / 2)), m_arrColorDefectList[i].ref_fAngle, ref newX1, ref newY1);
                    Math2.NewXYAfterRotate2(m_arrColorDefectList[i].ref_fCenterX, m_arrColorDefectList[i].ref_fCenterY, (m_arrColorDefectList[i].ref_fCenterX - (m_arrColorDefectList[i].ref_fWidth / 2)), (m_arrColorDefectList[i].ref_fCenterY + (m_arrColorDefectList[i].ref_fHeight / 2)), m_arrColorDefectList[i].ref_fAngle, ref newX2, ref newY2);
                    Math2.NewXYAfterRotate3(m_arrColorDefectList[i].ref_fCenterX, m_arrColorDefectList[i].ref_fCenterY, (m_arrColorDefectList[i].ref_fCenterX + (m_arrColorDefectList[i].ref_fWidth / 2)), (m_arrColorDefectList[i].ref_fCenterY - (m_arrColorDefectList[i].ref_fHeight / 2)), m_arrColorDefectList[i].ref_fAngle, ref newX3, ref newY3);
                    Math2.NewXYAfterRotate4(m_arrColorDefectList[i].ref_fCenterX, m_arrColorDefectList[i].ref_fCenterY, (m_arrColorDefectList[i].ref_fCenterX + (m_arrColorDefectList[i].ref_fWidth / 2)), (m_arrColorDefectList[i].ref_fCenterY + (m_arrColorDefectList[i].ref_fHeight / 2)), m_arrColorDefectList[i].ref_fAngle, ref newX4, ref newY4);
                }
                else
                {
                    Math2.NewXYAfterRotate1(m_arrColorDefectList[i].ref_fCenterX, m_arrColorDefectList[i].ref_fCenterY, (m_arrColorDefectList[i].ref_fCenterX - (m_arrColorDefectList[i].ref_fWidth / 2)), (m_arrColorDefectList[i].ref_fCenterY - (m_arrColorDefectList[i].ref_fHeight / 2)), -m_arrColorDefectList[i].ref_fAngle, ref newX1, ref newY1);
                    Math2.NewXYAfterRotate2(m_arrColorDefectList[i].ref_fCenterX, m_arrColorDefectList[i].ref_fCenterY, (m_arrColorDefectList[i].ref_fCenterX - (m_arrColorDefectList[i].ref_fWidth / 2)), (m_arrColorDefectList[i].ref_fCenterY + (m_arrColorDefectList[i].ref_fHeight / 2)), -m_arrColorDefectList[i].ref_fAngle, ref newX2, ref newY2);
                    Math2.NewXYAfterRotate3(m_arrColorDefectList[i].ref_fCenterX, m_arrColorDefectList[i].ref_fCenterY, (m_arrColorDefectList[i].ref_fCenterX + (m_arrColorDefectList[i].ref_fWidth / 2)), (m_arrColorDefectList[i].ref_fCenterY - (m_arrColorDefectList[i].ref_fHeight / 2)), -m_arrColorDefectList[i].ref_fAngle, ref newX3, ref newY3);
                    Math2.NewXYAfterRotate4(m_arrColorDefectList[i].ref_fCenterX, m_arrColorDefectList[i].ref_fCenterY, (m_arrColorDefectList[i].ref_fCenterX + (m_arrColorDefectList[i].ref_fWidth / 2)), (m_arrColorDefectList[i].ref_fCenterY + (m_arrColorDefectList[i].ref_fHeight / 2)), -m_arrColorDefectList[i].ref_fAngle, ref newX4, ref newY4);
                }
                
                float NewX1 = (float)((fGaugeCenterX) + ((newX1 - (fGaugeCenterX)) * Math.Cos(fGaugeAngle * Math.PI / 180)) - ((newY1 - (fGaugeCenterY)) * Math.Sin(fGaugeAngle * Math.PI / 180)));
                float NewY1 = (float)((fGaugeCenterY) + ((newX1 - (fGaugeCenterX)) * Math.Sin(fGaugeAngle * Math.PI / 180)) + ((newY1 - (fGaugeCenterY)) * Math.Cos(fGaugeAngle * Math.PI / 180)));

                float NewX2 = (float)((fGaugeCenterX) + ((newX2 - (fGaugeCenterX)) * Math.Cos(fGaugeAngle * Math.PI / 180)) - ((newY2 - (fGaugeCenterY)) * Math.Sin(fGaugeAngle * Math.PI / 180)));
                float NewY2 = (float)((fGaugeCenterY) + ((newX2 - (fGaugeCenterX)) * Math.Sin(fGaugeAngle * Math.PI / 180)) + ((newY2 - (fGaugeCenterY)) * Math.Cos(fGaugeAngle * Math.PI / 180)));

                float NewX3 = (float)((fGaugeCenterX) + ((newX3 - (fGaugeCenterX)) * Math.Cos(fGaugeAngle * Math.PI / 180)) - ((newY3 - (fGaugeCenterY)) * Math.Sin(fGaugeAngle * Math.PI / 180)));
                float NewY3 = (float)((fGaugeCenterY) + ((newX3 - (fGaugeCenterX)) * Math.Sin(fGaugeAngle * Math.PI / 180)) + ((newY3 - (fGaugeCenterY)) * Math.Cos(fGaugeAngle * Math.PI / 180)));

                float NewX4 = (float)((fGaugeCenterX) + ((newX4 - (fGaugeCenterX)) * Math.Cos(fGaugeAngle * Math.PI / 180)) - ((newY4 - (fGaugeCenterY)) * Math.Sin(fGaugeAngle * Math.PI / 180)));
                float NewY4 = (float)((fGaugeCenterY) + ((newX4 - (fGaugeCenterX)) * Math.Sin(fGaugeAngle * Math.PI / 180)) + ((newY4 - (fGaugeCenterY)) * Math.Cos(fGaugeAngle * Math.PI / 180)));

                g.DrawLine(pen, NewX1 * fDrawingScaleX, NewY1 * fDrawingScaleY, (NewX3) * fDrawingScaleX, (NewY3) * fDrawingScaleY);
                g.DrawLine(pen, NewX2 * fDrawingScaleX, NewY2 * fDrawingScaleY, (NewX1) * fDrawingScaleX, (NewY1) * fDrawingScaleY);
                g.DrawLine(pen, NewX2 * fDrawingScaleX, NewY2 * fDrawingScaleY, (NewX4) * fDrawingScaleX, (NewY4) * fDrawingScaleY);
                g.DrawLine(pen, NewX4 * fDrawingScaleX, NewY4 * fDrawingScaleY, (NewX3) * fDrawingScaleX, (NewY3) * fDrawingScaleY);
                
            }

        }

        public void SetColorDefectInspectionTotalAreaLimit(float fValue, int intFromValueType, string strName)
        {
            for (int i = 0; i < m_arrDefectColorInspectionTotalArea.Count; i++)
            {
                if (m_arrDefectColorThresName.Count > i && m_arrDefectColorThresName[i] == strName)
                {
                    switch (intFromValueType)
                    {
                        //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                        //case 0: // Pixel X
                        //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                        //    break;
                        //case 1: // Pixel Y
                        //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                        //    break;
                        case 1: // mm
                        case 2: // mil
                        case 3: // micron
                        default:
                            m_arrDefectColorInspectionTotalArea[i] = fValue / m_fMMToUnitValueArea;
                            break;
                    }
                }
            }
        }
        public bool CheckColorDefect(CROI objSampleUnitROI, List<CImageDrawing> arrColorImages)
        {
            if (m_arrDefectColorThresName.Count == 0)
                return true;

            if ((((m_intFailColorOptionMask & 0x03) == 0) && m_arrDefectColorThresName.Count == 1) &&
                (((m_intFailColorOptionMask & 0x0C) == 0) && m_arrDefectColorThresName.Count == 2) &&
                (((m_intFailColorOptionMask & 0x30) == 0) && m_arrDefectColorThresName.Count == 3) &&
                (((m_intFailColorOptionMask & 0xC0) == 0) && m_arrDefectColorThresName.Count == 4) &&
                (((m_intFailColorOptionMask & 0x300) == 0) && m_arrDefectColorThresName.Count == 5))
                return true;

            bool blnResult = true;
            bool blnDebugImage = false;

            //float fPkgOffsetX = (objSampleUnitROI.ref_ROIWidth - Math.Max(GetResultUpWidth_RectGauge4L(0), GetResultDownWidth_RectGauge4L(0))) / 2;
            //float fPkgOffsetY = (objSampleUnitROI.ref_ROIHeight - Math.Max(GetResultLeftHeight_RectGauge4L(0), GetResultRightHeight_RectGauge4L(0))) / 2;

            int intStartPixelFromEdgeX = 0;// (int)Math.Round(fPkgOffsetX - m_intPadROIStartPixelFromLeft, 0, MidpointRounding.AwayFromZero); //m_fPkgStartPixelFromLeft
            int intStartPixelFromEdgeY = 0;// (int)Math.Round(fPkgOffsetY - m_intPadROIStartPixelFromTop, 0, MidpointRounding.AwayFromZero); //m_fPkgStartPixelFromEdge
            //int intStartPixelFromEdgeX2 = (int)Math.Round(fPkgOffsetX + m_intPadROIStartPixelFromRight, 0, MidpointRounding.AwayFromZero); //m_fPkgStartPixelFromRight
            //int intStartPixelFromEdgeY2 = (int)Math.Round(fPkgOffsetY + m_intPadROIStartPixelFromBottom, 0, MidpointRounding.AwayFromZero); //m_fPkgStartPixelFromBottom
            ImageDrawing objImageTemp = new ImageDrawing(true, arrColorImages[0].ref_intImageWidth, arrColorImages[0].ref_intImageHeight);
            ROI objThresholdSampleROI = new ROI();
            objThresholdSampleROI.AttachImage(objImageTemp); // Attach sample ROI to ori size image. m_objInsPadPkgImage1 is a ori size image used to keep the sample image temporary for modification such as double threshold
            objThresholdSampleROI.LoadROISetting(objSampleUnitROI.ref_ROIPositionX, objSampleUnitROI.ref_ROIPositionY, objSampleUnitROI.ref_ROIWidth, objSampleUnitROI.ref_ROIHeight);

            if (blnDebugImage)
            {
                objSampleUnitROI.SaveImage("D:\\TS\\1.objSampleUnitROI.bmp");
            }
       
            for (int intColorThresIndex = 0; intColorThresIndex < m_arrDefectColor.Count; intColorThresIndex++)
            {
                if (intColorThresIndex == 0 && ((m_intFailColorOptionMask & 0x03) == 0))
                    continue;
                else if (intColorThresIndex == 1 && ((m_intFailColorOptionMask & 0x0C) == 0))
                    continue;
                else if (intColorThresIndex == 2 && ((m_intFailColorOptionMask & 0x30) == 0))
                    continue;
                else if (intColorThresIndex == 3 && ((m_intFailColorOptionMask & 0xC0) == 0))
                    continue;
                else if (intColorThresIndex == 4 && ((m_intFailColorOptionMask & 0x300) == 0))
                    continue;

                if (!blnResult)
                    break;

                objSampleUnitROI.AttachImage(arrColorImages[CImageDrawing.GetArrayImageIndex(m_arrDefectImageNo[intColorThresIndex], m_intVisionIndex)]);

                if (blnDebugImage)
                {
                    objSampleUnitROI.SaveImage("D:\\TS\\1_1.objSampleUnitROI2.bmp");
                }

                bool blnCheckLength = false;
                bool blnCheckArea = false;
                int intFailMask = 0;
                if (intColorThresIndex == 0)
                {
                    intFailMask = 0x01;
                    if ((m_intFailColorOptionMask & 0x01) > 0)
                        blnCheckLength = true;
                    if ((m_intFailColorOptionMask & 0x02) > 0)
                        blnCheckArea = true;
                }
                else if (intColorThresIndex == 1)
                {
                    intFailMask = 0x02;
                    if ((m_intFailColorOptionMask & 0x04) > 0)
                        blnCheckLength = true;
                    if ((m_intFailColorOptionMask & 0x08) > 0)
                        blnCheckArea = true;
                }
                else if (intColorThresIndex == 2)
                {
                    intFailMask = 0x04;
                    if ((m_intFailColorOptionMask & 0x10) > 0)
                        blnCheckLength = true;
                    if ((m_intFailColorOptionMask & 0x20) > 0)
                        blnCheckArea = true;
                }
                else if (intColorThresIndex == 3)
                {
                    intFailMask = 0x08;
                    if ((m_intFailColorOptionMask & 0x40) > 0)
                        blnCheckLength = true;
                    if ((m_intFailColorOptionMask & 0x80) > 0)
                        blnCheckArea = true;
                }
                else if (intColorThresIndex == 4)
                {
                    intFailMask = 0x10;
                    if ((m_intFailColorOptionMask & 0x100) > 0)
                        blnCheckLength = true;
                    if ((m_intFailColorOptionMask & 0x200) > 0)
                        blnCheckArea = true;
                }

                int intSelectedObjectNum = 0;
                // Get color threshold min max value
                m_objColorBlobs.ref_C24LowColorThreshold = ColorProcessing.CalculateMinColor(m_arrDefectColor[intColorThresIndex], m_arrDefectColorTolerance[intColorThresIndex]).ref_Color24;
                m_objColorBlobs.ref_C24HighColorThreshold = ColorProcessing.CalculateMaxColor(m_arrDefectColor[intColorThresIndex], m_arrDefectColorTolerance[intColorThresIndex]).ref_Color24;

                // Threshold color image 
                if (m_arrDefectColorSystem[intColorThresIndex] == 0)
                    EasyImage.Threshold(objSampleUnitROI.ref_CROI, objThresholdSampleROI.ref_ROI, m_objColorBlobs.ref_C24LowColorThreshold, m_objColorBlobs.ref_C24HighColorThreshold, m_objColorLookupLSH);
                else if (m_arrDefectColorSystem[intColorThresIndex] == 1)
                    EasyImage.Threshold(objSampleUnitROI.ref_CROI, objThresholdSampleROI.ref_ROI, m_objColorBlobs.ref_C24LowColorThreshold, m_objColorBlobs.ref_C24HighColorThreshold, m_objColorLookupRGB);
                else
                {
                    EasyColor.GetComponent(objSampleUnitROI.ref_CROI, objThresholdSampleROI.ref_ROI, 1, m_objColorLookupYSH);
                    if (blnDebugImage)
                        objThresholdSampleROI.SaveImage("D:\\TS\\1_2.SaturationImg" + intColorThresIndex + ".bmp");
#if (Debug_2_12 || Release_2_12)
                    EasyImage.Threshold(objThresholdSampleROI.ref_ROI, objThresholdSampleROI.ref_ROI, (uint)m_arrDefectColor[intColorThresIndex][0]);
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                    EasyImage.Threshold(objThresholdSampleROI.ref_ROI, objThresholdSampleROI.ref_ROI, m_arrDefectColor[intColorThresIndex][0]);
#endif
                }

                if (blnDebugImage)
                    objThresholdSampleROI.SaveImage("D:\\TS\\2.objThresholdSampleROI" + intColorThresIndex + ".bmp");

                SubtractColorDontCareImage(objThresholdSampleROI, m_arrDefectDontCareMode[intColorThresIndex], m_arrPackageColorDontCareImage[intColorThresIndex]);

                objThresholdSampleROI.LoadROISetting(objSampleUnitROI.ref_ROITotalX + GetColorDefectInspection_Left(intColorThresIndex),
                    objSampleUnitROI.ref_ROITotalY + GetColorDefectInspection_Top(intColorThresIndex),
                    objSampleUnitROI.ref_ROIWidth - GetColorDefectInspection_Left(intColorThresIndex) - GetColorDefectInspection_Right(intColorThresIndex),
                    objSampleUnitROI.ref_ROIHeight - GetColorDefectInspection_Top(intColorThresIndex) - GetColorDefectInspection_Bottom(intColorThresIndex));

                if (blnDebugImage)
                    objThresholdSampleROI.SaveImage("D:\\TS\\3.objThresholdSampleROI" + intColorThresIndex + ".bmp");

                intSelectedObjectNum = m_objColorBlobs.BuildObjects_Filter_GetElement(objThresholdSampleROI, false, true, 0, -4,
                m_arrDefectColorMinArea[intColorThresIndex], objSampleUnitROI.ref_ROIWidth * objSampleUnitROI.ref_ROIHeight, false, 0xFF);

                if (intSelectedObjectNum == 0 && m_arrDefectType[intColorThresIndex] == 1)
                {
                    ColorDefect objDefect = new ColorDefect();

                    objDefect.ref_strName = m_arrDefectColorThresName[intColorThresIndex];
                    objDefect.ref_intFailMask = intFailMask;
                    objDefect.ref_fCenterX = -1;
                    objDefect.ref_fCenterY = -1;
                    objDefect.ref_fStartX = -1;
                    objDefect.ref_fStartY = -1;
                    objDefect.ref_fEndX = -1;
                    objDefect.ref_fEndY = -1;
                    objDefect.ref_fWidth = -1;
                    objDefect.ref_fHeight = -1;
                    objDefect.ref_fArea = -1;
                    objDefect.ref_fWidthInMM = -1;
                    objDefect.ref_fHeightInMM = -1;
                    objDefect.ref_fAreaInMM2 = -1;
                    objDefect.ref_intImageNo = m_arrDefectImageNo[intColorThresIndex] + 1;

                    objDefect.ref_fAreaFailValue = -1;
                    objDefect.ref_intFailCriteria |= 0x10;

                    m_arrColorDefectList.Add(objDefect);

                    m_intFailColorResultMask |= intFailMask;

                    blnResult = false;
                }

                bool blnOverallResult = true;
                if (intSelectedObjectNum > 0)
                {
                    float fCenterX = 0, fCenterY = 0, fWidth = 0, fHeight = 0;
                    float fStartX, fStartY, fEndX, fEndY, fAngle = 0;
                    int intArea = 0;
                    float fWidthMM, fHeightMM, fAreaInMM;
                    int intFailCount = 0;

                    int intTotalArea = 0;
                    for (int i = 0; i < intSelectedObjectNum; i++)
                    {
                        intArea = m_objColorBlobs.ref_arrArea[i];

                        if (m_objColorBlobs.ref_arrRectWidth[i] < m_objColorBlobs.ref_arrRectHeight[i])
                        {
                            fWidth = m_objColorBlobs.ref_arrRectWidth[i];
                            fHeight = m_objColorBlobs.ref_arrRectHeight[i];

                            fAngle = m_objColorBlobs.ref_arrRectAngle[i];


                            if (fAngle < 0)
                                fAngle = -Math.Abs(fAngle);
                            else
                                fAngle = -fAngle;
                        }
                        else
                        {
                            fWidth = m_objColorBlobs.ref_arrRectHeight[i];
                            fHeight = m_objColorBlobs.ref_arrRectWidth[i];

                            fAngle = m_objColorBlobs.ref_arrRectAngle[i];


                            if (fAngle < 0)
                                fAngle = Math.Abs(fAngle);
                            else
                                fAngle = 90 - (fAngle);
                        }
                        fCenterX = m_objColorBlobs.ref_arrRectLimitCenterX[i];
                        fCenterY = m_objColorBlobs.ref_arrRectLimitCenterY[i];

                        intTotalArea += intArea;
                        fCenterX += intStartPixelFromEdgeX;
                        fCenterY += intStartPixelFromEdgeY;
                        fStartX = (float)Math.Floor(fCenterX - (fWidth / 2));
                        fStartY = (float)Math.Floor(fCenterY - (fHeight / 2));
                        fEndX = (float)Math.Ceiling(fCenterX + (fWidth / 2));
                        fEndY = (float)Math.Ceiling(fCenterY + (fHeight / 2));

                        // convert width and height to mm
                        fWidthMM = fWidth / m_fMMToPixelXValue;
                        fHeightMM = fHeight / m_fMMToPixelYValue; // 11-04-2019 ZJYEOH : Changed m_fMMToPixelXValue to m_fMMToPixelYValue
                        fAreaInMM = intArea / m_fMMToPixelXValue / m_fMMToPixelYValue;

                        {
                            intFailCount++;

                            ColorDefect objDefect = new ColorDefect();

                            objDefect.ref_strName = m_arrDefectColorThresName[intColorThresIndex];
                            objDefect.ref_intFailMask = intFailMask;
                            objDefect.ref_fCenterX = objThresholdSampleROI.ref_ROITotalX + fCenterX;
                            objDefect.ref_fCenterY = objThresholdSampleROI.ref_ROITotalY + fCenterY;
                            objDefect.ref_fStartX = objThresholdSampleROI.ref_ROITotalX + fStartX;
                            objDefect.ref_fStartY = objThresholdSampleROI.ref_ROITotalY + fStartY;
                            objDefect.ref_fEndX = objThresholdSampleROI.ref_ROITotalX + fEndX;
                            objDefect.ref_fEndY = objThresholdSampleROI.ref_ROITotalY + fEndY;
                            objDefect.ref_fWidth = fWidth;
                            objDefect.ref_fHeight = fHeight;
                            objDefect.ref_fArea = intArea;
                            objDefect.ref_fAngle = fAngle;
                            objDefect.ref_fWidthInMM = fWidthMM;
                            objDefect.ref_fHeightInMM = fHeightMM;
                            objDefect.ref_fAreaInMM2 = fAreaInMM;
                            objDefect.ref_intImageNo = m_arrDefectImageNo[intColorThresIndex] + 1;

                            if (blnCheckLength)
                            {
                                if (m_arrDefectColorInspectionFailCondition[intColorThresIndex] == 0)
                                {
                                    if (fWidthMM > m_arrDefectColorInspectionWidth[intColorThresIndex])
                                    {
                                        m_intFailColorResultMask |= intFailMask;

                                        blnOverallResult = false;
                                        objDefect.ref_fWidthFailValue = fWidthMM;
                                        objDefect.ref_intFailCriteria |= 0x01;
                                        blnResult = false;
                                        m_strErrorMessage += "* " + objDefect.ref_strName + " Width Fail. Set = " + m_arrDefectColorInspectionWidth[intColorThresIndex].ToString("f5") + " mm,   Result = " + fWidthMM.ToString("f5") + " mm";
                                    }
                                    if (fHeightMM > m_arrDefectColorInspectionLength[intColorThresIndex])
                                    {
                                        m_intFailColorResultMask |= intFailMask;

                                        blnOverallResult = false;
                                        objDefect.ref_fHeightFailValue = fHeightMM;
                                        objDefect.ref_intFailCriteria |= 0x02;
                                        blnResult = false;
                                        m_strErrorMessage += "* " + objDefect.ref_strName + " Length Fail. Set = " + m_arrDefectColorInspectionLength[intColorThresIndex].ToString("f5") + " mm,   Result = " + fHeightMM.ToString("f5") + " mm";
                                    }
                                }
                                else
                                {
                                    if ((fWidthMM > m_arrDefectColorInspectionWidth[intColorThresIndex]) && (fHeightMM > m_arrDefectColorInspectionLength[intColorThresIndex]))
                                    {
                                        m_intFailColorResultMask |= intFailMask;

                                        blnOverallResult = false;
                                        objDefect.ref_fWidthFailValue = fWidthMM;
                                        objDefect.ref_fHeightFailValue = fHeightMM;
                                        objDefect.ref_intFailCriteria |= 0x01;
                                        objDefect.ref_intFailCriteria |= 0x02;
                                        blnResult = false;
                                        m_strErrorMessage += "* " + objDefect.ref_strName + " Width Fail. Set = " + m_arrDefectColorInspectionWidth[intColorThresIndex].ToString("f5") + " mm,   Result = " + fWidthMM.ToString("f5") + " mm";
                                        m_strErrorMessage += "* " + objDefect.ref_strName + " Length Fail. Set = " + m_arrDefectColorInspectionLength[intColorThresIndex].ToString("f5") + " mm,   Result = " + fHeightMM.ToString("f5") + " mm";
                                    }
                                }
                                
                            }

                            if (blnCheckArea)
                            {
                                if (/*fAreaInMM < m_arrDefectColorInspectionMinArea[intColorThresIndex] ||*/ fAreaInMM > m_arrDefectColorInspectionMaxArea[intColorThresIndex])
                                {
                                    m_intFailColorResultMask |= intFailMask;

                                    blnOverallResult = false;
                                    objDefect.ref_fAreaFailValue = fAreaInMM;
                                    objDefect.ref_intFailCriteria |= 0x04;
                                    blnResult = false;
                                    m_strErrorMessage += "* "+ objDefect.ref_strName + " Area Fail. Set = " + m_arrDefectColorInspectionMaxArea[intColorThresIndex].ToString("f5") + " mm^2,   Result = " + fAreaInMM.ToString("f5") + " mm^2";
                                }
                            }

                            m_arrColorDefectList.Add(objDefect);
                        }

                    }

                    if (blnCheckArea)
                    {
                        fAreaInMM = intTotalArea / m_fMMToPixelXValue / m_fMMToPixelYValue;
                       
                        if (fAreaInMM > m_arrDefectColorInspectionTotalArea[intColorThresIndex])
                        {
                            ColorDefect objDefect = new ColorDefect();

                            objDefect.ref_strName = "Total " + m_arrDefectColorThresName[intColorThresIndex];
                            objDefect.ref_intFailMask = intFailMask;
                            objDefect.ref_fCenterX = -1;
                            objDefect.ref_fCenterY = -1;
                            objDefect.ref_fStartX = -1;
                            objDefect.ref_fStartY = -1;
                            objDefect.ref_fEndX = -1;
                            objDefect.ref_fEndY = -1;
                            objDefect.ref_fWidth = -1;
                            objDefect.ref_fHeight = -1;
                            objDefect.ref_fArea = intTotalArea;
                            objDefect.ref_fWidthInMM = -1;
                            objDefect.ref_fHeightInMM = -1;
                            objDefect.ref_fAreaInMM2 = fAreaInMM;
                            objDefect.ref_intImageNo = m_arrDefectImageNo[intColorThresIndex] + 1;
                            objDefect.ref_blnFailTotalArea = true;

                            blnOverallResult = false;
                            objDefect.ref_fAreaFailValue = fAreaInMM;
                            objDefect.ref_intFailCriteria |= 0x08;

                            m_arrColorDefectList.Add(objDefect);

                            m_intFailColorResultMask |= intFailMask;

                            m_strErrorMessage += "* " + objDefect.ref_strName + " Area Fail. Set = " + m_arrDefectColorInspectionTotalArea[intColorThresIndex].ToString("f5") + " mm^2,   Result = " + fAreaInMM.ToString("f5") + " mm^2";

                            //for (int b = 0; b < m_arrColorDefectList.Count; b++)
                            //{
                            //    if (((ColorDefect)m_arrColorDefectList[b]).ref_strName == m_arrDefectColorThresName[intColorThresIndex])
                            //    {
                            //        if (!((ColorDefect)m_arrColorDefectList[b]).ref_blnFailTotalArea)
                            //        {
                            //            ColorDefect objDefect2 = m_arrColorDefectList[b];
                            //            objDefect2.ref_blnFailTotalArea = true;
                            //            m_arrColorDefectList.RemoveAt(b);
                            //            m_arrColorDefectList.Insert(b, objDefect2);
                            //        }
                            //    }
                            //}

                            blnResult = false;
                        }
                        
                    }
                }
            }
            objThresholdSampleROI.Dispose();
            objImageTemp.Dispose();
            return blnResult;
        }
        public bool CheckColorDefect_CombineSameName(CROI objSampleUnitROI, List<CImageDrawing> arrColorImages, ImageDrawing objWhiteImage, ImageDrawing objBlackImage, List<int> arrStartX, List<int> arrStartY, List<int> arrEndX, List<int> arrEndY)
        {
            if (m_arrDefectColorThresName.Count == 0)
                return true;

            if ((((m_intFailColorOptionMask & 0x03) == 0) && m_arrDefectColorThresName.Count == 1) &&
                (((m_intFailColorOptionMask & 0x0C) == 0) && m_arrDefectColorThresName.Count == 2) &&
                (((m_intFailColorOptionMask & 0x30) == 0) && m_arrDefectColorThresName.Count == 3) &&
                (((m_intFailColorOptionMask & 0xC0) == 0) && m_arrDefectColorThresName.Count == 4) &&
                (((m_intFailColorOptionMask & 0x300) == 0) && m_arrDefectColorThresName.Count == 5))
                return true;

            bool blnResult = true;
            bool blnDebugImage = false;

            //float fPkgOffsetX = (objSampleUnitROI.ref_ROIWidth - Math.Max(GetResultUpWidth_RectGauge4L(0), GetResultDownWidth_RectGauge4L(0))) / 2;
            //float fPkgOffsetY = (objSampleUnitROI.ref_ROIHeight - Math.Max(GetResultLeftHeight_RectGauge4L(0), GetResultRightHeight_RectGauge4L(0))) / 2;

            int intStartPixelFromEdgeX = 0;// (int)Math.Round(fPkgOffsetX - m_intPadROIStartPixelFromLeft, 0, MidpointRounding.AwayFromZero); //m_fPkgStartPixelFromLeft
            int intStartPixelFromEdgeY = 0;// (int)Math.Round(fPkgOffsetY - m_intPadROIStartPixelFromTop, 0, MidpointRounding.AwayFromZero); //m_fPkgStartPixelFromEdge
            //int intStartPixelFromEdgeX2 = (int)Math.Round(fPkgOffsetX + m_intPadROIStartPixelFromRight, 0, MidpointRounding.AwayFromZero); //m_fPkgStartPixelFromRight
            //int intStartPixelFromEdgeY2 = (int)Math.Round(fPkgOffsetY + m_intPadROIStartPixelFromBottom, 0, MidpointRounding.AwayFromZero); //m_fPkgStartPixelFromBottom
            ImageDrawing objImageTemp = new ImageDrawing(true, arrColorImages[0].ref_intImageWidth, arrColorImages[0].ref_intImageHeight);
            ROI objThresholdSampleROI = new ROI();
            objThresholdSampleROI.AttachImage(objImageTemp); // Attach sample ROI to ori size image. m_objInsPadPkgImage1 is a ori size image used to keep the sample image temporary for modification such as double threshold
            objThresholdSampleROI.LoadROISetting(objSampleUnitROI.ref_ROIPositionX, objSampleUnitROI.ref_ROIPositionY, objSampleUnitROI.ref_ROIWidth, objSampleUnitROI.ref_ROIHeight);

            ImageDrawing objImageTemp2 = new ImageDrawing(true, arrColorImages[0].ref_intImageWidth, arrColorImages[0].ref_intImageHeight);
            ROI objThresholdSampleROI_Temp = new ROI();
            objThresholdSampleROI_Temp.AttachImage(objImageTemp2); // Attach sample ROI to ori size image. m_objInsSurfacePkgImage1 is a ori size image used to keep the sample image temporary for modification such as double threshold
            objThresholdSampleROI_Temp.LoadROISetting(objSampleUnitROI.ref_ROIPositionX, objSampleUnitROI.ref_ROIPositionY, objSampleUnitROI.ref_ROIWidth, objSampleUnitROI.ref_ROIHeight);

            if (blnDebugImage)
            {
                objSampleUnitROI.SaveImage("D:\\TS\\1.objSampleUnitROI.bmp");
            }
            List<int> arrSkip = new List<int>();

            for (int intColorThresIndex = 0; intColorThresIndex < m_arrDefectColor.Count; intColorThresIndex++)
            {
                if (intColorThresIndex == 0 && ((m_intFailColorOptionMask & 0x03) == 0))
                    continue;
                else if (intColorThresIndex == 1 && ((m_intFailColorOptionMask & 0x0C) == 0))
                    continue;
                else if (intColorThresIndex == 2 && ((m_intFailColorOptionMask & 0x30) == 0))
                    continue;
                else if (intColorThresIndex == 3 && ((m_intFailColorOptionMask & 0xC0) == 0))
                    continue;
                else if (intColorThresIndex == 4 && ((m_intFailColorOptionMask & 0x300) == 0))
                    continue;

                if (!blnResult)
                    break;

                objBlackImage.CopyTo(ref objImageTemp);

                string strThresName = m_arrDefectColorThresName[intColorThresIndex];
                if (!arrSkip.Contains(intColorThresIndex))
                {
                    bool blnFirstTime = true;
                    for (int i = 0; i < m_arrDefectColor.Count; i++)
                    {
                        if (!arrSkip.Contains(i) && strThresName == m_arrDefectColorThresName[i])
                        {
                            arrSkip.Add(i);
                        }
                        else
                            continue;

                        objSampleUnitROI.AttachImage(arrColorImages[CImageDrawing.GetArrayImageIndex(m_arrDefectImageNo[i], m_intVisionIndex)]);

                        if (blnDebugImage)
                        {
                            objSampleUnitROI.SaveImage("D:\\TS\\1_1.objSampleUnitROI2.bmp");
                        }
                        objBlackImage.CopyTo(ref objImageTemp2);

                        // Get color threshold min max value
                        m_objColorBlobs.ref_C24LowColorThreshold = ColorProcessing.CalculateMinColor(m_arrDefectColor[i], m_arrDefectColorTolerance[i]).ref_Color24;
                        m_objColorBlobs.ref_C24HighColorThreshold = ColorProcessing.CalculateMaxColor(m_arrDefectColor[i], m_arrDefectColorTolerance[i]).ref_Color24;

                        objThresholdSampleROI_Temp.LoadROISetting(objSampleUnitROI.ref_ROITotalX,
                            objSampleUnitROI.ref_ROITotalY,
                            objSampleUnitROI.ref_ROIWidth,
                            objSampleUnitROI.ref_ROIHeight);

                        // Threshold color image 
                        if (m_arrDefectColorSystem[i] == 0)
                            EasyImage.Threshold(objSampleUnitROI.ref_CROI, objThresholdSampleROI_Temp.ref_ROI, m_objColorBlobs.ref_C24LowColorThreshold, m_objColorBlobs.ref_C24HighColorThreshold, m_objColorLookupLSH);
                        else if (m_arrDefectColorSystem[i] == 1)
                            EasyImage.Threshold(objSampleUnitROI.ref_CROI, objThresholdSampleROI_Temp.ref_ROI, m_objColorBlobs.ref_C24LowColorThreshold, m_objColorBlobs.ref_C24HighColorThreshold, m_objColorLookupRGB);
                        else
                        {
                            EasyColor.GetComponent(objSampleUnitROI.ref_CROI, objThresholdSampleROI_Temp.ref_ROI, 1, m_objColorLookupYSH);
                            if (blnDebugImage)
                                objThresholdSampleROI_Temp.SaveImage("D:\\TS\\1_2.SaturationImg" + i + ".bmp");
#if (Debug_2_12 || Release_2_12)
                            EasyImage.Threshold(objThresholdSampleROI_Temp.ref_ROI, objThresholdSampleROI_Temp.ref_ROI, (uint)m_arrDefectColor[i][0]);
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                    EasyImage.Threshold(objThresholdSampleROI_Temp.ref_ROI, objThresholdSampleROI_Temp.ref_ROI, m_arrDefectColor[i][0]);
#endif
                        }

                        if (blnDebugImage)
                            objThresholdSampleROI_Temp.SaveImage("D:\\TS\\2.objThresholdSampleROI_Temp" + i + ".bmp");

                        if (m_arrDefectCloseIteration[i] > 0)
                        {
#if (Debug_2_12 || Release_2_12)
                            EasyImage.CloseBox(objThresholdSampleROI_Temp.ref_ROI, objThresholdSampleROI_Temp.ref_ROI, (uint)Math.Abs(m_arrDefectCloseIteration[i]), (uint)Math.Abs(m_arrDefectCloseIteration[i]));
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                            EasyImage.CloseBox(objThresholdSampleROI_Temp.ref_ROI, objThresholdSampleROI_Temp.ref_ROI, Math.Abs(m_arrDefectCloseIteration[i]), Math.Abs(m_arrDefectCloseIteration[i]));
#endif
                        }

                        if (blnDebugImage)
                            objThresholdSampleROI_Temp.SaveImage("D:\\TS\\3.objThresholdSampleROI_Temp" + i + ".bmp");

                        if (m_arrDefectInvertBlackWhite[i])
                        {
                            EasyImage.Oper(EArithmeticLogicOperation.Invert, objThresholdSampleROI_Temp.ref_ROI, objThresholdSampleROI_Temp.ref_ROI);
                        }

                        if (blnDebugImage)
                            objThresholdSampleROI_Temp.SaveImage("D:\\TS\\4.objThresholdSampleROI_Temp" + i + ".bmp");

                        SubtractColorDontCareImage(objThresholdSampleROI_Temp, m_arrDefectDontCareMode[i], m_arrPackageColorDontCareImage[i], objWhiteImage, objBlackImage, arrStartX, arrStartY, arrEndX, arrEndY);

                        objThresholdSampleROI_Temp.LoadROISetting(objSampleUnitROI.ref_ROITotalX + GetColorDefectInspection_Left(i),
                            objSampleUnitROI.ref_ROITotalY + GetColorDefectInspection_Top(i),
                            objSampleUnitROI.ref_ROIWidth - GetColorDefectInspection_Left(i) - GetColorDefectInspection_Right(i),
                            objSampleUnitROI.ref_ROIHeight - GetColorDefectInspection_Top(i) - GetColorDefectInspection_Bottom(i));

                        objThresholdSampleROI.LoadROISetting(objSampleUnitROI.ref_ROITotalX + GetColorDefectInspection_Left(i),
                         objSampleUnitROI.ref_ROITotalY + GetColorDefectInspection_Top(i),
                         objSampleUnitROI.ref_ROIWidth - GetColorDefectInspection_Left(i) - GetColorDefectInspection_Right(i),
                         objSampleUnitROI.ref_ROIHeight - GetColorDefectInspection_Top(i) - GetColorDefectInspection_Bottom(i));

                        if (blnDebugImage)
                            objThresholdSampleROI_Temp.SaveImage("D:\\TS\\5.objThresholdSampleROI_Temp" + i + ".bmp");

                        if (!blnFirstTime)
                        {
                            ROI.LogicOperationAddROI(objThresholdSampleROI, objThresholdSampleROI_Temp);
                        }
                        else
                        {
                            objThresholdSampleROI_Temp.CopyImage(ref objThresholdSampleROI);
                        }

                        if (blnDebugImage)
                        {
                            objThresholdSampleROI.SaveImage("D:\\TS\\6.objThresholdSampleROI" + i + ".bmp");
                        }
                        blnFirstTime = false;
                    }
                }
                else
                    continue;
                
                objThresholdSampleROI.LoadROISetting(objSampleUnitROI.ref_ROITotalX,
                 objSampleUnitROI.ref_ROITotalY,
                 objSampleUnitROI.ref_ROIWidth,
                 objSampleUnitROI.ref_ROIHeight);

                if (blnDebugImage)
                {
                    objThresholdSampleROI.SaveImage("D:\\TS\\7.objThresholdSampleROI" + intColorThresIndex + ".bmp");
                }
                
                bool blnCheckLength = false;
                bool blnCheckArea = false;
                int intFailMask = 0;
                if (intColorThresIndex == 0)
                {
                    intFailMask = 0x01;
                    if ((m_intFailColorOptionMask & 0x01) > 0)
                        blnCheckLength = true;
                    if ((m_intFailColorOptionMask & 0x02) > 0)
                        blnCheckArea = true;
                }
                else if (intColorThresIndex == 1)
                {
                    intFailMask = 0x02;
                    if ((m_intFailColorOptionMask & 0x04) > 0)
                        blnCheckLength = true;
                    if ((m_intFailColorOptionMask & 0x08) > 0)
                        blnCheckArea = true;
                }
                else if (intColorThresIndex == 2)
                {
                    intFailMask = 0x04;
                    if ((m_intFailColorOptionMask & 0x10) > 0)
                        blnCheckLength = true;
                    if ((m_intFailColorOptionMask & 0x20) > 0)
                        blnCheckArea = true;
                }
                else if (intColorThresIndex == 3)
                {
                    intFailMask = 0x08;
                    if ((m_intFailColorOptionMask & 0x40) > 0)
                        blnCheckLength = true;
                    if ((m_intFailColorOptionMask & 0x80) > 0)
                        blnCheckArea = true;
                }
                else if (intColorThresIndex == 4)
                {
                    intFailMask = 0x10;
                    if ((m_intFailColorOptionMask & 0x100) > 0)
                        blnCheckLength = true;
                    if ((m_intFailColorOptionMask & 0x200) > 0)
                        blnCheckArea = true;
                }

                int intSelectedObjectNum = 0;
                intSelectedObjectNum = m_objColorBlobs.BuildObjects_Filter_GetElement(objThresholdSampleROI, false, true, 0, -4,
                m_arrDefectColorMinArea[intColorThresIndex], objSampleUnitROI.ref_ROIWidth * objSampleUnitROI.ref_ROIHeight, false, 0xFF);

                //if (intSelectedObjectNum == 0 && m_arrDefectType[intColorThresIndex] == 1)
                //{
                //    ColorDefect objDefect = new ColorDefect();

                //    objDefect.ref_strName = m_arrDefectColorThresName[intColorThresIndex];
                //    objDefect.ref_intFailMask = intFailMask;
                //    objDefect.ref_fCenterX = -1;
                //    objDefect.ref_fCenterY = -1;
                //    objDefect.ref_fStartX = -1;
                //    objDefect.ref_fStartY = -1;
                //    objDefect.ref_fEndX = -1;
                //    objDefect.ref_fEndY = -1;
                //    objDefect.ref_fWidth = -1;
                //    objDefect.ref_fHeight = -1;
                //    objDefect.ref_fArea = -1;
                //    objDefect.ref_fWidthInMM = -1;
                //    objDefect.ref_fHeightInMM = -1;
                //    objDefect.ref_fAreaInMM2 = -1;
                //    objDefect.ref_intImageNo = m_arrDefectImageNo[intColorThresIndex] + 1;

                //    objDefect.ref_fAreaFailValue = -1;
                //    objDefect.ref_intFailCriteria |= 0x10;

                //    m_arrColorDefectList.Add(objDefect);

                //    m_intFailColorResultMask |= intFailMask;

                //    blnResult = false;
                //}

                bool blnOverallResult = true;
                if (intSelectedObjectNum > 0)
                {
                    float fCenterX = 0, fCenterY = 0, fWidth = 0, fHeight = 0;
                    float fStartX, fStartY, fEndX, fEndY, fAngle = 0;
                    int intArea = 0;
                    float fWidthMM, fHeightMM, fAreaInMM;
                    int intFailCount = 0;

                    int intTotalArea = 0;
                    for (int i = 0; i < intSelectedObjectNum; i++)
                    {
                        intArea = m_objColorBlobs.ref_arrArea[i];

                        if (m_objColorBlobs.ref_arrRectWidth[i] < m_objColorBlobs.ref_arrRectHeight[i])
                        {
                            fWidth = m_objColorBlobs.ref_arrRectWidth[i];
                            fHeight = m_objColorBlobs.ref_arrRectHeight[i];

                            fAngle = m_objColorBlobs.ref_arrRectAngle[i];


                            if (fAngle < 0)
                                fAngle = -Math.Abs(fAngle);
                            else
                                fAngle = -fAngle;
                        }
                        else
                        {
                            fWidth = m_objColorBlobs.ref_arrRectHeight[i];
                            fHeight = m_objColorBlobs.ref_arrRectWidth[i];

                            fAngle = m_objColorBlobs.ref_arrRectAngle[i];


                            if (fAngle < 0)
                                fAngle = Math.Abs(fAngle);
                            else
                                fAngle = 90 - (fAngle);
                        }
                        fCenterX = m_objColorBlobs.ref_arrRectLimitCenterX[i];
                        fCenterY = m_objColorBlobs.ref_arrRectLimitCenterY[i];

                        intTotalArea += intArea;
                        fCenterX += intStartPixelFromEdgeX;
                        fCenterY += intStartPixelFromEdgeY;
                        fStartX = (float)Math.Floor(fCenterX - (fWidth / 2));
                        fStartY = (float)Math.Floor(fCenterY - (fHeight / 2));
                        fEndX = (float)Math.Ceiling(fCenterX + (fWidth / 2));
                        fEndY = (float)Math.Ceiling(fCenterY + (fHeight / 2));

                        // convert width and height to mm
                        fWidthMM = fWidth / m_fMMToPixelXValue;
                        fHeightMM = fHeight / m_fMMToPixelYValue; // 11-04-2019 ZJYEOH : Changed m_fMMToPixelXValue to m_fMMToPixelYValue
                        fAreaInMM = intArea / m_fMMToPixelXValue / m_fMMToPixelYValue;

                        {
                            intFailCount++;

                            ColorDefect objDefect = new ColorDefect();

                            objDefect.ref_strName = m_arrDefectColorThresName[intColorThresIndex];
                            objDefect.ref_intFailMask = intFailMask;
                            objDefect.ref_fCenterX = objThresholdSampleROI.ref_ROITotalX + fCenterX;
                            objDefect.ref_fCenterY = objThresholdSampleROI.ref_ROITotalY + fCenterY;
                            objDefect.ref_fStartX = objThresholdSampleROI.ref_ROITotalX + fStartX;
                            objDefect.ref_fStartY = objThresholdSampleROI.ref_ROITotalY + fStartY;
                            objDefect.ref_fEndX = objThresholdSampleROI.ref_ROITotalX + fEndX;
                            objDefect.ref_fEndY = objThresholdSampleROI.ref_ROITotalY + fEndY;
                            objDefect.ref_fWidth = fWidth;
                            objDefect.ref_fHeight = fHeight;
                            objDefect.ref_fArea = intArea;
                            objDefect.ref_fAngle = fAngle;
                            objDefect.ref_fWidthInMM = fWidthMM;
                            objDefect.ref_fHeightInMM = fHeightMM;
                            objDefect.ref_fAreaInMM2 = fAreaInMM;
                            objDefect.ref_intImageNo = m_arrDefectImageNo[intColorThresIndex] + 1;

                            if (blnCheckLength)
                            {
                                if (m_arrDefectColorInspectionFailCondition[intColorThresIndex] == 0)
                                {
                                    if (fWidthMM > m_arrDefectColorInspectionWidth[intColorThresIndex])
                                    {
                                        m_intFailColorResultMask |= intFailMask;

                                        blnOverallResult = false;
                                        objDefect.ref_fWidthFailValue = fWidthMM;
                                        objDefect.ref_intFailCriteria |= 0x01;
                                        blnResult = false;
                                        m_strErrorMessage += "* " + objDefect.ref_strName + " Width Fail. Set = " + m_arrDefectColorInspectionWidth[intColorThresIndex].ToString("f5") + " mm,   Result = " + fWidthMM.ToString("f5") + " mm";
                                    }
                                    if (fHeightMM > m_arrDefectColorInspectionLength[intColorThresIndex])
                                    {
                                        m_intFailColorResultMask |= intFailMask;

                                        blnOverallResult = false;
                                        objDefect.ref_fHeightFailValue = fHeightMM;
                                        objDefect.ref_intFailCriteria |= 0x02;
                                        blnResult = false;
                                        m_strErrorMessage += "* " + objDefect.ref_strName + " Length Fail. Set = " + m_arrDefectColorInspectionLength[intColorThresIndex].ToString("f5") + " mm,   Result = " + fHeightMM.ToString("f5") + " mm";
                                    }
                                }
                                else
                                {
                                    if ((fWidthMM > m_arrDefectColorInspectionWidth[intColorThresIndex]) && (fHeightMM > m_arrDefectColorInspectionLength[intColorThresIndex]))
                                    {
                                        m_intFailColorResultMask |= intFailMask;

                                        blnOverallResult = false;
                                        objDefect.ref_fWidthFailValue = fWidthMM;
                                        objDefect.ref_fHeightFailValue = fHeightMM;
                                        objDefect.ref_intFailCriteria |= 0x01;
                                        objDefect.ref_intFailCriteria |= 0x02;
                                        blnResult = false;
                                        m_strErrorMessage += "* " + objDefect.ref_strName + " Width Fail. Set = " + m_arrDefectColorInspectionWidth[intColorThresIndex].ToString("f5") + " mm,   Result = " + fWidthMM.ToString("f5") + " mm";
                                        m_strErrorMessage += "* " + objDefect.ref_strName + " Length Fail. Set = " + m_arrDefectColorInspectionLength[intColorThresIndex].ToString("f5") + " mm,   Result = " + fHeightMM.ToString("f5") + " mm";
                                    }
                                }
                            }

                            if (blnCheckArea)
                            {
                                if (/*fAreaInMM < m_arrDefectColorInspectionMinArea[intColorThresIndex] ||*/ fAreaInMM > m_arrDefectColorInspectionMaxArea[intColorThresIndex])
                                {
                                    m_intFailColorResultMask |= intFailMask;

                                    blnOverallResult = false;
                                    objDefect.ref_fAreaFailValue = fAreaInMM;
                                    objDefect.ref_intFailCriteria |= 0x04;
                                    blnResult = false;
                                    m_strErrorMessage += "* " + objDefect.ref_strName + " Area Fail. Set = " + m_arrDefectColorInspectionMaxArea[intColorThresIndex].ToString("f5") + " mm^2,   Result = " + fAreaInMM.ToString("f5") + " mm^2";
                                }
                            }

                            m_arrColorDefectList.Add(objDefect);
                        }

                    }

                    if (blnCheckArea)
                    {
                        fAreaInMM = intTotalArea / m_fMMToPixelXValue / m_fMMToPixelYValue;

                        if (fAreaInMM > m_arrDefectColorInspectionTotalArea[intColorThresIndex])
                        {
                            ColorDefect objDefect = new ColorDefect();

                            objDefect.ref_strName = "Total " + m_arrDefectColorThresName[intColorThresIndex];
                            objDefect.ref_intFailMask = intFailMask;
                            objDefect.ref_fCenterX = -1;
                            objDefect.ref_fCenterY = -1;
                            objDefect.ref_fStartX = -1;
                            objDefect.ref_fStartY = -1;
                            objDefect.ref_fEndX = -1;
                            objDefect.ref_fEndY = -1;
                            objDefect.ref_fWidth = -1;
                            objDefect.ref_fHeight = -1;
                            objDefect.ref_fArea = intTotalArea;
                            objDefect.ref_fWidthInMM = -1;
                            objDefect.ref_fHeightInMM = -1;
                            objDefect.ref_fAreaInMM2 = fAreaInMM;
                            objDefect.ref_intImageNo = m_arrDefectImageNo[intColorThresIndex] + 1;
                            objDefect.ref_blnFailTotalArea = true;

                            blnOverallResult = false;
                            objDefect.ref_fAreaFailValue = fAreaInMM;
                            objDefect.ref_intFailCriteria |= 0x08;

                            m_arrColorDefectList.Add(objDefect);

                            m_intFailColorResultMask |= intFailMask;

                            m_strErrorMessage += "* " + objDefect.ref_strName + " Area Fail. Set = " + m_arrDefectColorInspectionTotalArea[intColorThresIndex].ToString("f5") + " mm^2,   Result = " + fAreaInMM.ToString("f5") + " mm^2";

                            for (int b = 0; b < m_arrColorDefectList.Count; b++)
                            {
                                if (((ColorDefect)m_arrColorDefectList[b]).ref_strName == m_arrDefectColorThresName[intColorThresIndex])
                                {
                                    if (!((ColorDefect)m_arrColorDefectList[b]).ref_blnFailTotalArea)
                                    {
                                        ColorDefect objDefect2 = m_arrColorDefectList[b];
                                        objDefect2.ref_blnFailTotalArea = true;
                                        m_arrColorDefectList.RemoveAt(b);
                                        m_arrColorDefectList.Insert(b, objDefect2);
                                    }
                                }
                            }

                            blnResult = false;
                        }

                    }
                }
            }
            objThresholdSampleROI.Dispose();
            objThresholdSampleROI_Temp.Dispose();
            objImageTemp.Dispose();
            objImageTemp2.Dispose();
            return blnResult;
        }
        public bool CheckColorDefect_CombineSameName_LinkNearest(CROI objSampleUnitROI, List<CImageDrawing> arrColorImages, ImageDrawing objWhiteImage, ImageDrawing objBlackImage, List<int> arrStartX, List<int> arrStartY, List<int> arrEndX, List<int> arrEndY)
        {
            if (m_arrDefectColorThresName.Count == 0)
                return true;

            if ((((m_intFailColorOptionMask & 0x03) == 0) && m_arrDefectColorThresName.Count == 1) &&
                (((m_intFailColorOptionMask & 0x0C) == 0) && m_arrDefectColorThresName.Count == 2) &&
                (((m_intFailColorOptionMask & 0x30) == 0) && m_arrDefectColorThresName.Count == 3) &&
                (((m_intFailColorOptionMask & 0xC0) == 0) && m_arrDefectColorThresName.Count == 4) &&
                (((m_intFailColorOptionMask & 0x300) == 0) && m_arrDefectColorThresName.Count == 5))
                return true;

            bool blnResult = true;
            bool blnDebugImage = false;

            //float fPkgOffsetX = (objSampleUnitROI.ref_ROIWidth - Math.Max(GetResultUpWidth_RectGauge4L(0), GetResultDownWidth_RectGauge4L(0))) / 2;
            //float fPkgOffsetY = (objSampleUnitROI.ref_ROIHeight - Math.Max(GetResultLeftHeight_RectGauge4L(0), GetResultRightHeight_RectGauge4L(0))) / 2;

            int intStartPixelFromEdgeX = 0;// (int)Math.Round(fPkgOffsetX - m_intPadROIStartPixelFromLeft, 0, MidpointRounding.AwayFromZero); //m_fPkgStartPixelFromLeft
            int intStartPixelFromEdgeY = 0;// (int)Math.Round(fPkgOffsetY - m_intPadROIStartPixelFromTop, 0, MidpointRounding.AwayFromZero); //m_fPkgStartPixelFromEdge
            //int intStartPixelFromEdgeX2 = (int)Math.Round(fPkgOffsetX + m_intPadROIStartPixelFromRight, 0, MidpointRounding.AwayFromZero); //m_fPkgStartPixelFromRight
            //int intStartPixelFromEdgeY2 = (int)Math.Round(fPkgOffsetY + m_intPadROIStartPixelFromBottom, 0, MidpointRounding.AwayFromZero); //m_fPkgStartPixelFromBottom
            ImageDrawing objImageTemp = new ImageDrawing(true, arrColorImages[0].ref_intImageWidth, arrColorImages[0].ref_intImageHeight);
            ROI objThresholdSampleROI = new ROI();
            objThresholdSampleROI.AttachImage(objImageTemp); // Attach sample ROI to ori size image. m_objInsPadPkgImage1 is a ori size image used to keep the sample image temporary for modification such as double threshold
            objThresholdSampleROI.LoadROISetting(objSampleUnitROI.ref_ROIPositionX, objSampleUnitROI.ref_ROIPositionY, objSampleUnitROI.ref_ROIWidth, objSampleUnitROI.ref_ROIHeight);

            ImageDrawing objImageTemp2 = new ImageDrawing(true, arrColorImages[0].ref_intImageWidth, arrColorImages[0].ref_intImageHeight);
            ROI objThresholdSampleROI_Temp = new ROI();
            objThresholdSampleROI_Temp.AttachImage(objImageTemp2); // Attach sample ROI to ori size image. m_objInsSurfacePkgImage1 is a ori size image used to keep the sample image temporary for modification such as double threshold
            objThresholdSampleROI_Temp.LoadROISetting(objSampleUnitROI.ref_ROIPositionX, objSampleUnitROI.ref_ROIPositionY, objSampleUnitROI.ref_ROIWidth, objSampleUnitROI.ref_ROIHeight);

            if (blnDebugImage)
            {
                objSampleUnitROI.SaveImage("D:\\TS\\1.objSampleUnitROI.bmp");
            }
            List<int> arrSkip = new List<int>();

            for (int intColorThresIndex = 0; intColorThresIndex < m_arrDefectColor.Count; intColorThresIndex++)
            {
                if (intColorThresIndex == 0 && ((m_intFailColorOptionMask & 0x03) == 0))
                    continue;
                else if (intColorThresIndex == 1 && ((m_intFailColorOptionMask & 0x0C) == 0))
                    continue;
                else if (intColorThresIndex == 2 && ((m_intFailColorOptionMask & 0x30) == 0))
                    continue;
                else if (intColorThresIndex == 3 && ((m_intFailColorOptionMask & 0xC0) == 0))
                    continue;
                else if (intColorThresIndex == 4 && ((m_intFailColorOptionMask & 0x300) == 0))
                    continue;

                if (!blnResult)
                    break;

                objBlackImage.CopyTo(ref objImageTemp);

                string strThresName = m_arrDefectColorThresName[intColorThresIndex];
                if (!arrSkip.Contains(intColorThresIndex))
                {
                    bool blnFirstTime = true;
                    for (int i = 0; i < m_arrDefectColor.Count; i++)
                    {
                        if (!arrSkip.Contains(i) && strThresName == m_arrDefectColorThresName[i])
                        {
                            arrSkip.Add(i);
                        }
                        else
                            continue;

                        objSampleUnitROI.AttachImage(arrColorImages[CImageDrawing.GetArrayImageIndex(m_arrDefectImageNo[i], m_intVisionIndex)]);

                        if (blnDebugImage)
                        {
                            objSampleUnitROI.SaveImage("D:\\TS\\1_1.objSampleUnitROI2.bmp");
                        }
                        objBlackImage.CopyTo(ref objImageTemp2);

                        // Get color threshold min max value
                        m_objColorBlobs.ref_C24LowColorThreshold = ColorProcessing.CalculateMinColor(m_arrDefectColor[i], m_arrDefectColorTolerance[i]).ref_Color24;
                        m_objColorBlobs.ref_C24HighColorThreshold = ColorProcessing.CalculateMaxColor(m_arrDefectColor[i], m_arrDefectColorTolerance[i]).ref_Color24;

                        objThresholdSampleROI_Temp.LoadROISetting(objSampleUnitROI.ref_ROITotalX,
                            objSampleUnitROI.ref_ROITotalY,
                            objSampleUnitROI.ref_ROIWidth,
                            objSampleUnitROI.ref_ROIHeight);

                        // Threshold color image 
                        if (m_arrDefectColorSystem[i] == 0)
                            EasyImage.Threshold(objSampleUnitROI.ref_CROI, objThresholdSampleROI_Temp.ref_ROI, m_objColorBlobs.ref_C24LowColorThreshold, m_objColorBlobs.ref_C24HighColorThreshold, m_objColorLookupLSH);
                        else if (m_arrDefectColorSystem[i] == 1)
                            EasyImage.Threshold(objSampleUnitROI.ref_CROI, objThresholdSampleROI_Temp.ref_ROI, m_objColorBlobs.ref_C24LowColorThreshold, m_objColorBlobs.ref_C24HighColorThreshold, m_objColorLookupRGB);
                        else
                        {
                            EasyColor.GetComponent(objSampleUnitROI.ref_CROI, objThresholdSampleROI_Temp.ref_ROI, 1, m_objColorLookupYSH);
                            if (blnDebugImage)
                                objThresholdSampleROI_Temp.SaveImage("D:\\TS\\1_2.SaturationImg" + i + ".bmp");
#if (Debug_2_12 || Release_2_12)
                            EasyImage.Threshold(objThresholdSampleROI_Temp.ref_ROI, objThresholdSampleROI_Temp.ref_ROI, (uint)m_arrDefectColor[i][0]);
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                    EasyImage.Threshold(objThresholdSampleROI_Temp.ref_ROI, objThresholdSampleROI_Temp.ref_ROI, m_arrDefectColor[i][0]);
#endif
                        }

                        if (blnDebugImage)
                            objThresholdSampleROI_Temp.SaveImage("D:\\TS\\2.objThresholdSampleROI_Temp" + i + ".bmp");

                        if (m_arrDefectCloseIteration[i] > 0)
                        {
#if (Debug_2_12 || Release_2_12)
                            EasyImage.CloseBox(objThresholdSampleROI_Temp.ref_ROI, objThresholdSampleROI_Temp.ref_ROI, (uint)Math.Abs(m_arrDefectCloseIteration[i]), (uint)Math.Abs(m_arrDefectCloseIteration[i]));
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                            EasyImage.CloseBox(objThresholdSampleROI_Temp.ref_ROI, objThresholdSampleROI_Temp.ref_ROI, Math.Abs(m_arrDefectCloseIteration[i]), Math.Abs(m_arrDefectCloseIteration[i]));
#endif
                        }

                        if (blnDebugImage)
                            objThresholdSampleROI_Temp.SaveImage("D:\\TS\\3.objThresholdSampleROI_Temp" + i + ".bmp");

                        if (m_arrDefectInvertBlackWhite[i])
                        {
                            EasyImage.Oper(EArithmeticLogicOperation.Invert, objThresholdSampleROI_Temp.ref_ROI, objThresholdSampleROI_Temp.ref_ROI);
                        }

                        if (blnDebugImage)
                            objThresholdSampleROI_Temp.SaveImage("D:\\TS\\4.objThresholdSampleROI_Temp" + i + ".bmp");

                        SubtractColorDontCareImage(objThresholdSampleROI_Temp, m_arrDefectDontCareMode[i], m_arrPackageColorDontCareImage[i], objWhiteImage, objBlackImage, arrStartX, arrStartY, arrEndX, arrEndY);

                        objThresholdSampleROI_Temp.LoadROISetting(objSampleUnitROI.ref_ROITotalX + GetColorDefectInspection_Left(i),
                            objSampleUnitROI.ref_ROITotalY + GetColorDefectInspection_Top(i),
                            objSampleUnitROI.ref_ROIWidth - GetColorDefectInspection_Left(i) - GetColorDefectInspection_Right(i),
                            objSampleUnitROI.ref_ROIHeight - GetColorDefectInspection_Top(i) - GetColorDefectInspection_Bottom(i));

                        objThresholdSampleROI.LoadROISetting(objSampleUnitROI.ref_ROITotalX + GetColorDefectInspection_Left(i),
                         objSampleUnitROI.ref_ROITotalY + GetColorDefectInspection_Top(i),
                         objSampleUnitROI.ref_ROIWidth - GetColorDefectInspection_Left(i) - GetColorDefectInspection_Right(i),
                         objSampleUnitROI.ref_ROIHeight - GetColorDefectInspection_Top(i) - GetColorDefectInspection_Bottom(i));

                        if (blnDebugImage)
                            objThresholdSampleROI_Temp.SaveImage("D:\\TS\\5.objThresholdSampleROI_Temp" + i + ".bmp");

                        if (!blnFirstTime)
                        {
                            ROI.LogicOperationAddROI(objThresholdSampleROI, objThresholdSampleROI_Temp);
                        }
                        else
                        {
                            objThresholdSampleROI_Temp.CopyImage(ref objThresholdSampleROI);
                        }

                        if (blnDebugImage)
                        {
                            objThresholdSampleROI.SaveImage("D:\\TS\\6.objThresholdSampleROI" + i + ".bmp");
                        }
                        blnFirstTime = false;
                    }
                }
                else
                    continue;
                
                objThresholdSampleROI.LoadROISetting(objSampleUnitROI.ref_ROITotalX,
                 objSampleUnitROI.ref_ROITotalY,
                 objSampleUnitROI.ref_ROIWidth,
                 objSampleUnitROI.ref_ROIHeight);

                if (blnDebugImage)
                {
                    objThresholdSampleROI.SaveImage("D:\\TS\\7.objThresholdSampleROI" + intColorThresIndex + ".bmp");
                }

                bool blnCheckLength = false;
                bool blnCheckArea = false;
                int intFailMask = 0;
                if (intColorThresIndex == 0)
                {
                    intFailMask = 0x01;
                    if ((m_intFailColorOptionMask & 0x01) > 0)
                        blnCheckLength = true;
                    if ((m_intFailColorOptionMask & 0x02) > 0)
                        blnCheckArea = true;
                }
                else if (intColorThresIndex == 1)
                {
                    intFailMask = 0x02;
                    if ((m_intFailColorOptionMask & 0x04) > 0)
                        blnCheckLength = true;
                    if ((m_intFailColorOptionMask & 0x08) > 0)
                        blnCheckArea = true;
                }
                else if (intColorThresIndex == 2)
                {
                    intFailMask = 0x04;
                    if ((m_intFailColorOptionMask & 0x10) > 0)
                        blnCheckLength = true;
                    if ((m_intFailColorOptionMask & 0x20) > 0)
                        blnCheckArea = true;
                }
                else if (intColorThresIndex == 3)
                {
                    intFailMask = 0x08;
                    if ((m_intFailColorOptionMask & 0x40) > 0)
                        blnCheckLength = true;
                    if ((m_intFailColorOptionMask & 0x80) > 0)
                        blnCheckArea = true;
                }
                else if (intColorThresIndex == 4)
                {
                    intFailMask = 0x10;
                    if ((m_intFailColorOptionMask & 0x100) > 0)
                        blnCheckLength = true;
                    if ((m_intFailColorOptionMask & 0x200) > 0)
                        blnCheckArea = true;
                }

                int intSelectedObjectNum = 0;
                intSelectedObjectNum = m_objColorBlobs.BuildObjects_Filter_GetElement(objThresholdSampleROI, false, true, 0, -4,
                m_arrDefectColorMinArea[intColorThresIndex], objSampleUnitROI.ref_ROIWidth * objSampleUnitROI.ref_ROIHeight, false, 0xFF);

                //if (intSelectedObjectNum == 0 && m_arrDefectType[intColorThresIndex] == 1)
                //{
                //    ColorDefect objDefect = new ColorDefect();

                //    objDefect.ref_strName = m_arrDefectColorThresName[intColorThresIndex];
                //    objDefect.ref_intFailMask = intFailMask;
                //    objDefect.ref_fCenterX = -1;
                //    objDefect.ref_fCenterY = -1;
                //    objDefect.ref_fStartX = -1;
                //    objDefect.ref_fStartY = -1;
                //    objDefect.ref_fEndX = -1;
                //    objDefect.ref_fEndY = -1;
                //    objDefect.ref_fWidth = -1;
                //    objDefect.ref_fHeight = -1;
                //    objDefect.ref_fArea = -1;
                //    objDefect.ref_fWidthInMM = -1;
                //    objDefect.ref_fHeightInMM = -1;
                //    objDefect.ref_fAreaInMM2 = -1;
                //    objDefect.ref_intImageNo = m_arrDefectImageNo[intColorThresIndex] + 1;

                //    objDefect.ref_fAreaFailValue = -1;
                //    objDefect.ref_intFailCriteria |= 0x10;

                //    m_arrColorDefectList.Add(objDefect);

                //    m_intFailColorResultMask |= intFailMask;

                //    blnResult = false;
                //}

                bool blnOverallResult = true;
                if (intSelectedObjectNum > 0)
                {
                    List<List<System.Windows.Point>> arr2DPoints = new List<List<System.Windows.Point>>();
                    List<List<PointF>> arrRotatedPoints = new List<List<PointF>>();
                    List<float> fObjectHeightList = new List<float>(), fObjectWidthList = new List<float>(), fObjectCenterXList = new List<float>(), fObjectCenterYList = new List<float>(), fObjectAngleList = new List<float>();
                    List<float> fObjectLimitHeightList = new List<float>(), fObjectLimitWidthList = new List<float>(), fObjectLimitCenterXList = new List<float>(), fObjectLimitCenterYList = new List<float>();
                    List<int> fObjectAreaList = new List<int>(), fObjectAreaList2 = new List<int>();
                    int intObjectTotalArea = 0;
                    int intObjectArea = 0;
                    int intLengthMode = 0;
                    float fObjectHeight = 0, fObjectWidth = 0, fObjectCenterX = 0, fObjectCenterY = 0, fObjectAngle = 0;
                    float fObjectLimitHeight = 0, fObjectLimitWidth = 0, fObjectLimitCenterX = 0, fObjectLimitCenterY = 0;
                    bool blnOverAllFail = false;
                    for (int i = 0; i < intSelectedObjectNum; i++)
                    {
                        arrRotatedPoints.Add(new List<PointF>());
                        arr2DPoints.Add(new List<System.Windows.Point>());
                        intObjectArea = m_objColorBlobs.ref_arrArea[i];

                        if (m_objColorBlobs.ref_arrRectHeight[i] < m_objColorBlobs.ref_arrRectWidth[i])
                        {
                            fObjectWidth = m_objColorBlobs.ref_arrRectHeight[i];
                            fObjectHeight = m_objColorBlobs.ref_arrRectWidth[i];
                            intLengthMode = 0;
                            fObjectAngle = m_objColorBlobs.ref_arrRectAngle[i];

                            if (fObjectAngle >= 10)//&& fAngle <= 80)
                                fObjectAngle = m_objColorBlobs.ref_arrRectAngle[i] - 90;
                            else
                                fObjectAngle = 90 + m_objColorBlobs.ref_arrRectAngle[i];

                        }
                        else
                        {
                            fObjectHeight = m_objColorBlobs.ref_arrRectHeight[i];
                            fObjectWidth = m_objColorBlobs.ref_arrRectWidth[i];
                            intLengthMode = 0;

                            fObjectAngle = m_objColorBlobs.ref_arrRectAngle[i];

                        }
                        fObjectCenterX = m_objColorBlobs.ref_arrRectLimitCenterX[i];
                        fObjectCenterY = m_objColorBlobs.ref_arrRectLimitCenterY[i];

                        fObjectLimitCenterX = m_objColorBlobs.ref_arrLimitCenterX[i];
                        fObjectLimitCenterY = m_objColorBlobs.ref_arrLimitCenterY[i];
                        fObjectLimitWidth = m_objColorBlobs.ref_arrWidth[i];
                        fObjectLimitHeight = m_objColorBlobs.ref_arrHeight[i];

                        intObjectTotalArea += intObjectArea;
                        //float MaxX = 0, MaxY = 0, MinX = 0, MinY = 0;
                        float newX1 = 0, newY1 = 0;  // new point 1
                        float newX2 = 0, newY2 = 0; // new point 2
                        float newX3 = 0, newY3 = 0; // new point 3
                        float newX4 = 0, newY4 = 0; // new point 4

                        //2020-12-18 ZJYEOH : Change to this format
                        //  Point 1 *-------------* Point 2
                        //          |             |
                        //          |             |
                        //          |             |
                        //  Point 4 *-------------* Point 3

                        Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX - (fObjectWidth / 2)), (fObjectCenterY - (fObjectHeight / 2)), fObjectAngle, ref newX1, ref newY1);
                        Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX + (fObjectWidth / 2)), (fObjectCenterY - (fObjectHeight / 2)), fObjectAngle, ref newX2, ref newY2);
                        Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX + (fObjectWidth / 2)), (fObjectCenterY + (fObjectHeight / 2)), fObjectAngle, ref newX3, ref newY3);
                        Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX - (fObjectWidth / 2)), (fObjectCenterY + (fObjectHeight / 2)), fObjectAngle, ref newX4, ref newY4);


                        arrRotatedPoints[i].Add(new PointF(newX1, newY1));
                        arrRotatedPoints[i].Add(new PointF(newX2, newY2));
                        arrRotatedPoints[i].Add(new PointF(newX3, newY3));
                        arrRotatedPoints[i].Add(new PointF(newX4, newY4));

                        Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX - (fObjectWidth / 2)) - m_intColorDefectLinkTolerance, (fObjectCenterY - (fObjectHeight / 2)) - m_intColorDefectLinkTolerance, fObjectAngle, ref newX1, ref newY1);
                        Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX + (fObjectWidth / 2)) + m_intColorDefectLinkTolerance, (fObjectCenterY - (fObjectHeight / 2)) - m_intColorDefectLinkTolerance, fObjectAngle, ref newX2, ref newY2);
                        Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX + (fObjectWidth / 2)) + m_intColorDefectLinkTolerance, (fObjectCenterY + (fObjectHeight / 2)) + m_intColorDefectLinkTolerance, fObjectAngle, ref newX3, ref newY3);
                        Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX - (fObjectWidth / 2)) - m_intColorDefectLinkTolerance, (fObjectCenterY + (fObjectHeight / 2)) + m_intColorDefectLinkTolerance, fObjectAngle, ref newX4, ref newY4);

                        arr2DPoints[i].Add(new System.Windows.Point(newX1, newY1));
                        arr2DPoints[i].Add(new System.Windows.Point(newX2, newY2));
                        arr2DPoints[i].Add(new System.Windows.Point(newX3, newY3));
                        arr2DPoints[i].Add(new System.Windows.Point(newX4, newY4));

                        fObjectHeightList.Add(fObjectHeight);
                        fObjectWidthList.Add(fObjectWidth);
                        fObjectCenterXList.Add(fObjectCenterX);
                        fObjectCenterYList.Add(fObjectCenterY);
                        fObjectAngleList.Add(fObjectAngle);
                        fObjectAreaList.Add(intObjectArea);
                        fObjectAreaList2.Add(intObjectArea);
                    }
                    int intTolerance = m_intColorDefectLinkTolerance;
                    int intAngleTolerance = 10;
                    bool blnDecrement = false;
                    if (intTolerance >= 0)
                    {
                        for (int i = 0; i < fObjectHeightList.Count; i++)
                        {
                            if (blnDecrement)
                            {
                                blnDecrement = false;
                                if (i > 0)
                                    i--;
                            }
                            for (int j = 0; j < fObjectHeightList.Count; j++)
                            {
                                if (i != j && i < fObjectHeightList.Count && j < fObjectHeightList.Count)
                                {
                                    if (Intersection.CheckRectRectIntersection(arr2DPoints[i].ToArray(), arr2DPoints[j].ToArray(), intTolerance))
                                    {
                                        PointF[] arrPoints = new PointF[8];

                                        arrPoints[0] = arrRotatedPoints[i][0];
                                        arrPoints[1] = arrRotatedPoints[i][1];
                                        arrPoints[2] = arrRotatedPoints[i][2];
                                        arrPoints[3] = arrRotatedPoints[i][3];
                                        arrPoints[4] = arrRotatedPoints[j][0];
                                        arrPoints[5] = arrRotatedPoints[j][1];
                                        arrPoints[6] = arrRotatedPoints[j][2];
                                        arrPoints[7] = arrRotatedPoints[j][3];

                                        float fMinAngle = 0;
                                        List<PointF> arrMinRect = new List<PointF>();
                                        arrMinRect = MinimumBoundingBox.CalculateMinimumBoundingBox(arrPoints, ref fMinAngle);

                                        if (fMinAngle < 0)
                                            fObjectAngleList[i] = -(90 + fMinAngle);
                                        else
                                            fObjectAngleList[i] = 90 - fMinAngle;

                                        Line onjLine1 = new Line();
                                        Line onjLine2 = new Line();
                                        onjLine1.CalculateStraightLine(arrMinRect[0], arrMinRect[2]);
                                        onjLine2.CalculateStraightLine(arrMinRect[1], arrMinRect[3]);
                                        PointF pCenter = Line.GetCrossPoint(onjLine1, onjLine2);
                                        float p1X = 0, p1Y = 0;
                                        float p2X = 0, p2Y = 0;
                                        float p3X = 0, p3Y = 0;
                                        float p4X = 0, p4Y = 0;
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[0].X, arrMinRect[0].Y, -fObjectAngleList[i], ref p1X, ref p1Y);
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[1].X, arrMinRect[1].Y, -fObjectAngleList[i], ref p2X, ref p2Y);
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[2].X, arrMinRect[2].Y, -fObjectAngleList[i], ref p3X, ref p3Y);
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[3].X, arrMinRect[3].Y, -fObjectAngleList[i], ref p4X, ref p4Y);

                                        float pR1X = 0, pR1Y = 0;
                                        float pR2X = 0, pR2Y = 0;
                                        float pR3X = 0, pR3Y = 0;
                                        float pR4X = 0, pR4Y = 0;
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)), Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)), fObjectAngleList[i], ref pR1X, ref pR1Y); // Top Left
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)), Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)), fObjectAngleList[i], ref pR2X, ref pR2Y); // Top Right
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)), Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)), fObjectAngleList[i], ref pR3X, ref pR3Y); // Bottom Right
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)), Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)), fObjectAngleList[i], ref pR4X, ref pR4Y); // Bottom Left
                                        arrMinRect[0] = new PointF(pR1X, pR1Y);
                                        arrMinRect[1] = new PointF(pR2X, pR2Y);
                                        arrMinRect[2] = new PointF(pR3X, pR3Y);
                                        arrMinRect[3] = new PointF(pR4X, pR4Y);

                                        arrRotatedPoints[i][0] = arrMinRect[0];
                                        arrRotatedPoints[i][1] = arrMinRect[1];
                                        arrRotatedPoints[i][2] = arrMinRect[2];
                                        arrRotatedPoints[i][3] = arrMinRect[3];

                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)) - m_intColorDefectLinkTolerance, Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)) - m_intColorDefectLinkTolerance, fObjectAngleList[i], ref pR1X, ref pR1Y); // Top Left
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)) + m_intColorDefectLinkTolerance, Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)) - m_intColorDefectLinkTolerance, fObjectAngleList[i], ref pR2X, ref pR2Y); // Top Right
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)) + m_intColorDefectLinkTolerance, Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)) + m_intColorDefectLinkTolerance, fObjectAngleList[i], ref pR3X, ref pR3Y); // Bottom Right
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)) - m_intColorDefectLinkTolerance, Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)) + m_intColorDefectLinkTolerance, fObjectAngleList[i], ref pR4X, ref pR4Y); // Bottom Left

                                        arr2DPoints[i][0] = new System.Windows.Point(pR1X, pR1Y);
                                        arr2DPoints[i][1] = new System.Windows.Point(pR2X, pR2Y);
                                        arr2DPoints[i][2] = new System.Windows.Point(pR3X, pR3Y);
                                        arr2DPoints[i][3] = new System.Windows.Point(pR4X, pR4Y);

                                        arrRotatedPoints.RemoveAt(j);
                                        arr2DPoints.RemoveAt(j);

                                        float fDiffX = Math.Max(Math.Abs(p1X - p4X), Math.Abs(p2X - p3X));
                                        float fDiffY = Math.Max(Math.Abs(p3Y - p4Y), Math.Abs(p2Y - p1Y));

                                        fObjectWidthList[i] = fDiffX;
                                        fObjectHeightList[i] = fDiffY;

                                        fObjectCenterXList[i] = pCenter.X;
                                        fObjectCenterYList[i] = pCenter.Y;

                                        fObjectAreaList2.RemoveAt(j);
                                        fObjectAreaList[i] = fObjectAreaList[i] + fObjectAreaList[j];

                                        fObjectHeightList.RemoveAt(j);
                                        fObjectWidthList.RemoveAt(j);
                                        fObjectCenterXList.RemoveAt(j);
                                        fObjectCenterYList.RemoveAt(j);
                                        fObjectAngleList.RemoveAt(j);
                                        fObjectAreaList.RemoveAt(j);

                                        if (j > 0)
                                            j = -1;
                                        if (i > 0)
                                        {
                                            i = 0;
                                        }
                                        else
                                            blnDecrement = true;

                                    }
                                }
                            }
                        }
                    }
                    float fStartX, fStartY, fEndX, fEndY, fWidthMM, fHeightMM, fAreaInMM;
                    for (int i = 0; i < fObjectHeightList.Count; i++)
                    {
                        if (fObjectHeightList[i] < fObjectWidthList[i])
                        {
                            fObjectWidth = fObjectHeightList[i];
                            fObjectHeight = fObjectWidthList[i];

                            fObjectAngle = fObjectAngleList[i];

                            if (fObjectAngle >= 10)//&& fAngle <= 80)
                                fObjectAngle = fObjectAngleList[i] - 90;
                            else
                                fObjectAngle = 90 + fObjectAngleList[i];

                            fObjectWidthList[i] = fObjectWidth;
                            fObjectHeightList[i] = fObjectHeight;
                            fObjectAngleList[i] = fObjectAngle;
                        }
                        else
                        {
                            fObjectHeight = fObjectHeightList[i];
                            fObjectWidth = fObjectWidthList[i];

                            fObjectAngle = fObjectAngleList[i];

                            fObjectWidthList[i] = fObjectWidth;
                            fObjectHeightList[i] = fObjectHeight;
                            fObjectAngleList[i] = fObjectAngle;
                        }

                        fObjectCenterXList[i] += intStartPixelFromEdgeX;
                        fObjectCenterYList[i] += intStartPixelFromEdgeY;
                        fStartX = (float)Math.Floor(fObjectCenterXList[i] - (fObjectWidthList[i] / 2));
                        fStartY = (float)Math.Floor(fObjectCenterYList[i] - (fObjectHeightList[i] / 2));
                        fEndX = (float)Math.Ceiling(fObjectCenterXList[i] + (fObjectWidthList[i] / 2));
                        fEndY = (float)Math.Ceiling(fObjectCenterYList[i] + (fObjectHeightList[i] / 2));

                        // convert width and height to mm
                        fWidthMM = fObjectWidthList[i] / m_fMMToPixelXValue;
                        fHeightMM = fObjectHeightList[i] / m_fMMToPixelYValue; // 11-04-2019 ZJYEOH : Changed m_fMMToPixelXValue to m_fMMToPixelYValue
                        fAreaInMM = fObjectAreaList[i] / m_fMMToPixelXValue / m_fMMToPixelYValue;

                        ColorDefect objDefect = new ColorDefect();

                        objDefect.ref_strName = m_arrDefectColorThresName[intColorThresIndex];
                        objDefect.ref_intFailMask = intFailMask;
                        objDefect.ref_fCenterX = objThresholdSampleROI.ref_ROITotalX + fObjectCenterXList[i];
                        objDefect.ref_fCenterY = objThresholdSampleROI.ref_ROITotalY + fObjectCenterYList[i];
                        objDefect.ref_fStartX = objThresholdSampleROI.ref_ROITotalX + fStartX;
                        objDefect.ref_fStartY = objThresholdSampleROI.ref_ROITotalY + fStartY;
                        objDefect.ref_fEndX = objThresholdSampleROI.ref_ROITotalX + fEndX;
                        objDefect.ref_fEndY = objThresholdSampleROI.ref_ROITotalY + fEndY;
                        objDefect.ref_fWidth = fObjectWidthList[i];
                        objDefect.ref_fHeight = fObjectHeightList[i];
                        objDefect.ref_fArea = fObjectAreaList[i];
                        objDefect.ref_fAngle = fObjectAngleList[i];
                        objDefect.ref_fWidthInMM = fWidthMM;
                        objDefect.ref_fHeightInMM = fHeightMM;
                        objDefect.ref_fAreaInMM2 = fAreaInMM;
                        objDefect.ref_intImageNo = m_arrDefectImageNo[intColorThresIndex] + 1;

                        if (blnCheckLength)
                        {
                            if (m_arrDefectColorInspectionFailCondition[intColorThresIndex] == 0)
                            {
                                if (fWidthMM > m_arrDefectColorInspectionWidth[intColorThresIndex])
                                {
                                    m_intFailColorResultMask |= intFailMask;

                                    blnOverallResult = false;
                                    objDefect.ref_fWidthFailValue = fWidthMM;
                                    objDefect.ref_intFailCriteria |= 0x01;
                                    blnResult = false;
                                    m_strErrorMessage += "* " + objDefect.ref_strName + " Width Fail. Set = " + m_arrDefectColorInspectionWidth[intColorThresIndex].ToString("f5") + " mm,   Result = " + fWidthMM.ToString("f5") + " mm";
                                }
                                if (fHeightMM > m_arrDefectColorInspectionLength[intColorThresIndex])
                                {
                                    m_intFailColorResultMask |= intFailMask;

                                    blnOverallResult = false;
                                    objDefect.ref_fHeightFailValue = fHeightMM;
                                    objDefect.ref_intFailCriteria |= 0x02;
                                    blnResult = false;
                                    m_strErrorMessage += "* " + objDefect.ref_strName + " Length Fail. Set = " + m_arrDefectColorInspectionLength[intColorThresIndex].ToString("f5") + " mm,   Result = " + fHeightMM.ToString("f5") + " mm";
                                }
                            }
                            else
                            {
                                if ((fWidthMM > m_arrDefectColorInspectionWidth[intColorThresIndex]) && (fHeightMM > m_arrDefectColorInspectionLength[intColorThresIndex]))
                                {
                                    m_intFailColorResultMask |= intFailMask;

                                    blnOverallResult = false;
                                    objDefect.ref_fWidthFailValue = fWidthMM;
                                    objDefect.ref_fHeightFailValue = fHeightMM;
                                    objDefect.ref_intFailCriteria |= 0x01;
                                    objDefect.ref_intFailCriteria |= 0x02;
                                    blnResult = false;
                                    m_strErrorMessage += "* " + objDefect.ref_strName + " Width Fail. Set = " + m_arrDefectColorInspectionWidth[intColorThresIndex].ToString("f5") + " mm,   Result = " + fWidthMM.ToString("f5") + " mm";
                                    m_strErrorMessage += "* " + objDefect.ref_strName + " Length Fail. Set = " + m_arrDefectColorInspectionLength[intColorThresIndex].ToString("f5") + " mm,   Result = " + fHeightMM.ToString("f5") + " mm";
                                }
                            }
                        }

                        if (blnCheckArea)
                        {
                            if (/*fAreaInMM < m_arrDefectColorInspectionMinArea[intColorThresIndex] ||*/ fAreaInMM > m_arrDefectColorInspectionMaxArea[intColorThresIndex])
                            {
                                m_intFailColorResultMask |= intFailMask;

                                blnOverallResult = false;
                                objDefect.ref_fAreaFailValue = fAreaInMM;
                                objDefect.ref_intFailCriteria |= 0x04;
                                blnResult = false;
                                m_strErrorMessage += "* " + objDefect.ref_strName + " Area Fail. Set = " + m_arrDefectColorInspectionMaxArea[intColorThresIndex].ToString("f5") + " mm^2,   Result = " + fAreaInMM.ToString("f5") + " mm^2";
                            }
                        }

                        m_arrColorDefectList.Add(objDefect);
                    }

                    if (blnCheckArea)
                    {
                        fAreaInMM = intObjectTotalArea / m_fMMToPixelXValue / m_fMMToPixelYValue;

                        if (fAreaInMM > m_arrDefectColorInspectionTotalArea[intColorThresIndex])
                        {
                            ColorDefect objDefect = new ColorDefect();

                            objDefect.ref_strName = "Total " + m_arrDefectColorThresName[intColorThresIndex];
                            objDefect.ref_intFailMask = intFailMask;
                            objDefect.ref_fCenterX = -1;
                            objDefect.ref_fCenterY = -1;
                            objDefect.ref_fStartX = -1;
                            objDefect.ref_fStartY = -1;
                            objDefect.ref_fEndX = -1;
                            objDefect.ref_fEndY = -1;
                            objDefect.ref_fWidth = -1;
                            objDefect.ref_fHeight = -1;
                            objDefect.ref_fArea = intObjectTotalArea;
                            objDefect.ref_fWidthInMM = -1;
                            objDefect.ref_fHeightInMM = -1;
                            objDefect.ref_fAreaInMM2 = fAreaInMM;
                            objDefect.ref_intImageNo = m_arrDefectImageNo[intColorThresIndex] + 1;
                            objDefect.ref_blnFailTotalArea = true;

                            blnOverallResult = false;
                            objDefect.ref_fAreaFailValue = fAreaInMM;
                            objDefect.ref_intFailCriteria |= 0x08;

                            m_arrColorDefectList.Add(objDefect);

                            m_intFailColorResultMask |= intFailMask;

                            m_strErrorMessage += "* " + objDefect.ref_strName + " Area Fail. Set = " + m_arrDefectColorInspectionTotalArea[intColorThresIndex].ToString("f5") + " mm^2,   Result = " + fAreaInMM.ToString("f5") + " mm^2";

                            for (int b = 0; b < m_arrColorDefectList.Count; b++)
                            {
                                if (((ColorDefect)m_arrColorDefectList[b]).ref_strName == m_arrDefectColorThresName[intColorThresIndex])
                                {
                                    if (!((ColorDefect)m_arrColorDefectList[b]).ref_blnFailTotalArea)
                                    {
                                        ColorDefect objDefect2 = m_arrColorDefectList[b];
                                        objDefect2.ref_blnFailTotalArea = true;
                                        m_arrColorDefectList.RemoveAt(b);
                                        m_arrColorDefectList.Insert(b, objDefect2);
                                    }
                                }
                            }

                            blnResult = false;
                        }

                    }
                }
            }
            objThresholdSampleROI.Dispose();
            objThresholdSampleROI_Temp.Dispose();
            objImageTemp.Dispose();
            objImageTemp2.Dispose();
            return blnResult;
        }
        public void SubtractColorDontCareImage(ROI objResultROI, int intDontCareMode, ImageDrawing objPadColorDontCareImage)
        {
            if (intDontCareMode != 3)
                return;
            //ROI objROI2 = new ROI();
            //objROI2.LoadROISetting(objROI.ref_ROITotalX, objROI.ref_ROITotalY, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
            //ImageDrawing objImage = new ImageDrawing(objROI.ref_ROI.TopParent.Width, objROI.ref_ROI.TopParent.Height);
            //EasyImage.Copy(objROI.ref_ROI.TopParent, objImage.ref_objMainImage);
            //objROI2.AttachImage(objImage);

            //EasyImage.Threshold(objROI2.ref_ROI, objROI2.ref_ROI, m_intThresholdValue);
            //if (!blnPadChecked)
            //{
            //    EasyImage.Oper(EArithmeticLogicOperation.Invert, objROI2.ref_ROI, objROI2.ref_ROI);
            //}

            //EasyImage.Oper(EArithmeticLogicOperation.Multiply, objResultROI.ref_ROI, objROI2.ref_ROI, objResultROI.ref_ROI);

            //objROI2.Dispose();
            //objImage.Dispose();
            bool blnDebugImage = false;

            if (blnDebugImage)
            {
                if (objPadColorDontCareImage != null)
                    objPadColorDontCareImage.SaveImage("D:\\TS\\objPadColorDontCareImage.bmp");
            }

            if (objPadColorDontCareImage != null)
            {
                ROI objDontCareROI = new ROI();
                objDontCareROI.LoadROISetting(0, 0, objResultROI.ref_ROIWidth, objResultROI.ref_ROIHeight);
                objDontCareROI.AttachImage(objPadColorDontCareImage);
                ROI.SubtractROI(objResultROI, objDontCareROI);
                objDontCareROI.Dispose();
            }
            //if (blnDebugImage)
            //    objThresholdSampleROI.SaveImage("D:\\TS\\14_AfSBSampleROI.bmp");// debug

            if (blnDebugImage)
            {
                if (objPadColorDontCareImage != null)
                    objResultROI.SaveImage("D:\\TS\\16_objResultROI.bmp");
            }

        }
        public void SubtractColorDontCareImage(ROI objResultROI, int intDontCareMode, ImageDrawing objPadColorDontCareImage, ImageDrawing objWhiteImage, ImageDrawing objBlackImage, List<int> arrStartX, List<int> arrStartY, List<int> arrEndX, List<int> arrEndY)
        {
            if (intDontCareMode == 0)
                return;
            //ROI objROI2 = new ROI();
            //objROI2.LoadROISetting(objROI.ref_ROITotalX, objROI.ref_ROITotalY, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
            //ImageDrawing objImage = new ImageDrawing(objROI.ref_ROI.TopParent.Width, objROI.ref_ROI.TopParent.Height);
            //EasyImage.Copy(objROI.ref_ROI.TopParent, objImage.ref_objMainImage);
            //objROI2.AttachImage(objImage);

            //EasyImage.Threshold(objROI2.ref_ROI, objROI2.ref_ROI, m_intThresholdValue);
            //if (!blnPadChecked)
            //{
            //    EasyImage.Oper(EArithmeticLogicOperation.Invert, objROI2.ref_ROI, objROI2.ref_ROI);
            //}

            //EasyImage.Oper(EArithmeticLogicOperation.Multiply, objResultROI.ref_ROI, objROI2.ref_ROI, objResultROI.ref_ROI);

            //objROI2.Dispose();
            //objImage.Dispose();
            bool blnDebugImage = false;

            if (blnDebugImage)
            {
                if (objPadColorDontCareImage != null)
                    objPadColorDontCareImage.SaveImage("D:\\TS\\objPadColorDontCareImage.bmp");
            }

            if (objPadColorDontCareImage != null)
            {
                if (intDontCareMode == 3)
                {
                    ROI objDontCareROI = new ROI();
                    objDontCareROI.LoadROISetting(0, 0, objResultROI.ref_ROIWidth, objResultROI.ref_ROIHeight);
                    objDontCareROI.AttachImage(objPadColorDontCareImage);
                    ROI.SubtractROI(objResultROI, objDontCareROI);
                    objDontCareROI.Dispose();
                }
                else
                {
                    ImageDrawing objDontCareImage = new ImageDrawing();
                    objBlackImage.CopyTo(objDontCareImage);
                    ROI objDontCareROI = new ROI();
                    objDontCareROI.LoadROISetting(objResultROI.ref_ROITotalX, objResultROI.ref_ROITotalY, objResultROI.ref_ROIWidth, objResultROI.ref_ROIHeight);
                    objDontCareROI.AttachImage(objDontCareImage);
                    for (int i = 0; i < arrStartX.Count; i++)
                    {
                        Shape.FillRectangle(objDontCareImage, arrStartX[i], arrStartY[i], arrEndX[i], arrEndY[i], 255);
                    }
                    
                    if (intDontCareMode == 2)
                    {
                        EasyImage.Oper(EArithmeticLogicOperation.Invert, objDontCareImage.ref_objMainImage, objDontCareImage.ref_objMainImage);
                    }

                    if (blnDebugImage)
                    {
                        objResultROI.SaveImage("D:\\TS\\objResultROI.bmp");
                        objDontCareROI.SaveImage("D:\\TS\\objDontCareROI.bmp");
                        objDontCareImage.SaveImage("D:\\TS\\objDontCareImage.bmp");
                    }

                    ROI.SubtractROI(objResultROI, objDontCareROI);
                    objDontCareImage.Dispose();
                    objDontCareROI.Dispose();
                }
            }

            //if (blnDebugImage)
            //    objThresholdSampleROI.SaveImage("D:\\TS\\14_AfSBSampleROI.bmp");// debug

            if (blnDebugImage)
            {
                objResultROI.SaveImage("D:\\TS\\16_objResultROI.bmp");
            }

        }
        public void SubtractColorDontCareImage_Learn(ROI objResultROI, int intDontCareMode, ImageDrawing objPadColorDontCareImage, ImageDrawing objBlackImage, List<int> arrStartX, List<int> arrStartY, List<int> arrEndX, List<int> arrEndY, CROI objPkgROI)
        {
            if (intDontCareMode == 0)
                return;
            //ROI objROI2 = new ROI();
            //objROI2.LoadROISetting(objROI.ref_ROITotalX, objROI.ref_ROITotalY, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
            //ImageDrawing objImage = new ImageDrawing(objROI.ref_ROI.TopParent.Width, objROI.ref_ROI.TopParent.Height);
            //EasyImage.Copy(objROI.ref_ROI.TopParent, objImage.ref_objMainImage);
            //objROI2.AttachImage(objImage);

            //EasyImage.Threshold(objROI2.ref_ROI, objROI2.ref_ROI, m_intThresholdValue);
            //if (!blnPadChecked)
            //{
            //    EasyImage.Oper(EArithmeticLogicOperation.Invert, objROI2.ref_ROI, objROI2.ref_ROI);
            //}

            //EasyImage.Oper(EArithmeticLogicOperation.Multiply, objResultROI.ref_ROI, objROI2.ref_ROI, objResultROI.ref_ROI);

            //objROI2.Dispose();
            //objImage.Dispose();
            bool blnDebugImage = false;

            if (blnDebugImage)
            {
                if (objPadColorDontCareImage != null)
                    objPadColorDontCareImage.SaveImage("D:\\TS\\objPadColorDontCareImage.bmp");
            }

            if (objPadColorDontCareImage != null)
            {
                if (intDontCareMode == 3)
                {
                    ROI objDontCareROI = new ROI();
                    objDontCareROI.LoadROISetting(0, 0, objResultROI.ref_ROIWidth, objResultROI.ref_ROIHeight);
                    objDontCareROI.AttachImage(objPadColorDontCareImage);
                    ROI.SubtractROI(objResultROI, objDontCareROI);
                    objDontCareROI.Dispose();
                }
                else
                {
                    ImageDrawing objDontCareImage = new ImageDrawing();
                    objBlackImage.CopyTo(objDontCareImage);
                    ROI objDontCareROI = new ROI();
                    objDontCareROI.LoadROISetting(objPkgROI.ref_ROITotalX, objPkgROI.ref_ROITotalY, objPkgROI.ref_ROIWidth, objPkgROI.ref_ROIHeight);
                    objDontCareROI.AttachImage(objDontCareImage);
                    for (int i = 0; i < arrStartX.Count; i++)
                    {
                        Shape.FillRectangle(objDontCareImage, arrStartX[i], arrStartY[i], arrEndX[i], arrEndY[i], 255);
                    }

                    if (intDontCareMode == 2)
                    {
                        EasyImage.Oper(EArithmeticLogicOperation.Invert, objDontCareImage.ref_objMainImage, objDontCareImage.ref_objMainImage);
                    }

                    if (blnDebugImage)
                    {
                        objResultROI.SaveImage("D:\\TS\\objResultROI.bmp");
                        objDontCareImage.SaveImage("D:\\TS\\objDontCareImage.bmp");
                        objDontCareROI.SaveImage("D:\\TS\\objDontCareROI.bmp");
                    }

                    ROI.SubtractROI(objResultROI, objDontCareROI);
                    objDontCareImage.Dispose();
                    objDontCareROI.Dispose();
                }
            }

            //if (blnDebugImage)
            //    objThresholdSampleROI.SaveImage("D:\\TS\\14_AfSBSampleROI.bmp");// debug

            if (blnDebugImage)
            {
                objResultROI.SaveImage("D:\\TS\\16_objResultROI.bmp");
            }

        }
        public void LoadColorDontCareImage(string strFolderPath, int intVisionIndex)
        {
            for (int i = 0; i < m_arrDefectColorThresName.Count; i++)
            {
                if (File.Exists(strFolderPath + "ColorDontCareImage" + intVisionIndex.ToString() + "_" + i.ToString() + ".bmp"))
                    m_arrPackageColorDontCareImage[i].LoadImage(strFolderPath + "ColorDontCareImage" + intVisionIndex.ToString() + "_" + i.ToString() + ".bmp");
            }

        }
        public int GetColorDefectCount(ref List<int> arrColorDefectSkipNo)
        {
            int intCount = m_arrDefectColorThresName.Count;
            arrColorDefectSkipNo = new List<int>();
            for (int i = 0; i < m_arrDefectColorThresName.Count; i++)
            {
                if (!arrColorDefectSkipNo.Contains(i))
                {
                    for (int j = 0; j < m_arrDefectColorThresName.Count; j++)
                    {
                        if (i == j)
                            continue;

                        if (m_arrDefectColorThresName[i] == m_arrDefectColorThresName[j])
                        {
                            if (!arrColorDefectSkipNo.Contains(j))
                                arrColorDefectSkipNo.Add(j);

                        }
                    }
                }
            }

            return intCount - arrColorDefectSkipNo.Count;
        }
        public void SwapColorDefect(int intFrom, int intTo)
        {
            string arrDefectColorThresName = m_arrDefectColorThresName[intTo];
            int arrDefectColorSystem = m_arrDefectColorSystem[intTo];
            int arrDefectCloseIteration = m_arrDefectCloseIteration[intTo];
            bool arrDefectInvertBlackWhite = m_arrDefectInvertBlackWhite[intTo];
            int[] arrDefectColor = m_arrDefectColor[intTo];
            int[] arrDefectColorTolerance = m_arrDefectColorTolerance[intTo];
            int arrDefectColorMinArea = m_arrDefectColorMinArea[intTo];
            int arrDefectType = m_arrDefectType[intTo];
            int arrDefectImageNo = m_arrDefectImageNo[intTo];
            int arrDefectDontCareMode = m_arrDefectDontCareMode[intTo];
            int arrDefectColorInspection_Top = m_arrDefectColorInspection_Top[intTo];
            int arrDefectColorInspection_Right = m_arrDefectColorInspection_Right[intTo];
            int arrDefectColorInspection_Bottom = m_arrDefectColorInspection_Bottom[intTo];
            int arrDefectColorInspection_Left = m_arrDefectColorInspection_Left[intTo];
            int arrDefectColorInspectionFailCondition = m_arrDefectColorInspectionFailCondition[intTo];
            float arrDefectColorInspectionWidth = m_arrDefectColorInspectionWidth[intTo];
            float arrDefectColorInspectionLength = m_arrDefectColorInspectionLength[intTo];
            float arrDefectColorInspectionMinArea = m_arrDefectColorInspectionMinArea[intTo];
            float arrDefectColorInspectionMaxArea = m_arrDefectColorInspectionMaxArea[intTo];
            float arrDefectColorInspectionTotalArea = m_arrDefectColorInspectionTotalArea[intTo];

            m_arrDefectColorThresName[intTo] = m_arrDefectColorThresName[intFrom];
            m_arrDefectColorSystem[intTo] = m_arrDefectColorSystem[intFrom];
            m_arrDefectCloseIteration[intTo] = m_arrDefectCloseIteration[intFrom];
            m_arrDefectInvertBlackWhite[intTo] = m_arrDefectInvertBlackWhite[intFrom];
            m_arrDefectColor[intTo] = m_arrDefectColor[intFrom];
            m_arrDefectColorTolerance[intTo] = m_arrDefectColorTolerance[intFrom];
            m_arrDefectColorMinArea[intTo] = m_arrDefectColorMinArea[intFrom];
            m_arrDefectType[intTo] = m_arrDefectType[intFrom];
            m_arrDefectImageNo[intTo] = m_arrDefectImageNo[intFrom];
            m_arrDefectDontCareMode[intTo] = m_arrDefectDontCareMode[intFrom];
            m_arrDefectColorInspection_Top[intTo] = m_arrDefectColorInspection_Top[intFrom];
            m_arrDefectColorInspection_Right[intTo] = m_arrDefectColorInspection_Right[intFrom];
            m_arrDefectColorInspection_Bottom[intTo] = m_arrDefectColorInspection_Bottom[intFrom];
            m_arrDefectColorInspection_Left[intTo] = m_arrDefectColorInspection_Left[intFrom];
            m_arrDefectColorInspectionFailCondition[intTo] = m_arrDefectColorInspectionFailCondition[intFrom];
            m_arrDefectColorInspectionWidth[intTo] = m_arrDefectColorInspectionWidth[intFrom];
            m_arrDefectColorInspectionLength[intTo] = m_arrDefectColorInspectionLength[intFrom];
            m_arrDefectColorInspectionMinArea[intTo] = m_arrDefectColorInspectionMinArea[intFrom];
            m_arrDefectColorInspectionMaxArea[intTo] = m_arrDefectColorInspectionMaxArea[intFrom];
            m_arrDefectColorInspectionTotalArea[intTo] = m_arrDefectColorInspectionTotalArea[intFrom];

            m_arrDefectColorThresName[intFrom] = arrDefectColorThresName;
            m_arrDefectColorSystem[intFrom] = arrDefectColorSystem;
            m_arrDefectCloseIteration[intFrom] = arrDefectCloseIteration;
            m_arrDefectInvertBlackWhite[intFrom] = arrDefectInvertBlackWhite;
            m_arrDefectColor[intFrom] = arrDefectColor;
            m_arrDefectColorTolerance[intFrom] = arrDefectColorTolerance;
            m_arrDefectColorMinArea[intFrom] = arrDefectColorMinArea;
            m_arrDefectType[intFrom] = arrDefectType;
            m_arrDefectImageNo[intFrom] = arrDefectImageNo;
            m_arrDefectDontCareMode[intFrom] = arrDefectDontCareMode;
            m_arrDefectColorInspection_Top[intFrom] = arrDefectColorInspection_Top;
            m_arrDefectColorInspection_Right[intFrom] = arrDefectColorInspection_Right;
            m_arrDefectColorInspection_Bottom[intFrom] = arrDefectColorInspection_Bottom;
            m_arrDefectColorInspection_Left[intFrom] = arrDefectColorInspection_Left;
            m_arrDefectColorInspectionFailCondition[intFrom] = arrDefectColorInspectionFailCondition;
            m_arrDefectColorInspectionWidth[intFrom] = arrDefectColorInspectionWidth;
            m_arrDefectColorInspectionLength[intFrom] = arrDefectColorInspectionLength;
            m_arrDefectColorInspectionMinArea[intFrom] = arrDefectColorInspectionMinArea;
            m_arrDefectColorInspectionMaxArea[intFrom] = arrDefectColorInspectionMaxArea;
            m_arrDefectColorInspectionTotalArea[intFrom] = arrDefectColorInspectionTotalArea;

        }
    }
}
